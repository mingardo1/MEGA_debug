<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>444</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    444
                    <a href="443.html">prev</a>
                    <a href="445.html">next</a>
                    <a href="444_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_5553ee5c6410a412ab4ed61d9499805adee8995a_core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^1:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5553ee5c6410a412ab4ed61d9499805adee8995a^2:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e0a10435dcb243a911c0405daebc6aa667d5119d:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [bj], [b]], subset: [[b], [bj], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.format.dtnest;
  20 
  21 import com.dtstack.flink.sql.table.AbstractTableInfo;
  22 import com.google.common.base.Strings;
  23 import com.google.common.collect.Maps;
  24 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25 import org.apache.flink.api.common.typeinfo.TypeInformation;
  26 import org.apache.flink.api.common.typeinfo.Types;
  27 import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
  28 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  29 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  30 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  31 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  32 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  33 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  34 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  35 import org.apache.flink.types.Row;
  36 
  37 import java.io.IOException;
  38 import java.lang.reflect.Array;
  39 import java.sql.Date;
  40 import java.sql.Time;
  41 import java.sql.Timestamp;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.Map;
  45 
  46 /**
  47  * source data parse to json format
  48  * &lt;p&gt;
  49  * Date: 2019/12/12
  50  * Company: www.dtstack.com
  51  *
  52  * @author maqi
  53  */
  54 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  55 
  56     private final ObjectMapper objectMapper = new ObjectMapper();
  57 
  58     private final Map&lt;String, String&gt; rowAndFieldMapping;
  59     private final Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  60 
  61     private final String[] fieldNames;
  62     private final TypeInformation&lt;?&gt;[] fieldTypes;
  63 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  64     private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  65     private TypeInformation&lt;Row&gt; typeInfo;</span>
  66 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  67     private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  68 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  69     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  69     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  70         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
  71 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  72     private final List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  73     private final String charsetName;</span>
  74 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  75 
  76 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  77     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  77     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78         this.typeInfo = typeInfo;</span>
  79 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82         this.rowAndFieldMapping = rowAndFieldMapping;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83         this.fieldExtraInfos = fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84     }</span>
  85 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  86     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,">  86     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87                                           List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  88                                           String charsetName) {</span>
  89 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  90         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  91         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  92         this.rowAndFieldMapping = rowAndFieldMapping;
  93         this.fieldExtraInfos = fieldExtraInfos;
  94         this.charsetName = charsetName;
  95     }
  96 
  97     @Override
  98     public Row deserialize(byte[] message) throws IOException {
  99         String decoderStr = new String(message, charsetName);
 100         JsonNode root = objectMapper.readTree(decoderStr);
 101         this.parseTree(root, null);
 102         return convertTopRow();
 103     }
 104 
 105     private void parseTree(JsonNode jsonNode, String prefix) {
 106         if (jsonNode.isArray()) {
 107             ArrayNode array = (ArrayNode) jsonNode;
 108             for (int i = 0; i &lt; array.size(); i++) {
 109                 JsonNode child = array.get(i);
 110                 String nodeKey = getNodeKey(prefix, i);
 111 
 112                 if (child.isValueNode()) {
 113                     nodeAndJsonNodeMapping.put(nodeKey, child);
 114                 } else {
 115                     if (rowAndFieldMapping.containsValue(nodeKey)) {
 116                         nodeAndJsonNodeMapping.put(nodeKey, child);
 117                     }
 118                     parseTree(child, nodeKey);
 119                 }
 120             }
 121             return;
 122         }
 123         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 124         while (iterator.hasNext()) {
 125             String next = iterator.next();
 126             JsonNode child = jsonNode.get(next);
 127             String nodeKey = getNodeKey(prefix, next);
 128 
 129             nodeAndJsonNodeMapping.put(nodeKey, child);
 130             if (child.isArray()) {
 131                 parseTree(child, nodeKey);
 132             } else {
 133                 parseTree(child, nodeKey);
 134             }
 135         }
 136     }
 137 
 138     private JsonNode getIgnoreCase(String key) {
 139         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 140         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 141     }
 142 
 143     private String getNodeKey(String prefix, String nodeName) {
 144         if (Strings.isNullOrEmpty(prefix)) {
 145             return nodeName;
 146         }
 147         return prefix + &quot;.&quot; + nodeName;
 148     }
 149 
 150     private String getNodeKey(String prefix, int i) {
 151         if (Strings.isNullOrEmpty(prefix)) {
 152             return &quot;[&quot; + i + &quot;]&quot;;
 153         }
 154         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 155     }
 156 
 157     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 158         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 159             return node.asBoolean();
 160         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 161             if (node instanceof ObjectNode) {
 162                 return node.toString();
 163             } else if (node instanceof NullNode) {
 164                 return null;
 165             } else {
 166                 return node.asText();
 167             }
 168         } else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 169             return Date.valueOf(node.asText());
 170         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 171             // local zone
 172             return Time.valueOf(node.asText());
 173         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 174             // local zone
 175             return Timestamp.valueOf(node.asText());
 176         }  else if (info instanceof RowTypeInfo) {
 177             return convertRow(node, (RowTypeInfo) info);
 178         } else if (info instanceof ObjectArrayTypeInfo) {
 179             return convertObjectArray(node, ((ObjectArrayTypeInfo) info).getComponentInfo());
 180         } else {
 181             // for types that were specified without JSON schema
 182             // e.g. POJOs
 183             try {
 184                 return objectMapper.treeToValue(node, info.getTypeClass());
 185             } catch (JsonProcessingException e) {
<abbr title=" 186                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);"> 186                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; ðŸ”µ</abbr>
 187             }
 188         }
 189     }
 190 
 191 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 192     @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 193     public TypeInformation&lt;Row&gt; getProducedType() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 194         return typeInfo;</span>
 195 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196             return Timestamp.valueOf(node.asText());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197         }  else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198             // for types that were specified without JSON schema</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199             // e.g. POJOs</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201                 return objectMapper.treeToValue(node, info.getTypeClass());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 202             } catch (JsonProcessingException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 203                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);"> 203                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208 </span>
 209 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 210     private Row convertTopRow() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 211         Row row = new Row(fieldNames.length);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213             for (int i = 0; i &lt; fieldNames.length; i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 214                 JsonNode node = getIgnoreCase(fieldNames[i]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 215                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 216 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 217                 if (node == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 218                     if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 219                         throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 220                             + fieldNames[i] + &quot;&#x27;.&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 221                     } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222                         row.setField(i, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224                 } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225                     // Read the value as specified type</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226                     Object value = convert(node, fieldTypes[i]);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 227                     row.setField(i, value);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 230             return row;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 231         } finally {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 232             nodeAndJsonNodeMapping.clear();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 233         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 234     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 235 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 236     private Row convertRow(JsonNode node, RowTypeInfo info) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 237         final String[] names = info.getFieldNames();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 238         final TypeInformation&lt;?&gt;[] types = info.getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 239 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 240         final Row row = new Row(names.length);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 241         for (int i = 0; i &lt; names.length; i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 242             final String name = names[i];</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 243             final JsonNode subNode = node.get(name);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 244             if (subNode == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 245                 row.setField(i, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 246             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 247                 row.setField(i, convert(subNode, types[i]));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 248             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 249         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 250 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 251         return row;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 252     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 253 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 254     private Object convertObjectArray(JsonNode node, TypeInformation&lt;?&gt; elementType) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 255         final Object[] array = (Object[]) Array.newInstance(elementType.getTypeClass(), node.size());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 256         for (int i = 0; i &lt; node.size(); i++) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 257             array[i] = convert(node.get(i), elementType);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 258         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 259         return array;</span>
 260 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 261     }
 262 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.format.dtnest;
  20 
  21 import com.dtstack.flink.sql.table.AbstractTableInfo;
  22 import com.google.common.base.Strings;
  23 import com.google.common.collect.Maps;
  24 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25 import org.apache.flink.api.common.typeinfo.TypeInformation;
  26 import org.apache.flink.api.common.typeinfo.Types;
  27 import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
  28 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  29 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  30 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  31 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  32 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  33 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  34 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  35 import org.apache.flink.types.Row;
  36 
  37 import java.io.IOException;
  38 import java.lang.reflect.Array;
  39 import java.sql.Date;
  40 import java.sql.Time;
  41 import java.sql.Timestamp;
  42 import java.util.Iterator;
  43 import java.util.List;
  44 import java.util.Map;
  45 
  46 /**
  47  * source data parse to json format
  48  * &lt;p&gt;
  49  * Date: 2019/12/12
  50  * Company: www.dtstack.com
  51  *
  52  * @author maqi
  53  */
  54 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  55 
  56     private final ObjectMapper objectMapper = new ObjectMapper();
  57 
  58     private final Map&lt;String, String&gt; rowAndFieldMapping;
  59     private final Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  60 
  61     private final String[] fieldNames;
  62     private final TypeInformation&lt;?&gt;[] fieldTypes;
  63     private final List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;
  64     private TypeInformation&lt;Row&gt; typeInfo;
  65 
  66 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  67 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  67 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMappiðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  68         this.typeInfo = typeInfo;</span>
  69 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  70 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  70 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMappiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  71         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  72         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
  73 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  74 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,">  74 public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMappiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  75                                           List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  76                                           String charsetName) {</span>
  77 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
  78         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  79         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  80         this.rowAndFieldMapping = rowAndFieldMapping;
  81         this.fieldExtraInfos = fieldExtraInfos;
  82         this.charsetName = charsetName;
  83     }
  84     private final String charsetName;
  85 
  86     @Override
  87     public Row deserialize(byte[] message) throws IOException {
  88         String decoderStr = new String(message, charsetName);
  89         JsonNode root = objectMapper.readTree(decoderStr);
  90         this.parseTree(root, null);
  91         return convertTopRow();
  92     }
  93 
  94     private void parseTree(JsonNode jsonNode, String prefix){
  95         if (jsonNode.isArray()) {
  96             ArrayNode array = (ArrayNode) jsonNode;
  97             for (int i = 0; i &lt; array.size(); i++) {
  98                 JsonNode child = array.get(i);
  99                 String nodeKey = getNodeKey(prefix, i);
 100 
 101                 if (child.isValueNode()) {
 102                     nodeAndJsonNodeMapping.put(nodeKey, child);
 103                 } else {
 104                     if (rowAndFieldMapping.containsValue(nodeKey)) {
 105                         nodeAndJsonNodeMapping.put(nodeKey, child);
 106                     }
 107                     parseTree(child, nodeKey);
 108                 }
 109             }
 110             return;
 111         }
 112         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 113         while (iterator.hasNext()){
 114             String next = iterator.next();
 115             JsonNode child = jsonNode.get(next);
 116             String nodeKey = getNodeKey(prefix, next);
 117 
 118             nodeAndJsonNodeMapping.put(nodeKey, child);
 119             if(child.isArray()){
 120                 parseTree(child, nodeKey);
 121             }else {
 122                 parseTree(child, nodeKey);
 123             }
 124         }
 125     }
 126 
 127     private JsonNode getIgnoreCase(String key) {
 128         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 129         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 130     }
 131 
 132     private String getNodeKey(String prefix, String nodeName){
 133         if(Strings.isNullOrEmpty(prefix)){
 134             return nodeName;
 135         }
 136         return prefix + &quot;.&quot; + nodeName;
 137     }
 138 
 139     private String getNodeKey(String prefix, int i) {
 140         if (Strings.isNullOrEmpty(prefix)) {
 141             return &quot;[&quot; + i + &quot;]&quot;;
 142         }
 143         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 144     }
 145 
 146     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 147         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 148             return node.asBoolean();
 149         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 150             if (node instanceof ObjectNode) {
 151                 return node.toString();
 152             } else if (node instanceof NullNode) {
 153                 return null;
 154             } else {
 155                 return node.asText();
 156             }
 157         }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 158             return Date.valueOf(node.asText());
 159         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 160             // local zone
 161             return Time.valueOf(node.asText());
 162         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 163             // local zone
 164             return Timestamp.valueOf(node.asText());
 165         }  else if (info instanceof RowTypeInfo) {
 166             return convertRow(node, (RowTypeInfo) info);
 167         } else if (info instanceof ObjectArrayTypeInfo) {
 168             return convertObjectArray(node, ((ObjectArrayTypeInfo) info).getComponentInfo());
 169         }  else {
 170             // for types that were specified without JSON schema
 171             // e.g. POJOs
 172             try {
 173                 return objectMapper.treeToValue(node, info.getTypeClass());
 174             } catch (JsonProcessingException e) {
<abbr title=" 175                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);"> 175                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; ðŸ”µ</abbr>
 176             }
 177         }
 178     }
 179 
 180     @Override
 181     public TypeInformation&lt;Row&gt; getProducedType() {
 182         return typeInfo;
 183     }
 184 
 185     private Row convertTopRow() {
 186         Row row = new Row(fieldNames.length);
 187         try {
 188             for (int i = 0; i &lt; fieldNames.length; i++) {
 189                 JsonNode node = getIgnoreCase(fieldNames[i]);
 190                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
 191 
 192                 if (node == null) {
 193                     if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
 194                         throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
 195                             + fieldNames[i] + &quot;&#x27;.&quot;);
 196                     } else {
 197                         row.setField(i, null);
 198                     }
 199                 } else {
 200                     // Read the value as specified type
 201                     Object value = convert(node, fieldTypes[i]);
 202                     row.setField(i, value);
 203                 }
 204             }
 205             return row;
 206         } finally {
 207             nodeAndJsonNodeMapping.clear();
 208         }
 209     }
 210 
 211     private Row convertRow(JsonNode node, RowTypeInfo info) {
 212         final String[] names = info.getFieldNames();
 213         final TypeInformation&lt;?&gt;[] types = info.getFieldTypes();
 214 
 215         final Row row = new Row(names.length);
 216         for (int i = 0; i &lt; names.length; i++) {
 217             final String name = names[i];
 218             final JsonNode subNode = node.get(name);
 219             if (subNode == null) {
 220                 row.setField(i, null);
 221             } else {
 222                 row.setField(i, convert(subNode, types[i]));
 223             }
 224         }
 225 
 226         return row;
 227     }
 228 
 229     private Object convertObjectArray(JsonNode node, TypeInformation&lt;?&gt; elementType) {
 230         final Object[] array = (Object[]) Array.newInstance(elementType.getTypeClass(), node.size());
 231         for (int i = 0; i &lt; node.size(); i++) {
 232             array[i] = convert(node.get(i), elementType);
 233         }
 234         return array;
 235     }
 236 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.format.dtnest;
  19 
  20 import com.dtstack.flink.sql.table.AbstractTableInfo;
  21 import com.google.common.base.Strings;
  22 import com.google.common.collect.Maps;
  23 import java.io.IOException;
  24 import java.lang.reflect.Array;
  25 import java.sql.Date;
  26 import java.sql.Time;
  27 import java.sql.Timestamp;
  28 import java.util.Iterator;
  29 import java.util.List;
  30 import java.util.Map;
  31 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  32 import org.apache.flink.api.common.typeinfo.TypeInformation;
  33 import org.apache.flink.api.common.typeinfo.Types;
  34 import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;
  35 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  36 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  37 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  38 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  39 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  40 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  41 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  42 import org.apache.flink.types.Row;
  43 
  44 
  45 /**
  46  * source data parse to json format
  47  * &lt;p&gt;
  48  * Date: 2019/12/12
  49  * Company: www.dtstack.com
  50  *
  51  * @author maqi
  52  */
  53 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  54     private final ObjectMapper objectMapper = new ObjectMapper();
  55 
  56     private final Map&lt;String, String&gt; rowAndFieldMapping;
  57 
  58     private final Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  59 
  60     private final String[] fieldNames;
  61 
  62     private final TypeInformation&lt;?&gt;[] fieldTypes;
  63 
  64     private final List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;
  65 
  66     private TypeInformation&lt;Row&gt; typeInfo;
  67 
  68     private final String charsetName;
  69 
<abbr title="  70     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos, String charsetName) {">  70     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr>
  71         this.typeInfo = typeInfo;
  72         this.fieldNames = ((RowTypeInfo) (typeInfo)).getFieldNames();
  73         this.fieldTypes = ((RowTypeInfo) (typeInfo)).getFieldTypes();
  74         this.rowAndFieldMapping = rowAndFieldMapping;
  75         this.fieldExtraInfos = fieldExtraInfos;
  76         this.charsetName = charsetName;
  77     }
  78 
  79     @Override
  80     public Row deserialize(byte[] message) throws IOException {
  81         String decoderStr = new String(message, charsetName);
  82         JsonNode root = objectMapper.readTree(decoderStr);
  83         this.parseTree(root, null);
  84         return convertTopRow();
  85     }
  86 
  87     private void parseTree(JsonNode jsonNode, String prefix){
  88         if (jsonNode.isArray()) {
  89             ArrayNode array = (ArrayNode) jsonNode;
  90             for (int i = 0; i &lt; array.size(); i++) {
  91                 JsonNode child = array.get(i);
  92                 String nodeKey = getNodeKey(prefix, i);
  93 
  94                 if (child.isValueNode()) {
  95                     nodeAndJsonNodeMapping.put(nodeKey, child);
  96                 } else {
  97                     if (rowAndFieldMapping.containsValue(nodeKey)) {
  98                         nodeAndJsonNodeMapping.put(nodeKey, child);
  99                     }
 100                     parseTree(child, nodeKey);
 101                 }
 102             }
 103             return;
 104         }
 105         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 106         while (iterator.hasNext()){
 107             String next = iterator.next();
 108             JsonNode child = jsonNode.get(next);
 109             String nodeKey = getNodeKey(prefix, next);
 110 
 111             nodeAndJsonNodeMapping.put(nodeKey, child);
 112             if(child.isArray()){
 113                 parseTree(child, nodeKey);
 114             }else {
 115                 parseTree(child, nodeKey);
 116             }
 117         }
 118     }
 119 
 120     private JsonNode getIgnoreCase(String key) {
 121         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 122         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 123     }
 124 
 125     private String getNodeKey(String prefix, String nodeName){
 126         if(Strings.isNullOrEmpty(prefix)){
 127             return nodeName;
 128         }
 129         return prefix + &quot;.&quot; + nodeName;
 130     }
 131 
 132     private String getNodeKey(String prefix, int i) {
 133         if (Strings.isNullOrEmpty(prefix)) {
 134             return &quot;[&quot; + i + &quot;]&quot;;
 135         }
 136         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 137     }
 138 
 139     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 140         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 141             return node.asBoolean();
 142         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 143             if (node instanceof ObjectNode) {
 144                 return node.toString();
 145             } else if (node instanceof NullNode) {
 146                 return null;
 147             } else {
 148                 return node.asText();
 149             }
 150         } else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 151             return Date.valueOf(node.asText());
 152         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 153             // local zone
 154             return Time.valueOf(node.asText());
 155         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 156             // local zone
 157             return Timestamp.valueOf(node.asText());
 158         } else if (info instanceof RowTypeInfo) {
 159             return convertRow(node, ((RowTypeInfo) (info)));
 160         } else if (info instanceof ObjectArrayTypeInfo) {
 161             return convertObjectArray(node, ((ObjectArrayTypeInfo) (info)).getComponentInfo());
 162         } else {
 163             // for types that were specified without JSON schema
 164             // e.g. POJOs
 165             try {
 166                 return objectMapper.treeToValue(node, info.getTypeClass());
 167             } catch (JsonProcessingException e) {
<abbr title=" 168                 throw new IllegalStateException(((&quot;Unsupported type information &#x27;&quot; + info) + &quot;&#x27; for node: &quot;) + node);"> 168                 throw new IllegalStateException(((&quot;Unsupported type information &#x27;&quot; + info) + &quot;&#x27; for node:ðŸ”µ</abbr>
 169             }
 170         }
 171     }
 172 
 173     @Override
 174     public TypeInformation&lt;Row&gt; getProducedType() {
 175         return typeInfo;
 176     }
 177 
 178     private Row convertTopRow() {
 179         Row row = new Row(fieldNames.length);
 180         try {
 181             for (int i = 0; i &lt; fieldNames.length; i++) {
 182                 JsonNode node = getIgnoreCase(fieldNames[i]);
 183                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
 184                 if (node == null) {
 185                     if ((fieldExtraInfo != null) &amp;&amp; fieldExtraInfo.getNotNull()) {
<abbr title=" 186                         throw new IllegalStateException((&quot;Failed to find field with name &#x27;&quot; + fieldNames[i]) + &quot;&#x27;.&quot;);"> 186                         throw new IllegalStateException((&quot;Failed to find field with name &#x27;&quot; + fieldNames[ðŸ”µ</abbr>
 187                     } else {
 188                         row.setField(i, null);
 189                     }
 190                 } else {
 191                     // Read the value as specified type
 192                     Object value = convert(node, fieldTypes[i]);
 193                     row.setField(i, value);
 194                 }
 195             }
 196             return row;
 197         } finally {
 198             nodeAndJsonNodeMapping.clear();
 199         }
 200     }
 201 
 202     private Row convertRow(JsonNode node, RowTypeInfo info) {
 203         final String[] names = info.getFieldNames();
 204         final TypeInformation&lt;?&gt;[] types = info.getFieldTypes();
 205 
 206         final Row row = new Row(names.length);
 207         for (int i = 0; i &lt; names.length; i++) {
 208             final String name = names[i];
 209             final JsonNode subNode = node.get(name);
 210             if (subNode == null) {
 211                 row.setField(i, null);
 212             } else {
 213                 row.setField(i, convert(subNode, types[i]));
 214             }
 215         }
 216 
 217         return row;
 218     }
 219 
 220     private Object convertObjectArray(JsonNode node, TypeInformation&lt;?&gt; elementType) {
 221         final Object[] array = (Object[]) Array.newInstance(elementType.getTypeClass(), node.size());
 222         for (int i = 0; i &lt; node.size(); i++) {
 223             array[i] = convert(node.get(i), elementType);
 224         }
 225         return array;
 226     }
 227 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.format.dtnest;
  20  
  21  import com.dtstack.flink.sql.table.AbstractTableInfo;
  22  import com.google.common.base.Strings;
  23  import com.google.common.collect.Maps;
  24  import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25  import org.apache.flink.api.common.typeinfo.TypeInformation;
  26  import org.apache.flink.api.common.typeinfo.Types;

  27  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  29  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  30  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  31  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  32  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  33  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  34  import org.apache.flink.types.Row;
  35  
  36  import java.io.IOException;

  37  import java.sql.Date;
  38  import java.sql.Time;
  39  import java.sql.Timestamp;
  40  import java.util.Iterator;
  41  import java.util.List;
  42  import java.util.Map;
  43  
  44  /**
  45   * source data parse to json format
  46   *

  47   * Date: 2019/12/12
  48   * Company: www.dtstack.com
  49   *
  50   * @author maqi
  51   */
  52  public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  53  
  54      private final ObjectMapper objectMapper = new ObjectMapper();
  55  
  56      private Map&lt;String, String&gt; rowAndFieldMapping;
  57      private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();


  58  
  59      private final String[] fieldNames;
  60      private final TypeInformation&lt;?&gt;[] fieldTypes;
  61      private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +    private TypeInformation&lt;Row&gt; typeInfo;</span>
  63  
<abbr title="  64      public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  64      public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, LðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +        this.typeInfo = typeInfo;</span>





  66          this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  67          this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  68          this.rowAndFieldMapping = rowAndFieldMapping;
  69          this.fieldExtraInfos = fieldExtraInfos;

  70      }
  71  
  72      @Override
  73      public Row deserialize(byte[] message) throws IOException {
  74          JsonNode root = objectMapper.readTree(message);


  75          this.parseTree(root, null);
  76          Row row = new Row(fieldNames.length);
  77  
  78          try {
  79              for (int i = 0; i &lt; fieldNames.length; i++) {
  80                  JsonNode node = getIgnoreCase(fieldNames[i]);
  81                  AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
  82  
  83                  if (node == null) {
  84                      if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
  85                          throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
  86                                  + fieldNames[i] + &quot;&#x27;.&quot;);
  87                      } else {
  88                          row.setField(i, null);
  89                      }
  90                  } else {
  91                      // Read the value as specified type
  92                      Object value = convert(node, fieldTypes[i]);
  93                      row.setField(i, value);
  94                  }
  95              }
  96              return row;
  97          } finally {
  98              nodeAndJsonNodeMapping.clear();
  99          }
 100      }
 101  
 102      private void parseTree(JsonNode jsonNode, String prefix){




 103          if (jsonNode.isArray()) {
 104              ArrayNode array = (ArrayNode) jsonNode;
 105              for (int i = 0; i &lt; array.size(); i++) {
 106                  JsonNode child = array.get(i);
 107                  String nodeKey = getNodeKey(prefix, i);
 108  
 109                  if (child.isValueNode()) {
 110                      nodeAndJsonNodeMapping.put(nodeKey, child);
 111                  } else {
 112                      if (rowAndFieldMapping.containsValue(nodeKey)) {
 113                          nodeAndJsonNodeMapping.put(nodeKey, child);
 114                      }
 115                      parseTree(child, nodeKey);
 116                  }
 117              }
 118              return;
 119          }
 120          Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 121          while (iterator.hasNext()){

 122              String next = iterator.next();
 123              JsonNode child = jsonNode.get(next);
 124              String nodeKey = getNodeKey(prefix, next);
 125  
 126              nodeAndJsonNodeMapping.put(nodeKey, child);
 127              if(child.isArray()){

 128                  parseTree(child, nodeKey);
 129              }else {

 130                  parseTree(child, nodeKey);
 131              }
 132          }
 133      }
 134  
 135      private JsonNode getIgnoreCase(String key) {
 136          String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 137          return nodeAndJsonNodeMapping.get(nodeMappingKey);
 138      }
 139  
 140      private String getNodeKey(String prefix, String nodeName){
 141          if(Strings.isNullOrEmpty(prefix)){


 142              return nodeName;
 143          }
 144          return prefix + &quot;.&quot; + nodeName;
 145      }
 146  
 147      private String getNodeKey(String prefix, int i) {
 148          if (Strings.isNullOrEmpty(prefix)) {
 149              return &quot;[&quot; + i + &quot;]&quot;;
 150          }
 151          return prefix + &quot;[&quot; + i + &quot;]&quot;;
 152      }
 153  
 154      private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 155          if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 156              return node.asBoolean();
 157          } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 158              if (node instanceof ObjectNode) {
 159                  return node.toString();
 160              } else if (node instanceof NullNode) {
 161                  return null;
 162              } else {
 163                  return node.asText();
 164              }
 165          }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {

 166              return Date.valueOf(node.asText());
 167          } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 168              // local zone
 169              return Time.valueOf(node.asText());
 170          } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 171              // local zone
 172              return Timestamp.valueOf(node.asText());
 173          }  else {





 174              // for types that were specified without JSON schema
 175              // e.g. POJOs
 176              try {
 177                  return objectMapper.treeToValue(node, info.getTypeClass());
 178              } catch (JsonProcessingException e) {
 179                  throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);
 180              }
 181          }
 182      }
 183  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +    public TypeInformation&lt;Row&gt; getProducedType() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        return typeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +    }</span>















































 189  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.format.dtnest;
  20  
  21  import com.dtstack.flink.sql.table.AbstractTableInfo;
  22  import com.google.common.base.Strings;
  23  import com.google.common.collect.Maps;
  24  import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25  import org.apache.flink.api.common.typeinfo.TypeInformation;
  26  import org.apache.flink.api.common.typeinfo.Types;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;</span>
  28  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  29  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  30  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  31  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  32  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  33  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  34  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  35  import org.apache.flink.types.Row;
  36  
  37  import java.io.IOException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import java.lang.reflect.Array;</span>
  39  import java.sql.Date;
  40  import java.sql.Time;
  41  import java.sql.Timestamp;
  42  import java.util.Iterator;
  43  import java.util.List;
  44  import java.util.Map;
  45  
  46  /**
  47   * source data parse to json format
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 - *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 + * &lt;p&gt;</span>
  50   * Date: 2019/12/12
  51   * Company: www.dtstack.com
  52   *
  53   * @author maqi
  54   */
  55  public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  56  
  57      private final ObjectMapper objectMapper = new ObjectMapper();
  58  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -    private Map&lt;String, String&gt; rowAndFieldMapping;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -    private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +    private final Map&lt;String, String&gt; rowAndFieldMapping;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +    private final Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();</span>
  63  
  64      private final String[] fieldNames;
  65      private final TypeInformation&lt;?&gt;[] fieldTypes;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  66 -    private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  68 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  68 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, LðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +    private final List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +    private final String charsetName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +                                          List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +                                          String charsetName) {</span>
  75          this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  76          this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  77          this.rowAndFieldMapping = rowAndFieldMapping;
  78          this.fieldExtraInfos = fieldExtraInfos;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +        this.charsetName = charsetName;</span>
  80      }
  81  
  82      @Override
  83      public Row deserialize(byte[] message) throws IOException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        JsonNode root = objectMapper.readTree(message);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +        String decoderStr = new String(message, charsetName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +        JsonNode root = objectMapper.readTree(decoderStr);</span>
  87          this.parseTree(root, null);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -        Row row = new Row(fieldNames.length);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -            for (int i = 0; i &lt; fieldNames.length; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -                JsonNode node = getIgnoreCase(fieldNames[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -                AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -                if (node == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -                    if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -                        throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -                                + fieldNames[i] + &quot;&#x27;.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -                    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -                        row.setField(i, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -                    // Read the value as specified type</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -                    Object value = convert(node, fieldTypes[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -                    row.setField(i, value);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -            return row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -        } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -            nodeAndJsonNodeMapping.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -    private void parseTree(JsonNode jsonNode, String prefix){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +        return convertTopRow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    private void parseTree(JsonNode jsonNode, String prefix) {</span>
 119          if (jsonNode.isArray()) {
 120              ArrayNode array = (ArrayNode) jsonNode;
 121              for (int i = 0; i &lt; array.size(); i++) {
 122                  JsonNode child = array.get(i);
 123                  String nodeKey = getNodeKey(prefix, i);
 124  
 125                  if (child.isValueNode()) {
 126                      nodeAndJsonNodeMapping.put(nodeKey, child);
 127                  } else {
 128                      if (rowAndFieldMapping.containsValue(nodeKey)) {
 129                          nodeAndJsonNodeMapping.put(nodeKey, child);
 130                      }
 131                      parseTree(child, nodeKey);
 132                  }
 133              }
 134              return;
 135          }
 136          Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -        while (iterator.hasNext()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +        while (iterator.hasNext()) {</span>
 139              String next = iterator.next();
 140              JsonNode child = jsonNode.get(next);
 141              String nodeKey = getNodeKey(prefix, next);
 142  
 143              nodeAndJsonNodeMapping.put(nodeKey, child);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -            if(child.isArray()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +            if (child.isArray()) {</span>
 146                  parseTree(child, nodeKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -            }else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +            } else {</span>
 149                  parseTree(child, nodeKey);
 150              }
 151          }
 152      }
 153  
 154      private JsonNode getIgnoreCase(String key) {
 155          String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 156          return nodeAndJsonNodeMapping.get(nodeMappingKey);
 157      }
 158  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -    private String getNodeKey(String prefix, String nodeName){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -        if(Strings.isNullOrEmpty(prefix)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +    private String getNodeKey(String prefix, String nodeName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +        if (Strings.isNullOrEmpty(prefix)) {</span>
 163              return nodeName;
 164          }
 165          return prefix + &quot;.&quot; + nodeName;
 166      }
 167  
 168      private String getNodeKey(String prefix, int i) {
 169          if (Strings.isNullOrEmpty(prefix)) {
 170              return &quot;[&quot; + i + &quot;]&quot;;
 171          }
 172          return prefix + &quot;[&quot; + i + &quot;]&quot;;
 173      }
 174  
 175      private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 176          if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 177              return node.asBoolean();
 178          } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 179              if (node instanceof ObjectNode) {
 180                  return node.toString();
 181              } else if (node instanceof NullNode) {
 182                  return null;
 183              } else {
 184                  return node.asText();
 185              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -        }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        } else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {</span>
 188              return Date.valueOf(node.asText());
 189          } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 190              // local zone
 191              return Time.valueOf(node.asText());
 192          } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 193              // local zone
 194              return Timestamp.valueOf(node.asText());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -        }  else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +        }  else if (info instanceof RowTypeInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +            return convertRow(node, (RowTypeInfo) info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +        } else if (info instanceof ObjectArrayTypeInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +            return convertObjectArray(node, ((ObjectArrayTypeInfo) info).getComponentInfo());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +        } else {</span>
 201              // for types that were specified without JSON schema
 202              // e.g. POJOs
 203              try {
 204                  return objectMapper.treeToValue(node, info.getTypeClass());
 205              } catch (JsonProcessingException e) {
 206                  throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);
 207              }
 208          }
 209      }
 210  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +    private Row convertTopRow() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        Row row = new Row(fieldNames.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +            for (int i = 0; i &lt; fieldNames.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                JsonNode node = getIgnoreCase(fieldNames[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                if (node == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                    if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                        throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +                            + fieldNames[i] + &quot;&#x27;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                        row.setField(i, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                    // Read the value as specified type</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                    Object value = convert(node, fieldTypes[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                    row.setField(i, value);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +            return row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +            nodeAndJsonNodeMapping.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +    private Row convertRow(JsonNode node, RowTypeInfo info) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        final String[] names = info.getFieldNames();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +        final TypeInformation&lt;?&gt;[] types = info.getFieldTypes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +        final Row row = new Row(names.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        for (int i = 0; i &lt; names.length; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +            final String name = names[i];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +            final JsonNode subNode = node.get(name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +            if (subNode == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +                row.setField(i, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +                row.setField(i, convert(subNode, types[i]));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +        return row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +    private Object convertObjectArray(JsonNode node, TypeInformation&lt;?&gt; elementType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +        final Object[] array = (Object[]) Array.newInstance(elementType.getTypeClass(), node.size());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        for (int i = 0; i &lt; node.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +            array[i] = convert(node.get(i), elementType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +        return array;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +    }</span>
 263  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            