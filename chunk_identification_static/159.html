<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>159</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    159
                    <a href="158.html">prev</a>
                    <a href="160.html">next</a>
                    <a href="159_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_85784acfd63b348aa9271a84368432c2699a9d67_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/web/form/component/ListGrid.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;85784acfd63b348aa9271a84368432c2699a9d67:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/web/form/component/ListGrid.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;85784acfd63b348aa9271a84368432c2699a9d67^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/web/form/component/ListGrid.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;85784acfd63b348aa9271a84368432c2699a9d67^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/web/form/component/ListGrid.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;ce5c9279711e306f5901899835666ffa510d85bd:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/web/form/component/ListGrid.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.web.form.component;
  20 
  21 import org.apache.commons.collections.CollectionUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.lang3.builder.CompareToBuilder;
  24 import org.broadleafcommerce.common.presentation.client.AddMethodType;
  25 import org.broadleafcommerce.common.util.TypedPredicate;
  26 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  27 import org.broadleafcommerce.openadmin.server.service.type.FetchType;
  28 import org.broadleafcommerce.openadmin.web.form.entity.Field;
  29 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.DataWrapper;
  30 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.FieldWrapper;
  31 
  32 import java.util.*;
  33 
  34 public class ListGrid {
  35 
  36     // We may have cases, when className not set.
  37     // In that case we need to initialize field with empty string,
  38     // to prevent &quot;null&quot; as css class for ListGrid
  39     protected String className = &quot;&quot;;
  40     protected String friendlyName = null;
  41     protected String idProperty;
  42     protected int order;
  43     protected boolean isSortable;
  44 
  45     protected boolean hideFriendlyName;
  46 
  47     protected Set&lt;Field&gt; headerFields = new TreeSet&lt;Field&gt;(new Comparator&lt;Field&gt;() {
  48 
  49         @Override
  50         public int compare(Field o1, Field o2) {
  51             return new CompareToBuilder()
  52                     .append(o1.getOrder(), o2.getOrder())
  53                     .append(o1.getFriendlyName(), o2.getFriendlyName())
  54                     .append(o1.getName(), o2.getName())
  55                     .toComparison();
  56         }
  57     });
  58     protected List&lt;ListGridRecord&gt; records = new ArrayList&lt;ListGridRecord&gt;();
  59     protected List&lt;ListGridAction&gt; toolbarActions = new ArrayList&lt;ListGridAction&gt;();
  60     
<abbr title="  61     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  61     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  62     protected List&lt;ListGridAction&gt; rowActions = new ArrayList&lt;ListGridAction&gt;();
  63 
  64     protected List&lt;ListGridActionGroup&gt; toolbarActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  65     protected List&lt;ListGridActionGroup&gt; rowActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  66 
<abbr title="  67     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  67     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  68     protected List&lt;ListGridAction&gt; modalRowActions = new ArrayList&lt;ListGridAction&gt;();
  69     private Set&lt;String&gt; cssClasses = new HashSet&lt;&gt;();
  70     protected int totalRecords;
  71     protected int startIndex;
  72     protected int pageSize;
  73     protected Boolean canFilterAndSort;
  74     protected Boolean isReadOnly;
  75     protected Boolean hideIdColumn;
  76     protected String fetchType = FetchType.DEFAULT.toString();
  77     protected long firstId;
  78     protected long lastId;
  79     protected int upperCount;
  80     protected int lowerCount;
  81     protected boolean totalCountLessThanPageSize;
  82     protected boolean promptSearch;
  83 
  84     // If true, only clicking the check box area will toggle the row selection when using multi select
  85     protected boolean multiSelectCheckBoxOnly;
  86 
  87     protected AddMethodType addMethodType;
  88     protected String listGridType;
  89     protected String selectType;
  90 
  91     protected String selectizeUrl;
  92 
  93     protected Boolean manualFetch;
  94     protected String helpText;
  95 
  96     // The section url that maps to this particular list grid
  97     protected String sectionKey;
  98 
<abbr title="  99     // The list of all section keys that have been traversed to arrive at this ListGrid (including the current one), in order">  99     // The list of all section keys that have been traversed to arrive at this ListGrid (including the cuðŸ”µ</abbr>
 100     // of occurrence
 101     protected List&lt;SectionCrumb&gt; sectionCrumbs = new ArrayList&lt;SectionCrumb&gt;();
 102 
<abbr title=" 103     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these properties"> 103     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these prðŸ”µ</abbr>
 104     // help identify the parent entity.
 105     protected String externalEntitySectionKey;
 106     protected String containingEntityId;
 107     protected String subCollectionFieldName;
 108     protected String pathOverride;
 109     protected String searchFieldsTemplateOverride;
 110     protected String templateOverride;
 111 
 112     public enum Type {
 113         MAIN,
 114         TO_ONE,
 115         BASIC,
 116         ADORNED,
 117         ADORNED_WITH_FORM,
 118         MAP,
 119         TRANSLATION,
 120         ASSET,
 121         WORKFLOW,
 122         TREE,
 123         ASSET_GRID,
 124         ASSET_GRID_FOLDER
 125     }
 126 
 127     public enum SelectType {
 128         SINGLE_SELECT,
 129         MULTI_SELECT,
 130         SELECTIZE,
 131         NONE
 132     }
 133 
 134     /* Filter Builder required Fields */
 135     protected String fieldBuilder;
 136     protected DataWrapper dataWrapper;
 137     protected String json;
 138     protected String jsonFieldName;
 139     protected FieldWrapper fieldWrapper;
 140 
 141 
 142 
 143     /* ************** */
 144     /* CUSTOM METHODS */
 145     /* ************** */
 146     
 147     public String getPath() {
 148         if (StringUtils.isNotBlank(pathOverride)) {
 149             return pathOverride;
 150         }
 151                 
 152         StringBuilder sb = new StringBuilder();
 153         
 154         if (!getSectionKey().startsWith(&quot;/&quot;)) {
 155             sb.append(&quot;/&quot;);
 156         }
 157         
 158         sb.append(getSectionKey());
 159         if (getContainingEntityId() != null) {
 160             sb.append(&quot;/&quot;).append(getContainingEntityId());
 161         }
 162         
 163         if (StringUtils.isNotBlank(getSubCollectionFieldName())) {
 164             sb.append(&quot;/&quot;).append(getSubCollectionFieldName());
 165         }
 166         
 167         //to-one grids need a slightly different grid URL; these need to be appended with &#x27;select&#x27;
 168         //TODO: surely there&#x27;s a better way to do this besides just hardcoding the &#x27;select&#x27;?
 169         if (Type.TO_ONE.toString().toLowerCase().equals(listGridType)) {
 170             sb.append(&quot;/select&quot;);
 171         }
 172         
 173         return sb.toString();
 174     }
 175 
 176     public String getSectionCrumbRepresentation() {
 177         StringBuilder sb = new StringBuilder();
 178         if (!sectionCrumbs.isEmpty()) {
 179            sb.append(&quot;?sectionCrumbs=&quot;);
 180         }
 181         int index = 0;
 182         for (SectionCrumb section : sectionCrumbs) {
 183             sb.append(section.getSectionIdentifier());
 184             sb.append(&quot;--&quot;);
 185             sb.append(section.getSectionId());
 186             if (index &lt; sectionCrumbs.size()-1) {
 187                 sb.append(&quot;,&quot;);
 188             }
 189             index++;
 190         }
 191         return sb.toString();
 192     }
 193 
 194     /**
<abbr title=" 195      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as the listgrid"> 195      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly sðŸ”µ</abbr>
 196      * and are thus shown on the screen
 197      */
 198     @SuppressWarnings(&quot;unchecked&quot;)
 199     public List&lt;ListGridAction&gt; getActiveToolbarActions() {
<abbr title=" 200         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 200         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListðŸ”µ</abbr>
 201             
 202             @Override
 203             public boolean eval(ListGridAction action) {
 204                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 205             }
 206         });
 207     }
 208     
 209     /**
<abbr title=" 210      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 210      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 211      * and are thus shown on the screen
 212      */
 213     @SuppressWarnings(&quot;unchecked&quot;)
 214     public List&lt;ListGridAction&gt; getActiveRowActions() {
<abbr title=" 215         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 215         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridðŸ”µ</abbr>
 216             
 217             @Override
 218             public boolean eval(ListGridAction action) {
 219                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 220             }
 221         });
 222     }
 223 
 224     /**
<abbr title=" 225      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly state as the listgrid"> 225      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same reaðŸ”µ</abbr>
 226      * and are thus shown on the screen
 227      */
 228     @SuppressWarnings(&quot;unchecked&quot;)
 229     public List&lt;ListGridAction&gt; getActiveToolbarActionGroups() {
<abbr title=" 230         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 230         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicateðŸ”µ</abbr>
 231 
 232             @Override
 233             public boolean eval(ListGridActionGroup actionGroup) {
 234                 boolean result = false;
 235                 for (ListGridAction action : actionGroup.getListGridActions()) {
 236                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 237                         result = true;
 238                     }
 239                 }
 240                 return result;
 241             }
 242         });
 243     }
 244 
 245     /**
<abbr title=" 246      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state as the listgrid"> 246      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonlðŸ”µ</abbr>
 247      * and are thus shown on the screen
 248      */
 249     @SuppressWarnings(&quot;unchecked&quot;)
 250     public List&lt;ListGridAction&gt; getActiveRowActionGroups() {
<abbr title=" 251         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 251         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;LisðŸ”µ</abbr>
 252 
 253             @Override
 254             public boolean eval(ListGridActionGroup actionGroup) {
 255                 boolean result = false;
 256                 for (ListGridAction action : actionGroup.getListGridActions()) {
 257                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 258                         result = true;
 259                     }
 260                 }
 261                 return result;
 262             }
 263         });
 264     }
 265 
 266     /**
<abbr title=" 267      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 267      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 268      * and are thus shown on the screen
 269      */
 270     @SuppressWarnings(&quot;unchecked&quot;)
 271     public List&lt;ListGridAction&gt; getActiveModalRowActions() {
<abbr title=" 272         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 272         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;LisðŸ”µ</abbr>
 273 
 274             @Override
 275             public boolean eval(ListGridAction action) {
 276                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 277             }
 278         });
 279     }
 280     
 281     public void addRowAction(ListGridAction action) {
 282         getRowActions().add(action);
 283     }
 284 
 285     public void addModalRowAction(ListGridAction action) {
 286         getModalRowActions().add(action);
 287     }
 288 
 289     public void addToolbarAction(ListGridAction action) {
 290         getToolbarActions().add(action);
 291     }
 292     
 293     public void removeAllToolbarActions() {
 294         getToolbarActions().clear();
 295     }
 296     
 297     public void removeAllRowActions() {
 298         getRowActions().clear();
 299     }
 300 
 301     public void addToolbarActionGroup(ListGridActionGroup actionGroup) {
 302         getToolbarActionGroups().add(actionGroup);
 303     }
 304 
 305     public void removeAllToolbarActionGroups() {
 306         getToolbarActionGroups().clear();
 307     }
 308 
 309     public void addRowActionGroup(ListGridActionGroup actionGroup) {
 310         getRowActionGroups().add(actionGroup);
 311     }
 312 
 313     public void removeAllRowActionGroups() {
 314         getRowActionGroups().clear();
 315     }
 316 
 317     public void removeAllModalRowActions() {
 318         getModalRowActions().clear();
 319     }
 320 
 321     public ListGridAction findToolbarAction(String actionId) {
 322         for (ListGridAction action : getToolbarActions()) {
 323             if (action.getActionId().equals(actionId)) {
 324                 return action;
 325             }
 326         }
 327         for (ListGridActionGroup actionGroup : getToolbarActionGroups()) {
 328             for (ListGridAction action : actionGroup.getListGridActions()) {
 329                 if (action.getActionId().equals(actionId)) {
 330                     return action;
 331                 }
 332             }
 333         }
 334         return null;
 335     }
 336     
 337     public ListGridAction findRowAction(String actionId) {
 338         for (ListGridAction action : getRowActions()) {
 339             if (action.getActionId().equals(actionId)) {
 340                 return action;
 341             }
 342         }
 343         for (ListGridActionGroup actionGroup : getRowActionGroups()) {
 344             for (ListGridAction action : actionGroup.getListGridActions()) {
 345                 if (action.getActionId().equals(actionId)) {
 346                     return action;
 347                 }
 348             }
 349         }
 350         return null;
 351     }
 352 
 353     public ListGridAction findModalRowAction(String actionId) {
 354         for (ListGridAction action : getModalRowActions()) {
 355             if (action.getActionId().equals(actionId)) {
 356                 return action;
 357             }
 358         }
 359         return null;
 360     }
 361     
 362     /**
<abbr title=" 363      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, then the"> 363      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordðŸ”µ</abbr>
 364      * sort functionality doesn&#x27;t make any sense.
 365      * 
 366      * Also, map structures are currently unsortable.
 367      * 
 368      * @return
 369      */
 370     public boolean isSortable() {
 371         return this.isSortable || Type.MAP.toString().toLowerCase().equals(getListGridType());
 372     }
 373 
 374     /* ************************ */
 375     /* CUSTOM GETTERS / SETTERS */
 376     /* ************************ */
 377     
 378     public void setListGridType(Type listGridType) {
 379         this.listGridType = listGridType.toString().toLowerCase();
 380     }
 381     
 382     /**
<abbr title=" 383      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to on the JS"> 383      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlðŸ”µ</abbr>
 384      * side
 385      * @param listGridType
 386      */
 387     public void setListGridTypeString(String listGridType) {
 388         this.listGridType = listGridType;
 389     }
 390 
 391     public void setSelectType(SelectType selectType) {
 392         this.selectType = selectType.toString().toLowerCase();
 393     }
 394 
 395     public void setSelectTypeString(String selectType) {
 396         this.selectType = selectType;
 397     }
 398 
 399     public Boolean getCanFilterAndSort() {
 400         return (canFilterAndSort == null ? true : canFilterAndSort);
 401     }
 402 
 403     public Boolean getIsReadOnly() {
 404         return isReadOnly == null ? false : isReadOnly;
 405     }
 406     
 407     public Boolean getClickable() {
 408         return !&quot;none&quot;.equals(selectType);
 409     }
 410     
 411     public Boolean getHideIdColumn() {
 412         return hideIdColumn == null ? true : hideIdColumn;
 413     }
 414 
 415     /* ************************** */
 416     /* STANDARD GETTERS / SETTERS */
 417     /* ************************** */        
 418 
 419 	public String getIdProperty() {
 420         return idProperty;
 421     }
 422 
 423     public void setIdProperty(String idProperty) {
 424         this.idProperty = idProperty;
 425     }
 426 
 427     public String getClassName() {
 428         return className;
 429     }
 430 
 431     public void setClassName(String className) {
 432         this.className = className;
 433     }
 434 
 435     public int getOrder() {
 436         return order;
 437     }
 438     
 439     public void setOrder(int order) {
 440         this.order = order;
 441     }
 442 
 443     public boolean getIsSortable() {
 444         return isSortable;
 445     }
 446 
 447     public void setIsSortable(boolean isSortable) {
 448         this.isSortable = isSortable;
 449     }
 450 
 451     public boolean getHideFriendlyName() { return hideFriendlyName; }
 452 
<abbr title=" 453     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName; }"> 453     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName;ðŸ”µ</abbr>
 454 
 455     public Set&lt;Field&gt; getHeaderFields() {
 456         return headerFields;
 457     }
 458 
 459     public void setHeaderFields(Set&lt;Field&gt; headerFields) {
 460         this.headerFields = headerFields;
 461     }
 462 
 463     public Field findHeaderField(String name) {
 464         if (name == null) {
 465             return null;
 466         }
 467 
 468         for (Field headerField : getHeaderFields()) {
 469             if (name.equals(headerField.getName())) {
 470                 return headerField;
 471             }
 472         }
 473         return null;
 474     }
 475 
 476     public boolean isEmpty() {
 477         return records.isEmpty();
 478     }
 479 
 480     public List&lt;ListGridRecord&gt; getRecords() {
 481         return records;
 482     }
 483 
 484     public void setRecords(List&lt;ListGridRecord&gt; records) {
 485         this.records = records;
 486     }
 487     
 488     public List&lt;ListGridAction&gt; getToolbarActions() {
 489         return toolbarActions;
 490     }
 491     
 492     public void setToolbarActions(List&lt;ListGridAction&gt; toolbarActions) {
 493         this.toolbarActions = toolbarActions;
 494     }
 495     
 496     public List&lt;ListGridAction&gt; getRowActions() {
 497         return rowActions;
 498     }
 499     
 500     public void setRowActions(List&lt;ListGridAction&gt; rowActions) {
 501         this.rowActions = rowActions;
 502     }
 503 
 504     public List&lt;ListGridActionGroup&gt; getToolbarActionGroups() {
 505         return toolbarActionGroups;
 506     }
 507 
 508     public void setToolbarActionGroups(List&lt;ListGridActionGroup&gt; toolbarActionGroups) {
 509         this.toolbarActionGroups = toolbarActionGroups;
 510     }
 511 
 512     public List&lt;ListGridActionGroup&gt; getRowActionGroups() {
 513         return rowActionGroups;
 514     }
 515 
 516     public void setRowActionGroups(List&lt;ListGridActionGroup&gt; rowActionGroups) {
 517         this.rowActionGroups = rowActionGroups;
 518     }
 519 
 520     public List&lt;ListGridAction&gt; getModalRowActions() {
 521         return modalRowActions;
 522     }
 523 
 524     public void setModalRowActions(List&lt;ListGridAction&gt; modalRowActions) {
 525         this.modalRowActions = modalRowActions;
 526     }
 527 
 528     public int getStartIndex() {
 529         return startIndex;
 530     }
 531 
 532     public void setStartIndex(int startIndex) {
 533         this.startIndex = startIndex;
 534     }
 535     
 536     public int getTotalRecords() {
 537         return totalRecords;
 538     }
 539 
 540     public void setTotalRecords(int totalRecords) {
 541         this.totalRecords = totalRecords;
 542     }
 543     
 544     public int getPageSize() {
 545         return pageSize;
 546     }
 547     
 548     public void setPageSize(int pageSize) {
 549         this.pageSize = pageSize;
 550     }
 551     
 552     public void setCanFilterAndSort(Boolean canFilterAndSort) {
 553         this.canFilterAndSort = canFilterAndSort;
 554     }
 555 
 556     public AddMethodType getAddMethodType() {
 557         return addMethodType;
 558     }
 559 
 560     public void setAddMethodType(AddMethodType addMethodType) {
 561         this.addMethodType = addMethodType;
 562     }
 563 
 564     public String getListGridType() {
 565         return listGridType;
 566     }
 567 
 568     public String getSelectType() {
 569         return selectType;
 570     }
 571 
 572     public String getContainingEntityId() {
 573         return containingEntityId;
 574     }
 575 
 576     public void setContainingEntityId(String containingEntityId) {
 577         this.containingEntityId = containingEntityId;
 578     }
 579 
 580     public String getSubCollectionFieldName() {
 581         return subCollectionFieldName;
 582     }
 583 
 584     public void setSubCollectionFieldName(String subCollectionFieldName) {
 585         this.subCollectionFieldName = subCollectionFieldName;
 586     }
 587 
 588     public String getFriendlyName() {
 589         return friendlyName;
 590     }
 591 
 592     public void setFriendlyName(String friendlyName) {
 593         this.friendlyName = friendlyName;
 594     }
 595 
 596     public String getSectionKey() {
 597         return sectionKey;
 598     }
 599     
 600     public void setSectionKey(String sectionKey) {
 601         this.sectionKey = sectionKey;
 602     }
 603 
 604     public String getSelectizeUrl() {
 605         return selectizeUrl;
 606     }
 607 
 608     public void setSelectizeUrl(String selectizeUrl) {
 609         this.selectizeUrl = selectizeUrl;
 610     }
 611 
 612     public Boolean getManualFetch() {
 613         if (manualFetch == null) {
 614             return false;
 615         }
 616         return manualFetch;
 617     }
 618 
 619     public void setManualFetch(Boolean manualFetch) {
 620         this.manualFetch = manualFetch;
 621     }
 622 
 623     public String getExternalEntitySectionKey() {
 624         return externalEntitySectionKey;
 625     }
 626 
 627     public void setExternalEntitySectionKey(String externalEntitySectionKey) {
 628         this.externalEntitySectionKey = externalEntitySectionKey;
 629     }
 630 
 631     public String getPathOverride() {
 632         return pathOverride;
 633     }
 634 
 635     public void setPathOverride(String pathOverride) {
 636         this.pathOverride = pathOverride;
 637     }
 638 
 639     public String getSearchFieldsTemplateOverride() {
 640         return searchFieldsTemplateOverride;
 641     }
 642 
 643     public void setSearchFieldsTemplateOverride(String searchFieldsTemplateOverride) {
 644         this.searchFieldsTemplateOverride = searchFieldsTemplateOverride;
 645     }
 646 
 647     public String getTemplateOverride() {
 648         return templateOverride;
 649     }
 650 
 651     public void setTemplateOverride(String templateOverride) {
 652         this.templateOverride = templateOverride;
 653     }
 654 
 655     public void setIsReadOnly(Boolean readOnly) {
 656         this.isReadOnly = readOnly;
 657     }
 658 
 659     public void setHideIdColumn(Boolean hideIdColumn) {
 660         this.hideIdColumn = hideIdColumn;
 661     }
 662 
 663     public List&lt;SectionCrumb&gt; getSectionCrumbs() {
 664         return sectionCrumbs;
 665     }
 666 
 667     public void setSectionCrumbs(List&lt;SectionCrumb&gt; sectionCrumbs) {
 668         if (sectionCrumbs == null) {
 669             this.sectionCrumbs.clear();
 670             return;
 671         }
 672         this.sectionCrumbs = sectionCrumbs;
 673     }
 674 
 675     public String getFieldBuilder() {
 676         return fieldBuilder;
 677     }
 678 
 679     public void setFieldBuilder(String fieldBuilder) {
 680         this.fieldBuilder = fieldBuilder;
 681     }
 682 
 683     public FieldWrapper getFieldWrapper() {
 684         return fieldWrapper;
 685     }
 686 
 687     public void setFieldWrapper(FieldWrapper fieldWrapper) {
 688         this.fieldWrapper = fieldWrapper;
 689     }
 690 
 691     public DataWrapper getDataWrapper() {
 692         return dataWrapper;
 693     }
 694 
 695     public void setDataWrapper(DataWrapper dataWrapper) {
 696         this.dataWrapper = dataWrapper;
 697     }
 698 
 699     public String getJson() {
 700         return json;
 701     }
 702 
 703     public void setJson(String json) {
 704         this.json = json;
 705     }
 706 
 707     public String getJsonFieldName() {
 708         return jsonFieldName;
 709     }
 710 
 711     public void setJsonFieldName(String jsonFieldName) {
 712         this.jsonFieldName = jsonFieldName;
 713     }
 714 
 715     public String getFetchType() {
 716         return fetchType;
 717     }
 718 
 719     public void setFetchType(String fetchType) {
 720         this.fetchType = fetchType;
 721     }
 722 
 723     public long getFirstId() {
 724         return firstId;
 725     }
 726 
 727     public void setFirstId(long firstId) {
 728         this.firstId = firstId;
 729     }
 730 
 731     public long getLastId() {
 732         return lastId;
 733     }
 734 
 735     public void setLastId(long lastId) {
 736         this.lastId = lastId;
 737     }
 738 
 739     public int getUpperCount() {
 740         return upperCount;
 741     }
 742 
 743     public void setUpperCount(int upperCount) {
 744         this.upperCount = upperCount;
 745     }
 746 
 747     public int getLowerCount() {
 748         return lowerCount;
 749     }
 750 
 751     public void setLowerCount(int lowerCount) {
 752         this.lowerCount = lowerCount;
 753     }
 754 
 755     public boolean isTotalCountLessThanPageSize() {
 756         return totalCountLessThanPageSize;
 757     }
 758 
 759     public void setTotalCountLessThanPageSize(boolean totalCountLessThanPageSize) {
 760         this.totalCountLessThanPageSize = totalCountLessThanPageSize;
 761     }
 762 
 763     public boolean isPromptSearch() {
 764         return promptSearch;
 765     }
 766 
 767     public void setPromptSearch(boolean promptSearch) {
 768         this.promptSearch = promptSearch;
 769     }
 770 
 771     public String getHelpText() { return helpText; }
 772 
 773     public void setHelpText(String helpText) { this.helpText = helpText; }
 774 
 775 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 776     public boolean isMultiSelectCheckBoxOnly() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 777         return multiSelectCheckBoxOnly;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 778     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 779 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 780     public void setMultiSelectCheckBoxOnly(boolean multiSelectCheckBoxOnly) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 781         this.multiSelectCheckBoxOnly = multiSelectCheckBoxOnly;</span>
 782 ||||||| GitAnalyzerPlus_base
 783 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 784     /* ***************************** */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 785     /* CSS CLASSES GETTERS / SETTERS */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 786     /* ***************************** */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 787 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 788     public void addCssClass(String className) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 789         this.cssClasses.add(className);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 790     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 791 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 792     public void removeCssClass(String className) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 793         this.cssClasses.remove(className);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 794     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 795 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 796     public void clearCssClasses() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 797         this.cssClasses.clear();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 798     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 799 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 800     public String getCssClassNames() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 801         return StringUtils.join(this.cssClasses, &quot; &quot;);</span>
 802 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 803     }
 804 
 805 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.web.form.component;
  20 
  21 import org.apache.commons.collections.CollectionUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.lang3.builder.CompareToBuilder;
  24 import org.broadleafcommerce.common.presentation.client.AddMethodType;
  25 import org.broadleafcommerce.common.util.TypedPredicate;
  26 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  27 import org.broadleafcommerce.openadmin.server.service.type.FetchType;
  28 import org.broadleafcommerce.openadmin.web.form.entity.Field;
  29 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.DataWrapper;
  30 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.FieldWrapper;
  31 
  32 import java.util.*;
  33 
  34 public class ListGrid {
  35 
  36     // We may have cases, when className not set.
  37     // In that case we need to initialize field with empty string,
  38     // to prevent &quot;null&quot; as css class for ListGrid
  39     protected String className = &quot;&quot;;
  40     protected String friendlyName = null;
  41     protected String idProperty;
  42     protected int order;
  43     protected boolean isSortable;
  44 
  45     protected boolean hideFriendlyName;
  46 
  47     protected Set&lt;Field&gt; headerFields = new TreeSet&lt;Field&gt;(new Comparator&lt;Field&gt;() {
  48 
  49         @Override
  50         public int compare(Field o1, Field o2) {
  51             return new CompareToBuilder()
  52                     .append(o1.getOrder(), o2.getOrder())
  53                     .append(o1.getFriendlyName(), o2.getFriendlyName())
  54                     .append(o1.getName(), o2.getName())
  55                     .toComparison();
  56         }
  57     });
  58     protected List&lt;ListGridRecord&gt; records = new ArrayList&lt;ListGridRecord&gt;();
  59     protected List&lt;ListGridAction&gt; toolbarActions = new ArrayList&lt;ListGridAction&gt;();
  60 
<abbr title="  61     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  61     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  62     protected List&lt;ListGridAction&gt; rowActions = new ArrayList&lt;ListGridAction&gt;();
  63 
  64     protected List&lt;ListGridActionGroup&gt; toolbarActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  65     protected List&lt;ListGridActionGroup&gt; rowActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  66 
<abbr title="  67     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  67     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  68     protected List&lt;ListGridAction&gt; modalRowActions = new ArrayList&lt;ListGridAction&gt;();
  69     private Set&lt;String&gt; cssClasses = new HashSet&lt;&gt;();
  70     protected int totalRecords;
  71     protected int startIndex;
  72     protected int pageSize;
  73     protected Boolean canFilterAndSort;
  74     protected Boolean isReadOnly;
  75     protected Boolean hideIdColumn;
  76     protected String fetchType = FetchType.DEFAULT.toString();
  77     protected long firstId;
  78     protected long lastId;
  79     protected int upperCount;
  80     protected int lowerCount;
  81     protected boolean totalCountLessThanPageSize;
  82     protected boolean promptSearch;
  83 
  84     // If true, only clicking the check box area will toggle the row selection when using multi select
  85     protected boolean multiSelectCheckBoxOnly;
  86 
  87     protected AddMethodType addMethodType;
  88     protected String listGridType;
  89     protected String selectType;
  90 
  91     protected String selectizeUrl;
  92 
  93     protected Boolean manualFetch;
  94     protected String helpText;
  95 
  96     // The section url that maps to this particular list grid
  97     protected String sectionKey;
  98 
<abbr title="  99     // The list of all section keys that have been traversed to arrive at this ListGrid (including the current one), in order">  99     // The list of all section keys that have been traversed to arrive at this ListGrid (including the cuðŸ”µ</abbr>
 100     // of occurrence
 101     protected List&lt;SectionCrumb&gt; sectionCrumbs = new ArrayList&lt;SectionCrumb&gt;();
 102 
<abbr title=" 103     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these properties"> 103     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these prðŸ”µ</abbr>
 104     // help identify the parent entity.
 105     protected String externalEntitySectionKey;
 106     protected String containingEntityId;
 107     protected String subCollectionFieldName;
 108     protected String pathOverride;
 109     protected String searchFieldsTemplateOverride;
 110     protected String templateOverride;
 111 
 112     public enum Type {
 113         MAIN,
 114         TO_ONE,
 115         BASIC,
 116         ADORNED,
 117         ADORNED_WITH_FORM,
 118         MAP,
 119         TRANSLATION,
 120         ASSET,
 121         WORKFLOW,
 122         TREE,
 123         ASSET_GRID,
 124         ASSET_GRID_FOLDER
 125     }
 126 
 127     public enum SelectType {
 128         SINGLE_SELECT,
 129         MULTI_SELECT,
 130         SELECTIZE,
 131         NONE
 132     }
 133 
 134     /* Filter Builder required Fields */
 135     protected String fieldBuilder;
 136     protected DataWrapper dataWrapper;
 137     protected String json;
 138     protected String jsonFieldName;
 139     protected FieldWrapper fieldWrapper;
 140 
 141 
 142 
 143     /* ************** */
 144     /* CUSTOM METHODS */
 145     /* ************** */
 146 
 147     public String getPath() {
 148         if (StringUtils.isNotBlank(pathOverride)) {
 149             return pathOverride;
 150         }
 151 
 152         StringBuilder sb = new StringBuilder();
 153 
 154         if (!getSectionKey().startsWith(&quot;/&quot;)) {
 155             sb.append(&quot;/&quot;);
 156         }
 157 
 158         sb.append(getSectionKey());
 159         if (getContainingEntityId() != null) {
 160             sb.append(&quot;/&quot;).append(getContainingEntityId());
 161         }
 162 
 163         if (StringUtils.isNotBlank(getSubCollectionFieldName())) {
 164             sb.append(&quot;/&quot;).append(getSubCollectionFieldName());
 165         }
 166 
 167         //to-one grids need a slightly different grid URL; these need to be appended with &#x27;select&#x27;
 168         //TODO: surely there&#x27;s a better way to do this besides just hardcoding the &#x27;select&#x27;?
 169         if (Type.TO_ONE.toString().toLowerCase().equals(listGridType)) {
 170             sb.append(&quot;/select&quot;);
 171         }
 172 
 173         return sb.toString();
 174     }
 175 
 176     public String getSectionCrumbRepresentation() {
 177         StringBuilder sb = new StringBuilder();
 178         if (!sectionCrumbs.isEmpty()) {
 179            sb.append(&quot;?sectionCrumbs=&quot;);
 180         }
 181         int index = 0;
 182         for (SectionCrumb section : sectionCrumbs) {
 183             sb.append(section.getSectionIdentifier());
 184             sb.append(&quot;--&quot;);
 185             sb.append(section.getSectionId());
 186             if (index &lt; sectionCrumbs.size()-1) {
 187                 sb.append(&quot;,&quot;);
 188             }
 189             index++;
 190         }
 191         return sb.toString();
 192     }
 193 
 194     /**
<abbr title=" 195      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as the listgrid"> 195      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly sðŸ”µ</abbr>
 196      * and are thus shown on the screen
 197      */
 198     @SuppressWarnings(&quot;unchecked&quot;)
 199     public List&lt;ListGridAction&gt; getActiveToolbarActions() {
<abbr title=" 200         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 200         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListðŸ”µ</abbr>
 201 
 202             @Override
 203             public boolean eval(ListGridAction action) {
 204                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 205             }
 206         });
 207     }
 208 
 209     /**
<abbr title=" 210      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 210      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 211      * and are thus shown on the screen
 212      */
 213     @SuppressWarnings(&quot;unchecked&quot;)
 214     public List&lt;ListGridAction&gt; getActiveRowActions() {
<abbr title=" 215         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 215         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridðŸ”µ</abbr>
 216 
 217             @Override
 218             public boolean eval(ListGridAction action) {
 219                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 220             }
 221         });
 222     }
 223 
 224     /**
<abbr title=" 225      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly state as the listgrid"> 225      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same reaðŸ”µ</abbr>
 226      * and are thus shown on the screen
 227      */
 228     @SuppressWarnings(&quot;unchecked&quot;)
 229     public List&lt;ListGridAction&gt; getActiveToolbarActionGroups() {
<abbr title=" 230         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 230         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicateðŸ”µ</abbr>
 231 
 232             @Override
 233             public boolean eval(ListGridActionGroup actionGroup) {
 234                 boolean result = false;
 235                 for (ListGridAction action : actionGroup.getListGridActions()) {
 236                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 237                         result = true;
 238                     }
 239                 }
 240                 return result;
 241             }
 242         });
 243     }
 244 
 245     /**
<abbr title=" 246      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state as the listgrid"> 246      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonlðŸ”µ</abbr>
 247      * and are thus shown on the screen
 248      */
 249     @SuppressWarnings(&quot;unchecked&quot;)
 250     public List&lt;ListGridAction&gt; getActiveRowActionGroups() {
<abbr title=" 251         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 251         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;LisðŸ”µ</abbr>
 252 
 253             @Override
 254             public boolean eval(ListGridActionGroup actionGroup) {
 255                 boolean result = false;
 256                 for (ListGridAction action : actionGroup.getListGridActions()) {
 257                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 258                         result = true;
 259                     }
 260                 }
 261                 return result;
 262             }
 263         });
 264     }
 265 
 266     /**
<abbr title=" 267      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 267      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 268      * and are thus shown on the screen
 269      */
 270     @SuppressWarnings(&quot;unchecked&quot;)
 271     public List&lt;ListGridAction&gt; getActiveModalRowActions() {
<abbr title=" 272         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 272         return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;LisðŸ”µ</abbr>
 273 
 274             @Override
 275             public boolean eval(ListGridAction action) {
 276                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 277             }
 278         });
 279     }
 280 
 281     public void addRowAction(ListGridAction action) {
 282         getRowActions().add(action);
 283     }
 284 
 285     public void addModalRowAction(ListGridAction action) {
 286         getModalRowActions().add(action);
 287     }
 288 
 289     public void addToolbarAction(ListGridAction action) {
 290         getToolbarActions().add(action);
 291     }
 292 
 293     public void removeAllToolbarActions() {
 294         getToolbarActions().clear();
 295     }
 296 
 297     public void removeAllRowActions() {
 298         getRowActions().clear();
 299     }
 300 
 301     public void addToolbarActionGroup(ListGridActionGroup actionGroup) {
 302         getToolbarActionGroups().add(actionGroup);
 303     }
 304 
 305     public void removeAllToolbarActionGroups() {
 306         getToolbarActionGroups().clear();
 307     }
 308 
 309     public void addRowActionGroup(ListGridActionGroup actionGroup) {
 310         getRowActionGroups().add(actionGroup);
 311     }
 312 
 313     public void removeAllRowActionGroups() {
 314         getRowActionGroups().clear();
 315     }
 316 
 317     public void removeAllModalRowActions() {
 318         getModalRowActions().clear();
 319     }
 320 
 321     public ListGridAction findToolbarAction(String actionId) {
 322         for (ListGridAction action : getToolbarActions()) {
 323             if (action.getActionId().equals(actionId)) {
 324                 return action;
 325             }
 326         }
 327         for (ListGridActionGroup actionGroup : getToolbarActionGroups()) {
 328             for (ListGridAction action : actionGroup.getListGridActions()) {
 329                 if (action.getActionId().equals(actionId)) {
 330                     return action;
 331                 }
 332             }
 333         }
 334         return null;
 335     }
 336 
 337     public ListGridAction findRowAction(String actionId) {
 338         for (ListGridAction action : getRowActions()) {
 339             if (action.getActionId().equals(actionId)) {
 340                 return action;
 341             }
 342         }
 343         for (ListGridActionGroup actionGroup : getRowActionGroups()) {
 344             for (ListGridAction action : actionGroup.getListGridActions()) {
 345                 if (action.getActionId().equals(actionId)) {
 346                     return action;
 347                 }
 348             }
 349         }
 350         return null;
 351     }
 352 
 353     public ListGridAction findModalRowAction(String actionId) {
 354         for (ListGridAction action : getModalRowActions()) {
 355             if (action.getActionId().equals(actionId)) {
 356                 return action;
 357             }
 358         }
 359         return null;
 360     }
 361 
 362     /**
<abbr title=" 363      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, then the"> 363      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordðŸ”µ</abbr>
 364      * sort functionality doesn&#x27;t make any sense.
 365      *
 366      * Also, map structures are currently unsortable.
 367      *
 368      * @return
 369      */
 370     public boolean isSortable() {
 371         return this.isSortable || Type.MAP.toString().toLowerCase().equals(getListGridType());
 372     }
 373 
 374     /* ************************ */
 375     /* CUSTOM GETTERS / SETTERS */
 376     /* ************************ */
 377 
 378     public void setListGridType(Type listGridType) {
 379         this.listGridType = listGridType.toString().toLowerCase();
 380     }
 381 
 382     /**
<abbr title=" 383      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to on the JS"> 383      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlðŸ”µ</abbr>
 384      * side
 385      * @param listGridType
 386      */
 387     public void setListGridTypeString(String listGridType) {
 388         this.listGridType = listGridType;
 389     }
 390 
 391     public void setSelectType(SelectType selectType) {
 392         this.selectType = selectType.toString().toLowerCase();
 393     }
 394 
 395     public void setSelectTypeString(String selectType) {
 396         this.selectType = selectType;
 397     }
 398 
 399     public Boolean getCanFilterAndSort() {
 400         return (canFilterAndSort == null ? true : canFilterAndSort);
 401     }
 402 
 403     public Boolean getIsReadOnly() {
 404         return isReadOnly == null ? false : isReadOnly;
 405     }
 406 
 407     public Boolean getClickable() {
 408         return !&quot;none&quot;.equals(selectType);
 409     }
 410 
 411     public Boolean getHideIdColumn() {
 412         return hideIdColumn == null ? true : hideIdColumn;
 413     }
 414 
 415     /* ************************** */
 416     /* STANDARD GETTERS / SETTERS */
 417     /* ************************** */
 418 
 419 	public String getIdProperty() {
 420         return idProperty;
 421     }
 422 
 423     public void setIdProperty(String idProperty) {
 424         this.idProperty = idProperty;
 425     }
 426 
 427     public String getClassName() {
 428         return className;
 429     }
 430 
 431     public void setClassName(String className) {
 432         this.className = className;
 433     }
 434 
 435     public int getOrder() {
 436         return order;
 437     }
 438 
 439     public void setOrder(int order) {
 440         this.order = order;
 441     }
 442 
 443     public boolean getIsSortable() {
 444         return isSortable;
 445     }
 446 
 447     public void setIsSortable(boolean isSortable) {
 448         this.isSortable = isSortable;
 449     }
 450 
 451     public boolean getHideFriendlyName() { return hideFriendlyName; }
 452 
<abbr title=" 453     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName; }"> 453     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName;ðŸ”µ</abbr>
 454 
 455     public Set&lt;Field&gt; getHeaderFields() {
 456         return headerFields;
 457     }
 458 
 459     public void setHeaderFields(Set&lt;Field&gt; headerFields) {
 460         this.headerFields = headerFields;
 461     }
 462 
 463     public Field findHeaderField(String name) {
 464         if (name == null) {
 465             return null;
 466         }
 467 
 468         for (Field headerField : getHeaderFields()) {
 469             if (name.equals(headerField.getName())) {
 470                 return headerField;
 471             }
 472         }
 473         return null;
 474     }
 475 
 476     public boolean isEmpty() {
 477         return records.isEmpty();
 478     }
 479 
 480     public List&lt;ListGridRecord&gt; getRecords() {
 481         return records;
 482     }
 483 
 484     public void setRecords(List&lt;ListGridRecord&gt; records) {
 485         this.records = records;
 486     }
 487 
 488     public List&lt;ListGridAction&gt; getToolbarActions() {
 489         return toolbarActions;
 490     }
 491 
 492     public void setToolbarActions(List&lt;ListGridAction&gt; toolbarActions) {
 493         this.toolbarActions = toolbarActions;
 494     }
 495 
 496     public List&lt;ListGridAction&gt; getRowActions() {
 497         return rowActions;
 498     }
 499 
 500     public void setRowActions(List&lt;ListGridAction&gt; rowActions) {
 501         this.rowActions = rowActions;
 502     }
 503 
 504     public List&lt;ListGridActionGroup&gt; getToolbarActionGroups() {
 505         return toolbarActionGroups;
 506     }
 507 
 508     public void setToolbarActionGroups(List&lt;ListGridActionGroup&gt; toolbarActionGroups) {
 509         this.toolbarActionGroups = toolbarActionGroups;
 510     }
 511 
 512     public List&lt;ListGridActionGroup&gt; getRowActionGroups() {
 513         return rowActionGroups;
 514     }
 515 
 516     public void setRowActionGroups(List&lt;ListGridActionGroup&gt; rowActionGroups) {
 517         this.rowActionGroups = rowActionGroups;
 518     }
 519 
 520     public List&lt;ListGridAction&gt; getModalRowActions() {
 521         return modalRowActions;
 522     }
 523 
 524     public void setModalRowActions(List&lt;ListGridAction&gt; modalRowActions) {
 525         this.modalRowActions = modalRowActions;
 526     }
 527 
 528     public int getStartIndex() {
 529         return startIndex;
 530     }
 531 
 532     public void setStartIndex(int startIndex) {
 533         this.startIndex = startIndex;
 534     }
 535 
 536     public int getTotalRecords() {
 537         return totalRecords;
 538     }
 539 
 540     public void setTotalRecords(int totalRecords) {
 541         this.totalRecords = totalRecords;
 542     }
 543 
 544     public int getPageSize() {
 545         return pageSize;
 546     }
 547 
 548     public void setPageSize(int pageSize) {
 549         this.pageSize = pageSize;
 550     }
 551 
 552     public void setCanFilterAndSort(Boolean canFilterAndSort) {
 553         this.canFilterAndSort = canFilterAndSort;
 554     }
 555 
 556     public AddMethodType getAddMethodType() {
 557         return addMethodType;
 558     }
 559 
 560     public void setAddMethodType(AddMethodType addMethodType) {
 561         this.addMethodType = addMethodType;
 562     }
 563 
 564     public String getListGridType() {
 565         return listGridType;
 566     }
 567 
 568     public String getSelectType() {
 569         return selectType;
 570     }
 571 
 572     public String getContainingEntityId() {
 573         return containingEntityId;
 574     }
 575 
 576     public void setContainingEntityId(String containingEntityId) {
 577         this.containingEntityId = containingEntityId;
 578     }
 579 
 580     public String getSubCollectionFieldName() {
 581         return subCollectionFieldName;
 582     }
 583 
 584     public void setSubCollectionFieldName(String subCollectionFieldName) {
 585         this.subCollectionFieldName = subCollectionFieldName;
 586     }
 587 
 588     public String getFriendlyName() {
 589         return friendlyName;
 590     }
 591 
 592     public void setFriendlyName(String friendlyName) {
 593         this.friendlyName = friendlyName;
 594     }
 595 
 596     public String getSectionKey() {
 597         return sectionKey;
 598     }
 599 
 600     public void setSectionKey(String sectionKey) {
 601         this.sectionKey = sectionKey;
 602     }
 603 
 604     public String getSelectizeUrl() {
 605         return selectizeUrl;
 606     }
 607 
 608     public void setSelectizeUrl(String selectizeUrl) {
 609         this.selectizeUrl = selectizeUrl;
 610     }
 611 
 612     public Boolean getManualFetch() {
 613         if (manualFetch == null) {
 614             return false;
 615         }
 616         return manualFetch;
 617     }
 618 
 619     public void setManualFetch(Boolean manualFetch) {
 620         this.manualFetch = manualFetch;
 621     }
 622 
 623     public String getExternalEntitySectionKey() {
 624         return externalEntitySectionKey;
 625     }
 626 
 627     public void setExternalEntitySectionKey(String externalEntitySectionKey) {
 628         this.externalEntitySectionKey = externalEntitySectionKey;
 629     }
 630 
 631     public String getPathOverride() {
 632         return pathOverride;
 633     }
 634 
 635     public void setPathOverride(String pathOverride) {
 636         this.pathOverride = pathOverride;
 637     }
 638 
 639     public String getSearchFieldsTemplateOverride() {
 640         return searchFieldsTemplateOverride;
 641     }
 642 
 643     public void setSearchFieldsTemplateOverride(String searchFieldsTemplateOverride) {
 644         this.searchFieldsTemplateOverride = searchFieldsTemplateOverride;
 645     }
 646 
 647     public String getTemplateOverride() {
 648         return templateOverride;
 649     }
 650 
 651     public void setTemplateOverride(String templateOverride) {
 652         this.templateOverride = templateOverride;
 653     }
 654 
 655     public void setIsReadOnly(Boolean readOnly) {
 656         this.isReadOnly = readOnly;
 657     }
 658 
 659     public void setHideIdColumn(Boolean hideIdColumn) {
 660         this.hideIdColumn = hideIdColumn;
 661     }
 662 
 663     public List&lt;SectionCrumb&gt; getSectionCrumbs() {
 664         return sectionCrumbs;
 665     }
 666 
 667     public void setSectionCrumbs(List&lt;SectionCrumb&gt; sectionCrumbs) {
 668         if (sectionCrumbs == null) {
 669             this.sectionCrumbs.clear();
 670             return;
 671         }
 672         this.sectionCrumbs = sectionCrumbs;
 673     }
 674 
 675     public String getFieldBuilder() {
 676         return fieldBuilder;
 677     }
 678 
 679     public void setFieldBuilder(String fieldBuilder) {
 680         this.fieldBuilder = fieldBuilder;
 681     }
 682 
 683     public FieldWrapper getFieldWrapper() {
 684         return fieldWrapper;
 685     }
 686 
 687     public void setFieldWrapper(FieldWrapper fieldWrapper) {
 688         this.fieldWrapper = fieldWrapper;
 689     }
 690 
 691     public DataWrapper getDataWrapper() {
 692         return dataWrapper;
 693     }
 694 
 695     public void setDataWrapper(DataWrapper dataWrapper) {
 696         this.dataWrapper = dataWrapper;
 697     }
 698 
 699     public String getJson() {
 700         return json;
 701     }
 702 
 703     public void setJson(String json) {
 704         this.json = json;
 705     }
 706 
 707     public String getJsonFieldName() {
 708         return jsonFieldName;
 709     }
 710 
 711     public void setJsonFieldName(String jsonFieldName) {
 712         this.jsonFieldName = jsonFieldName;
 713     }
 714 
 715     public String getFetchType() {
 716         return fetchType;
 717     }
 718 
 719     public void setFetchType(String fetchType) {
 720         this.fetchType = fetchType;
 721     }
 722 
 723     public long getFirstId() {
 724         return firstId;
 725     }
 726 
 727     public void setFirstId(long firstId) {
 728         this.firstId = firstId;
 729     }
 730 
 731     public long getLastId() {
 732         return lastId;
 733     }
 734 
 735     public void setLastId(long lastId) {
 736         this.lastId = lastId;
 737     }
 738 
 739     public int getUpperCount() {
 740         return upperCount;
 741     }
 742 
 743     public void setUpperCount(int upperCount) {
 744         this.upperCount = upperCount;
 745     }
 746 
 747     public int getLowerCount() {
 748         return lowerCount;
 749     }
 750 
 751     public void setLowerCount(int lowerCount) {
 752         this.lowerCount = lowerCount;
 753     }
 754 
 755     public boolean isTotalCountLessThanPageSize() {
 756         return totalCountLessThanPageSize;
 757     }
 758 
 759     public void setTotalCountLessThanPageSize(boolean totalCountLessThanPageSize) {
 760         this.totalCountLessThanPageSize = totalCountLessThanPageSize;
 761     }
 762 
 763     public boolean isPromptSearch() {
 764         return promptSearch;
 765     }
 766 
 767     public void setPromptSearch(boolean promptSearch) {
 768         this.promptSearch = promptSearch;
 769     }
 770 
 771     public String getHelpText() { return helpText; }
 772 
 773     public void setHelpText(String helpText) { this.helpText = helpText; }
 774 
 775     public boolean isMultiSelectCheckBoxOnly() {
 776         return multiSelectCheckBoxOnly;
 777     }
 778 
 779     public void setMultiSelectCheckBoxOnly(boolean multiSelectCheckBoxOnly) {
 780         this.multiSelectCheckBoxOnly = multiSelectCheckBoxOnly;
 781     }
 782 
 783     /* ***************************** */
 784     /* CSS CLASSES GETTERS / SETTERS */
 785     /* ***************************** */
 786 
 787     public void addCssClass(String className) {
 788         this.cssClasses.add(className);
 789     }
 790 
 791     public void removeCssClass(String className) {
 792         this.cssClasses.remove(className);
 793     }
 794 
 795     public void clearCssClasses() {
 796         this.cssClasses.clear();
 797     }
 798 
 799     public String getCssClassNames() {
 800         return StringUtils.join(this.cssClasses, &quot; &quot;);
 801     }
 802 
 803 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.web.form.component;
  19 
  20 import java.util.*;
  21 import org.apache.commons.collections.CollectionUtils;
  22 import org.apache.commons.lang3.StringUtils;
  23 import org.apache.commons.lang3.builder.CompareToBuilder;
  24 import org.broadleafcommerce.common.presentation.client.AddMethodType;
  25 import org.broadleafcommerce.common.util.TypedPredicate;
  26 import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  27 import org.broadleafcommerce.openadmin.server.service.type.FetchType;
  28 import org.broadleafcommerce.openadmin.web.form.entity.Field;
  29 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.DataWrapper;
  30 import org.broadleafcommerce.openadmin.web.rulebuilder.dto.FieldWrapper;
  31 
  32 
  33 public class ListGrid {
  34     // We may have cases, when className not set.
  35     // In that case we need to initialize field with empty string,
  36     // to prevent &quot;null&quot; as css class for ListGrid
  37     protected String className = &quot;&quot;;
  38 
  39     protected String friendlyName = null;
  40 
  41     protected String idProperty;
  42 
  43     protected int order;
  44 
  45     protected boolean isSortable;
  46 
  47     protected boolean hideFriendlyName;
  48 
  49     protected Set&lt;Field&gt; headerFields = new TreeSet&lt;Field&gt;(new Comparator&lt;Field&gt;() {
  50         @Override
  51         public int compare(Field o1, Field o2) {
<abbr title="  52             return new CompareToBuilder().append(o1.getOrder(), o2.getOrder()).append(o1.getFriendlyName(), o2.getFriendlyName()).append(o1.getName(), o2.getName()).toComparison();">  52             return new CompareToBuilder().append(o1.getOrder(), o2.getOrder()).append(o1.getFriendlyName(ðŸ”µ</abbr>
  53         }
  54     });
  55 
  56     protected List&lt;ListGridRecord&gt; records = new ArrayList&lt;ListGridRecord&gt;();
  57 
  58     protected List&lt;ListGridAction&gt; toolbarActions = new ArrayList&lt;ListGridAction&gt;();
  59 
<abbr title="  60     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  60     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  61     protected List&lt;ListGridAction&gt; rowActions = new ArrayList&lt;ListGridAction&gt;();
  62 
  63     protected List&lt;ListGridActionGroup&gt; toolbarActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  64 
  65     protected List&lt;ListGridActionGroup&gt; rowActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  66 
<abbr title="  67     // These actions will start greyed out and unable to be clicked until a specific row has been selected">  67     // These actions will start greyed out and unable to be clicked until a specific row has been selecteðŸ”µ</abbr>
  68     protected List&lt;ListGridAction&gt; modalRowActions = new ArrayList&lt;ListGridAction&gt;();
  69 
  70     private Set&lt;String&gt; cssClasses = new HashSet&lt;&gt;();
  71 
  72     protected int totalRecords;
  73 
  74     protected int startIndex;
  75 
  76     protected int pageSize;
  77 
  78     protected Boolean canFilterAndSort;
  79 
  80     protected Boolean isReadOnly;
  81 
  82     protected Boolean hideIdColumn;
  83 
  84     protected String fetchType = FetchType.DEFAULT.toString();
  85 
  86     protected long firstId;
  87 
  88     protected long lastId;
  89 
  90     protected int upperCount;
  91 
  92     protected int lowerCount;
  93 
  94     protected boolean totalCountLessThanPageSize;
  95 
  96     protected boolean promptSearch;
  97 
  98     // If true, only clicking the check box area will toggle the row selection when using multi select
  99     protected boolean multiSelectCheckBoxOnly;
 100 
 101     protected AddMethodType addMethodType;
 102 
 103     protected String listGridType;
 104 
 105     protected String selectType;
 106 
 107     protected String selectizeUrl;
 108 
 109     protected Boolean manualFetch;
 110 
 111     protected String helpText;
 112 
 113     // The section url that maps to this particular list grid
 114     // The section url that maps to this particular list grid
 115     protected String sectionKey;
 116 
<abbr title=" 117     // The list of all section keys that have been traversed to arrive at this ListGrid (including the current one), in order"> 117     // The list of all section keys that have been traversed to arrive at this ListGrid (including the cuðŸ”µ</abbr>
 118     // of occurrence
 119     protected List&lt;SectionCrumb&gt; sectionCrumbs = new ArrayList&lt;SectionCrumb&gt;();
 120 
<abbr title=" 121     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these properties"> 121     // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these prðŸ”µ</abbr>
 122     // help identify the parent entity.
 123     protected String externalEntitySectionKey;
 124 
 125     protected String containingEntityId;
 126 
 127     protected String subCollectionFieldName;
 128 
 129     protected String pathOverride;
 130 
 131     protected String searchFieldsTemplateOverride;
 132 
 133     protected String templateOverride;
 134 
 135     public enum Type {
 136 
 137         MAIN,
 138         TO_ONE,
 139         BASIC,
 140         ADORNED,
 141         ADORNED_WITH_FORM,
 142         MAP,
 143         TRANSLATION,
 144         ASSET,
 145         WORKFLOW,
 146         TREE,
 147         ASSET_GRID,
 148         ASSET_GRID_FOLDER;}
 149 
 150     public enum SelectType {
 151 
 152         SINGLE_SELECT,
 153         MULTI_SELECT,
 154         SELECTIZE,
 155         NONE;}
 156 
 157     /* Filter Builder required Fields */
 158     protected String fieldBuilder;
 159 
 160     protected DataWrapper dataWrapper;
 161 
 162     protected String json;
 163 
 164     protected String jsonFieldName;
 165 
 166     protected FieldWrapper fieldWrapper;
 167 
 168     /* ************** */
 169     /* CUSTOM METHODS */
 170     /* ************** */
 171 
 172     public String getPath() {
 173         if (StringUtils.isNotBlank(pathOverride)) {
 174             return pathOverride;
 175         }
 176 
 177         StringBuilder sb = new StringBuilder();
 178 
 179         if (!getSectionKey().startsWith(&quot;/&quot;)) {
 180             sb.append(&quot;/&quot;);
 181         }
 182 
 183         sb.append(getSectionKey());
 184         if (getContainingEntityId() != null) {
 185             sb.append(&quot;/&quot;).append(getContainingEntityId());
 186         }
 187 
 188         if (StringUtils.isNotBlank(getSubCollectionFieldName())) {
 189             sb.append(&quot;/&quot;).append(getSubCollectionFieldName());
 190         }
 191 
 192         //to-one grids need a slightly different grid URL; these need to be appended with &#x27;select&#x27;
 193         //TODO: surely there&#x27;s a better way to do this besides just hardcoding the &#x27;select&#x27;?
 194         if (Type.TO_ONE.toString().toLowerCase().equals(listGridType)) {
 195             sb.append(&quot;/select&quot;);
 196         }
 197 
 198         return sb.toString();
 199     }
 200 
 201     public String getSectionCrumbRepresentation() {
 202         StringBuilder sb = new StringBuilder();
 203         if (!sectionCrumbs.isEmpty()) {
 204            sb.append(&quot;?sectionCrumbs=&quot;);
 205         }
 206         int index = 0;
 207         for (SectionCrumb section : sectionCrumbs) {
 208             sb.append(section.getSectionIdentifier());
 209             sb.append(&quot;--&quot;);
 210             sb.append(section.getSectionId());
 211             if (index &lt; sectionCrumbs.size()-1) {
 212                 sb.append(&quot;,&quot;);
 213             }
 214             index++;
 215         }
 216         return sb.toString();
 217     }
 218 
 219     /**
<abbr title=" 220      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as the listgrid"> 220      * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly sðŸ”µ</abbr>
 221      * and are thus shown on the screen
 222      */
 223     @SuppressWarnings(&quot;unchecked&quot;)
 224     public List&lt;ListGridAction&gt; getActiveToolbarActions() {
<abbr title=" 225         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 225         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;LiðŸ”µ</abbr>
 226             @Override
 227             public boolean eval(ListGridAction action) {
 228                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 229             }
 230         })));
 231     }
 232 
 233     /**
<abbr title=" 234      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 234      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 235      * and are thus shown on the screen
 236      */
 237     @SuppressWarnings(&quot;unchecked&quot;)
 238     public List&lt;ListGridAction&gt; getActiveRowActions() {
<abbr title=" 239         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 239         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGrðŸ”µ</abbr>
 240             @Override
 241             public boolean eval(ListGridAction action) {
 242                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 243             }
 244         })));
 245     }
 246 
 247     /**
<abbr title=" 248      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly state as the listgrid"> 248      * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same reaðŸ”µ</abbr>
 249      * and are thus shown on the screen
 250      */
 251     @SuppressWarnings(&quot;unchecked&quot;)
 252     public List&lt;ListGridAction&gt; getActiveToolbarActionGroups() {
<abbr title=" 253         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 253         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getToolbarActionGroups(), new TypedPredicaðŸ”µ</abbr>
 254             @Override
 255             public boolean eval(ListGridActionGroup actionGroup) {
 256                 boolean result = false;
 257                 for (ListGridAction action : actionGroup.getListGridActions()) {
 258                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 259                         result = true;
 260                     }
 261                 }
 262                 return result;
 263             }
 264         })));
 265     }
 266 
 267     /**
<abbr title=" 268      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state as the listgrid"> 268      * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonlðŸ”µ</abbr>
 269      * and are thus shown on the screen
 270      */
 271     @SuppressWarnings(&quot;unchecked&quot;)
 272     public List&lt;ListGridAction&gt; getActiveRowActionGroups() {
<abbr title=" 273         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 273         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;LðŸ”µ</abbr>
 274             @Override
 275             public boolean eval(ListGridActionGroup actionGroup) {
 276                 boolean result = false;
 277                 for (ListGridAction action : actionGroup.getListGridActions()) {
 278                     if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 279                         result = true;
 280                     }
 281                 }
 282                 return result;
 283             }
 284         })));
 285     }
 286 
 287     /**
<abbr title=" 288      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 288      * Grabs a filtered list of row actions filtered by whether or not they match the same readonly stateðŸ”µ</abbr>
 289      * and are thus shown on the screen
 290      */
 291     @SuppressWarnings(&quot;unchecked&quot;)
 292     public List&lt;ListGridAction&gt; getActiveModalRowActions() {
<abbr title=" 293         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 293         return ((List&lt;ListGridAction&gt;) (CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;LðŸ”µ</abbr>
 294             @Override
 295             public boolean eval(ListGridAction action) {
 296                 return action.getForListGridReadOnly().equals(getIsReadOnly());
 297             }
 298         })));
 299     }
 300 
 301     public void addRowAction(ListGridAction action) {
 302         getRowActions().add(action);
 303     }
 304 
 305     public void addModalRowAction(ListGridAction action) {
 306         getModalRowActions().add(action);
 307     }
 308 
 309     public void addToolbarAction(ListGridAction action) {
 310         getToolbarActions().add(action);
 311     }
 312 
 313     public void removeAllToolbarActions() {
 314         getToolbarActions().clear();
 315     }
 316 
 317     public void removeAllRowActions() {
 318         getRowActions().clear();
 319     }
 320 
 321     public void addToolbarActionGroup(ListGridActionGroup actionGroup) {
 322         getToolbarActionGroups().add(actionGroup);
 323     }
 324 
 325     public void removeAllToolbarActionGroups() {
 326         getToolbarActionGroups().clear();
 327     }
 328 
 329     public void addRowActionGroup(ListGridActionGroup actionGroup) {
 330         getRowActionGroups().add(actionGroup);
 331     }
 332 
 333     public void removeAllRowActionGroups() {
 334         getRowActionGroups().clear();
 335     }
 336 
 337     public void removeAllModalRowActions() {
 338         getModalRowActions().clear();
 339     }
 340 
 341     public ListGridAction findToolbarAction(String actionId) {
 342         for (ListGridAction action : getToolbarActions()) {
 343             if (action.getActionId().equals(actionId)) {
 344                 return action;
 345             }
 346         }
 347         for (ListGridActionGroup actionGroup : getToolbarActionGroups()) {
 348             for (ListGridAction action : actionGroup.getListGridActions()) {
 349                 if (action.getActionId().equals(actionId)) {
 350                     return action;
 351                 }
 352             }
 353         }
 354         return null;
 355     }
 356 
 357     public ListGridAction findRowAction(String actionId) {
 358         for (ListGridAction action : getRowActions()) {
 359             if (action.getActionId().equals(actionId)) {
 360                 return action;
 361             }
 362         }
 363         for (ListGridActionGroup actionGroup : getRowActionGroups()) {
 364             for (ListGridAction action : actionGroup.getListGridActions()) {
 365                 if (action.getActionId().equals(actionId)) {
 366                     return action;
 367                 }
 368             }
 369         }
 370         return null;
 371     }
 372 
 373     public ListGridAction findModalRowAction(String actionId) {
 374         for (ListGridAction action : getModalRowActions()) {
 375             if (action.getActionId().equals(actionId)) {
 376                 return action;
 377             }
 378         }
 379         return null;
 380     }
 381 
 382     /**
<abbr title=" 383      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, then the"> 383      * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordðŸ”µ</abbr>
 384      * sort functionality doesn&#x27;t make any sense.
 385      *
 386      * Also, map structures are currently unsortable.
 387      *
 388      * @return
 389      */
 390     public boolean isSortable() {
 391         return this.isSortable || Type.MAP.toString().toLowerCase().equals(getListGridType());
 392     }
 393 
 394     /* ************************ */
 395     /* CUSTOM GETTERS / SETTERS */
 396     /* ************************ */
 397 
 398     public void setListGridType(Type listGridType) {
 399         this.listGridType = listGridType.toString().toLowerCase();
 400     }
 401 
 402     /**
<abbr title=" 403      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to on the JS"> 403      * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlðŸ”µ</abbr>
 404      * side
 405      * @param listGridType
 406      */
 407     public void setListGridTypeString(String listGridType) {
 408         this.listGridType = listGridType;
 409     }
 410 
 411     public void setSelectType(SelectType selectType) {
 412         this.selectType = selectType.toString().toLowerCase();
 413     }
 414 
 415     public void setSelectTypeString(String selectType) {
 416         this.selectType = selectType;
 417     }
 418 
 419     public Boolean getCanFilterAndSort() {
 420         return (canFilterAndSort == null ? true : canFilterAndSort);
 421     }
 422 
 423     public Boolean getIsReadOnly() {
 424         return isReadOnly == null ? false : isReadOnly;
 425     }
 426 
 427     public Boolean getClickable() {
 428         return !&quot;none&quot;.equals(selectType);
 429     }
 430 
 431     public Boolean getHideIdColumn() {
 432         return hideIdColumn == null ? true : hideIdColumn;
 433     }
 434 
 435     /* ************************** */
 436     /* STANDARD GETTERS / SETTERS */
 437     /* ************************** */
 438 
 439     	public String getIdProperty() {
 440         return idProperty;
 441     }
 442 
 443     public void setIdProperty(String idProperty) {
 444         this.idProperty = idProperty;
 445     }
 446 
 447     public String getClassName() {
 448         return className;
 449     }
 450 
 451     public void setClassName(String className) {
 452         this.className = className;
 453     }
 454 
 455     public int getOrder() {
 456         return order;
 457     }
 458 
 459     public void setOrder(int order) {
 460         this.order = order;
 461     }
 462 
 463     public boolean getIsSortable() {
 464         return isSortable;
 465     }
 466 
 467     public void setIsSortable(boolean isSortable) {
 468         this.isSortable = isSortable;
 469     }
 470 
 471     public boolean getHideFriendlyName() { return hideFriendlyName; }
 472 
<abbr title=" 473     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName; }"> 473     public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName;ðŸ”µ</abbr>
 474 
 475     public Set&lt;Field&gt; getHeaderFields() {
 476         return headerFields;
 477     }
 478 
 479     public void setHeaderFields(Set&lt;Field&gt; headerFields) {
 480         this.headerFields = headerFields;
 481     }
 482 
 483     public Field findHeaderField(String name) {
 484         if (name == null) {
 485             return null;
 486         }
 487 
 488         for (Field headerField : getHeaderFields()) {
 489             if (name.equals(headerField.getName())) {
 490                 return headerField;
 491             }
 492         }
 493         return null;
 494     }
 495 
 496     public boolean isEmpty() {
 497         return records.isEmpty();
 498     }
 499 
 500     public List&lt;ListGridRecord&gt; getRecords() {
 501         return records;
 502     }
 503 
 504     public void setRecords(List&lt;ListGridRecord&gt; records) {
 505         this.records = records;
 506     }
 507 
 508     public List&lt;ListGridAction&gt; getToolbarActions() {
 509         return toolbarActions;
 510     }
 511 
 512     public void setToolbarActions(List&lt;ListGridAction&gt; toolbarActions) {
 513         this.toolbarActions = toolbarActions;
 514     }
 515 
 516     public List&lt;ListGridAction&gt; getRowActions() {
 517         return rowActions;
 518     }
 519 
 520     public void setRowActions(List&lt;ListGridAction&gt; rowActions) {
 521         this.rowActions = rowActions;
 522     }
 523 
 524     public List&lt;ListGridActionGroup&gt; getToolbarActionGroups() {
 525         return toolbarActionGroups;
 526     }
 527 
 528     public void setToolbarActionGroups(List&lt;ListGridActionGroup&gt; toolbarActionGroups) {
 529         this.toolbarActionGroups = toolbarActionGroups;
 530     }
 531 
 532     public List&lt;ListGridActionGroup&gt; getRowActionGroups() {
 533         return rowActionGroups;
 534     }
 535 
 536     public void setRowActionGroups(List&lt;ListGridActionGroup&gt; rowActionGroups) {
 537         this.rowActionGroups = rowActionGroups;
 538     }
 539 
 540     public List&lt;ListGridAction&gt; getModalRowActions() {
 541         return modalRowActions;
 542     }
 543 
 544     public void setModalRowActions(List&lt;ListGridAction&gt; modalRowActions) {
 545         this.modalRowActions = modalRowActions;
 546     }
 547 
 548     public int getStartIndex() {
 549         return startIndex;
 550     }
 551 
 552     public void setStartIndex(int startIndex) {
 553         this.startIndex = startIndex;
 554     }
 555 
 556     public int getTotalRecords() {
 557         return totalRecords;
 558     }
 559 
 560     public void setTotalRecords(int totalRecords) {
 561         this.totalRecords = totalRecords;
 562     }
 563 
 564     public int getPageSize() {
 565         return pageSize;
 566     }
 567 
 568     public void setPageSize(int pageSize) {
 569         this.pageSize = pageSize;
 570     }
 571 
 572     public void setCanFilterAndSort(Boolean canFilterAndSort) {
 573         this.canFilterAndSort = canFilterAndSort;
 574     }
 575 
 576     public AddMethodType getAddMethodType() {
 577         return addMethodType;
 578     }
 579 
 580     public void setAddMethodType(AddMethodType addMethodType) {
 581         this.addMethodType = addMethodType;
 582     }
 583 
 584     public String getListGridType() {
 585         return listGridType;
 586     }
 587 
 588     public String getSelectType() {
 589         return selectType;
 590     }
 591 
 592     public String getContainingEntityId() {
 593         return containingEntityId;
 594     }
 595 
 596     public void setContainingEntityId(String containingEntityId) {
 597         this.containingEntityId = containingEntityId;
 598     }
 599 
 600     public String getSubCollectionFieldName() {
 601         return subCollectionFieldName;
 602     }
 603 
 604     public void setSubCollectionFieldName(String subCollectionFieldName) {
 605         this.subCollectionFieldName = subCollectionFieldName;
 606     }
 607 
 608     public String getFriendlyName() {
 609         return friendlyName;
 610     }
 611 
 612     public void setFriendlyName(String friendlyName) {
 613         this.friendlyName = friendlyName;
 614     }
 615 
 616     public String getSectionKey() {
 617         return sectionKey;
 618     }
 619 
 620     public void setSectionKey(String sectionKey) {
 621         this.sectionKey = sectionKey;
 622     }
 623 
 624     public String getSelectizeUrl() {
 625         return selectizeUrl;
 626     }
 627 
 628     public void setSelectizeUrl(String selectizeUrl) {
 629         this.selectizeUrl = selectizeUrl;
 630     }
 631 
 632     public Boolean getManualFetch() {
 633         if (manualFetch == null) {
 634             return false;
 635         }
 636         return manualFetch;
 637     }
 638 
 639     public void setManualFetch(Boolean manualFetch) {
 640         this.manualFetch = manualFetch;
 641     }
 642 
 643     public String getExternalEntitySectionKey() {
 644         return externalEntitySectionKey;
 645     }
 646 
 647     public void setExternalEntitySectionKey(String externalEntitySectionKey) {
 648         this.externalEntitySectionKey = externalEntitySectionKey;
 649     }
 650 
 651     public String getPathOverride() {
 652         return pathOverride;
 653     }
 654 
 655     public void setPathOverride(String pathOverride) {
 656         this.pathOverride = pathOverride;
 657     }
 658 
 659     public String getSearchFieldsTemplateOverride() {
 660         return searchFieldsTemplateOverride;
 661     }
 662 
 663     public void setSearchFieldsTemplateOverride(String searchFieldsTemplateOverride) {
 664         this.searchFieldsTemplateOverride = searchFieldsTemplateOverride;
 665     }
 666 
 667     public String getTemplateOverride() {
 668         return templateOverride;
 669     }
 670 
 671     public void setTemplateOverride(String templateOverride) {
 672         this.templateOverride = templateOverride;
 673     }
 674 
 675     public void setIsReadOnly(Boolean readOnly) {
 676         this.isReadOnly = readOnly;
 677     }
 678 
 679     public void setHideIdColumn(Boolean hideIdColumn) {
 680         this.hideIdColumn = hideIdColumn;
 681     }
 682 
 683     public List&lt;SectionCrumb&gt; getSectionCrumbs() {
 684         return sectionCrumbs;
 685     }
 686 
 687     public void setSectionCrumbs(List&lt;SectionCrumb&gt; sectionCrumbs) {
 688         if (sectionCrumbs == null) {
 689             this.sectionCrumbs.clear();
 690             return;
 691         }
 692         this.sectionCrumbs = sectionCrumbs;
 693     }
 694 
 695     public String getFieldBuilder() {
 696         return fieldBuilder;
 697     }
 698 
 699     public void setFieldBuilder(String fieldBuilder) {
 700         this.fieldBuilder = fieldBuilder;
 701     }
 702 
 703     public FieldWrapper getFieldWrapper() {
 704         return fieldWrapper;
 705     }
 706 
 707     public void setFieldWrapper(FieldWrapper fieldWrapper) {
 708         this.fieldWrapper = fieldWrapper;
 709     }
 710 
 711     public DataWrapper getDataWrapper() {
 712         return dataWrapper;
 713     }
 714 
 715     public void setDataWrapper(DataWrapper dataWrapper) {
 716         this.dataWrapper = dataWrapper;
 717     }
 718 
 719     public String getJson() {
 720         return json;
 721     }
 722 
 723     public void setJson(String json) {
 724         this.json = json;
 725     }
 726 
 727     public String getJsonFieldName() {
 728         return jsonFieldName;
 729     }
 730 
 731     public void setJsonFieldName(String jsonFieldName) {
 732         this.jsonFieldName = jsonFieldName;
 733     }
 734 
 735     public String getFetchType() {
 736         return fetchType;
 737     }
 738 
 739     public void setFetchType(String fetchType) {
 740         this.fetchType = fetchType;
 741     }
 742 
 743     public long getFirstId() {
 744         return firstId;
 745     }
 746 
 747     public void setFirstId(long firstId) {
 748         this.firstId = firstId;
 749     }
 750 
 751     public long getLastId() {
 752         return lastId;
 753     }
 754 
 755     public void setLastId(long lastId) {
 756         this.lastId = lastId;
 757     }
 758 
 759     public int getUpperCount() {
 760         return upperCount;
 761     }
 762 
 763     public void setUpperCount(int upperCount) {
 764         this.upperCount = upperCount;
 765     }
 766 
 767     public int getLowerCount() {
 768         return lowerCount;
 769     }
 770 
 771     public void setLowerCount(int lowerCount) {
 772         this.lowerCount = lowerCount;
 773     }
 774 
 775     public boolean isTotalCountLessThanPageSize() {
 776         return totalCountLessThanPageSize;
 777     }
 778 
 779     public void setTotalCountLessThanPageSize(boolean totalCountLessThanPageSize) {
 780         this.totalCountLessThanPageSize = totalCountLessThanPageSize;
 781     }
 782 
 783     public boolean isPromptSearch() {
 784         return promptSearch;
 785     }
 786 
 787     public void setPromptSearch(boolean promptSearch) {
 788         this.promptSearch = promptSearch;
 789     }
 790 
 791     public String getHelpText() { return helpText; }
 792 
 793     public void setHelpText(String helpText) { this.helpText = helpText; }
 794 
 795     public boolean isMultiSelectCheckBoxOnly() {
 796         return multiSelectCheckBoxOnly;
 797     }
 798 
 799     public void setMultiSelectCheckBoxOnly(boolean multiSelectCheckBoxOnly) {
 800         this.multiSelectCheckBoxOnly = multiSelectCheckBoxOnly;
 801     }
 802 
 803     /* ***************************** */
 804     /* CSS CLASSES GETTERS / SETTERS */
 805     /* ***************************** */
 806 
 807     public void addCssClass(String className) {
 808         this.cssClasses.add(className);
 809     }
 810 
 811     public void removeCssClass(String className) {
 812         this.cssClasses.remove(className);
 813     }
 814 
 815     public void clearCssClasses() {
 816         this.cssClasses.clear();
 817     }
 818 
 819     public String getCssClassNames() {
 820         return StringUtils.join(this.cssClasses, &quot; &quot;);
 821     }
 822 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.web.form.component;
  20  
  21  import org.apache.commons.collections.CollectionUtils;
  22  import org.apache.commons.lang3.StringUtils;
  23  import org.apache.commons.lang3.builder.CompareToBuilder;
  24  import org.broadleafcommerce.common.presentation.client.AddMethodType;
  25  import org.broadleafcommerce.common.util.TypedPredicate;
  26  import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  27  import org.broadleafcommerce.openadmin.server.service.type.FetchType;
  28  import org.broadleafcommerce.openadmin.web.form.entity.Field;
  29  import org.broadleafcommerce.openadmin.web.rulebuilder.dto.DataWrapper;
  30  import org.broadleafcommerce.openadmin.web.rulebuilder.dto.FieldWrapper;
  31  
  32  import java.util.ArrayList;
  33  import java.util.Comparator;
  34  import java.util.List;
  35  import java.util.Set;
  36  import java.util.TreeSet;

  37  
  38  public class ListGrid {
  39  
  40      protected String className;




  41      protected String friendlyName = null;
  42      protected String idProperty;
  43      protected int order;
  44      protected boolean isSortable;
  45  
  46      protected boolean hideFriendlyName;
  47  
  48      protected Set&lt;Field&gt; headerFields = new TreeSet&lt;Field&gt;(new Comparator&lt;Field&gt;() {
  49  
  50          @Override
  51          public int compare(Field o1, Field o2) {
  52              return new CompareToBuilder()
  53                      .append(o1.getOrder(), o2.getOrder())
  54                      .append(o1.getFriendlyName(), o2.getFriendlyName())
  55                      .append(o1.getName(), o2.getName())
  56                      .toComparison();
  57          }
  58      });
  59      protected List&lt;ListGridRecord&gt; records = new ArrayList&lt;ListGridRecord&gt;();
  60      protected List&lt;ListGridAction&gt; toolbarActions = new ArrayList&lt;ListGridAction&gt;();
  61  
  62      // These actions will start greyed out and unable to be clicked until a specific row has been selected
  63      protected List&lt;ListGridAction&gt; rowActions = new ArrayList&lt;ListGridAction&gt;();
  64  
  65      protected List&lt;ListGridActionGroup&gt; toolbarActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  66      protected List&lt;ListGridActionGroup&gt; rowActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  67  
  68      // These actions will start greyed out and unable to be clicked until a specific row has been selected
  69      protected List&lt;ListGridAction&gt; modalRowActions = new ArrayList&lt;ListGridAction&gt;();

  70      protected int totalRecords;
  71      protected int startIndex;
  72      protected int pageSize;
  73      protected Boolean canFilterAndSort;
  74      protected Boolean isReadOnly;
  75      protected Boolean hideIdColumn;
  76      protected String fetchType = FetchType.DEFAULT.toString();
  77      protected long firstId;
  78      protected long lastId;
  79      protected int upperCount;
  80      protected int lowerCount;
  81      protected boolean totalCountLessThanPageSize;
  82      protected boolean promptSearch;
  83  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +    // If true, only clicking the check box area will toggle the row selection when using multi select</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +    protected boolean multiSelectCheckBoxOnly;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +</span>
  87      protected AddMethodType addMethodType;
  88      protected String listGridType;
  89      protected String selectType;
  90  
  91      protected String selectizeUrl;
  92  
  93      protected Boolean manualFetch;
  94      protected String helpText;
  95  
  96      // The section url that maps to this particular list grid
  97      protected String sectionKey;
  98  
<abbr title="  99      // The list of all section keys that have been traversed to arrive at this ListGrid (including the current one), in order">  99      // The list of all section keys that have been traversed to arrive at this ListGrid (including the current oneðŸ”µ</abbr>
 100      // of occurrence
 101      protected List&lt;SectionCrumb&gt; sectionCrumbs = new ArrayList&lt;SectionCrumb&gt;();
 102  
 103      // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these properties
 104      // help identify the parent entity.
 105      protected String externalEntitySectionKey;
 106      protected String containingEntityId;
 107      protected String subCollectionFieldName;
 108      protected String pathOverride;
 109      protected String searchFieldsTemplateOverride;
 110      protected String templateOverride;
 111  
 112      public enum Type {
 113          MAIN,
 114          TO_ONE,
 115          BASIC,
 116          ADORNED,
 117          ADORNED_WITH_FORM,
 118          MAP,
 119          TRANSLATION,
 120          ASSET,
 121          WORKFLOW,
 122          TREE,
 123          ASSET_GRID,
 124          ASSET_GRID_FOLDER
 125      }
 126  
 127      public enum SelectType {
 128          SINGLE_SELECT,
 129          MULTI_SELECT,
 130          SELECTIZE,
 131          NONE
 132      }
 133  
 134      /* Filter Builder required Fields */
 135      protected String fieldBuilder;
 136      protected DataWrapper dataWrapper;
 137      protected String json;
 138      protected String jsonFieldName;
 139      protected FieldWrapper fieldWrapper;
 140  
 141  
 142  
 143      /* ************** */
 144      /* CUSTOM METHODS */
 145      /* ************** */
 146  
 147      public String getPath() {
 148          if (StringUtils.isNotBlank(pathOverride)) {
 149              return pathOverride;
 150          }
 151  
 152          StringBuilder sb = new StringBuilder();
 153  
 154          if (!getSectionKey().startsWith(&quot;/&quot;)) {
 155              sb.append(&quot;/&quot;);
 156          }
 157  
 158          sb.append(getSectionKey());
 159          if (getContainingEntityId() != null) {
 160              sb.append(&quot;/&quot;).append(getContainingEntityId());
 161          }
 162  
 163          if (StringUtils.isNotBlank(getSubCollectionFieldName())) {
 164              sb.append(&quot;/&quot;).append(getSubCollectionFieldName());
 165          }
 166  
 167          //to-one grids need a slightly different grid URL; these need to be appended with &#x27;select&#x27;
 168          //TODO: surely there&#x27;s a better way to do this besides just hardcoding the &#x27;select&#x27;?
 169          if (Type.TO_ONE.toString().toLowerCase().equals(listGridType)) {
 170              sb.append(&quot;/select&quot;);
 171          }
 172  
 173          return sb.toString();
 174      }
 175  
 176      public String getSectionCrumbRepresentation() {
 177          StringBuilder sb = new StringBuilder();
 178          if (!sectionCrumbs.isEmpty()) {
 179             sb.append(&quot;?sectionCrumbs=&quot;);
 180          }
 181          int index = 0;
 182          for (SectionCrumb section : sectionCrumbs) {
 183              sb.append(section.getSectionIdentifier());
 184              sb.append(&quot;--&quot;);
 185              sb.append(section.getSectionId());
 186              if (index &lt; sectionCrumbs.size()-1) {
 187                  sb.append(&quot;,&quot;);
 188              }
 189              index++;
 190          }
 191          return sb.toString();
 192      }
 193  
 194      /**
<abbr title=" 195       * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as the listgrid"> 195       * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as tðŸ”µ</abbr>
 196       * and are thus shown on the screen
 197       */
 198      @SuppressWarnings(&quot;unchecked&quot;)
 199      public List&lt;ListGridAction&gt; getActiveToolbarActions() {
<abbr title=" 200          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 200          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridActioðŸ”µ</abbr>
 201  
 202              @Override
 203              public boolean eval(ListGridAction action) {
 204                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 205              }
 206          });
 207      }
 208  
 209      /**
<abbr title=" 210       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 210       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the lðŸ”µ</abbr>
 211       * and are thus shown on the screen
 212       */
 213      @SuppressWarnings(&quot;unchecked&quot;)
 214      public List&lt;ListGridAction&gt; getActiveRowActions() {
<abbr title=" 215          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 215          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;()ðŸ”µ</abbr>
 216  
 217              @Override
 218              public boolean eval(ListGridAction action) {
 219                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 220              }
 221          });
 222      }
 223  
 224      /**
<abbr title=" 225       * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly state as the listgrid"> 225       * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly staðŸ”µ</abbr>
 226       * and are thus shown on the screen
 227       */
 228      @SuppressWarnings(&quot;unchecked&quot;)
 229      public List&lt;ListGridAction&gt; getActiveToolbarActionGroups() {
<abbr title=" 230          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 230          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridðŸ”µ</abbr>
 231  
 232              @Override
 233              public boolean eval(ListGridActionGroup actionGroup) {
 234                  boolean result = false;
 235                  for (ListGridAction action : actionGroup.getListGridActions()) {
 236                      if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 237                          result = true;
 238                      }
 239                  }
 240                  return result;
 241              }
 242          });
 243      }
 244  
 245      /**
<abbr title=" 246       * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state as the listgrid"> 246       * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state aðŸ”µ</abbr>
 247       * and are thus shown on the screen
 248       */
 249      @SuppressWarnings(&quot;unchecked&quot;)
 250      public List&lt;ListGridAction&gt; getActiveRowActionGroups() {
<abbr title=" 251          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 251          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActiðŸ”µ</abbr>
 252  
 253              @Override
 254              public boolean eval(ListGridActionGroup actionGroup) {
 255                  boolean result = false;
 256                  for (ListGridAction action : actionGroup.getListGridActions()) {
 257                      if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 258                          result = true;
 259                      }
 260                  }
 261                  return result;
 262              }
 263          });
 264      }
 265  
 266      /**
<abbr title=" 267       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 267       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the lðŸ”µ</abbr>
 268       * and are thus shown on the screen
 269       */
 270      @SuppressWarnings(&quot;unchecked&quot;)
 271      public List&lt;ListGridAction&gt; getActiveModalRowActions() {
<abbr title=" 272          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 272          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridActiðŸ”µ</abbr>
 273  
 274              @Override
 275              public boolean eval(ListGridAction action) {
 276                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 277              }
 278          });
 279      }
 280  
 281      public void addRowAction(ListGridAction action) {
 282          getRowActions().add(action);
 283      }
 284  
 285      public void addModalRowAction(ListGridAction action) {
 286          getModalRowActions().add(action);
 287      }
 288  
 289      public void addToolbarAction(ListGridAction action) {
 290          getToolbarActions().add(action);
 291      }
 292  
 293      public void removeAllToolbarActions() {
 294          getToolbarActions().clear();
 295      }
 296  
 297      public void removeAllRowActions() {
 298          getRowActions().clear();
 299      }
 300  
 301      public void addToolbarActionGroup(ListGridActionGroup actionGroup) {
 302          getToolbarActionGroups().add(actionGroup);
 303      }
 304  
 305      public void removeAllToolbarActionGroups() {
 306          getToolbarActionGroups().clear();
 307      }
 308  
 309      public void addRowActionGroup(ListGridActionGroup actionGroup) {
 310          getRowActionGroups().add(actionGroup);
 311      }
 312  
 313      public void removeAllRowActionGroups() {
 314          getRowActionGroups().clear();
 315      }
 316  
 317      public void removeAllModalRowActions() {
 318          getModalRowActions().clear();
 319      }
 320  
 321      public ListGridAction findToolbarAction(String actionId) {
 322          for (ListGridAction action : getToolbarActions()) {
 323              if (action.getActionId().equals(actionId)) {
 324                  return action;
 325              }
 326          }
 327          for (ListGridActionGroup actionGroup : getToolbarActionGroups()) {
 328              for (ListGridAction action : actionGroup.getListGridActions()) {
 329                  if (action.getActionId().equals(actionId)) {
 330                      return action;
 331                  }
 332              }
 333          }
 334          return null;
 335      }
 336  
 337      public ListGridAction findRowAction(String actionId) {
 338          for (ListGridAction action : getRowActions()) {
 339              if (action.getActionId().equals(actionId)) {
 340                  return action;
 341              }
 342          }
 343          for (ListGridActionGroup actionGroup : getRowActionGroups()) {
 344              for (ListGridAction action : actionGroup.getListGridActions()) {
 345                  if (action.getActionId().equals(actionId)) {
 346                      return action;
 347                  }
 348              }
 349          }
 350          return null;
 351      }
 352  
 353      public ListGridAction findModalRowAction(String actionId) {
 354          for (ListGridAction action : getModalRowActions()) {
 355              if (action.getActionId().equals(actionId)) {
 356                  return action;
 357              }
 358          }
 359          return null;
 360      }
 361  
 362      /**
<abbr title=" 363       * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, then the"> 363       * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, theðŸ”µ</abbr>
 364       * sort functionality doesn&#x27;t make any sense.
 365       *
 366       * Also, map structures are currently unsortable.
 367       *
 368       * @return
 369       */
 370      public boolean isSortable() {
 371          return this.isSortable || Type.MAP.toString().toLowerCase().equals(getListGridType());
 372      }
 373  
 374      /* ************************ */
 375      /* CUSTOM GETTERS / SETTERS */
 376      /* ************************ */
 377  
 378      public void setListGridType(Type listGridType) {
 379          this.listGridType = listGridType.toString().toLowerCase();
 380      }
 381  
 382      /**
<abbr title=" 383       * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to on the JS"> 383       * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to onðŸ”µ</abbr>
 384       * side
 385       * @param listGridType
 386       */
 387      public void setListGridTypeString(String listGridType) {
 388          this.listGridType = listGridType;
 389      }
 390  
 391      public void setSelectType(SelectType selectType) {
 392          this.selectType = selectType.toString().toLowerCase();
 393      }
 394  
 395      public void setSelectTypeString(String selectType) {
 396          this.selectType = selectType;
 397      }
 398  
 399      public Boolean getCanFilterAndSort() {
 400          return (canFilterAndSort == null ? true : canFilterAndSort);
 401      }
 402  
 403      public Boolean getIsReadOnly() {
 404          return isReadOnly == null ? false : isReadOnly;
 405      }
 406  
 407      public Boolean getClickable() {
 408          return !&quot;none&quot;.equals(selectType);
 409      }
 410  
 411      public Boolean getHideIdColumn() {
 412          return hideIdColumn == null ? true : hideIdColumn;
 413      }
 414  
 415      /* ************************** */
 416      /* STANDARD GETTERS / SETTERS */
 417      /* ************************** */
 418  
 419  	public String getIdProperty() {
 420          return idProperty;
 421      }
 422  
 423      public void setIdProperty(String idProperty) {
 424          this.idProperty = idProperty;
 425      }
 426  
 427      public String getClassName() {
 428          return className;
 429      }
 430  
 431      public void setClassName(String className) {
 432          this.className = className;
 433      }
 434  
 435      public int getOrder() {
 436          return order;
 437      }
 438  
 439      public void setOrder(int order) {
 440          this.order = order;
 441      }
 442  
 443      public boolean getIsSortable() {
 444          return isSortable;
 445      }
 446  
 447      public void setIsSortable(boolean isSortable) {
 448          this.isSortable = isSortable;
 449      }
 450  
 451      public boolean getHideFriendlyName() { return hideFriendlyName; }
 452  
 453      public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName; }
 454  
 455      public Set&lt;Field&gt; getHeaderFields() {
 456          return headerFields;
 457      }
 458  
 459      public void setHeaderFields(Set&lt;Field&gt; headerFields) {
 460          this.headerFields = headerFields;
 461      }
 462  
 463      public Field findHeaderField(String name) {
 464          if (name == null) {
 465              return null;
 466          }
 467  
 468          for (Field headerField : getHeaderFields()) {
 469              if (name.equals(headerField.getName())) {
 470                  return headerField;
 471              }
 472          }
 473          return null;
 474      }
 475  
 476      public boolean isEmpty() {
 477          return records.isEmpty();
 478      }
 479  
 480      public List&lt;ListGridRecord&gt; getRecords() {
 481          return records;
 482      }
 483  
 484      public void setRecords(List&lt;ListGridRecord&gt; records) {
 485          this.records = records;
 486      }
 487  
 488      public List&lt;ListGridAction&gt; getToolbarActions() {
 489          return toolbarActions;
 490      }
 491  
 492      public void setToolbarActions(List&lt;ListGridAction&gt; toolbarActions) {
 493          this.toolbarActions = toolbarActions;
 494      }
 495  
 496      public List&lt;ListGridAction&gt; getRowActions() {
 497          return rowActions;
 498      }
 499  
 500      public void setRowActions(List&lt;ListGridAction&gt; rowActions) {
 501          this.rowActions = rowActions;
 502      }
 503  
 504      public List&lt;ListGridActionGroup&gt; getToolbarActionGroups() {
 505          return toolbarActionGroups;
 506      }
 507  
 508      public void setToolbarActionGroups(List&lt;ListGridActionGroup&gt; toolbarActionGroups) {
 509          this.toolbarActionGroups = toolbarActionGroups;
 510      }
 511  
 512      public List&lt;ListGridActionGroup&gt; getRowActionGroups() {
 513          return rowActionGroups;
 514      }
 515  
 516      public void setRowActionGroups(List&lt;ListGridActionGroup&gt; rowActionGroups) {
 517          this.rowActionGroups = rowActionGroups;
 518      }
 519  
 520      public List&lt;ListGridAction&gt; getModalRowActions() {
 521          return modalRowActions;
 522      }
 523  
 524      public void setModalRowActions(List&lt;ListGridAction&gt; modalRowActions) {
 525          this.modalRowActions = modalRowActions;
 526      }
 527  
 528      public int getStartIndex() {
 529          return startIndex;
 530      }
 531  
 532      public void setStartIndex(int startIndex) {
 533          this.startIndex = startIndex;
 534      }
 535  
 536      public int getTotalRecords() {
 537          return totalRecords;
 538      }
 539  
 540      public void setTotalRecords(int totalRecords) {
 541          this.totalRecords = totalRecords;
 542      }
 543  
 544      public int getPageSize() {
 545          return pageSize;
 546      }
 547  
 548      public void setPageSize(int pageSize) {
 549          this.pageSize = pageSize;
 550      }
 551  
 552      public void setCanFilterAndSort(Boolean canFilterAndSort) {
 553          this.canFilterAndSort = canFilterAndSort;
 554      }
 555  
 556      public AddMethodType getAddMethodType() {
 557          return addMethodType;
 558      }
 559  
 560      public void setAddMethodType(AddMethodType addMethodType) {
 561          this.addMethodType = addMethodType;
 562      }
 563  
 564      public String getListGridType() {
 565          return listGridType;
 566      }
 567  
 568      public String getSelectType() {
 569          return selectType;
 570      }
 571  
 572      public String getContainingEntityId() {
 573          return containingEntityId;
 574      }
 575  
 576      public void setContainingEntityId(String containingEntityId) {
 577          this.containingEntityId = containingEntityId;
 578      }
 579  
 580      public String getSubCollectionFieldName() {
 581          return subCollectionFieldName;
 582      }
 583  
 584      public void setSubCollectionFieldName(String subCollectionFieldName) {
 585          this.subCollectionFieldName = subCollectionFieldName;
 586      }
 587  
 588      public String getFriendlyName() {
 589          return friendlyName;
 590      }
 591  
 592      public void setFriendlyName(String friendlyName) {
 593          this.friendlyName = friendlyName;
 594      }
 595  
 596      public String getSectionKey() {
 597          return sectionKey;
 598      }
 599  
 600      public void setSectionKey(String sectionKey) {
 601          this.sectionKey = sectionKey;
 602      }
 603  
 604      public String getSelectizeUrl() {
 605          return selectizeUrl;
 606      }
 607  
 608      public void setSelectizeUrl(String selectizeUrl) {
 609          this.selectizeUrl = selectizeUrl;
 610      }
 611  
 612      public Boolean getManualFetch() {
 613          if (manualFetch == null) {
 614              return false;
 615          }
 616          return manualFetch;
 617      }
 618  
 619      public void setManualFetch(Boolean manualFetch) {
 620          this.manualFetch = manualFetch;
 621      }
 622  
 623      public String getExternalEntitySectionKey() {
 624          return externalEntitySectionKey;
 625      }
 626  
 627      public void setExternalEntitySectionKey(String externalEntitySectionKey) {
 628          this.externalEntitySectionKey = externalEntitySectionKey;
 629      }
 630  
 631      public String getPathOverride() {
 632          return pathOverride;
 633      }
 634  
 635      public void setPathOverride(String pathOverride) {
 636          this.pathOverride = pathOverride;
 637      }
 638  
 639      public String getSearchFieldsTemplateOverride() {
 640          return searchFieldsTemplateOverride;
 641      }
 642  
 643      public void setSearchFieldsTemplateOverride(String searchFieldsTemplateOverride) {
 644          this.searchFieldsTemplateOverride = searchFieldsTemplateOverride;
 645      }
 646  
 647      public String getTemplateOverride() {
 648          return templateOverride;
 649      }
 650  
 651      public void setTemplateOverride(String templateOverride) {
 652          this.templateOverride = templateOverride;
 653      }
 654  
 655      public void setIsReadOnly(Boolean readOnly) {
 656          this.isReadOnly = readOnly;
 657      }
 658  
 659      public void setHideIdColumn(Boolean hideIdColumn) {
 660          this.hideIdColumn = hideIdColumn;
 661      }
 662  
 663      public List&lt;SectionCrumb&gt; getSectionCrumbs() {
 664          return sectionCrumbs;
 665      }
 666  
 667      public void setSectionCrumbs(List&lt;SectionCrumb&gt; sectionCrumbs) {
 668          if (sectionCrumbs == null) {
 669              this.sectionCrumbs.clear();
 670              return;
 671          }
 672          this.sectionCrumbs = sectionCrumbs;
 673      }
 674  
 675      public String getFieldBuilder() {
 676          return fieldBuilder;
 677      }
 678  
 679      public void setFieldBuilder(String fieldBuilder) {
 680          this.fieldBuilder = fieldBuilder;
 681      }
 682  
 683      public FieldWrapper getFieldWrapper() {
 684          return fieldWrapper;
 685      }
 686  
 687      public void setFieldWrapper(FieldWrapper fieldWrapper) {
 688          this.fieldWrapper = fieldWrapper;
 689      }
 690  
 691      public DataWrapper getDataWrapper() {
 692          return dataWrapper;
 693      }
 694  
 695      public void setDataWrapper(DataWrapper dataWrapper) {
 696          this.dataWrapper = dataWrapper;
 697      }
 698  
 699      public String getJson() {
 700          return json;
 701      }
 702  
 703      public void setJson(String json) {
 704          this.json = json;
 705      }
 706  
 707      public String getJsonFieldName() {
 708          return jsonFieldName;
 709      }
 710  
 711      public void setJsonFieldName(String jsonFieldName) {
 712          this.jsonFieldName = jsonFieldName;
 713      }
 714  
 715      public String getFetchType() {
 716          return fetchType;
 717      }
 718  
 719      public void setFetchType(String fetchType) {
 720          this.fetchType = fetchType;
 721      }
 722  
 723      public long getFirstId() {
 724          return firstId;
 725      }
 726  
 727      public void setFirstId(long firstId) {
 728          this.firstId = firstId;
 729      }
 730  
 731      public long getLastId() {
 732          return lastId;
 733      }
 734  
 735      public void setLastId(long lastId) {
 736          this.lastId = lastId;
 737      }
 738  
 739      public int getUpperCount() {
 740          return upperCount;
 741      }
 742  
 743      public void setUpperCount(int upperCount) {
 744          this.upperCount = upperCount;
 745      }
 746  
 747      public int getLowerCount() {
 748          return lowerCount;
 749      }
 750  
 751      public void setLowerCount(int lowerCount) {
 752          this.lowerCount = lowerCount;
 753      }
 754  
 755      public boolean isTotalCountLessThanPageSize() {
 756          return totalCountLessThanPageSize;
 757      }
 758  
 759      public void setTotalCountLessThanPageSize(boolean totalCountLessThanPageSize) {
 760          this.totalCountLessThanPageSize = totalCountLessThanPageSize;
 761      }
 762  
 763      public boolean isPromptSearch() {
 764          return promptSearch;
 765      }
 766  
 767      public void setPromptSearch(boolean promptSearch) {
 768          this.promptSearch = promptSearch;
 769      }
 770  
 771      public String getHelpText() { return helpText; }
 772  
 773      public void setHelpText(String helpText) { this.helpText = helpText; }
 774  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 775 +    public boolean isMultiSelectCheckBoxOnly() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 776 +        return multiSelectCheckBoxOnly;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 777 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 778 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +    public void setMultiSelectCheckBoxOnly(boolean multiSelectCheckBoxOnly) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 780 +        this.multiSelectCheckBoxOnly = multiSelectCheckBoxOnly;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 781 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +</span>












 783  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.web.form.component;
  20  
  21  import org.apache.commons.collections.CollectionUtils;
  22  import org.apache.commons.lang3.StringUtils;
  23  import org.apache.commons.lang3.builder.CompareToBuilder;
  24  import org.broadleafcommerce.common.presentation.client.AddMethodType;
  25  import org.broadleafcommerce.common.util.TypedPredicate;
  26  import org.broadleafcommerce.openadmin.dto.SectionCrumb;
  27  import org.broadleafcommerce.openadmin.server.service.type.FetchType;
  28  import org.broadleafcommerce.openadmin.web.form.entity.Field;
  29  import org.broadleafcommerce.openadmin.web.rulebuilder.dto.DataWrapper;
  30  import org.broadleafcommerce.openadmin.web.rulebuilder.dto.FieldWrapper;
  31  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import java.util.Comparator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import java.util.Set;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import java.util.TreeSet;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import java.util.*;</span>
  38  
  39  public class ListGrid {
  40  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  41 -    protected String className;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +    // We may have cases, when className not set.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +    // In that case we need to initialize field with empty string,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +    // to prevent &quot;null&quot; as css class for ListGrid</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +    protected String className = &quot;&quot;;</span>
  46      protected String friendlyName = null;
  47      protected String idProperty;
  48      protected int order;
  49      protected boolean isSortable;
  50  
  51      protected boolean hideFriendlyName;
  52  
  53      protected Set&lt;Field&gt; headerFields = new TreeSet&lt;Field&gt;(new Comparator&lt;Field&gt;() {
  54  
  55          @Override
  56          public int compare(Field o1, Field o2) {
  57              return new CompareToBuilder()
  58                      .append(o1.getOrder(), o2.getOrder())
  59                      .append(o1.getFriendlyName(), o2.getFriendlyName())
  60                      .append(o1.getName(), o2.getName())
  61                      .toComparison();
  62          }
  63      });
  64      protected List&lt;ListGridRecord&gt; records = new ArrayList&lt;ListGridRecord&gt;();
  65      protected List&lt;ListGridAction&gt; toolbarActions = new ArrayList&lt;ListGridAction&gt;();
  66  
  67      // These actions will start greyed out and unable to be clicked until a specific row has been selected
  68      protected List&lt;ListGridAction&gt; rowActions = new ArrayList&lt;ListGridAction&gt;();
  69  
  70      protected List&lt;ListGridActionGroup&gt; toolbarActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  71      protected List&lt;ListGridActionGroup&gt; rowActionGroups = new ArrayList&lt;ListGridActionGroup&gt;();
  72  
  73      // These actions will start greyed out and unable to be clicked until a specific row has been selected
  74      protected List&lt;ListGridAction&gt; modalRowActions = new ArrayList&lt;ListGridAction&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +    private Set&lt;String&gt; cssClasses = new HashSet&lt;&gt;();</span>
  76      protected int totalRecords;
  77      protected int startIndex;
  78      protected int pageSize;
  79      protected Boolean canFilterAndSort;
  80      protected Boolean isReadOnly;
  81      protected Boolean hideIdColumn;
  82      protected String fetchType = FetchType.DEFAULT.toString();
  83      protected long firstId;
  84      protected long lastId;
  85      protected int upperCount;
  86      protected int lowerCount;
  87      protected boolean totalCountLessThanPageSize;
  88      protected boolean promptSearch;
  89  



  90      protected AddMethodType addMethodType;
  91      protected String listGridType;
  92      protected String selectType;
  93  
  94      protected String selectizeUrl;
  95  
  96      protected Boolean manualFetch;
  97      protected String helpText;
  98  
  99      // The section url that maps to this particular list grid
 100      protected String sectionKey;
 101  
<abbr title=" 102      // The list of all section keys that have been traversed to arrive at this ListGrid (including the current one), in order"> 102      // The list of all section keys that have been traversed to arrive at this ListGrid (including the current oneðŸ”µ</abbr>
 103      // of occurrence
 104      protected List&lt;SectionCrumb&gt; sectionCrumbs = new ArrayList&lt;SectionCrumb&gt;();
 105  
 106      // If this list grid is a sublistgrid, meaning it is rendered as part of a different entity, these properties
 107      // help identify the parent entity.
 108      protected String externalEntitySectionKey;
 109      protected String containingEntityId;
 110      protected String subCollectionFieldName;
 111      protected String pathOverride;
 112      protected String searchFieldsTemplateOverride;
 113      protected String templateOverride;
 114  
 115      public enum Type {
 116          MAIN,
 117          TO_ONE,
 118          BASIC,
 119          ADORNED,
 120          ADORNED_WITH_FORM,
 121          MAP,
 122          TRANSLATION,
 123          ASSET,
 124          WORKFLOW,
 125          TREE,
 126          ASSET_GRID,
 127          ASSET_GRID_FOLDER
 128      }
 129  
 130      public enum SelectType {
 131          SINGLE_SELECT,
 132          MULTI_SELECT,
 133          SELECTIZE,
 134          NONE
 135      }
 136  
 137      /* Filter Builder required Fields */
 138      protected String fieldBuilder;
 139      protected DataWrapper dataWrapper;
 140      protected String json;
 141      protected String jsonFieldName;
 142      protected FieldWrapper fieldWrapper;
 143  
 144  
 145  
 146      /* ************** */
 147      /* CUSTOM METHODS */
 148      /* ************** */
 149  
 150      public String getPath() {
 151          if (StringUtils.isNotBlank(pathOverride)) {
 152              return pathOverride;
 153          }
 154  
 155          StringBuilder sb = new StringBuilder();
 156  
 157          if (!getSectionKey().startsWith(&quot;/&quot;)) {
 158              sb.append(&quot;/&quot;);
 159          }
 160  
 161          sb.append(getSectionKey());
 162          if (getContainingEntityId() != null) {
 163              sb.append(&quot;/&quot;).append(getContainingEntityId());
 164          }
 165  
 166          if (StringUtils.isNotBlank(getSubCollectionFieldName())) {
 167              sb.append(&quot;/&quot;).append(getSubCollectionFieldName());
 168          }
 169  
 170          //to-one grids need a slightly different grid URL; these need to be appended with &#x27;select&#x27;
 171          //TODO: surely there&#x27;s a better way to do this besides just hardcoding the &#x27;select&#x27;?
 172          if (Type.TO_ONE.toString().toLowerCase().equals(listGridType)) {
 173              sb.append(&quot;/select&quot;);
 174          }
 175  
 176          return sb.toString();
 177      }
 178  
 179      public String getSectionCrumbRepresentation() {
 180          StringBuilder sb = new StringBuilder();
 181          if (!sectionCrumbs.isEmpty()) {
 182             sb.append(&quot;?sectionCrumbs=&quot;);
 183          }
 184          int index = 0;
 185          for (SectionCrumb section : sectionCrumbs) {
 186              sb.append(section.getSectionIdentifier());
 187              sb.append(&quot;--&quot;);
 188              sb.append(section.getSectionId());
 189              if (index &lt; sectionCrumbs.size()-1) {
 190                  sb.append(&quot;,&quot;);
 191              }
 192              index++;
 193          }
 194          return sb.toString();
 195      }
 196  
 197      /**
<abbr title=" 198       * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as the listgrid"> 198       * Grabs a filtered list of toolbar actions filtered by whether or not they match the same readonly state as tðŸ”µ</abbr>
 199       * and are thus shown on the screen
 200       */
 201      @SuppressWarnings(&quot;unchecked&quot;)
 202      public List&lt;ListGridAction&gt; getActiveToolbarActions() {
<abbr title=" 203          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 203          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActions(), new TypedPredicate&lt;ListGridActioðŸ”µ</abbr>
 204  
 205              @Override
 206              public boolean eval(ListGridAction action) {
 207                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 208              }
 209          });
 210      }
 211  
 212      /**
<abbr title=" 213       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 213       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the lðŸ”µ</abbr>
 214       * and are thus shown on the screen
 215       */
 216      @SuppressWarnings(&quot;unchecked&quot;)
 217      public List&lt;ListGridAction&gt; getActiveRowActions() {
<abbr title=" 218          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 218          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActions(), new TypedPredicate&lt;ListGridAction&gt;()ðŸ”µ</abbr>
 219  
 220              @Override
 221              public boolean eval(ListGridAction action) {
 222                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 223              }
 224          });
 225      }
 226  
 227      /**
<abbr title=" 228       * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly state as the listgrid"> 228       * Grabs a filtered list of toolbar action groupss filtered by whether or not they match the same readonly staðŸ”µ</abbr>
 229       * and are thus shown on the screen
 230       */
 231      @SuppressWarnings(&quot;unchecked&quot;)
 232      public List&lt;ListGridAction&gt; getActiveToolbarActionGroups() {
<abbr title=" 233          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 233          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getToolbarActionGroups(), new TypedPredicate&lt;ListGridðŸ”µ</abbr>
 234  
 235              @Override
 236              public boolean eval(ListGridActionGroup actionGroup) {
 237                  boolean result = false;
 238                  for (ListGridAction action : actionGroup.getListGridActions()) {
 239                      if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 240                          result = true;
 241                      }
 242                  }
 243                  return result;
 244              }
 245          });
 246      }
 247  
 248      /**
<abbr title=" 249       * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state as the listgrid"> 249       * Grabs a filtered list of row action groupss filtered by whether or not they match the same readonly state aðŸ”µ</abbr>
 250       * and are thus shown on the screen
 251       */
 252      @SuppressWarnings(&quot;unchecked&quot;)
 253      public List&lt;ListGridAction&gt; getActiveRowActionGroups() {
<abbr title=" 254          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActionGroup&gt;() {"> 254          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getRowActionGroups(), new TypedPredicate&lt;ListGridActiðŸ”µ</abbr>
 255  
 256              @Override
 257              public boolean eval(ListGridActionGroup actionGroup) {
 258                  boolean result = false;
 259                  for (ListGridAction action : actionGroup.getListGridActions()) {
 260                      if (action.getForListGridReadOnly().equals(getIsReadOnly())) {
 261                          result = true;
 262                      }
 263                  }
 264                  return result;
 265              }
 266          });
 267      }
 268  
 269      /**
<abbr title=" 270       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the listgrid"> 270       * Grabs a filtered list of row actions filtered by whether or not they match the same readonly state as the lðŸ”µ</abbr>
 271       * and are thus shown on the screen
 272       */
 273      @SuppressWarnings(&quot;unchecked&quot;)
 274      public List&lt;ListGridAction&gt; getActiveModalRowActions() {
<abbr title=" 275          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridAction&gt;() {"> 275          return (List&lt;ListGridAction&gt;) CollectionUtils.select(getModalRowActions(), new TypedPredicate&lt;ListGridActiðŸ”µ</abbr>
 276  
 277              @Override
 278              public boolean eval(ListGridAction action) {
 279                  return action.getForListGridReadOnly().equals(getIsReadOnly());
 280              }
 281          });
 282      }
 283  
 284      public void addRowAction(ListGridAction action) {
 285          getRowActions().add(action);
 286      }
 287  
 288      public void addModalRowAction(ListGridAction action) {
 289          getModalRowActions().add(action);
 290      }
 291  
 292      public void addToolbarAction(ListGridAction action) {
 293          getToolbarActions().add(action);
 294      }
 295  
 296      public void removeAllToolbarActions() {
 297          getToolbarActions().clear();
 298      }
 299  
 300      public void removeAllRowActions() {
 301          getRowActions().clear();
 302      }
 303  
 304      public void addToolbarActionGroup(ListGridActionGroup actionGroup) {
 305          getToolbarActionGroups().add(actionGroup);
 306      }
 307  
 308      public void removeAllToolbarActionGroups() {
 309          getToolbarActionGroups().clear();
 310      }
 311  
 312      public void addRowActionGroup(ListGridActionGroup actionGroup) {
 313          getRowActionGroups().add(actionGroup);
 314      }
 315  
 316      public void removeAllRowActionGroups() {
 317          getRowActionGroups().clear();
 318      }
 319  
 320      public void removeAllModalRowActions() {
 321          getModalRowActions().clear();
 322      }
 323  
 324      public ListGridAction findToolbarAction(String actionId) {
 325          for (ListGridAction action : getToolbarActions()) {
 326              if (action.getActionId().equals(actionId)) {
 327                  return action;
 328              }
 329          }
 330          for (ListGridActionGroup actionGroup : getToolbarActionGroups()) {
 331              for (ListGridAction action : actionGroup.getListGridActions()) {
 332                  if (action.getActionId().equals(actionId)) {
 333                      return action;
 334                  }
 335              }
 336          }
 337          return null;
 338      }
 339  
 340      public ListGridAction findRowAction(String actionId) {
 341          for (ListGridAction action : getRowActions()) {
 342              if (action.getActionId().equals(actionId)) {
 343                  return action;
 344              }
 345          }
 346          for (ListGridActionGroup actionGroup : getRowActionGroups()) {
 347              for (ListGridAction action : actionGroup.getListGridActions()) {
 348                  if (action.getActionId().equals(actionId)) {
 349                      return action;
 350                  }
 351              }
 352          }
 353          return null;
 354      }
 355  
 356      public ListGridAction findModalRowAction(String actionId) {
 357          for (ListGridAction action : getModalRowActions()) {
 358              if (action.getActionId().equals(actionId)) {
 359                  return action;
 360              }
 361          }
 362          return null;
 363      }
 364  
 365      /**
<abbr title=" 366       * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, then the"> 366       * This grid is sortable if there is a reorder action defined in the toolbar. If records can be reordered, theðŸ”µ</abbr>
 367       * sort functionality doesn&#x27;t make any sense.
 368       *
 369       * Also, map structures are currently unsortable.
 370       *
 371       * @return
 372       */
 373      public boolean isSortable() {
 374          return this.isSortable || Type.MAP.toString().toLowerCase().equals(getListGridType());
 375      }
 376  
 377      /* ************************ */
 378      /* CUSTOM GETTERS / SETTERS */
 379      /* ************************ */
 380  
 381      public void setListGridType(Type listGridType) {
 382          this.listGridType = listGridType.toString().toLowerCase();
 383      }
 384  
 385      /**
<abbr title=" 386       * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to on the JS"> 386       * Allows for completely custom types other than the ones defined {@link Type} to assign unique handlers to onðŸ”µ</abbr>
 387       * side
 388       * @param listGridType
 389       */
 390      public void setListGridTypeString(String listGridType) {
 391          this.listGridType = listGridType;
 392      }
 393  
 394      public void setSelectType(SelectType selectType) {
 395          this.selectType = selectType.toString().toLowerCase();
 396      }
 397  
 398      public void setSelectTypeString(String selectType) {
 399          this.selectType = selectType;
 400      }
 401  
 402      public Boolean getCanFilterAndSort() {
 403          return (canFilterAndSort == null ? true : canFilterAndSort);
 404      }
 405  
 406      public Boolean getIsReadOnly() {
 407          return isReadOnly == null ? false : isReadOnly;
 408      }
 409  
 410      public Boolean getClickable() {
 411          return !&quot;none&quot;.equals(selectType);
 412      }
 413  
 414      public Boolean getHideIdColumn() {
 415          return hideIdColumn == null ? true : hideIdColumn;
 416      }
 417  
 418      /* ************************** */
 419      /* STANDARD GETTERS / SETTERS */
 420      /* ************************** */
 421  
 422  	public String getIdProperty() {
 423          return idProperty;
 424      }
 425  
 426      public void setIdProperty(String idProperty) {
 427          this.idProperty = idProperty;
 428      }
 429  
 430      public String getClassName() {
 431          return className;
 432      }
 433  
 434      public void setClassName(String className) {
 435          this.className = className;
 436      }
 437  
 438      public int getOrder() {
 439          return order;
 440      }
 441  
 442      public void setOrder(int order) {
 443          this.order = order;
 444      }
 445  
 446      public boolean getIsSortable() {
 447          return isSortable;
 448      }
 449  
 450      public void setIsSortable(boolean isSortable) {
 451          this.isSortable = isSortable;
 452      }
 453  
 454      public boolean getHideFriendlyName() { return hideFriendlyName; }
 455  
 456      public void setHideFriendlyName(boolean hideFriendlyName) { this.hideFriendlyName = hideFriendlyName; }
 457  
 458      public Set&lt;Field&gt; getHeaderFields() {
 459          return headerFields;
 460      }
 461  
 462      public void setHeaderFields(Set&lt;Field&gt; headerFields) {
 463          this.headerFields = headerFields;
 464      }
 465  
 466      public Field findHeaderField(String name) {
 467          if (name == null) {
 468              return null;
 469          }
 470  
 471          for (Field headerField : getHeaderFields()) {
 472              if (name.equals(headerField.getName())) {
 473                  return headerField;
 474              }
 475          }
 476          return null;
 477      }
 478  
 479      public boolean isEmpty() {
 480          return records.isEmpty();
 481      }
 482  
 483      public List&lt;ListGridRecord&gt; getRecords() {
 484          return records;
 485      }
 486  
 487      public void setRecords(List&lt;ListGridRecord&gt; records) {
 488          this.records = records;
 489      }
 490  
 491      public List&lt;ListGridAction&gt; getToolbarActions() {
 492          return toolbarActions;
 493      }
 494  
 495      public void setToolbarActions(List&lt;ListGridAction&gt; toolbarActions) {
 496          this.toolbarActions = toolbarActions;
 497      }
 498  
 499      public List&lt;ListGridAction&gt; getRowActions() {
 500          return rowActions;
 501      }
 502  
 503      public void setRowActions(List&lt;ListGridAction&gt; rowActions) {
 504          this.rowActions = rowActions;
 505      }
 506  
 507      public List&lt;ListGridActionGroup&gt; getToolbarActionGroups() {
 508          return toolbarActionGroups;
 509      }
 510  
 511      public void setToolbarActionGroups(List&lt;ListGridActionGroup&gt; toolbarActionGroups) {
 512          this.toolbarActionGroups = toolbarActionGroups;
 513      }
 514  
 515      public List&lt;ListGridActionGroup&gt; getRowActionGroups() {
 516          return rowActionGroups;
 517      }
 518  
 519      public void setRowActionGroups(List&lt;ListGridActionGroup&gt; rowActionGroups) {
 520          this.rowActionGroups = rowActionGroups;
 521      }
 522  
 523      public List&lt;ListGridAction&gt; getModalRowActions() {
 524          return modalRowActions;
 525      }
 526  
 527      public void setModalRowActions(List&lt;ListGridAction&gt; modalRowActions) {
 528          this.modalRowActions = modalRowActions;
 529      }
 530  
 531      public int getStartIndex() {
 532          return startIndex;
 533      }
 534  
 535      public void setStartIndex(int startIndex) {
 536          this.startIndex = startIndex;
 537      }
 538  
 539      public int getTotalRecords() {
 540          return totalRecords;
 541      }
 542  
 543      public void setTotalRecords(int totalRecords) {
 544          this.totalRecords = totalRecords;
 545      }
 546  
 547      public int getPageSize() {
 548          return pageSize;
 549      }
 550  
 551      public void setPageSize(int pageSize) {
 552          this.pageSize = pageSize;
 553      }
 554  
 555      public void setCanFilterAndSort(Boolean canFilterAndSort) {
 556          this.canFilterAndSort = canFilterAndSort;
 557      }
 558  
 559      public AddMethodType getAddMethodType() {
 560          return addMethodType;
 561      }
 562  
 563      public void setAddMethodType(AddMethodType addMethodType) {
 564          this.addMethodType = addMethodType;
 565      }
 566  
 567      public String getListGridType() {
 568          return listGridType;
 569      }
 570  
 571      public String getSelectType() {
 572          return selectType;
 573      }
 574  
 575      public String getContainingEntityId() {
 576          return containingEntityId;
 577      }
 578  
 579      public void setContainingEntityId(String containingEntityId) {
 580          this.containingEntityId = containingEntityId;
 581      }
 582  
 583      public String getSubCollectionFieldName() {
 584          return subCollectionFieldName;
 585      }
 586  
 587      public void setSubCollectionFieldName(String subCollectionFieldName) {
 588          this.subCollectionFieldName = subCollectionFieldName;
 589      }
 590  
 591      public String getFriendlyName() {
 592          return friendlyName;
 593      }
 594  
 595      public void setFriendlyName(String friendlyName) {
 596          this.friendlyName = friendlyName;
 597      }
 598  
 599      public String getSectionKey() {
 600          return sectionKey;
 601      }
 602  
 603      public void setSectionKey(String sectionKey) {
 604          this.sectionKey = sectionKey;
 605      }
 606  
 607      public String getSelectizeUrl() {
 608          return selectizeUrl;
 609      }
 610  
 611      public void setSelectizeUrl(String selectizeUrl) {
 612          this.selectizeUrl = selectizeUrl;
 613      }
 614  
 615      public Boolean getManualFetch() {
 616          if (manualFetch == null) {
 617              return false;
 618          }
 619          return manualFetch;
 620      }
 621  
 622      public void setManualFetch(Boolean manualFetch) {
 623          this.manualFetch = manualFetch;
 624      }
 625  
 626      public String getExternalEntitySectionKey() {
 627          return externalEntitySectionKey;
 628      }
 629  
 630      public void setExternalEntitySectionKey(String externalEntitySectionKey) {
 631          this.externalEntitySectionKey = externalEntitySectionKey;
 632      }
 633  
 634      public String getPathOverride() {
 635          return pathOverride;
 636      }
 637  
 638      public void setPathOverride(String pathOverride) {
 639          this.pathOverride = pathOverride;
 640      }
 641  
 642      public String getSearchFieldsTemplateOverride() {
 643          return searchFieldsTemplateOverride;
 644      }
 645  
 646      public void setSearchFieldsTemplateOverride(String searchFieldsTemplateOverride) {
 647          this.searchFieldsTemplateOverride = searchFieldsTemplateOverride;
 648      }
 649  
 650      public String getTemplateOverride() {
 651          return templateOverride;
 652      }
 653  
 654      public void setTemplateOverride(String templateOverride) {
 655          this.templateOverride = templateOverride;
 656      }
 657  
 658      public void setIsReadOnly(Boolean readOnly) {
 659          this.isReadOnly = readOnly;
 660      }
 661  
 662      public void setHideIdColumn(Boolean hideIdColumn) {
 663          this.hideIdColumn = hideIdColumn;
 664      }
 665  
 666      public List&lt;SectionCrumb&gt; getSectionCrumbs() {
 667          return sectionCrumbs;
 668      }
 669  
 670      public void setSectionCrumbs(List&lt;SectionCrumb&gt; sectionCrumbs) {
 671          if (sectionCrumbs == null) {
 672              this.sectionCrumbs.clear();
 673              return;
 674          }
 675          this.sectionCrumbs = sectionCrumbs;
 676      }
 677  
 678      public String getFieldBuilder() {
 679          return fieldBuilder;
 680      }
 681  
 682      public void setFieldBuilder(String fieldBuilder) {
 683          this.fieldBuilder = fieldBuilder;
 684      }
 685  
 686      public FieldWrapper getFieldWrapper() {
 687          return fieldWrapper;
 688      }
 689  
 690      public void setFieldWrapper(FieldWrapper fieldWrapper) {
 691          this.fieldWrapper = fieldWrapper;
 692      }
 693  
 694      public DataWrapper getDataWrapper() {
 695          return dataWrapper;
 696      }
 697  
 698      public void setDataWrapper(DataWrapper dataWrapper) {
 699          this.dataWrapper = dataWrapper;
 700      }
 701  
 702      public String getJson() {
 703          return json;
 704      }
 705  
 706      public void setJson(String json) {
 707          this.json = json;
 708      }
 709  
 710      public String getJsonFieldName() {
 711          return jsonFieldName;
 712      }
 713  
 714      public void setJsonFieldName(String jsonFieldName) {
 715          this.jsonFieldName = jsonFieldName;
 716      }
 717  
 718      public String getFetchType() {
 719          return fetchType;
 720      }
 721  
 722      public void setFetchType(String fetchType) {
 723          this.fetchType = fetchType;
 724      }
 725  
 726      public long getFirstId() {
 727          return firstId;
 728      }
 729  
 730      public void setFirstId(long firstId) {
 731          this.firstId = firstId;
 732      }
 733  
 734      public long getLastId() {
 735          return lastId;
 736      }
 737  
 738      public void setLastId(long lastId) {
 739          this.lastId = lastId;
 740      }
 741  
 742      public int getUpperCount() {
 743          return upperCount;
 744      }
 745  
 746      public void setUpperCount(int upperCount) {
 747          this.upperCount = upperCount;
 748      }
 749  
 750      public int getLowerCount() {
 751          return lowerCount;
 752      }
 753  
 754      public void setLowerCount(int lowerCount) {
 755          this.lowerCount = lowerCount;
 756      }
 757  
 758      public boolean isTotalCountLessThanPageSize() {
 759          return totalCountLessThanPageSize;
 760      }
 761  
 762      public void setTotalCountLessThanPageSize(boolean totalCountLessThanPageSize) {
 763          this.totalCountLessThanPageSize = totalCountLessThanPageSize;
 764      }
 765  
 766      public boolean isPromptSearch() {
 767          return promptSearch;
 768      }
 769  
 770      public void setPromptSearch(boolean promptSearch) {
 771          this.promptSearch = promptSearch;
 772      }
 773  
 774      public String getHelpText() { return helpText; }
 775  
 776      public void setHelpText(String helpText) { this.helpText = helpText; }
 777  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 778 +    /* ***************************** */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +    /* CSS CLASSES GETTERS / SETTERS */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 780 +    /* ***************************** */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 781 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +    public void addCssClass(String className) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 783 +        this.cssClasses.add(className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 784 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +    public void removeCssClass(String className) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +        this.cssClasses.remove(className);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 790 +    public void clearCssClasses() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 791 +        this.cssClasses.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 792 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 793 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 794 +    public String getCssClassNames() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 795 +        return StringUtils.join(this.cssClasses, &quot; &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 796 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 797 +</span>
 798  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            