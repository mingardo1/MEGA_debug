<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>467</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    467
                    <a href="466.html">prev</a>
                    <a href="468.html">next</a>
                    <a href="467_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05_src/com/android/launcher3/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05:src/com/android/launcher3/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05^1:src/com/android/launcher3/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05^2:src/com/android/launcher3/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;9ee142497e1272697393867be0bccddd758aef35:src/com/android/launcher3/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.*;
  23 import android.content.Intent.ShortcutIconResource;
  24 import android.content.pm.ActivityInfo;
  25 import android.content.pm.PackageInfo;
  26 import android.content.pm.PackageManager;
  27 import android.content.pm.PackageManager.NameNotFoundException;
  28 import android.content.pm.ResolveInfo;
  29 import android.content.res.Configuration;
  30 import android.content.res.Resources;
  31 import android.database.Cursor;
  32 import android.graphics.Bitmap;
  33 import android.graphics.BitmapFactory;
  34 import android.net.Uri;
  35 import android.os.Environment;
  36 import android.os.Handler;
  37 import android.os.HandlerThread;
  38 import android.os.Parcelable;
  39 import android.os.Process;
  40 import android.os.RemoteException;
  41 import android.os.SystemClock;
  42 import android.provider.BaseColumns;
  43 import android.text.TextUtils;
  44 import android.util.Log;
  45 import android.util.Pair;
  46 
  47 import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  48 
  49 import java.lang.ref.WeakReference;
  50 import java.net.URISyntaxException;
  51 import java.text.Collator;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Collection;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.Iterator;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.TreeMap;
  63 import java.util.concurrent.atomic.AtomicBoolean;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  75     // false = strew non-workspace apps across the workspace on upgrade
  76     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  77 
  78     public static final int LOADER_FLAG_NONE = 0;
  79     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  80     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  81 
  82     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  83     private static final long INVALID_SCREEN_ID = -1L;
  84 
  85     private final boolean mAppsCanBeOnRemoveableStorage;
  86     private final boolean mOldContentProviderExists;
  87 
  88     private final LauncherAppState mApp;
  89     private final Object mLock = new Object();
  90     private DeferredHandler mHandler = new DeferredHandler();
  91     private LoaderTask mLoaderTask;
  92     private boolean mIsLoaderTaskRunning;
  93     private volatile boolean mFlushingWorkerThread;
  94 
  95     // Specific runnable types that are run on the main thread deferred handler, this allows us to
  96     // clear all queued binding runnables when the Launcher activity is destroyed.
  97     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
  98     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
  99 
 100 
 101     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 102     static {
 103         sWorkerThread.start();
 104     }
 105     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 106 
 107     // We start off with everything not loaded.  After that, we assume that
 108     // our monitoring of the package manager provides all updates and we never
 109     // need to do a requery.  These are only ever touched from the loader thread.
 110     private boolean mWorkspaceLoaded;
 111     private boolean mAllAppsLoaded;
 112 
 113     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 114     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 115     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 116     // a normal load, we also clear this set of Runnables.
 117     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 118 
 119     private WeakReference&lt;Callbacks&gt; mCallbacks;
 120 
 121     // &lt; only access in worker thread &gt;
 122     AllAppsList mBgAllAppsList;
 123 
 124     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 125     // other locks, this one can generally be held long-term because we never expect any of these
 126     // static data structures to be referenced outside of the worker thread except on the first
 127     // load after configuration change.
 128     static final Object sBgLock = new Object();
 129 
 130     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 131     // LauncherModel to their ids
 132     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 133 
 134     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 135     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 136     //       shortcuts within folders).
 137     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 138 
 139     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 140     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 141         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 142 
 143     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 144     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 145 
 146     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 147     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 148 
 149     // sBgWorkspaceScreens is the ordered set of workspace screens.
 150     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 151 
 152     // &lt;/ only access in worker thread &gt;
 153 
 154     private IconCache mIconCache;
 155     private Bitmap mDefaultIcon;
 156 
 157     protected int mPreviousConfigMcc;
 158 
 159     public interface Callbacks {
 160         public boolean setLoadOnResume();
 161         public int getCurrentWorkspaceScreen();
 162         public void startBinding();
 163         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 164                               boolean forceAnimateIcons);
 165         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 166         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 167         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 168         public void finishBindingItems(boolean upgradePath);
 169         public void bindAppWidget(LauncherAppWidgetInfo info);
 170         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 171         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 172                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 173                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 174                                   ArrayList&lt;AppInfo&gt; addedApps);
 175         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 176         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 177                         ArrayList&lt;AppInfo&gt; appInfos);
 178         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 179         public void bindSearchablesChanged();
 180         public boolean isAllAppsButtonRank(int rank);
 181         public void onPageBoundSynchronously(int page);
 182         public void dumpLogsToLocalData();
 183     }
 184 
 185     public interface ItemInfoFilter {
 186         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 187     }
 188 
 189     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 190         Context context = app.getContext();
 191         ContentResolver contentResolver = context.getContentResolver();
 192 
 193         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 194         mOldContentProviderExists = (contentResolver.acquireContentProviderClient(
 195                 LauncherSettings.Favorites.OLD_CONTENT_URI) != null);
 196         mApp = app;
 197         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 198         mIconCache = iconCache;
 199 
 200         final Resources res = context.getResources();
 201         Configuration config = res.getConfiguration();
 202         mPreviousConfigMcc = config.mcc;
 203     }
 204 
 205     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 206      * posted on the main thread handler. */
 207     private void runOnMainThread(Runnable r) {
 208         runOnMainThread(r, 0);
 209     }
 210     private void runOnMainThread(Runnable r, int type) {
 211         if (sWorkerThread.getThreadId() == Process.myTid()) {
 212             // If we are on the worker thread, post onto the main handler
 213             mHandler.post(r);
 214         } else {
 215             r.run();
 216         }
 217     }
 218 
 219     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 220      * posted on the worker thread handler. */
 221     private static void runOnWorkerThread(Runnable r) {
 222         if (sWorkerThread.getThreadId() == Process.myTid()) {
 223             r.run();
 224         } else {
 225             // If we are not on the worker thread, then post to the worker handler
 226             sWorker.post(r);
 227         }
 228     }
 229 
 230     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 231         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 232     }
 233 
 234     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 235                                  long screen) {
 236         LauncherAppState app = LauncherAppState.getInstance();
 237         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 238         final int xCount = (int) grid.numColumns;
 239         final int yCount = (int) grid.numRows;
 240         boolean[][] occupied = new boolean[xCount][yCount];
 241 
 242         int cellX, cellY, spanX, spanY;
 243         for (int i = 0; i &lt; items.size(); ++i) {
 244             final ItemInfo item = items.get(i);
 245             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 246                 if (item.screenId == screen) {
 247                     cellX = item.cellX;
 248                     cellY = item.cellY;
 249                     spanX = item.spanX;
 250                     spanY = item.spanY;
 251                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 252                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 253                             occupied[x][y] = true;
 254                         }
 255                     }
 256                 }
 257             }
 258         }
 259 
 260         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 261     }
 262     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 263                                                         Intent launchIntent,
 264                                                         int firstScreenIndex,
 265                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 266         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 267         LauncherAppState app = LauncherAppState.getInstance();
 268         LauncherModel model = app.getModel();
 269         boolean found = false;
 270         synchronized (app) {
 271             if (sWorkerThread.getThreadId() != Process.myTid()) {
 272                 // Flush the LauncherModel worker thread, so that if we just did another
 273                 // processInstallShortcut, we give it time for its shortcut to get added to the
 274                 // database (getItemsInLocalCoordinates reads the database)
 275                 model.flushWorkerThread();
 276             }
 277             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 278 
 279             // Try adding to the workspace screens incrementally, starting at the default or center
 280             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 281             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 282             int count = workspaceScreens.size();
 283             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 284                 int[] tmpCoordinates = new int[2];
 285                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 286                         workspaceScreens.get(screen))) {
 287                     // Update the Launcher db
 288                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 289                 }
 290             }
 291         }
 292         return null;
 293     }
 294 
 295 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 296     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 297                                     final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 298         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 299         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
 300 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 301     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 302         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 303 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 304         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 305             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 306         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 307         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 308             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 309         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 310 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 311         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 312         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 313         while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 314             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 315             if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 316                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 317             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 318         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 319 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 320         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 321         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 322             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 323                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 324                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 325                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 326                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 327                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 328                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 329                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 330                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 331                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 332                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 333                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 334             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 335         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 336         runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 337     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 338 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 339     public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 340             final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 341         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 342 </span>
 343 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 344     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 345         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 346 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 347         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 348             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 349         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 350         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 351             return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 352         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 353 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 354         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 355         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 356         while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 357             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 358             if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 359                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 360             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 361         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 362 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 363         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 364         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 365             public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 366                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 367                     public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 368                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 369                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 370                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 371                                 for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 372                                     final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 373                                     if (intent != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 374                                         mIconCache.deletePreloadedIcon(intent.getComponent());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 375                                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 376                                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 377                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 378                             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 379                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 380                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 381                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 382                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 383             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 384         };</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 385         runOnWorkerThread(r);</span>
 386 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 387     }
 388     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 389                                 final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 390         if (workspaceApps == null || allAppsApps == null) {
 391             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 392         }
 393         if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {
 394             return;
 395         }
 396         // Process the newly added applications and add them to the database first
 397         Runnable r = new Runnable() {
 398             public void run() {
 399                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 400                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 401 
 402                 // Get the list of workspace screens.  We need to append to this list and
 403                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 404                 // called.
 405                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 406                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 407                 for (Integer i : orderedScreens.keySet()) {
 408                     long screenId = orderedScreens.get(i);
 409                     workspaceScreens.add(screenId);
 410                 }
 411 
 412                 synchronized(sBgLock) {
 413                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 414                     while (iter.hasNext()) {
 415                         ItemInfo a = iter.next();
 416                         final String name = a.title.toString();
 417                         final Intent launchIntent = a.getIntent();
 418 
 419                         // Short-circuit this logic if the icon exists somewhere on the workspace
 420                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 421                             continue;
 422                         }
 423 
 424                         // Add this icon to the db, creating a new page if necessary.  If there
 425                         // is only the empty page then we just add items to the first page.
 426                         // Otherwise, we add them to the next pages.
 427                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 428                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 429                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 430                         if (coords == null) {
 431                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 432 
 433                             // If we can&#x27;t find a valid position, then just add a new screen.
 434                             // This takes time so we need to re-queue the add until the new
 435                             // page is added.  Create as many screens as necessary to satisfy
 436                             // the startSearchPageIndex.
 437                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 438                                     workspaceScreens.size());
 439                             while (numPagesToAdd &gt; 0) {
 440                                 long screenId = lp.generateNewScreenId();
 441                                 // Save the screen id for binding in the workspace
 442                                 workspaceScreens.add(screenId);
 443                                 addedWorkspaceScreensFinal.add(screenId);
 444                                 numPagesToAdd--;
 445                             }
 446 
 447                             // Find the coordinate again
 448                             coords = LauncherModel.findNextAvailableIconSpace(context,
 449                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 450                         }
 451                         if (coords == null) {
 452                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 453                         }
 454 
 455                         ShortcutInfo shortcutInfo;
 456                         if (a instanceof ShortcutInfo) {
 457                             shortcutInfo = (ShortcutInfo) a;
 458                         } else if (a instanceof AppInfo) {
 459                             shortcutInfo = ((AppInfo) a).makeShortcut();
 460                         } else {
 461                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 462                         }
 463 
 464                         // Add the shortcut to the db
 465                         addItemToDatabase(context, shortcutInfo,
 466                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 467                                 coords.first, coords.second[0], coords.second[1], false);
 468                         // Save the ShortcutInfo for binding in the workspace
 469                         addedShortcutsFinal.add(shortcutInfo);
 470                     }
 471                 }
 472 
 473                 // Update the workspace screens
 474                 updateWorkspaceScreenOrder(context, workspaceScreens);
 475 
 476                 if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {
 477                     runOnMainThread(new Runnable() {
 478                         public void run() {
 479                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 480                             if (callbacks == cb &amp;&amp; cb != null) {
 481                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 482                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 483                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 484                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 484                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 485                                     long lastScreenId = info.screenId;
 486                                     for (ItemInfo i : addedShortcutsFinal) {
 487                                         if (i.screenId == lastScreenId) {
 488                                             addAnimated.add(i);
 489                                         } else {
 490                                             addNotAnimated.add(i);
 491                                         }
 492                                     }
 493                                 }
 494                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 495                                         addNotAnimated, addAnimated, allAppsApps);
 496                             }
 497                         }
 498                     });
 499                 }
 500             }
 501         };
 502         runOnWorkerThread(r);
 503     }
 504 
 505     public Bitmap getFallbackIcon() {
 506         if (mDefaultIcon == null) {
 507             final Context context = LauncherAppState.getInstance().getContext();
 508             mDefaultIcon = Utilities.createIconBitmap(
 509                     mIconCache.getFullResDefaultActivityIcon(), context);
 510         }
 511         return Bitmap.createBitmap(mDefaultIcon);
 512     }
 513 
 514     public void unbindItemInfosAndClearQueuedBindRunnables() {
 515         if (sWorkerThread.getThreadId() == Process.myTid()) {
 516             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 517                     &quot;main thread&quot;);
 518         }
 519 
 520         // Clear any deferred bind runnables
 521         mDeferredBindRunnables.clear();
 522         // Remove any queued bind runnables
 523         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 524         // Unbind all the workspace items
 525         unbindWorkspaceItemsOnMainThread();
 526     }
 527 
 528     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 529     void unbindWorkspaceItemsOnMainThread() {
 530         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 531         // by making a copy of workspace items first.
 532         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 533         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 534         synchronized (sBgLock) {
 535             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 536             tmpAppWidgets.addAll(sBgAppWidgets);
 537         }
 538         Runnable r = new Runnable() {
 539                 @Override
 540                 public void run() {
 541                    for (ItemInfo item : tmpWorkspaceItems) {
 542                        item.unbind();
 543                    }
 544                    for (ItemInfo item : tmpAppWidgets) {
 545                        item.unbind();
 546                    }
 547                 }
 548             };
 549         runOnMainThread(r);
 550     }
 551 
 552     /**
 553      * Adds an item to the DB if it was not created previously, or move it to a new
 554      * &lt;container, screen, cellX, cellY&gt;
 555      */
 556     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 557             long screenId, int cellX, int cellY) {
 558         if (item.container == ItemInfo.NO_ID) {
 559             // From all apps
 560             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 561         } else {
 562             // From somewhere else
 563             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 564         }
 565     }
 566 
 567     static void checkItemInfoLocked(
 568             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 569         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 570         if (modelItem != null &amp;&amp; item != modelItem) {
 571             // check all the data is consistent
 572             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 573                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 574                 ShortcutInfo shortcut = (ShortcutInfo) item;
 575                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 576                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 577                         modelShortcut.id == shortcut.id &amp;&amp;
 578                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 579                         modelShortcut.container == shortcut.container &amp;&amp;
 580                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 581                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 582                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 583                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 584                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 585                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 586                         (modelShortcut.dropPos != null &amp;&amp;
 587                                 shortcut.dropPos != null &amp;&amp;
 588                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 589                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 590                     // For all intents and purposes, this is the same object
 591                     return;
 592                 }
 593             }
 594 
 595             // the modelItem needs to match up perfectly with item if our model is
 596             // to be consistent with the database-- for now, just require
 597             // modelItem == item or the equality check above
 598             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 599                     &quot;modelItem: &quot; +
 600                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 601                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 602             RuntimeException e = new RuntimeException(msg);
 603             if (stackTrace != null) {
 604                 e.setStackTrace(stackTrace);
 605             }
 606             throw e;
 607         }
 608     }
 609 
 610     static void checkItemInfo(final ItemInfo item) {
 611         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 612         final long itemId = item.id;
 613         Runnable r = new Runnable() {
 614             public void run() {
 615                 synchronized (sBgLock) {
 616                     checkItemInfoLocked(itemId, item, stackTrace);
 617                 }
 618             }
 619         };
 620         runOnWorkerThread(r);
 621     }
 622 
 623     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 624             final ItemInfo item, final String callingFunction) {
 625         final long itemId = item.id;
 626         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 627         final ContentResolver cr = context.getContentResolver();
 628 
 629         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 630         Runnable r = new Runnable() {
 631             public void run() {
 632                 cr.update(uri, values, null, null);
 633                 updateItemArrays(item, itemId, stackTrace);
 634             }
 635         };
 636         runOnWorkerThread(r);
 637     }
 638 
 639     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 640             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 641         final ContentResolver cr = context.getContentResolver();
 642 
 643         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 644         Runnable r = new Runnable() {
 645             public void run() {
 646                 ArrayList&lt;ContentProviderOperation&gt; ops =
 647                         new ArrayList&lt;ContentProviderOperation&gt;();
 648                 int count = items.size();
 649                 for (int i = 0; i &lt; count; i++) {
 650                     ItemInfo item = items.get(i);
 651                     final long itemId = item.id;
 652                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 653                     ContentValues values = valuesList.get(i);
 654 
 655                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 656                     updateItemArrays(item, itemId, stackTrace);
 657 
 658                 }
 659                 try {
 660                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 661                 } catch (Exception e) {
 662                     e.printStackTrace();
 663                 }
 664             }
 665         };
 666         runOnWorkerThread(r);
 667     }
 668 
 669     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 670         // Lock on mBgLock *after* the db operation
 671         synchronized (sBgLock) {
 672             checkItemInfoLocked(itemId, item, stackTrace);
 673 
 674             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 675                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 676                 // Item is in a folder, make sure this folder exists
 677                 if (!sBgFolders.containsKey(item.container)) {
 678                     // An items container is being set to a that of an item which is not in
 679                     // the list of Folders.
 680                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 681                             item.container + &quot;, not in the list of folders&quot;;
 682                     Log.e(TAG, msg);
 683                 }
 684             }
 685 
 686             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 687             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 688             // that are on the desktop, as appropriate
 689             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 690             if (modelItem != null &amp;&amp;
 691                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 692                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 693                 switch (modelItem.itemType) {
 694                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 695                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 696                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 697                         if (!sBgWorkspaceItems.contains(modelItem)) {
 698                             sBgWorkspaceItems.add(modelItem);
 699                         }
 700                         break;
 701                     default:
 702                         break;
 703                 }
 704             } else {
 705                 sBgWorkspaceItems.remove(modelItem);
 706             }
 707         }
 708     }
 709 
 710     public void flushWorkerThread() {
 711         mFlushingWorkerThread = true;
 712         Runnable waiter = new Runnable() {
 713                 public void run() {
 714                     synchronized (this) {
 715                         notifyAll();
 716                         mFlushingWorkerThread = false;
 717                     }
 718                 }
 719             };
 720 
 721         synchronized(waiter) {
 722             runOnWorkerThread(waiter);
 723             if (mLoaderTask != null) {
 724                 synchronized(mLoaderTask) {
 725                     mLoaderTask.notify();
 726                 }
 727             }
 728             boolean success = false;
 729             while (!success) {
 730                 try {
 731                     waiter.wait();
 732                     success = true;
 733                 } catch (InterruptedException e) {
 734                 }
 735             }
 736         }
 737     }
 738 
 739     /**
 740      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 741      */
 742     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 743             final long screenId, final int cellX, final int cellY) {
 744         item.container = container;
 745         item.cellX = cellX;
 746         item.cellY = cellY;
 747 
 748         // We store hotseat items in canonical form which is this orientation invariant position
 749         // in the hotseat
 750         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 751                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 752             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 753         } else {
 754             item.screenId = screenId;
 755         }
 756 
 757         final ContentValues values = new ContentValues();
 758         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 759         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 760         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 761         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 762 
 763         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 764     }
 765 
 766     /**
 767      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 768      * cellX, cellY have already been updated on the ItemInfos.
 769      */
 770     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 771             final long container, final int screen) {
 772 
 773         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 774         int count = items.size();
 775 
 776         for (int i = 0; i &lt; count; i++) {
 777             ItemInfo item = items.get(i);
 778             item.container = container;
 779 
 780             // We store hotseat items in canonical form which is this orientation invariant position
 781             // in the hotseat
 782             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 783                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 784                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 785                         item.cellY);
 786             } else {
 787                 item.screenId = screen;
 788             }
 789 
 790             final ContentValues values = new ContentValues();
 791             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 792             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 793             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 794             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 795 
 796             contentValues.add(values);
 797         }
 798         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 799     }
 800 
 801     /**
 802      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 803      */
 804     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 805             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 806         item.container = container;
 807         item.cellX = cellX;
 808         item.cellY = cellY;
 809         item.spanX = spanX;
 810         item.spanY = spanY;
 811 
 812         // We store hotseat items in canonical form which is this orientation invariant position
 813         // in the hotseat
 814         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 815                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 816             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 817         } else {
 818             item.screenId = screenId;
 819         }
 820 
 821         final ContentValues values = new ContentValues();
 822         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 823         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 824         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 825         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 826         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 827         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 828 
 829         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 830     }
 831 
 832     /**
 833      * Update an item to the database in a specified container.
 834      */
 835     static void updateItemInDatabase(Context context, final ItemInfo item) {
 836         final ContentValues values = new ContentValues();
 837         item.onAddToDatabase(values);
 838         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 839         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 840     }
 841 
 842     /**
 843      * Returns true if the shortcuts already exists in the database.
 844      * we identify a shortcut by its title and intent.
 845      */
 846     static boolean shortcutExists(Context context, String title, Intent intent) {
 847         final ContentResolver cr = context.getContentResolver();
 848         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 849             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 850             new String[] { title, intent.toUri(0) }, null);
 851         boolean result = false;
 852         try {
 853             result = c.moveToFirst();
 854         } finally {
 855             c.close();
 856         }
 857         return result;
 858     }
 859 
 860     /**
 861      * Returns an ItemInfo array containing all the items in the LauncherModel.
 862      * The ItemInfo.id is not set through this function.
 863      */
 864     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 865         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 866         final ContentResolver cr = context.getContentResolver();
 867         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 868                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 869                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 869                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 870                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 871 
 872         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 873         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 874         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 875         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 876         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 877         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 878         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 879 
 880         try {
 881             while (c.moveToNext()) {
 882                 ItemInfo item = new ItemInfo();
 883                 item.cellX = c.getInt(cellXIndex);
 884                 item.cellY = c.getInt(cellYIndex);
 885                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 886                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 887                 item.container = c.getInt(containerIndex);
 888                 item.itemType = c.getInt(itemTypeIndex);
 889                 item.screenId = c.getInt(screenIndex);
 890 
 891                 items.add(item);
 892             }
 893         } catch (Exception e) {
 894             items.clear();
 895         } finally {
 896             c.close();
 897         }
 898 
 899         return items;
 900     }
 901 
 902     /**
 903      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 904      */
 905     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 906         final ContentResolver cr = context.getContentResolver();
 907         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 908                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 909                 new String[] { String.valueOf(id),
 910                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 911 
 912         try {
 913             if (c.moveToFirst()) {
 914                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 915                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 916                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 917                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 918                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 919                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 920 
 921                 FolderInfo folderInfo = null;
 922                 switch (c.getInt(itemTypeIndex)) {
 923                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 924                         folderInfo = findOrMakeFolder(folderList, id);
 925                         break;
 926                 }
 927 
 928                 folderInfo.title = c.getString(titleIndex);
 929                 folderInfo.id = id;
 930                 folderInfo.container = c.getInt(containerIndex);
 931                 folderInfo.screenId = c.getInt(screenIndex);
 932                 folderInfo.cellX = c.getInt(cellXIndex);
 933                 folderInfo.cellY = c.getInt(cellYIndex);
 934 
 935                 return folderInfo;
 936             }
 937         } finally {
 938             c.close();
 939         }
 940 
 941         return null;
 942     }
 943 
 944     /**
 945      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 946      * cellY fields of the item. Also assigns an ID to the item.
 947      */
 948     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 949             final long screenId, final int cellX, final int cellY, final boolean notify) {
 950         item.container = container;
 951         item.cellX = cellX;
 952         item.cellY = cellY;
 953         // We store hotseat items in canonical form which is this orientation invariant position
 954         // in the hotseat
 955         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 956                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 957             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 958         } else {
 959             item.screenId = screenId;
 960         }
 961 
 962         final ContentValues values = new ContentValues();
 963         final ContentResolver cr = context.getContentResolver();
 964         item.onAddToDatabase(values);
 965 
 966         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 967         values.put(LauncherSettings.Favorites._ID, item.id);
 968         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 969 
 970         Runnable r = new Runnable() {
 971             public void run() {
 972                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 973                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 974 
 975                 // Lock on mBgLock *after* the db operation
 976                 synchronized (sBgLock) {
 977                     checkItemInfoLocked(item.id, item, null);
 978                     sBgItemsIdMap.put(item.id, item);
 979                     switch (item.itemType) {
 980                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 981                             sBgFolders.put(item.id, (FolderInfo) item);
 982                             // Fall through
 983                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 984                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 985                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 986                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 987                                 sBgWorkspaceItems.add(item);
 988                             } else {
 989                                 if (!sBgFolders.containsKey(item.container)) {
 990                                     // Adding an item to a folder that doesn&#x27;t exist.
 991                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 992                                             &quot; doesn&#x27;t exist&quot;;
 993                                     Log.e(TAG, msg);
 994                                 }
 995                             }
 996                             break;
 997                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 998                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 999                             break;
1000                     }
1001                 }
1002             }
1003         };
1004         runOnWorkerThread(r);
1005     }
1006 
1007     /**
1008      * Creates a new unique child id, for a given cell span across all layouts.
1009      */
1010     static int getCellLayoutChildId(
1011             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1012         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1013                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1014     }
1015 
1016     /**
1017      * Removes the specified item from the database
1018      * @param context
1019      * @param item
1020      */
1021     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1022         final ContentResolver cr = context.getContentResolver();
1023         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
1024 
1025         Runnable r = new Runnable() {
1026             public void run() {
1027                 cr.delete(uriToDelete, null, null);
1028 
1029                 // Lock on mBgLock *after* the db operation
1030                 synchronized (sBgLock) {
1031                     switch (item.itemType) {
1032                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1033                             sBgFolders.remove(item.id);
1034                             for (ItemInfo info: sBgItemsIdMap.values()) {
1035                                 if (info.container == item.id) {
1036                                     // We are deleting a folder which still contains items that
1037                                     // think they are contained by that folder.
1038                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1039                                             &quot;contains items (&quot; + info + &quot;)&quot;;
1040                                     Log.e(TAG, msg);
1041                                 }
1042                             }
1043                             sBgWorkspaceItems.remove(item);
1044                             break;
1045                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1046                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1047                             sBgWorkspaceItems.remove(item);
1048                             break;
1049                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1050                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1051                             break;
1052                     }
1053                     sBgItemsIdMap.remove(item.id);
1054                     sBgDbIconCache.remove(item);
1055                 }
1056             }
1057         };
1058         runOnWorkerThread(r);
1059     }
1060 
1061     /**
1062      * Update the order of the workspace screens in the database. The array list contains
1063      * a list of screen ids in the order that they should appear.
1064      */
1065     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1066         // Log to disk
1067         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1068         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1069 
1070         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1071         final ContentResolver cr = context.getContentResolver();
1072         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1073 
1074         // Remove any negative screen ids -- these aren&#x27;t persisted
1075         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1076         while (iter.hasNext()) {
1077             long id = iter.next();
1078             if (id &lt; 0) {
1079                 iter.remove();
1080             }
1081         }
1082 
1083         Runnable r = new Runnable() {
1084             @Override
1085             public void run() {
1086                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1087                 // Clear the table
1088                 ops.add(ContentProviderOperation.newDelete(uri).build());
1089                 int count = screensCopy.size();
1090                 for (int i = 0; i &lt; count; i++) {
1091                     ContentValues v = new ContentValues();
1092                     long screenId = screensCopy.get(i);
1093                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1094                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1095                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1096                 }
1097 
1098                 try {
1099                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1100                 } catch (Exception ex) {
1101                     throw new RuntimeException(ex);
1102                 }
1103 
1104                 synchronized (sBgLock) {
1105                     sBgWorkspaceScreens.clear();
1106                     sBgWorkspaceScreens.addAll(screensCopy);
1107                 }
1108             }
1109         };
1110         runOnWorkerThread(r);
1111     }
1112 
1113     /**
1114      * Remove the contents of the specified folder from the database
1115      */
1116     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1117         final ContentResolver cr = context.getContentResolver();
1118 
1119         Runnable r = new Runnable() {
1120             public void run() {
1121                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1122                 // Lock on mBgLock *after* the db operation
1123                 synchronized (sBgLock) {
1124                     sBgItemsIdMap.remove(info.id);
1125                     sBgFolders.remove(info.id);
1126                     sBgDbIconCache.remove(info);
1127                     sBgWorkspaceItems.remove(info);
1128                 }
1129 
1130                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1131                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1132                 // Lock on mBgLock *after* the db operation
1133                 synchronized (sBgLock) {
1134                     for (ItemInfo childInfo : info.contents) {
1135                         sBgItemsIdMap.remove(childInfo.id);
1136                         sBgDbIconCache.remove(childInfo);
1137                     }
1138                 }
1139             }
1140         };
1141         runOnWorkerThread(r);
1142     }
1143 
1144     /**
1145      * Set this as the current Launcher activity object for the loader.
1146      */
1147     public void initialize(Callbacks callbacks) {
1148         synchronized (mLock) {
1149             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1150         }
1151     }
1152 
1153     /**
1154      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1155      * ACTION_PACKAGE_CHANGED.
1156      */
1157     @Override
1158     public void onReceive(Context context, Intent intent) {
1159         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1160 
1161         final String action = intent.getAction();
1162 
1163         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1164                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1165                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1166             final String packageName = intent.getData().getSchemeSpecificPart();
1167             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1168 
1169             int op = PackageUpdatedTask.OP_NONE;
1170 
1171             if (packageName == null || packageName.length() == 0) {
1172                 // they sent us a bad intent
1173                 return;
1174             }
1175 
1176             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1177                 op = PackageUpdatedTask.OP_UPDATE;
1178             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1179                 if (!replacing) {
1180                     op = PackageUpdatedTask.OP_REMOVE;
1181                 }
1182                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1183                 // later, we will update the package at this time
1184             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1185                 if (!replacing) {
1186                     op = PackageUpdatedTask.OP_ADD;
1187                 } else {
1188                     op = PackageUpdatedTask.OP_UPDATE;
1189                 }
1190             }
1191 
1192             if (op != PackageUpdatedTask.OP_NONE) {
1193                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1194             }
1195 
1196         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1197             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1198             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1199             if (!replacing) {
1200                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1201                 if (mAppsCanBeOnRemoveableStorage) {
1202                     // Only rebind if we support removable storage.  It catches the case where
1203                     // apps on the external sd card need to be reloaded
1204                     startLoaderFromBackground();
1205                 }
1206             } else {
1207                 // If we are replacing then just update the packages in the list
1208                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1209                         packages));
1210             }
1211         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1212             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1213             if (!replacing) {
1214                 String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1215                 enqueuePackageUpdated(new PackageUpdatedTask(
1216                             PackageUpdatedTask.OP_UNAVAILABLE, packages));
1217             }
1218             // else, we are replacing the packages, so ignore this event and wait for
1219             // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time
1220         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1221             // If we have changed locale we need to clear out the labels in all apps/workspace.
1222             forceReload();
1223         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1224              // Check if configuration change was an mcc/mnc change which would affect app resources
1225              // and we would need to clear out the labels in all apps/workspace. Same handling as
1226              // above for ACTION_LOCALE_CHANGED
1227              Configuration currentConfig = context.getResources().getConfiguration();
1228              if (mPreviousConfigMcc != currentConfig.mcc) {
1229                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1230                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1231                    forceReload();
1232              }
1233              // Update previousConfig
1234              mPreviousConfigMcc = currentConfig.mcc;
1235         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1236                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1237             if (mCallbacks != null) {
1238                 Callbacks callbacks = mCallbacks.get();
1239                 if (callbacks != null) {
1240                     callbacks.bindSearchablesChanged();
1241                 }
1242             }
1243         }
1244     }
1245 
1246     private void forceReload() {
1247         resetLoadedState(true, true);
1248 
1249         // Do this here because if the launcher activity is running it will be restarted.
1250         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1251         // to reload.
1252         startLoaderFromBackground();
1253     }
1254 
1255     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1256         synchronized (mLock) {
1257             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1258             // mWorkspaceLoaded to true later
1259             stopLoaderLocked();
1260             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1261             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1262         }
1263     }
1264 
1265     /**
1266      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1267      * configuration changes.  So whenever we trigger the loader from the background
1268      * tell the launcher that it needs to re-run the loader when it comes back instead
1269      * of doing it now.
1270      */
1271     public void startLoaderFromBackground() {
1272         boolean runLoader = false;
1273         if (mCallbacks != null) {
1274             Callbacks callbacks = mCallbacks.get();
1275             if (callbacks != null) {
1276                 // Only actually run the loader if they&#x27;re not paused.
1277                 if (!callbacks.setLoadOnResume()) {
1278                     runLoader = true;
1279                 }
1280             }
1281         }
1282         if (runLoader) {
1283             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1284         }
1285     }
1286 
1287     // If there is already a loader task running, tell it to stop.
1288     // returns true if isLaunching() was true on the old task
1289     private boolean stopLoaderLocked() {
1290         boolean isLaunching = false;
1291         LoaderTask oldTask = mLoaderTask;
1292         if (oldTask != null) {
1293             if (oldTask.isLaunching()) {
1294                 isLaunching = true;
1295             }
1296             oldTask.stopLocked();
1297         }
1298         return isLaunching;
1299     }
1300 
1301     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1302         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1303     }
1304 
1305     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1306         synchronized (mLock) {
1307             if (DEBUG_LOADERS) {
1308                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1309             }
1310 
1311             // Clear any deferred bind-runnables from the synchronized load process
1312             // We must do this before any loading/binding is scheduled below.
1313             mDeferredBindRunnables.clear();
1314 
1315             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1316             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1317                 // If there is already one running, tell it to stop.
1318                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1319                 isLaunching = isLaunching || stopLoaderLocked();
1320                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1321                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1322                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1323                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1324                 } else {
1325                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1326                     sWorker.post(mLoaderTask);
1327                 }
1328             }
1329         }
1330     }
1331 
1332     void bindRemainingSynchronousPages() {
1333         // Post the remaining side pages to be loaded
1334         if (!mDeferredBindRunnables.isEmpty()) {
1335             for (final Runnable r : mDeferredBindRunnables) {
1336                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1337             }
1338             mDeferredBindRunnables.clear();
1339         }
1340     }
1341 
1342     public void stopLoader() {
1343         synchronized (mLock) {
1344             if (mLoaderTask != null) {
1345                 mLoaderTask.stopLocked();
1346             }
1347         }
1348     }
1349 
1350     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1351     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1352         final ContentResolver contentResolver = context.getContentResolver();
1353         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1354         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1355         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1356 
1357         try {
1358             final int idIndex = sc.getColumnIndexOrThrow(
1359                     LauncherSettings.WorkspaceScreens._ID);
1360             final int rankIndex = sc.getColumnIndexOrThrow(
1361                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1362             while (sc.moveToNext()) {
1363                 try {
1364                     long screenId = sc.getLong(idIndex);
1365                     int rank = sc.getInt(rankIndex);
1366                     orderedScreens.put(rank, screenId);
1367                 } catch (Exception e) {
<abbr title="1368                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1368                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1369                 }
1370             }
1371         } finally {
1372             sc.close();
1373         }
1374 
1375         // Log to disk
1376         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1377         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1378         for (Integer i : orderedScreens.keySet()) {
1379             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1380         }
1381         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1382                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1383         return orderedScreens;
1384     }
1385 
1386     public boolean isAllAppsLoaded() {
1387         return mAllAppsLoaded;
1388     }
1389 
1390     boolean isLoadingWorkspace() {
1391         synchronized (mLock) {
1392             if (mLoaderTask != null) {
1393                 return mLoaderTask.isLoadingWorkspace();
1394             }
1395         }
1396         return false;
1397     }
1398 
1399     /**
1400      * Runnable for the thread that loads the contents of the launcher:
1401      *   - workspace icons
1402      *   - widgets
1403      *   - all apps icons
1404      */
1405     private class LoaderTask implements Runnable {
1406         private Context mContext;
1407         private boolean mIsLaunching;
1408         private boolean mIsLoadingAndBindingWorkspace;
1409         private boolean mStopped;
1410         private boolean mLoadAndBindStepFinished;
1411         private int mFlags;
1412 
1413         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1414 
1415         LoaderTask(Context context, boolean isLaunching, int flags) {
1416             mContext = context;
1417             mIsLaunching = isLaunching;
1418             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1419             mFlags = flags;
1420         }
1421 
1422         boolean isLaunching() {
1423             return mIsLaunching;
1424         }
1425 
1426         boolean isLoadingWorkspace() {
1427             return mIsLoadingAndBindingWorkspace;
1428         }
1429 
1430         /** Returns whether this is an upgrade path */
1431         private boolean loadAndBindWorkspace() {
1432             mIsLoadingAndBindingWorkspace = true;
1433 
1434             // Load the workspace
1435             if (DEBUG_LOADERS) {
1436                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1437             }
1438 
1439             boolean isUpgradePath = false;
1440             if (!mWorkspaceLoaded) {
1441                 isUpgradePath = loadWorkspace();
1442                 synchronized (LoaderTask.this) {
1443                     if (mStopped) {
1444                         return isUpgradePath;
1445                     }
1446                     mWorkspaceLoaded = true;
1447                 }
1448             }
1449 
1450             // Bind the workspace
1451             bindWorkspace(-1, isUpgradePath);
1452             return isUpgradePath;
1453         }
1454 
1455         private void waitForIdle() {
1456             // Wait until the either we&#x27;re stopped or the other threads are done.
1457             // This way we don&#x27;t start loading all apps until the workspace has settled
1458             // down.
1459             synchronized (LoaderTask.this) {
1460                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1461 
1462                 mHandler.postIdle(new Runnable() {
1463                         public void run() {
1464                             synchronized (LoaderTask.this) {
1465                                 mLoadAndBindStepFinished = true;
1466                                 if (DEBUG_LOADERS) {
1467                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1468                                 }
1469                                 LoaderTask.this.notify();
1470                             }
1471                         }
1472                     });
1473 
1474                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1475                     try {
1476                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1477                         // wait no longer than 1sec at a time
1478                         this.wait(1000);
1479                     } catch (InterruptedException ex) {
1480                         // Ignore
1481                     }
1482                 }
1483                 if (DEBUG_LOADERS) {
1484                     Log.d(TAG, &quot;waited &quot;
1485                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1486                             + &quot;ms for previous step to finish binding&quot;);
1487                 }
1488             }
1489         }
1490 
1491         void runBindSynchronousPage(int synchronousBindPage) {
1492             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1493                 // Ensure that we have a valid page index to load synchronously
1494                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1495                         &quot;valid page index&quot;);
1496             }
1497             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1498                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1499                 // loaded already (we should load everything asynchronously in that case)
1500                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1501             }
1502             synchronized (mLock) {
1503                 if (mIsLoaderTaskRunning) {
1504                     // Ensure that we are never running the background loading at this point since
1505                     // we also touch the background collections
1506                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1507                 }
1508             }
1509 
1510             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1511             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1512             //      this call is synchronous, we can get away with not locking).
1513 
1514             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1515             // operations from the previous activity.  We need to ensure that all queued operations
1516             // are executed before any synchronous binding work is done.
1517             mHandler.flush();
1518 
1519             // Divide the set of loaded items into those that we are binding synchronously, and
1520             // everything else that is to be bound normally (asynchronously).
1521             bindWorkspace(synchronousBindPage, false);
1522             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1523             //      arise from that.
1524             onlyBindAllApps();
1525         }
1526 
1527         public void run() {
1528             boolean isUpgrade = false;
1529 
1530             synchronized (mLock) {
1531                 mIsLoaderTaskRunning = true;
1532             }
1533             // Optimize for end-user experience: if the Launcher is up and // running with the
1534             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1535             // workspace first (default).
1536             keep_running: {
1537                 // Elevate priority when Home launches for the first time to avoid
1538                 // starving at boot time. Staring at a blank home is not cool.
1539                 synchronized (mLock) {
1540                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1541                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1542                     android.os.Process.setThreadPriority(mIsLaunching
1543                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1544                 }
1545                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1546                 isUpgrade = loadAndBindWorkspace();
1547 
1548                 if (mStopped) {
1549                     break keep_running;
1550                 }
1551 
1552                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1553                 // settled down.
1554                 synchronized (mLock) {
1555                     if (mIsLaunching) {
1556                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1557                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1558                     }
1559                 }
1560                 waitForIdle();
1561 
1562                 // second step
1563                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1564                 loadAndBindAllApps();
1565 
1566                 // Restore the default thread priority after we are done loading items
1567                 synchronized (mLock) {
1568                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1569                 }
1570             }
1571 
1572             // Update the saved icons if necessary
1573             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1574             synchronized (sBgLock) {
1575                 for (Object key : sBgDbIconCache.keySet()) {
1576                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1577                 }
1578                 sBgDbIconCache.clear();
1579             }
1580 
1581             if (LauncherAppState.isDisableAllApps()) {
1582                 // Ensure that all the applications that are in the system are
1583                 // represented on the home screen.
1584                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1585                     verifyApplications();
1586                 }
1587             }
1588 
1589             // Clear out this reference, otherwise we end up holding it until all of the
1590             // callback runnables are done.
1591             mContext = null;
1592 
1593             synchronized (mLock) {
1594                 // If we are still the last one to be scheduled, remove ourselves.
1595                 if (mLoaderTask == this) {
1596                     mLoaderTask = null;
1597                 }
1598                 mIsLoaderTaskRunning = false;
1599             }
1600         }
1601 
1602         public void stopLocked() {
1603             synchronized (LoaderTask.this) {
1604                 mStopped = true;
1605                 this.notify();
1606             }
1607         }
1608 
1609         /**
1610          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1611          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1612          * object that was around when the deferred message was scheduled, and if there&#x27;s
1613          * a new Callbacks object around then also return null.  This will save us from
1614          * calling onto it with data that will be ignored.
1615          */
1616         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1617             synchronized (mLock) {
1618                 if (mStopped) {
1619                     return null;
1620                 }
1621 
1622                 if (mCallbacks == null) {
1623                     return null;
1624                 }
1625 
1626                 final Callbacks callbacks = mCallbacks.get();
1627                 if (callbacks != oldCallbacks) {
1628                     return null;
1629                 }
1630                 if (callbacks == null) {
1631                     Log.w(TAG, &quot;no mCallbacks&quot;);
1632                     return null;
1633                 }
1634 
1635                 return callbacks;
1636             }
1637         }
1638 
1639         private void verifyApplications() {
1640             final Context context = mApp.getContext();
1641 
1642             // Cross reference all the applications in our apps list with items in the workspace
1643             ArrayList&lt;ItemInfo&gt; tmpInfos;
1644             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1645             synchronized (sBgLock) {
1646                 for (AppInfo app : mBgAllAppsList.data) {
1647                     tmpInfos = getItemInfoForComponentName(app.componentName);
1648                     if (tmpInfos.isEmpty()) {
1649                         // We are missing an application icon, so add this to the workspace
1650                         added.add(app);
1651                         // This is a rare event, so lets log it
1652                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1653                     }
1654                 }
1655             }
1656             if (!added.isEmpty()) {
1657                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1658                 addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());
1659             }
1660         }
1661 
1662         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1663         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1664                                            AtomicBoolean deleteOnInvalidPlacement) {
1665             LauncherAppState app = LauncherAppState.getInstance();
1666             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1667             final int countX = (int) grid.numColumns;
1668             final int countY = (int) grid.numRows;
1669 
1670             long containerIndex = item.screenId;
1671             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1672                 // Return early if we detect that an item is under the hotseat button
1673                 if (mCallbacks == null ||
1674                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1675                     deleteOnInvalidPlacement.set(true);
1676                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1677                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1678                             + item.cellY + &quot;) occupied by all apps&quot;);
1679                     return false;
1680                 }
1681 
1682                 final ItemInfo[][] hotseatItems =
1683                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1684 
1685                 if (item.screenId &gt;= grid.numHotseatIcons) {
1686                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1687                             + &quot; into hotseat position &quot; + item.screenId
1688                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1689                             + &quot;)&quot;);
1690                     return false;
1691                 }
1692 
1693                 if (hotseatItems != null) {
1694                     if (hotseatItems[(int) item.screenId][0] != null) {
1695                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1696                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1697                                 + item.cellY + &quot;) occupied by &quot;
1698                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1699                                 [(int) item.screenId][0]);
1700                             return false;
1701                     } else {
1702                         hotseatItems[(int) item.screenId][0] = item;
1703                         return true;
1704                     }
1705                 } else {
1706                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1707                     items[(int) item.screenId][0] = item;
1708                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1709                     return true;
1710                 }
1711             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1712                 // Skip further checking if it is not the hotseat or workspace container
1713                 return true;
1714             }
1715 
1716             if (!occupied.containsKey(item.screenId)) {
1717                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1718                 occupied.put(item.screenId, items);
1719             }
1720 
1721             final ItemInfo[][] screens = occupied.get(item.screenId);
1722             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1723                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1724                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1725                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1726                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1727                         + item.cellX + &quot;,&quot; + item.cellY
1728                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1729                 return false;
1730             }
1731 
1732             // Check if any workspace icons overlap with each other
1733             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1734                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1735                     if (screens[x][y] != null) {
1736                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1737                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1738                             + x + &quot;,&quot; + y
1739                             + &quot;) occupied by &quot;
1740                             + screens[x][y]);
1741                         return false;
1742                     }
1743                 }
1744             }
1745             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1746                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1747                     screens[x][y] = item;
1748                 }
1749             }
1750 
1751             return true;
1752         }
1753 
1754         /** Clears all the sBg data structures */
1755         private void clearSBgDataStructures() {
1756             synchronized (sBgLock) {
1757                 sBgWorkspaceItems.clear();
1758                 sBgAppWidgets.clear();
1759                 sBgFolders.clear();
1760                 sBgItemsIdMap.clear();
1761                 sBgDbIconCache.clear();
1762                 sBgWorkspaceScreens.clear();
1763             }
1764         }
1765 
1766         /** Returns whether this is an upgrade path */
1767         private boolean loadWorkspace() {
1768             // Log to disk
1769             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1770 
1771             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1772 
1773             final Context context = mContext;
1774             final ContentResolver contentResolver = context.getContentResolver();
1775             final PackageManager manager = context.getPackageManager();
1776             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1777             final boolean isSafeMode = manager.isSafeMode();
1778 
1779             LauncherAppState app = LauncherAppState.getInstance();
1780             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1781             int countX = (int) grid.numColumns;
1782             int countY = (int) grid.numRows;
1783 
1784             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1785                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1786                 LauncherAppState.getLauncherProvider().deleteDatabase();
1787             }
1788 
1789             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1790                 // append the user&#x27;s Launcher2 shortcuts
1791                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1792                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1793             } else {
1794                 // Make sure the default workspace is loaded
1795                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1796                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);
1797             }
1798 
1799             // Check if we need to do any upgrade-path logic
1800             // (Includes having just imported default favorites)
1801             boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();
1802 
1803             // Log to disk
1804             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1805 
1806             synchronized (sBgLock) {
1807                 clearSBgDataStructures();
1808 
1809                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1810                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1811                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1812                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1813                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1814 
1815                 // +1 for the hotseat (it can be larger than the workspace)
1816                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1817                 // before any earlier duplicates)
1818                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1819 
1820                 try {
1821                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1822                     final int intentIndex = c.getColumnIndexOrThrow
1823                             (LauncherSettings.Favorites.INTENT);
1824                     final int titleIndex = c.getColumnIndexOrThrow
1825                             (LauncherSettings.Favorites.TITLE);
1826                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1827                             LauncherSettings.Favorites.ICON_TYPE);
1828                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1829                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1830                             LauncherSettings.Favorites.ICON_PACKAGE);
1831                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1832                             LauncherSettings.Favorites.ICON_RESOURCE);
1833                     final int containerIndex = c.getColumnIndexOrThrow(
1834                             LauncherSettings.Favorites.CONTAINER);
1835                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1836                             LauncherSettings.Favorites.ITEM_TYPE);
1837                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1838                             LauncherSettings.Favorites.APPWIDGET_ID);
1839                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1840                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1841                     final int screenIndex = c.getColumnIndexOrThrow(
1842                             LauncherSettings.Favorites.SCREEN);
1843                     final int cellXIndex = c.getColumnIndexOrThrow
1844                             (LauncherSettings.Favorites.CELLX);
1845                     final int cellYIndex = c.getColumnIndexOrThrow
1846                             (LauncherSettings.Favorites.CELLY);
1847                     final int spanXIndex = c.getColumnIndexOrThrow
1848                             (LauncherSettings.Favorites.SPANX);
1849                     final int spanYIndex = c.getColumnIndexOrThrow(
1850                             LauncherSettings.Favorites.SPANY);
1851                     final int restoredIndex = c.getColumnIndexOrThrow(
1852                             LauncherSettings.Favorites.RESTORED);
1853                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1854                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1855                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1856 
1857                     ShortcutInfo info;
1858                     String intentDescription;
1859                     LauncherAppWidgetInfo appWidgetInfo;
1860                     int container;
1861                     long id;
1862                     Intent intent;
1863 
1864                     while (!mStopped &amp;&amp; c.moveToNext()) {
1865                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1866                         try {
1867                             int itemType = c.getInt(itemTypeIndex);
1868                             boolean restored = 0 != c.getInt(restoredIndex);
1869 
1870                             switch (itemType) {
1871                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1872                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1873                                 id = c.getLong(idIndex);
1874                                 intentDescription = c.getString(intentIndex);
1875                                 try {
1876                                     intent = Intent.parseUri(intentDescription, 0);
1877                                     ComponentName cn = intent.getComponent();
1878                                     if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {
1879                                         if (restored) {
1880                                             // might be installed later
1881                                             Launcher.addDumpLog(TAG,
1882                                                     &quot;package not yet restored: &quot; + cn, true);
1883                                         } else {
1884                                             if (!mAppsCanBeOnRemoveableStorage) {
1885                                                 // Log the invalid package, and remove it
1886                                                 Launcher.addDumpLog(TAG,
1887                                                         &quot;Invalid package removed: &quot; + cn, true);
1888                                                 itemsToRemove.add(id);
1889                                             } else {
1890                                                 // If apps can be on external storage, then we just
1891                                                 // leave them for the user to remove (maybe add
1892                                                 // visual treatment to it)
1893                                                 Launcher.addDumpLog(TAG,
1894                                                         &quot;Invalid package found: &quot; + cn, true);
1895                                             }
1896                                             continue;
1897                                         }
1898                                     } else if (restored) {
1899                                         // no special handling necessary for this restored item
1900                                         restoredRows.add(id);
1901                                         restored = false;
1902                                     }
1903                                 } catch (URISyntaxException e) {
1904                                     Launcher.addDumpLog(TAG,
1905                                             &quot;Invalid uri: &quot; + intentDescription, true);
1906                                     continue;
1907                                 }
1908 
1909                                 if (restored) {
1910                                     Launcher.addDumpLog(TAG,
1911                                             &quot;constructing info for partially restored package&quot;,
1912                                             true);
1913                                     info = getRestoredItemInfo(c, titleIndex);
1914                                     intent = getRestoredItemIntent(c, context, intent);
1915                                 } else if (itemType ==
1916                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1917                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1918                                             titleIndex, mLabelCache);
1919                                 } else {
1920                                     info = getShortcutInfo(c, context, iconTypeIndex,
1921                                             iconPackageIndex, iconResourceIndex, iconIndex,
1922                                             titleIndex);
1923 
1924                                     // App shortcuts that used to be automatically added to Launcher
1925                                     // didn&#x27;t always have the correct intent flags set, so do that
1926                                     // here
1927                                     if (intent.getAction() != null &amp;&amp;
1928                                         intent.getCategories() != null &amp;&amp;
1929                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1930                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1931                                         intent.addFlags(
1932                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1933                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1934                                     }
1935                                 }
1936 
1937                                 if (info != null) {
1938                                     info.id = id;
1939                                     info.intent = intent;
1940                                     container = c.getInt(containerIndex);
1941                                     info.container = container;
1942                                     info.screenId = c.getInt(screenIndex);
1943                                     info.cellX = c.getInt(cellXIndex);
1944                                     info.cellY = c.getInt(cellYIndex);
1945                                     info.spanX = 1;
1946                                     info.spanY = 1;
1947 
1948                                     // check &amp; update map of what&#x27;s occupied
1949                                     deleteOnInvalidPlacement.set(false);
1950                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
1951                                         if (deleteOnInvalidPlacement.get()) {
1952                                             itemsToRemove.add(id);
1953                                         }
1954                                         break;
1955                                     }
1956 
1957                                     switch (container) {
1958                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1959                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1960                                         sBgWorkspaceItems.add(info);
1961                                         break;
1962                                     default:
1963                                         // Item is in a user folder
1964                                         FolderInfo folderInfo =
1965                                                 findOrMakeFolder(sBgFolders, container);
1966                                         folderInfo.add(info);
1967                                         break;
1968                                     }
1969                                     sBgItemsIdMap.put(info.id, info);
1970 
1971                                     // now that we&#x27;ve loaded everthing re-save it with the
1972                                     // icon in case it disappears somehow.
1973                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1974                                 } else {
1975                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1976                                 }
1977                                 break;
1978 
1979                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1980                                 id = c.getLong(idIndex);
1981                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1982 
1983                                 folderInfo.title = c.getString(titleIndex);
1984                                 folderInfo.id = id;
1985                                 container = c.getInt(containerIndex);
1986                                 folderInfo.container = container;
1987                                 folderInfo.screenId = c.getInt(screenIndex);
1988                                 folderInfo.cellX = c.getInt(cellXIndex);
1989                                 folderInfo.cellY = c.getInt(cellYIndex);
1990                                 folderInfo.spanX = 1;
1991                                 folderInfo.spanY = 1;
1992 
1993                                 // check &amp; update map of what&#x27;s occupied
1994                                 deleteOnInvalidPlacement.set(false);
1995                                 if (!checkItemPlacement(occupied, folderInfo,
1996                                         deleteOnInvalidPlacement)) {
1997                                     if (deleteOnInvalidPlacement.get()) {
1998                                         itemsToRemove.add(id);
1999                                     }
2000                                     break;
2001                                 }
2002 
2003                                 switch (container) {
2004                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2005                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2006                                         sBgWorkspaceItems.add(folderInfo);
2007                                         break;
2008                                 }
2009 
2010                                 if (restored) {
2011                                     // no special handling required for restored folders
2012                                     restoredRows.add(id);
2013                                 }
2014 
2015                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2016                                 sBgFolders.put(folderInfo.id, folderInfo);
2017                                 break;
2018 
2019                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2020                                 // Read all Launcher-specific widget details
2021                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2022                                 String savedProvider = c.getString(appWidgetProviderIndex);
2023 
2024                                 id = c.getLong(idIndex);
2025 
2026                                 final AppWidgetProviderInfo provider =
2027                                         widgets.getAppWidgetInfo(appWidgetId);
2028 
2029                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
2030                                         provider.provider.getPackageName() == null)) {
2031                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
2032                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
2033                                     Log.e(TAG, log);
2034                                     Launcher.addDumpLog(TAG, log, false);
2035                                     itemsToRemove.add(id);
2036                                 } else {
2037                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2038                                             provider.provider);
2039                                     appWidgetInfo.id = id;
2040                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2041                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2042                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2043                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2044                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2045                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
2046                                     appWidgetInfo.minSpanX = minSpan[0];
2047                                     appWidgetInfo.minSpanY = minSpan[1];
2048 
2049                                     container = c.getInt(containerIndex);
2050                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2051                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2052                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2053                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2054                                         continue;
2055                                     }
2056 
2057                                     appWidgetInfo.container = c.getInt(containerIndex);
2058                                     // check &amp; update map of what&#x27;s occupied
2059                                     deleteOnInvalidPlacement.set(false);
2060                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2061                                             deleteOnInvalidPlacement)) {
2062                                         if (deleteOnInvalidPlacement.get()) {
2063                                             itemsToRemove.add(id);
2064                                         }
2065                                         break;
2066                                     }
2067                                     String providerName = provider.provider.flattenToString();
2068                                     if (!providerName.equals(savedProvider)) {
2069                                         ContentValues values = new ContentValues();
2070                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2071                                                 providerName);
2072                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2073                                         String[] args = {Integer.toString(c.getInt(idIndex))};
2074                                         contentResolver.update(contentUri, values, where, args);
2075                                     }
2076                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2077                                     sBgAppWidgets.add(appWidgetInfo);
2078                                 }
2079                                 break;
2080                             }
2081                         } catch (Exception e) {
2082                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2083                         }
2084                     }
2085                 } finally {
2086                     if (c != null) {
2087                         c.close();
2088                     }
2089                 }
2090 
2091                 // Break early if we&#x27;ve stopped loading
2092                 if (mStopped) {
2093                     clearSBgDataStructures();
2094                     return false;
2095                 }
2096 
2097                 if (itemsToRemove.size() &gt; 0) {
2098                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2099                             LauncherSettings.Favorites.CONTENT_URI);
2100                     // Remove dead items
2101                     for (long id : itemsToRemove) {
2102                         if (DEBUG_LOADERS) {
2103                             Log.d(TAG, &quot;Removed id = &quot; + id);
2104                         }
2105                         // Don&#x27;t notify content observers
2106                         try {
2107                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2108                                     null, null);
2109                         } catch (RemoteException e) {
2110                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2111                         }
2112                     }
2113                 }
2114 
2115                 if (restoredRows.size() &gt; 0) {
2116                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2117                             LauncherSettings.Favorites.CONTENT_URI);
2118                     // Update restored items that no longer require special handling
2119                     try {
2120                         StringBuilder selectionBuilder = new StringBuilder();
2121                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2122                         selectionBuilder.append(&quot; IN (&quot;);
2123                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2124                         selectionBuilder.append(&quot;)&quot;);
2125                         ContentValues values = new ContentValues();
2126                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2127                         updater.update(LauncherSettings.Favorites.CONTENT_URI,
2128                                 values, selectionBuilder.toString(), null);
2129                     } catch (RemoteException e) {
2130                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2131                     }
2132                 }
2133 
2134                 if (loadedOldDb) {
2135                     long maxScreenId = 0;
2136                     // If we&#x27;re importing we use the old screen order.
2137                     for (ItemInfo item: sBgItemsIdMap.values()) {
2138                         long screenId = item.screenId;
2139                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2140                                 !sBgWorkspaceScreens.contains(screenId)) {
2141                             sBgWorkspaceScreens.add(screenId);
2142                             if (screenId &gt; maxScreenId) {
2143                                 maxScreenId = screenId;
2144                             }
2145                         }
2146                     }
2147                     Collections.sort(sBgWorkspaceScreens);
2148                     // Log to disk
2149                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2150                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2151                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2152 
2153                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2154                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2155 
2156                     // Update the max item id after we load an old db
2157                     long maxItemId = 0;
2158                     // If we&#x27;re importing we use the old screen order.
2159                     for (ItemInfo item: sBgItemsIdMap.values()) {
2160                         maxItemId = Math.max(maxItemId, item.id);
2161                     }
2162                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2163                 } else {
2164                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2165                     for (Integer i : orderedScreens.keySet()) {
2166                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2167                     }
2168                     // Log to disk
2169                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2170                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2171 
2172                     // Remove any empty screens
2173                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2174                     for (ItemInfo item: sBgItemsIdMap.values()) {
2175                         long screenId = item.screenId;
2176                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2177                                 unusedScreens.contains(screenId)) {
2178                             unusedScreens.remove(screenId);
2179                         }
2180                     }
2181 
2182                     // If there are any empty screens remove them, and update.
2183                     if (unusedScreens.size() != 0) {
2184                         // Log to disk
2185                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2186                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2187 
2188                         sBgWorkspaceScreens.removeAll(unusedScreens);
2189                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2190                     }
2191                 }
2192 
2193                 if (DEBUG_LOADERS) {
2194                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2195                     Log.d(TAG, &quot;workspace layout: &quot;);
2196                     int nScreens = occupied.size();
2197                     for (int y = 0; y &lt; countY; y++) {
2198                         String line = &quot;&quot;;
2199 
2200                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2201                         while (iter.hasNext()) {
2202                             long screenId = iter.next();
2203                             if (screenId &gt; 0) {
2204                                 line += &quot; | &quot;;
2205                             }
2206                             for (int x = 0; x &lt; countX; x++) {
2207                                 line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
2208                             }
2209                         }
2210                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2211                     }
2212                 }
2213             }
2214             return loadedOldDb;
2215         }
2216 
2217         /** Filters the set of items who are directly or indirectly (via another container) on the
2218          * specified screen. */
2219         private void filterCurrentWorkspaceItems(long currentScreenId,
2220                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2221                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2222                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2223             // Purge any null ItemInfos
2224             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2225             while (iter.hasNext()) {
2226                 ItemInfo i = iter.next();
2227                 if (i == null) {
2228                     iter.remove();
2229                 }
2230             }
2231 
2232             // Order the set of items by their containers first, this allows use to walk through the
2233             // list sequentially, build up a list of containers that are in the specified screen,
2234             // as well as all items in those containers.
2235             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2236             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2237                 @Override
2238                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2239                     return (int) (lhs.container - rhs.container);
2240                 }
2241             });
2242             for (ItemInfo info : allWorkspaceItems) {
2243                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2244                     if (info.screenId == currentScreenId) {
2245                         currentScreenItems.add(info);
2246                         itemsOnScreen.add(info.id);
2247                     } else {
2248                         otherScreenItems.add(info);
2249                     }
2250                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2251                     currentScreenItems.add(info);
2252                     itemsOnScreen.add(info.id);
2253                 } else {
2254                     if (itemsOnScreen.contains(info.container)) {
2255                         currentScreenItems.add(info);
2256                         itemsOnScreen.add(info.id);
2257                     } else {
2258                         otherScreenItems.add(info);
2259                     }
2260                 }
2261             }
2262         }
2263 
2264         /** Filters the set of widgets which are on the specified screen. */
2265         private void filterCurrentAppWidgets(long currentScreenId,
2266                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2267                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2268                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2269 
2270             for (LauncherAppWidgetInfo widget : appWidgets) {
2271                 if (widget == null) continue;
2272                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2273                         widget.screenId == currentScreenId) {
2274                     currentScreenWidgets.add(widget);
2275                 } else {
2276                     otherScreenWidgets.add(widget);
2277                 }
2278             }
2279         }
2280 
2281         /** Filters the set of folders which are on the specified screen. */
2282         private void filterCurrentFolders(long currentScreenId,
2283                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2284                 HashMap&lt;Long, FolderInfo&gt; folders,
2285                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2286                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2287 
2288             for (long id : folders.keySet()) {
2289                 ItemInfo info = itemsIdMap.get(id);
2290                 FolderInfo folder = folders.get(id);
2291                 if (info == null || folder == null) continue;
2292                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2293                         info.screenId == currentScreenId) {
2294                     currentScreenFolders.put(id, folder);
2295                 } else {
2296                     otherScreenFolders.put(id, folder);
2297                 }
2298             }
2299         }
2300 
2301         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2302          * right) */
2303         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2304             final LauncherAppState app = LauncherAppState.getInstance();
2305             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2306             // XXX: review this
2307             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2308                 @Override
2309                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2310                     int cellCountX = (int) grid.numColumns;
2311                     int cellCountY = (int) grid.numRows;
2312                     int screenOffset = cellCountX * cellCountY;
2313                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2314                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2315                             lhs.cellY * cellCountX + lhs.cellX);
2316                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2317                             rhs.cellY * cellCountX + rhs.cellX);
2318                     return (int) (lr - rr);
2319                 }
2320             });
2321         }
2322 
2323         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2324                 final ArrayList&lt;Long&gt; orderedScreens) {
2325             final Runnable r = new Runnable() {
2326                 @Override
2327                 public void run() {
2328                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2329                     if (callbacks != null) {
2330                         callbacks.bindScreens(orderedScreens);
2331                     }
2332                 }
2333             };
2334             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2335         }
2336 
2337         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2338                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2339                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2340                 final HashMap&lt;Long, FolderInfo&gt; folders,
2341                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2342 
2343             final boolean postOnMainThread = (deferredBindRunnables != null);
2344 
2345             // Bind the workspace items
2346             int N = workspaceItems.size();
2347             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2348                 final int start = i;
2349                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2350                 final Runnable r = new Runnable() {
2351                     @Override
2352                     public void run() {
2353                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2354                         if (callbacks != null) {
2355                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2356                                     false);
2357                         }
2358                     }
2359                 };
2360                 if (postOnMainThread) {
2361                     deferredBindRunnables.add(r);
2362                 } else {
2363                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2364                 }
2365             }
2366 
2367             // Bind the folders
2368             if (!folders.isEmpty()) {
2369                 final Runnable r = new Runnable() {
2370                     public void run() {
2371                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2372                         if (callbacks != null) {
2373                             callbacks.bindFolders(folders);
2374                         }
2375                     }
2376                 };
2377                 if (postOnMainThread) {
2378                     deferredBindRunnables.add(r);
2379                 } else {
2380                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2381                 }
2382             }
2383 
2384             // Bind the widgets, one at a time
2385             N = appWidgets.size();
2386             for (int i = 0; i &lt; N; i++) {
2387                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2388                 final Runnable r = new Runnable() {
2389                     public void run() {
2390                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2391                         if (callbacks != null) {
2392                             callbacks.bindAppWidget(widget);
2393                         }
2394                     }
2395                 };
2396                 if (postOnMainThread) {
2397                     deferredBindRunnables.add(r);
2398                 } else {
2399                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2400                 }
2401             }
2402         }
2403 
2404         /**
2405          * Binds all loaded data to actual views on the main thread.
2406          */
2407         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2408             final long t = SystemClock.uptimeMillis();
2409             Runnable r;
2410 
2411             // Don&#x27;t use these two variables in any of the callback runnables.
2412             // Otherwise we hold a reference to them.
2413             final Callbacks oldCallbacks = mCallbacks.get();
2414             if (oldCallbacks == null) {
2415                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2416                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2417                 return;
2418             }
2419 
2420             // Save a copy of all the bg-thread collections
2421             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2422             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2423                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2424             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2425             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2426             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2427             synchronized (sBgLock) {
2428                 workspaceItems.addAll(sBgWorkspaceItems);
2429                 appWidgets.addAll(sBgAppWidgets);
2430                 folders.putAll(sBgFolders);
2431                 itemsIdMap.putAll(sBgItemsIdMap);
2432                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2433             }
2434 
2435             final boolean isLoadingSynchronously =
2436                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2437             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2438                 oldCallbacks.getCurrentWorkspaceScreen();
2439             if (currScreen &gt;= orderedScreenIds.size()) {
2440                 // There may be no workspace screens (just hotseat items and an empty page).
2441                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2442             }
2443             final int currentScreen = currScreen;
2444             final long currentScreenId = currentScreen &lt; 0
2445                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2446 
2447             // Load all the items that are on the current page first (and in the process, unbind
2448             // all the existing workspace items before we call startBinding() below.
2449             unbindWorkspaceItemsOnMainThread();
2450 
2451             // Separate the items that are on the current screen, and all the other remaining items
2452             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2453             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2454             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2455                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2456             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2457                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2458             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2459             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2460 
2461             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2462                     otherWorkspaceItems);
2463             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2464                     otherAppWidgets);
2465             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2466                     otherFolders);
2467             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2468             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2469 
2470             // Tell the workspace that we&#x27;re about to start binding items
2471             r = new Runnable() {
2472                 public void run() {
2473                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2474                     if (callbacks != null) {
2475                         callbacks.startBinding();
2476                     }
2477                 }
2478             };
2479             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2480 
2481             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2482 
2483             // Load items on the current page
2484             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2485                     currentFolders, null);
2486             if (isLoadingSynchronously) {
2487                 r = new Runnable() {
2488                     public void run() {
2489                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2490                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2491                             callbacks.onPageBoundSynchronously(currentScreen);
2492                         }
2493                     }
2494                 };
2495                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2496             }
2497 
2498             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2499             // work until after the first render)
2500             mDeferredBindRunnables.clear();
2501             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2502                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2503 
2504             // Tell the workspace that we&#x27;re done binding items
2505             r = new Runnable() {
2506                 public void run() {
2507                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2508                     if (callbacks != null) {
2509                         callbacks.finishBindingItems(isUpgradePath);
2510                     }
2511 
2512                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2513                     if (DEBUG_LOADERS) {
2514                         Log.d(TAG, &quot;bound workspace in &quot;
2515                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2516                     }
2517 
2518                     mIsLoadingAndBindingWorkspace = false;
2519                 }
2520             };
2521             if (isLoadingSynchronously) {
2522                 mDeferredBindRunnables.add(r);
2523             } else {
2524                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2525             }
2526         }
2527 
2528         private void loadAndBindAllApps() {
2529             if (DEBUG_LOADERS) {
2530                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2531             }
2532             if (!mAllAppsLoaded) {
2533                 loadAllApps();
2534                 synchronized (LoaderTask.this) {
2535                     if (mStopped) {
2536                         return;
2537                     }
2538                     mAllAppsLoaded = true;
2539                 }
2540             } else {
2541                 onlyBindAllApps();
2542             }
2543         }
2544 
2545         private void onlyBindAllApps() {
2546             final Callbacks oldCallbacks = mCallbacks.get();
2547             if (oldCallbacks == null) {
2548                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2549                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2550                 return;
2551             }
2552 
2553             // shallow copy
2554             @SuppressWarnings(&quot;unchecked&quot;)
2555             final ArrayList&lt;AppInfo&gt; list
2556                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2557             Runnable r = new Runnable() {
2558                 public void run() {
2559                     final long t = SystemClock.uptimeMillis();
2560                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2561                     if (callbacks != null) {
2562                         callbacks.bindAllApplications(list);
2563                     }
2564                     if (DEBUG_LOADERS) {
2565                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2566                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2567                     }
2568                 }
2569             };
2570             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2571             if (isRunningOnMainThread) {
2572                 r.run();
2573             } else {
2574                 mHandler.post(r);
2575             }
2576         }
2577 
2578         private void loadAllApps() {
2579             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2580 
2581             final Callbacks oldCallbacks = mCallbacks.get();
2582             if (oldCallbacks == null) {
2583                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2584                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2585                 return;
2586             }
2587 
2588             final PackageManager packageManager = mContext.getPackageManager();
2589             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2590             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2591 
2592             // Clear the list of apps
2593             mBgAllAppsList.clear();
2594 
2595             // Query for the set of apps
2596             final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2597             List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);
2598             if (DEBUG_LOADERS) {
2599                 Log.d(TAG, &quot;queryIntentActivities took &quot;
2600                         + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2601                 Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);
2602             }
2603             // Fail if we don&#x27;t have any apps
2604             if (apps == null || apps.isEmpty()) {
2605                 return;
2606             }
2607             // Sort the applications by name
2608             final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2609             Collections.sort(apps,
2610                     new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2611             if (DEBUG_LOADERS) {
2612                 Log.d(TAG, &quot;sort took &quot;
2613                         + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2614             }
2615 
2616             // Create the ApplicationInfos
2617             for (int i = 0; i &lt; apps.size(); i++) {
2618                 ResolveInfo app = apps.get(i);
2619                 // This builds the icon bitmaps.
2620                 mBgAllAppsList.add(new AppInfo(packageManager, app,
2621                         mIconCache, mLabelCache));
2622             }
2623 
2624             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2625             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2626             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2627 
2628             // Post callback on main thread
2629             mHandler.post(new Runnable() {
2630                 public void run() {
2631                     final long bindTime = SystemClock.uptimeMillis();
2632                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2633                     if (callbacks != null) {
2634                         callbacks.bindAllApplications(added);
2635                         if (DEBUG_LOADERS) {
2636                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2637                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2638                         }
2639                     } else {
2640                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2641                     }
2642                 }
2643             });
2644 
2645             if (DEBUG_LOADERS) {
2646                 Log.d(TAG, &quot;Icons processed in &quot;
2647                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2648             }
2649         }
2650 
2651         public void dumpState() {
2652             synchronized (sBgLock) {
2653                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2654                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2655                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2656                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2657                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2658             }
2659         }
2660     }
2661 
2662     void enqueuePackageUpdated(PackageUpdatedTask task) {
2663         sWorker.post(task);
2664     }
2665 
2666     private class PackageUpdatedTask implements Runnable {
2667         int mOp;
2668         String[] mPackages;
2669 
2670         public static final int OP_NONE = 0;
2671         public static final int OP_ADD = 1;
2672         public static final int OP_UPDATE = 2;
2673         public static final int OP_REMOVE = 3; // uninstlled
2674         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2675 
2676 
2677         public PackageUpdatedTask(int op, String[] packages) {
2678             mOp = op;
2679             mPackages = packages;
2680         }
2681 
2682         public void run() {
2683             final Context context = mApp.getContext();
2684 
2685             final String[] packages = mPackages;
2686             final int N = packages.length;
2687             switch (mOp) {
2688                 case OP_ADD:
2689                     for (int i=0; i&lt;N; i++) {
2690                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2691                         mIconCache.remove(packages[i]);
2692                         mBgAllAppsList.addPackage(context, packages[i]);
2693                     }
2694                     break;
2695                 case OP_UPDATE:
2696                     for (int i=0; i&lt;N; i++) {
2697                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2698                         mBgAllAppsList.updatePackage(context, packages[i]);
2699                         WidgetPreviewLoader.removePackageFromDb(
2700                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
2701                     }
2702                     break;
2703                 case OP_REMOVE:
2704                 case OP_UNAVAILABLE:
2705                     for (int i=0; i&lt;N; i++) {
2706                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2707                         mBgAllAppsList.removePackage(packages[i]);
2708                         WidgetPreviewLoader.removePackageFromDb(
2709                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
2710                     }
2711                     break;
2712             }
2713 
2714             ArrayList&lt;AppInfo&gt; added = null;
2715             ArrayList&lt;AppInfo&gt; modified = null;
2716             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2717 
2718             if (mBgAllAppsList.added.size() &gt; 0) {
2719                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2720                 mBgAllAppsList.added.clear();
2721             }
2722             if (mBgAllAppsList.modified.size() &gt; 0) {
2723                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2724                 mBgAllAppsList.modified.clear();
2725             }
2726             if (mBgAllAppsList.removed.size() &gt; 0) {
2727                 removedApps.addAll(mBgAllAppsList.removed);
2728                 mBgAllAppsList.removed.clear();
2729             }
2730 
2731             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2732             if (callbacks == null) {
2733                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2734                 return;
2735             }
2736 
2737             if (added != null) {
2738                 // Ensure that we add all the workspace applications to the db
2739                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2740                 if (!LauncherAppState.isDisableAllApps()) {
2741                     addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);
2742                 } else {
2743                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2744                     addAndBindAddedApps(context, addedInfos, cb, added);
2745                 }
2746             }
2747             if (modified != null) {
2748                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2749 
2750                 // Update the launcher db to reflect the changes
2751                 for (AppInfo a : modifiedFinal) {
2752                     ArrayList&lt;ItemInfo&gt; infos =
2753                             getItemInfoForComponentName(a.componentName);
2754                     for (ItemInfo i : infos) {
2755                         if (isShortcutInfoUpdateable(i)) {
2756                             ShortcutInfo info = (ShortcutInfo) i;
2757                             info.title = a.title.toString();
2758                             updateItemInDatabase(context, info);
2759                         }
2760                     }
2761                 }
2762 
2763                 mHandler.post(new Runnable() {
2764                     public void run() {
2765                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2766                         if (callbacks == cb &amp;&amp; cb != null) {
2767                             callbacks.bindAppsUpdated(modifiedFinal);
2768                         }
2769                     }
2770                 });
2771             }
2772 
2773             final ArrayList&lt;String&gt; removedPackageNames =
2774                     new ArrayList&lt;String&gt;();
2775             if (mOp == OP_REMOVE) {
2776                 // Mark all packages in the broadcast to be removed
2777                 removedPackageNames.addAll(Arrays.asList(packages));
2778             } else if (mOp == OP_UPDATE) {
2779                 // Mark disabled packages in the broadcast to be removed
2780                 final PackageManager pm = context.getPackageManager();
2781                 for (int i=0; i&lt;N; i++) {
2782                     if (isPackageDisabled(pm, packages[i])) {
2783                         removedPackageNames.add(packages[i]);
2784                     }
2785                 }
2786             }
2787             // Remove all the components associated with this package
2788             for (String pn : removedPackageNames) {
2789                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);
2790                 for (ItemInfo i : infos) {
2791                     deleteItemFromDatabase(context, i);
2792                 }
2793             }
2794             // Remove all the specific components
2795             for (AppInfo a : removedApps) {
2796                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2797                 for (ItemInfo i : infos) {
2798                     deleteItemFromDatabase(context, i);
2799                 }
2800             }
2801             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
2802                 // Remove any queued items from the install queue
2803                 String spKey = LauncherAppState.getSharedPreferencesKey();
2804                 SharedPreferences sp =
2805                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2806                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2807                 // Call the components-removed callback
2808                 mHandler.post(new Runnable() {
2809                     public void run() {
2810                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2811                         if (callbacks == cb &amp;&amp; cb != null) {
2812                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps);
2813                         }
2814                     }
2815                 });
2816             }
2817 
2818             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
2819                 getSortedWidgetsAndShortcuts(context);
2820             mHandler.post(new Runnable() {
2821                 @Override
2822                 public void run() {
2823                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2824                     if (callbacks == cb &amp;&amp; cb != null) {
2825                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2826                     }
2827                 }
2828             });
2829 
2830             // Write all the logs to disk
2831             mHandler.post(new Runnable() {
2832                 public void run() {
2833                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2834                     if (callbacks == cb &amp;&amp; cb != null) {
2835                         callbacks.dumpLogsToLocalData();
2836                     }
2837                 }
2838             });
2839         }
2840     }
2841 
2842     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2843     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2844         PackageManager packageManager = context.getPackageManager();
2845         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2846         widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());
2847         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2848         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2849         Collections.sort(widgetsAndShortcuts,
2850             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));
2851         return widgetsAndShortcuts;
2852     }
2853 
2854     private static boolean isPackageDisabled(PackageManager pm, String packageName) {
2855         try {
2856             PackageInfo pi = pm.getPackageInfo(packageName, 0);
2857             return !pi.applicationInfo.enabled;
2858         } catch (NameNotFoundException e) {
2859             // Fall through
2860         }
2861         return false;
2862     }
2863 
2864     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {
2865         if (cn == null) {
2866             return false;
2867         }
2868         if (isPackageDisabled(pm, cn.getPackageName())) {
2869             return false;
2870         }
2871 
2872         try {
2873             // Check the activity
2874             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);
2875             return (pm.getActivityInfo(cn, 0) != null);
2876         } catch (NameNotFoundException e) {
2877             return false;
2878         }
2879     }
2880 
2881     /**
2882      * Make an ShortcutInfo object for a restored application or shortcut item that points
2883      * to a package that is not yet installed on the system.
2884      */
2885     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {
2886         final ShortcutInfo info = new ShortcutInfo();
2887         if (cursor != null) {
2888             info.title =  cursor.getString(titleIndex);
2889         } else {
2890             info.title = &quot;&quot;;
2891         }
2892         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));
2893         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2894         return info;
2895     }
2896 
2897     /**
2898      * Make an Intent object for a restored application or shortcut item that points
2899      * to the market page for the item.
2900      */
2901     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2902         ComponentName componentName = intent.getComponent();
2903         Intent marketIntent = new Intent(Intent.ACTION_VIEW);
2904         Uri marketUri = new Uri.Builder()
2905                 .scheme(&quot;market&quot;)
2906                 .authority(&quot;details&quot;)
2907                 .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())
2908                 .build();
2909         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());
2910         marketIntent.setData(marketUri);
2911         return marketIntent;
2912     }
2913 
2914     /**
2915      * This is called from the code that adds shortcuts from the intent receiver.  This
2916      * doesn&#x27;t have a Cursor, but
2917      */
2918     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2919         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2920     }
2921 
2922     /**
2923      * Make an ShortcutInfo object for a shortcut that is an application.
2924      *
2925      * If c is not null, then it will be used to fill in missing data like the title and icon.
2926      */
2927     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2928             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2929         ComponentName componentName = intent.getComponent();
2930         final ShortcutInfo info = new ShortcutInfo();
2931         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {
2932             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);
2933             return null;
2934         } else {
2935             try {
2936                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2937                 info.initFlagsAndFirstInstallTime(pi);
2938             } catch (NameNotFoundException e) {
2939                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +
2940                         componentName.getPackageName());
2941             }
2942         }
2943 
2944         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2945         // then return null &amp; delete this.
2946 
2947         // the resource -- This may implicitly give us back the fallback icon,
2948         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2949         // to avoid saving lots of copies of that in the database, and most apps
2950         // have icons anyway.
2951 
2952         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2953         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2954         // via resolveActivity().
2955         Bitmap icon = null;
2956         ResolveInfo resolveInfo = null;
2957         ComponentName oldComponent = intent.getComponent();
2958         Intent newIntent = new Intent(intent.getAction(), null);
2959         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2960         newIntent.setPackage(oldComponent.getPackageName());
2961         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2962         for (ResolveInfo i : infos) {
2963             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2964                     i.activityInfo.name);
2965             if (cn.equals(oldComponent)) {
2966                 resolveInfo = i;
2967             }
2968         }
2969         if (resolveInfo == null) {
2970             resolveInfo = manager.resolveActivity(intent, 0);
2971         }
2972         if (resolveInfo != null) {
2973             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2974         }
2975         // the db
2976         if (icon == null) {
2977             if (c != null) {
2978                 icon = getIconFromCursor(c, iconIndex, context);
2979             }
2980         }
2981         // the fallback icon
2982         if (icon == null) {
2983             icon = getFallbackIcon();
2984             info.usingFallbackIcon = true;
2985         }
2986         info.setIcon(icon);
2987 
2988         // from the resource
2989         if (resolveInfo != null) {
2990             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2991             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2992                 info.title = labelCache.get(key);
2993             } else {
2994                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2995                 if (labelCache != null) {
2996                     labelCache.put(key, info.title);
2997                 }
2998             }
2999         }
3000         // from the db
3001         if (info.title == null) {
3002             if (c != null) {
3003                 info.title =  c.getString(titleIndex);
3004             }
3005         }
3006         // fall back to the class name of the activity
3007         if (info.title == null) {
3008             info.title = componentName.getClassName();
3009         }
3010         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3011         return info;
3012     }
3013 
3014     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3015             ItemInfoFilter f) {
3016         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3017         for (ItemInfo i : infos) {
3018             if (i instanceof ShortcutInfo) {
3019                 ShortcutInfo info = (ShortcutInfo) i;
3020                 ComponentName cn = info.intent.getComponent();
3021                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3022                     filtered.add(info);
3023                 }
3024             } else if (i instanceof FolderInfo) {
3025                 FolderInfo info = (FolderInfo) i;
3026                 for (ShortcutInfo s : info.contents) {
3027                     ComponentName cn = s.intent.getComponent();
3028                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3029                         filtered.add(s);
3030                     }
3031                 }
3032             } else if (i instanceof LauncherAppWidgetInfo) {
3033                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3034                 ComponentName cn = info.providerName;
3035                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3036                     filtered.add(info);
3037                 }
3038             }
3039         }
3040         return new ArrayList&lt;ItemInfo&gt;(filtered);
3041     }
3042 
3043     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {
3044         ItemInfoFilter filter  = new ItemInfoFilter() {
3045             @Override
3046             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3047                 return cn.getPackageName().equals(pn);
3048             }
3049         };
3050         return filterItemInfos(sBgItemsIdMap.values(), filter);
3051     }
3052 
3053     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {
3054         ItemInfoFilter filter  = new ItemInfoFilter() {
3055             @Override
3056             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3057                 return cn.equals(cname);
3058             }
3059         };
3060         return filterItemInfos(sBgItemsIdMap.values(), filter);
3061     }
3062 
3063     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3064         if (i instanceof ShortcutInfo) {
3065             ShortcutInfo info = (ShortcutInfo) i;
3066             // We need to check for ACTION_MAIN otherwise getComponent() might
3067             // return null for some shortcuts (for instance, for shortcuts to
3068             // web pages.)
3069             Intent intent = info.intent;
3070             ComponentName name = intent.getComponent();
3071             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3072                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3073                 return true;
3074             }
3075         }
3076         return false;
3077     }
3078 
3079     /**
3080      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3081      */
3082     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3083             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3084             int titleIndex) {
3085 
3086         Bitmap icon = null;
3087         final ShortcutInfo info = new ShortcutInfo();
3088         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3089 
3090         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3091 
3092         info.title = c.getString(titleIndex);
3093 
3094         int iconType = c.getInt(iconTypeIndex);
3095         switch (iconType) {
3096         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3097             String packageName = c.getString(iconPackageIndex);
3098             String resourceName = c.getString(iconResourceIndex);
3099             PackageManager packageManager = context.getPackageManager();
3100             info.customIcon = false;
3101             // the resource
3102             try {
3103                 Resources resources = packageManager.getResourcesForApplication(packageName);
3104                 if (resources != null) {
3105                     final int id = resources.getIdentifier(resourceName, null, null);
3106                     icon = Utilities.createIconBitmap(
3107                             mIconCache.getFullResIcon(resources, id), context);
3108                 }
3109             } catch (Exception e) {
3110                 // drop this.  we have other places to look for icons
3111             }
3112             // the db
3113             if (icon == null) {
3114                 icon = getIconFromCursor(c, iconIndex, context);
3115             }
3116             // the fallback icon
3117             if (icon == null) {
3118                 icon = getFallbackIcon();
3119                 info.usingFallbackIcon = true;
3120             }
3121             break;
3122         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3123             icon = getIconFromCursor(c, iconIndex, context);
3124             if (icon == null) {
3125                 icon = getFallbackIcon();
3126                 info.customIcon = false;
3127                 info.usingFallbackIcon = true;
3128             } else {
3129                 info.customIcon = true;
3130             }
3131             break;
3132         default:
3133             icon = getFallbackIcon();
3134             info.usingFallbackIcon = true;
3135             info.customIcon = false;
3136             break;
3137         }
3138         info.setIcon(icon);
3139         return info;
3140     }
3141 
3142     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3143         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3144         final boolean debug = false;
3145         if (debug) {
3146             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3147                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3148         }
3149         byte[] data = c.getBlob(iconIndex);
3150         try {
3151             return Utilities.createIconBitmap(
3152                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3153         } catch (Exception e) {
3154             return null;
3155         }
3156     }
3157 
3158     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3159             int cellX, int cellY, boolean notify) {
3160         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3161         if (info == null) {
3162             return null;
3163         }
3164         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3165 
3166         return info;
3167     }
3168 
3169     /**
3170      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3171      */
3172     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3173             ComponentName component) {
3174         List&lt;AppWidgetProviderInfo&gt; widgets =
3175             AppWidgetManager.getInstance(context).getInstalledProviders();
3176         for (AppWidgetProviderInfo info : widgets) {
3177             if (info.provider.equals(component)) {
3178                 return info;
3179             }
3180         }
3181         return null;
3182     }
3183 
3184     /**
3185      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
3186      */
3187     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
3188         final PackageManager packageManager = context.getPackageManager();
3189         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
3190             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
3191 
3192         final Intent supportsIntent =
3193             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
3194         supportsIntent.setType(mimeType);
3195 
3196         // Create a set of widget configuration components that we can test against
3197         final List&lt;AppWidgetProviderInfo&gt; widgets =
3198             AppWidgetManager.getInstance(context).getInstalledProviders();
3199         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
3200             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
3201         for (AppWidgetProviderInfo info : widgets) {
3202             configurationComponentToWidget.put(info.configure, info);
3203         }
3204 
3205         // Run through each of the intents that can handle this type of clip data, and cross
3206         // reference them with the components that are actual configuration components
3207         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
3208                 PackageManager.MATCH_DEFAULT_ONLY);
3209         for (ResolveInfo info : activities) {
3210             final ActivityInfo activityInfo = info.activityInfo;
3211             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
3212                     activityInfo.name);
3213             if (configurationComponentToWidget.containsKey(infoComponent)) {
3214                 supportedConfigurationActivities.add(
3215                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
3216                                 configurationComponentToWidget.get(infoComponent)));
3217             }
3218         }
3219         return supportedConfigurationActivities;
3220     }
3221 
3222     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3223         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3224         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3225         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3226 
3227         if (intent == null) {
3228             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3229             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3230             return null;
3231         }
3232 
3233         Bitmap icon = null;
3234         boolean customIcon = false;
3235         ShortcutIconResource iconResource = null;
3236 
3237         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3238             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3239             customIcon = true;
3240         } else {
3241             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3242             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3243                 try {
3244                     iconResource = (ShortcutIconResource) extra;
3245                     final PackageManager packageManager = context.getPackageManager();
3246                     Resources resources = packageManager.getResourcesForApplication(
3247                             iconResource.packageName);
3248                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3249                     icon = Utilities.createIconBitmap(
3250                             mIconCache.getFullResIcon(resources, id), context);
3251                 } catch (Exception e) {
3252                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3253                 }
3254             }
3255         }
3256 
3257         final ShortcutInfo info = new ShortcutInfo();
3258 
3259         if (icon == null) {
3260             if (fallbackIcon != null) {
3261                 icon = fallbackIcon;
3262             } else {
3263                 icon = getFallbackIcon();
3264                 info.usingFallbackIcon = true;
3265             }
3266         }
3267         info.setIcon(icon);
3268 
3269         info.title = name;
3270         info.intent = intent;
3271         info.customIcon = customIcon;
3272         info.iconResource = iconResource;
3273 
3274         return info;
3275     }
3276 
3277     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3278             int iconIndex) {
3279         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3280         if (!mAppsCanBeOnRemoveableStorage) {
3281             return false;
3282         }
3283         // If this icon doesn&#x27;t have a custom icon, check to see
3284         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3285         // we&#x27;re going to show, store what we are going to show back
3286         // into the DB.  We do this so when we&#x27;re loading, if the
3287         // package manager can&#x27;t find an icon (for example because
3288         // the app is on SD) then we can use that instead.
3289         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3290             cache.put(info, c.getBlob(iconIndex));
3291             return true;
3292         }
3293         return false;
3294     }
3295     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3296         boolean needSave = false;
3297         try {
3298             if (data != null) {
3299                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3300                 Bitmap loaded = info.getIcon(mIconCache);
3301                 needSave = !saved.sameAs(loaded);
3302             } else {
3303                 needSave = true;
3304             }
3305         } catch (Exception e) {
3306             needSave = true;
3307         }
3308         if (needSave) {
3309             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3310             // This is slower than is ideal, but this only happens once
3311             // or when the app is updated with a new icon.
3312             updateItemInDatabase(context, info);
3313         }
3314     }
3315 
3316     /**
3317      * Return an existing FolderInfo object if we have encountered this ID previously,
3318      * or make a new one.
3319      */
3320     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3321         // See if a placeholder was created for us already
3322         FolderInfo folderInfo = folders.get(id);
3323         if (folderInfo == null) {
3324             // No placeholder -- create a new instance
3325             folderInfo = new FolderInfo();
3326             folders.put(id, folderInfo);
3327         }
3328         return folderInfo;
3329     }
3330 
3331     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3332         final Collator collator = Collator.getInstance();
3333         return new Comparator&lt;AppInfo&gt;() {
3334             public final int compare(AppInfo a, AppInfo b) {
3335                 int result = collator.compare(a.title.toString().trim(),
3336                         b.title.toString().trim());
3337                 if (result == 0) {
3338                     result = a.componentName.compareTo(b.componentName);
3339                 }
3340                 return result;
3341             }
3342         };
3343     }
3344     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3345             = new Comparator&lt;AppInfo&gt;() {
3346         public final int compare(AppInfo a, AppInfo b) {
3347             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3348             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3349             return 0;
3350         }
3351     };
3352     public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {
3353         final Collator collator = Collator.getInstance();
3354         return new Comparator&lt;AppWidgetProviderInfo&gt;() {
3355             public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
3356                 return collator.compare(a.label.toString().trim(), b.label.toString().trim());
3357             }
3358         };
3359     }
3360     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3361         if (info.activityInfo != null) {
3362             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3363         } else {
3364             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3365         }
3366     }
3367     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
3368         private Collator mCollator;
3369         private PackageManager mPackageManager;
3370         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3371         ShortcutNameComparator(PackageManager pm) {
3372             mPackageManager = pm;
3373             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3374             mCollator = Collator.getInstance();
3375         }
3376         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
3377             mPackageManager = pm;
3378             mLabelCache = labelCache;
3379             mCollator = Collator.getInstance();
3380         }
3381         public final int compare(ResolveInfo a, ResolveInfo b) {
3382             CharSequence labelA, labelB;
3383             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
3384             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
3385             if (mLabelCache.containsKey(keyA)) {
3386                 labelA = mLabelCache.get(keyA);
3387             } else {
3388                 labelA = a.loadLabel(mPackageManager).toString().trim();
3389 
3390                 mLabelCache.put(keyA, labelA);
3391             }
3392             if (mLabelCache.containsKey(keyB)) {
3393                 labelB = mLabelCache.get(keyB);
3394             } else {
3395                 labelB = b.loadLabel(mPackageManager).toString().trim();
3396 
3397                 mLabelCache.put(keyB, labelB);
3398             }
3399             return mCollator.compare(labelA, labelB);
3400         }
3401     };
3402     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3403         private Collator mCollator;
3404         private PackageManager mPackageManager;
3405         private HashMap&lt;Object, String&gt; mLabelCache;
3406         WidgetAndShortcutNameComparator(PackageManager pm) {
3407             mPackageManager = pm;
3408             mLabelCache = new HashMap&lt;Object, String&gt;();
3409             mCollator = Collator.getInstance();
3410         }
3411         public final int compare(Object a, Object b) {
3412             String labelA, labelB;
3413             if (mLabelCache.containsKey(a)) {
3414                 labelA = mLabelCache.get(a);
3415             } else {
3416                 labelA = (a instanceof AppWidgetProviderInfo) ?
3417                     ((AppWidgetProviderInfo) a).label :
3418                     ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3419                 mLabelCache.put(a, labelA);
3420             }
3421             if (mLabelCache.containsKey(b)) {
3422                 labelB = mLabelCache.get(b);
3423             } else {
3424                 labelB = (b instanceof AppWidgetProviderInfo) ?
3425                     ((AppWidgetProviderInfo) b).label :
3426                     ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3427                 mLabelCache.put(b, labelB);
3428             }
3429             return mCollator.compare(labelA, labelB);
3430         }
3431     };
3432 
3433     public void dumpState() {
3434         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3435         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3436         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3437         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3438         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3439         if (mLoaderTask != null) {
3440             mLoaderTask.dumpState();
3441         } else {
3442             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3443         }
3444     }
3445 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.*;
  23 import android.content.Intent.ShortcutIconResource;
  24 import android.content.pm.ActivityInfo;
  25 import android.content.pm.PackageInfo;
  26 import android.content.pm.PackageManager;
  27 import android.content.pm.PackageManager.NameNotFoundException;
  28 import android.content.pm.ResolveInfo;
  29 import android.content.res.Configuration;
  30 import android.content.res.Resources;
  31 import android.database.Cursor;
  32 import android.graphics.Bitmap;
  33 import android.graphics.BitmapFactory;
  34 import android.net.Uri;
  35 import android.os.Environment;
  36 import android.os.Handler;
  37 import android.os.HandlerThread;
  38 import android.os.Parcelable;
  39 import android.os.Process;
  40 import android.os.RemoteException;
  41 import android.os.SystemClock;
  42 import android.provider.BaseColumns;
  43 import android.text.TextUtils;
  44 import android.util.Log;
  45 import android.util.Pair;
  46 
  47 import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  48 
  49 import java.lang.ref.WeakReference;
  50 import java.net.URISyntaxException;
  51 import java.text.Collator;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Collection;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.Iterator;
  60 import java.util.List;
  61 import java.util.Set;
  62 import java.util.TreeMap;
  63 import java.util.concurrent.atomic.AtomicBoolean;
  64 
  65 /**
  66  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67  * LauncherModel object held in a static. Also provide APIs for updating the database state
  68  * for the Launcher.
  69  */
  70 public class LauncherModel extends BroadcastReceiver {
  71     static final boolean DEBUG_LOADERS = false;
  72     static final String TAG = &quot;Launcher.Model&quot;;
  73 
  74     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  75     // false = strew non-workspace apps across the workspace on upgrade
  76     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  77 
  78     public static final int LOADER_FLAG_NONE = 0;
  79     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  80     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  81 
  82     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  83     private static final long INVALID_SCREEN_ID = -1L;
  84 
  85     private final boolean mAppsCanBeOnRemoveableStorage;
  86     private final boolean mOldContentProviderExists;
  87 
  88     private final LauncherAppState mApp;
  89     private final Object mLock = new Object();
  90     private DeferredHandler mHandler = new DeferredHandler();
  91     private LoaderTask mLoaderTask;
  92     private boolean mIsLoaderTaskRunning;
  93     private volatile boolean mFlushingWorkerThread;
  94 
  95     // Specific runnable types that are run on the main thread deferred handler, this allows us to
  96     // clear all queued binding runnables when the Launcher activity is destroyed.
  97     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
  98     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
  99 
 100 
 101     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 102     static {
 103         sWorkerThread.start();
 104     }
 105     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 106 
 107     // We start off with everything not loaded.  After that, we assume that
 108     // our monitoring of the package manager provides all updates and we never
 109     // need to do a requery.  These are only ever touched from the loader thread.
 110     private boolean mWorkspaceLoaded;
 111     private boolean mAllAppsLoaded;
 112 
 113     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 114     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 115     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 116     // a normal load, we also clear this set of Runnables.
 117     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 118 
 119     private WeakReference&lt;Callbacks&gt; mCallbacks;
 120 
 121     // &lt; only access in worker thread &gt;
 122     AllAppsList mBgAllAppsList;
 123 
 124     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 125     // other locks, this one can generally be held long-term because we never expect any of these
 126     // static data structures to be referenced outside of the worker thread except on the first
 127     // load after configuration change.
 128     static final Object sBgLock = new Object();
 129 
 130     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 131     // LauncherModel to their ids
 132     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 133 
 134     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 135     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 136     //       shortcuts within folders).
 137     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 138 
 139     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 140     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 141         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 142 
 143     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 144     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 145 
 146     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 147     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 148 
 149     // sBgWorkspaceScreens is the ordered set of workspace screens.
 150     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 151 
 152     // &lt;/ only access in worker thread &gt;
 153 
 154     private IconCache mIconCache;
 155     private Bitmap mDefaultIcon;
 156 
 157     protected int mPreviousConfigMcc;
 158 
 159     public interface Callbacks {
 160         public boolean setLoadOnResume();
 161         public int getCurrentWorkspaceScreen();
 162         public void startBinding();
 163         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 164                               boolean forceAnimateIcons);
 165         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 166         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 167         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 168         public void finishBindingItems(boolean upgradePath);
 169         public void bindAppWidget(LauncherAppWidgetInfo info);
 170         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 171         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 172                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 173                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 174                                   ArrayList&lt;AppInfo&gt; addedApps);
 175         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 176         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 177                         ArrayList&lt;AppInfo&gt; appInfos);
 178         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 179         public void bindSearchablesChanged();
 180         public boolean isAllAppsButtonRank(int rank);
 181         public void onPageBoundSynchronously(int page);
 182         public void dumpLogsToLocalData();
 183     }
 184 
 185     public interface ItemInfoFilter {
 186         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 187     }
 188 
 189     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 190         Context context = app.getContext();
 191         ContentResolver contentResolver = context.getContentResolver();
 192 
 193         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 194         mOldContentProviderExists = (contentResolver.acquireContentProviderClient(
 195                 LauncherSettings.Favorites.OLD_CONTENT_URI) != null);
 196         mApp = app;
 197         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 198         mIconCache = iconCache;
 199 
 200         final Resources res = context.getResources();
 201         Configuration config = res.getConfiguration();
 202         mPreviousConfigMcc = config.mcc;
 203     }
 204 
 205     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 206      * posted on the main thread handler. */
 207     private void runOnMainThread(Runnable r) {
 208         runOnMainThread(r, 0);
 209     }
 210     private void runOnMainThread(Runnable r, int type) {
 211         if (sWorkerThread.getThreadId() == Process.myTid()) {
 212             // If we are on the worker thread, post onto the main handler
 213             mHandler.post(r);
 214         } else {
 215             r.run();
 216         }
 217     }
 218 
 219     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 220      * posted on the worker thread handler. */
 221     private static void runOnWorkerThread(Runnable r) {
 222         if (sWorkerThread.getThreadId() == Process.myTid()) {
 223             r.run();
 224         } else {
 225             // If we are not on the worker thread, then post to the worker handler
 226             sWorker.post(r);
 227         }
 228     }
 229 
 230     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 231         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 232     }
 233 
 234     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 235                                  long screen) {
 236         LauncherAppState app = LauncherAppState.getInstance();
 237         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 238         final int xCount = (int) grid.numColumns;
 239         final int yCount = (int) grid.numRows;
 240         boolean[][] occupied = new boolean[xCount][yCount];
 241 
 242         int cellX, cellY, spanX, spanY;
 243         for (int i = 0; i &lt; items.size(); ++i) {
 244             final ItemInfo item = items.get(i);
 245             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 246                 if (item.screenId == screen) {
 247                     cellX = item.cellX;
 248                     cellY = item.cellY;
 249                     spanX = item.spanX;
 250                     spanY = item.spanY;
 251                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 252                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 253                             occupied[x][y] = true;
 254                         }
 255                     }
 256                 }
 257             }
 258         }
 259 
 260         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 261     }
 262     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 263                                                         Intent launchIntent,
 264                                                         int firstScreenIndex,
 265                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 266         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 267         LauncherAppState app = LauncherAppState.getInstance();
 268         LauncherModel model = app.getModel();
 269         boolean found = false;
 270         synchronized (app) {
 271             if (sWorkerThread.getThreadId() != Process.myTid()) {
 272                 // Flush the LauncherModel worker thread, so that if we just did another
 273                 // processInstallShortcut, we give it time for its shortcut to get added to the
 274                 // database (getItemsInLocalCoordinates reads the database)
 275                 model.flushWorkerThread();
 276             }
 277             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 278 
 279             // Try adding to the workspace screens incrementally, starting at the default or center
 280             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 281             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 282             int count = workspaceScreens.size();
 283             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 284                 int[] tmpCoordinates = new int[2];
 285                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 286                         workspaceScreens.get(screen))) {
 287                     // Update the Launcher db
 288                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 289                 }
 290             }
 291         }
 292         return null;
 293     }
 294 
 295     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 296                                     final ArrayList&lt;AppInfo&gt; allAppsApps) {
 297         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 298         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);
 299     }
 300     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 301                                 final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 302         if (workspaceApps == null || allAppsApps == null) {
 303             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 304         }
 305         if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {
 306             return;
 307         }
 308         // Process the newly added applications and add them to the database first
 309         Runnable r = new Runnable() {
 310             public void run() {
 311                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 312                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 313 
 314                 // Get the list of workspace screens.  We need to append to this list and
 315                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 316                 // called.
 317                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 318                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 319                 for (Integer i : orderedScreens.keySet()) {
 320                     long screenId = orderedScreens.get(i);
 321                     workspaceScreens.add(screenId);
 322                 }
 323 
 324                 synchronized(sBgLock) {
 325                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 326                     while (iter.hasNext()) {
 327                         ItemInfo a = iter.next();
 328                         final String name = a.title.toString();
 329                         final Intent launchIntent = a.getIntent();
 330 
 331                         // Short-circuit this logic if the icon exists somewhere on the workspace
 332                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 333                             continue;
 334                         }
 335 
 336                         // Add this icon to the db, creating a new page if necessary.  If there
 337                         // is only the empty page then we just add items to the first page.
 338                         // Otherwise, we add them to the next pages.
 339                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 340                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 341                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 342                         if (coords == null) {
 343                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 344 
 345                             // If we can&#x27;t find a valid position, then just add a new screen.
 346                             // This takes time so we need to re-queue the add until the new
 347                             // page is added.  Create as many screens as necessary to satisfy
 348                             // the startSearchPageIndex.
 349                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 350                                     workspaceScreens.size());
 351                             while (numPagesToAdd &gt; 0) {
 352                                 long screenId = lp.generateNewScreenId();
 353                                 // Save the screen id for binding in the workspace
 354                                 workspaceScreens.add(screenId);
 355                                 addedWorkspaceScreensFinal.add(screenId);
 356                                 numPagesToAdd--;
 357                             }
 358 
 359                             // Find the coordinate again
 360                             coords = LauncherModel.findNextAvailableIconSpace(context,
 361                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 362                         }
 363                         if (coords == null) {
 364                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 365                         }
 366 
 367                         ShortcutInfo shortcutInfo;
 368                         if (a instanceof ShortcutInfo) {
 369                             shortcutInfo = (ShortcutInfo) a;
 370                         } else if (a instanceof AppInfo) {
 371                             shortcutInfo = ((AppInfo) a).makeShortcut();
 372                         } else {
 373                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 374                         }
 375 
 376                         // Add the shortcut to the db
 377                         addItemToDatabase(context, shortcutInfo,
 378                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 379                                 coords.first, coords.second[0], coords.second[1], false);
 380                         // Save the ShortcutInfo for binding in the workspace
 381                         addedShortcutsFinal.add(shortcutInfo);
 382                     }
 383                 }
 384 
 385                 // Update the workspace screens
 386                 updateWorkspaceScreenOrder(context, workspaceScreens);
 387 
 388                 if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {
 389                     runOnMainThread(new Runnable() {
 390                         public void run() {
 391                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 392                             if (callbacks == cb &amp;&amp; cb != null) {
 393                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 394                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 395                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 396                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 396                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 397                                     long lastScreenId = info.screenId;
 398                                     for (ItemInfo i : addedShortcutsFinal) {
 399                                         if (i.screenId == lastScreenId) {
 400                                             addAnimated.add(i);
 401                                         } else {
 402                                             addNotAnimated.add(i);
 403                                         }
 404                                     }
 405                                 }
 406                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 407                                         addNotAnimated, addAnimated, allAppsApps);
 408                             }
 409                         }
 410                     });
 411                 }
 412             }
 413         };
 414         runOnWorkerThread(r);
 415     }
 416 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 417 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 418 public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 419         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 420 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 421         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 422             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 423         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 424         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 425             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 426         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 427 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 428         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 429         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 430         while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 431             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 432             if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 433                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 434             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 435         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 436 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 437         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 438         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 439             public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 440                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 441                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 442                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 443                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 444                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 445                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 446                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 447                             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 448                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 449                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 450                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 451             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 452         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 453         runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454     }</span>
 455 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 456 public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 457         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 458 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 459         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 460             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 461         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 462         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 463             return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 464         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 465 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 466         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 467         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 468         while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 469             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 470             if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 471                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 472             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 473         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 475         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 476         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 477             public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 478                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 479                     public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 480                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 481                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 482                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 483                                 for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 484                                     final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 485                                     if (intent != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 486                                         mIconCache.deletePreloadedIcon(intent.getComponent());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 487                                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 488                                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 489                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 490                             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 491                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 492                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 493                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 494                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 495             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 496         };</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 497         runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 498     }</span>
 499 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 500 
 501 
 502     public Bitmap getFallbackIcon() {
 503         if (mDefaultIcon == null) {
 504             final Context context = LauncherAppState.getInstance().getContext();
 505             mDefaultIcon = Utilities.createIconBitmap(
 506                     mIconCache.getFullResDefaultActivityIcon(), context);
 507         }
 508         return Bitmap.createBitmap(mDefaultIcon);
 509     }
 510 
 511     public void unbindItemInfosAndClearQueuedBindRunnables() {
 512         if (sWorkerThread.getThreadId() == Process.myTid()) {
 513             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 514                     &quot;main thread&quot;);
 515         }
 516 
 517         // Clear any deferred bind runnables
 518         mDeferredBindRunnables.clear();
 519         // Remove any queued bind runnables
 520         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 521         // Unbind all the workspace items
 522         unbindWorkspaceItemsOnMainThread();
 523     }
 524 
 525     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 526     void unbindWorkspaceItemsOnMainThread() {
 527         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 528         // by making a copy of workspace items first.
 529         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 530         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 531         synchronized (sBgLock) {
 532             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 533             tmpAppWidgets.addAll(sBgAppWidgets);
 534         }
 535         Runnable r = new Runnable() {
 536                 @Override
 537                 public void run() {
 538                    for (ItemInfo item : tmpWorkspaceItems) {
 539                        item.unbind();
 540                    }
 541                    for (ItemInfo item : tmpAppWidgets) {
 542                        item.unbind();
 543                    }
 544                 }
 545             };
 546         runOnMainThread(r);
 547     }
 548 
 549     /**
 550      * Adds an item to the DB if it was not created previously, or move it to a new
 551      * &lt;container, screen, cellX, cellY&gt;
 552      */
 553     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 554             long screenId, int cellX, int cellY) {
 555         if (item.container == ItemInfo.NO_ID) {
 556             // From all apps
 557             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 558         } else {
 559             // From somewhere else
 560             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 561         }
 562     }
 563 
 564     static void checkItemInfoLocked(
 565             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 566         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 567         if (modelItem != null &amp;&amp; item != modelItem) {
 568             // check all the data is consistent
 569             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 570                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 571                 ShortcutInfo shortcut = (ShortcutInfo) item;
 572                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 573                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 574                         modelShortcut.id == shortcut.id &amp;&amp;
 575                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 576                         modelShortcut.container == shortcut.container &amp;&amp;
 577                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 578                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 579                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 580                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 581                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 582                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 583                         (modelShortcut.dropPos != null &amp;&amp;
 584                                 shortcut.dropPos != null &amp;&amp;
 585                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 586                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 587                     // For all intents and purposes, this is the same object
 588                     return;
 589                 }
 590             }
 591 
 592             // the modelItem needs to match up perfectly with item if our model is
 593             // to be consistent with the database-- for now, just require
 594             // modelItem == item or the equality check above
 595             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 596                     &quot;modelItem: &quot; +
 597                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 598                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 599             RuntimeException e = new RuntimeException(msg);
 600             if (stackTrace != null) {
 601                 e.setStackTrace(stackTrace);
 602             }
 603             throw e;
 604         }
 605     }
 606 
 607     static void checkItemInfo(final ItemInfo item) {
 608         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 609         final long itemId = item.id;
 610         Runnable r = new Runnable() {
 611             public void run() {
 612                 synchronized (sBgLock) {
 613                     checkItemInfoLocked(itemId, item, stackTrace);
 614                 }
 615             }
 616         };
 617         runOnWorkerThread(r);
 618     }
 619 
 620     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 621             final ItemInfo item, final String callingFunction) {
 622         final long itemId = item.id;
 623         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 624         final ContentResolver cr = context.getContentResolver();
 625 
 626         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 627         Runnable r = new Runnable() {
 628             public void run() {
 629                 cr.update(uri, values, null, null);
 630                 updateItemArrays(item, itemId, stackTrace);
 631             }
 632         };
 633         runOnWorkerThread(r);
 634     }
 635 
 636     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 637             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 638         final ContentResolver cr = context.getContentResolver();
 639 
 640         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 641         Runnable r = new Runnable() {
 642             public void run() {
 643                 ArrayList&lt;ContentProviderOperation&gt; ops =
 644                         new ArrayList&lt;ContentProviderOperation&gt;();
 645                 int count = items.size();
 646                 for (int i = 0; i &lt; count; i++) {
 647                     ItemInfo item = items.get(i);
 648                     final long itemId = item.id;
 649                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 650                     ContentValues values = valuesList.get(i);
 651 
 652                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 653                     updateItemArrays(item, itemId, stackTrace);
 654 
 655                 }
 656                 try {
 657                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 658                 } catch (Exception e) {
 659                     e.printStackTrace();
 660                 }
 661             }
 662         };
 663         runOnWorkerThread(r);
 664     }
 665 
 666     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 667         // Lock on mBgLock *after* the db operation
 668         synchronized (sBgLock) {
 669             checkItemInfoLocked(itemId, item, stackTrace);
 670 
 671             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 672                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 673                 // Item is in a folder, make sure this folder exists
 674                 if (!sBgFolders.containsKey(item.container)) {
 675                     // An items container is being set to a that of an item which is not in
 676                     // the list of Folders.
 677                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 678                             item.container + &quot;, not in the list of folders&quot;;
 679                     Log.e(TAG, msg);
 680                 }
 681             }
 682 
 683             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 684             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 685             // that are on the desktop, as appropriate
 686             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 687             if (modelItem != null &amp;&amp;
 688                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 689                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 690                 switch (modelItem.itemType) {
 691                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 692                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 693                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 694                         if (!sBgWorkspaceItems.contains(modelItem)) {
 695                             sBgWorkspaceItems.add(modelItem);
 696                         }
 697                         break;
 698                     default:
 699                         break;
 700                 }
 701             } else {
 702                 sBgWorkspaceItems.remove(modelItem);
 703             }
 704         }
 705     }
 706 
 707     public void flushWorkerThread() {
 708         mFlushingWorkerThread = true;
 709         Runnable waiter = new Runnable() {
 710                 public void run() {
 711                     synchronized (this) {
 712                         notifyAll();
 713                         mFlushingWorkerThread = false;
 714                     }
 715                 }
 716             };
 717 
 718         synchronized(waiter) {
 719             runOnWorkerThread(waiter);
 720             if (mLoaderTask != null) {
 721                 synchronized(mLoaderTask) {
 722                     mLoaderTask.notify();
 723                 }
 724             }
 725             boolean success = false;
 726             while (!success) {
 727                 try {
 728                     waiter.wait();
 729                     success = true;
 730                 } catch (InterruptedException e) {
 731                 }
 732             }
 733         }
 734     }
 735 
 736     /**
 737      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 738      */
 739     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 740             final long screenId, final int cellX, final int cellY) {
 741         item.container = container;
 742         item.cellX = cellX;
 743         item.cellY = cellY;
 744 
 745         // We store hotseat items in canonical form which is this orientation invariant position
 746         // in the hotseat
 747         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 748                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 749             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 750         } else {
 751             item.screenId = screenId;
 752         }
 753 
 754         final ContentValues values = new ContentValues();
 755         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 756         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 757         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 758         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 759 
 760         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 761     }
 762 
 763     /**
 764      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 765      * cellX, cellY have already been updated on the ItemInfos.
 766      */
 767     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 768             final long container, final int screen) {
 769 
 770         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 771         int count = items.size();
 772 
 773         for (int i = 0; i &lt; count; i++) {
 774             ItemInfo item = items.get(i);
 775             item.container = container;
 776 
 777             // We store hotseat items in canonical form which is this orientation invariant position
 778             // in the hotseat
 779             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 780                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 781                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 782                         item.cellY);
 783             } else {
 784                 item.screenId = screen;
 785             }
 786 
 787             final ContentValues values = new ContentValues();
 788             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 789             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 790             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 791             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 792 
 793             contentValues.add(values);
 794         }
 795         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 796     }
 797 
 798     /**
 799      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 800      */
 801     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 802             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 803         item.container = container;
 804         item.cellX = cellX;
 805         item.cellY = cellY;
 806         item.spanX = spanX;
 807         item.spanY = spanY;
 808 
 809         // We store hotseat items in canonical form which is this orientation invariant position
 810         // in the hotseat
 811         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 812                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 813             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 814         } else {
 815             item.screenId = screenId;
 816         }
 817 
 818         final ContentValues values = new ContentValues();
 819         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 820         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 821         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 822         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 823         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 824         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 825 
 826         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 827     }
 828 
 829     /**
 830      * Update an item to the database in a specified container.
 831      */
 832     static void updateItemInDatabase(Context context, final ItemInfo item) {
 833         final ContentValues values = new ContentValues();
 834         item.onAddToDatabase(values);
 835         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 836         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 837     }
 838 
 839     /**
 840      * Returns true if the shortcuts already exists in the database.
 841      * we identify a shortcut by its title and intent.
 842      */
 843     static boolean shortcutExists(Context context, String title, Intent intent) {
 844         final ContentResolver cr = context.getContentResolver();
 845         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 846             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 847             new String[] { title, intent.toUri(0) }, null);
 848         boolean result = false;
 849         try {
 850             result = c.moveToFirst();
 851         } finally {
 852             c.close();
 853         }
 854         return result;
 855     }
 856 
 857     /**
 858      * Returns an ItemInfo array containing all the items in the LauncherModel.
 859      * The ItemInfo.id is not set through this function.
 860      */
 861     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 862         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 863         final ContentResolver cr = context.getContentResolver();
 864         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 865                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 866                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 866                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 867                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 868 
 869         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 870         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 871         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 872         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 873         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 874         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 875         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 876 
 877         try {
 878             while (c.moveToNext()) {
 879                 ItemInfo item = new ItemInfo();
 880                 item.cellX = c.getInt(cellXIndex);
 881                 item.cellY = c.getInt(cellYIndex);
 882                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 883                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 884                 item.container = c.getInt(containerIndex);
 885                 item.itemType = c.getInt(itemTypeIndex);
 886                 item.screenId = c.getInt(screenIndex);
 887 
 888                 items.add(item);
 889             }
 890         } catch (Exception e) {
 891             items.clear();
 892         } finally {
 893             c.close();
 894         }
 895 
 896         return items;
 897     }
 898 
 899     /**
 900      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 901      */
 902     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 903         final ContentResolver cr = context.getContentResolver();
 904         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 905                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 906                 new String[] { String.valueOf(id),
 907                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 908 
 909         try {
 910             if (c.moveToFirst()) {
 911                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 912                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 913                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 914                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 915                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 916                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 917 
 918                 FolderInfo folderInfo = null;
 919                 switch (c.getInt(itemTypeIndex)) {
 920                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 921                         folderInfo = findOrMakeFolder(folderList, id);
 922                         break;
 923                 }
 924 
 925                 folderInfo.title = c.getString(titleIndex);
 926                 folderInfo.id = id;
 927                 folderInfo.container = c.getInt(containerIndex);
 928                 folderInfo.screenId = c.getInt(screenIndex);
 929                 folderInfo.cellX = c.getInt(cellXIndex);
 930                 folderInfo.cellY = c.getInt(cellYIndex);
 931 
 932                 return folderInfo;
 933             }
 934         } finally {
 935             c.close();
 936         }
 937 
 938         return null;
 939     }
 940 
 941     /**
 942      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 943      * cellY fields of the item. Also assigns an ID to the item.
 944      */
 945     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 946             final long screenId, final int cellX, final int cellY, final boolean notify) {
 947         item.container = container;
 948         item.cellX = cellX;
 949         item.cellY = cellY;
 950         // We store hotseat items in canonical form which is this orientation invariant position
 951         // in the hotseat
 952         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 953                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 954             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 955         } else {
 956             item.screenId = screenId;
 957         }
 958 
 959         final ContentValues values = new ContentValues();
 960         final ContentResolver cr = context.getContentResolver();
 961         item.onAddToDatabase(values);
 962 
 963         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 964         values.put(LauncherSettings.Favorites._ID, item.id);
 965         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 966 
 967         Runnable r = new Runnable() {
 968             public void run() {
 969                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 970                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 971 
 972                 // Lock on mBgLock *after* the db operation
 973                 synchronized (sBgLock) {
 974                     checkItemInfoLocked(item.id, item, null);
 975                     sBgItemsIdMap.put(item.id, item);
 976                     switch (item.itemType) {
 977                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 978                             sBgFolders.put(item.id, (FolderInfo) item);
 979                             // Fall through
 980                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 981                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 982                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 983                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 984                                 sBgWorkspaceItems.add(item);
 985                             } else {
 986                                 if (!sBgFolders.containsKey(item.container)) {
 987                                     // Adding an item to a folder that doesn&#x27;t exist.
 988                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 989                                             &quot; doesn&#x27;t exist&quot;;
 990                                     Log.e(TAG, msg);
 991                                 }
 992                             }
 993                             break;
 994                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 995                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 996                             break;
 997                     }
 998                 }
 999             }
1000         };
1001         runOnWorkerThread(r);
1002     }
1003 
1004     /**
1005      * Creates a new unique child id, for a given cell span across all layouts.
1006      */
1007     static int getCellLayoutChildId(
1008             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1009         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1010                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1011     }
1012 
1013     /**
1014      * Removes the specified item from the database
1015      * @param context
1016      * @param item
1017      */
1018     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1019         final ContentResolver cr = context.getContentResolver();
1020         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
1021 
1022         Runnable r = new Runnable() {
1023             public void run() {
1024                 cr.delete(uriToDelete, null, null);
1025 
1026                 // Lock on mBgLock *after* the db operation
1027                 synchronized (sBgLock) {
1028                     switch (item.itemType) {
1029                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1030                             sBgFolders.remove(item.id);
1031                             for (ItemInfo info: sBgItemsIdMap.values()) {
1032                                 if (info.container == item.id) {
1033                                     // We are deleting a folder which still contains items that
1034                                     // think they are contained by that folder.
1035                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1036                                             &quot;contains items (&quot; + info + &quot;)&quot;;
1037                                     Log.e(TAG, msg);
1038                                 }
1039                             }
1040                             sBgWorkspaceItems.remove(item);
1041                             break;
1042                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1043                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1044                             sBgWorkspaceItems.remove(item);
1045                             break;
1046                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1047                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1048                             break;
1049                     }
1050                     sBgItemsIdMap.remove(item.id);
1051                     sBgDbIconCache.remove(item);
1052                 }
1053             }
1054         };
1055         runOnWorkerThread(r);
1056     }
1057 
1058     /**
1059      * Update the order of the workspace screens in the database. The array list contains
1060      * a list of screen ids in the order that they should appear.
1061      */
1062     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1063         // Log to disk
1064         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1065         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1066 
1067         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1068         final ContentResolver cr = context.getContentResolver();
1069         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1070 
1071         // Remove any negative screen ids -- these aren&#x27;t persisted
1072         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1073         while (iter.hasNext()) {
1074             long id = iter.next();
1075             if (id &lt; 0) {
1076                 iter.remove();
1077             }
1078         }
1079 
1080         Runnable r = new Runnable() {
1081             @Override
1082             public void run() {
1083                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1084                 // Clear the table
1085                 ops.add(ContentProviderOperation.newDelete(uri).build());
1086                 int count = screensCopy.size();
1087                 for (int i = 0; i &lt; count; i++) {
1088                     ContentValues v = new ContentValues();
1089                     long screenId = screensCopy.get(i);
1090                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1091                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1092                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1093                 }
1094 
1095                 try {
1096                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1097                 } catch (Exception ex) {
1098                     throw new RuntimeException(ex);
1099                 }
1100 
1101                 synchronized (sBgLock) {
1102                     sBgWorkspaceScreens.clear();
1103                     sBgWorkspaceScreens.addAll(screensCopy);
1104                 }
1105             }
1106         };
1107         runOnWorkerThread(r);
1108     }
1109 
1110     /**
1111      * Remove the contents of the specified folder from the database
1112      */
1113     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1114         final ContentResolver cr = context.getContentResolver();
1115 
1116         Runnable r = new Runnable() {
1117             public void run() {
1118                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1119                 // Lock on mBgLock *after* the db operation
1120                 synchronized (sBgLock) {
1121                     sBgItemsIdMap.remove(info.id);
1122                     sBgFolders.remove(info.id);
1123                     sBgDbIconCache.remove(info);
1124                     sBgWorkspaceItems.remove(info);
1125                 }
1126 
1127                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1128                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1129                 // Lock on mBgLock *after* the db operation
1130                 synchronized (sBgLock) {
1131                     for (ItemInfo childInfo : info.contents) {
1132                         sBgItemsIdMap.remove(childInfo.id);
1133                         sBgDbIconCache.remove(childInfo);
1134                     }
1135                 }
1136             }
1137         };
1138         runOnWorkerThread(r);
1139     }
1140 
1141     /**
1142      * Set this as the current Launcher activity object for the loader.
1143      */
1144     public void initialize(Callbacks callbacks) {
1145         synchronized (mLock) {
1146             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1147         }
1148     }
1149 
1150     /**
1151      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1152      * ACTION_PACKAGE_CHANGED.
1153      */
1154     @Override
1155     public void onReceive(Context context, Intent intent) {
1156         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1157 
1158         final String action = intent.getAction();
1159 
1160         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1161                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1162                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1163             final String packageName = intent.getData().getSchemeSpecificPart();
1164             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1165 
1166             int op = PackageUpdatedTask.OP_NONE;
1167 
1168             if (packageName == null || packageName.length() == 0) {
1169                 // they sent us a bad intent
1170                 return;
1171             }
1172 
1173             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1174                 op = PackageUpdatedTask.OP_UPDATE;
1175             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1176                 if (!replacing) {
1177                     op = PackageUpdatedTask.OP_REMOVE;
1178                 }
1179                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1180                 // later, we will update the package at this time
1181             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1182                 if (!replacing) {
1183                     op = PackageUpdatedTask.OP_ADD;
1184                 } else {
1185                     op = PackageUpdatedTask.OP_UPDATE;
1186                 }
1187             }
1188 
1189             if (op != PackageUpdatedTask.OP_NONE) {
1190                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1191             }
1192 
1193         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1194             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1195             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1196             if (!replacing) {
1197                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1198                 if (mAppsCanBeOnRemoveableStorage) {
1199                     // Only rebind if we support removable storage.  It catches the case where
1200                     // apps on the external sd card need to be reloaded
1201                     startLoaderFromBackground();
1202                 }
1203             } else {
1204                 // If we are replacing then just update the packages in the list
1205                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1206                         packages));
1207             }
1208         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1209             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1210             if (!replacing) {
1211                 String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1212                 enqueuePackageUpdated(new PackageUpdatedTask(
1213                             PackageUpdatedTask.OP_UNAVAILABLE, packages));
1214             }
1215             // else, we are replacing the packages, so ignore this event and wait for
1216             // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time
1217         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1218             // If we have changed locale we need to clear out the labels in all apps/workspace.
1219             forceReload();
1220         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1221              // Check if configuration change was an mcc/mnc change which would affect app resources
1222              // and we would need to clear out the labels in all apps/workspace. Same handling as
1223              // above for ACTION_LOCALE_CHANGED
1224              Configuration currentConfig = context.getResources().getConfiguration();
1225              if (mPreviousConfigMcc != currentConfig.mcc) {
1226                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1227                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1228                    forceReload();
1229              }
1230              // Update previousConfig
1231              mPreviousConfigMcc = currentConfig.mcc;
1232         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1233                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1234             if (mCallbacks != null) {
1235                 Callbacks callbacks = mCallbacks.get();
1236                 if (callbacks != null) {
1237                     callbacks.bindSearchablesChanged();
1238                 }
1239             }
1240         }
1241     }
1242 
1243     private void forceReload() {
1244         resetLoadedState(true, true);
1245 
1246         // Do this here because if the launcher activity is running it will be restarted.
1247         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1248         // to reload.
1249         startLoaderFromBackground();
1250     }
1251 
1252     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1253         synchronized (mLock) {
1254             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1255             // mWorkspaceLoaded to true later
1256             stopLoaderLocked();
1257             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1258             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1259         }
1260     }
1261 
1262     /**
1263      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1264      * configuration changes.  So whenever we trigger the loader from the background
1265      * tell the launcher that it needs to re-run the loader when it comes back instead
1266      * of doing it now.
1267      */
1268     public void startLoaderFromBackground() {
1269         boolean runLoader = false;
1270         if (mCallbacks != null) {
1271             Callbacks callbacks = mCallbacks.get();
1272             if (callbacks != null) {
1273                 // Only actually run the loader if they&#x27;re not paused.
1274                 if (!callbacks.setLoadOnResume()) {
1275                     runLoader = true;
1276                 }
1277             }
1278         }
1279         if (runLoader) {
1280             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1281         }
1282     }
1283 
1284     // If there is already a loader task running, tell it to stop.
1285     // returns true if isLaunching() was true on the old task
1286     private boolean stopLoaderLocked() {
1287         boolean isLaunching = false;
1288         LoaderTask oldTask = mLoaderTask;
1289         if (oldTask != null) {
1290             if (oldTask.isLaunching()) {
1291                 isLaunching = true;
1292             }
1293             oldTask.stopLocked();
1294         }
1295         return isLaunching;
1296     }
1297 
1298     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1299         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1300     }
1301 
1302     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1303         synchronized (mLock) {
1304             if (DEBUG_LOADERS) {
1305                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1306             }
1307 
1308             // Clear any deferred bind-runnables from the synchronized load process
1309             // We must do this before any loading/binding is scheduled below.
1310             mDeferredBindRunnables.clear();
1311 
1312             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1313             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1314                 // If there is already one running, tell it to stop.
1315                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1316                 isLaunching = isLaunching || stopLoaderLocked();
1317                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1318                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1319                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1320                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1321                 } else {
1322                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1323                     sWorker.post(mLoaderTask);
1324                 }
1325             }
1326         }
1327     }
1328 
1329     void bindRemainingSynchronousPages() {
1330         // Post the remaining side pages to be loaded
1331         if (!mDeferredBindRunnables.isEmpty()) {
1332             for (final Runnable r : mDeferredBindRunnables) {
1333                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1334             }
1335             mDeferredBindRunnables.clear();
1336         }
1337     }
1338 
1339     public void stopLoader() {
1340         synchronized (mLock) {
1341             if (mLoaderTask != null) {
1342                 mLoaderTask.stopLocked();
1343             }
1344         }
1345     }
1346 
1347     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1348     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1349         final ContentResolver contentResolver = context.getContentResolver();
1350         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1351         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1352         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1353 
1354         try {
1355             final int idIndex = sc.getColumnIndexOrThrow(
1356                     LauncherSettings.WorkspaceScreens._ID);
1357             final int rankIndex = sc.getColumnIndexOrThrow(
1358                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1359             while (sc.moveToNext()) {
1360                 try {
1361                     long screenId = sc.getLong(idIndex);
1362                     int rank = sc.getInt(rankIndex);
1363                     orderedScreens.put(rank, screenId);
1364                 } catch (Exception e) {
<abbr title="1365                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1365                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1366                 }
1367             }
1368         } finally {
1369             sc.close();
1370         }
1371 
1372         // Log to disk
1373         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1374         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1375         for (Integer i : orderedScreens.keySet()) {
1376             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1377         }
1378         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1379                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1380         return orderedScreens;
1381     }
1382 
1383     public boolean isAllAppsLoaded() {
1384         return mAllAppsLoaded;
1385     }
1386 
1387     boolean isLoadingWorkspace() {
1388         synchronized (mLock) {
1389             if (mLoaderTask != null) {
1390                 return mLoaderTask.isLoadingWorkspace();
1391             }
1392         }
1393         return false;
1394     }
1395 
1396     /**
1397      * Runnable for the thread that loads the contents of the launcher:
1398      *   - workspace icons
1399      *   - widgets
1400      *   - all apps icons
1401      */
1402     private class LoaderTask implements Runnable {
1403         private Context mContext;
1404         private boolean mIsLaunching;
1405         private boolean mIsLoadingAndBindingWorkspace;
1406         private boolean mStopped;
1407         private boolean mLoadAndBindStepFinished;
1408         private int mFlags;
1409 
1410         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1411 
1412         LoaderTask(Context context, boolean isLaunching, int flags) {
1413             mContext = context;
1414             mIsLaunching = isLaunching;
1415             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1416             mFlags = flags;
1417         }
1418 
1419         boolean isLaunching() {
1420             return mIsLaunching;
1421         }
1422 
1423         boolean isLoadingWorkspace() {
1424             return mIsLoadingAndBindingWorkspace;
1425         }
1426 
1427         /** Returns whether this is an upgrade path */
1428         private boolean loadAndBindWorkspace() {
1429             mIsLoadingAndBindingWorkspace = true;
1430 
1431             // Load the workspace
1432             if (DEBUG_LOADERS) {
1433                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1434             }
1435 
1436             boolean isUpgradePath = false;
1437             if (!mWorkspaceLoaded) {
1438                 isUpgradePath = loadWorkspace();
1439                 synchronized (LoaderTask.this) {
1440                     if (mStopped) {
1441                         return isUpgradePath;
1442                     }
1443                     mWorkspaceLoaded = true;
1444                 }
1445             }
1446 
1447             // Bind the workspace
1448             bindWorkspace(-1, isUpgradePath);
1449             return isUpgradePath;
1450         }
1451 
1452         private void waitForIdle() {
1453             // Wait until the either we&#x27;re stopped or the other threads are done.
1454             // This way we don&#x27;t start loading all apps until the workspace has settled
1455             // down.
1456             synchronized (LoaderTask.this) {
1457                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1458 
1459                 mHandler.postIdle(new Runnable() {
1460                         public void run() {
1461                             synchronized (LoaderTask.this) {
1462                                 mLoadAndBindStepFinished = true;
1463                                 if (DEBUG_LOADERS) {
1464                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1465                                 }
1466                                 LoaderTask.this.notify();
1467                             }
1468                         }
1469                     });
1470 
1471                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1472                     try {
1473                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1474                         // wait no longer than 1sec at a time
1475                         this.wait(1000);
1476                     } catch (InterruptedException ex) {
1477                         // Ignore
1478                     }
1479                 }
1480                 if (DEBUG_LOADERS) {
1481                     Log.d(TAG, &quot;waited &quot;
1482                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1483                             + &quot;ms for previous step to finish binding&quot;);
1484                 }
1485             }
1486         }
1487 
1488         void runBindSynchronousPage(int synchronousBindPage) {
1489             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1490                 // Ensure that we have a valid page index to load synchronously
1491                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1492                         &quot;valid page index&quot;);
1493             }
1494             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1495                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1496                 // loaded already (we should load everything asynchronously in that case)
1497                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1498             }
1499             synchronized (mLock) {
1500                 if (mIsLoaderTaskRunning) {
1501                     // Ensure that we are never running the background loading at this point since
1502                     // we also touch the background collections
1503                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1504                 }
1505             }
1506 
1507             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1508             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1509             //      this call is synchronous, we can get away with not locking).
1510 
1511             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1512             // operations from the previous activity.  We need to ensure that all queued operations
1513             // are executed before any synchronous binding work is done.
1514             mHandler.flush();
1515 
1516             // Divide the set of loaded items into those that we are binding synchronously, and
1517             // everything else that is to be bound normally (asynchronously).
1518             bindWorkspace(synchronousBindPage, false);
1519             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1520             //      arise from that.
1521             onlyBindAllApps();
1522         }
1523 
1524         public void run() {
1525             boolean isUpgrade = false;
1526 
1527             synchronized (mLock) {
1528                 mIsLoaderTaskRunning = true;
1529             }
1530             // Optimize for end-user experience: if the Launcher is up and // running with the
1531             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1532             // workspace first (default).
1533             keep_running: {
1534                 // Elevate priority when Home launches for the first time to avoid
1535                 // starving at boot time. Staring at a blank home is not cool.
1536                 synchronized (mLock) {
1537                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1538                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1539                     android.os.Process.setThreadPriority(mIsLaunching
1540                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1541                 }
1542                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1543                 isUpgrade = loadAndBindWorkspace();
1544 
1545                 if (mStopped) {
1546                     break keep_running;
1547                 }
1548 
1549                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1550                 // settled down.
1551                 synchronized (mLock) {
1552                     if (mIsLaunching) {
1553                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1554                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1555                     }
1556                 }
1557                 waitForIdle();
1558 
1559                 // second step
1560                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1561                 loadAndBindAllApps();
1562 
1563                 // Restore the default thread priority after we are done loading items
1564                 synchronized (mLock) {
1565                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1566                 }
1567             }
1568 
1569             // Update the saved icons if necessary
1570             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1571             synchronized (sBgLock) {
1572                 for (Object key : sBgDbIconCache.keySet()) {
1573                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1574                 }
1575                 sBgDbIconCache.clear();
1576             }
1577 
1578             if (LauncherAppState.isDisableAllApps()) {
1579                 // Ensure that all the applications that are in the system are
1580                 // represented on the home screen.
1581                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1582                     verifyApplications();
1583                 }
1584             }
1585 
1586             // Clear out this reference, otherwise we end up holding it until all of the
1587             // callback runnables are done.
1588             mContext = null;
1589 
1590             synchronized (mLock) {
1591                 // If we are still the last one to be scheduled, remove ourselves.
1592                 if (mLoaderTask == this) {
1593                     mLoaderTask = null;
1594                 }
1595                 mIsLoaderTaskRunning = false;
1596             }
1597         }
1598 
1599         public void stopLocked() {
1600             synchronized (LoaderTask.this) {
1601                 mStopped = true;
1602                 this.notify();
1603             }
1604         }
1605 
1606         /**
1607          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1608          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1609          * object that was around when the deferred message was scheduled, and if there&#x27;s
1610          * a new Callbacks object around then also return null.  This will save us from
1611          * calling onto it with data that will be ignored.
1612          */
1613         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1614             synchronized (mLock) {
1615                 if (mStopped) {
1616                     return null;
1617                 }
1618 
1619                 if (mCallbacks == null) {
1620                     return null;
1621                 }
1622 
1623                 final Callbacks callbacks = mCallbacks.get();
1624                 if (callbacks != oldCallbacks) {
1625                     return null;
1626                 }
1627                 if (callbacks == null) {
1628                     Log.w(TAG, &quot;no mCallbacks&quot;);
1629                     return null;
1630                 }
1631 
1632                 return callbacks;
1633             }
1634         }
1635 
1636         private void verifyApplications() {
1637             final Context context = mApp.getContext();
1638 
1639             // Cross reference all the applications in our apps list with items in the workspace
1640             ArrayList&lt;ItemInfo&gt; tmpInfos;
1641             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1642             synchronized (sBgLock) {
1643                 for (AppInfo app : mBgAllAppsList.data) {
1644                     tmpInfos = getItemInfoForComponentName(app.componentName);
1645                     if (tmpInfos.isEmpty()) {
1646                         // We are missing an application icon, so add this to the workspace
1647                         added.add(app);
1648                         // This is a rare event, so lets log it
1649                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1650                     }
1651                 }
1652             }
1653             if (!added.isEmpty()) {
1654                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
1655                 addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());
1656             }
1657         }
1658 
1659         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1660         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1661                                            AtomicBoolean deleteOnInvalidPlacement) {
1662             LauncherAppState app = LauncherAppState.getInstance();
1663             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1664             final int countX = (int) grid.numColumns;
1665             final int countY = (int) grid.numRows;
1666 
1667             long containerIndex = item.screenId;
1668             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1669                 // Return early if we detect that an item is under the hotseat button
1670                 if (mCallbacks == null ||
1671                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1672                     deleteOnInvalidPlacement.set(true);
1673                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1674                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1675                             + item.cellY + &quot;) occupied by all apps&quot;);
1676                     return false;
1677                 }
1678 
1679                 final ItemInfo[][] hotseatItems =
1680                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1681 
1682                 if (item.screenId &gt;= grid.numHotseatIcons) {
1683                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1684                             + &quot; into hotseat position &quot; + item.screenId
1685                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1686                             + &quot;)&quot;);
1687                     return false;
1688                 }
1689 
1690                 if (hotseatItems != null) {
1691                     if (hotseatItems[(int) item.screenId][0] != null) {
1692                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1693                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1694                                 + item.cellY + &quot;) occupied by &quot;
1695                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1696                                 [(int) item.screenId][0]);
1697                             return false;
1698                     } else {
1699                         hotseatItems[(int) item.screenId][0] = item;
1700                         return true;
1701                     }
1702                 } else {
1703                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1704                     items[(int) item.screenId][0] = item;
1705                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1706                     return true;
1707                 }
1708             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1709                 // Skip further checking if it is not the hotseat or workspace container
1710                 return true;
1711             }
1712 
1713             if (!occupied.containsKey(item.screenId)) {
1714                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1715                 occupied.put(item.screenId, items);
1716             }
1717 
1718             final ItemInfo[][] screens = occupied.get(item.screenId);
1719             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1720                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1721                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1722                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1723                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1724                         + item.cellX + &quot;,&quot; + item.cellY
1725                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1726                 return false;
1727             }
1728 
1729             // Check if any workspace icons overlap with each other
1730             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1731                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1732                     if (screens[x][y] != null) {
1733                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1734                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1735                             + x + &quot;,&quot; + y
1736                             + &quot;) occupied by &quot;
1737                             + screens[x][y]);
1738                         return false;
1739                     }
1740                 }
1741             }
1742             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1743                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1744                     screens[x][y] = item;
1745                 }
1746             }
1747 
1748             return true;
1749         }
1750 
1751         /** Clears all the sBg data structures */
1752         private void clearSBgDataStructures() {
1753             synchronized (sBgLock) {
1754                 sBgWorkspaceItems.clear();
1755                 sBgAppWidgets.clear();
1756                 sBgFolders.clear();
1757                 sBgItemsIdMap.clear();
1758                 sBgDbIconCache.clear();
1759                 sBgWorkspaceScreens.clear();
1760             }
1761         }
1762 
1763         /** Returns whether this is an upgrade path */
1764         private boolean loadWorkspace() {
1765             // Log to disk
1766             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1767 
1768             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1769 
1770             final Context context = mContext;
1771             final ContentResolver contentResolver = context.getContentResolver();
1772             final PackageManager manager = context.getPackageManager();
1773             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1774             final boolean isSafeMode = manager.isSafeMode();
1775 
1776             LauncherAppState app = LauncherAppState.getInstance();
1777             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1778             int countX = (int) grid.numColumns;
1779             int countY = (int) grid.numRows;
1780 
1781             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1782                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1783                 LauncherAppState.getLauncherProvider().deleteDatabase();
1784             }
1785 
1786             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1787                 // append the user&#x27;s Launcher2 shortcuts
1788                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1789                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1790             } else {
1791                 // Make sure the default workspace is loaded
1792                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1793                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);
1794             }
1795 
1796             // Check if we need to do any upgrade-path logic
1797             // (Includes having just imported default favorites)
1798             boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();
1799 
1800             // Log to disk
1801             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1802 
1803             synchronized (sBgLock) {
1804                 clearSBgDataStructures();
1805 
1806                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1807                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1808                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1809                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1810                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1811 
1812                 // +1 for the hotseat (it can be larger than the workspace)
1813                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1814                 // before any earlier duplicates)
1815                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1816 
1817                 try {
1818                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1819                     final int intentIndex = c.getColumnIndexOrThrow
1820                             (LauncherSettings.Favorites.INTENT);
1821                     final int titleIndex = c.getColumnIndexOrThrow
1822                             (LauncherSettings.Favorites.TITLE);
1823                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1824                             LauncherSettings.Favorites.ICON_TYPE);
1825                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1826                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1827                             LauncherSettings.Favorites.ICON_PACKAGE);
1828                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1829                             LauncherSettings.Favorites.ICON_RESOURCE);
1830                     final int containerIndex = c.getColumnIndexOrThrow(
1831                             LauncherSettings.Favorites.CONTAINER);
1832                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1833                             LauncherSettings.Favorites.ITEM_TYPE);
1834                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1835                             LauncherSettings.Favorites.APPWIDGET_ID);
1836                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1837                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1838                     final int screenIndex = c.getColumnIndexOrThrow(
1839                             LauncherSettings.Favorites.SCREEN);
1840                     final int cellXIndex = c.getColumnIndexOrThrow
1841                             (LauncherSettings.Favorites.CELLX);
1842                     final int cellYIndex = c.getColumnIndexOrThrow
1843                             (LauncherSettings.Favorites.CELLY);
1844                     final int spanXIndex = c.getColumnIndexOrThrow
1845                             (LauncherSettings.Favorites.SPANX);
1846                     final int spanYIndex = c.getColumnIndexOrThrow(
1847                             LauncherSettings.Favorites.SPANY);
1848                     final int restoredIndex = c.getColumnIndexOrThrow(
1849                             LauncherSettings.Favorites.RESTORED);
1850                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1851                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1852                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1853 
1854                     ShortcutInfo info;
1855                     String intentDescription;
1856                     LauncherAppWidgetInfo appWidgetInfo;
1857                     int container;
1858                     long id;
1859                     Intent intent;
1860 
1861                     while (!mStopped &amp;&amp; c.moveToNext()) {
1862                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1863                         try {
1864                             int itemType = c.getInt(itemTypeIndex);
1865                             boolean restored = 0 != c.getInt(restoredIndex);
1866 
1867                             switch (itemType) {
1868                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1869                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1870                                 id = c.getLong(idIndex);
1871                                 intentDescription = c.getString(intentIndex);
1872                                 try {
1873                                     intent = Intent.parseUri(intentDescription, 0);
1874                                     ComponentName cn = intent.getComponent();
1875                                     if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {
1876                                         if (restored) {
1877                                             // might be installed later
1878                                             Launcher.addDumpLog(TAG,
1879                                                     &quot;package not yet restored: &quot; + cn, true);
1880                                         } else {
1881                                             if (!mAppsCanBeOnRemoveableStorage) {
1882                                                 // Log the invalid package, and remove it
1883                                                 Launcher.addDumpLog(TAG,
1884                                                         &quot;Invalid package removed: &quot; + cn, true);
1885                                                 itemsToRemove.add(id);
1886                                             } else {
1887                                                 // If apps can be on external storage, then we just
1888                                                 // leave them for the user to remove (maybe add
1889                                                 // visual treatment to it)
1890                                                 Launcher.addDumpLog(TAG,
1891                                                         &quot;Invalid package found: &quot; + cn, true);
1892                                             }
1893                                             continue;
1894                                         }
1895                                     } else if (restored) {
1896                                         // no special handling necessary for this restored item
1897                                         restoredRows.add(id);
1898                                         restored = false;
1899                                     }
1900                                 } catch (URISyntaxException e) {
1901                                     Launcher.addDumpLog(TAG,
1902                                             &quot;Invalid uri: &quot; + intentDescription, true);
1903                                     continue;
1904                                 }
1905 
1906                                 if (restored) {
1907                                     Launcher.addDumpLog(TAG,
1908                                             &quot;constructing info for partially restored package&quot;,
1909                                             true);
1910                                     info = getRestoredItemInfo(c, titleIndex);
1911                                     intent = getRestoredItemIntent(c, context, intent);
1912                                 } else if (itemType ==
1913                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1914                                     info = getShortcutInfo(manager, intent, context, c, iconIndex,
1915                                             titleIndex, mLabelCache);
1916                                 } else {
1917                                     info = getShortcutInfo(c, context, iconTypeIndex,
1918                                             iconPackageIndex, iconResourceIndex, iconIndex,
1919                                             titleIndex);
1920 
1921                                     // App shortcuts that used to be automatically added to Launcher
1922                                     // didn&#x27;t always have the correct intent flags set, so do that
1923                                     // here
1924                                     if (intent.getAction() != null &amp;&amp;
1925                                         intent.getCategories() != null &amp;&amp;
1926                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1927                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1928                                         intent.addFlags(
1929                                             Intent.FLAG_ACTIVITY_NEW_TASK |
1930                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1931                                     }
1932                                 }
1933 
1934                                 if (info != null) {
1935                                     info.id = id;
1936                                     info.intent = intent;
1937                                     container = c.getInt(containerIndex);
1938                                     info.container = container;
1939                                     info.screenId = c.getInt(screenIndex);
1940                                     info.cellX = c.getInt(cellXIndex);
1941                                     info.cellY = c.getInt(cellYIndex);
1942                                     info.spanX = 1;
1943                                     info.spanY = 1;
1944 
1945                                     // check &amp; update map of what&#x27;s occupied
1946                                     deleteOnInvalidPlacement.set(false);
1947                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
1948                                         if (deleteOnInvalidPlacement.get()) {
1949                                             itemsToRemove.add(id);
1950                                         }
1951                                         break;
1952                                     }
1953 
1954                                     switch (container) {
1955                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1956                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1957                                         sBgWorkspaceItems.add(info);
1958                                         break;
1959                                     default:
1960                                         // Item is in a user folder
1961                                         FolderInfo folderInfo =
1962                                                 findOrMakeFolder(sBgFolders, container);
1963                                         folderInfo.add(info);
1964                                         break;
1965                                     }
1966                                     sBgItemsIdMap.put(info.id, info);
1967 
1968                                     // now that we&#x27;ve loaded everthing re-save it with the
1969                                     // icon in case it disappears somehow.
1970                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1971                                 } else {
1972                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1973                                 }
1974                                 break;
1975 
1976                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1977                                 id = c.getLong(idIndex);
1978                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1979 
1980                                 folderInfo.title = c.getString(titleIndex);
1981                                 folderInfo.id = id;
1982                                 container = c.getInt(containerIndex);
1983                                 folderInfo.container = container;
1984                                 folderInfo.screenId = c.getInt(screenIndex);
1985                                 folderInfo.cellX = c.getInt(cellXIndex);
1986                                 folderInfo.cellY = c.getInt(cellYIndex);
1987                                 folderInfo.spanX = 1;
1988                                 folderInfo.spanY = 1;
1989 
1990                                 // check &amp; update map of what&#x27;s occupied
1991                                 deleteOnInvalidPlacement.set(false);
1992                                 if (!checkItemPlacement(occupied, folderInfo,
1993                                         deleteOnInvalidPlacement)) {
1994                                     if (deleteOnInvalidPlacement.get()) {
1995                                         itemsToRemove.add(id);
1996                                     }
1997                                     break;
1998                                 }
1999 
2000                                 switch (container) {
2001                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2002                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2003                                         sBgWorkspaceItems.add(folderInfo);
2004                                         break;
2005                                 }
2006 
2007                                 if (restored) {
2008                                     // no special handling required for restored folders
2009                                     restoredRows.add(id);
2010                                 }
2011 
2012                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2013                                 sBgFolders.put(folderInfo.id, folderInfo);
2014                                 break;
2015 
2016                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2017                                 // Read all Launcher-specific widget details
2018                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2019                                 String savedProvider = c.getString(appWidgetProviderIndex);
2020 
2021                                 id = c.getLong(idIndex);
2022 
2023                                 final AppWidgetProviderInfo provider =
2024                                         widgets.getAppWidgetInfo(appWidgetId);
2025 
2026                                 if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
2027                                         provider.provider.getPackageName() == null)) {
2028                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
2029                                         + id + &quot; appWidgetId=&quot; + appWidgetId;
2030                                     Log.e(TAG, log);
2031                                     Launcher.addDumpLog(TAG, log, false);
2032                                     itemsToRemove.add(id);
2033                                 } else {
2034                                     appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2035                                             provider.provider);
2036                                     appWidgetInfo.id = id;
2037                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2038                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2039                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2040                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2041                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2042                                     int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
2043                                     appWidgetInfo.minSpanX = minSpan[0];
2044                                     appWidgetInfo.minSpanY = minSpan[1];
2045 
2046                                     container = c.getInt(containerIndex);
2047                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2048                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2049                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2050                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2051                                         continue;
2052                                     }
2053 
2054                                     appWidgetInfo.container = c.getInt(containerIndex);
2055                                     // check &amp; update map of what&#x27;s occupied
2056                                     deleteOnInvalidPlacement.set(false);
2057                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2058                                             deleteOnInvalidPlacement)) {
2059                                         if (deleteOnInvalidPlacement.get()) {
2060                                             itemsToRemove.add(id);
2061                                         }
2062                                         break;
2063                                     }
2064                                     String providerName = provider.provider.flattenToString();
2065                                     if (!providerName.equals(savedProvider)) {
2066                                         ContentValues values = new ContentValues();
2067                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2068                                                 providerName);
2069                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2070                                         String[] args = {Integer.toString(c.getInt(idIndex))};
2071                                         contentResolver.update(contentUri, values, where, args);
2072                                     }
2073                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2074                                     sBgAppWidgets.add(appWidgetInfo);
2075                                 }
2076                                 break;
2077                             }
2078                         } catch (Exception e) {
2079                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2080                         }
2081                     }
2082                 } finally {
2083                     if (c != null) {
2084                         c.close();
2085                     }
2086                 }
2087 
2088                 // Break early if we&#x27;ve stopped loading
2089                 if (mStopped) {
2090                     clearSBgDataStructures();
2091                     return false;
2092                 }
2093 
2094                 if (itemsToRemove.size() &gt; 0) {
2095                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2096                             LauncherSettings.Favorites.CONTENT_URI);
2097                     // Remove dead items
2098                     for (long id : itemsToRemove) {
2099                         if (DEBUG_LOADERS) {
2100                             Log.d(TAG, &quot;Removed id = &quot; + id);
2101                         }
2102                         // Don&#x27;t notify content observers
2103                         try {
2104                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2105                                     null, null);
2106                         } catch (RemoteException e) {
2107                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2108                         }
2109                     }
2110                 }
2111 
2112                 if (restoredRows.size() &gt; 0) {
2113                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2114                             LauncherSettings.Favorites.CONTENT_URI);
2115                     // Update restored items that no longer require special handling
2116                     try {
2117                         StringBuilder selectionBuilder = new StringBuilder();
2118                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2119                         selectionBuilder.append(&quot; IN (&quot;);
2120                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2121                         selectionBuilder.append(&quot;)&quot;);
2122                         ContentValues values = new ContentValues();
2123                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2124                         updater.update(LauncherSettings.Favorites.CONTENT_URI,
2125                                 values, selectionBuilder.toString(), null);
2126                     } catch (RemoteException e) {
2127                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2128                     }
2129                 }
2130 
2131                 if (loadedOldDb) {
2132                     long maxScreenId = 0;
2133                     // If we&#x27;re importing we use the old screen order.
2134                     for (ItemInfo item: sBgItemsIdMap.values()) {
2135                         long screenId = item.screenId;
2136                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2137                                 !sBgWorkspaceScreens.contains(screenId)) {
2138                             sBgWorkspaceScreens.add(screenId);
2139                             if (screenId &gt; maxScreenId) {
2140                                 maxScreenId = screenId;
2141                             }
2142                         }
2143                     }
2144                     Collections.sort(sBgWorkspaceScreens);
2145                     // Log to disk
2146                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2147                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2148                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2149 
2150                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2151                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2152 
2153                     // Update the max item id after we load an old db
2154                     long maxItemId = 0;
2155                     // If we&#x27;re importing we use the old screen order.
2156                     for (ItemInfo item: sBgItemsIdMap.values()) {
2157                         maxItemId = Math.max(maxItemId, item.id);
2158                     }
2159                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2160                 } else {
2161                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2162                     for (Integer i : orderedScreens.keySet()) {
2163                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2164                     }
2165                     // Log to disk
2166                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2167                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2168 
2169                     // Remove any empty screens
2170                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2171                     for (ItemInfo item: sBgItemsIdMap.values()) {
2172                         long screenId = item.screenId;
2173                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2174                                 unusedScreens.contains(screenId)) {
2175                             unusedScreens.remove(screenId);
2176                         }
2177                     }
2178 
2179                     // If there are any empty screens remove them, and update.
2180                     if (unusedScreens.size() != 0) {
2181                         // Log to disk
2182                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2183                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2184 
2185                         sBgWorkspaceScreens.removeAll(unusedScreens);
2186                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2187                     }
2188                 }
2189 
2190                 if (DEBUG_LOADERS) {
2191                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2192                     Log.d(TAG, &quot;workspace layout: &quot;);
2193                     int nScreens = occupied.size();
2194                     for (int y = 0; y &lt; countY; y++) {
2195                         String line = &quot;&quot;;
2196 
2197                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2198                         while (iter.hasNext()) {
2199                             long screenId = iter.next();
2200                             if (screenId &gt; 0) {
2201                                 line += &quot; | &quot;;
2202                             }
2203                             for (int x = 0; x &lt; countX; x++) {
2204                                 line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
2205                             }
2206                         }
2207                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2208                     }
2209                 }
2210             }
2211             return loadedOldDb;
2212         }
2213 
2214         /** Filters the set of items who are directly or indirectly (via another container) on the
2215          * specified screen. */
2216         private void filterCurrentWorkspaceItems(long currentScreenId,
2217                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2218                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2219                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2220             // Purge any null ItemInfos
2221             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2222             while (iter.hasNext()) {
2223                 ItemInfo i = iter.next();
2224                 if (i == null) {
2225                     iter.remove();
2226                 }
2227             }
2228 
2229             // Order the set of items by their containers first, this allows use to walk through the
2230             // list sequentially, build up a list of containers that are in the specified screen,
2231             // as well as all items in those containers.
2232             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2233             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2234                 @Override
2235                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2236                     return (int) (lhs.container - rhs.container);
2237                 }
2238             });
2239             for (ItemInfo info : allWorkspaceItems) {
2240                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2241                     if (info.screenId == currentScreenId) {
2242                         currentScreenItems.add(info);
2243                         itemsOnScreen.add(info.id);
2244                     } else {
2245                         otherScreenItems.add(info);
2246                     }
2247                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2248                     currentScreenItems.add(info);
2249                     itemsOnScreen.add(info.id);
2250                 } else {
2251                     if (itemsOnScreen.contains(info.container)) {
2252                         currentScreenItems.add(info);
2253                         itemsOnScreen.add(info.id);
2254                     } else {
2255                         otherScreenItems.add(info);
2256                     }
2257                 }
2258             }
2259         }
2260 
2261         /** Filters the set of widgets which are on the specified screen. */
2262         private void filterCurrentAppWidgets(long currentScreenId,
2263                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2264                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2265                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2266 
2267             for (LauncherAppWidgetInfo widget : appWidgets) {
2268                 if (widget == null) continue;
2269                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2270                         widget.screenId == currentScreenId) {
2271                     currentScreenWidgets.add(widget);
2272                 } else {
2273                     otherScreenWidgets.add(widget);
2274                 }
2275             }
2276         }
2277 
2278         /** Filters the set of folders which are on the specified screen. */
2279         private void filterCurrentFolders(long currentScreenId,
2280                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2281                 HashMap&lt;Long, FolderInfo&gt; folders,
2282                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2283                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2284 
2285             for (long id : folders.keySet()) {
2286                 ItemInfo info = itemsIdMap.get(id);
2287                 FolderInfo folder = folders.get(id);
2288                 if (info == null || folder == null) continue;
2289                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2290                         info.screenId == currentScreenId) {
2291                     currentScreenFolders.put(id, folder);
2292                 } else {
2293                     otherScreenFolders.put(id, folder);
2294                 }
2295             }
2296         }
2297 
2298         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2299          * right) */
2300         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2301             final LauncherAppState app = LauncherAppState.getInstance();
2302             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2303             // XXX: review this
2304             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2305                 @Override
2306                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2307                     int cellCountX = (int) grid.numColumns;
2308                     int cellCountY = (int) grid.numRows;
2309                     int screenOffset = cellCountX * cellCountY;
2310                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2311                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2312                             lhs.cellY * cellCountX + lhs.cellX);
2313                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2314                             rhs.cellY * cellCountX + rhs.cellX);
2315                     return (int) (lr - rr);
2316                 }
2317             });
2318         }
2319 
2320         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2321                 final ArrayList&lt;Long&gt; orderedScreens) {
2322             final Runnable r = new Runnable() {
2323                 @Override
2324                 public void run() {
2325                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2326                     if (callbacks != null) {
2327                         callbacks.bindScreens(orderedScreens);
2328                     }
2329                 }
2330             };
2331             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2332         }
2333 
2334         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2335                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2336                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2337                 final HashMap&lt;Long, FolderInfo&gt; folders,
2338                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2339 
2340             final boolean postOnMainThread = (deferredBindRunnables != null);
2341 
2342             // Bind the workspace items
2343             int N = workspaceItems.size();
2344             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2345                 final int start = i;
2346                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2347                 final Runnable r = new Runnable() {
2348                     @Override
2349                     public void run() {
2350                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2351                         if (callbacks != null) {
2352                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2353                                     false);
2354                         }
2355                     }
2356                 };
2357                 if (postOnMainThread) {
2358                     deferredBindRunnables.add(r);
2359                 } else {
2360                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2361                 }
2362             }
2363 
2364             // Bind the folders
2365             if (!folders.isEmpty()) {
2366                 final Runnable r = new Runnable() {
2367                     public void run() {
2368                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2369                         if (callbacks != null) {
2370                             callbacks.bindFolders(folders);
2371                         }
2372                     }
2373                 };
2374                 if (postOnMainThread) {
2375                     deferredBindRunnables.add(r);
2376                 } else {
2377                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2378                 }
2379             }
2380 
2381             // Bind the widgets, one at a time
2382             N = appWidgets.size();
2383             for (int i = 0; i &lt; N; i++) {
2384                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2385                 final Runnable r = new Runnable() {
2386                     public void run() {
2387                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2388                         if (callbacks != null) {
2389                             callbacks.bindAppWidget(widget);
2390                         }
2391                     }
2392                 };
2393                 if (postOnMainThread) {
2394                     deferredBindRunnables.add(r);
2395                 } else {
2396                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2397                 }
2398             }
2399         }
2400 
2401         /**
2402          * Binds all loaded data to actual views on the main thread.
2403          */
2404         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2405             final long t = SystemClock.uptimeMillis();
2406             Runnable r;
2407 
2408             // Don&#x27;t use these two variables in any of the callback runnables.
2409             // Otherwise we hold a reference to them.
2410             final Callbacks oldCallbacks = mCallbacks.get();
2411             if (oldCallbacks == null) {
2412                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2413                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2414                 return;
2415             }
2416 
2417             // Save a copy of all the bg-thread collections
2418             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2419             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2420                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2421             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2422             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2423             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2424             synchronized (sBgLock) {
2425                 workspaceItems.addAll(sBgWorkspaceItems);
2426                 appWidgets.addAll(sBgAppWidgets);
2427                 folders.putAll(sBgFolders);
2428                 itemsIdMap.putAll(sBgItemsIdMap);
2429                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2430             }
2431 
2432             final boolean isLoadingSynchronously =
2433                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2434             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2435                 oldCallbacks.getCurrentWorkspaceScreen();
2436             if (currScreen &gt;= orderedScreenIds.size()) {
2437                 // There may be no workspace screens (just hotseat items and an empty page).
2438                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2439             }
2440             final int currentScreen = currScreen;
2441             final long currentScreenId = currentScreen &lt; 0
2442                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2443 
2444             // Load all the items that are on the current page first (and in the process, unbind
2445             // all the existing workspace items before we call startBinding() below.
2446             unbindWorkspaceItemsOnMainThread();
2447 
2448             // Separate the items that are on the current screen, and all the other remaining items
2449             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2450             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2451             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2452                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2453             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2454                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2455             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2456             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2457 
2458             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2459                     otherWorkspaceItems);
2460             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2461                     otherAppWidgets);
2462             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2463                     otherFolders);
2464             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2465             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2466 
2467             // Tell the workspace that we&#x27;re about to start binding items
2468             r = new Runnable() {
2469                 public void run() {
2470                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2471                     if (callbacks != null) {
2472                         callbacks.startBinding();
2473                     }
2474                 }
2475             };
2476             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2477 
2478             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2479 
2480             // Load items on the current page
2481             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2482                     currentFolders, null);
2483             if (isLoadingSynchronously) {
2484                 r = new Runnable() {
2485                     public void run() {
2486                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2487                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2488                             callbacks.onPageBoundSynchronously(currentScreen);
2489                         }
2490                     }
2491                 };
2492                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2493             }
2494 
2495             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2496             // work until after the first render)
2497             mDeferredBindRunnables.clear();
2498             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2499                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2500 
2501             // Tell the workspace that we&#x27;re done binding items
2502             r = new Runnable() {
2503                 public void run() {
2504                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2505                     if (callbacks != null) {
2506                         callbacks.finishBindingItems(isUpgradePath);
2507                     }
2508 
2509                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2510                     if (DEBUG_LOADERS) {
2511                         Log.d(TAG, &quot;bound workspace in &quot;
2512                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2513                     }
2514 
2515                     mIsLoadingAndBindingWorkspace = false;
2516                 }
2517             };
2518             if (isLoadingSynchronously) {
2519                 mDeferredBindRunnables.add(r);
2520             } else {
2521                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2522             }
2523         }
2524 
2525         private void loadAndBindAllApps() {
2526             if (DEBUG_LOADERS) {
2527                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2528             }
2529             if (!mAllAppsLoaded) {
2530                 loadAllApps();
2531                 synchronized (LoaderTask.this) {
2532                     if (mStopped) {
2533                         return;
2534                     }
2535                     mAllAppsLoaded = true;
2536                 }
2537             } else {
2538                 onlyBindAllApps();
2539             }
2540         }
2541 
2542         private void onlyBindAllApps() {
2543             final Callbacks oldCallbacks = mCallbacks.get();
2544             if (oldCallbacks == null) {
2545                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2546                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2547                 return;
2548             }
2549 
2550             // shallow copy
2551             @SuppressWarnings(&quot;unchecked&quot;)
2552             final ArrayList&lt;AppInfo&gt; list
2553                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2554             Runnable r = new Runnable() {
2555                 public void run() {
2556                     final long t = SystemClock.uptimeMillis();
2557                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2558                     if (callbacks != null) {
2559                         callbacks.bindAllApplications(list);
2560                     }
2561                     if (DEBUG_LOADERS) {
2562                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2563                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2564                     }
2565                 }
2566             };
2567             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2568             if (isRunningOnMainThread) {
2569                 r.run();
2570             } else {
2571                 mHandler.post(r);
2572             }
2573         }
2574 
2575         private void loadAllApps() {
2576             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2577 
2578             final Callbacks oldCallbacks = mCallbacks.get();
2579             if (oldCallbacks == null) {
2580                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2581                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2582                 return;
2583             }
2584 
2585             final PackageManager packageManager = mContext.getPackageManager();
2586             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2587             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2588 
2589             // Clear the list of apps
2590             mBgAllAppsList.clear();
2591 
2592             // Query for the set of apps
2593             final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2594             List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);
2595             if (DEBUG_LOADERS) {
2596                 Log.d(TAG, &quot;queryIntentActivities took &quot;
2597                         + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2598                 Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);
2599             }
2600             // Fail if we don&#x27;t have any apps
2601             if (apps == null || apps.isEmpty()) {
2602                 return;
2603             }
2604             // Sort the applications by name
2605             final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2606             Collections.sort(apps,
2607                     new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2608             if (DEBUG_LOADERS) {
2609                 Log.d(TAG, &quot;sort took &quot;
2610                         + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2611             }
2612 
2613             // Create the ApplicationInfos
2614             for (int i = 0; i &lt; apps.size(); i++) {
2615                 ResolveInfo app = apps.get(i);
2616                 // This builds the icon bitmaps.
2617                 mBgAllAppsList.add(new AppInfo(packageManager, app,
2618                         mIconCache, mLabelCache));
2619             }
2620 
2621             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2622             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2623             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2624 
2625             // Post callback on main thread
2626             mHandler.post(new Runnable() {
2627                 public void run() {
2628                     final long bindTime = SystemClock.uptimeMillis();
2629                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2630                     if (callbacks != null) {
2631                         callbacks.bindAllApplications(added);
2632                         if (DEBUG_LOADERS) {
2633                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2634                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2635                         }
2636                     } else {
2637                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2638                     }
2639                 }
2640             });
2641 
2642             if (DEBUG_LOADERS) {
2643                 Log.d(TAG, &quot;Icons processed in &quot;
2644                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2645             }
2646         }
2647 
2648         public void dumpState() {
2649             synchronized (sBgLock) {
2650                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2651                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2652                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2653                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2654                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2655             }
2656         }
2657     }
2658 
2659     void enqueuePackageUpdated(PackageUpdatedTask task) {
2660         sWorker.post(task);
2661     }
2662 
2663     private class PackageUpdatedTask implements Runnable {
2664         int mOp;
2665         String[] mPackages;
2666 
2667         public static final int OP_NONE = 0;
2668         public static final int OP_ADD = 1;
2669         public static final int OP_UPDATE = 2;
2670         public static final int OP_REMOVE = 3; // uninstlled
2671         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2672 
2673 
2674         public PackageUpdatedTask(int op, String[] packages) {
2675             mOp = op;
2676             mPackages = packages;
2677         }
2678 
2679         public void run() {
2680             final Context context = mApp.getContext();
2681 
2682             final String[] packages = mPackages;
2683             final int N = packages.length;
2684             switch (mOp) {
2685                 case OP_ADD:
2686                     for (int i=0; i&lt;N; i++) {
2687                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2688                         mIconCache.remove(packages[i]);
2689                         mBgAllAppsList.addPackage(context, packages[i]);
2690                     }
2691                     break;
2692                 case OP_UPDATE:
2693                     for (int i=0; i&lt;N; i++) {
2694                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2695                         mBgAllAppsList.updatePackage(context, packages[i]);
2696                         WidgetPreviewLoader.removePackageFromDb(
2697                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
2698                     }
2699                     break;
2700                 case OP_REMOVE:
2701                 case OP_UNAVAILABLE:
2702                     for (int i=0; i&lt;N; i++) {
2703                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2704                         mBgAllAppsList.removePackage(packages[i]);
2705                         WidgetPreviewLoader.removePackageFromDb(
2706                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
2707                     }
2708                     break;
2709             }
2710 
2711             ArrayList&lt;AppInfo&gt; added = null;
2712             ArrayList&lt;AppInfo&gt; modified = null;
2713             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2714 
2715             if (mBgAllAppsList.added.size() &gt; 0) {
2716                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2717                 mBgAllAppsList.added.clear();
2718             }
2719             if (mBgAllAppsList.modified.size() &gt; 0) {
2720                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2721                 mBgAllAppsList.modified.clear();
2722             }
2723             if (mBgAllAppsList.removed.size() &gt; 0) {
2724                 removedApps.addAll(mBgAllAppsList.removed);
2725                 mBgAllAppsList.removed.clear();
2726             }
2727 
2728             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2729             if (callbacks == null) {
2730                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2731                 return;
2732             }
2733 
2734             if (added != null) {
2735                 // Ensure that we add all the workspace applications to the db
2736                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2737                 if (!LauncherAppState.isDisableAllApps()) {
2738                     addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);
2739                 } else {
2740                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2741                     addAndBindAddedApps(context, addedInfos, cb, added);
2742                 }
2743             }
2744             if (modified != null) {
2745                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2746 
2747                 // Update the launcher db to reflect the changes
2748                 for (AppInfo a : modifiedFinal) {
2749                     ArrayList&lt;ItemInfo&gt; infos =
2750                             getItemInfoForComponentName(a.componentName);
2751                     for (ItemInfo i : infos) {
2752                         if (isShortcutInfoUpdateable(i)) {
2753                             ShortcutInfo info = (ShortcutInfo) i;
2754                             info.title = a.title.toString();
2755                             updateItemInDatabase(context, info);
2756                         }
2757                     }
2758                 }
2759 
2760                 mHandler.post(new Runnable() {
2761                     public void run() {
2762                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2763                         if (callbacks == cb &amp;&amp; cb != null) {
2764                             callbacks.bindAppsUpdated(modifiedFinal);
2765                         }
2766                     }
2767                 });
2768             }
2769 
2770             final ArrayList&lt;String&gt; removedPackageNames =
2771                     new ArrayList&lt;String&gt;();
2772             if (mOp == OP_REMOVE) {
2773                 // Mark all packages in the broadcast to be removed
2774                 removedPackageNames.addAll(Arrays.asList(packages));
2775             } else if (mOp == OP_UPDATE) {
2776                 // Mark disabled packages in the broadcast to be removed
2777                 final PackageManager pm = context.getPackageManager();
2778                 for (int i=0; i&lt;N; i++) {
2779                     if (isPackageDisabled(pm, packages[i])) {
2780                         removedPackageNames.add(packages[i]);
2781                     }
2782                 }
2783             }
2784             // Remove all the components associated with this package
2785             for (String pn : removedPackageNames) {
2786                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);
2787                 for (ItemInfo i : infos) {
2788                     deleteItemFromDatabase(context, i);
2789                 }
2790             }
2791             // Remove all the specific components
2792             for (AppInfo a : removedApps) {
2793                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2794                 for (ItemInfo i : infos) {
2795                     deleteItemFromDatabase(context, i);
2796                 }
2797             }
2798             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
2799                 // Remove any queued items from the install queue
2800                 String spKey = LauncherAppState.getSharedPreferencesKey();
2801                 SharedPreferences sp =
2802                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2803                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2804                 // Call the components-removed callback
2805                 mHandler.post(new Runnable() {
2806                     public void run() {
2807                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2808                         if (callbacks == cb &amp;&amp; cb != null) {
2809                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps);
2810                         }
2811                     }
2812                 });
2813             }
2814 
2815             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
2816                 getSortedWidgetsAndShortcuts(context);
2817             mHandler.post(new Runnable() {
2818                 @Override
2819                 public void run() {
2820                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2821                     if (callbacks == cb &amp;&amp; cb != null) {
2822                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2823                     }
2824                 }
2825             });
2826 
2827             // Write all the logs to disk
2828             mHandler.post(new Runnable() {
2829                 public void run() {
2830                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2831                     if (callbacks == cb &amp;&amp; cb != null) {
2832                         callbacks.dumpLogsToLocalData();
2833                     }
2834                 }
2835             });
2836         }
2837     }
2838 
2839     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2840     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2841         PackageManager packageManager = context.getPackageManager();
2842         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2843         widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());
2844         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2845         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2846         Collections.sort(widgetsAndShortcuts,
2847             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));
2848         return widgetsAndShortcuts;
2849     }
2850 
2851     private static boolean isPackageDisabled(PackageManager pm, String packageName) {
2852         try {
2853             PackageInfo pi = pm.getPackageInfo(packageName, 0);
2854             return !pi.applicationInfo.enabled;
2855         } catch (NameNotFoundException e) {
2856             // Fall through
2857         }
2858         return false;
2859     }
2860 
2861     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {
2862         if (cn == null) {
2863             return false;
2864         }
2865         if (isPackageDisabled(pm, cn.getPackageName())) {
2866             return false;
2867         }
2868 
2869         try {
2870             // Check the activity
2871             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);
2872             return (pm.getActivityInfo(cn, 0) != null);
2873         } catch (NameNotFoundException e) {
2874             return false;
2875         }
2876     }
2877 
2878     /**
2879      * Make an ShortcutInfo object for a restored application or shortcut item that points
2880      * to a package that is not yet installed on the system.
2881      */
2882     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {
2883         final ShortcutInfo info = new ShortcutInfo();
2884         if (cursor != null) {
2885             info.title =  cursor.getString(titleIndex);
2886         } else {
2887             info.title = &quot;&quot;;
2888         }
2889         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));
2890         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2891         return info;
2892     }
2893 
2894     /**
2895      * Make an Intent object for a restored application or shortcut item that points
2896      * to the market page for the item.
2897      */
2898     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2899         ComponentName componentName = intent.getComponent();
2900         Intent marketIntent = new Intent(Intent.ACTION_VIEW);
2901         Uri marketUri = new Uri.Builder()
2902                 .scheme(&quot;market&quot;)
2903                 .authority(&quot;details&quot;)
2904                 .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())
2905                 .build();
2906         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());
2907         marketIntent.setData(marketUri);
2908         return marketIntent;
2909     }
2910 
2911     /**
2912      * This is called from the code that adds shortcuts from the intent receiver.  This
2913      * doesn&#x27;t have a Cursor, but
2914      */
2915     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2916         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2917     }
2918 
2919     /**
2920      * Make an ShortcutInfo object for a shortcut that is an application.
2921      *
2922      * If c is not null, then it will be used to fill in missing data like the title and icon.
2923      */
2924     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2925             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2926         ComponentName componentName = intent.getComponent();
2927         final ShortcutInfo info = new ShortcutInfo();
2928         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {
2929             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);
2930             return null;
2931         } else {
2932             try {
2933                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2934                 info.initFlagsAndFirstInstallTime(pi);
2935             } catch (NameNotFoundException e) {
2936                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +
2937                         componentName.getPackageName());
2938             }
2939         }
2940 
2941         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2942         // then return null &amp; delete this.
2943 
2944         // the resource -- This may implicitly give us back the fallback icon,
2945         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2946         // to avoid saving lots of copies of that in the database, and most apps
2947         // have icons anyway.
2948 
2949         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2950         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2951         // via resolveActivity().
2952         Bitmap icon = null;
2953         ResolveInfo resolveInfo = null;
2954         ComponentName oldComponent = intent.getComponent();
2955         Intent newIntent = new Intent(intent.getAction(), null);
2956         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2957         newIntent.setPackage(oldComponent.getPackageName());
2958         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2959         for (ResolveInfo i : infos) {
2960             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2961                     i.activityInfo.name);
2962             if (cn.equals(oldComponent)) {
2963                 resolveInfo = i;
2964             }
2965         }
2966         if (resolveInfo == null) {
2967             resolveInfo = manager.resolveActivity(intent, 0);
2968         }
2969         if (resolveInfo != null) {
2970             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2971         }
2972         // the db
2973         if (icon == null) {
2974             if (c != null) {
2975                 icon = getIconFromCursor(c, iconIndex, context);
2976             }
2977         }
2978         // the fallback icon
2979         if (icon == null) {
2980             icon = getFallbackIcon();
2981             info.usingFallbackIcon = true;
2982         }
2983         info.setIcon(icon);
2984 
2985         // from the resource
2986         if (resolveInfo != null) {
2987             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2988             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2989                 info.title = labelCache.get(key);
2990             } else {
2991                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2992                 if (labelCache != null) {
2993                     labelCache.put(key, info.title);
2994                 }
2995             }
2996         }
2997         // from the db
2998         if (info.title == null) {
2999             if (c != null) {
3000                 info.title =  c.getString(titleIndex);
3001             }
3002         }
3003         // fall back to the class name of the activity
3004         if (info.title == null) {
3005             info.title = componentName.getClassName();
3006         }
3007         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3008         return info;
3009     }
3010 
3011     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3012             ItemInfoFilter f) {
3013         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3014         for (ItemInfo i : infos) {
3015             if (i instanceof ShortcutInfo) {
3016                 ShortcutInfo info = (ShortcutInfo) i;
3017                 ComponentName cn = info.intent.getComponent();
3018                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3019                     filtered.add(info);
3020                 }
3021             } else if (i instanceof FolderInfo) {
3022                 FolderInfo info = (FolderInfo) i;
3023                 for (ShortcutInfo s : info.contents) {
3024                     ComponentName cn = s.intent.getComponent();
3025                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3026                         filtered.add(s);
3027                     }
3028                 }
3029             } else if (i instanceof LauncherAppWidgetInfo) {
3030                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3031                 ComponentName cn = info.providerName;
3032                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3033                     filtered.add(info);
3034                 }
3035             }
3036         }
3037         return new ArrayList&lt;ItemInfo&gt;(filtered);
3038     }
3039 
3040     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {
3041         ItemInfoFilter filter  = new ItemInfoFilter() {
3042             @Override
3043             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3044                 return cn.getPackageName().equals(pn);
3045             }
3046         };
3047         return filterItemInfos(sBgItemsIdMap.values(), filter);
3048     }
3049 
3050     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {
3051         ItemInfoFilter filter  = new ItemInfoFilter() {
3052             @Override
3053             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3054                 return cn.equals(cname);
3055             }
3056         };
3057         return filterItemInfos(sBgItemsIdMap.values(), filter);
3058     }
3059 
3060     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3061         if (i instanceof ShortcutInfo) {
3062             ShortcutInfo info = (ShortcutInfo) i;
3063             // We need to check for ACTION_MAIN otherwise getComponent() might
3064             // return null for some shortcuts (for instance, for shortcuts to
3065             // web pages.)
3066             Intent intent = info.intent;
3067             ComponentName name = intent.getComponent();
3068             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3069                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3070                 return true;
3071             }
3072         }
3073         return false;
3074     }
3075 
3076     /**
3077      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3078      */
3079     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3080             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3081             int titleIndex) {
3082 
3083         Bitmap icon = null;
3084         final ShortcutInfo info = new ShortcutInfo();
3085         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3086 
3087         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3088 
3089         info.title = c.getString(titleIndex);
3090 
3091         int iconType = c.getInt(iconTypeIndex);
3092         switch (iconType) {
3093         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3094             String packageName = c.getString(iconPackageIndex);
3095             String resourceName = c.getString(iconResourceIndex);
3096             PackageManager packageManager = context.getPackageManager();
3097             info.customIcon = false;
3098             // the resource
3099             try {
3100                 Resources resources = packageManager.getResourcesForApplication(packageName);
3101                 if (resources != null) {
3102                     final int id = resources.getIdentifier(resourceName, null, null);
3103                     icon = Utilities.createIconBitmap(
3104                             mIconCache.getFullResIcon(resources, id), context);
3105                 }
3106             } catch (Exception e) {
3107                 // drop this.  we have other places to look for icons
3108             }
3109             // the db
3110             if (icon == null) {
3111                 icon = getIconFromCursor(c, iconIndex, context);
3112             }
3113             // the fallback icon
3114             if (icon == null) {
3115                 icon = getFallbackIcon();
3116                 info.usingFallbackIcon = true;
3117             }
3118             break;
3119         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3120             icon = getIconFromCursor(c, iconIndex, context);
3121             if (icon == null) {
3122                 icon = getFallbackIcon();
3123                 info.customIcon = false;
3124                 info.usingFallbackIcon = true;
3125             } else {
3126                 info.customIcon = true;
3127             }
3128             break;
3129         default:
3130             icon = getFallbackIcon();
3131             info.usingFallbackIcon = true;
3132             info.customIcon = false;
3133             break;
3134         }
3135         info.setIcon(icon);
3136         return info;
3137     }
3138 
3139     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3140         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3141         final boolean debug = false;
3142         if (debug) {
3143             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3144                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3145         }
3146         byte[] data = c.getBlob(iconIndex);
3147         try {
3148             return Utilities.createIconBitmap(
3149                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3150         } catch (Exception e) {
3151             return null;
3152         }
3153     }
3154 
3155     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3156             int cellX, int cellY, boolean notify) {
3157         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3158         if (info == null) {
3159             return null;
3160         }
3161         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3162 
3163         return info;
3164     }
3165 
3166     /**
3167      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3168      */
3169     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3170             ComponentName component) {
3171         List&lt;AppWidgetProviderInfo&gt; widgets =
3172             AppWidgetManager.getInstance(context).getInstalledProviders();
3173         for (AppWidgetProviderInfo info : widgets) {
3174             if (info.provider.equals(component)) {
3175                 return info;
3176             }
3177         }
3178         return null;
3179     }
3180 
3181     /**
3182      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
3183      */
3184     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
3185         final PackageManager packageManager = context.getPackageManager();
3186         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
3187             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
3188 
3189         final Intent supportsIntent =
3190             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
3191         supportsIntent.setType(mimeType);
3192 
3193         // Create a set of widget configuration components that we can test against
3194         final List&lt;AppWidgetProviderInfo&gt; widgets =
3195             AppWidgetManager.getInstance(context).getInstalledProviders();
3196         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
3197             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
3198         for (AppWidgetProviderInfo info : widgets) {
3199             configurationComponentToWidget.put(info.configure, info);
3200         }
3201 
3202         // Run through each of the intents that can handle this type of clip data, and cross
3203         // reference them with the components that are actual configuration components
3204         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
3205                 PackageManager.MATCH_DEFAULT_ONLY);
3206         for (ResolveInfo info : activities) {
3207             final ActivityInfo activityInfo = info.activityInfo;
3208             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
3209                     activityInfo.name);
3210             if (configurationComponentToWidget.containsKey(infoComponent)) {
3211                 supportedConfigurationActivities.add(
3212                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
3213                                 configurationComponentToWidget.get(infoComponent)));
3214             }
3215         }
3216         return supportedConfigurationActivities;
3217     }
3218 
3219     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3220         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3221         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3222         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3223 
3224         if (intent == null) {
3225             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3226             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3227             return null;
3228         }
3229 
3230         Bitmap icon = null;
3231         boolean customIcon = false;
3232         ShortcutIconResource iconResource = null;
3233 
3234         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3235             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3236             customIcon = true;
3237         } else {
3238             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3239             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3240                 try {
3241                     iconResource = (ShortcutIconResource) extra;
3242                     final PackageManager packageManager = context.getPackageManager();
3243                     Resources resources = packageManager.getResourcesForApplication(
3244                             iconResource.packageName);
3245                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3246                     icon = Utilities.createIconBitmap(
3247                             mIconCache.getFullResIcon(resources, id), context);
3248                 } catch (Exception e) {
3249                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3250                 }
3251             }
3252         }
3253 
3254         final ShortcutInfo info = new ShortcutInfo();
3255 
3256         if (icon == null) {
3257             if (fallbackIcon != null) {
3258                 icon = fallbackIcon;
3259             } else {
3260                 icon = getFallbackIcon();
3261                 info.usingFallbackIcon = true;
3262             }
3263         }
3264         info.setIcon(icon);
3265 
3266         info.title = name;
3267         info.intent = intent;
3268         info.customIcon = customIcon;
3269         info.iconResource = iconResource;
3270 
3271         return info;
3272     }
3273 
3274     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3275             int iconIndex) {
3276         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3277         if (!mAppsCanBeOnRemoveableStorage) {
3278             return false;
3279         }
3280         // If this icon doesn&#x27;t have a custom icon, check to see
3281         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3282         // we&#x27;re going to show, store what we are going to show back
3283         // into the DB.  We do this so when we&#x27;re loading, if the
3284         // package manager can&#x27;t find an icon (for example because
3285         // the app is on SD) then we can use that instead.
3286         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3287             cache.put(info, c.getBlob(iconIndex));
3288             return true;
3289         }
3290         return false;
3291     }
3292     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3293         boolean needSave = false;
3294         try {
3295             if (data != null) {
3296                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3297                 Bitmap loaded = info.getIcon(mIconCache);
3298                 needSave = !saved.sameAs(loaded);
3299             } else {
3300                 needSave = true;
3301             }
3302         } catch (Exception e) {
3303             needSave = true;
3304         }
3305         if (needSave) {
3306             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3307             // This is slower than is ideal, but this only happens once
3308             // or when the app is updated with a new icon.
3309             updateItemInDatabase(context, info);
3310         }
3311     }
3312 
3313     /**
3314      * Return an existing FolderInfo object if we have encountered this ID previously,
3315      * or make a new one.
3316      */
3317     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3318         // See if a placeholder was created for us already
3319         FolderInfo folderInfo = folders.get(id);
3320         if (folderInfo == null) {
3321             // No placeholder -- create a new instance
3322             folderInfo = new FolderInfo();
3323             folders.put(id, folderInfo);
3324         }
3325         return folderInfo;
3326     }
3327 
3328     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3329         final Collator collator = Collator.getInstance();
3330         return new Comparator&lt;AppInfo&gt;() {
3331             public final int compare(AppInfo a, AppInfo b) {
3332                 int result = collator.compare(a.title.toString().trim(),
3333                         b.title.toString().trim());
3334                 if (result == 0) {
3335                     result = a.componentName.compareTo(b.componentName);
3336                 }
3337                 return result;
3338             }
3339         };
3340     }
3341     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3342             = new Comparator&lt;AppInfo&gt;() {
3343         public final int compare(AppInfo a, AppInfo b) {
3344             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3345             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3346             return 0;
3347         }
3348     };
3349     public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {
3350         final Collator collator = Collator.getInstance();
3351         return new Comparator&lt;AppWidgetProviderInfo&gt;() {
3352             public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
3353                 return collator.compare(a.label.toString().trim(), b.label.toString().trim());
3354             }
3355         };
3356     }
3357     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3358         if (info.activityInfo != null) {
3359             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3360         } else {
3361             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3362         }
3363     }
3364     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
3365         private Collator mCollator;
3366         private PackageManager mPackageManager;
3367         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3368         ShortcutNameComparator(PackageManager pm) {
3369             mPackageManager = pm;
3370             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3371             mCollator = Collator.getInstance();
3372         }
3373         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
3374             mPackageManager = pm;
3375             mLabelCache = labelCache;
3376             mCollator = Collator.getInstance();
3377         }
3378         public final int compare(ResolveInfo a, ResolveInfo b) {
3379             CharSequence labelA, labelB;
3380             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
3381             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
3382             if (mLabelCache.containsKey(keyA)) {
3383                 labelA = mLabelCache.get(keyA);
3384             } else {
3385                 labelA = a.loadLabel(mPackageManager).toString().trim();
3386 
3387                 mLabelCache.put(keyA, labelA);
3388             }
3389             if (mLabelCache.containsKey(keyB)) {
3390                 labelB = mLabelCache.get(keyB);
3391             } else {
3392                 labelB = b.loadLabel(mPackageManager).toString().trim();
3393 
3394                 mLabelCache.put(keyB, labelB);
3395             }
3396             return mCollator.compare(labelA, labelB);
3397         }
3398     }
3399     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3400         private Collator mCollator;
3401         private PackageManager mPackageManager;
3402         private HashMap&lt;Object, String&gt; mLabelCache;
3403         WidgetAndShortcutNameComparator(PackageManager pm) {
3404             mPackageManager = pm;
3405             mLabelCache = new HashMap&lt;Object, String&gt;();
3406             mCollator = Collator.getInstance();
3407         }
3408         public final int compare(Object a, Object b) {
3409             String labelA, labelB;
3410             if (mLabelCache.containsKey(a)) {
3411                 labelA = mLabelCache.get(a);
3412             } else {
3413                 labelA = (a instanceof AppWidgetProviderInfo) ?
3414                     ((AppWidgetProviderInfo) a).label :
3415                     ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3416                 mLabelCache.put(a, labelA);
3417             }
3418             if (mLabelCache.containsKey(b)) {
3419                 labelB = mLabelCache.get(b);
3420             } else {
3421                 labelB = (b instanceof AppWidgetProviderInfo) ?
3422                     ((AppWidgetProviderInfo) b).label :
3423                     ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3424                 mLabelCache.put(b, labelB);
3425             }
3426             return mCollator.compare(labelA, labelB);
3427         }
3428     }
3429 
3430     public void dumpState() {
3431         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3432         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3433         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3434         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3435         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3436         if (mLoaderTask != null) {
3437             mLoaderTask.dumpState();
3438         } else {
3439             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3440         }
3441     }
3442 }
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.*;
  22 import android.content.Intent.ShortcutIconResource;
  23 import android.content.pm.ActivityInfo;
  24 import android.content.pm.PackageInfo;
  25 import android.content.pm.PackageManager.NameNotFoundException;
  26 import android.content.pm.PackageManager;
  27 import android.content.pm.ResolveInfo;
  28 import android.content.res.Configuration;
  29 import android.content.res.Resources;
  30 import android.database.Cursor;
  31 import android.graphics.Bitmap;
  32 import android.graphics.BitmapFactory;
  33 import android.net.Uri;
  34 import android.os.Environment;
  35 import android.os.Handler;
  36 import android.os.HandlerThread;
  37 import android.os.Parcelable;
  38 import android.os.Process;
  39 import android.os.RemoteException;
  40 import android.os.SystemClock;
  41 import android.provider.BaseColumns;
  42 import android.text.TextUtils;
  43 import android.util.Log;
  44 import android.util.Pair;
  45 import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  46 import java.lang.ref.WeakReference;
  47 import java.net.URISyntaxException;
  48 import java.text.Collator;
  49 import java.util.ArrayList;
  50 import java.util.Arrays;
  51 import java.util.Collection;
  52 import java.util.Collections;
  53 import java.util.Comparator;
  54 import java.util.HashMap;
  55 import java.util.HashSet;
  56 import java.util.Iterator;
  57 import java.util.List;
  58 import java.util.Set;
  59 import java.util.TreeMap;
  60 import java.util.concurrent.atomic.AtomicBoolean;
  61 
  62 
  63 /**
  64  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  65  * LauncherModel object held in a static. Also provide APIs for updating the database state
  66  * for the Launcher.
  67  */
  68 public class LauncherModel extends BroadcastReceiver {
  69     static final boolean DEBUG_LOADERS = false;
  70 
  71     static final String TAG = &quot;Launcher.Model&quot;;
  72 
  73     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  74     // false = strew non-workspace apps across the workspace on upgrade
  75     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  76     // false = strew non-workspace apps across the workspace on upgrade
  77     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  78 
  79     public static final int LOADER_FLAG_NONE = 0;
  80 
  81     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  82 
  83     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  84 
  85     // batch size for the workspace icons
  86     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  87 
  88     private static final long INVALID_SCREEN_ID = -1L;
  89 
  90     private final boolean mAppsCanBeOnRemoveableStorage;
  91 
  92     private final boolean mOldContentProviderExists;
  93 
  94     private final LauncherAppState mApp;
  95 
  96     private final Object mLock = new Object();
  97 
  98     private DeferredHandler mHandler = new DeferredHandler();
  99 
 100     private LoaderTask mLoaderTask;
 101 
 102     private boolean mIsLoaderTaskRunning;
 103 
 104     private volatile boolean mFlushingWorkerThread;
 105 
 106     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 107     // clear all queued binding runnables when the Launcher activity is destroyed.
 108     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 109 
 110     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 111 
 112     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 113 
 114     static {
 115         sWorkerThread.start();
 116     }
 117 
 118     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 119 
 120     // We start off with everything not loaded.  After that, we assume that
 121     // our monitoring of the package manager provides all updates and we never
 122     // need to do a requery.  These are only ever touched from the loader thread.
 123     private boolean mWorkspaceLoaded;
 124 
 125     private boolean mAllAppsLoaded;
 126 
 127     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 128     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 129     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 130     // a normal load, we also clear this set of Runnables.
 131     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 132 
 133     private WeakReference&lt;Callbacks&gt; mCallbacks;
 134 
 135     // &lt; only access in worker thread &gt;
 136     // &lt; only access in worker thread &gt;
 137     AllAppsList mBgAllAppsList;
 138 
 139     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 140     // other locks, this one can generally be held long-term because we never expect any of these
 141     // static data structures to be referenced outside of the worker thread except on the first
 142     // load after configuration change.
 143     static final Object sBgLock = new Object();
 144 
 145     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 146     // LauncherModel to their ids
 147     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 148 
 149     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 150     // created by LauncherModel that are directly on the home screen (however, no widgets or
 151     // shortcuts within folders).
 152     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 153 
 154     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 155     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 156     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 157         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 158 
 159     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 160     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 161 
 162     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 163     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 164 
 165     // sBgWorkspaceScreens is the ordered set of workspace screens.
 166     // sBgWorkspaceScreens is the ordered set of workspace screens.
 167     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 168 
 169     // &lt;/ only access in worker thread &gt;
 170     // &lt;/ only access in worker thread &gt;
 171 
 172     private IconCache mIconCache;
 173 
 174     private Bitmap mDefaultIcon;
 175 
 176     protected int mPreviousConfigMcc;
 177 
 178     public interface Callbacks {
 179         public abstract boolean setLoadOnResume();
 180 
 181         public abstract int getCurrentWorkspaceScreen();
 182 
 183         public abstract void startBinding();
 184 
<abbr title=" 185         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAnimateIcons);"> 185         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAnðŸ”µ</abbr>
 186 
 187         public abstract void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 188 
 189         public abstract void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 190 
 191         public abstract void bindFolders(HashMap&lt;Long, FolderInfo&gt; folders);
 192 
 193         public abstract void finishBindingItems(boolean upgradePath);
 194 
 195         public abstract void bindAppWidget(LauncherAppWidgetInfo info);
 196 
 197         public abstract void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 198 
<abbr title=" 199         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated, ArrayList&lt;ItemInfo&gt; addAnimated, ArrayList&lt;AppInfo&gt; addedApps);"> 199         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimatedðŸ”µ</abbr>
 200 
 201         public abstract void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 202 
<abbr title=" 203         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appInfos);"> 203         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appðŸ”µ</abbr>
 204 
 205         public abstract void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 206 
 207         public abstract void bindSearchablesChanged();
 208 
 209         public abstract boolean isAllAppsButtonRank(int rank);
 210 
 211         public abstract void onPageBoundSynchronously(int page);
 212 
 213         public abstract void dumpLogsToLocalData();
 214     }
 215 
 216     public interface ItemInfoFilter {
 217         public abstract boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 218     }
 219 
 220     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 221         Context context = app.getContext();
 222         ContentResolver contentResolver = context.getContentResolver();
 223         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
<abbr title=" 224         mOldContentProviderExists = contentResolver.acquireContentProviderClient(LauncherSettings.Favorites.OLD_CONTENT_URI) != null;"> 224         mOldContentProviderExists = contentResolver.acquireContentProviderClient(LauncherSettings.FavoritðŸ”µ</abbr>
 225         mApp = app;
 226         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 227         mIconCache = iconCache;
 228         final Resources res = context.getResources();
 229         Configuration config = res.getConfiguration();
 230         mPreviousConfigMcc = config.mcc;
 231     }
 232 
 233     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 234      * posted on the main thread handler. */
 235     private void runOnMainThread(Runnable r) {
 236         runOnMainThread(r, 0);
 237     }
 238 
 239     private void runOnMainThread(Runnable r, int type) {
 240         if (sWorkerThread.getThreadId() == Process.myTid()) {
 241             // If we are on the worker thread, post onto the main handler
 242             mHandler.post(r);
 243         } else {
 244             r.run();
 245         }
 246     }
 247 
 248     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 249      * posted on the worker thread handler. */
 250     private static void runOnWorkerThread(Runnable r) {
 251         if (sWorkerThread.getThreadId() == Process.myTid()) {
 252             r.run();
 253         } else {
 254             // If we are not on the worker thread, then post to the worker handler
 255             sWorker.post(r);
 256         }
 257     }
 258 
 259     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 260         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 261     }
 262 
 263     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 264                                  long screen) {
 265         LauncherAppState app = LauncherAppState.getInstance();
 266         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 267         final int xCount = (int) grid.numColumns;
 268         final int yCount = (int) grid.numRows;
 269         boolean[][] occupied = new boolean[xCount][yCount];
 270 
 271         int cellX, cellY, spanX, spanY;
 272         for (int i = 0; i &lt; items.size(); ++i) {
 273             final ItemInfo item = items.get(i);
 274             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 275                 if (item.screenId == screen) {
 276                     cellX = item.cellX;
 277                     cellY = item.cellY;
 278                     spanX = item.spanX;
 279                     spanY = item.spanY;
 280                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 281                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 282                             occupied[x][y] = true;
 283                         }
 284                     }
 285                 }
 286             }
 287         }
 288 
 289         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 290     }
 291 
 292     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 293                                                         Intent launchIntent,
 294                                                         int firstScreenIndex,
 295                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 296         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 297         LauncherAppState app = LauncherAppState.getInstance();
 298         LauncherModel model = app.getModel();
 299         boolean found = false;
 300         synchronized (app) {
 301             if (sWorkerThread.getThreadId() != Process.myTid()) {
 302                 // Flush the LauncherModel worker thread, so that if we just did another
 303                 // processInstallShortcut, we give it time for its shortcut to get added to the
 304                 // database (getItemsInLocalCoordinates reads the database)
 305                 model.flushWorkerThread();
 306             }
 307             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 308 
 309             // Try adding to the workspace screens incrementally, starting at the default or center
 310             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 311             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 312             int count = workspaceScreens.size();
 313             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 314                 int[] tmpCoordinates = new int[2];
 315                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 316                         workspaceScreens.get(screen))) {
 317                     // Update the Launcher db
 318                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 319                 }
 320             }
 321         }
 322         return null;
 323     }
 324 
<abbr title=" 325     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps, final ArrayList&lt;AppInfo&gt; allAppsApps) {"> 325     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps, finalðŸ”µ</abbr>
 326         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 327         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);
 328     }
 329 
<abbr title=" 330     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps, final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {"> 330     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps, finalðŸ”µ</abbr>
 331         if ((workspaceApps == null) || (allAppsApps == null)) {
 332             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 333         }
 334         if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {
 335             return;
 336         }
 337         // Process the newly added applications and add them to the database first
 338         Runnable r = new Runnable() {
 339             public void run() {
 340                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 341                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 342                 // Get the list of workspace screens.  We need to append to this list and
 343                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 344                 // called.
 345                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 346                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 347                 for (Integer i : orderedScreens.keySet()) {
 348                     long screenId = orderedScreens.get(i);
 349                     workspaceScreens.add(screenId);
 350                 }
 351                 synchronized(sBgLock) {
 352                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 353                     while (iter.hasNext()) {
 354                         ItemInfo a = iter.next();
 355                         final String name = a.title.toString();
 356                         final Intent launchIntent = a.getIntent();
 357                         // Short-circuit this logic if the icon exists somewhere on the workspace
 358                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 359                             continue;
 360                         }
 361                         // Add this icon to the db, creating a new page if necessary.  If there
 362                         // is only the empty page then we just add items to the first page.
 363                         // Otherwise, we add them to the next pages.
 364                         int startSearchPageIndex = (workspaceScreens.isEmpty()) ? 0 : 1;
<abbr title=" 365                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 365                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, nameðŸ”µ</abbr>
 366                         if (coords == null) {
 367                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 368                             // If we can&#x27;t find a valid position, then just add a new screen.
 369                             // This takes time so we need to re-queue the add until the new
 370                             // page is added.  Create as many screens as necessary to satisfy
 371                             // the startSearchPageIndex.
<abbr title=" 372                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreens.size());"> 372                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreensðŸ”µ</abbr>
 373                             while (numPagesToAdd &gt; 0) {
 374                                 long screenId = lp.generateNewScreenId();
 375                                 // Save the screen id for binding in the workspace
 376                                 workspaceScreens.add(screenId);
 377                                 addedWorkspaceScreensFinal.add(screenId);
 378                                 numPagesToAdd--;
 379                             }
 380                             // Find the coordinate again
<abbr title=" 381                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 381                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntentðŸ”µ</abbr>
 382                         }
 383                         if (coords == null) {
 384                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 385                         }
 386                         ShortcutInfo shortcutInfo;
 387                         if (a instanceof ShortcutInfo) {
 388                             shortcutInfo = ((ShortcutInfo) (a));
 389                         } else if (a instanceof AppInfo) {
 390                             shortcutInfo = ((AppInfo) (a)).makeShortcut();
 391                         } else {
 392                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 393                         }
 394                         // Add the shortcut to the db
<abbr title=" 395                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP, coords.first, coords.second[0], coords.second[1], false);"> 395                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DESðŸ”µ</abbr>
 396                         // Save the ShortcutInfo for binding in the workspace
 397                         addedShortcutsFinal.add(shortcutInfo);
 398                     }
 399                 }
 400                 // Update the workspace screens
 401                 updateWorkspaceScreenOrder(context, workspaceScreens);
 402                 if ((!addedShortcutsFinal.isEmpty()) || (!allAppsApps.isEmpty())) {
 403                     runOnMainThread(new Runnable() {
 404                         public void run() {
 405                             Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 406                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
 407                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 408                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 409                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 410                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 410                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 411                                     long lastScreenId = info.screenId;
 412                                     for (ItemInfo i : addedShortcutsFinal) {
 413                                         if (i.screenId == lastScreenId) {
 414                                             addAnimated.add(i);
 415                                         } else {
 416                                             addNotAnimated.add(i);
 417                                         }
 418                                     }
 419                                 }
<abbr title=" 420                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAnimated, allAppsApps);"> 420                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAnðŸ”µ</abbr>
 421                             }
 422                         }
 423                     });
 424                 }
 425             }
 426         };
 427         runOnWorkerThread(r);
 428     }
 429 
 430     public Bitmap getFallbackIcon() {
 431         if (mDefaultIcon == null) {
 432             final Context context = LauncherAppState.getInstance().getContext();
 433             mDefaultIcon = Utilities.createIconBitmap(
 434                     mIconCache.getFullResDefaultActivityIcon(), context);
 435         }
 436         return Bitmap.createBitmap(mDefaultIcon);
 437     }
 438 
 439     public void unbindItemInfosAndClearQueuedBindRunnables() {
 440         if (sWorkerThread.getThreadId() == Process.myTid()) {
 441             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 442                     &quot;main thread&quot;);
 443         }
 444 
 445         // Clear any deferred bind runnables
 446         mDeferredBindRunnables.clear();
 447         // Remove any queued bind runnables
 448         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 449         // Unbind all the workspace items
 450         unbindWorkspaceItemsOnMainThread();
 451     }
 452 
 453     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 454     void unbindWorkspaceItemsOnMainThread() {
 455         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 456         // by making a copy of workspace items first.
 457         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 458         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 459         synchronized (sBgLock) {
 460             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 461             tmpAppWidgets.addAll(sBgAppWidgets);
 462         }
 463         Runnable r = new Runnable() {
 464                 @Override
 465                 public void run() {
 466                    for (ItemInfo item : tmpWorkspaceItems) {
 467                        item.unbind();
 468                    }
 469                    for (ItemInfo item : tmpAppWidgets) {
 470                        item.unbind();
 471                    }
 472                 }
 473             };
 474         runOnMainThread(r);
 475     }
 476 
 477     /**
 478      * Adds an item to the DB if it was not created previously, or move it to a new
 479      * &lt;container, screen, cellX, cellY&gt;
 480      */
 481     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 482             long screenId, int cellX, int cellY) {
 483         if (item.container == ItemInfo.NO_ID) {
 484             // From all apps
 485             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 486         } else {
 487             // From somewhere else
 488             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 489         }
 490     }
 491 
 492     static void checkItemInfoLocked(
 493             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 494         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 495         if (modelItem != null &amp;&amp; item != modelItem) {
 496             // check all the data is consistent
 497             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 498                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 499                 ShortcutInfo shortcut = (ShortcutInfo) item;
 500                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 501                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 502                         modelShortcut.id == shortcut.id &amp;&amp;
 503                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 504                         modelShortcut.container == shortcut.container &amp;&amp;
 505                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 506                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 507                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 508                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 509                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 510                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 511                         (modelShortcut.dropPos != null &amp;&amp;
 512                                 shortcut.dropPos != null &amp;&amp;
 513                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 514                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 515                     // For all intents and purposes, this is the same object
 516                     return;
 517                 }
 518             }
 519 
 520             // the modelItem needs to match up perfectly with item if our model is
 521             // to be consistent with the database-- for now, just require
 522             // modelItem == item or the equality check above
 523             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 524                     &quot;modelItem: &quot; +
 525                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 526                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 527             RuntimeException e = new RuntimeException(msg);
 528             if (stackTrace != null) {
 529                 e.setStackTrace(stackTrace);
 530             }
 531             throw e;
 532         }
 533     }
 534 
 535     static void checkItemInfo(final ItemInfo item) {
 536         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 537         final long itemId = item.id;
 538         Runnable r = new Runnable() {
 539             public void run() {
 540                 synchronized (sBgLock) {
 541                     checkItemInfoLocked(itemId, item, stackTrace);
 542                 }
 543             }
 544         };
 545         runOnWorkerThread(r);
 546     }
 547 
 548     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 549             final ItemInfo item, final String callingFunction) {
 550         final long itemId = item.id;
 551         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 552         final ContentResolver cr = context.getContentResolver();
 553 
 554         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 555         Runnable r = new Runnable() {
 556             public void run() {
 557                 cr.update(uri, values, null, null);
 558                 updateItemArrays(item, itemId, stackTrace);
 559             }
 560         };
 561         runOnWorkerThread(r);
 562     }
 563 
 564     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 565             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 566         final ContentResolver cr = context.getContentResolver();
 567 
 568         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 569         Runnable r = new Runnable() {
 570             public void run() {
 571                 ArrayList&lt;ContentProviderOperation&gt; ops =
 572                         new ArrayList&lt;ContentProviderOperation&gt;();
 573                 int count = items.size();
 574                 for (int i = 0; i &lt; count; i++) {
 575                     ItemInfo item = items.get(i);
 576                     final long itemId = item.id;
 577                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 578                     ContentValues values = valuesList.get(i);
 579 
 580                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 581                     updateItemArrays(item, itemId, stackTrace);
 582 
 583                 }
 584                 try {
 585                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 586                 } catch (Exception e) {
 587                     e.printStackTrace();
 588                 }
 589             }
 590         };
 591         runOnWorkerThread(r);
 592     }
 593 
 594     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 595         // Lock on mBgLock *after* the db operation
 596         synchronized (sBgLock) {
 597             checkItemInfoLocked(itemId, item, stackTrace);
 598 
 599             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 600                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 601                 // Item is in a folder, make sure this folder exists
 602                 if (!sBgFolders.containsKey(item.container)) {
 603                     // An items container is being set to a that of an item which is not in
 604                     // the list of Folders.
 605                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 606                             item.container + &quot;, not in the list of folders&quot;;
 607                     Log.e(TAG, msg);
 608                 }
 609             }
 610 
 611             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 612             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 613             // that are on the desktop, as appropriate
 614             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 615             if (modelItem != null &amp;&amp;
 616                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 617                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 618                 switch (modelItem.itemType) {
 619                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 620                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 621                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 622                         if (!sBgWorkspaceItems.contains(modelItem)) {
 623                             sBgWorkspaceItems.add(modelItem);
 624                         }
 625                         break;
 626                     default:
 627                         break;
 628                 }
 629             } else {
 630                 sBgWorkspaceItems.remove(modelItem);
 631             }
 632         }
 633     }
 634 
 635     public void flushWorkerThread() {
 636         mFlushingWorkerThread = true;
 637         Runnable waiter = new Runnable() {
 638                 public void run() {
 639                     synchronized (this) {
 640                         notifyAll();
 641                         mFlushingWorkerThread = false;
 642                     }
 643                 }
 644             };
 645 
 646         synchronized(waiter) {
 647             runOnWorkerThread(waiter);
 648             if (mLoaderTask != null) {
 649                 synchronized(mLoaderTask) {
 650                     mLoaderTask.notify();
 651                 }
 652             }
 653             boolean success = false;
 654             while (!success) {
 655                 try {
 656                     waiter.wait();
 657                     success = true;
 658                 } catch (InterruptedException e) {
 659                 }
 660             }
 661         }
 662     }
 663 
 664     /**
 665      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 666      */
 667     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 668             final long screenId, final int cellX, final int cellY) {
 669         item.container = container;
 670         item.cellX = cellX;
 671         item.cellY = cellY;
 672 
 673         // We store hotseat items in canonical form which is this orientation invariant position
 674         // in the hotseat
 675         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 676                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 677             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 678         } else {
 679             item.screenId = screenId;
 680         }
 681 
 682         final ContentValues values = new ContentValues();
 683         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 684         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 685         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 686         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 687 
 688         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 689     }
 690 
 691     /**
 692      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 693      * cellX, cellY have already been updated on the ItemInfos.
 694      */
 695     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 696             final long container, final int screen) {
 697 
 698         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 699         int count = items.size();
 700 
 701         for (int i = 0; i &lt; count; i++) {
 702             ItemInfo item = items.get(i);
 703             item.container = container;
 704 
 705             // We store hotseat items in canonical form which is this orientation invariant position
 706             // in the hotseat
 707             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 708                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 709                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 710                         item.cellY);
 711             } else {
 712                 item.screenId = screen;
 713             }
 714 
 715             final ContentValues values = new ContentValues();
 716             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 717             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 718             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 719             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 720 
 721             contentValues.add(values);
 722         }
 723         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 724     }
 725 
 726     /**
 727      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 728      */
 729     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 730             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 731         item.container = container;
 732         item.cellX = cellX;
 733         item.cellY = cellY;
 734         item.spanX = spanX;
 735         item.spanY = spanY;
 736 
 737         // We store hotseat items in canonical form which is this orientation invariant position
 738         // in the hotseat
 739         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 740                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 741             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 742         } else {
 743             item.screenId = screenId;
 744         }
 745 
 746         final ContentValues values = new ContentValues();
 747         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 748         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 749         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 750         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 751         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 752         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 753 
 754         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 755     }
 756 
 757     /**
 758      * Update an item to the database in a specified container.
 759      */
 760     static void updateItemInDatabase(Context context, final ItemInfo item) {
 761         final ContentValues values = new ContentValues();
 762         item.onAddToDatabase(values);
 763         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 764         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 765     }
 766 
 767     /**
 768      * Returns true if the shortcuts already exists in the database.
 769      * we identify a shortcut by its title and intent.
 770      */
 771     static boolean shortcutExists(Context context, String title, Intent intent) {
 772         final ContentResolver cr = context.getContentResolver();
 773         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 774             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 775             new String[] { title, intent.toUri(0) }, null);
 776         boolean result = false;
 777         try {
 778             result = c.moveToFirst();
 779         } finally {
 780             c.close();
 781         }
 782         return result;
 783     }
 784 
 785     /**
 786      * Returns an ItemInfo array containing all the items in the LauncherModel.
 787      * The ItemInfo.id is not set through this function.
 788      */
 789     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 790         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 791         final ContentResolver cr = context.getContentResolver();
 792         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 793                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 794                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 794                 LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.FavðŸ”µ</abbr>
 795                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 796 
 797         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 798         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 799         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 800         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 801         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 802         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 803         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 804 
 805         try {
 806             while (c.moveToNext()) {
 807                 ItemInfo item = new ItemInfo();
 808                 item.cellX = c.getInt(cellXIndex);
 809                 item.cellY = c.getInt(cellYIndex);
 810                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 811                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 812                 item.container = c.getInt(containerIndex);
 813                 item.itemType = c.getInt(itemTypeIndex);
 814                 item.screenId = c.getInt(screenIndex);
 815 
 816                 items.add(item);
 817             }
 818         } catch (Exception e) {
 819             items.clear();
 820         } finally {
 821             c.close();
 822         }
 823 
 824         return items;
 825     }
 826 
 827     /**
 828      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 829      */
 830     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 831         final ContentResolver cr = context.getContentResolver();
 832         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 833                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 834                 new String[] { String.valueOf(id),
 835                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 836 
 837         try {
 838             if (c.moveToFirst()) {
 839                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 840                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 841                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 842                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 843                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 844                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 845 
 846                 FolderInfo folderInfo = null;
 847                 switch (c.getInt(itemTypeIndex)) {
 848                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 849                         folderInfo = findOrMakeFolder(folderList, id);
 850                         break;
 851                 }
 852 
 853                 folderInfo.title = c.getString(titleIndex);
 854                 folderInfo.id = id;
 855                 folderInfo.container = c.getInt(containerIndex);
 856                 folderInfo.screenId = c.getInt(screenIndex);
 857                 folderInfo.cellX = c.getInt(cellXIndex);
 858                 folderInfo.cellY = c.getInt(cellYIndex);
 859 
 860                 return folderInfo;
 861             }
 862         } finally {
 863             c.close();
 864         }
 865 
 866         return null;
 867     }
 868 
 869     /**
 870      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 871      * cellY fields of the item. Also assigns an ID to the item.
 872      */
 873     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 874             final long screenId, final int cellX, final int cellY, final boolean notify) {
 875         item.container = container;
 876         item.cellX = cellX;
 877         item.cellY = cellY;
 878         // We store hotseat items in canonical form which is this orientation invariant position
 879         // in the hotseat
 880         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 881                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 882             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 883         } else {
 884             item.screenId = screenId;
 885         }
 886 
 887         final ContentValues values = new ContentValues();
 888         final ContentResolver cr = context.getContentResolver();
 889         item.onAddToDatabase(values);
 890 
 891         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 892         values.put(LauncherSettings.Favorites._ID, item.id);
 893         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 894 
 895         Runnable r = new Runnable() {
 896             public void run() {
 897                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 898                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 899 
 900                 // Lock on mBgLock *after* the db operation
 901                 synchronized (sBgLock) {
 902                     checkItemInfoLocked(item.id, item, null);
 903                     sBgItemsIdMap.put(item.id, item);
 904                     switch (item.itemType) {
 905                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 906                             sBgFolders.put(item.id, (FolderInfo) item);
 907                             // Fall through
 908                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 909                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 910                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 911                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 912                                 sBgWorkspaceItems.add(item);
 913                             } else {
 914                                 if (!sBgFolders.containsKey(item.container)) {
 915                                     // Adding an item to a folder that doesn&#x27;t exist.
 916                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 917                                             &quot; doesn&#x27;t exist&quot;;
 918                                     Log.e(TAG, msg);
 919                                 }
 920                             }
 921                             break;
 922                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 923                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 924                             break;
 925                     }
 926                 }
 927             }
 928         };
 929         runOnWorkerThread(r);
 930     }
 931 
 932     /**
 933      * Creates a new unique child id, for a given cell span across all layouts.
 934      */
 935     static int getCellLayoutChildId(
 936             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
 937         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 938                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 939     }
 940 
 941     /**
 942      * Removes the specified item from the database
 943      * @param context
 944      * @param item
 945      */
 946     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
 947         final ContentResolver cr = context.getContentResolver();
 948         final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
 949 
 950         Runnable r = new Runnable() {
 951             public void run() {
 952                 cr.delete(uriToDelete, null, null);
 953 
 954                 // Lock on mBgLock *after* the db operation
 955                 synchronized (sBgLock) {
 956                     switch (item.itemType) {
 957                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 958                             sBgFolders.remove(item.id);
 959                             for (ItemInfo info: sBgItemsIdMap.values()) {
 960                                 if (info.container == item.id) {
 961                                     // We are deleting a folder which still contains items that
 962                                     // think they are contained by that folder.
 963                                     String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
 964                                             &quot;contains items (&quot; + info + &quot;)&quot;;
 965                                     Log.e(TAG, msg);
 966                                 }
 967                             }
 968                             sBgWorkspaceItems.remove(item);
 969                             break;
 970                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 971                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 972                             sBgWorkspaceItems.remove(item);
 973                             break;
 974                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 975                             sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
 976                             break;
 977                     }
 978                     sBgItemsIdMap.remove(item.id);
 979                     sBgDbIconCache.remove(item);
 980                 }
 981             }
 982         };
 983         runOnWorkerThread(r);
 984     }
 985 
 986     /**
 987      * Update the order of the workspace screens in the database. The array list contains
 988      * a list of screen ids in the order that they should appear.
 989      */
 990     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
 991         // Log to disk
 992         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
 993         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
 994 
 995         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
 996         final ContentResolver cr = context.getContentResolver();
 997         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
 998 
 999         // Remove any negative screen ids -- these aren&#x27;t persisted
1000         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1001         while (iter.hasNext()) {
1002             long id = iter.next();
1003             if (id &lt; 0) {
1004                 iter.remove();
1005             }
1006         }
1007 
1008         Runnable r = new Runnable() {
1009             @Override
1010             public void run() {
1011                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1012                 // Clear the table
1013                 ops.add(ContentProviderOperation.newDelete(uri).build());
1014                 int count = screensCopy.size();
1015                 for (int i = 0; i &lt; count; i++) {
1016                     ContentValues v = new ContentValues();
1017                     long screenId = screensCopy.get(i);
1018                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1019                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1020                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1021                 }
1022 
1023                 try {
1024                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1025                 } catch (Exception ex) {
1026                     throw new RuntimeException(ex);
1027                 }
1028 
1029                 synchronized (sBgLock) {
1030                     sBgWorkspaceScreens.clear();
1031                     sBgWorkspaceScreens.addAll(screensCopy);
1032                 }
1033             }
1034         };
1035         runOnWorkerThread(r);
1036     }
1037 
1038     /**
1039      * Remove the contents of the specified folder from the database
1040      */
1041     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1042         final ContentResolver cr = context.getContentResolver();
1043 
1044         Runnable r = new Runnable() {
1045             public void run() {
1046                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1047                 // Lock on mBgLock *after* the db operation
1048                 synchronized (sBgLock) {
1049                     sBgItemsIdMap.remove(info.id);
1050                     sBgFolders.remove(info.id);
1051                     sBgDbIconCache.remove(info);
1052                     sBgWorkspaceItems.remove(info);
1053                 }
1054 
1055                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1056                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1057                 // Lock on mBgLock *after* the db operation
1058                 synchronized (sBgLock) {
1059                     for (ItemInfo childInfo : info.contents) {
1060                         sBgItemsIdMap.remove(childInfo.id);
1061                         sBgDbIconCache.remove(childInfo);
1062                     }
1063                 }
1064             }
1065         };
1066         runOnWorkerThread(r);
1067     }
1068 
1069     /**
1070      * Set this as the current Launcher activity object for the loader.
1071      */
1072     public void initialize(Callbacks callbacks) {
1073         synchronized (mLock) {
1074             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1075         }
1076     }
1077 
1078     /**
1079      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1080      * ACTION_PACKAGE_CHANGED.
1081      */
1082     @Override
1083     public void onReceive(Context context, Intent intent) {
1084         if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1085 
1086         final String action = intent.getAction();
1087 
1088         if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1089                 || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1090                 || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1091             final String packageName = intent.getData().getSchemeSpecificPart();
1092             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1093 
1094             int op = PackageUpdatedTask.OP_NONE;
1095 
1096             if (packageName == null || packageName.length() == 0) {
1097                 // they sent us a bad intent
1098                 return;
1099             }
1100 
1101             if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1102                 op = PackageUpdatedTask.OP_UPDATE;
1103             } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1104                 if (!replacing) {
1105                     op = PackageUpdatedTask.OP_REMOVE;
1106                 }
1107                 // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1108                 // later, we will update the package at this time
1109             } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1110                 if (!replacing) {
1111                     op = PackageUpdatedTask.OP_ADD;
1112                 } else {
1113                     op = PackageUpdatedTask.OP_UPDATE;
1114                 }
1115             }
1116 
1117             if (op != PackageUpdatedTask.OP_NONE) {
1118                 enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1119             }
1120 
1121         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1122             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1123             String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1124             if (!replacing) {
1125                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1126                 if (mAppsCanBeOnRemoveableStorage) {
1127                     // Only rebind if we support removable storage.  It catches the case where
1128                     // apps on the external sd card need to be reloaded
1129                     startLoaderFromBackground();
1130                 }
1131             } else {
1132                 // If we are replacing then just update the packages in the list
1133                 enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1134                         packages));
1135             }
1136         } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1137             final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1138             if (!replacing) {
1139                 String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1140                 enqueuePackageUpdated(new PackageUpdatedTask(
1141                             PackageUpdatedTask.OP_UNAVAILABLE, packages));
1142             }
1143             // else, we are replacing the packages, so ignore this event and wait for
1144             // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time
1145         } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1146             // If we have changed locale we need to clear out the labels in all apps/workspace.
1147             forceReload();
1148         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1149              // Check if configuration change was an mcc/mnc change which would affect app resources
1150              // and we would need to clear out the labels in all apps/workspace. Same handling as
1151              // above for ACTION_LOCALE_CHANGED
1152              Configuration currentConfig = context.getResources().getConfiguration();
1153              if (mPreviousConfigMcc != currentConfig.mcc) {
1154                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1155                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1156                    forceReload();
1157              }
1158              // Update previousConfig
1159              mPreviousConfigMcc = currentConfig.mcc;
1160         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1161                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1162             if (mCallbacks != null) {
1163                 Callbacks callbacks = mCallbacks.get();
1164                 if (callbacks != null) {
1165                     callbacks.bindSearchablesChanged();
1166                 }
1167             }
1168         }
1169     }
1170 
1171     private void forceReload() {
1172         resetLoadedState(true, true);
1173 
1174         // Do this here because if the launcher activity is running it will be restarted.
1175         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1176         // to reload.
1177         startLoaderFromBackground();
1178     }
1179 
1180     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1181         synchronized (mLock) {
1182             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1183             // mWorkspaceLoaded to true later
1184             stopLoaderLocked();
1185             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1186             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1187         }
1188     }
1189 
1190     /**
1191      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1192      * configuration changes.  So whenever we trigger the loader from the background
1193      * tell the launcher that it needs to re-run the loader when it comes back instead
1194      * of doing it now.
1195      */
1196     public void startLoaderFromBackground() {
1197         boolean runLoader = false;
1198         if (mCallbacks != null) {
1199             Callbacks callbacks = mCallbacks.get();
1200             if (callbacks != null) {
1201                 // Only actually run the loader if they&#x27;re not paused.
1202                 if (!callbacks.setLoadOnResume()) {
1203                     runLoader = true;
1204                 }
1205             }
1206         }
1207         if (runLoader) {
1208             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1209         }
1210     }
1211 
1212     // If there is already a loader task running, tell it to stop.
1213     // returns true if isLaunching() was true on the old task
1214     private boolean stopLoaderLocked() {
1215         boolean isLaunching = false;
1216         LoaderTask oldTask = mLoaderTask;
1217         if (oldTask != null) {
1218             if (oldTask.isLaunching()) {
1219                 isLaunching = true;
1220             }
1221             oldTask.stopLocked();
1222         }
1223         return isLaunching;
1224     }
1225 
1226     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1227         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1228     }
1229 
1230     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1231         synchronized (mLock) {
1232             if (DEBUG_LOADERS) {
1233                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1234             }
1235 
1236             // Clear any deferred bind-runnables from the synchronized load process
1237             // We must do this before any loading/binding is scheduled below.
1238             mDeferredBindRunnables.clear();
1239 
1240             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1241             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1242                 // If there is already one running, tell it to stop.
1243                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1244                 isLaunching = isLaunching || stopLoaderLocked();
1245                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1246                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1247                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1248                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1249                 } else {
1250                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1251                     sWorker.post(mLoaderTask);
1252                 }
1253             }
1254         }
1255     }
1256 
1257     void bindRemainingSynchronousPages() {
1258         // Post the remaining side pages to be loaded
1259         if (!mDeferredBindRunnables.isEmpty()) {
1260             for (final Runnable r : mDeferredBindRunnables) {
1261                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1262             }
1263             mDeferredBindRunnables.clear();
1264         }
1265     }
1266 
1267     public void stopLoader() {
1268         synchronized (mLock) {
1269             if (mLoaderTask != null) {
1270                 mLoaderTask.stopLocked();
1271             }
1272         }
1273     }
1274 
1275     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1276     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1277         final ContentResolver contentResolver = context.getContentResolver();
1278         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1279         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1280         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1281 
1282         try {
1283             final int idIndex = sc.getColumnIndexOrThrow(
1284                     LauncherSettings.WorkspaceScreens._ID);
1285             final int rankIndex = sc.getColumnIndexOrThrow(
1286                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1287             while (sc.moveToNext()) {
1288                 try {
1289                     long screenId = sc.getLong(idIndex);
1290                     int rank = sc.getInt(rankIndex);
1291                     orderedScreens.put(rank, screenId);
1292                 } catch (Exception e) {
<abbr title="1293                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1293                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1294                 }
1295             }
1296         } finally {
1297             sc.close();
1298         }
1299 
1300         // Log to disk
1301         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1302         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1303         for (Integer i : orderedScreens.keySet()) {
1304             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1305         }
1306         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1307                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1308         return orderedScreens;
1309     }
1310 
1311     public boolean isAllAppsLoaded() {
1312         return mAllAppsLoaded;
1313     }
1314 
1315     boolean isLoadingWorkspace() {
1316         synchronized (mLock) {
1317             if (mLoaderTask != null) {
1318                 return mLoaderTask.isLoadingWorkspace();
1319             }
1320         }
1321         return false;
1322     }
1323 
1324     /**
1325      * Runnable for the thread that loads the contents of the launcher:
1326      *   - workspace icons
1327      *   - widgets
1328      *   - all apps icons
1329      */
1330     private class LoaderTask implements Runnable {
1331         private Context mContext;
1332 
1333         private boolean mIsLaunching;
1334 
1335         private boolean mIsLoadingAndBindingWorkspace;
1336 
1337         private boolean mStopped;
1338 
1339         private boolean mLoadAndBindStepFinished;
1340 
1341         private int mFlags;
1342 
1343         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1344 
1345         LoaderTask(Context context, boolean isLaunching, int flags) {
1346             mContext = context;
1347             mIsLaunching = isLaunching;
1348             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1349             mFlags = flags;
1350         }
1351 
1352         boolean isLaunching() {
1353             return mIsLaunching;
1354         }
1355 
1356         boolean isLoadingWorkspace() {
1357             return mIsLoadingAndBindingWorkspace;
1358         }
1359 
1360         /** Returns whether this is an upgrade path */
1361         private boolean loadAndBindWorkspace() {
1362             mIsLoadingAndBindingWorkspace = true;
1363 
1364             // Load the workspace
1365             if (DEBUG_LOADERS) {
1366                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1367             }
1368 
1369             boolean isUpgradePath = false;
1370             if (!mWorkspaceLoaded) {
1371                 isUpgradePath = loadWorkspace();
1372                 synchronized (LoaderTask.this) {
1373                     if (mStopped) {
1374                         return isUpgradePath;
1375                     }
1376                     mWorkspaceLoaded = true;
1377                 }
1378             }
1379 
1380             // Bind the workspace
1381             bindWorkspace(-1, isUpgradePath);
1382             return isUpgradePath;
1383         }
1384 
1385         private void waitForIdle() {
1386             // Wait until the either we&#x27;re stopped or the other threads are done.
1387             // This way we don&#x27;t start loading all apps until the workspace has settled
1388             // down.
1389             synchronized (LoaderTask.this) {
1390                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1391 
1392                 mHandler.postIdle(new Runnable() {
1393                         public void run() {
1394                             synchronized (LoaderTask.this) {
1395                                 mLoadAndBindStepFinished = true;
1396                                 if (DEBUG_LOADERS) {
1397                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1398                                 }
1399                                 LoaderTask.this.notify();
1400                             }
1401                         }
1402                     });
1403 
1404                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1405                     try {
1406                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1407                         // wait no longer than 1sec at a time
1408                         this.wait(1000);
1409                     } catch (InterruptedException ex) {
1410                         // Ignore
1411                     }
1412                 }
1413                 if (DEBUG_LOADERS) {
1414                     Log.d(TAG, &quot;waited &quot;
1415                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1416                             + &quot;ms for previous step to finish binding&quot;);
1417                 }
1418             }
1419         }
1420 
1421         void runBindSynchronousPage(int synchronousBindPage) {
1422             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1423                 // Ensure that we have a valid page index to load synchronously
1424                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1425                         &quot;valid page index&quot;);
1426             }
1427             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1428                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1429                 // loaded already (we should load everything asynchronously in that case)
1430                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1431             }
1432             synchronized (mLock) {
1433                 if (mIsLoaderTaskRunning) {
1434                     // Ensure that we are never running the background loading at this point since
1435                     // we also touch the background collections
1436                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1437                 }
1438             }
1439 
1440             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1441             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1442             //      this call is synchronous, we can get away with not locking).
1443 
1444             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1445             // operations from the previous activity.  We need to ensure that all queued operations
1446             // are executed before any synchronous binding work is done.
1447             mHandler.flush();
1448 
1449             // Divide the set of loaded items into those that we are binding synchronously, and
1450             // everything else that is to be bound normally (asynchronously).
1451             bindWorkspace(synchronousBindPage, false);
1452             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1453             //      arise from that.
1454             onlyBindAllApps();
1455         }
1456 
1457         public void run() {
1458             boolean isUpgrade = false;
1459 
1460             synchronized (mLock) {
1461                 mIsLoaderTaskRunning = true;
1462             }
1463             // Optimize for end-user experience: if the Launcher is up and // running with the
1464             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1465             // workspace first (default).
1466             keep_running: {
1467                 // Elevate priority when Home launches for the first time to avoid
1468                 // starving at boot time. Staring at a blank home is not cool.
1469                 synchronized (mLock) {
1470                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1471                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1472                     android.os.Process.setThreadPriority(mIsLaunching
1473                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1474                 }
1475                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1476                 isUpgrade = loadAndBindWorkspace();
1477 
1478                 if (mStopped) {
1479                     break keep_running;
1480                 }
1481 
1482                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1483                 // settled down.
1484                 synchronized (mLock) {
1485                     if (mIsLaunching) {
1486                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1487                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1488                     }
1489                 }
1490                 waitForIdle();
1491 
1492                 // second step
1493                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1494                 loadAndBindAllApps();
1495 
1496                 // Restore the default thread priority after we are done loading items
1497                 synchronized (mLock) {
1498                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1499                 }
1500             }
1501 
1502             // Update the saved icons if necessary
1503             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1504             synchronized (sBgLock) {
1505                 for (Object key : sBgDbIconCache.keySet()) {
1506                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1507                 }
1508                 sBgDbIconCache.clear();
1509             }
1510 
1511             if (LauncherAppState.isDisableAllApps()) {
1512                 // Ensure that all the applications that are in the system are
1513                 // represented on the home screen.
1514                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1515                     verifyApplications();
1516                 }
1517             }
1518 
1519             // Clear out this reference, otherwise we end up holding it until all of the
1520             // callback runnables are done.
1521             mContext = null;
1522 
1523             synchronized (mLock) {
1524                 // If we are still the last one to be scheduled, remove ourselves.
1525                 if (mLoaderTask == this) {
1526                     mLoaderTask = null;
1527                 }
1528                 mIsLoaderTaskRunning = false;
1529             }
1530         }
1531 
1532         public void stopLocked() {
1533             synchronized (LoaderTask.this) {
1534                 mStopped = true;
1535                 this.notify();
1536             }
1537         }
1538 
1539         /**
1540          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1541          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1542          * object that was around when the deferred message was scheduled, and if there&#x27;s
1543          * a new Callbacks object around then also return null.  This will save us from
1544          * calling onto it with data that will be ignored.
1545          */
1546         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1547             synchronized (mLock) {
1548                 if (mStopped) {
1549                     return null;
1550                 }
1551 
1552                 if (mCallbacks == null) {
1553                     return null;
1554                 }
1555 
1556                 final Callbacks callbacks = mCallbacks.get();
1557                 if (callbacks != oldCallbacks) {
1558                     return null;
1559                 }
1560                 if (callbacks == null) {
1561                     Log.w(TAG, &quot;no mCallbacks&quot;);
1562                     return null;
1563                 }
1564 
1565                 return callbacks;
1566             }
1567         }
1568 
1569         private void verifyApplications() {
1570             final Context context = mApp.getContext();
1571             // Cross reference all the applications in our apps list with items in the workspace
1572             ArrayList&lt;ItemInfo&gt; tmpInfos;
1573             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1574             synchronized(sBgLock) {
1575                 for (AppInfo app : mBgAllAppsList.data) {
1576                     tmpInfos = getItemInfoForComponentName(app.componentName);
1577                     if (tmpInfos.isEmpty()) {
1578                         // We are missing an application icon, so add this to the workspace
1579                         added.add(app);
1580                         // This is a rare event, so lets log it
1581                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1582                     }
1583                 }
1584             }
1585             if (!added.isEmpty()) {
1586                 Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
1587                 addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());
1588             }
1589         }
1590 
1591         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1592         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1593                                            AtomicBoolean deleteOnInvalidPlacement) {
1594             LauncherAppState app = LauncherAppState.getInstance();
1595             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1596             final int countX = (int) grid.numColumns;
1597             final int countY = (int) grid.numRows;
1598 
1599             long containerIndex = item.screenId;
1600             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1601                 // Return early if we detect that an item is under the hotseat button
1602                 if (mCallbacks == null ||
1603                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1604                     deleteOnInvalidPlacement.set(true);
1605                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1606                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1607                             + item.cellY + &quot;) occupied by all apps&quot;);
1608                     return false;
1609                 }
1610 
1611                 final ItemInfo[][] hotseatItems =
1612                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1613 
1614                 if (item.screenId &gt;= grid.numHotseatIcons) {
1615                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1616                             + &quot; into hotseat position &quot; + item.screenId
1617                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1618                             + &quot;)&quot;);
1619                     return false;
1620                 }
1621 
1622                 if (hotseatItems != null) {
1623                     if (hotseatItems[(int) item.screenId][0] != null) {
1624                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1625                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1626                                 + item.cellY + &quot;) occupied by &quot;
1627                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1628                                 [(int) item.screenId][0]);
1629                             return false;
1630                     } else {
1631                         hotseatItems[(int) item.screenId][0] = item;
1632                         return true;
1633                     }
1634                 } else {
1635                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1636                     items[(int) item.screenId][0] = item;
1637                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1638                     return true;
1639                 }
1640             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1641                 // Skip further checking if it is not the hotseat or workspace container
1642                 return true;
1643             }
1644 
1645             if (!occupied.containsKey(item.screenId)) {
1646                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1647                 occupied.put(item.screenId, items);
1648             }
1649 
1650             final ItemInfo[][] screens = occupied.get(item.screenId);
1651             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1652                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1653                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1654                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1655                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1656                         + item.cellX + &quot;,&quot; + item.cellY
1657                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1658                 return false;
1659             }
1660 
1661             // Check if any workspace icons overlap with each other
1662             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1663                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1664                     if (screens[x][y] != null) {
1665                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1666                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1667                             + x + &quot;,&quot; + y
1668                             + &quot;) occupied by &quot;
1669                             + screens[x][y]);
1670                         return false;
1671                     }
1672                 }
1673             }
1674             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1675                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1676                     screens[x][y] = item;
1677                 }
1678             }
1679 
1680             return true;
1681         }
1682 
1683         /** Clears all the sBg data structures */
1684         private void clearSBgDataStructures() {
1685             synchronized (sBgLock) {
1686                 sBgWorkspaceItems.clear();
1687                 sBgAppWidgets.clear();
1688                 sBgFolders.clear();
1689                 sBgItemsIdMap.clear();
1690                 sBgDbIconCache.clear();
1691                 sBgWorkspaceScreens.clear();
1692             }
1693         }
1694 
1695         /** Returns whether this is an upgrade path */
1696         private boolean loadWorkspace() {
1697             // Log to disk
1698             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1699             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1700             final Context context = mContext;
1701             final ContentResolver contentResolver = context.getContentResolver();
1702             final PackageManager manager = context.getPackageManager();
1703             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1704             final boolean isSafeMode = manager.isSafeMode();
1705             LauncherAppState app = LauncherAppState.getInstance();
1706             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1707             int countX = ((int) (grid.numColumns));
1708             int countY = ((int) (grid.numRows));
1709             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1710                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1711                 LauncherAppState.getLauncherProvider().deleteDatabase();
1712             }
1713             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1714                 // append the user&#x27;s Launcher2 shortcuts
1715                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1716                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1717             } else {
1718                 // Make sure the default workspace is loaded
1719                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1720                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);
1721             }
1722             // Check if we need to do any upgrade-path logic
1723             // (Includes having just imported default favorites)
1724             boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();
1725             // Log to disk
1726             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1727             synchronized(sBgLock) {
1728                 clearSBgDataStructures();
1729                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1730                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1731                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1732                 if (DEBUG_LOADERS) {
1733                     Log.d(TAG, &quot;loading model from &quot; + contentUri);
1734                 }
1735                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1736                 // +1 for the hotseat (it can be larger than the workspace)
1737                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1738                 // before any earlier duplicates)
1739                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1740                 try {
1741                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1742                     final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1743                     final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1744                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);">1744                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPðŸ”µ</abbr>
1745                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title="1746                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);">1746                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_ðŸ”µ</abbr>
<abbr title="1747                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);">1747                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICONðŸ”µ</abbr>
<abbr title="1748                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1748                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINðŸ”µ</abbr>
<abbr title="1749                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1749                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPðŸ”µ</abbr>
<abbr title="1750                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_ID);">1750                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIðŸ”µ</abbr>
<abbr title="1751                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_PROVIDER);">1751                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.FavoritesðŸ”µ</abbr>
1752                     final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1753                     final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1754                     final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1755                     final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1756                     final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<abbr title="1757                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED);">1757                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTOREDðŸ”µ</abbr>
1758                     // final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1759                     // final int displayModeIndex = c.getColumnIndexOrThrow(
1760                     // LauncherSettings.Favorites.DISPLAY_MODE);
1761                     ShortcutInfo info;
1762                     String intentDescription;
1763                     LauncherAppWidgetInfo appWidgetInfo;
1764                     int container;
1765                     long id;
1766                     Intent intent;
1767                     while ((!mStopped) &amp;&amp; c.moveToNext()) {
1768                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1769                         try {
1770                             int itemType = c.getInt(itemTypeIndex);
1771                             boolean restored = 0 != c.getInt(restoredIndex);
1772                             switch (itemType) {
1773                                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1774                                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1775                                     id = c.getLong(idIndex);
1776                                     intentDescription = c.getString(intentIndex);
1777                                     try {
1778                                         intent = Intent.parseUri(intentDescription, 0);
1779                                         ComponentName cn = intent.getComponent();
1780                                         if ((cn != null) &amp;&amp; (!isValidPackageComponent(manager, cn))) {
1781                                             if (restored) {
1782                                                 // might be installed later
<abbr title="1783                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cn, true);">1783                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cðŸ”µ</abbr>
1784                                             } else {
1785                                                 if (!mAppsCanBeOnRemoveableStorage) {
1786                                                     // Log the invalid package, and remove it
<abbr title="1787                                                     Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn, true);">1787                                                     Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; ðŸ”µ</abbr>
1788                                                     itemsToRemove.add(id);
1789                                                 } else {
1790                                                     // If apps can be on external storage, then we just
1791                                                     // leave them for the user to remove (maybe add
1792                                                     // visual treatment to it)
<abbr title="1793                                                     Launcher.addDumpLog(TAG, &quot;Invalid package found: &quot; + cn, true);">1793                                                     Launcher.addDumpLog(TAG, &quot;Invalid package found: &quot; + ðŸ”µ</abbr>
1794                                                 }
1795                                                 continue;
1796                                             }
1797                                         } else if (restored) {
1798                                             // no special handling necessary for this restored item
1799                                             restoredRows.add(id);
1800                                             restored = false;
1801                                         }
1802                                     } catch (URISyntaxException e) {
<abbr title="1803                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, true);">1803                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, truðŸ”µ</abbr>
1804                                         continue;
1805                                     }
1806                                     if (restored) {
<abbr title="1807                                         Launcher.addDumpLog(TAG, &quot;constructing info for partially restored package&quot;, true);">1807                                         Launcher.addDumpLog(TAG, &quot;constructing info for partially restoreðŸ”µ</abbr>
1808                                         info = getRestoredItemInfo(c, titleIndex);
1809                                         intent = getRestoredItemIntent(c, context, intent);
<abbr title="1810                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">1810                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATIðŸ”µ</abbr>
<abbr title="1811                                         info = getShortcutInfo(manager, intent, context, c, iconIndex, titleIndex, mLabelCache);">1811                                         info = getShortcutInfo(manager, intent, context, c, iconIndex, tiðŸ”µ</abbr>
1812                                     } else {
<abbr title="1813                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndex, iconResourceIndex, iconIndex, titleIndex);">1813                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndeðŸ”µ</abbr>
1814                                         // App shortcuts that used to be automatically added to Launcher
1815                                         // didn&#x27;t always have the correct intent flags set, so do that
1816                                         // here
<abbr title="1817                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != null)) &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN)) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {">1817                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != ðŸ”µ</abbr>
<abbr title="1818                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">1818                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_AðŸ”µ</abbr>
1819                                         }
1820                                     }
1821                                     if (info != null) {
1822                                         info.id = id;
1823                                         info.intent = intent;
1824                                         container = c.getInt(containerIndex);
1825                                         info.container = container;
1826                                         info.screenId = c.getInt(screenIndex);
1827                                         info.cellX = c.getInt(cellXIndex);
1828                                         info.cellY = c.getInt(cellYIndex);
1829                                         info.spanX = 1;
1830                                         info.spanY = 1;
1831                                         // check &amp; update map of what&#x27;s occupied
1832                                         deleteOnInvalidPlacement.set(false);
<abbr title="1833                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {">1833                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)ðŸ”µ</abbr>
1834                                             if (deleteOnInvalidPlacement.get()) {
1835                                                 itemsToRemove.add(id);
1836                                             }
1837                                             break;
1838                                         }
1839                                         switch (container) {
1840                                             case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1841                                             case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1842                                                 sBgWorkspaceItems.add(info);
1843                                                 break;
1844                                             default :
1845                                                 // Item is in a user folder
<abbr title="1846                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, container);">1846                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, contðŸ”µ</abbr>
1847                                                 folderInfo.add(info);
1848                                                 break;
1849                                         }
1850                                         sBgItemsIdMap.put(info.id, info);
1851                                         // now that we&#x27;ve loaded everthing re-save it with the
1852                                         // icon in case it disappears somehow.
1853                                         queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1854                                     } else {
1855                                         throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1856                                     }
1857                                     break;
1858                                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1859                                     id = c.getLong(idIndex);
1860                                     FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1861                                     folderInfo.title = c.getString(titleIndex);
1862                                     folderInfo.id = id;
1863                                     container = c.getInt(containerIndex);
1864                                     folderInfo.container = container;
1865                                     folderInfo.screenId = c.getInt(screenIndex);
1866                                     folderInfo.cellX = c.getInt(cellXIndex);
1867                                     folderInfo.cellY = c.getInt(cellYIndex);
1868                                     folderInfo.spanX = 1;
1869                                     folderInfo.spanY = 1;
1870                                     // check &amp; update map of what&#x27;s occupied
1871                                     deleteOnInvalidPlacement.set(false);
<abbr title="1872                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacement)) {">1872                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacemenðŸ”µ</abbr>
1873                                         if (deleteOnInvalidPlacement.get()) {
1874                                             itemsToRemove.add(id);
1875                                         }
1876                                         break;
1877                                     }
1878                                     switch (container) {
1879                                         case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1880                                         case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1881                                             sBgWorkspaceItems.add(folderInfo);
1882                                             break;
1883                                     }
1884                                     if (restored) {
1885                                         // no special handling required for restored folders
1886                                         restoredRows.add(id);
1887                                     }
1888                                     sBgItemsIdMap.put(folderInfo.id, folderInfo);
1889                                     sBgFolders.put(folderInfo.id, folderInfo);
1890                                     break;
1891                                 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1892                                     // Read all Launcher-specific widget details
1893                                     int appWidgetId = c.getInt(appWidgetIdIndex);
1894                                     String savedProvider = c.getString(appWidgetProviderIndex);
1895                                     id = c.getLong(idIndex);
<abbr title="1896                                     final AppWidgetProviderInfo provider = widgets.getAppWidgetInfo(appWidgetId);">1896                                     final AppWidgetProviderInfo provider = widgets.getAppWidgetInfo(appWiðŸ”µ</abbr>
<abbr title="1897                                     if ((!isSafeMode) &amp;&amp; (((provider == null) || (provider.provider == null)) || (provider.provider.getPackageName() == null))) {">1897                                     if ((!isSafeMode) &amp;&amp; (((provider == null) || (provider.provider == nuðŸ”µ</abbr>
<abbr title="1898                                         String log = ((&quot;Deleting widget that isn&#x27;t installed anymore: id=&quot; + id) + &quot; appWidgetId=&quot;) + appWidgetId;">1898                                         String log = ((&quot;Deleting widget that isn&#x27;t installed anymore: id=ðŸ”µ</abbr>
1899                                         Log.e(TAG, log);
1900                                         Launcher.addDumpLog(TAG, log, false);
1901                                         itemsToRemove.add(id);
1902                                     } else {
<abbr title="1903                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider);">1903                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.pðŸ”µ</abbr>
1904                                         appWidgetInfo.id = id;
1905                                         appWidgetInfo.screenId = c.getInt(screenIndex);
1906                                         appWidgetInfo.cellX = c.getInt(cellXIndex);
1907                                         appWidgetInfo.cellY = c.getInt(cellYIndex);
1908                                         appWidgetInfo.spanX = c.getInt(spanXIndex);
1909                                         appWidgetInfo.spanY = c.getInt(spanYIndex);
1910                                         int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
1911                                         appWidgetInfo.minSpanX = minSpan[0];
1912                                         appWidgetInfo.minSpanY = minSpan[1];
1913                                         container = c.getInt(containerIndex);
<abbr title="1914                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {">1914                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;ðŸ”µ</abbr>
<abbr title="1915                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);">1915                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DEðŸ”µ</abbr>
1916                                             continue;
1917                                         }
1918                                         appWidgetInfo.container = c.getInt(containerIndex);
1919                                         // check &amp; update map of what&#x27;s occupied
1920                                         deleteOnInvalidPlacement.set(false);
<abbr title="1921                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPlacement)) {">1921                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPðŸ”µ</abbr>
1922                                             if (deleteOnInvalidPlacement.get()) {
1923                                                 itemsToRemove.add(id);
1924                                             }
1925                                             break;
1926                                         }
1927                                         String providerName = provider.provider.flattenToString();
1928                                         if (!providerName.equals(savedProvider)) {
1929                                             ContentValues values = new ContentValues();
<abbr title="1930                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, providerName);">1930                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, proðŸ”µ</abbr>
1931                                             String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="1932                                             String[] args = new java.lang.String[]{ Integer.toString(c.getInt(idIndex)) };">1932                                             String[] args = new java.lang.String[]{ Integer.toString(c.geðŸ”µ</abbr>
1933                                             contentResolver.update(contentUri, values, where, args);
1934                                         }
1935                                         sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
1936                                         sBgAppWidgets.add(appWidgetInfo);
1937                                     }
1938                                     break;
1939                             }
1940                         } catch (java.lang.Exception e) {
1941                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
1942                         }
1943                     }
1944                 } finally {
1945                     if (c != null) {
1946                         c.close();
1947                     }
1948                 }
1949                 // Break early if we&#x27;ve stopped loading
1950                 if (mStopped) {
1951                     clearSBgDataStructures();
1952                     return false;
1953                 }
1954                 if (itemsToRemove.size() &gt; 0) {
<abbr title="1955                     ContentProviderClient client = contentResolver.acquireContentProviderClient(LauncherSettings.Favorites.CONTENT_URI);">1955                     ContentProviderClient client = contentResolver.acquireContentProviderClient(LauncherSðŸ”µ</abbr>
1956                     // Remove dead items
1957                     for (long id : itemsToRemove) {
1958                         if (DEBUG_LOADERS) {
1959                             Log.d(TAG, &quot;Removed id = &quot; + id);
1960                         }
1961                         // Don&#x27;t notify content observers
1962                         try {
<abbr title="1963                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null);">1963                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, nullðŸ”µ</abbr>
1964                         } catch (RemoteException e) {
1965                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
1966                         }
1967                     }
1968                 }
1969                 if (restoredRows.size() &gt; 0) {
<abbr title="1970                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(LauncherSettings.Favorites.CONTENT_URI);">1970                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(LauncherðŸ”µ</abbr>
1971                     // Update restored items that no longer require special handling
1972                     try {
1973                         StringBuilder selectionBuilder = new StringBuilder();
1974                         selectionBuilder.append(LauncherSettings.Favorites._ID);
1975                         selectionBuilder.append(&quot; IN (&quot;);
1976                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
1977                         selectionBuilder.append(&quot;)&quot;);
1978                         ContentValues values = new ContentValues();
1979                         values.put(LauncherSettings.Favorites.RESTORED, 0);
<abbr title="1980                         updater.update(LauncherSettings.Favorites.CONTENT_URI, values, selectionBuilder.toString(), null);">1980                         updater.update(LauncherSettings.Favorites.CONTENT_URI, values, selectionBuilder.tðŸ”µ</abbr>
1981                     } catch (RemoteException e) {
1982                         Log.w(TAG, &quot;Could not update restored rows&quot;);
1983                     }
1984                 }
1985                 if (loadedOldDb) {
1986                     long maxScreenId = 0;
1987                     // If we&#x27;re importing we use the old screen order.
1988                     for (ItemInfo item : sBgItemsIdMap.values()) {
1989                         long screenId = item.screenId;
<abbr title="1990                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkspaceScreens.contains(screenId))) {">1990                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkðŸ”µ</abbr>
1991                             sBgWorkspaceScreens.add(screenId);
1992                             if (screenId &gt; maxScreenId) {
1993                                 maxScreenId = screenId;
1994                             }
1995                         }
1996                     }
1997                     Collections.sort(sBgWorkspaceScreens);
1998                     // Log to disk
1999                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
<abbr title="2000                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2000                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, ðŸ”µ</abbr>
2001                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2002                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2003                     // Update the max item id after we load an old db
2004                     long maxItemId = 0;
2005                     // If we&#x27;re importing we use the old screen order.
2006                     for (ItemInfo item : sBgItemsIdMap.values()) {
2007                         maxItemId = Math.max(maxItemId, item.id);
2008                     }
2009                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2010                 } else {
2011                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2012                     for (Integer i : orderedScreens.keySet()) {
2013                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2014                     }
2015                     // Log to disk
<abbr title="2016                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2016                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, ðŸ”µ</abbr>
2017                     // Remove any empty screens
2018                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2019                     for (ItemInfo item : sBgItemsIdMap.values()) {
2020                         long screenId = item.screenId;
<abbr title="2021                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens.contains(screenId)) {">2021                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScrðŸ”µ</abbr>
2022                             unusedScreens.remove(screenId);
2023                         }
2024                     }
2025                     // If there are any empty screens remove them, and update.
2026                     if (unusedScreens.size() != 0) {
2027                         // Log to disk
<abbr title="2028                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtils.join(&quot;, &quot;, unusedScreens), true);">2028                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtiðŸ”µ</abbr>
2029                         sBgWorkspaceScreens.removeAll(unusedScreens);
2030                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2031                     }
2032                 }
2033                 if (DEBUG_LOADERS) {
2034                     Log.d(TAG, (&quot;loaded workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2035                     Log.d(TAG, &quot;workspace layout: &quot;);
2036                     int nScreens = occupied.size();
2037                     for (int y = 0; y &lt; countY; y++) {
2038                         String line = &quot;&quot;;
2039                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2040                         while (iter.hasNext()) {
2041                             long screenId = iter.next();
2042                             if (screenId &gt; 0) {
2043                                 line += &quot; | &quot;;
2044                             }
2045                             for (int x = 0; x &lt; countX; x++) {
2046                                 line += (occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2047                             }
2048                         }
2049                         Log.d(TAG, (&quot;[ &quot; + line) + &quot; ]&quot;);
2050                     }
2051                 }
2052             }
2053             return loadedOldDb;
2054         }
2055 
2056         /** Filters the set of items who are directly or indirectly (via another container) on the
2057          * specified screen. */
2058         private void filterCurrentWorkspaceItems(long currentScreenId,
2059                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2060                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2061                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2062             // Purge any null ItemInfos
2063             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2064             while (iter.hasNext()) {
2065                 ItemInfo i = iter.next();
2066                 if (i == null) {
2067                     iter.remove();
2068                 }
2069             }
2070 
2071             // Order the set of items by their containers first, this allows use to walk through the
2072             // list sequentially, build up a list of containers that are in the specified screen,
2073             // as well as all items in those containers.
2074             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2075             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2076                 @Override
2077                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2078                     return (int) (lhs.container - rhs.container);
2079                 }
2080             });
2081             for (ItemInfo info : allWorkspaceItems) {
2082                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2083                     if (info.screenId == currentScreenId) {
2084                         currentScreenItems.add(info);
2085                         itemsOnScreen.add(info.id);
2086                     } else {
2087                         otherScreenItems.add(info);
2088                     }
2089                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2090                     currentScreenItems.add(info);
2091                     itemsOnScreen.add(info.id);
2092                 } else {
2093                     if (itemsOnScreen.contains(info.container)) {
2094                         currentScreenItems.add(info);
2095                         itemsOnScreen.add(info.id);
2096                     } else {
2097                         otherScreenItems.add(info);
2098                     }
2099                 }
2100             }
2101         }
2102 
2103         /** Filters the set of widgets which are on the specified screen. */
2104         private void filterCurrentAppWidgets(long currentScreenId,
2105                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2106                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2107                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2108 
2109             for (LauncherAppWidgetInfo widget : appWidgets) {
2110                 if (widget == null) continue;
2111                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2112                         widget.screenId == currentScreenId) {
2113                     currentScreenWidgets.add(widget);
2114                 } else {
2115                     otherScreenWidgets.add(widget);
2116                 }
2117             }
2118         }
2119 
2120         /** Filters the set of folders which are on the specified screen. */
2121         private void filterCurrentFolders(long currentScreenId,
2122                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2123                 HashMap&lt;Long, FolderInfo&gt; folders,
2124                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2125                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2126 
2127             for (long id : folders.keySet()) {
2128                 ItemInfo info = itemsIdMap.get(id);
2129                 FolderInfo folder = folders.get(id);
2130                 if (info == null || folder == null) continue;
2131                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2132                         info.screenId == currentScreenId) {
2133                     currentScreenFolders.put(id, folder);
2134                 } else {
2135                     otherScreenFolders.put(id, folder);
2136                 }
2137             }
2138         }
2139 
2140         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2141          * right) */
2142         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2143             final LauncherAppState app = LauncherAppState.getInstance();
2144             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2145             // XXX: review this
2146             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2147                 @Override
2148                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2149                     int cellCountX = (int) grid.numColumns;
2150                     int cellCountY = (int) grid.numRows;
2151                     int screenOffset = cellCountX * cellCountY;
2152                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2153                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2154                             lhs.cellY * cellCountX + lhs.cellX);
2155                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2156                             rhs.cellY * cellCountX + rhs.cellX);
2157                     return (int) (lr - rr);
2158                 }
2159             });
2160         }
2161 
2162         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2163                 final ArrayList&lt;Long&gt; orderedScreens) {
2164             final Runnable r = new Runnable() {
2165                 @Override
2166                 public void run() {
2167                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2168                     if (callbacks != null) {
2169                         callbacks.bindScreens(orderedScreens);
2170                     }
2171                 }
2172             };
2173             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2174         }
2175 
2176         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2177                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2178                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2179                 final HashMap&lt;Long, FolderInfo&gt; folders,
2180                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2181 
2182             final boolean postOnMainThread = (deferredBindRunnables != null);
2183 
2184             // Bind the workspace items
2185             int N = workspaceItems.size();
2186             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2187                 final int start = i;
2188                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2189                 final Runnable r = new Runnable() {
2190                     @Override
2191                     public void run() {
2192                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2193                         if (callbacks != null) {
2194                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2195                                     false);
2196                         }
2197                     }
2198                 };
2199                 if (postOnMainThread) {
2200                     deferredBindRunnables.add(r);
2201                 } else {
2202                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2203                 }
2204             }
2205 
2206             // Bind the folders
2207             if (!folders.isEmpty()) {
2208                 final Runnable r = new Runnable() {
2209                     public void run() {
2210                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2211                         if (callbacks != null) {
2212                             callbacks.bindFolders(folders);
2213                         }
2214                     }
2215                 };
2216                 if (postOnMainThread) {
2217                     deferredBindRunnables.add(r);
2218                 } else {
2219                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2220                 }
2221             }
2222 
2223             // Bind the widgets, one at a time
2224             N = appWidgets.size();
2225             for (int i = 0; i &lt; N; i++) {
2226                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2227                 final Runnable r = new Runnable() {
2228                     public void run() {
2229                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2230                         if (callbacks != null) {
2231                             callbacks.bindAppWidget(widget);
2232                         }
2233                     }
2234                 };
2235                 if (postOnMainThread) {
2236                     deferredBindRunnables.add(r);
2237                 } else {
2238                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2239                 }
2240             }
2241         }
2242 
2243         /**
2244          * Binds all loaded data to actual views on the main thread.
2245          */
2246         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2247             final long t = SystemClock.uptimeMillis();
2248             Runnable r;
2249 
2250             // Don&#x27;t use these two variables in any of the callback runnables.
2251             // Otherwise we hold a reference to them.
2252             final Callbacks oldCallbacks = mCallbacks.get();
2253             if (oldCallbacks == null) {
2254                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2255                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2256                 return;
2257             }
2258 
2259             // Save a copy of all the bg-thread collections
2260             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2261             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2262                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2263             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2264             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2265             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2266             synchronized (sBgLock) {
2267                 workspaceItems.addAll(sBgWorkspaceItems);
2268                 appWidgets.addAll(sBgAppWidgets);
2269                 folders.putAll(sBgFolders);
2270                 itemsIdMap.putAll(sBgItemsIdMap);
2271                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2272             }
2273 
2274             final boolean isLoadingSynchronously =
2275                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2276             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2277                 oldCallbacks.getCurrentWorkspaceScreen();
2278             if (currScreen &gt;= orderedScreenIds.size()) {
2279                 // There may be no workspace screens (just hotseat items and an empty page).
2280                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2281             }
2282             final int currentScreen = currScreen;
2283             final long currentScreenId = currentScreen &lt; 0
2284                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2285 
2286             // Load all the items that are on the current page first (and in the process, unbind
2287             // all the existing workspace items before we call startBinding() below.
2288             unbindWorkspaceItemsOnMainThread();
2289 
2290             // Separate the items that are on the current screen, and all the other remaining items
2291             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2292             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2293             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2294                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2295             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2296                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2297             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2298             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2299 
2300             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2301                     otherWorkspaceItems);
2302             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2303                     otherAppWidgets);
2304             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2305                     otherFolders);
2306             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2307             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2308 
2309             // Tell the workspace that we&#x27;re about to start binding items
2310             r = new Runnable() {
2311                 public void run() {
2312                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2313                     if (callbacks != null) {
2314                         callbacks.startBinding();
2315                     }
2316                 }
2317             };
2318             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2319 
2320             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2321 
2322             // Load items on the current page
2323             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2324                     currentFolders, null);
2325             if (isLoadingSynchronously) {
2326                 r = new Runnable() {
2327                     public void run() {
2328                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2329                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2330                             callbacks.onPageBoundSynchronously(currentScreen);
2331                         }
2332                     }
2333                 };
2334                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2335             }
2336 
2337             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2338             // work until after the first render)
2339             mDeferredBindRunnables.clear();
2340             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2341                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2342 
2343             // Tell the workspace that we&#x27;re done binding items
2344             r = new Runnable() {
2345                 public void run() {
2346                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2347                     if (callbacks != null) {
2348                         callbacks.finishBindingItems(isUpgradePath);
2349                     }
2350 
2351                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2352                     if (DEBUG_LOADERS) {
2353                         Log.d(TAG, &quot;bound workspace in &quot;
2354                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2355                     }
2356 
2357                     mIsLoadingAndBindingWorkspace = false;
2358                 }
2359             };
2360             if (isLoadingSynchronously) {
2361                 mDeferredBindRunnables.add(r);
2362             } else {
2363                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2364             }
2365         }
2366 
2367         private void loadAndBindAllApps() {
2368             if (DEBUG_LOADERS) {
2369                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2370             }
2371             if (!mAllAppsLoaded) {
2372                 loadAllApps();
2373                 synchronized (LoaderTask.this) {
2374                     if (mStopped) {
2375                         return;
2376                     }
2377                     mAllAppsLoaded = true;
2378                 }
2379             } else {
2380                 onlyBindAllApps();
2381             }
2382         }
2383 
2384         private void onlyBindAllApps() {
2385             final Callbacks oldCallbacks = mCallbacks.get();
2386             if (oldCallbacks == null) {
2387                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2388                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2389                 return;
2390             }
2391 
2392             // shallow copy
2393             @SuppressWarnings(&quot;unchecked&quot;)
2394             final ArrayList&lt;AppInfo&gt; list
2395                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2396             Runnable r = new Runnable() {
2397                 public void run() {
2398                     final long t = SystemClock.uptimeMillis();
2399                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2400                     if (callbacks != null) {
2401                         callbacks.bindAllApplications(list);
2402                     }
2403                     if (DEBUG_LOADERS) {
2404                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2405                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2406                     }
2407                 }
2408             };
2409             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2410             if (isRunningOnMainThread) {
2411                 r.run();
2412             } else {
2413                 mHandler.post(r);
2414             }
2415         }
2416 
2417         private void loadAllApps() {
2418             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2419 
2420             final Callbacks oldCallbacks = mCallbacks.get();
2421             if (oldCallbacks == null) {
2422                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2423                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2424                 return;
2425             }
2426 
2427             final PackageManager packageManager = mContext.getPackageManager();
2428             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2429             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2430 
2431             // Clear the list of apps
2432             mBgAllAppsList.clear();
2433 
2434             // Query for the set of apps
2435             final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2436             List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);
2437             if (DEBUG_LOADERS) {
2438                 Log.d(TAG, &quot;queryIntentActivities took &quot;
2439                         + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2440                 Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);
2441             }
2442             // Fail if we don&#x27;t have any apps
2443             if (apps == null || apps.isEmpty()) {
2444                 return;
2445             }
2446             // Sort the applications by name
2447             final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2448             Collections.sort(apps,
2449                     new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2450             if (DEBUG_LOADERS) {
2451                 Log.d(TAG, &quot;sort took &quot;
2452                         + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2453             }
2454 
2455             // Create the ApplicationInfos
2456             for (int i = 0; i &lt; apps.size(); i++) {
2457                 ResolveInfo app = apps.get(i);
2458                 // This builds the icon bitmaps.
2459                 mBgAllAppsList.add(new AppInfo(packageManager, app,
2460                         mIconCache, mLabelCache));
2461             }
2462 
2463             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2464             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2465             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2466 
2467             // Post callback on main thread
2468             mHandler.post(new Runnable() {
2469                 public void run() {
2470                     final long bindTime = SystemClock.uptimeMillis();
2471                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2472                     if (callbacks != null) {
2473                         callbacks.bindAllApplications(added);
2474                         if (DEBUG_LOADERS) {
2475                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2476                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2477                         }
2478                     } else {
2479                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2480                     }
2481                 }
2482             });
2483 
2484             if (DEBUG_LOADERS) {
2485                 Log.d(TAG, &quot;Icons processed in &quot;
2486                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2487             }
2488         }
2489 
2490         public void dumpState() {
2491             synchronized (sBgLock) {
2492                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2493                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2494                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2495                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2496                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2497             }
2498         }
2499     }
2500 
2501     void enqueuePackageUpdated(PackageUpdatedTask task) {
2502         sWorker.post(task);
2503     }
2504 
2505     private class PackageUpdatedTask implements Runnable {
2506         int mOp;
2507 
2508         String[] mPackages;
2509 
2510         public static final int OP_NONE = 0;
2511 
2512         public static final int OP_ADD = 1;
2513 
2514         public static final int OP_UPDATE = 2;
2515 
2516         // uninstlled
2517         public static final int OP_REMOVE = 3; // uninstlled
2518 
2519         // external media unmounted
2520         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2521 
2522         public PackageUpdatedTask(int op, String[] packages) {
2523             mOp = op;
2524             mPackages = packages;
2525         }
2526 
2527         public void run() {
2528             final Context context = mApp.getContext();
2529             final String[] packages = mPackages;
2530             final int N = packages.length;
2531             switch (mOp) {
2532                 case OP_ADD :
2533                     for (int i = 0; i &lt; N; i++) {
2534                         if (DEBUG_LOADERS) {
2535                             Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2536                         }
2537                         mIconCache.remove(packages[i]);
2538                         mBgAllAppsList.addPackage(context, packages[i]);
2539                     }
2540                     break;
2541                 case OP_UPDATE :
2542                     for (int i = 0; i &lt; N; i++) {
2543                         if (DEBUG_LOADERS) {
2544                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2545                         }
2546                         mBgAllAppsList.updatePackage(context, packages[i]);
<abbr title="2547                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2547                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[ðŸ”µ</abbr>
2548                     }
2549                     break;
2550                 case OP_REMOVE :
2551                 case OP_UNAVAILABLE :
2552                     for (int i = 0; i &lt; N; i++) {
2553                         if (DEBUG_LOADERS) {
2554                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2555                         }
2556                         mBgAllAppsList.removePackage(packages[i]);
<abbr title="2557                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2557                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[ðŸ”µ</abbr>
2558                     }
2559                     break;
2560             }
2561             ArrayList&lt;AppInfo&gt; added = null;
2562             ArrayList&lt;AppInfo&gt; modified = null;
2563             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2564             if (mBgAllAppsList.added.size() &gt; 0) {
2565                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2566                 mBgAllAppsList.added.clear();
2567             }
2568             if (mBgAllAppsList.modified.size() &gt; 0) {
2569                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2570                 mBgAllAppsList.modified.clear();
2571             }
2572             if (mBgAllAppsList.removed.size() &gt; 0) {
2573                 removedApps.addAll(mBgAllAppsList.removed);
2574                 mBgAllAppsList.removed.clear();
2575             }
2576             final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
2577             if (callbacks == null) {
2578                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2579                 return;
2580             }
2581             if (added != null) {
2582                 // Ensure that we add all the workspace applications to the db
2583                 Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2584                 if (!LauncherAppState.isDisableAllApps()) {
2585                     addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);
2586                 } else {
2587                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2588                     addAndBindAddedApps(context, addedInfos, cb, added);
2589                 }
2590             }
2591             if (modified != null) {
2592                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2593                 // Update the launcher db to reflect the changes
2594                 for (AppInfo a : modifiedFinal) {
2595                     ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2596                     for (ItemInfo i : infos) {
2597                         if (isShortcutInfoUpdateable(i)) {
2598                             ShortcutInfo info = ((ShortcutInfo) (i));
2599                             info.title = a.title.toString();
2600                             updateItemInDatabase(context, info);
2601                         }
2602                     }
2603                 }
2604                 mHandler.post(new Runnable() {
2605                     public void run() {
2606                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2607                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2608                             callbacks.bindAppsUpdated(modifiedFinal);
2609                         }
2610                     }
2611                 });
2612             }
2613             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2614             if (mOp == OP_REMOVE) {
2615                 // Mark all packages in the broadcast to be removed
2616                 removedPackageNames.addAll(Arrays.asList(packages));
2617             } else if (mOp == OP_UPDATE) {
2618                 // Mark disabled packages in the broadcast to be removed
2619                 final PackageManager pm = context.getPackageManager();
2620                 for (int i = 0; i &lt; N; i++) {
2621                     if (isPackageDisabled(pm, packages[i])) {
2622                         removedPackageNames.add(packages[i]);
2623                     }
2624                 }
2625             }
2626             // Remove all the components associated with this package
2627             for (String pn : removedPackageNames) {
2628                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);
2629                 for (ItemInfo i : infos) {
2630                     deleteItemFromDatabase(context, i);
2631                 }
2632             }
2633             // Remove all the specific components
2634             for (AppInfo a : removedApps) {
2635                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2636                 for (ItemInfo i : infos) {
2637                     deleteItemFromDatabase(context, i);
2638                 }
2639             }
2640             if ((!removedPackageNames.isEmpty()) || (!removedApps.isEmpty())) {
2641                 // Remove any queued items from the install queue
2642                 String spKey = LauncherAppState.getSharedPreferencesKey();
2643                 SharedPreferences sp = context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2644                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2645                 // Call the components-removed callback
2646                 mHandler.post(new Runnable() {
2647                     public void run() {
2648                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2649                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2650                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps);
2651                         }
2652                     }
2653                 });
2654             }
2655             final ArrayList&lt;Object&gt; widgetsAndShortcuts = getSortedWidgetsAndShortcuts(context);
2656             mHandler.post(new Runnable() {
2657                 @Override
2658                 public void run() {
2659                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2660                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2661                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2662                     }
2663                 }
2664             });
2665             // Write all the logs to disk
2666             mHandler.post(new Runnable() {
2667                 public void run() {
2668                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2669                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2670                         callbacks.dumpLogsToLocalData();
2671                     }
2672                 }
2673             });
2674         }
2675     }
2676 
2677     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2678     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2679         PackageManager packageManager = context.getPackageManager();
2680         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2681         widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());
2682         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2683         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2684         Collections.sort(widgetsAndShortcuts,
2685             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));
2686         return widgetsAndShortcuts;
2687     }
2688 
2689     private static boolean isPackageDisabled(PackageManager pm, String packageName) {
2690         try {
2691             PackageInfo pi = pm.getPackageInfo(packageName, 0);
2692             return !pi.applicationInfo.enabled;
2693         } catch (NameNotFoundException e) {
2694             // Fall through
2695         }
2696         return false;
2697     }
2698 
2699     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {
2700         if (cn == null) {
2701             return false;
2702         }
2703         if (isPackageDisabled(pm, cn.getPackageName())) {
2704             return false;
2705         }
2706 
2707         try {
2708             // Check the activity
2709             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);
2710             return (pm.getActivityInfo(cn, 0) != null);
2711         } catch (NameNotFoundException e) {
2712             return false;
2713         }
2714     }
2715 
2716     /**
2717      * Make an ShortcutInfo object for a restored application or shortcut item that points
2718      * to a package that is not yet installed on the system.
2719      */
2720     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {
2721         final ShortcutInfo info = new ShortcutInfo();
2722         if (cursor != null) {
2723             info.title = cursor.getString(titleIndex);
2724         } else {
2725             info.title = &quot;&quot;;
2726         }
2727         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));
2728         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2729         return info;
2730     }
2731 
2732     /**
2733      * Make an Intent object for a restored application or shortcut item that points
2734      * to the market page for the item.
2735      */
2736     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2737         ComponentName componentName = intent.getComponent();
2738         Intent marketIntent = new Intent(Intent.ACTION_VIEW);
<abbr title="2739         Uri marketUri = new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;details&quot;).appendQueryParameter(&quot;id&quot;, componentName.getPackageName()).build();">2739         Uri marketUri = new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;details&quot;).appendQueryParameter(&quot;id&quot;ðŸ”µ</abbr>
2740         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());
2741         marketIntent.setData(marketUri);
2742         return marketIntent;
2743     }
2744 
2745     /**
2746      * This is called from the code that adds shortcuts from the intent receiver.  This
2747      * doesn&#x27;t have a Cursor, but
2748      */
2749     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2750         return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2751     }
2752 
2753     /**
2754      * Make an ShortcutInfo object for a shortcut that is an application.
2755      *
2756      * If c is not null, then it will be used to fill in missing data like the title and icon.
2757      */
2758     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2759             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2760         ComponentName componentName = intent.getComponent();
2761         final ShortcutInfo info = new ShortcutInfo();
2762         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {
2763             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);
2764             return null;
2765         } else {
2766             try {
2767                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2768                 info.initFlagsAndFirstInstallTime(pi);
2769             } catch (NameNotFoundException e) {
2770                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +
2771                         componentName.getPackageName());
2772             }
2773         }
2774 
2775         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2776         // then return null &amp; delete this.
2777 
2778         // the resource -- This may implicitly give us back the fallback icon,
2779         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2780         // to avoid saving lots of copies of that in the database, and most apps
2781         // have icons anyway.
2782 
2783         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2784         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2785         // via resolveActivity().
2786         Bitmap icon = null;
2787         ResolveInfo resolveInfo = null;
2788         ComponentName oldComponent = intent.getComponent();
2789         Intent newIntent = new Intent(intent.getAction(), null);
2790         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2791         newIntent.setPackage(oldComponent.getPackageName());
2792         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2793         for (ResolveInfo i : infos) {
2794             ComponentName cn = new ComponentName(i.activityInfo.packageName,
2795                     i.activityInfo.name);
2796             if (cn.equals(oldComponent)) {
2797                 resolveInfo = i;
2798             }
2799         }
2800         if (resolveInfo == null) {
2801             resolveInfo = manager.resolveActivity(intent, 0);
2802         }
2803         if (resolveInfo != null) {
2804             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2805         }
2806         // the db
2807         if (icon == null) {
2808             if (c != null) {
2809                 icon = getIconFromCursor(c, iconIndex, context);
2810             }
2811         }
2812         // the fallback icon
2813         if (icon == null) {
2814             icon = getFallbackIcon();
2815             info.usingFallbackIcon = true;
2816         }
2817         info.setIcon(icon);
2818 
2819         // from the resource
2820         if (resolveInfo != null) {
2821             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2822             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2823                 info.title = labelCache.get(key);
2824             } else {
2825                 info.title = resolveInfo.activityInfo.loadLabel(manager);
2826                 if (labelCache != null) {
2827                     labelCache.put(key, info.title);
2828                 }
2829             }
2830         }
2831         // from the db
2832         if (info.title == null) {
2833             if (c != null) {
2834                 info.title =  c.getString(titleIndex);
2835             }
2836         }
2837         // fall back to the class name of the activity
2838         if (info.title == null) {
2839             info.title = componentName.getClassName();
2840         }
2841         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2842         return info;
2843     }
2844 
2845     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
2846             ItemInfoFilter f) {
2847         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
2848         for (ItemInfo i : infos) {
2849             if (i instanceof ShortcutInfo) {
2850                 ShortcutInfo info = (ShortcutInfo) i;
2851                 ComponentName cn = info.intent.getComponent();
2852                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
2853                     filtered.add(info);
2854                 }
2855             } else if (i instanceof FolderInfo) {
2856                 FolderInfo info = (FolderInfo) i;
2857                 for (ShortcutInfo s : info.contents) {
2858                     ComponentName cn = s.intent.getComponent();
2859                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
2860                         filtered.add(s);
2861                     }
2862                 }
2863             } else if (i instanceof LauncherAppWidgetInfo) {
2864                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
2865                 ComponentName cn = info.providerName;
2866                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
2867                     filtered.add(info);
2868                 }
2869             }
2870         }
2871         return new ArrayList&lt;ItemInfo&gt;(filtered);
2872     }
2873 
2874     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {
2875         ItemInfoFilter filter  = new ItemInfoFilter() {
2876             @Override
2877             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
2878                 return cn.getPackageName().equals(pn);
2879             }
2880         };
2881         return filterItemInfos(sBgItemsIdMap.values(), filter);
2882     }
2883 
2884     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {
2885         ItemInfoFilter filter  = new ItemInfoFilter() {
2886             @Override
2887             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
2888                 return cn.equals(cname);
2889             }
2890         };
2891         return filterItemInfos(sBgItemsIdMap.values(), filter);
2892     }
2893 
2894     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
2895         if (i instanceof ShortcutInfo) {
2896             ShortcutInfo info = ((ShortcutInfo) (i));
2897             // We need to check for ACTION_MAIN otherwise getComponent() might
2898             // return null for some shortcuts (for instance, for shortcuts to
2899             // web pages.)
2900             Intent intent = info.intent;
2901             ComponentName name = intent.getComponent();
<abbr title="2902             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAIN.equals(intent.getAction())) &amp;&amp; (name != null)) {">2902             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAIðŸ”µ</abbr>
2903                 return true;
2904             }
2905         }
2906         return false;
2907     }
2908 
2909     /**
2910      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
2911      */
2912     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
2913             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
2914             int titleIndex) {
2915 
2916         Bitmap icon = null;
2917         final ShortcutInfo info = new ShortcutInfo();
2918         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2919 
2920         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
2921 
2922         info.title = c.getString(titleIndex);
2923 
2924         int iconType = c.getInt(iconTypeIndex);
2925         switch (iconType) {
2926         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
2927             String packageName = c.getString(iconPackageIndex);
2928             String resourceName = c.getString(iconResourceIndex);
2929             PackageManager packageManager = context.getPackageManager();
2930             info.customIcon = false;
2931             // the resource
2932             try {
2933                 Resources resources = packageManager.getResourcesForApplication(packageName);
2934                 if (resources != null) {
2935                     final int id = resources.getIdentifier(resourceName, null, null);
2936                     icon = Utilities.createIconBitmap(
2937                             mIconCache.getFullResIcon(resources, id), context);
2938                 }
2939             } catch (Exception e) {
2940                 // drop this.  we have other places to look for icons
2941             }
2942             // the db
2943             if (icon == null) {
2944                 icon = getIconFromCursor(c, iconIndex, context);
2945             }
2946             // the fallback icon
2947             if (icon == null) {
2948                 icon = getFallbackIcon();
2949                 info.usingFallbackIcon = true;
2950             }
2951             break;
2952         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
2953             icon = getIconFromCursor(c, iconIndex, context);
2954             if (icon == null) {
2955                 icon = getFallbackIcon();
2956                 info.customIcon = false;
2957                 info.usingFallbackIcon = true;
2958             } else {
2959                 info.customIcon = true;
2960             }
2961             break;
2962         default:
2963             icon = getFallbackIcon();
2964             info.usingFallbackIcon = true;
2965             info.customIcon = false;
2966             break;
2967         }
2968         info.setIcon(icon);
2969         return info;
2970     }
2971 
2972     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
2973         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
2974         final boolean debug = false;
2975         if (debug) {
2976             Log.d(TAG, &quot;getIconFromCursor app=&quot;
2977                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
2978         }
2979         byte[] data = c.getBlob(iconIndex);
2980         try {
2981             return Utilities.createIconBitmap(
2982                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
2983         } catch (Exception e) {
2984             return null;
2985         }
2986     }
2987 
2988     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
2989             int cellX, int cellY, boolean notify) {
2990         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
2991         if (info == null) {
2992             return null;
2993         }
2994         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
2995 
2996         return info;
2997     }
2998 
2999     /**
3000      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3001      */
3002     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3003             ComponentName component) {
3004         List&lt;AppWidgetProviderInfo&gt; widgets =
3005             AppWidgetManager.getInstance(context).getInstalledProviders();
3006         for (AppWidgetProviderInfo info : widgets) {
3007             if (info.provider.equals(component)) {
3008                 return info;
3009             }
3010         }
3011         return null;
3012     }
3013 
3014     /**
3015      * Returns a list of all the widgets that can handle configuration with a particular mimeType.
3016      */
3017     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
3018         final PackageManager packageManager = context.getPackageManager();
3019         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
3020             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
3021 
3022         final Intent supportsIntent =
3023             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
3024         supportsIntent.setType(mimeType);
3025 
3026         // Create a set of widget configuration components that we can test against
3027         final List&lt;AppWidgetProviderInfo&gt; widgets =
3028             AppWidgetManager.getInstance(context).getInstalledProviders();
3029         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
3030             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
3031         for (AppWidgetProviderInfo info : widgets) {
3032             configurationComponentToWidget.put(info.configure, info);
3033         }
3034 
3035         // Run through each of the intents that can handle this type of clip data, and cross
3036         // reference them with the components that are actual configuration components
3037         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
3038                 PackageManager.MATCH_DEFAULT_ONLY);
3039         for (ResolveInfo info : activities) {
3040             final ActivityInfo activityInfo = info.activityInfo;
3041             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
3042                     activityInfo.name);
3043             if (configurationComponentToWidget.containsKey(infoComponent)) {
3044                 supportedConfigurationActivities.add(
3045                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
3046                                 configurationComponentToWidget.get(infoComponent)));
3047             }
3048         }
3049         return supportedConfigurationActivities;
3050     }
3051 
3052     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3053         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3054         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3055         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3056 
3057         if (intent == null) {
3058             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3059             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3060             return null;
3061         }
3062 
3063         Bitmap icon = null;
3064         boolean customIcon = false;
3065         ShortcutIconResource iconResource = null;
3066 
3067         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3068             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3069             customIcon = true;
3070         } else {
3071             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3072             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3073                 try {
3074                     iconResource = (ShortcutIconResource) extra;
3075                     final PackageManager packageManager = context.getPackageManager();
3076                     Resources resources = packageManager.getResourcesForApplication(
3077                             iconResource.packageName);
3078                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3079                     icon = Utilities.createIconBitmap(
3080                             mIconCache.getFullResIcon(resources, id), context);
3081                 } catch (Exception e) {
3082                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3083                 }
3084             }
3085         }
3086 
3087         final ShortcutInfo info = new ShortcutInfo();
3088 
3089         if (icon == null) {
3090             if (fallbackIcon != null) {
3091                 icon = fallbackIcon;
3092             } else {
3093                 icon = getFallbackIcon();
3094                 info.usingFallbackIcon = true;
3095             }
3096         }
3097         info.setIcon(icon);
3098 
3099         info.title = name;
3100         info.intent = intent;
3101         info.customIcon = customIcon;
3102         info.iconResource = iconResource;
3103 
3104         return info;
3105     }
3106 
3107     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3108             int iconIndex) {
3109         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3110         if (!mAppsCanBeOnRemoveableStorage) {
3111             return false;
3112         }
3113         // If this icon doesn&#x27;t have a custom icon, check to see
3114         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3115         // we&#x27;re going to show, store what we are going to show back
3116         // into the DB.  We do this so when we&#x27;re loading, if the
3117         // package manager can&#x27;t find an icon (for example because
3118         // the app is on SD) then we can use that instead.
3119         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3120             cache.put(info, c.getBlob(iconIndex));
3121             return true;
3122         }
3123         return false;
3124     }
3125 
3126     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3127         boolean needSave = false;
3128         try {
3129             if (data != null) {
3130                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3131                 Bitmap loaded = info.getIcon(mIconCache);
3132                 needSave = !saved.sameAs(loaded);
3133             } else {
3134                 needSave = true;
3135             }
3136         } catch (Exception e) {
3137             needSave = true;
3138         }
3139         if (needSave) {
3140             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3141             // This is slower than is ideal, but this only happens once
3142             // or when the app is updated with a new icon.
3143             updateItemInDatabase(context, info);
3144         }
3145     }
3146 
3147     /**
3148      * Return an existing FolderInfo object if we have encountered this ID previously,
3149      * or make a new one.
3150      */
3151     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3152         // See if a placeholder was created for us already
3153         FolderInfo folderInfo = folders.get(id);
3154         if (folderInfo == null) {
3155             // No placeholder -- create a new instance
3156             folderInfo = new FolderInfo();
3157             folders.put(id, folderInfo);
3158         }
3159         return folderInfo;
3160     }
3161 
3162     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3163         final Collator collator = Collator.getInstance();
3164         return new Comparator&lt;AppInfo&gt;() {
3165             public final int compare(AppInfo a, AppInfo b) {
3166                 int result = collator.compare(a.title.toString().trim(),
3167                         b.title.toString().trim());
3168                 if (result == 0) {
3169                     result = a.componentName.compareTo(b.componentName);
3170                 }
3171                 return result;
3172             }
3173         };
3174     }
3175 
3176     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;AppInfo&gt;() {
3177         public final int compare(AppInfo a, AppInfo b) {
3178             if (a.firstInstallTime &lt; b.firstInstallTime) {
3179                 return 1;
3180             }
3181             if (a.firstInstallTime &gt; b.firstInstallTime) {
3182                 return -1;
3183             }
3184             return 0;
3185         }
3186     };
3187 
3188     public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {
3189         final Collator collator = Collator.getInstance();
3190         return new Comparator&lt;AppWidgetProviderInfo&gt;() {
3191             public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
3192                 return collator.compare(a.label.toString().trim(), b.label.toString().trim());
3193             }
3194         };
3195     }
3196 
3197     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3198         if (info.activityInfo != null) {
3199             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3200         } else {
3201             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3202         }
3203     }
3204 
3205     public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
3206         private Collator mCollator;
3207 
3208         private PackageManager mPackageManager;
3209 
3210         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3211 
3212         ShortcutNameComparator(PackageManager pm) {
3213             mPackageManager = pm;
3214             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3215             mCollator = Collator.getInstance();
3216         }
3217 
3218         ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
3219             mPackageManager = pm;
3220             mLabelCache = labelCache;
3221             mCollator = Collator.getInstance();
3222         }
3223 
3224         public final int compare(ResolveInfo a, ResolveInfo b) {
3225             CharSequence labelA;
3226             CharSequence labelB;
3227             ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
3228             ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
3229             if (mLabelCache.containsKey(keyA)) {
3230                 labelA = mLabelCache.get(keyA);
3231             } else {
3232                 labelA = a.loadLabel(mPackageManager).toString().trim();
3233                 mLabelCache.put(keyA, labelA);
3234             }
3235             if (mLabelCache.containsKey(keyB)) {
3236                 labelB = mLabelCache.get(keyB);
3237             } else {
3238                 labelB = b.loadLabel(mPackageManager).toString().trim();
3239                 mLabelCache.put(keyB, labelB);
3240             }
3241             return mCollator.compare(labelA, labelB);
3242         }
3243     }
3244 
3245     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3246         private Collator mCollator;
3247 
3248         private PackageManager mPackageManager;
3249 
3250         private HashMap&lt;Object, String&gt; mLabelCache;
3251 
3252         WidgetAndShortcutNameComparator(PackageManager pm) {
3253             mPackageManager = pm;
3254             mLabelCache = new HashMap&lt;Object, String&gt;();
3255             mCollator = Collator.getInstance();
3256         }
3257 
3258         public final int compare(Object a, Object b) {
3259             String labelA;
3260             String labelB;
3261             if (mLabelCache.containsKey(a)) {
3262                 labelA = mLabelCache.get(a);
3263             } else {
<abbr title="3264                 labelA = (a instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (a)).label : ((ResolveInfo) (a)).loadLabel(mPackageManager).toString().trim();">3264                 labelA = (a instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (a)).label : ((RðŸ”µ</abbr>
3265                 mLabelCache.put(a, labelA);
3266             }
3267             if (mLabelCache.containsKey(b)) {
3268                 labelB = mLabelCache.get(b);
3269             } else {
<abbr title="3270                 labelB = (b instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (b)).label : ((ResolveInfo) (b)).loadLabel(mPackageManager).toString().trim();">3270                 labelB = (b instanceof AppWidgetProviderInfo) ? ((AppWidgetProviderInfo) (b)).label : ((RðŸ”µ</abbr>
3271                 mLabelCache.put(b, labelB);
3272             }
3273             return mCollator.compare(labelA, labelB);
3274         }
3275     }
3276 
3277     public void dumpState() {
3278         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3279         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3280         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3281         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3282         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3283         if (mLoaderTask != null) {
3284             mLoaderTask.dumpState();
3285         } else {
3286             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3287         }
3288     }
3289 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.*;
  23  import android.content.Intent.ShortcutIconResource;
  24  import android.content.pm.ActivityInfo;
  25  import android.content.pm.PackageInfo;
  26  import android.content.pm.PackageManager;
  27  import android.content.pm.PackageManager.NameNotFoundException;
  28  import android.content.pm.ResolveInfo;
  29  import android.content.res.Configuration;
  30  import android.content.res.Resources;
  31  import android.database.Cursor;
  32  import android.graphics.Bitmap;
  33  import android.graphics.BitmapFactory;
  34  import android.net.Uri;
  35  import android.os.Environment;
  36  import android.os.Handler;
  37  import android.os.HandlerThread;
  38  import android.os.Parcelable;
  39  import android.os.Process;
  40  import android.os.RemoteException;
  41  import android.os.SystemClock;
  42  import android.provider.BaseColumns;
  43  import android.text.TextUtils;
  44  import android.util.Log;
  45  import android.util.Pair;
  46  
  47  import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  48  
  49  import java.lang.ref.WeakReference;
  50  import java.net.URISyntaxException;
  51  import java.text.Collator;
  52  import java.util.ArrayList;
  53  import java.util.Arrays;
  54  import java.util.Collection;
  55  import java.util.Collections;
  56  import java.util.Comparator;
  57  import java.util.HashMap;
  58  import java.util.HashSet;
  59  import java.util.Iterator;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.TreeMap;
  63  import java.util.concurrent.atomic.AtomicBoolean;
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  75      // false = strew non-workspace apps across the workspace on upgrade
  76      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  77  
  78      public static final int LOADER_FLAG_NONE = 0;
  79      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  80      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  81  
  82      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  83      private static final long INVALID_SCREEN_ID = -1L;
  84  
  85      private final boolean mAppsCanBeOnRemoveableStorage;
  86      private final boolean mOldContentProviderExists;
  87  
  88      private final LauncherAppState mApp;
  89      private final Object mLock = new Object();
  90      private DeferredHandler mHandler = new DeferredHandler();
  91      private LoaderTask mLoaderTask;
  92      private boolean mIsLoaderTaskRunning;
  93      private volatile boolean mFlushingWorkerThread;
  94  
  95      // Specific runnable types that are run on the main thread deferred handler, this allows us to
  96      // clear all queued binding runnables when the Launcher activity is destroyed.
  97      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
  98      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
  99  
 100  
 101      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 102      static {
 103          sWorkerThread.start();
 104      }
 105      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 106  
 107      // We start off with everything not loaded.  After that, we assume that
 108      // our monitoring of the package manager provides all updates and we never
 109      // need to do a requery.  These are only ever touched from the loader thread.
 110      private boolean mWorkspaceLoaded;
 111      private boolean mAllAppsLoaded;
 112  
 113      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 114      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 115      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 116      // a normal load, we also clear this set of Runnables.
 117      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 118  
 119      private WeakReference&lt;Callbacks&gt; mCallbacks;
 120  
 121      // &lt; only access in worker thread &gt;
 122      AllAppsList mBgAllAppsList;
 123  
 124      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 125      // other locks, this one can generally be held long-term because we never expect any of these
 126      // static data structures to be referenced outside of the worker thread except on the first
 127      // load after configuration change.
 128      static final Object sBgLock = new Object();
 129  
 130      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 131      // LauncherModel to their ids
 132      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 133  
 134      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 135      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 136      //       shortcuts within folders).
 137      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 138  
 139      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 140      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 141          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 142  
 143      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 144      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 145  
 146      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 147      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 148  
 149      // sBgWorkspaceScreens is the ordered set of workspace screens.
 150      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 151  
 152      // &lt;/ only access in worker thread &gt;
 153  
 154      private IconCache mIconCache;
 155      private Bitmap mDefaultIcon;
 156  
 157      protected int mPreviousConfigMcc;
 158  
 159      public interface Callbacks {
 160          public boolean setLoadOnResume();
 161          public int getCurrentWorkspaceScreen();
 162          public void startBinding();
 163          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 164                                boolean forceAnimateIcons);
 165          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 166          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 167          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 168          public void finishBindingItems(boolean upgradePath);
 169          public void bindAppWidget(LauncherAppWidgetInfo info);
 170          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 171          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 172                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 173                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 174                                    ArrayList&lt;AppInfo&gt; addedApps);
 175          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 176          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 177                          ArrayList&lt;AppInfo&gt; appInfos);
 178          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 179          public void bindSearchablesChanged();
 180          public boolean isAllAppsButtonRank(int rank);
 181          public void onPageBoundSynchronously(int page);
 182          public void dumpLogsToLocalData();
 183      }
 184  
 185      public interface ItemInfoFilter {
 186          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 187      }
 188  
 189      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 190          Context context = app.getContext();
 191          ContentResolver contentResolver = context.getContentResolver();
 192  
 193          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 194          mOldContentProviderExists = (contentResolver.acquireContentProviderClient(
 195                  LauncherSettings.Favorites.OLD_CONTENT_URI) != null);
 196          mApp = app;
 197          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 198          mIconCache = iconCache;
 199  
 200          final Resources res = context.getResources();
 201          Configuration config = res.getConfiguration();
 202          mPreviousConfigMcc = config.mcc;
 203      }
 204  
 205      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 206       * posted on the main thread handler. */
 207      private void runOnMainThread(Runnable r) {
 208          runOnMainThread(r, 0);
 209      }
 210      private void runOnMainThread(Runnable r, int type) {
 211          if (sWorkerThread.getThreadId() == Process.myTid()) {
 212              // If we are on the worker thread, post onto the main handler
 213              mHandler.post(r);
 214          } else {
 215              r.run();
 216          }
 217      }
 218  
 219      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 220       * posted on the worker thread handler. */
 221      private static void runOnWorkerThread(Runnable r) {
 222          if (sWorkerThread.getThreadId() == Process.myTid()) {
 223              r.run();
 224          } else {
 225              // If we are not on the worker thread, then post to the worker handler
 226              sWorker.post(r);
 227          }
 228      }
 229  
 230      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 231          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 232      }
 233  
 234      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 235                                   long screen) {
 236          LauncherAppState app = LauncherAppState.getInstance();
 237          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 238          final int xCount = (int) grid.numColumns;
 239          final int yCount = (int) grid.numRows;
 240          boolean[][] occupied = new boolean[xCount][yCount];
 241  
 242          int cellX, cellY, spanX, spanY;
 243          for (int i = 0; i &lt; items.size(); ++i) {
 244              final ItemInfo item = items.get(i);
 245              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 246                  if (item.screenId == screen) {
 247                      cellX = item.cellX;
 248                      cellY = item.cellY;
 249                      spanX = item.spanX;
 250                      spanY = item.spanY;
 251                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 252                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 253                              occupied[x][y] = true;
 254                          }
 255                      }
 256                  }
 257              }
 258          }
 259  
 260          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 261      }
 262      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 263                                                          Intent launchIntent,
 264                                                          int firstScreenIndex,
 265                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 266          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 267          LauncherAppState app = LauncherAppState.getInstance();
 268          LauncherModel model = app.getModel();
 269          boolean found = false;
 270          synchronized (app) {
 271              if (sWorkerThread.getThreadId() != Process.myTid()) {
 272                  // Flush the LauncherModel worker thread, so that if we just did another
 273                  // processInstallShortcut, we give it time for its shortcut to get added to the
 274                  // database (getItemsInLocalCoordinates reads the database)
 275                  model.flushWorkerThread();
 276              }
 277              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 278  
 279              // Try adding to the workspace screens incrementally, starting at the default or center
 280              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 281              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 282              int count = workspaceScreens.size();
 283              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 284                  int[] tmpCoordinates = new int[2];
 285                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 286                          workspaceScreens.get(screen))) {
 287                      // Update the Launcher db
 288                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 289                  }
 290              }
 291          }
 292          return null;
 293      }
 294  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 295 -    public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -        if (allAppsApps == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -            throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -        if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 304 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 305 -        final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 306 -        Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 307 -        while (iter.hasNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -            ItemInfo a = iter.next();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -            if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 312 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 313 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 314 -        // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 315 -        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 316 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 317 -                runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -                    public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -                        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 320 -                        if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 321 -                            callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 322 -                            if (!restoredAppsFinal.isEmpty()) {</span>






<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 323 -                                callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 324 -                            }</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -        runOnWorkerThread(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -    public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -            final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -        if (workspaceApps == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +                                    final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +        addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +                                final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +        if (workspaceApps == null || allAppsApps == null) {</span>
 346              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 347          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 348 -        if (workspaceApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +        if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {</span>
 350              return;
 351          }
 352          // Process the newly added applications and add them to the database first
 353          Runnable r = new Runnable() {
 354              public void run() {
 355                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 356                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -                final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
 358  
 359                  // Get the list of workspace screens.  We need to append to this list and
 360                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 361                  // called.
 362                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 363                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 364                  for (Integer i : orderedScreens.keySet()) {
 365                      long screenId = orderedScreens.get(i);
 366                      workspaceScreens.add(screenId);
 367                  }
 368  
 369                  synchronized(sBgLock) {
 370                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 371                      while (iter.hasNext()) {
 372                          ItemInfo a = iter.next();
 373                          final String name = a.title.toString();
 374                          final Intent launchIntent = a.getIntent();
 375  
 376                          // Short-circuit this logic if the icon exists somewhere on the workspace
 377                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -                            // Only InstallShortcutReceiver sends us shortcutInfos, ignore them</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -                            if (a instanceof AppInfo &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -                                    LauncherModel.appWasRestored(context, launchIntent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -                                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -                            }</span>
 383                              continue;
 384                          }
 385  
 386                          // Add this icon to the db, creating a new page if necessary.  If there
 387                          // is only the empty page then we just add items to the first page.
 388                          // Otherwise, we add them to the next pages.
 389                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 390                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 391                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 392                          if (coords == null) {
 393                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 394  
 395                              // If we can&#x27;t find a valid position, then just add a new screen.
 396                              // This takes time so we need to re-queue the add until the new
 397                              // page is added.  Create as many screens as necessary to satisfy
 398                              // the startSearchPageIndex.
 399                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 400                                      workspaceScreens.size());
 401                              while (numPagesToAdd &gt; 0) {
 402                                  long screenId = lp.generateNewScreenId();
 403                                  // Save the screen id for binding in the workspace
 404                                  workspaceScreens.add(screenId);
 405                                  addedWorkspaceScreensFinal.add(screenId);
 406                                  numPagesToAdd--;
 407                              }
 408  
 409                              // Find the coordinate again
 410                              coords = LauncherModel.findNextAvailableIconSpace(context,
 411                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 412                          }
 413                          if (coords == null) {
 414                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 415                          }
 416  
 417                          ShortcutInfo shortcutInfo;
 418                          if (a instanceof ShortcutInfo) {
 419                              shortcutInfo = (ShortcutInfo) a;
 420                          } else if (a instanceof AppInfo) {
 421                              shortcutInfo = ((AppInfo) a).makeShortcut();
 422                          } else {
 423                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 424                          }
 425  
 426                          // Add the shortcut to the db
 427                          addItemToDatabase(context, shortcutInfo,
 428                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 429                                  coords.first, coords.second[0], coords.second[1], false);
 430                          // Save the ShortcutInfo for binding in the workspace
 431                          addedShortcutsFinal.add(shortcutInfo);
 432                      }
 433                  }
 434  
 435                  // Update the workspace screens
 436                  updateWorkspaceScreenOrder(context, workspaceScreens);
 437  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -                if (!addedShortcutsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +                if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {</span>
 440                      runOnMainThread(new Runnable() {
 441                          public void run() {
 442                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 443                              if (callbacks == cb &amp;&amp; cb != null) {
 444                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 445                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 446                                  if (!addedShortcutsFinal.isEmpty()) {
 447                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 448                                      long lastScreenId = info.screenId;
 449                                      for (ItemInfo i : addedShortcutsFinal) {
 450                                          if (i.screenId == lastScreenId) {
 451                                              addAnimated.add(i);
 452                                          } else {
 453                                              addNotAnimated.add(i);
 454                                          }
 455                                      }
 456                                  }
 457                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -                                        addNotAnimated, addAnimated, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -                                if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -                                    callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +                                        addNotAnimated, addAnimated, allAppsApps);</span>
 463                              }
 464                          }
 465                      });
 466                  }
 467              }
 468          };
 469          runOnWorkerThread(r);
 470      }
 471  
 472      public Bitmap getFallbackIcon() {
 473          if (mDefaultIcon == null) {
 474              final Context context = LauncherAppState.getInstance().getContext();
 475              mDefaultIcon = Utilities.createIconBitmap(
 476                      mIconCache.getFullResDefaultActivityIcon(), context);
 477          }
 478          return Bitmap.createBitmap(mDefaultIcon);
 479      }
 480  
 481      public void unbindItemInfosAndClearQueuedBindRunnables() {
 482          if (sWorkerThread.getThreadId() == Process.myTid()) {
 483              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 484                      &quot;main thread&quot;);
 485          }
 486  
 487          // Clear any deferred bind runnables
 488          mDeferredBindRunnables.clear();
 489          // Remove any queued bind runnables
 490          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 491          // Unbind all the workspace items
 492          unbindWorkspaceItemsOnMainThread();
 493      }
 494  
 495      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 496      void unbindWorkspaceItemsOnMainThread() {
 497          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 498          // by making a copy of workspace items first.
 499          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 500          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 501          synchronized (sBgLock) {
 502              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 503              tmpAppWidgets.addAll(sBgAppWidgets);
 504          }
 505          Runnable r = new Runnable() {
 506                  @Override
 507                  public void run() {
 508                     for (ItemInfo item : tmpWorkspaceItems) {
 509                         item.unbind();
 510                     }
 511                     for (ItemInfo item : tmpAppWidgets) {
 512                         item.unbind();
 513                     }
 514                  }
 515              };
 516          runOnMainThread(r);
 517      }
 518  
 519      /**
 520       * Adds an item to the DB if it was not created previously, or move it to a new
 521       * &lt;container, screen, cellX, cellY&gt;
 522       */
 523      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 524              long screenId, int cellX, int cellY) {
 525          if (item.container == ItemInfo.NO_ID) {
 526              // From all apps
 527              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 528          } else {
 529              // From somewhere else
 530              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 531          }
 532      }
 533  
 534      static void checkItemInfoLocked(
 535              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 536          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 537          if (modelItem != null &amp;&amp; item != modelItem) {
 538              // check all the data is consistent
 539              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 540                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 541                  ShortcutInfo shortcut = (ShortcutInfo) item;
 542                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 543                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 544                          modelShortcut.id == shortcut.id &amp;&amp;
 545                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 546                          modelShortcut.container == shortcut.container &amp;&amp;
 547                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 548                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 549                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 550                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 551                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 552                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 553                          (modelShortcut.dropPos != null &amp;&amp;
 554                                  shortcut.dropPos != null &amp;&amp;
 555                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 556                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 557                      // For all intents and purposes, this is the same object
 558                      return;
 559                  }
 560              }
 561  
 562              // the modelItem needs to match up perfectly with item if our model is
 563              // to be consistent with the database-- for now, just require
 564              // modelItem == item or the equality check above
 565              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 566                      &quot;modelItem: &quot; +
 567                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 568                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 569              RuntimeException e = new RuntimeException(msg);
 570              if (stackTrace != null) {
 571                  e.setStackTrace(stackTrace);
 572              }
 573              throw e;
 574          }
 575      }
 576  
 577      static void checkItemInfo(final ItemInfo item) {
 578          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 579          final long itemId = item.id;
 580          Runnable r = new Runnable() {
 581              public void run() {
 582                  synchronized (sBgLock) {
 583                      checkItemInfoLocked(itemId, item, stackTrace);
 584                  }
 585              }
 586          };
 587          runOnWorkerThread(r);
 588      }
 589  
 590      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 591              final ItemInfo item, final String callingFunction) {
 592          final long itemId = item.id;
 593          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 594          final ContentResolver cr = context.getContentResolver();
 595  
 596          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 597          Runnable r = new Runnable() {
 598              public void run() {
 599                  cr.update(uri, values, null, null);
 600                  updateItemArrays(item, itemId, stackTrace);
 601              }
 602          };
 603          runOnWorkerThread(r);
 604      }
 605  
 606      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 607              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 608          final ContentResolver cr = context.getContentResolver();
 609  
 610          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 611          Runnable r = new Runnable() {
 612              public void run() {
 613                  ArrayList&lt;ContentProviderOperation&gt; ops =
 614                          new ArrayList&lt;ContentProviderOperation&gt;();
 615                  int count = items.size();
 616                  for (int i = 0; i &lt; count; i++) {
 617                      ItemInfo item = items.get(i);
 618                      final long itemId = item.id;
 619                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 620                      ContentValues values = valuesList.get(i);
 621  
 622                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 623                      updateItemArrays(item, itemId, stackTrace);
 624  
 625                  }
 626                  try {
 627                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 628                  } catch (Exception e) {
 629                      e.printStackTrace();
 630                  }
 631              }
 632          };
 633          runOnWorkerThread(r);
 634      }
 635  
 636      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 637          // Lock on mBgLock *after* the db operation
 638          synchronized (sBgLock) {
 639              checkItemInfoLocked(itemId, item, stackTrace);
 640  
 641              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 642                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 643                  // Item is in a folder, make sure this folder exists
 644                  if (!sBgFolders.containsKey(item.container)) {
 645                      // An items container is being set to a that of an item which is not in
 646                      // the list of Folders.
 647                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 648                              item.container + &quot;, not in the list of folders&quot;;
 649                      Log.e(TAG, msg);
 650                  }
 651              }
 652  
 653              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 654              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 655              // that are on the desktop, as appropriate
 656              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 657              if (modelItem != null &amp;&amp;
 658                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 659                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 660                  switch (modelItem.itemType) {
 661                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 662                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 663                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 664                          if (!sBgWorkspaceItems.contains(modelItem)) {
 665                              sBgWorkspaceItems.add(modelItem);
 666                          }
 667                          break;
 668                      default:
 669                          break;
 670                  }
 671              } else {
 672                  sBgWorkspaceItems.remove(modelItem);
 673              }
 674          }
 675      }
 676  
 677      public void flushWorkerThread() {
 678          mFlushingWorkerThread = true;
 679          Runnable waiter = new Runnable() {
 680                  public void run() {
 681                      synchronized (this) {
 682                          notifyAll();
 683                          mFlushingWorkerThread = false;
 684                      }
 685                  }
 686              };
 687  
 688          synchronized(waiter) {
 689              runOnWorkerThread(waiter);
 690              if (mLoaderTask != null) {
 691                  synchronized(mLoaderTask) {
 692                      mLoaderTask.notify();
 693                  }
 694              }
 695              boolean success = false;
 696              while (!success) {
 697                  try {
 698                      waiter.wait();
 699                      success = true;
 700                  } catch (InterruptedException e) {
 701                  }
 702              }
 703          }
 704      }
 705  
 706      /**
 707       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 708       */
 709      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 710              final long screenId, final int cellX, final int cellY) {
 711          item.container = container;
 712          item.cellX = cellX;
 713          item.cellY = cellY;
 714  
 715          // We store hotseat items in canonical form which is this orientation invariant position
 716          // in the hotseat
 717          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 718                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 719              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 720          } else {
 721              item.screenId = screenId;
 722          }
 723  
 724          final ContentValues values = new ContentValues();
 725          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 726          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 727          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 728          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 729  
 730          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 731      }
 732  
 733      /**
 734       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 735       * cellX, cellY have already been updated on the ItemInfos.
 736       */
 737      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 738              final long container, final int screen) {
 739  
 740          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 741          int count = items.size();
 742  
 743          for (int i = 0; i &lt; count; i++) {
 744              ItemInfo item = items.get(i);
 745              item.container = container;
 746  
 747              // We store hotseat items in canonical form which is this orientation invariant position
 748              // in the hotseat
 749              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 750                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 751                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 752                          item.cellY);
 753              } else {
 754                  item.screenId = screen;
 755              }
 756  
 757              final ContentValues values = new ContentValues();
 758              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 759              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 760              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 761              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 762  
 763              contentValues.add(values);
 764          }
 765          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 766      }
 767  
 768      /**
 769       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 770       */
 771      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 772              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 773          item.container = container;
 774          item.cellX = cellX;
 775          item.cellY = cellY;
 776          item.spanX = spanX;
 777          item.spanY = spanY;
 778  
 779          // We store hotseat items in canonical form which is this orientation invariant position
 780          // in the hotseat
 781          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 782                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 783              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 784          } else {
 785              item.screenId = screenId;
 786          }
 787  
 788          final ContentValues values = new ContentValues();
 789          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 790          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 791          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 792          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 793          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 794          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 795  
 796          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 797      }
 798  
 799      /**
 800       * Update an item to the database in a specified container.
 801       */
 802      static void updateItemInDatabase(Context context, final ItemInfo item) {
 803          final ContentValues values = new ContentValues();
 804          item.onAddToDatabase(values);
 805          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 806          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 807      }
 808  
 809      /**
 810       * Returns true if the shortcuts already exists in the database.
 811       * we identify a shortcut by its title and intent.
 812       */
 813      static boolean shortcutExists(Context context, String title, Intent intent) {
 814          final ContentResolver cr = context.getContentResolver();
 815          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 816              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 817              new String[] { title, intent.toUri(0) }, null);
 818          boolean result = false;
 819          try {
 820              result = c.moveToFirst();
 821          } finally {
 822              c.close();
 823          }
 824          return result;
 825      }
 826  
 827      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -     * Returns true if the shortcuts already exists in the database.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -     * we identify a shortcut by the component name of the intent.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 830 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 831 -    static boolean appWasRestored(Context context, Intent intent) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 832 -        final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 833 -        final ComponentName component = intent.getComponent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 834 -        if (component == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 835 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 836 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -        String componentName = component.flattenToString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 838 -        final String where = &quot;intent glob \&quot;*component=&quot; + componentName + &quot;*\&quot; and restored = 1&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 839 -        Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -                new String[]{&quot;intent&quot;, &quot;restored&quot;}, where, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -        boolean result = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -            result = c.moveToFirst();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 844 -        } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 845 -            c.close();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 846 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 847 -        Log.d(TAG, &quot;shortcutWasRestored is &quot; + result + &quot; for &quot; + componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 848 -        return result;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 849 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 850 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 851 -    /**</span>
 852       * Returns an ItemInfo array containing all the items in the LauncherModel.
 853       * The ItemInfo.id is not set through this function.
 854       */
 855      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 856          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 857          final ContentResolver cr = context.getContentResolver();
 858          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 859                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 860                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 860                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 861                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 862  
 863          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 864          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 865          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 866          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 867          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 868          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 869          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 870  
 871          try {
 872              while (c.moveToNext()) {
 873                  ItemInfo item = new ItemInfo();
 874                  item.cellX = c.getInt(cellXIndex);
 875                  item.cellY = c.getInt(cellYIndex);
 876                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 877                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 878                  item.container = c.getInt(containerIndex);
 879                  item.itemType = c.getInt(itemTypeIndex);
 880                  item.screenId = c.getInt(screenIndex);
 881  
 882                  items.add(item);
 883              }
 884          } catch (Exception e) {
 885              items.clear();
 886          } finally {
 887              c.close();
 888          }
 889  
 890          return items;
 891      }
 892  
 893      /**
 894       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 895       */
 896      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 897          final ContentResolver cr = context.getContentResolver();
 898          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 899                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 900                  new String[] { String.valueOf(id),
 901                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 902  
 903          try {
 904              if (c.moveToFirst()) {
 905                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 906                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 907                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 908                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 909                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 910                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 911  
 912                  FolderInfo folderInfo = null;
 913                  switch (c.getInt(itemTypeIndex)) {
 914                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 915                          folderInfo = findOrMakeFolder(folderList, id);
 916                          break;
 917                  }
 918  
 919                  folderInfo.title = c.getString(titleIndex);
 920                  folderInfo.id = id;
 921                  folderInfo.container = c.getInt(containerIndex);
 922                  folderInfo.screenId = c.getInt(screenIndex);
 923                  folderInfo.cellX = c.getInt(cellXIndex);
 924                  folderInfo.cellY = c.getInt(cellYIndex);
 925  
 926                  return folderInfo;
 927              }
 928          } finally {
 929              c.close();
 930          }
 931  
 932          return null;
 933      }
 934  
 935      /**
 936       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 937       * cellY fields of the item. Also assigns an ID to the item.
 938       */
 939      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 940              final long screenId, final int cellX, final int cellY, final boolean notify) {
 941          item.container = container;
 942          item.cellX = cellX;
 943          item.cellY = cellY;
 944          // We store hotseat items in canonical form which is this orientation invariant position
 945          // in the hotseat
 946          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 947                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 948              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 949          } else {
 950              item.screenId = screenId;
 951          }
 952  
 953          final ContentValues values = new ContentValues();
 954          final ContentResolver cr = context.getContentResolver();
 955          item.onAddToDatabase(values);
 956  
 957          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 958          values.put(LauncherSettings.Favorites._ID, item.id);
 959          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 960  
 961          Runnable r = new Runnable() {
 962              public void run() {
 963                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 964                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 965  
 966                  // Lock on mBgLock *after* the db operation
 967                  synchronized (sBgLock) {
 968                      checkItemInfoLocked(item.id, item, null);
 969                      sBgItemsIdMap.put(item.id, item);
 970                      switch (item.itemType) {
 971                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 972                              sBgFolders.put(item.id, (FolderInfo) item);
 973                              // Fall through
 974                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 975                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 976                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 977                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 978                                  sBgWorkspaceItems.add(item);
 979                              } else {
 980                                  if (!sBgFolders.containsKey(item.container)) {
 981                                      // Adding an item to a folder that doesn&#x27;t exist.
 982                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 983                                              &quot; doesn&#x27;t exist&quot;;
 984                                      Log.e(TAG, msg);
 985                                  }
 986                              }
 987                              break;
 988                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 989                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 990                              break;
 991                      }
 992                  }
 993              }
 994          };
 995          runOnWorkerThread(r);
 996      }
 997  
 998      /**
 999       * Creates a new unique child id, for a given cell span across all layouts.
1000       */
1001      static int getCellLayoutChildId(
1002              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1003          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1004                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1005      }
1006  
1007      /**
1008       * Removes the specified item from the database
1009       * @param context
1010       * @param item
1011       */
1012      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1013          final ContentResolver cr = context.getContentResolver();
1014          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
1015  
1016          Runnable r = new Runnable() {
1017              public void run() {
1018                  cr.delete(uriToDelete, null, null);
1019  
1020                  // Lock on mBgLock *after* the db operation
1021                  synchronized (sBgLock) {
1022                      switch (item.itemType) {
1023                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1024                              sBgFolders.remove(item.id);
1025                              for (ItemInfo info: sBgItemsIdMap.values()) {
1026                                  if (info.container == item.id) {
1027                                      // We are deleting a folder which still contains items that
1028                                      // think they are contained by that folder.
1029                                      String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1030                                              &quot;contains items (&quot; + info + &quot;)&quot;;
1031                                      Log.e(TAG, msg);
1032                                  }
1033                              }
1034                              sBgWorkspaceItems.remove(item);
1035                              break;
1036                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1037                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1038                              sBgWorkspaceItems.remove(item);
1039                              break;
1040                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1041                              sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1042                              break;
1043                      }
1044                      sBgItemsIdMap.remove(item.id);
1045                      sBgDbIconCache.remove(item);
1046                  }
1047              }
1048          };
1049          runOnWorkerThread(r);
1050      }
1051  
1052      /**
1053       * Update the order of the workspace screens in the database. The array list contains
1054       * a list of screen ids in the order that they should appear.
1055       */
1056      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1057          // Log to disk
1058          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1059          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1060  
1061          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1062          final ContentResolver cr = context.getContentResolver();
1063          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1064  
1065          // Remove any negative screen ids -- these aren&#x27;t persisted
1066          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1067          while (iter.hasNext()) {
1068              long id = iter.next();
1069              if (id &lt; 0) {
1070                  iter.remove();
1071              }
1072          }
1073  
1074          Runnable r = new Runnable() {
1075              @Override
1076              public void run() {
1077                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1078                  // Clear the table
1079                  ops.add(ContentProviderOperation.newDelete(uri).build());
1080                  int count = screensCopy.size();
1081                  for (int i = 0; i &lt; count; i++) {
1082                      ContentValues v = new ContentValues();
1083                      long screenId = screensCopy.get(i);
1084                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1085                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1086                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1087                  }
1088  
1089                  try {
1090                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1091                  } catch (Exception ex) {
1092                      throw new RuntimeException(ex);
1093                  }
1094  
1095                  synchronized (sBgLock) {
1096                      sBgWorkspaceScreens.clear();
1097                      sBgWorkspaceScreens.addAll(screensCopy);
1098                  }
1099              }
1100          };
1101          runOnWorkerThread(r);
1102      }
1103  
1104      /**
1105       * Remove the contents of the specified folder from the database
1106       */
1107      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1108          final ContentResolver cr = context.getContentResolver();
1109  
1110          Runnable r = new Runnable() {
1111              public void run() {
1112                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1113                  // Lock on mBgLock *after* the db operation
1114                  synchronized (sBgLock) {
1115                      sBgItemsIdMap.remove(info.id);
1116                      sBgFolders.remove(info.id);
1117                      sBgDbIconCache.remove(info);
1118                      sBgWorkspaceItems.remove(info);
1119                  }
1120  
1121                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1122                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1123                  // Lock on mBgLock *after* the db operation
1124                  synchronized (sBgLock) {
1125                      for (ItemInfo childInfo : info.contents) {
1126                          sBgItemsIdMap.remove(childInfo.id);
1127                          sBgDbIconCache.remove(childInfo);
1128                      }
1129                  }
1130              }
1131          };
1132          runOnWorkerThread(r);
1133      }
1134  
1135      /**
1136       * Set this as the current Launcher activity object for the loader.
1137       */
1138      public void initialize(Callbacks callbacks) {
1139          synchronized (mLock) {
1140              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1141          }
1142      }
1143  
1144      /**
1145       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1146       * ACTION_PACKAGE_CHANGED.
1147       */
1148      @Override
1149      public void onReceive(Context context, Intent intent) {
1150          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1151  
1152          final String action = intent.getAction();
1153  
1154          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1155                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1156                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1157              final String packageName = intent.getData().getSchemeSpecificPart();
1158              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1159  
1160              int op = PackageUpdatedTask.OP_NONE;
1161  
1162              if (packageName == null || packageName.length() == 0) {
1163                  // they sent us a bad intent
1164                  return;
1165              }
1166  
1167              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1168                  op = PackageUpdatedTask.OP_UPDATE;
1169              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1170                  if (!replacing) {
1171                      op = PackageUpdatedTask.OP_REMOVE;
1172                  }
1173                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1174                  // later, we will update the package at this time
1175              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1176                  if (!replacing) {
1177                      op = PackageUpdatedTask.OP_ADD;
1178                  } else {
1179                      op = PackageUpdatedTask.OP_UPDATE;
1180                  }
1181              }
1182  
1183              if (op != PackageUpdatedTask.OP_NONE) {
1184                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1185              }
1186  
1187          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1188              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1189              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1190              if (!replacing) {
1191                  enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1192                  if (mAppsCanBeOnRemoveableStorage) {
1193                      // Only rebind if we support removable storage.  It catches the case where
1194                      // apps on the external sd card need to be reloaded
1195                      startLoaderFromBackground();
1196                  }
1197              } else {
1198                  // If we are replacing then just update the packages in the list
1199                  enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1200                          packages));
1201              }
1202          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1203              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1204              if (!replacing) {
1205                  String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1206                  enqueuePackageUpdated(new PackageUpdatedTask(
1207                              PackageUpdatedTask.OP_UNAVAILABLE, packages));
1208              }
1209              // else, we are replacing the packages, so ignore this event and wait for
1210              // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time
1211          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1212              // If we have changed locale we need to clear out the labels in all apps/workspace.
1213              forceReload();
1214          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1215               // Check if configuration change was an mcc/mnc change which would affect app resources
1216               // and we would need to clear out the labels in all apps/workspace. Same handling as
1217               // above for ACTION_LOCALE_CHANGED
1218               Configuration currentConfig = context.getResources().getConfiguration();
1219               if (mPreviousConfigMcc != currentConfig.mcc) {
1220                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1221                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1222                     forceReload();
1223               }
1224               // Update previousConfig
1225               mPreviousConfigMcc = currentConfig.mcc;
1226          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1227                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1228              if (mCallbacks != null) {
1229                  Callbacks callbacks = mCallbacks.get();
1230                  if (callbacks != null) {
1231                      callbacks.bindSearchablesChanged();
1232                  }
1233              }
1234          }
1235      }
1236  
1237      private void forceReload() {
1238          resetLoadedState(true, true);
1239  
1240          // Do this here because if the launcher activity is running it will be restarted.
1241          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1242          // to reload.
1243          startLoaderFromBackground();
1244      }
1245  
1246      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1247          synchronized (mLock) {
1248              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1249              // mWorkspaceLoaded to true later
1250              stopLoaderLocked();
1251              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1252              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1253          }
1254      }
1255  
1256      /**
1257       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1258       * configuration changes.  So whenever we trigger the loader from the background
1259       * tell the launcher that it needs to re-run the loader when it comes back instead
1260       * of doing it now.
1261       */
1262      public void startLoaderFromBackground() {
1263          boolean runLoader = false;
1264          if (mCallbacks != null) {
1265              Callbacks callbacks = mCallbacks.get();
1266              if (callbacks != null) {
1267                  // Only actually run the loader if they&#x27;re not paused.
1268                  if (!callbacks.setLoadOnResume()) {
1269                      runLoader = true;
1270                  }
1271              }
1272          }
1273          if (runLoader) {
1274              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1275          }
1276      }
1277  
1278      // If there is already a loader task running, tell it to stop.
1279      // returns true if isLaunching() was true on the old task
1280      private boolean stopLoaderLocked() {
1281          boolean isLaunching = false;
1282          LoaderTask oldTask = mLoaderTask;
1283          if (oldTask != null) {
1284              if (oldTask.isLaunching()) {
1285                  isLaunching = true;
1286              }
1287              oldTask.stopLocked();
1288          }
1289          return isLaunching;
1290      }
1291  
1292      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1293          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1294      }
1295  
1296      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1297          synchronized (mLock) {
1298              if (DEBUG_LOADERS) {
1299                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1300              }
1301  
1302              // Clear any deferred bind-runnables from the synchronized load process
1303              // We must do this before any loading/binding is scheduled below.
1304              mDeferredBindRunnables.clear();
1305  
1306              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1307              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1308                  // If there is already one running, tell it to stop.
1309                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1310                  isLaunching = isLaunching || stopLoaderLocked();
1311                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1312                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1313                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1314                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1315                  } else {
1316                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1317                      sWorker.post(mLoaderTask);
1318                  }
1319              }
1320          }
1321      }
1322  
1323      void bindRemainingSynchronousPages() {
1324          // Post the remaining side pages to be loaded
1325          if (!mDeferredBindRunnables.isEmpty()) {
1326              for (final Runnable r : mDeferredBindRunnables) {
1327                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1328              }
1329              mDeferredBindRunnables.clear();
1330          }
1331      }
1332  
1333      public void stopLoader() {
1334          synchronized (mLock) {
1335              if (mLoaderTask != null) {
1336                  mLoaderTask.stopLocked();
1337              }
1338          }
1339      }
1340  
1341      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1342      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1343          final ContentResolver contentResolver = context.getContentResolver();
1344          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1345          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1346          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1347  
1348          try {
1349              final int idIndex = sc.getColumnIndexOrThrow(
1350                      LauncherSettings.WorkspaceScreens._ID);
1351              final int rankIndex = sc.getColumnIndexOrThrow(
1352                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1353              while (sc.moveToNext()) {
1354                  try {
1355                      long screenId = sc.getLong(idIndex);
1356                      int rank = sc.getInt(rankIndex);
1357                      orderedScreens.put(rank, screenId);
1358                  } catch (Exception e) {
1359                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1360                  }
1361              }
1362          } finally {
1363              sc.close();
1364          }
1365  
1366          // Log to disk
1367          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1368          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1369          for (Integer i : orderedScreens.keySet()) {
1370              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1371          }
1372          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1373                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1374          return orderedScreens;
1375      }
1376  
1377      public boolean isAllAppsLoaded() {
1378          return mAllAppsLoaded;
1379      }
1380  
1381      boolean isLoadingWorkspace() {
1382          synchronized (mLock) {
1383              if (mLoaderTask != null) {
1384                  return mLoaderTask.isLoadingWorkspace();
1385              }
1386          }
1387          return false;
1388      }
1389  
1390      /**
1391       * Runnable for the thread that loads the contents of the launcher:
1392       *   - workspace icons
1393       *   - widgets
1394       *   - all apps icons
1395       */
1396      private class LoaderTask implements Runnable {
1397          private Context mContext;
1398          private boolean mIsLaunching;
1399          private boolean mIsLoadingAndBindingWorkspace;
1400          private boolean mStopped;
1401          private boolean mLoadAndBindStepFinished;
1402          private int mFlags;
1403  
1404          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1405  
1406          LoaderTask(Context context, boolean isLaunching, int flags) {
1407              mContext = context;
1408              mIsLaunching = isLaunching;
1409              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1410              mFlags = flags;
1411          }
1412  
1413          boolean isLaunching() {
1414              return mIsLaunching;
1415          }
1416  
1417          boolean isLoadingWorkspace() {
1418              return mIsLoadingAndBindingWorkspace;
1419          }
1420  
1421          /** Returns whether this is an upgrade path */
1422          private boolean loadAndBindWorkspace() {
1423              mIsLoadingAndBindingWorkspace = true;
1424  
1425              // Load the workspace
1426              if (DEBUG_LOADERS) {
1427                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1428              }
1429  
1430              boolean isUpgradePath = false;
1431              if (!mWorkspaceLoaded) {
1432                  isUpgradePath = loadWorkspace();
1433                  synchronized (LoaderTask.this) {
1434                      if (mStopped) {
1435                          return isUpgradePath;
1436                      }
1437                      mWorkspaceLoaded = true;
1438                  }
1439              }
1440  
1441              // Bind the workspace
1442              bindWorkspace(-1, isUpgradePath);
1443              return isUpgradePath;
1444          }
1445  
1446          private void waitForIdle() {
1447              // Wait until the either we&#x27;re stopped or the other threads are done.
1448              // This way we don&#x27;t start loading all apps until the workspace has settled
1449              // down.
1450              synchronized (LoaderTask.this) {
1451                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1452  
1453                  mHandler.postIdle(new Runnable() {
1454                          public void run() {
1455                              synchronized (LoaderTask.this) {
1456                                  mLoadAndBindStepFinished = true;
1457                                  if (DEBUG_LOADERS) {
1458                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1459                                  }
1460                                  LoaderTask.this.notify();
1461                              }
1462                          }
1463                      });
1464  
1465                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1466                      try {
1467                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1468                          // wait no longer than 1sec at a time
1469                          this.wait(1000);
1470                      } catch (InterruptedException ex) {
1471                          // Ignore
1472                      }
1473                  }
1474                  if (DEBUG_LOADERS) {
1475                      Log.d(TAG, &quot;waited &quot;
1476                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1477                              + &quot;ms for previous step to finish binding&quot;);
1478                  }
1479              }
1480          }
1481  
1482          void runBindSynchronousPage(int synchronousBindPage) {
1483              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1484                  // Ensure that we have a valid page index to load synchronously
1485                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1486                          &quot;valid page index&quot;);
1487              }
1488              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1489                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1490                  // loaded already (we should load everything asynchronously in that case)
1491                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1492              }
1493              synchronized (mLock) {
1494                  if (mIsLoaderTaskRunning) {
1495                      // Ensure that we are never running the background loading at this point since
1496                      // we also touch the background collections
1497                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1498                  }
1499              }
1500  
1501              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1502              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1503              //      this call is synchronous, we can get away with not locking).
1504  
1505              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1506              // operations from the previous activity.  We need to ensure that all queued operations
1507              // are executed before any synchronous binding work is done.
1508              mHandler.flush();
1509  
1510              // Divide the set of loaded items into those that we are binding synchronously, and
1511              // everything else that is to be bound normally (asynchronously).
1512              bindWorkspace(synchronousBindPage, false);
1513              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1514              //      arise from that.
1515              onlyBindAllApps();
1516          }
1517  
1518          public void run() {
1519              boolean isUpgrade = false;
1520  
1521              synchronized (mLock) {
1522                  mIsLoaderTaskRunning = true;
1523              }
1524              // Optimize for end-user experience: if the Launcher is up and // running with the
1525              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1526              // workspace first (default).
1527              keep_running: {
1528                  // Elevate priority when Home launches for the first time to avoid
1529                  // starving at boot time. Staring at a blank home is not cool.
1530                  synchronized (mLock) {
1531                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1532                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1533                      android.os.Process.setThreadPriority(mIsLaunching
1534                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1535                  }
1536                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1537                  isUpgrade = loadAndBindWorkspace();
1538  
1539                  if (mStopped) {
1540                      break keep_running;
1541                  }
1542  
1543                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1544                  // settled down.
1545                  synchronized (mLock) {
1546                      if (mIsLaunching) {
1547                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1548                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1549                      }
1550                  }
1551                  waitForIdle();
1552  
1553                  // second step
1554                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1555                  loadAndBindAllApps();
1556  
1557                  // Restore the default thread priority after we are done loading items
1558                  synchronized (mLock) {
1559                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1560                  }
1561              }
1562  
1563              // Update the saved icons if necessary
1564              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1565              synchronized (sBgLock) {
1566                  for (Object key : sBgDbIconCache.keySet()) {
1567                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1568                  }
1569                  sBgDbIconCache.clear();
1570              }
1571  
1572              if (LauncherAppState.isDisableAllApps()) {
1573                  // Ensure that all the applications that are in the system are
1574                  // represented on the home screen.
1575                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1576                      verifyApplications();
1577                  }
1578              }
1579  
1580              // Clear out this reference, otherwise we end up holding it until all of the
1581              // callback runnables are done.
1582              mContext = null;
1583  
1584              synchronized (mLock) {
1585                  // If we are still the last one to be scheduled, remove ourselves.
1586                  if (mLoaderTask == this) {
1587                      mLoaderTask = null;
1588                  }
1589                  mIsLoaderTaskRunning = false;
1590              }
1591          }
1592  
1593          public void stopLocked() {
1594              synchronized (LoaderTask.this) {
1595                  mStopped = true;
1596                  this.notify();
1597              }
1598          }
1599  
1600          /**
1601           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1602           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1603           * object that was around when the deferred message was scheduled, and if there&#x27;s
1604           * a new Callbacks object around then also return null.  This will save us from
1605           * calling onto it with data that will be ignored.
1606           */
1607          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1608              synchronized (mLock) {
1609                  if (mStopped) {
1610                      return null;
1611                  }
1612  
1613                  if (mCallbacks == null) {
1614                      return null;
1615                  }
1616  
1617                  final Callbacks callbacks = mCallbacks.get();
1618                  if (callbacks != oldCallbacks) {
1619                      return null;
1620                  }
1621                  if (callbacks == null) {
1622                      Log.w(TAG, &quot;no mCallbacks&quot;);
1623                      return null;
1624                  }
1625  
1626                  return callbacks;
1627              }
1628          }
1629  
1630          private void verifyApplications() {
1631              final Context context = mApp.getContext();
1632  
1633              // Cross reference all the applications in our apps list with items in the workspace
1634              ArrayList&lt;ItemInfo&gt; tmpInfos;
1635              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1636              synchronized (sBgLock) {
1637                  for (AppInfo app : mBgAllAppsList.data) {
1638                      tmpInfos = getItemInfoForComponentName(app.componentName);
1639                      if (tmpInfos.isEmpty()) {
1640                          // We are missing an application icon, so add this to the workspace
1641                          added.add(app);
1642                          // This is a rare event, so lets log it
1643                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1644                      }
1645                  }
1646              }
1647              if (!added.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1648 -                addAndBindAddedWorkspaceApps(context, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1649 +                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1650 +                addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());</span>
1651              }
1652          }
1653  
1654          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1655          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1656                                             AtomicBoolean deleteOnInvalidPlacement) {
1657              LauncherAppState app = LauncherAppState.getInstance();
1658              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1659              final int countX = (int) grid.numColumns;
1660              final int countY = (int) grid.numRows;
1661  
1662              long containerIndex = item.screenId;
1663              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1664                  // Return early if we detect that an item is under the hotseat button
1665                  if (mCallbacks == null ||
1666                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1667                      deleteOnInvalidPlacement.set(true);
1668                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1669                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1670                              + item.cellY + &quot;) occupied by all apps&quot;);
1671                      return false;
1672                  }
1673  
1674                  final ItemInfo[][] hotseatItems =
1675                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1676  
1677                  if (item.screenId &gt;= grid.numHotseatIcons) {
1678                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1679                              + &quot; into hotseat position &quot; + item.screenId
1680                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1681                              + &quot;)&quot;);
1682                      return false;
1683                  }
1684  
1685                  if (hotseatItems != null) {
1686                      if (hotseatItems[(int) item.screenId][0] != null) {
1687                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1688                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1689                                  + item.cellY + &quot;) occupied by &quot;
1690                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1691                                  [(int) item.screenId][0]);
1692                              return false;
1693                      } else {
1694                          hotseatItems[(int) item.screenId][0] = item;
1695                          return true;
1696                      }
1697                  } else {
1698                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1699                      items[(int) item.screenId][0] = item;
1700                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1701                      return true;
1702                  }
1703              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1704                  // Skip further checking if it is not the hotseat or workspace container
1705                  return true;
1706              }
1707  
1708              if (!occupied.containsKey(item.screenId)) {
1709                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1710                  occupied.put(item.screenId, items);
1711              }
1712  
1713              final ItemInfo[][] screens = occupied.get(item.screenId);
1714              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1715                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1716                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1717                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1718                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1719                          + item.cellX + &quot;,&quot; + item.cellY
1720                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1721                  return false;
1722              }
1723  
1724              // Check if any workspace icons overlap with each other
1725              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1726                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1727                      if (screens[x][y] != null) {
1728                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1729                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1730                              + x + &quot;,&quot; + y
1731                              + &quot;) occupied by &quot;
1732                              + screens[x][y]);
1733                          return false;
1734                      }
1735                  }
1736              }
1737              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1738                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1739                      screens[x][y] = item;
1740                  }
1741              }
1742  
1743              return true;
1744          }
1745  
1746          /** Clears all the sBg data structures */
1747          private void clearSBgDataStructures() {
1748              synchronized (sBgLock) {
1749                  sBgWorkspaceItems.clear();
1750                  sBgAppWidgets.clear();
1751                  sBgFolders.clear();
1752                  sBgItemsIdMap.clear();
1753                  sBgDbIconCache.clear();
1754                  sBgWorkspaceScreens.clear();
1755              }
1756          }
1757  
1758          /** Returns whether this is an upgrade path */
1759          private boolean loadWorkspace() {
1760              // Log to disk
1761              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1762  
1763              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1764  
1765              final Context context = mContext;
1766              final ContentResolver contentResolver = context.getContentResolver();
1767              final PackageManager manager = context.getPackageManager();
1768              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1769              final boolean isSafeMode = manager.isSafeMode();
1770  
1771              LauncherAppState app = LauncherAppState.getInstance();
1772              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1773              int countX = (int) grid.numColumns;
1774              int countY = (int) grid.numRows;
1775  
1776              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1777                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1778                  LauncherAppState.getLauncherProvider().deleteDatabase();
1779              }
1780  
1781              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1782                  // append the user&#x27;s Launcher2 shortcuts
1783                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1784                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1785              } else {
1786                  // Make sure the default workspace is loaded
1787                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1788                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);
1789              }
1790  
1791              // Check if we need to do any upgrade-path logic
1792              // (Includes having just imported default favorites)
1793              boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();
1794  
1795              // Log to disk
1796              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1797  
1798              synchronized (sBgLock) {
1799                  clearSBgDataStructures();
1800  
1801                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1802                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1803                  final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1804                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1805                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1806  
1807                  // +1 for the hotseat (it can be larger than the workspace)
1808                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1809                  // before any earlier duplicates)
1810                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1811  
1812                  try {
1813                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1814                      final int intentIndex = c.getColumnIndexOrThrow
1815                              (LauncherSettings.Favorites.INTENT);
1816                      final int titleIndex = c.getColumnIndexOrThrow
1817                              (LauncherSettings.Favorites.TITLE);
1818                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1819                              LauncherSettings.Favorites.ICON_TYPE);
1820                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1821                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1822                              LauncherSettings.Favorites.ICON_PACKAGE);
1823                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1824                              LauncherSettings.Favorites.ICON_RESOURCE);
1825                      final int containerIndex = c.getColumnIndexOrThrow(
1826                              LauncherSettings.Favorites.CONTAINER);
1827                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1828                              LauncherSettings.Favorites.ITEM_TYPE);
1829                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1830                              LauncherSettings.Favorites.APPWIDGET_ID);
1831                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1832                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1833                      final int screenIndex = c.getColumnIndexOrThrow(
1834                              LauncherSettings.Favorites.SCREEN);
1835                      final int cellXIndex = c.getColumnIndexOrThrow
1836                              (LauncherSettings.Favorites.CELLX);
1837                      final int cellYIndex = c.getColumnIndexOrThrow
1838                              (LauncherSettings.Favorites.CELLY);
1839                      final int spanXIndex = c.getColumnIndexOrThrow
1840                              (LauncherSettings.Favorites.SPANX);
1841                      final int spanYIndex = c.getColumnIndexOrThrow(
1842                              LauncherSettings.Favorites.SPANY);
1843                      final int restoredIndex = c.getColumnIndexOrThrow(
1844                              LauncherSettings.Favorites.RESTORED);
1845                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1846                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1847                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1848  
1849                      ShortcutInfo info;
1850                      String intentDescription;
1851                      LauncherAppWidgetInfo appWidgetInfo;
1852                      int container;
1853                      long id;
1854                      Intent intent;
1855  
1856                      while (!mStopped &amp;&amp; c.moveToNext()) {
1857                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1858                          try {
1859                              int itemType = c.getInt(itemTypeIndex);
1860                              boolean restored = 0 != c.getInt(restoredIndex);
1861  
1862                              switch (itemType) {
1863                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1864                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1865                                  id = c.getLong(idIndex);
1866                                  intentDescription = c.getString(intentIndex);
1867                                  try {
1868                                      intent = Intent.parseUri(intentDescription, 0);
1869                                      ComponentName cn = intent.getComponent();
1870                                      if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {
1871                                          if (restored) {
1872                                              // might be installed later
1873                                              Launcher.addDumpLog(TAG,
1874                                                      &quot;package not yet restored: &quot; + cn, true);
1875                                          } else {
1876                                              if (!mAppsCanBeOnRemoveableStorage) {
1877                                                  // Log the invalid package, and remove it
1878                                                  Launcher.addDumpLog(TAG,
1879                                                          &quot;Invalid package removed: &quot; + cn, true);
1880                                                  itemsToRemove.add(id);
1881                                              } else {
1882                                                  // If apps can be on external storage, then we just
1883                                                  // leave them for the user to remove (maybe add
1884                                                  // visual treatment to it)
1885                                                  Launcher.addDumpLog(TAG,
1886                                                          &quot;Invalid package found: &quot; + cn, true);
1887                                              }
1888                                              continue;
1889                                          }
1890                                      } else if (restored) {
1891                                          // no special handling necessary for this restored item
1892                                          restoredRows.add(id);
1893                                          restored = false;
1894                                      }
1895                                  } catch (URISyntaxException e) {
1896                                      Launcher.addDumpLog(TAG,
1897                                              &quot;Invalid uri: &quot; + intentDescription, true);
1898                                      continue;
1899                                  }
1900  
1901                                  if (restored) {
1902                                      Launcher.addDumpLog(TAG,
1903                                              &quot;constructing info for partially restored package&quot;,
1904                                              true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1905 -                                    info = getRestoredItemInfo(c, titleIndex, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1906 +                                    info = getRestoredItemInfo(c, titleIndex);</span>
1907                                      intent = getRestoredItemIntent(c, context, intent);
1908                                  } else if (itemType ==
1909                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1910                                      info = getShortcutInfo(manager, intent, context, c, iconIndex,
1911                                              titleIndex, mLabelCache);
1912                                  } else {
1913                                      info = getShortcutInfo(c, context, iconTypeIndex,
1914                                              iconPackageIndex, iconResourceIndex, iconIndex,
1915                                              titleIndex);
1916  
1917                                      // App shortcuts that used to be automatically added to Launcher
1918                                      // didn&#x27;t always have the correct intent flags set, so do that
1919                                      // here
1920                                      if (intent.getAction() != null &amp;&amp;
1921                                          intent.getCategories() != null &amp;&amp;
1922                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1923                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1924                                          intent.addFlags(
1925                                              Intent.FLAG_ACTIVITY_NEW_TASK |
1926                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1927                                      }
1928                                  }
1929  
1930                                  if (info != null) {
1931                                      info.id = id;
1932                                      info.intent = intent;
1933                                      container = c.getInt(containerIndex);
1934                                      info.container = container;
1935                                      info.screenId = c.getInt(screenIndex);
1936                                      info.cellX = c.getInt(cellXIndex);
1937                                      info.cellY = c.getInt(cellYIndex);
1938                                      info.spanX = 1;
1939                                      info.spanY = 1;
1940  
1941                                      // check &amp; update map of what&#x27;s occupied
1942                                      deleteOnInvalidPlacement.set(false);
1943                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
1944                                          if (deleteOnInvalidPlacement.get()) {
1945                                              itemsToRemove.add(id);
1946                                          }
1947                                          break;
1948                                      }
1949  
1950                                      switch (container) {
1951                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1952                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1953                                          sBgWorkspaceItems.add(info);
1954                                          break;
1955                                      default:
1956                                          // Item is in a user folder
1957                                          FolderInfo folderInfo =
1958                                                  findOrMakeFolder(sBgFolders, container);
1959                                          folderInfo.add(info);
1960                                          break;
1961                                      }
1962                                      sBgItemsIdMap.put(info.id, info);
1963  
1964                                      // now that we&#x27;ve loaded everthing re-save it with the
1965                                      // icon in case it disappears somehow.
1966                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1967                                  } else {
1968                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1969                                  }
1970                                  break;
1971  
1972                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1973                                  id = c.getLong(idIndex);
1974                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1975  
1976                                  folderInfo.title = c.getString(titleIndex);
1977                                  folderInfo.id = id;
1978                                  container = c.getInt(containerIndex);
1979                                  folderInfo.container = container;
1980                                  folderInfo.screenId = c.getInt(screenIndex);
1981                                  folderInfo.cellX = c.getInt(cellXIndex);
1982                                  folderInfo.cellY = c.getInt(cellYIndex);
1983                                  folderInfo.spanX = 1;
1984                                  folderInfo.spanY = 1;
1985  
1986                                  // check &amp; update map of what&#x27;s occupied
1987                                  deleteOnInvalidPlacement.set(false);
1988                                  if (!checkItemPlacement(occupied, folderInfo,
1989                                          deleteOnInvalidPlacement)) {
1990                                      if (deleteOnInvalidPlacement.get()) {
1991                                          itemsToRemove.add(id);
1992                                      }
1993                                      break;
1994                                  }
1995  
1996                                  switch (container) {
1997                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1998                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1999                                          sBgWorkspaceItems.add(folderInfo);
2000                                          break;
2001                                  }
2002  
2003                                  if (restored) {
2004                                      // no special handling required for restored folders
2005                                      restoredRows.add(id);
2006                                  }
2007  
2008                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2009                                  sBgFolders.put(folderInfo.id, folderInfo);
2010                                  break;
2011  
2012                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2013                                  // Read all Launcher-specific widget details
2014                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2015                                  String savedProvider = c.getString(appWidgetProviderIndex);
2016  
2017                                  id = c.getLong(idIndex);
2018  
2019                                  final AppWidgetProviderInfo provider =
2020                                          widgets.getAppWidgetInfo(appWidgetId);
2021  
2022                                  if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
2023                                          provider.provider.getPackageName() == null)) {
2024                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
2025                                          + id + &quot; appWidgetId=&quot; + appWidgetId;
2026                                      Log.e(TAG, log);
2027                                      Launcher.addDumpLog(TAG, log, false);
2028                                      itemsToRemove.add(id);
2029                                  } else {
2030                                      appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2031                                              provider.provider);
2032                                      appWidgetInfo.id = id;
2033                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2034                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2035                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2036                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2037                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
2038                                      int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
2039                                      appWidgetInfo.minSpanX = minSpan[0];
2040                                      appWidgetInfo.minSpanY = minSpan[1];
2041  
2042                                      container = c.getInt(containerIndex);
2043                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2044                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2045                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2046                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2047                                          continue;
2048                                      }
2049  
2050                                      appWidgetInfo.container = c.getInt(containerIndex);
2051                                      // check &amp; update map of what&#x27;s occupied
2052                                      deleteOnInvalidPlacement.set(false);
2053                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2054                                              deleteOnInvalidPlacement)) {
2055                                          if (deleteOnInvalidPlacement.get()) {
2056                                              itemsToRemove.add(id);
2057                                          }
2058                                          break;
2059                                      }
2060                                      String providerName = provider.provider.flattenToString();
2061                                      if (!providerName.equals(savedProvider)) {
2062                                          ContentValues values = new ContentValues();
2063                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2064                                                  providerName);
2065                                          String where = BaseColumns._ID + &quot;= ?&quot;;
2066                                          String[] args = {Integer.toString(c.getInt(idIndex))};
2067                                          contentResolver.update(contentUri, values, where, args);
2068                                      }
2069                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2070                                      sBgAppWidgets.add(appWidgetInfo);
2071                                  }
2072                                  break;
2073                              }
2074                          } catch (Exception e) {
2075                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2076                          }
2077                      }
2078                  } finally {
2079                      if (c != null) {
2080                          c.close();
2081                      }
2082                  }
2083  
2084                  // Break early if we&#x27;ve stopped loading
2085                  if (mStopped) {
2086                      clearSBgDataStructures();
2087                      return false;
2088                  }
2089  
2090                  if (itemsToRemove.size() &gt; 0) {
2091                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
2092                              LauncherSettings.Favorites.CONTENT_URI);
2093                      // Remove dead items
2094                      for (long id : itemsToRemove) {
2095                          if (DEBUG_LOADERS) {
2096                              Log.d(TAG, &quot;Removed id = &quot; + id);
2097                          }
2098                          // Don&#x27;t notify content observers
2099                          try {
2100                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2101                                      null, null);
2102                          } catch (RemoteException e) {
2103                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2104                          }
2105                      }
2106                  }
2107  
2108                  if (restoredRows.size() &gt; 0) {
2109                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2110                              LauncherSettings.Favorites.CONTENT_URI);
2111                      // Update restored items that no longer require special handling
2112                      try {
2113                          StringBuilder selectionBuilder = new StringBuilder();
2114                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2115                          selectionBuilder.append(&quot; IN (&quot;);
2116                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2117                          selectionBuilder.append(&quot;)&quot;);
2118                          ContentValues values = new ContentValues();
2119                          values.put(LauncherSettings.Favorites.RESTORED, 0);
2120                          updater.update(LauncherSettings.Favorites.CONTENT_URI,
2121                                  values, selectionBuilder.toString(), null);
2122                      } catch (RemoteException e) {
2123                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2124                      }
2125                  }
2126  
2127                  if (loadedOldDb) {
2128                      long maxScreenId = 0;
2129                      // If we&#x27;re importing we use the old screen order.
2130                      for (ItemInfo item: sBgItemsIdMap.values()) {
2131                          long screenId = item.screenId;
2132                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2133                                  !sBgWorkspaceScreens.contains(screenId)) {
2134                              sBgWorkspaceScreens.add(screenId);
2135                              if (screenId &gt; maxScreenId) {
2136                                  maxScreenId = screenId;
2137                              }
2138                          }
2139                      }
2140                      Collections.sort(sBgWorkspaceScreens);
2141                      // Log to disk
2142                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2143                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2144                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2145  
2146                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2147                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2148  
2149                      // Update the max item id after we load an old db
2150                      long maxItemId = 0;
2151                      // If we&#x27;re importing we use the old screen order.
2152                      for (ItemInfo item: sBgItemsIdMap.values()) {
2153                          maxItemId = Math.max(maxItemId, item.id);
2154                      }
2155                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2156                  } else {
2157                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2158                      for (Integer i : orderedScreens.keySet()) {
2159                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2160                      }
2161                      // Log to disk
2162                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2163                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2164  
2165                      // Remove any empty screens
2166                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2167                      for (ItemInfo item: sBgItemsIdMap.values()) {
2168                          long screenId = item.screenId;
2169                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2170                                  unusedScreens.contains(screenId)) {
2171                              unusedScreens.remove(screenId);
2172                          }
2173                      }
2174  
2175                      // If there are any empty screens remove them, and update.
2176                      if (unusedScreens.size() != 0) {
2177                          // Log to disk
2178                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2179                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2180  
2181                          sBgWorkspaceScreens.removeAll(unusedScreens);
2182                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2183                      }
2184                  }
2185  
2186                  if (DEBUG_LOADERS) {
2187                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2188                      Log.d(TAG, &quot;workspace layout: &quot;);
2189                      int nScreens = occupied.size();
2190                      for (int y = 0; y &lt; countY; y++) {
2191                          String line = &quot;&quot;;
2192  
2193                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2194                          while (iter.hasNext()) {
2195                              long screenId = iter.next();
2196                              if (screenId &gt; 0) {
2197                                  line += &quot; | &quot;;
2198                              }
2199                              for (int x = 0; x &lt; countX; x++) {
2200                                  line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
2201                              }
2202                          }
2203                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2204                      }
2205                  }
2206              }
2207              return loadedOldDb;
2208          }
2209  
2210          /** Filters the set of items who are directly or indirectly (via another container) on the
2211           * specified screen. */
2212          private void filterCurrentWorkspaceItems(long currentScreenId,
2213                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2214                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2215                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2216              // Purge any null ItemInfos
2217              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2218              while (iter.hasNext()) {
2219                  ItemInfo i = iter.next();
2220                  if (i == null) {
2221                      iter.remove();
2222                  }
2223              }
2224  
2225              // Order the set of items by their containers first, this allows use to walk through the
2226              // list sequentially, build up a list of containers that are in the specified screen,
2227              // as well as all items in those containers.
2228              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2229              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2230                  @Override
2231                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2232                      return (int) (lhs.container - rhs.container);
2233                  }
2234              });
2235              for (ItemInfo info : allWorkspaceItems) {
2236                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2237                      if (info.screenId == currentScreenId) {
2238                          currentScreenItems.add(info);
2239                          itemsOnScreen.add(info.id);
2240                      } else {
2241                          otherScreenItems.add(info);
2242                      }
2243                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2244                      currentScreenItems.add(info);
2245                      itemsOnScreen.add(info.id);
2246                  } else {
2247                      if (itemsOnScreen.contains(info.container)) {
2248                          currentScreenItems.add(info);
2249                          itemsOnScreen.add(info.id);
2250                      } else {
2251                          otherScreenItems.add(info);
2252                      }
2253                  }
2254              }
2255          }
2256  
2257          /** Filters the set of widgets which are on the specified screen. */
2258          private void filterCurrentAppWidgets(long currentScreenId,
2259                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2260                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2261                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2262  
2263              for (LauncherAppWidgetInfo widget : appWidgets) {
2264                  if (widget == null) continue;
2265                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2266                          widget.screenId == currentScreenId) {
2267                      currentScreenWidgets.add(widget);
2268                  } else {
2269                      otherScreenWidgets.add(widget);
2270                  }
2271              }
2272          }
2273  
2274          /** Filters the set of folders which are on the specified screen. */
2275          private void filterCurrentFolders(long currentScreenId,
2276                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2277                  HashMap&lt;Long, FolderInfo&gt; folders,
2278                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2279                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2280  
2281              for (long id : folders.keySet()) {
2282                  ItemInfo info = itemsIdMap.get(id);
2283                  FolderInfo folder = folders.get(id);
2284                  if (info == null || folder == null) continue;
2285                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2286                          info.screenId == currentScreenId) {
2287                      currentScreenFolders.put(id, folder);
2288                  } else {
2289                      otherScreenFolders.put(id, folder);
2290                  }
2291              }
2292          }
2293  
2294          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2295           * right) */
2296          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2297              final LauncherAppState app = LauncherAppState.getInstance();
2298              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2299              // XXX: review this
2300              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2301                  @Override
2302                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2303                      int cellCountX = (int) grid.numColumns;
2304                      int cellCountY = (int) grid.numRows;
2305                      int screenOffset = cellCountX * cellCountY;
2306                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2307                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2308                              lhs.cellY * cellCountX + lhs.cellX);
2309                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2310                              rhs.cellY * cellCountX + rhs.cellX);
2311                      return (int) (lr - rr);
2312                  }
2313              });
2314          }
2315  
2316          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2317                  final ArrayList&lt;Long&gt; orderedScreens) {
2318              final Runnable r = new Runnable() {
2319                  @Override
2320                  public void run() {
2321                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2322                      if (callbacks != null) {
2323                          callbacks.bindScreens(orderedScreens);
2324                      }
2325                  }
2326              };
2327              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2328          }
2329  
2330          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2331                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2332                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2333                  final HashMap&lt;Long, FolderInfo&gt; folders,
2334                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2335  
2336              final boolean postOnMainThread = (deferredBindRunnables != null);
2337  
2338              // Bind the workspace items
2339              int N = workspaceItems.size();
2340              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2341                  final int start = i;
2342                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2343                  final Runnable r = new Runnable() {
2344                      @Override
2345                      public void run() {
2346                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2347                          if (callbacks != null) {
2348                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2349                                      false);
2350                          }
2351                      }
2352                  };
2353                  if (postOnMainThread) {
2354                      deferredBindRunnables.add(r);
2355                  } else {
2356                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2357                  }
2358              }
2359  
2360              // Bind the folders
2361              if (!folders.isEmpty()) {
2362                  final Runnable r = new Runnable() {
2363                      public void run() {
2364                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2365                          if (callbacks != null) {
2366                              callbacks.bindFolders(folders);
2367                          }
2368                      }
2369                  };
2370                  if (postOnMainThread) {
2371                      deferredBindRunnables.add(r);
2372                  } else {
2373                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2374                  }
2375              }
2376  
2377              // Bind the widgets, one at a time
2378              N = appWidgets.size();
2379              for (int i = 0; i &lt; N; i++) {
2380                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2381                  final Runnable r = new Runnable() {
2382                      public void run() {
2383                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2384                          if (callbacks != null) {
2385                              callbacks.bindAppWidget(widget);
2386                          }
2387                      }
2388                  };
2389                  if (postOnMainThread) {
2390                      deferredBindRunnables.add(r);
2391                  } else {
2392                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2393                  }
2394              }
2395          }
2396  
2397          /**
2398           * Binds all loaded data to actual views on the main thread.
2399           */
2400          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2401              final long t = SystemClock.uptimeMillis();
2402              Runnable r;
2403  
2404              // Don&#x27;t use these two variables in any of the callback runnables.
2405              // Otherwise we hold a reference to them.
2406              final Callbacks oldCallbacks = mCallbacks.get();
2407              if (oldCallbacks == null) {
2408                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2409                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2410                  return;
2411              }
2412  
2413              // Save a copy of all the bg-thread collections
2414              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2415              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2416                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2417              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2418              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2419              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2420              synchronized (sBgLock) {
2421                  workspaceItems.addAll(sBgWorkspaceItems);
2422                  appWidgets.addAll(sBgAppWidgets);
2423                  folders.putAll(sBgFolders);
2424                  itemsIdMap.putAll(sBgItemsIdMap);
2425                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2426              }
2427  
2428              final boolean isLoadingSynchronously =
2429                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2430              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2431                  oldCallbacks.getCurrentWorkspaceScreen();
2432              if (currScreen &gt;= orderedScreenIds.size()) {
2433                  // There may be no workspace screens (just hotseat items and an empty page).
2434                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2435              }
2436              final int currentScreen = currScreen;
2437              final long currentScreenId = currentScreen &lt; 0
2438                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2439  
2440              // Load all the items that are on the current page first (and in the process, unbind
2441              // all the existing workspace items before we call startBinding() below.
2442              unbindWorkspaceItemsOnMainThread();
2443  
2444              // Separate the items that are on the current screen, and all the other remaining items
2445              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2446              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2447              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2448                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2449              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2450                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2451              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2452              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2453  
2454              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2455                      otherWorkspaceItems);
2456              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2457                      otherAppWidgets);
2458              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2459                      otherFolders);
2460              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2461              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2462  
2463              // Tell the workspace that we&#x27;re about to start binding items
2464              r = new Runnable() {
2465                  public void run() {
2466                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2467                      if (callbacks != null) {
2468                          callbacks.startBinding();
2469                      }
2470                  }
2471              };
2472              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2473  
2474              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2475  
2476              // Load items on the current page
2477              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2478                      currentFolders, null);
2479              if (isLoadingSynchronously) {
2480                  r = new Runnable() {
2481                      public void run() {
2482                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2483                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2484                              callbacks.onPageBoundSynchronously(currentScreen);
2485                          }
2486                      }
2487                  };
2488                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2489              }
2490  
2491              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2492              // work until after the first render)
2493              mDeferredBindRunnables.clear();
2494              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2495                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2496  
2497              // Tell the workspace that we&#x27;re done binding items
2498              r = new Runnable() {
2499                  public void run() {
2500                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2501                      if (callbacks != null) {
2502                          callbacks.finishBindingItems(isUpgradePath);
2503                      }
2504  
2505                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2506                      if (DEBUG_LOADERS) {
2507                          Log.d(TAG, &quot;bound workspace in &quot;
2508                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2509                      }
2510  
2511                      mIsLoadingAndBindingWorkspace = false;
2512                  }
2513              };
2514              if (isLoadingSynchronously) {
2515                  mDeferredBindRunnables.add(r);
2516              } else {
2517                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2518              }
2519          }
2520  
2521          private void loadAndBindAllApps() {
2522              if (DEBUG_LOADERS) {
2523                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2524              }
2525              if (!mAllAppsLoaded) {
2526                  loadAllApps();
2527                  synchronized (LoaderTask.this) {
2528                      if (mStopped) {
2529                          return;
2530                      }
2531                      mAllAppsLoaded = true;
2532                  }
2533              } else {
2534                  onlyBindAllApps();
2535              }
2536          }
2537  
2538          private void onlyBindAllApps() {
2539              final Callbacks oldCallbacks = mCallbacks.get();
2540              if (oldCallbacks == null) {
2541                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2542                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2543                  return;
2544              }
2545  
2546              // shallow copy
2547              @SuppressWarnings(&quot;unchecked&quot;)
2548              final ArrayList&lt;AppInfo&gt; list
2549                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2550              Runnable r = new Runnable() {
2551                  public void run() {
2552                      final long t = SystemClock.uptimeMillis();
2553                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2554                      if (callbacks != null) {
2555                          callbacks.bindAllApplications(list);
2556                      }
2557                      if (DEBUG_LOADERS) {
2558                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2559                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2560                      }
2561                  }
2562              };
2563              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2564              if (isRunningOnMainThread) {
2565                  r.run();
2566              } else {
2567                  mHandler.post(r);
2568              }
2569          }
2570  
2571          private void loadAllApps() {
2572              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2573  
2574              final Callbacks oldCallbacks = mCallbacks.get();
2575              if (oldCallbacks == null) {
2576                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2577                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2578                  return;
2579              }
2580  
2581              final PackageManager packageManager = mContext.getPackageManager();
2582              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2583              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2584  
2585              // Clear the list of apps
2586              mBgAllAppsList.clear();
2587  
2588              // Query for the set of apps
2589              final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2590              List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);
2591              if (DEBUG_LOADERS) {
2592                  Log.d(TAG, &quot;queryIntentActivities took &quot;
2593                          + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2594                  Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);
2595              }
2596              // Fail if we don&#x27;t have any apps
2597              if (apps == null || apps.isEmpty()) {
2598                  return;
2599              }
2600              // Sort the applications by name
2601              final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2602              Collections.sort(apps,
2603                      new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2604              if (DEBUG_LOADERS) {
2605                  Log.d(TAG, &quot;sort took &quot;
2606                          + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2607              }
2608  
2609              // Create the ApplicationInfos
2610              for (int i = 0; i &lt; apps.size(); i++) {
2611                  ResolveInfo app = apps.get(i);
2612                  // This builds the icon bitmaps.
2613                  mBgAllAppsList.add(new AppInfo(packageManager, app,
2614                          mIconCache, mLabelCache));
2615              }
2616  
2617              // Huh? Shouldn&#x27;t this be inside the Runnable below?
2618              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2619              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2620  
2621              // Post callback on main thread
2622              mHandler.post(new Runnable() {
2623                  public void run() {
2624                      final long bindTime = SystemClock.uptimeMillis();
2625                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2626                      if (callbacks != null) {
2627                          callbacks.bindAllApplications(added);
2628                          if (DEBUG_LOADERS) {
2629                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2630                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2631                          }
2632                      } else {
2633                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2634                      }
2635                  }
2636              });
2637  
2638              if (DEBUG_LOADERS) {
2639                  Log.d(TAG, &quot;Icons processed in &quot;
2640                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2641              }
2642          }
2643  
2644          public void dumpState() {
2645              synchronized (sBgLock) {
2646                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2647                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2648                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2649                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2650                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2651              }
2652          }
2653      }
2654  
2655      void enqueuePackageUpdated(PackageUpdatedTask task) {
2656          sWorker.post(task);
2657      }
2658  
2659      private class PackageUpdatedTask implements Runnable {
2660          int mOp;
2661          String[] mPackages;
2662  
2663          public static final int OP_NONE = 0;
2664          public static final int OP_ADD = 1;
2665          public static final int OP_UPDATE = 2;
2666          public static final int OP_REMOVE = 3; // uninstlled
2667          public static final int OP_UNAVAILABLE = 4; // external media unmounted
2668  
2669  
2670          public PackageUpdatedTask(int op, String[] packages) {
2671              mOp = op;
2672              mPackages = packages;
2673          }
2674  
2675          public void run() {
2676              final Context context = mApp.getContext();
2677  
2678              final String[] packages = mPackages;
2679              final int N = packages.length;
2680              switch (mOp) {
2681                  case OP_ADD:
2682                      for (int i=0; i&lt;N; i++) {
2683                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);

2684                          mBgAllAppsList.addPackage(context, packages[i]);
2685                      }
2686                      break;
2687                  case OP_UPDATE:
2688                      for (int i=0; i&lt;N; i++) {
2689                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2690                          mBgAllAppsList.updatePackage(context, packages[i]);
2691                          WidgetPreviewLoader.removePackageFromDb(
2692                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
2693                      }
2694                      break;
2695                  case OP_REMOVE:
2696                  case OP_UNAVAILABLE:
2697                      for (int i=0; i&lt;N; i++) {
2698                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2699                          mBgAllAppsList.removePackage(packages[i]);
2700                          WidgetPreviewLoader.removePackageFromDb(
2701                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
2702                      }
2703                      break;
2704              }
2705  
2706              ArrayList&lt;AppInfo&gt; added = null;
2707              ArrayList&lt;AppInfo&gt; modified = null;
2708              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2709  
2710              if (mBgAllAppsList.added.size() &gt; 0) {
2711                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2712                  mBgAllAppsList.added.clear();
2713              }
2714              if (mBgAllAppsList.modified.size() &gt; 0) {
2715                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2716                  mBgAllAppsList.modified.clear();
2717              }
2718              if (mBgAllAppsList.removed.size() &gt; 0) {
2719                  removedApps.addAll(mBgAllAppsList.removed);
2720                  mBgAllAppsList.removed.clear();
2721              }
2722  
2723              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2724              if (callbacks == null) {
2725                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2726                  return;
2727              }
2728  
2729              if (added != null) {
2730                  // Ensure that we add all the workspace applications to the db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2731 -                if (LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2732 +                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2733 +                if (!LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2734 +                    addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2735 +                } else {</span>
2736                      final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2737 -                    addAndBindAddedWorkspaceApps(context, addedInfos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2738 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2739 -                    addAppsToAllApps(context, added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2740 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2741 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2742 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2743 +                    addAndBindAddedApps(context, addedInfos, cb, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2744 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2745 +            }</span>
2746              if (modified != null) {
2747                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2748  
2749                  // Update the launcher db to reflect the changes
2750                  for (AppInfo a : modifiedFinal) {
2751                      ArrayList&lt;ItemInfo&gt; infos =
2752                              getItemInfoForComponentName(a.componentName);
2753                      for (ItemInfo i : infos) {
2754                          if (isShortcutInfoUpdateable(i)) {
2755                              ShortcutInfo info = (ShortcutInfo) i;
2756                              info.title = a.title.toString();
2757                              updateItemInDatabase(context, info);
2758                          }
2759                      }
2760                  }
2761  
2762                  mHandler.post(new Runnable() {
2763                      public void run() {
2764                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2765                          if (callbacks == cb &amp;&amp; cb != null) {
2766                              callbacks.bindAppsUpdated(modifiedFinal);
2767                          }
2768                      }
2769                  });
2770              }
2771  
2772              final ArrayList&lt;String&gt; removedPackageNames =
2773                      new ArrayList&lt;String&gt;();
2774              if (mOp == OP_REMOVE) {
2775                  // Mark all packages in the broadcast to be removed
2776                  removedPackageNames.addAll(Arrays.asList(packages));
2777              } else if (mOp == OP_UPDATE) {
2778                  // Mark disabled packages in the broadcast to be removed
2779                  final PackageManager pm = context.getPackageManager();
2780                  for (int i=0; i&lt;N; i++) {
2781                      if (isPackageDisabled(pm, packages[i])) {
2782                          removedPackageNames.add(packages[i]);
2783                      }
2784                  }
2785              }
2786              // Remove all the components associated with this package
2787              for (String pn : removedPackageNames) {
2788                  ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);
2789                  for (ItemInfo i : infos) {
2790                      deleteItemFromDatabase(context, i);
2791                  }
2792              }
2793              // Remove all the specific components
2794              for (AppInfo a : removedApps) {
2795                  ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2796                  for (ItemInfo i : infos) {
2797                      deleteItemFromDatabase(context, i);
2798                  }
2799              }
2800              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
2801                  // Remove any queued items from the install queue
2802                  String spKey = LauncherAppState.getSharedPreferencesKey();
2803                  SharedPreferences sp =
2804                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2805                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2806                  // Call the components-removed callback
2807                  mHandler.post(new Runnable() {
2808                      public void run() {
2809                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2810                          if (callbacks == cb &amp;&amp; cb != null) {
2811                              callbacks.bindComponentsRemoved(removedPackageNames, removedApps);
2812                          }
2813                      }
2814                  });
2815              }
2816  
2817              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
2818                  getSortedWidgetsAndShortcuts(context);
2819              mHandler.post(new Runnable() {
2820                  @Override
2821                  public void run() {
2822                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2823                      if (callbacks == cb &amp;&amp; cb != null) {
2824                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2825                      }
2826                  }
2827              });
2828  
2829              // Write all the logs to disk
2830              mHandler.post(new Runnable() {
2831                  public void run() {
2832                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2833                      if (callbacks == cb &amp;&amp; cb != null) {
2834                          callbacks.dumpLogsToLocalData();
2835                      }
2836                  }
2837              });
2838          }
2839      }
2840  
2841      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2842      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2843          PackageManager packageManager = context.getPackageManager();
2844          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2845          widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());
2846          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2847          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2848          Collections.sort(widgetsAndShortcuts,
2849              new LauncherModel.WidgetAndShortcutNameComparator(packageManager));
2850          return widgetsAndShortcuts;
2851      }
2852  
2853      private static boolean isPackageDisabled(PackageManager pm, String packageName) {
2854          try {
2855              PackageInfo pi = pm.getPackageInfo(packageName, 0);
2856              return !pi.applicationInfo.enabled;
2857          } catch (NameNotFoundException e) {
2858              // Fall through
2859          }
2860          return false;
2861      }
2862  
2863      public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {
2864          if (cn == null) {
2865              return false;
2866          }
2867          if (isPackageDisabled(pm, cn.getPackageName())) {
2868              return false;
2869          }
2870  
2871          try {
2872              // Check the activity
2873              PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);
2874              return (pm.getActivityInfo(cn, 0) != null);
2875          } catch (NameNotFoundException e) {
2876              return false;
2877          }
2878      }
2879  
2880      /**
2881       * Make an ShortcutInfo object for a restored application or shortcut item that points
2882       * to a package that is not yet installed on the system.
2883       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2884 -    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2885 +    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
2886          final ShortcutInfo info = new ShortcutInfo();
2887          info.usingFallbackIcon = true;
2888          info.setIcon(getFallbackIcon());
2889          if (cursor != null) {
2890              info.title =  cursor.getString(titleIndex);
2891          } else {
2892              info.title = &quot;&quot;;
2893          }

2894          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2895 -        info.restoredIntent = intent;</span>
2896          return info;
2897      }
2898  
2899      /**
2900       * Make an Intent object for a restored application or shortcut item that points
2901       * to the market page for the item.
2902       */
2903      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2904 -        final boolean debug = false;</span>
2905          ComponentName componentName = intent.getComponent();
2906          Intent marketIntent = new Intent(Intent.ACTION_VIEW);
2907          Uri marketUri = new Uri.Builder()
2908                  .scheme(&quot;market&quot;)
2909                  .authority(&quot;details&quot;)
2910                  .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())
2911                  .build();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2912 -        if (debug) Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2913 +        Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
2914          marketIntent.setData(marketUri);
2915          return marketIntent;
2916      }
2917  
2918      /**
2919       * This is called from the code that adds shortcuts from the intent receiver.  This
2920       * doesn&#x27;t have a Cursor, but
2921       */
2922      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2923          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2924      }
2925  
2926      /**
2927       * Make an ShortcutInfo object for a shortcut that is an application.
2928       *
2929       * If c is not null, then it will be used to fill in missing data like the title and icon.
2930       */
2931      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2932              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2933          ComponentName componentName = intent.getComponent();
2934          final ShortcutInfo info = new ShortcutInfo();
2935          if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {
2936              Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);
2937              return null;
2938          } else {
2939              try {
2940                  PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2941                  info.initFlagsAndFirstInstallTime(pi);
2942              } catch (NameNotFoundException e) {
2943                  Log.d(TAG, &quot;getPackInfo failed for package &quot; +
2944                          componentName.getPackageName());
2945              }
2946          }
2947  
2948          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2949          // then return null &amp; delete this.
2950  
2951          // the resource -- This may implicitly give us back the fallback icon,
2952          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2953          // to avoid saving lots of copies of that in the database, and most apps
2954          // have icons anyway.
2955  
2956          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2957          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2958          // via resolveActivity().
2959          Bitmap icon = null;
2960          ResolveInfo resolveInfo = null;
2961          ComponentName oldComponent = intent.getComponent();
2962          Intent newIntent = new Intent(intent.getAction(), null);
2963          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2964          newIntent.setPackage(oldComponent.getPackageName());
2965          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2966          for (ResolveInfo i : infos) {
2967              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2968                      i.activityInfo.name);
2969              if (cn.equals(oldComponent)) {
2970                  resolveInfo = i;
2971              }
2972          }
2973          if (resolveInfo == null) {
2974              resolveInfo = manager.resolveActivity(intent, 0);
2975          }
2976          if (resolveInfo != null) {
2977              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2978          }
2979          // the db
2980          if (icon == null) {
2981              if (c != null) {
2982                  icon = getIconFromCursor(c, iconIndex, context);
2983              }
2984          }
2985          // the fallback icon
2986          if (icon == null) {
2987              icon = getFallbackIcon();
2988              info.usingFallbackIcon = true;
2989          }
2990          info.setIcon(icon);
2991  
2992          // from the resource
2993          if (resolveInfo != null) {
2994              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2995              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2996                  info.title = labelCache.get(key);
2997              } else {
2998                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2999                  if (labelCache != null) {
3000                      labelCache.put(key, info.title);
3001                  }
3002              }
3003          }
3004          // from the db
3005          if (info.title == null) {
3006              if (c != null) {
3007                  info.title =  c.getString(titleIndex);
3008              }
3009          }
3010          // fall back to the class name of the activity
3011          if (info.title == null) {
3012              info.title = componentName.getClassName();
3013          }
3014          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3015          return info;
3016      }
3017  
3018      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3019              ItemInfoFilter f) {
3020          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3021          for (ItemInfo i : infos) {
3022              if (i instanceof ShortcutInfo) {
3023                  ShortcutInfo info = (ShortcutInfo) i;
3024                  ComponentName cn = info.intent.getComponent();
3025                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3026                      filtered.add(info);
3027                  }
3028              } else if (i instanceof FolderInfo) {
3029                  FolderInfo info = (FolderInfo) i;
3030                  for (ShortcutInfo s : info.contents) {
3031                      ComponentName cn = s.intent.getComponent();
3032                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3033                          filtered.add(s);
3034                      }
3035                  }
3036              } else if (i instanceof LauncherAppWidgetInfo) {
3037                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3038                  ComponentName cn = info.providerName;
3039                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3040                      filtered.add(info);
3041                  }
3042              }
3043          }
3044          return new ArrayList&lt;ItemInfo&gt;(filtered);
3045      }
3046  
3047      private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {
3048          ItemInfoFilter filter  = new ItemInfoFilter() {
3049              @Override
3050              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3051                  return cn.getPackageName().equals(pn);
3052              }
3053          };
3054          return filterItemInfos(sBgItemsIdMap.values(), filter);
3055      }
3056  
3057      private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {
3058          ItemInfoFilter filter  = new ItemInfoFilter() {
3059              @Override
3060              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3061                  return cn.equals(cname);
3062              }
3063          };
3064          return filterItemInfos(sBgItemsIdMap.values(), filter);
3065      }
3066  
3067      public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3068          if (i instanceof ShortcutInfo) {
3069              ShortcutInfo info = (ShortcutInfo) i;
3070              // We need to check for ACTION_MAIN otherwise getComponent() might
3071              // return null for some shortcuts (for instance, for shortcuts to
3072              // web pages.)
3073              Intent intent = info.intent;
3074              ComponentName name = intent.getComponent();
3075              if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3076                      Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3077                  return true;
3078              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3079 -            // placeholder shortcuts get special treatment, let them through too.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3080 -            if (info.getRestoredIntent() != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3081 -                return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3082 -            }</span>
3083          }
3084          return false;
3085      }
3086  
3087      /**
3088       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3089       */
3090      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3091              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3092              int titleIndex) {
3093  
3094          Bitmap icon = null;
3095          final ShortcutInfo info = new ShortcutInfo();
3096          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3097  
3098          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3099  
3100          info.title = c.getString(titleIndex);
3101  
3102          int iconType = c.getInt(iconTypeIndex);
3103          switch (iconType) {
3104          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3105              String packageName = c.getString(iconPackageIndex);
3106              String resourceName = c.getString(iconResourceIndex);
3107              PackageManager packageManager = context.getPackageManager();
3108              info.customIcon = false;
3109              // the resource
3110              try {
3111                  Resources resources = packageManager.getResourcesForApplication(packageName);
3112                  if (resources != null) {
3113                      final int id = resources.getIdentifier(resourceName, null, null);
3114                      icon = Utilities.createIconBitmap(
3115                              mIconCache.getFullResIcon(resources, id), context);
3116                  }
3117              } catch (Exception e) {
3118                  // drop this.  we have other places to look for icons
3119              }
3120              // the db
3121              if (icon == null) {
3122                  icon = getIconFromCursor(c, iconIndex, context);
3123              }
3124              // the fallback icon
3125              if (icon == null) {
3126                  icon = getFallbackIcon();
3127                  info.usingFallbackIcon = true;
3128              }
3129              break;
3130          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3131              icon = getIconFromCursor(c, iconIndex, context);
3132              if (icon == null) {
3133                  icon = getFallbackIcon();
3134                  info.customIcon = false;
3135                  info.usingFallbackIcon = true;
3136              } else {
3137                  info.customIcon = true;
3138              }
3139              break;
3140          default:
3141              icon = getFallbackIcon();
3142              info.usingFallbackIcon = true;
3143              info.customIcon = false;
3144              break;
3145          }
3146          info.setIcon(icon);
3147          return info;
3148      }
3149  
3150      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3151          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3152          final boolean debug = false;
3153          if (debug) {
3154              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3155                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3156          }
3157          byte[] data = c.getBlob(iconIndex);
3158          try {
3159              return Utilities.createIconBitmap(
3160                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3161          } catch (Exception e) {
3162              return null;
3163          }
3164      }
3165  
3166      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3167              int cellX, int cellY, boolean notify) {
3168          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3169          if (info == null) {
3170              return null;
3171          }
3172          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3173  
3174          return info;
3175      }
3176  
3177      /**
3178       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3179       */
3180      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3181              ComponentName component) {
3182          List&lt;AppWidgetProviderInfo&gt; widgets =
3183              AppWidgetManager.getInstance(context).getInstalledProviders();
3184          for (AppWidgetProviderInfo info : widgets) {
3185              if (info.provider.equals(component)) {
3186                  return info;
3187              }
3188          }
3189          return null;
3190      }
3191  
3192      /**
3193       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
3194       */
3195      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
3196          final PackageManager packageManager = context.getPackageManager();
3197          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
3198              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
3199  
3200          final Intent supportsIntent =
3201              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
3202          supportsIntent.setType(mimeType);
3203  
3204          // Create a set of widget configuration components that we can test against
3205          final List&lt;AppWidgetProviderInfo&gt; widgets =
3206              AppWidgetManager.getInstance(context).getInstalledProviders();
3207          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
3208              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
3209          for (AppWidgetProviderInfo info : widgets) {
3210              configurationComponentToWidget.put(info.configure, info);
3211          }
3212  
3213          // Run through each of the intents that can handle this type of clip data, and cross
3214          // reference them with the components that are actual configuration components
3215          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
3216                  PackageManager.MATCH_DEFAULT_ONLY);
3217          for (ResolveInfo info : activities) {
3218              final ActivityInfo activityInfo = info.activityInfo;
3219              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
3220                      activityInfo.name);
3221              if (configurationComponentToWidget.containsKey(infoComponent)) {
3222                  supportedConfigurationActivities.add(
3223                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
3224                                  configurationComponentToWidget.get(infoComponent)));
3225              }
3226          }
3227          return supportedConfigurationActivities;
3228      }
3229  
3230      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3231          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3232          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3233          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3234  
3235          if (intent == null) {
3236              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3237              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3238              return null;
3239          }
3240  
3241          Bitmap icon = null;
3242          boolean customIcon = false;
3243          ShortcutIconResource iconResource = null;
3244  
3245          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3246              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3247              customIcon = true;
3248          } else {
3249              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3250              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3251                  try {
3252                      iconResource = (ShortcutIconResource) extra;
3253                      final PackageManager packageManager = context.getPackageManager();
3254                      Resources resources = packageManager.getResourcesForApplication(
3255                              iconResource.packageName);
3256                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3257                      icon = Utilities.createIconBitmap(
3258                              mIconCache.getFullResIcon(resources, id), context);
3259                  } catch (Exception e) {
3260                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3261                  }
3262              }
3263          }
3264  
3265          final ShortcutInfo info = new ShortcutInfo();
3266  
3267          if (icon == null) {
3268              if (fallbackIcon != null) {
3269                  icon = fallbackIcon;
3270              } else {
3271                  icon = getFallbackIcon();
3272                  info.usingFallbackIcon = true;
3273              }
3274          }
3275          info.setIcon(icon);
3276  
3277          info.title = name;
3278          info.intent = intent;
3279          info.customIcon = customIcon;
3280          info.iconResource = iconResource;
3281  
3282          return info;
3283      }
3284  
3285      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3286              int iconIndex) {
3287          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3288          if (!mAppsCanBeOnRemoveableStorage) {
3289              return false;
3290          }
3291          // If this icon doesn&#x27;t have a custom icon, check to see
3292          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3293          // we&#x27;re going to show, store what we are going to show back
3294          // into the DB.  We do this so when we&#x27;re loading, if the
3295          // package manager can&#x27;t find an icon (for example because
3296          // the app is on SD) then we can use that instead.
3297          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3298              cache.put(info, c.getBlob(iconIndex));
3299              return true;
3300          }
3301          return false;
3302      }
3303      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3304          boolean needSave = false;
3305          try {
3306              if (data != null) {
3307                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3308                  Bitmap loaded = info.getIcon(mIconCache);
3309                  needSave = !saved.sameAs(loaded);
3310              } else {
3311                  needSave = true;
3312              }
3313          } catch (Exception e) {
3314              needSave = true;
3315          }
3316          if (needSave) {
3317              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3318              // This is slower than is ideal, but this only happens once
3319              // or when the app is updated with a new icon.
3320              updateItemInDatabase(context, info);
3321          }
3322      }
3323  
3324      /**
3325       * Return an existing FolderInfo object if we have encountered this ID previously,
3326       * or make a new one.
3327       */
3328      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3329          // See if a placeholder was created for us already
3330          FolderInfo folderInfo = folders.get(id);
3331          if (folderInfo == null) {
3332              // No placeholder -- create a new instance
3333              folderInfo = new FolderInfo();
3334              folders.put(id, folderInfo);
3335          }
3336          return folderInfo;
3337      }
3338  
3339      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3340          final Collator collator = Collator.getInstance();
3341          return new Comparator&lt;AppInfo&gt;() {
3342              public final int compare(AppInfo a, AppInfo b) {
3343                  int result = collator.compare(a.title.toString().trim(),
3344                          b.title.toString().trim());
3345                  if (result == 0) {
3346                      result = a.componentName.compareTo(b.componentName);
3347                  }
3348                  return result;
3349              }
3350          };
3351      }
3352      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3353              = new Comparator&lt;AppInfo&gt;() {
3354          public final int compare(AppInfo a, AppInfo b) {
3355              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3356              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3357              return 0;
3358          }
3359      };
3360      public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {
3361          final Collator collator = Collator.getInstance();
3362          return new Comparator&lt;AppWidgetProviderInfo&gt;() {
3363              public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
3364                  return collator.compare(a.label.toString().trim(), b.label.toString().trim());
3365              }
3366          };
3367      }
3368      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3369          if (info.activityInfo != null) {
3370              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3371          } else {
3372              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3373          }
3374      }
3375      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
3376          private Collator mCollator;
3377          private PackageManager mPackageManager;
3378          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3379          ShortcutNameComparator(PackageManager pm) {
3380              mPackageManager = pm;
3381              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3382              mCollator = Collator.getInstance();
3383          }
3384          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
3385              mPackageManager = pm;
3386              mLabelCache = labelCache;
3387              mCollator = Collator.getInstance();
3388          }
3389          public final int compare(ResolveInfo a, ResolveInfo b) {
3390              CharSequence labelA, labelB;
3391              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
3392              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
3393              if (mLabelCache.containsKey(keyA)) {
3394                  labelA = mLabelCache.get(keyA);
3395              } else {
3396                  labelA = a.loadLabel(mPackageManager).toString().trim();
3397  
3398                  mLabelCache.put(keyA, labelA);
3399              }
3400              if (mLabelCache.containsKey(keyB)) {
3401                  labelB = mLabelCache.get(keyB);
3402              } else {
3403                  labelB = b.loadLabel(mPackageManager).toString().trim();
3404  
3405                  mLabelCache.put(keyB, labelB);
3406              }
3407              return mCollator.compare(labelA, labelB);
3408          }
3409      };
3410      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3411          private Collator mCollator;
3412          private PackageManager mPackageManager;
3413          private HashMap&lt;Object, String&gt; mLabelCache;
3414          WidgetAndShortcutNameComparator(PackageManager pm) {
3415              mPackageManager = pm;
3416              mLabelCache = new HashMap&lt;Object, String&gt;();
3417              mCollator = Collator.getInstance();
3418          }
3419          public final int compare(Object a, Object b) {
3420              String labelA, labelB;
3421              if (mLabelCache.containsKey(a)) {
3422                  labelA = mLabelCache.get(a);
3423              } else {
3424                  labelA = (a instanceof AppWidgetProviderInfo) ?
3425                      ((AppWidgetProviderInfo) a).label :
3426                      ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3427                  mLabelCache.put(a, labelA);
3428              }
3429              if (mLabelCache.containsKey(b)) {
3430                  labelB = mLabelCache.get(b);
3431              } else {
3432                  labelB = (b instanceof AppWidgetProviderInfo) ?
3433                      ((AppWidgetProviderInfo) b).label :
3434                      ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3435                  mLabelCache.put(b, labelB);
3436              }
3437              return mCollator.compare(labelA, labelB);
3438          }
3439      };
3440  
3441      public void dumpState() {
3442          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3443          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3444          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3445          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3446          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3447          if (mLoaderTask != null) {
3448              mLoaderTask.dumpState();
3449          } else {
3450              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3451          }
3452      }
3453  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.*;
  23  import android.content.Intent.ShortcutIconResource;
  24  import android.content.pm.ActivityInfo;
  25  import android.content.pm.PackageInfo;
  26  import android.content.pm.PackageManager;
  27  import android.content.pm.PackageManager.NameNotFoundException;
  28  import android.content.pm.ResolveInfo;
  29  import android.content.res.Configuration;
  30  import android.content.res.Resources;
  31  import android.database.Cursor;
  32  import android.graphics.Bitmap;
  33  import android.graphics.BitmapFactory;
  34  import android.net.Uri;
  35  import android.os.Environment;
  36  import android.os.Handler;
  37  import android.os.HandlerThread;
  38  import android.os.Parcelable;
  39  import android.os.Process;
  40  import android.os.RemoteException;
  41  import android.os.SystemClock;
  42  import android.provider.BaseColumns;
  43  import android.text.TextUtils;
  44  import android.util.Log;
  45  import android.util.Pair;
  46  
  47  import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;
  48  
  49  import java.lang.ref.WeakReference;
  50  import java.net.URISyntaxException;
  51  import java.text.Collator;
  52  import java.util.ArrayList;
  53  import java.util.Arrays;
  54  import java.util.Collection;
  55  import java.util.Collections;
  56  import java.util.Comparator;
  57  import java.util.HashMap;
  58  import java.util.HashSet;
  59  import java.util.Iterator;
  60  import java.util.List;
  61  import java.util.Set;
  62  import java.util.TreeMap;
  63  import java.util.concurrent.atomic.AtomicBoolean;
  64  
  65  /**
  66   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  67   * LauncherModel object held in a static. Also provide APIs for updating the database state
  68   * for the Launcher.
  69   */
  70  public class LauncherModel extends BroadcastReceiver {
  71      static final boolean DEBUG_LOADERS = false;
  72      static final String TAG = &quot;Launcher.Model&quot;;
  73  
  74      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  75      // false = strew non-workspace apps across the workspace on upgrade
  76      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  77  
  78      public static final int LOADER_FLAG_NONE = 0;
  79      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  80      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  81  
  82      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  83      private static final long INVALID_SCREEN_ID = -1L;
  84  
  85      private final boolean mAppsCanBeOnRemoveableStorage;
  86      private final boolean mOldContentProviderExists;
  87  
  88      private final LauncherAppState mApp;
  89      private final Object mLock = new Object();
  90      private DeferredHandler mHandler = new DeferredHandler();
  91      private LoaderTask mLoaderTask;
  92      private boolean mIsLoaderTaskRunning;
  93      private volatile boolean mFlushingWorkerThread;
  94  
  95      // Specific runnable types that are run on the main thread deferred handler, this allows us to
  96      // clear all queued binding runnables when the Launcher activity is destroyed.
  97      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
  98      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
  99  
 100  
 101      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 102      static {
 103          sWorkerThread.start();
 104      }
 105      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 106  
 107      // We start off with everything not loaded.  After that, we assume that
 108      // our monitoring of the package manager provides all updates and we never
 109      // need to do a requery.  These are only ever touched from the loader thread.
 110      private boolean mWorkspaceLoaded;
 111      private boolean mAllAppsLoaded;
 112  
 113      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 114      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 115      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 116      // a normal load, we also clear this set of Runnables.
 117      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 118  
 119      private WeakReference&lt;Callbacks&gt; mCallbacks;
 120  
 121      // &lt; only access in worker thread &gt;
 122      AllAppsList mBgAllAppsList;
 123  
 124      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 125      // other locks, this one can generally be held long-term because we never expect any of these
 126      // static data structures to be referenced outside of the worker thread except on the first
 127      // load after configuration change.
 128      static final Object sBgLock = new Object();
 129  
 130      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 131      // LauncherModel to their ids
 132      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 133  
 134      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 135      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 136      //       shortcuts within folders).
 137      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 138  
 139      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 140      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 141          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 142  
 143      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 144      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 145  
 146      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 147      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 148  
 149      // sBgWorkspaceScreens is the ordered set of workspace screens.
 150      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 151  
 152      // &lt;/ only access in worker thread &gt;
 153  
 154      private IconCache mIconCache;
 155      private Bitmap mDefaultIcon;
 156  
 157      protected int mPreviousConfigMcc;
 158  
 159      public interface Callbacks {
 160          public boolean setLoadOnResume();
 161          public int getCurrentWorkspaceScreen();
 162          public void startBinding();
 163          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 164                                boolean forceAnimateIcons);
 165          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 166          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 167          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 168          public void finishBindingItems(boolean upgradePath);
 169          public void bindAppWidget(LauncherAppWidgetInfo info);
 170          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 171          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 172                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 173                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 174                                    ArrayList&lt;AppInfo&gt; addedApps);
 175          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 176          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 177                          ArrayList&lt;AppInfo&gt; appInfos);
 178          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 179          public void bindSearchablesChanged();
 180          public boolean isAllAppsButtonRank(int rank);
 181          public void onPageBoundSynchronously(int page);
 182          public void dumpLogsToLocalData();
 183      }
 184  
 185      public interface ItemInfoFilter {
 186          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 187      }
 188  
 189      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 190          Context context = app.getContext();
 191          ContentResolver contentResolver = context.getContentResolver();
 192  
 193          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 194          mOldContentProviderExists = (contentResolver.acquireContentProviderClient(
 195                  LauncherSettings.Favorites.OLD_CONTENT_URI) != null);
 196          mApp = app;
 197          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 198          mIconCache = iconCache;
 199  
 200          final Resources res = context.getResources();
 201          Configuration config = res.getConfiguration();
 202          mPreviousConfigMcc = config.mcc;
 203      }
 204  
 205      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 206       * posted on the main thread handler. */
 207      private void runOnMainThread(Runnable r) {
 208          runOnMainThread(r, 0);
 209      }
 210      private void runOnMainThread(Runnable r, int type) {
 211          if (sWorkerThread.getThreadId() == Process.myTid()) {
 212              // If we are on the worker thread, post onto the main handler
 213              mHandler.post(r);
 214          } else {
 215              r.run();
 216          }
 217      }
 218  
 219      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 220       * posted on the worker thread handler. */
 221      private static void runOnWorkerThread(Runnable r) {
 222          if (sWorkerThread.getThreadId() == Process.myTid()) {
 223              r.run();
 224          } else {
 225              // If we are not on the worker thread, then post to the worker handler
 226              sWorker.post(r);
 227          }
 228      }
 229  
 230      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 231          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 232      }
 233  
 234      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 235                                   long screen) {
 236          LauncherAppState app = LauncherAppState.getInstance();
 237          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 238          final int xCount = (int) grid.numColumns;
 239          final int yCount = (int) grid.numRows;
 240          boolean[][] occupied = new boolean[xCount][yCount];
 241  
 242          int cellX, cellY, spanX, spanY;
 243          for (int i = 0; i &lt; items.size(); ++i) {
 244              final ItemInfo item = items.get(i);
 245              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 246                  if (item.screenId == screen) {
 247                      cellX = item.cellX;
 248                      cellY = item.cellY;
 249                      spanX = item.spanX;
 250                      spanY = item.spanY;
 251                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 252                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 253                              occupied[x][y] = true;
 254                          }
 255                      }
 256                  }
 257              }
 258          }
 259  
 260          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 261      }
 262      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 263                                                          Intent launchIntent,
 264                                                          int firstScreenIndex,
 265                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 266          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 267          LauncherAppState app = LauncherAppState.getInstance();
 268          LauncherModel model = app.getModel();
 269          boolean found = false;
 270          synchronized (app) {
 271              if (sWorkerThread.getThreadId() != Process.myTid()) {
 272                  // Flush the LauncherModel worker thread, so that if we just did another
 273                  // processInstallShortcut, we give it time for its shortcut to get added to the
 274                  // database (getItemsInLocalCoordinates reads the database)
 275                  model.flushWorkerThread();
 276              }
 277              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 278  
 279              // Try adding to the workspace screens incrementally, starting at the default or center
 280              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 281              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 282              int count = workspaceScreens.size();
 283              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 284                  int[] tmpCoordinates = new int[2];
 285                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 286                          workspaceScreens.get(screen))) {
 287                      // Update the Launcher db
 288                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 289                  }
 290              }
 291          }
 292          return null;
 293      }
 294  
 295      public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 296          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 297  
 298          if (allAppsApps == null) {
 299              throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 300          }
 301          if (allAppsApps.isEmpty()) {
 302              return;
 303          }
 304  
 305          final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 306          Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 307          while (iter.hasNext()) {
 308              ItemInfo a = iter.next();
 309              if (LauncherModel.appWasRestored(ctx, a.getIntent())) {
 310                  restoredAppsFinal.add((AppInfo) a);
 311              }
 312          }
 313  
 314          // Process the newly added applications and add them to the database first
 315          Runnable r = new Runnable() {
 316              public void run() {
 317                  runOnMainThread(new Runnable() {
 318                      public void run() {
 319                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 320                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 321 -                            callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
 322                              if (!restoredAppsFinal.isEmpty()) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +                                for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +                                    final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +                                    if (intent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +                                        mIconCache.deletePreloadedIcon(intent.getComponent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +                                }</span>
 329                                  callbacks.bindAppsUpdated(restoredAppsFinal);
 330                              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +                            callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
 332                          }
 333                      }
 334                  });
 335              }
 336          };
 337          runOnWorkerThread(r);
 338      }
 339  
 340      public void addAndBindAddedWorkspaceApps(final Context context,
 341              final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 342          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 343  
 344          if (workspaceApps == null) {








 345              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 346          }
 347          if (workspaceApps.isEmpty()) {

 348              return;
 349          }
 350          // Process the newly added applications and add them to the database first
 351          Runnable r = new Runnable() {
 352              public void run() {
 353                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 354                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 355                  final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 356  
 357                  // Get the list of workspace screens.  We need to append to this list and
 358                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 359                  // called.
 360                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 361                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 362                  for (Integer i : orderedScreens.keySet()) {
 363                      long screenId = orderedScreens.get(i);
 364                      workspaceScreens.add(screenId);
 365                  }
 366  
 367                  synchronized(sBgLock) {
 368                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 369                      while (iter.hasNext()) {
 370                          ItemInfo a = iter.next();
 371                          final String name = a.title.toString();
 372                          final Intent launchIntent = a.getIntent();
 373  
 374                          // Short-circuit this logic if the icon exists somewhere on the workspace
 375                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 376                              // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 377                              if (a instanceof AppInfo &amp;&amp;
 378                                      LauncherModel.appWasRestored(context, launchIntent)) {
 379                                  restoredAppsFinal.add((AppInfo) a);
 380                              }
 381                              continue;
 382                          }
 383  
 384                          // Add this icon to the db, creating a new page if necessary.  If there
 385                          // is only the empty page then we just add items to the first page.
 386                          // Otherwise, we add them to the next pages.
 387                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 388                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 389                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 390                          if (coords == null) {
 391                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 392  
 393                              // If we can&#x27;t find a valid position, then just add a new screen.
 394                              // This takes time so we need to re-queue the add until the new
 395                              // page is added.  Create as many screens as necessary to satisfy
 396                              // the startSearchPageIndex.
 397                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 398                                      workspaceScreens.size());
 399                              while (numPagesToAdd &gt; 0) {
 400                                  long screenId = lp.generateNewScreenId();
 401                                  // Save the screen id for binding in the workspace
 402                                  workspaceScreens.add(screenId);
 403                                  addedWorkspaceScreensFinal.add(screenId);
 404                                  numPagesToAdd--;
 405                              }
 406  
 407                              // Find the coordinate again
 408                              coords = LauncherModel.findNextAvailableIconSpace(context,
 409                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 410                          }
 411                          if (coords == null) {
 412                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 413                          }
 414  
 415                          ShortcutInfo shortcutInfo;
 416                          if (a instanceof ShortcutInfo) {
 417                              shortcutInfo = (ShortcutInfo) a;
 418                          } else if (a instanceof AppInfo) {
 419                              shortcutInfo = ((AppInfo) a).makeShortcut();
 420                          } else {
 421                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 422                          }
 423  
 424                          // Add the shortcut to the db
 425                          addItemToDatabase(context, shortcutInfo,
 426                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 427                                  coords.first, coords.second[0], coords.second[1], false);
 428                          // Save the ShortcutInfo for binding in the workspace
 429                          addedShortcutsFinal.add(shortcutInfo);
 430                      }
 431                  }
 432  
 433                  // Update the workspace screens
 434                  updateWorkspaceScreenOrder(context, workspaceScreens);
 435  
 436                  if (!addedShortcutsFinal.isEmpty()) {

 437                      runOnMainThread(new Runnable() {
 438                          public void run() {
 439                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 440                              if (callbacks == cb &amp;&amp; cb != null) {
 441                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 442                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 443                                  if (!addedShortcutsFinal.isEmpty()) {
 444                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 445                                      long lastScreenId = info.screenId;
 446                                      for (ItemInfo i : addedShortcutsFinal) {
 447                                          if (i.screenId == lastScreenId) {
 448                                              addAnimated.add(i);
 449                                          } else {
 450                                              addNotAnimated.add(i);
 451                                          }
 452                                      }
 453                                  }
 454                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 455                                          addNotAnimated, addAnimated, null);
 456                                  if (!restoredAppsFinal.isEmpty()) {
 457                                      callbacks.bindAppsUpdated(restoredAppsFinal);
 458                                  }

 459                              }
 460                          }
 461                      });
 462                  }
 463              }
 464          };
 465          runOnWorkerThread(r);
 466      }
 467  
 468      public Bitmap getFallbackIcon() {
 469          if (mDefaultIcon == null) {
 470              final Context context = LauncherAppState.getInstance().getContext();
 471              mDefaultIcon = Utilities.createIconBitmap(
 472                      mIconCache.getFullResDefaultActivityIcon(), context);
 473          }
 474          return Bitmap.createBitmap(mDefaultIcon);
 475      }
 476  
 477      public void unbindItemInfosAndClearQueuedBindRunnables() {
 478          if (sWorkerThread.getThreadId() == Process.myTid()) {
 479              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 480                      &quot;main thread&quot;);
 481          }
 482  
 483          // Clear any deferred bind runnables
 484          mDeferredBindRunnables.clear();
 485          // Remove any queued bind runnables
 486          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 487          // Unbind all the workspace items
 488          unbindWorkspaceItemsOnMainThread();
 489      }
 490  
 491      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 492      void unbindWorkspaceItemsOnMainThread() {
 493          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 494          // by making a copy of workspace items first.
 495          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 496          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 497          synchronized (sBgLock) {
 498              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 499              tmpAppWidgets.addAll(sBgAppWidgets);
 500          }
 501          Runnable r = new Runnable() {
 502                  @Override
 503                  public void run() {
 504                     for (ItemInfo item : tmpWorkspaceItems) {
 505                         item.unbind();
 506                     }
 507                     for (ItemInfo item : tmpAppWidgets) {
 508                         item.unbind();
 509                     }
 510                  }
 511              };
 512          runOnMainThread(r);
 513      }
 514  
 515      /**
 516       * Adds an item to the DB if it was not created previously, or move it to a new
 517       * &lt;container, screen, cellX, cellY&gt;
 518       */
 519      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 520              long screenId, int cellX, int cellY) {
 521          if (item.container == ItemInfo.NO_ID) {
 522              // From all apps
 523              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 524          } else {
 525              // From somewhere else
 526              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 527          }
 528      }
 529  
 530      static void checkItemInfoLocked(
 531              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 532          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 533          if (modelItem != null &amp;&amp; item != modelItem) {
 534              // check all the data is consistent
 535              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 536                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 537                  ShortcutInfo shortcut = (ShortcutInfo) item;
 538                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 539                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 540                          modelShortcut.id == shortcut.id &amp;&amp;
 541                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 542                          modelShortcut.container == shortcut.container &amp;&amp;
 543                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 544                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 545                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 546                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 547                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 548                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 549                          (modelShortcut.dropPos != null &amp;&amp;
 550                                  shortcut.dropPos != null &amp;&amp;
 551                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 552                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 553                      // For all intents and purposes, this is the same object
 554                      return;
 555                  }
 556              }
 557  
 558              // the modelItem needs to match up perfectly with item if our model is
 559              // to be consistent with the database-- for now, just require
 560              // modelItem == item or the equality check above
 561              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 562                      &quot;modelItem: &quot; +
 563                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 564                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 565              RuntimeException e = new RuntimeException(msg);
 566              if (stackTrace != null) {
 567                  e.setStackTrace(stackTrace);
 568              }
 569              throw e;
 570          }
 571      }
 572  
 573      static void checkItemInfo(final ItemInfo item) {
 574          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 575          final long itemId = item.id;
 576          Runnable r = new Runnable() {
 577              public void run() {
 578                  synchronized (sBgLock) {
 579                      checkItemInfoLocked(itemId, item, stackTrace);
 580                  }
 581              }
 582          };
 583          runOnWorkerThread(r);
 584      }
 585  
 586      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 587              final ItemInfo item, final String callingFunction) {
 588          final long itemId = item.id;
 589          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 590          final ContentResolver cr = context.getContentResolver();
 591  
 592          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 593          Runnable r = new Runnable() {
 594              public void run() {
 595                  cr.update(uri, values, null, null);
 596                  updateItemArrays(item, itemId, stackTrace);
 597              }
 598          };
 599          runOnWorkerThread(r);
 600      }
 601  
 602      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 603              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 604          final ContentResolver cr = context.getContentResolver();
 605  
 606          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 607          Runnable r = new Runnable() {
 608              public void run() {
 609                  ArrayList&lt;ContentProviderOperation&gt; ops =
 610                          new ArrayList&lt;ContentProviderOperation&gt;();
 611                  int count = items.size();
 612                  for (int i = 0; i &lt; count; i++) {
 613                      ItemInfo item = items.get(i);
 614                      final long itemId = item.id;
 615                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 616                      ContentValues values = valuesList.get(i);
 617  
 618                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 619                      updateItemArrays(item, itemId, stackTrace);
 620  
 621                  }
 622                  try {
 623                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 624                  } catch (Exception e) {
 625                      e.printStackTrace();
 626                  }
 627              }
 628          };
 629          runOnWorkerThread(r);
 630      }
 631  
 632      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 633          // Lock on mBgLock *after* the db operation
 634          synchronized (sBgLock) {
 635              checkItemInfoLocked(itemId, item, stackTrace);
 636  
 637              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 638                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 639                  // Item is in a folder, make sure this folder exists
 640                  if (!sBgFolders.containsKey(item.container)) {
 641                      // An items container is being set to a that of an item which is not in
 642                      // the list of Folders.
 643                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 644                              item.container + &quot;, not in the list of folders&quot;;
 645                      Log.e(TAG, msg);
 646                  }
 647              }
 648  
 649              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 650              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 651              // that are on the desktop, as appropriate
 652              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 653              if (modelItem != null &amp;&amp;
 654                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 655                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 656                  switch (modelItem.itemType) {
 657                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 658                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 659                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 660                          if (!sBgWorkspaceItems.contains(modelItem)) {
 661                              sBgWorkspaceItems.add(modelItem);
 662                          }
 663                          break;
 664                      default:
 665                          break;
 666                  }
 667              } else {
 668                  sBgWorkspaceItems.remove(modelItem);
 669              }
 670          }
 671      }
 672  
 673      public void flushWorkerThread() {
 674          mFlushingWorkerThread = true;
 675          Runnable waiter = new Runnable() {
 676                  public void run() {
 677                      synchronized (this) {
 678                          notifyAll();
 679                          mFlushingWorkerThread = false;
 680                      }
 681                  }
 682              };
 683  
 684          synchronized(waiter) {
 685              runOnWorkerThread(waiter);
 686              if (mLoaderTask != null) {
 687                  synchronized(mLoaderTask) {
 688                      mLoaderTask.notify();
 689                  }
 690              }
 691              boolean success = false;
 692              while (!success) {
 693                  try {
 694                      waiter.wait();
 695                      success = true;
 696                  } catch (InterruptedException e) {
 697                  }
 698              }
 699          }
 700      }
 701  
 702      /**
 703       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 704       */
 705      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 706              final long screenId, final int cellX, final int cellY) {
 707          item.container = container;
 708          item.cellX = cellX;
 709          item.cellY = cellY;
 710  
 711          // We store hotseat items in canonical form which is this orientation invariant position
 712          // in the hotseat
 713          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 714                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 715              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 716          } else {
 717              item.screenId = screenId;
 718          }
 719  
 720          final ContentValues values = new ContentValues();
 721          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 722          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 723          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 724          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 725  
 726          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 727      }
 728  
 729      /**
 730       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 731       * cellX, cellY have already been updated on the ItemInfos.
 732       */
 733      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 734              final long container, final int screen) {
 735  
 736          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 737          int count = items.size();
 738  
 739          for (int i = 0; i &lt; count; i++) {
 740              ItemInfo item = items.get(i);
 741              item.container = container;
 742  
 743              // We store hotseat items in canonical form which is this orientation invariant position
 744              // in the hotseat
 745              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 746                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 747                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 748                          item.cellY);
 749              } else {
 750                  item.screenId = screen;
 751              }
 752  
 753              final ContentValues values = new ContentValues();
 754              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 755              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 756              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 757              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 758  
 759              contentValues.add(values);
 760          }
 761          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 762      }
 763  
 764      /**
 765       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 766       */
 767      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 768              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 769          item.container = container;
 770          item.cellX = cellX;
 771          item.cellY = cellY;
 772          item.spanX = spanX;
 773          item.spanY = spanY;
 774  
 775          // We store hotseat items in canonical form which is this orientation invariant position
 776          // in the hotseat
 777          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 778                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 779              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 780          } else {
 781              item.screenId = screenId;
 782          }
 783  
 784          final ContentValues values = new ContentValues();
 785          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 786          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 787          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 788          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 789          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 790          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 791  
 792          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 793      }
 794  
 795      /**
 796       * Update an item to the database in a specified container.
 797       */
 798      static void updateItemInDatabase(Context context, final ItemInfo item) {
 799          final ContentValues values = new ContentValues();
 800          item.onAddToDatabase(values);
 801          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 802          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 803      }
 804  
 805      /**
 806       * Returns true if the shortcuts already exists in the database.
 807       * we identify a shortcut by its title and intent.
 808       */
 809      static boolean shortcutExists(Context context, String title, Intent intent) {
 810          final ContentResolver cr = context.getContentResolver();
 811          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 812              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,
 813              new String[] { title, intent.toUri(0) }, null);
 814          boolean result = false;
 815          try {
 816              result = c.moveToFirst();
 817          } finally {
 818              c.close();
 819          }
 820          return result;
 821      }
 822  
 823      /**
 824       * Returns true if the shortcuts already exists in the database.
 825       * we identify a shortcut by the component name of the intent.
 826       */
 827      static boolean appWasRestored(Context context, Intent intent) {
 828          final ContentResolver cr = context.getContentResolver();
 829          final ComponentName component = intent.getComponent();
 830          if (component == null) {
 831              return false;
 832          }
 833          String componentName = component.flattenToString();
 834          final String where = &quot;intent glob \&quot;*component=&quot; + componentName + &quot;*\&quot; and restored = 1&quot;;
 835          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 836                  new String[]{&quot;intent&quot;, &quot;restored&quot;}, where, null, null);
 837          boolean result = false;
 838          try {
 839              result = c.moveToFirst();
 840          } finally {
 841              c.close();
 842          }
 843          Log.d(TAG, &quot;shortcutWasRestored is &quot; + result + &quot; for &quot; + componentName);
 844          return result;
 845      }
 846  
 847      /**
 848       * Returns an ItemInfo array containing all the items in the LauncherModel.
 849       * The ItemInfo.id is not set through this function.
 850       */
 851      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 852          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 853          final ContentResolver cr = context.getContentResolver();
 854          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 855                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<abbr title=" 856                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 856                  LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CEðŸ”µ</abbr>
 857                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);
 858  
 859          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 860          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 861          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 862          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 863          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 864          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 865          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 866  
 867          try {
 868              while (c.moveToNext()) {
 869                  ItemInfo item = new ItemInfo();
 870                  item.cellX = c.getInt(cellXIndex);
 871                  item.cellY = c.getInt(cellYIndex);
 872                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 873                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 874                  item.container = c.getInt(containerIndex);
 875                  item.itemType = c.getInt(itemTypeIndex);
 876                  item.screenId = c.getInt(screenIndex);
 877  
 878                  items.add(item);
 879              }
 880          } catch (Exception e) {
 881              items.clear();
 882          } finally {
 883              c.close();
 884          }
 885  
 886          return items;
 887      }
 888  
 889      /**
 890       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 891       */
 892      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 893          final ContentResolver cr = context.getContentResolver();
 894          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 895                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 896                  new String[] { String.valueOf(id),
 897                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 898  
 899          try {
 900              if (c.moveToFirst()) {
 901                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 902                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 903                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 904                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 905                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 906                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 907  
 908                  FolderInfo folderInfo = null;
 909                  switch (c.getInt(itemTypeIndex)) {
 910                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 911                          folderInfo = findOrMakeFolder(folderList, id);
 912                          break;
 913                  }
 914  
 915                  folderInfo.title = c.getString(titleIndex);
 916                  folderInfo.id = id;
 917                  folderInfo.container = c.getInt(containerIndex);
 918                  folderInfo.screenId = c.getInt(screenIndex);
 919                  folderInfo.cellX = c.getInt(cellXIndex);
 920                  folderInfo.cellY = c.getInt(cellYIndex);
 921  
 922                  return folderInfo;
 923              }
 924          } finally {
 925              c.close();
 926          }
 927  
 928          return null;
 929      }
 930  
 931      /**
 932       * Add an item to the database in a specified container. Sets the container, screen, cellX and
 933       * cellY fields of the item. Also assigns an ID to the item.
 934       */
 935      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 936              final long screenId, final int cellX, final int cellY, final boolean notify) {
 937          item.container = container;
 938          item.cellX = cellX;
 939          item.cellY = cellY;
 940          // We store hotseat items in canonical form which is this orientation invariant position
 941          // in the hotseat
 942          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 943                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 944              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 945          } else {
 946              item.screenId = screenId;
 947          }
 948  
 949          final ContentValues values = new ContentValues();
 950          final ContentResolver cr = context.getContentResolver();
 951          item.onAddToDatabase(values);
 952  
 953          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 954          values.put(LauncherSettings.Favorites._ID, item.id);
 955          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 956  
 957          Runnable r = new Runnable() {
 958              public void run() {
 959                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
 960                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 961  
 962                  // Lock on mBgLock *after* the db operation
 963                  synchronized (sBgLock) {
 964                      checkItemInfoLocked(item.id, item, null);
 965                      sBgItemsIdMap.put(item.id, item);
 966                      switch (item.itemType) {
 967                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 968                              sBgFolders.put(item.id, (FolderInfo) item);
 969                              // Fall through
 970                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 971                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 972                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 973                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 974                                  sBgWorkspaceItems.add(item);
 975                              } else {
 976                                  if (!sBgFolders.containsKey(item.container)) {
 977                                      // Adding an item to a folder that doesn&#x27;t exist.
 978                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
 979                                              &quot; doesn&#x27;t exist&quot;;
 980                                      Log.e(TAG, msg);
 981                                  }
 982                              }
 983                              break;
 984                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
 985                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
 986                              break;
 987                      }
 988                  }
 989              }
 990          };
 991          runOnWorkerThread(r);
 992      }
 993  
 994      /**
 995       * Creates a new unique child id, for a given cell span across all layouts.
 996       */
 997      static int getCellLayoutChildId(
 998              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
 999          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1000                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1001      }
1002  
1003      /**
1004       * Removes the specified item from the database
1005       * @param context
1006       * @param item
1007       */
1008      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1009          final ContentResolver cr = context.getContentResolver();
1010          final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);
1011  
1012          Runnable r = new Runnable() {
1013              public void run() {
1014                  cr.delete(uriToDelete, null, null);
1015  
1016                  // Lock on mBgLock *after* the db operation
1017                  synchronized (sBgLock) {
1018                      switch (item.itemType) {
1019                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1020                              sBgFolders.remove(item.id);
1021                              for (ItemInfo info: sBgItemsIdMap.values()) {
1022                                  if (info.container == item.id) {
1023                                      // We are deleting a folder which still contains items that
1024                                      // think they are contained by that folder.
1025                                      String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1026                                              &quot;contains items (&quot; + info + &quot;)&quot;;
1027                                      Log.e(TAG, msg);
1028                                  }
1029                              }
1030                              sBgWorkspaceItems.remove(item);
1031                              break;
1032                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1033                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1034                              sBgWorkspaceItems.remove(item);
1035                              break;
1036                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1037                              sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1038                              break;
1039                      }
1040                      sBgItemsIdMap.remove(item.id);
1041                      sBgDbIconCache.remove(item);
1042                  }
1043              }
1044          };
1045          runOnWorkerThread(r);
1046      }
1047  
1048      /**
1049       * Update the order of the workspace screens in the database. The array list contains
1050       * a list of screen ids in the order that they should appear.
1051       */
1052      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1053          // Log to disk
1054          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1055          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1056  
1057          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1058          final ContentResolver cr = context.getContentResolver();
1059          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1060  
1061          // Remove any negative screen ids -- these aren&#x27;t persisted
1062          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1063          while (iter.hasNext()) {
1064              long id = iter.next();
1065              if (id &lt; 0) {
1066                  iter.remove();
1067              }
1068          }
1069  
1070          Runnable r = new Runnable() {
1071              @Override
1072              public void run() {
1073                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1074                  // Clear the table
1075                  ops.add(ContentProviderOperation.newDelete(uri).build());
1076                  int count = screensCopy.size();
1077                  for (int i = 0; i &lt; count; i++) {
1078                      ContentValues v = new ContentValues();
1079                      long screenId = screensCopy.get(i);
1080                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1081                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1082                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1083                  }
1084  
1085                  try {
1086                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1087                  } catch (Exception ex) {
1088                      throw new RuntimeException(ex);
1089                  }
1090  
1091                  synchronized (sBgLock) {
1092                      sBgWorkspaceScreens.clear();
1093                      sBgWorkspaceScreens.addAll(screensCopy);
1094                  }
1095              }
1096          };
1097          runOnWorkerThread(r);
1098      }
1099  
1100      /**
1101       * Remove the contents of the specified folder from the database
1102       */
1103      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1104          final ContentResolver cr = context.getContentResolver();
1105  
1106          Runnable r = new Runnable() {
1107              public void run() {
1108                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1109                  // Lock on mBgLock *after* the db operation
1110                  synchronized (sBgLock) {
1111                      sBgItemsIdMap.remove(info.id);
1112                      sBgFolders.remove(info.id);
1113                      sBgDbIconCache.remove(info);
1114                      sBgWorkspaceItems.remove(info);
1115                  }
1116  
1117                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1118                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1119                  // Lock on mBgLock *after* the db operation
1120                  synchronized (sBgLock) {
1121                      for (ItemInfo childInfo : info.contents) {
1122                          sBgItemsIdMap.remove(childInfo.id);
1123                          sBgDbIconCache.remove(childInfo);
1124                      }
1125                  }
1126              }
1127          };
1128          runOnWorkerThread(r);
1129      }
1130  
1131      /**
1132       * Set this as the current Launcher activity object for the loader.
1133       */
1134      public void initialize(Callbacks callbacks) {
1135          synchronized (mLock) {
1136              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1137          }
1138      }
1139  
1140      /**
1141       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1142       * ACTION_PACKAGE_CHANGED.
1143       */
1144      @Override
1145      public void onReceive(Context context, Intent intent) {
1146          if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1147  
1148          final String action = intent.getAction();
1149  
1150          if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
1151                  || Intent.ACTION_PACKAGE_REMOVED.equals(action)
1152                  || Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1153              final String packageName = intent.getData().getSchemeSpecificPart();
1154              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1155  
1156              int op = PackageUpdatedTask.OP_NONE;
1157  
1158              if (packageName == null || packageName.length() == 0) {
1159                  // they sent us a bad intent
1160                  return;
1161              }
1162  
1163              if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {
1164                  op = PackageUpdatedTask.OP_UPDATE;
1165              } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
1166                  if (!replacing) {
1167                      op = PackageUpdatedTask.OP_REMOVE;
1168                  }
1169                  // else, we are replacing the package, so a PACKAGE_ADDED will be sent
1170                  // later, we will update the package at this time
1171              } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {
1172                  if (!replacing) {
1173                      op = PackageUpdatedTask.OP_ADD;
1174                  } else {
1175                      op = PackageUpdatedTask.OP_UPDATE;
1176                  }
1177              }
1178  
1179              if (op != PackageUpdatedTask.OP_NONE) {
1180                  enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));
1181              }
1182  
1183          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {
1184              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1185              String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1186              if (!replacing) {
1187                  enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));
1188                  if (mAppsCanBeOnRemoveableStorage) {
1189                      // Only rebind if we support removable storage.  It catches the case where
1190                      // apps on the external sd card need to be reloaded
1191                      startLoaderFromBackground();
1192                  }
1193              } else {
1194                  // If we are replacing then just update the packages in the list
1195                  enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1196                          packages));
1197              }
1198          } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {
1199              final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
1200              if (!replacing) {
1201                  String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
1202                  enqueuePackageUpdated(new PackageUpdatedTask(
1203                              PackageUpdatedTask.OP_UNAVAILABLE, packages));
1204              }
1205              // else, we are replacing the packages, so ignore this event and wait for
1206              // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time
1207          } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1208              // If we have changed locale we need to clear out the labels in all apps/workspace.
1209              forceReload();
1210          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1211               // Check if configuration change was an mcc/mnc change which would affect app resources
1212               // and we would need to clear out the labels in all apps/workspace. Same handling as
1213               // above for ACTION_LOCALE_CHANGED
1214               Configuration currentConfig = context.getResources().getConfiguration();
1215               if (mPreviousConfigMcc != currentConfig.mcc) {
1216                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1217                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1218                     forceReload();
1219               }
1220               // Update previousConfig
1221               mPreviousConfigMcc = currentConfig.mcc;
1222          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1223                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1224              if (mCallbacks != null) {
1225                  Callbacks callbacks = mCallbacks.get();
1226                  if (callbacks != null) {
1227                      callbacks.bindSearchablesChanged();
1228                  }
1229              }
1230          }
1231      }
1232  
1233      private void forceReload() {
1234          resetLoadedState(true, true);
1235  
1236          // Do this here because if the launcher activity is running it will be restarted.
1237          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1238          // to reload.
1239          startLoaderFromBackground();
1240      }
1241  
1242      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1243          synchronized (mLock) {
1244              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1245              // mWorkspaceLoaded to true later
1246              stopLoaderLocked();
1247              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1248              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1249          }
1250      }
1251  
1252      /**
1253       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1254       * configuration changes.  So whenever we trigger the loader from the background
1255       * tell the launcher that it needs to re-run the loader when it comes back instead
1256       * of doing it now.
1257       */
1258      public void startLoaderFromBackground() {
1259          boolean runLoader = false;
1260          if (mCallbacks != null) {
1261              Callbacks callbacks = mCallbacks.get();
1262              if (callbacks != null) {
1263                  // Only actually run the loader if they&#x27;re not paused.
1264                  if (!callbacks.setLoadOnResume()) {
1265                      runLoader = true;
1266                  }
1267              }
1268          }
1269          if (runLoader) {
1270              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1271          }
1272      }
1273  
1274      // If there is already a loader task running, tell it to stop.
1275      // returns true if isLaunching() was true on the old task
1276      private boolean stopLoaderLocked() {
1277          boolean isLaunching = false;
1278          LoaderTask oldTask = mLoaderTask;
1279          if (oldTask != null) {
1280              if (oldTask.isLaunching()) {
1281                  isLaunching = true;
1282              }
1283              oldTask.stopLocked();
1284          }
1285          return isLaunching;
1286      }
1287  
1288      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1289          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1290      }
1291  
1292      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1293          synchronized (mLock) {
1294              if (DEBUG_LOADERS) {
1295                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1296              }
1297  
1298              // Clear any deferred bind-runnables from the synchronized load process
1299              // We must do this before any loading/binding is scheduled below.
1300              mDeferredBindRunnables.clear();
1301  
1302              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1303              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1304                  // If there is already one running, tell it to stop.
1305                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1306                  isLaunching = isLaunching || stopLoaderLocked();
1307                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1308                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1309                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1310                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1311                  } else {
1312                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1313                      sWorker.post(mLoaderTask);
1314                  }
1315              }
1316          }
1317      }
1318  
1319      void bindRemainingSynchronousPages() {
1320          // Post the remaining side pages to be loaded
1321          if (!mDeferredBindRunnables.isEmpty()) {
1322              for (final Runnable r : mDeferredBindRunnables) {
1323                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1324              }
1325              mDeferredBindRunnables.clear();
1326          }
1327      }
1328  
1329      public void stopLoader() {
1330          synchronized (mLock) {
1331              if (mLoaderTask != null) {
1332                  mLoaderTask.stopLocked();
1333              }
1334          }
1335      }
1336  
1337      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1338      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1339          final ContentResolver contentResolver = context.getContentResolver();
1340          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1341          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1342          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1343  
1344          try {
1345              final int idIndex = sc.getColumnIndexOrThrow(
1346                      LauncherSettings.WorkspaceScreens._ID);
1347              final int rankIndex = sc.getColumnIndexOrThrow(
1348                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1349              while (sc.moveToNext()) {
1350                  try {
1351                      long screenId = sc.getLong(idIndex);
1352                      int rank = sc.getInt(rankIndex);
1353                      orderedScreens.put(rank, screenId);
1354                  } catch (Exception e) {
1355                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1356                  }
1357              }
1358          } finally {
1359              sc.close();
1360          }
1361  
1362          // Log to disk
1363          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1364          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1365          for (Integer i : orderedScreens.keySet()) {
1366              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1367          }
1368          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1369                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1370          return orderedScreens;
1371      }
1372  
1373      public boolean isAllAppsLoaded() {
1374          return mAllAppsLoaded;
1375      }
1376  
1377      boolean isLoadingWorkspace() {
1378          synchronized (mLock) {
1379              if (mLoaderTask != null) {
1380                  return mLoaderTask.isLoadingWorkspace();
1381              }
1382          }
1383          return false;
1384      }
1385  
1386      /**
1387       * Runnable for the thread that loads the contents of the launcher:
1388       *   - workspace icons
1389       *   - widgets
1390       *   - all apps icons
1391       */
1392      private class LoaderTask implements Runnable {
1393          private Context mContext;
1394          private boolean mIsLaunching;
1395          private boolean mIsLoadingAndBindingWorkspace;
1396          private boolean mStopped;
1397          private boolean mLoadAndBindStepFinished;
1398          private int mFlags;
1399  
1400          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1401  
1402          LoaderTask(Context context, boolean isLaunching, int flags) {
1403              mContext = context;
1404              mIsLaunching = isLaunching;
1405              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1406              mFlags = flags;
1407          }
1408  
1409          boolean isLaunching() {
1410              return mIsLaunching;
1411          }
1412  
1413          boolean isLoadingWorkspace() {
1414              return mIsLoadingAndBindingWorkspace;
1415          }
1416  
1417          /** Returns whether this is an upgrade path */
1418          private boolean loadAndBindWorkspace() {
1419              mIsLoadingAndBindingWorkspace = true;
1420  
1421              // Load the workspace
1422              if (DEBUG_LOADERS) {
1423                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1424              }
1425  
1426              boolean isUpgradePath = false;
1427              if (!mWorkspaceLoaded) {
1428                  isUpgradePath = loadWorkspace();
1429                  synchronized (LoaderTask.this) {
1430                      if (mStopped) {
1431                          return isUpgradePath;
1432                      }
1433                      mWorkspaceLoaded = true;
1434                  }
1435              }
1436  
1437              // Bind the workspace
1438              bindWorkspace(-1, isUpgradePath);
1439              return isUpgradePath;
1440          }
1441  
1442          private void waitForIdle() {
1443              // Wait until the either we&#x27;re stopped or the other threads are done.
1444              // This way we don&#x27;t start loading all apps until the workspace has settled
1445              // down.
1446              synchronized (LoaderTask.this) {
1447                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1448  
1449                  mHandler.postIdle(new Runnable() {
1450                          public void run() {
1451                              synchronized (LoaderTask.this) {
1452                                  mLoadAndBindStepFinished = true;
1453                                  if (DEBUG_LOADERS) {
1454                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1455                                  }
1456                                  LoaderTask.this.notify();
1457                              }
1458                          }
1459                      });
1460  
1461                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1462                      try {
1463                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1464                          // wait no longer than 1sec at a time
1465                          this.wait(1000);
1466                      } catch (InterruptedException ex) {
1467                          // Ignore
1468                      }
1469                  }
1470                  if (DEBUG_LOADERS) {
1471                      Log.d(TAG, &quot;waited &quot;
1472                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1473                              + &quot;ms for previous step to finish binding&quot;);
1474                  }
1475              }
1476          }
1477  
1478          void runBindSynchronousPage(int synchronousBindPage) {
1479              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1480                  // Ensure that we have a valid page index to load synchronously
1481                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1482                          &quot;valid page index&quot;);
1483              }
1484              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1485                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1486                  // loaded already (we should load everything asynchronously in that case)
1487                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1488              }
1489              synchronized (mLock) {
1490                  if (mIsLoaderTaskRunning) {
1491                      // Ensure that we are never running the background loading at this point since
1492                      // we also touch the background collections
1493                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1494                  }
1495              }
1496  
1497              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1498              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1499              //      this call is synchronous, we can get away with not locking).
1500  
1501              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1502              // operations from the previous activity.  We need to ensure that all queued operations
1503              // are executed before any synchronous binding work is done.
1504              mHandler.flush();
1505  
1506              // Divide the set of loaded items into those that we are binding synchronously, and
1507              // everything else that is to be bound normally (asynchronously).
1508              bindWorkspace(synchronousBindPage, false);
1509              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1510              //      arise from that.
1511              onlyBindAllApps();
1512          }
1513  
1514          public void run() {
1515              boolean isUpgrade = false;
1516  
1517              synchronized (mLock) {
1518                  mIsLoaderTaskRunning = true;
1519              }
1520              // Optimize for end-user experience: if the Launcher is up and // running with the
1521              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1522              // workspace first (default).
1523              keep_running: {
1524                  // Elevate priority when Home launches for the first time to avoid
1525                  // starving at boot time. Staring at a blank home is not cool.
1526                  synchronized (mLock) {
1527                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1528                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1529                      android.os.Process.setThreadPriority(mIsLaunching
1530                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1531                  }
1532                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1533                  isUpgrade = loadAndBindWorkspace();
1534  
1535                  if (mStopped) {
1536                      break keep_running;
1537                  }
1538  
1539                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1540                  // settled down.
1541                  synchronized (mLock) {
1542                      if (mIsLaunching) {
1543                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1544                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1545                      }
1546                  }
1547                  waitForIdle();
1548  
1549                  // second step
1550                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1551                  loadAndBindAllApps();
1552  
1553                  // Restore the default thread priority after we are done loading items
1554                  synchronized (mLock) {
1555                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1556                  }
1557              }
1558  
1559              // Update the saved icons if necessary
1560              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1561              synchronized (sBgLock) {
1562                  for (Object key : sBgDbIconCache.keySet()) {
1563                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1564                  }
1565                  sBgDbIconCache.clear();
1566              }
1567  
1568              if (LauncherAppState.isDisableAllApps()) {
1569                  // Ensure that all the applications that are in the system are
1570                  // represented on the home screen.
1571                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1572                      verifyApplications();
1573                  }
1574              }
1575  
1576              // Clear out this reference, otherwise we end up holding it until all of the
1577              // callback runnables are done.
1578              mContext = null;
1579  
1580              synchronized (mLock) {
1581                  // If we are still the last one to be scheduled, remove ourselves.
1582                  if (mLoaderTask == this) {
1583                      mLoaderTask = null;
1584                  }
1585                  mIsLoaderTaskRunning = false;
1586              }
1587          }
1588  
1589          public void stopLocked() {
1590              synchronized (LoaderTask.this) {
1591                  mStopped = true;
1592                  this.notify();
1593              }
1594          }
1595  
1596          /**
1597           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1598           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1599           * object that was around when the deferred message was scheduled, and if there&#x27;s
1600           * a new Callbacks object around then also return null.  This will save us from
1601           * calling onto it with data that will be ignored.
1602           */
1603          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1604              synchronized (mLock) {
1605                  if (mStopped) {
1606                      return null;
1607                  }
1608  
1609                  if (mCallbacks == null) {
1610                      return null;
1611                  }
1612  
1613                  final Callbacks callbacks = mCallbacks.get();
1614                  if (callbacks != oldCallbacks) {
1615                      return null;
1616                  }
1617                  if (callbacks == null) {
1618                      Log.w(TAG, &quot;no mCallbacks&quot;);
1619                      return null;
1620                  }
1621  
1622                  return callbacks;
1623              }
1624          }
1625  
1626          private void verifyApplications() {
1627              final Context context = mApp.getContext();
1628  
1629              // Cross reference all the applications in our apps list with items in the workspace
1630              ArrayList&lt;ItemInfo&gt; tmpInfos;
1631              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1632              synchronized (sBgLock) {
1633                  for (AppInfo app : mBgAllAppsList.data) {
1634                      tmpInfos = getItemInfoForComponentName(app.componentName);
1635                      if (tmpInfos.isEmpty()) {
1636                          // We are missing an application icon, so add this to the workspace
1637                          added.add(app);
1638                          // This is a rare event, so lets log it
1639                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1640                      }
1641                  }
1642              }
1643              if (!added.isEmpty()) {
1644                  addAndBindAddedWorkspaceApps(context, added);


1645              }
1646          }
1647  
1648          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1649          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1650                                             AtomicBoolean deleteOnInvalidPlacement) {
1651              LauncherAppState app = LauncherAppState.getInstance();
1652              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1653              final int countX = (int) grid.numColumns;
1654              final int countY = (int) grid.numRows;
1655  
1656              long containerIndex = item.screenId;
1657              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1658                  // Return early if we detect that an item is under the hotseat button
1659                  if (mCallbacks == null ||
1660                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1661                      deleteOnInvalidPlacement.set(true);
1662                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1663                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1664                              + item.cellY + &quot;) occupied by all apps&quot;);
1665                      return false;
1666                  }
1667  
1668                  final ItemInfo[][] hotseatItems =
1669                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1670  
1671                  if (item.screenId &gt;= grid.numHotseatIcons) {
1672                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1673                              + &quot; into hotseat position &quot; + item.screenId
1674                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1675                              + &quot;)&quot;);
1676                      return false;
1677                  }
1678  
1679                  if (hotseatItems != null) {
1680                      if (hotseatItems[(int) item.screenId][0] != null) {
1681                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1682                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1683                                  + item.cellY + &quot;) occupied by &quot;
1684                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1685                                  [(int) item.screenId][0]);
1686                              return false;
1687                      } else {
1688                          hotseatItems[(int) item.screenId][0] = item;
1689                          return true;
1690                      }
1691                  } else {
1692                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1693                      items[(int) item.screenId][0] = item;
1694                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1695                      return true;
1696                  }
1697              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1698                  // Skip further checking if it is not the hotseat or workspace container
1699                  return true;
1700              }
1701  
1702              if (!occupied.containsKey(item.screenId)) {
1703                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1704                  occupied.put(item.screenId, items);
1705              }
1706  
1707              final ItemInfo[][] screens = occupied.get(item.screenId);
1708              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1709                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1710                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1711                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1712                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1713                          + item.cellX + &quot;,&quot; + item.cellY
1714                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1715                  return false;
1716              }
1717  
1718              // Check if any workspace icons overlap with each other
1719              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1720                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1721                      if (screens[x][y] != null) {
1722                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1723                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1724                              + x + &quot;,&quot; + y
1725                              + &quot;) occupied by &quot;
1726                              + screens[x][y]);
1727                          return false;
1728                      }
1729                  }
1730              }
1731              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1732                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1733                      screens[x][y] = item;
1734                  }
1735              }
1736  
1737              return true;
1738          }
1739  
1740          /** Clears all the sBg data structures */
1741          private void clearSBgDataStructures() {
1742              synchronized (sBgLock) {
1743                  sBgWorkspaceItems.clear();
1744                  sBgAppWidgets.clear();
1745                  sBgFolders.clear();
1746                  sBgItemsIdMap.clear();
1747                  sBgDbIconCache.clear();
1748                  sBgWorkspaceScreens.clear();
1749              }
1750          }
1751  
1752          /** Returns whether this is an upgrade path */
1753          private boolean loadWorkspace() {
1754              // Log to disk
1755              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1756  
1757              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1758  
1759              final Context context = mContext;
1760              final ContentResolver contentResolver = context.getContentResolver();
1761              final PackageManager manager = context.getPackageManager();
1762              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1763              final boolean isSafeMode = manager.isSafeMode();
1764  
1765              LauncherAppState app = LauncherAppState.getInstance();
1766              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1767              int countX = (int) grid.numColumns;
1768              int countY = (int) grid.numRows;
1769  
1770              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1771                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1772                  LauncherAppState.getLauncherProvider().deleteDatabase();
1773              }
1774  
1775              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1776                  // append the user&#x27;s Launcher2 shortcuts
1777                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1778                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1779              } else {
1780                  // Make sure the default workspace is loaded
1781                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1782                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);
1783              }
1784  
1785              // Check if we need to do any upgrade-path logic
1786              // (Includes having just imported default favorites)
1787              boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();
1788  
1789              // Log to disk
1790              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1791  
1792              synchronized (sBgLock) {
1793                  clearSBgDataStructures();
1794  
1795                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1796                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1797                  final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1798                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1799                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1800  
1801                  // +1 for the hotseat (it can be larger than the workspace)
1802                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1803                  // before any earlier duplicates)
1804                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1805  
1806                  try {
1807                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1808                      final int intentIndex = c.getColumnIndexOrThrow
1809                              (LauncherSettings.Favorites.INTENT);
1810                      final int titleIndex = c.getColumnIndexOrThrow
1811                              (LauncherSettings.Favorites.TITLE);
1812                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1813                              LauncherSettings.Favorites.ICON_TYPE);
1814                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1815                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1816                              LauncherSettings.Favorites.ICON_PACKAGE);
1817                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1818                              LauncherSettings.Favorites.ICON_RESOURCE);
1819                      final int containerIndex = c.getColumnIndexOrThrow(
1820                              LauncherSettings.Favorites.CONTAINER);
1821                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1822                              LauncherSettings.Favorites.ITEM_TYPE);
1823                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1824                              LauncherSettings.Favorites.APPWIDGET_ID);
1825                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1826                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1827                      final int screenIndex = c.getColumnIndexOrThrow(
1828                              LauncherSettings.Favorites.SCREEN);
1829                      final int cellXIndex = c.getColumnIndexOrThrow
1830                              (LauncherSettings.Favorites.CELLX);
1831                      final int cellYIndex = c.getColumnIndexOrThrow
1832                              (LauncherSettings.Favorites.CELLY);
1833                      final int spanXIndex = c.getColumnIndexOrThrow
1834                              (LauncherSettings.Favorites.SPANX);
1835                      final int spanYIndex = c.getColumnIndexOrThrow(
1836                              LauncherSettings.Favorites.SPANY);
1837                      final int restoredIndex = c.getColumnIndexOrThrow(
1838                              LauncherSettings.Favorites.RESTORED);
1839                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1840                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1841                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1842  
1843                      ShortcutInfo info;
1844                      String intentDescription;
1845                      LauncherAppWidgetInfo appWidgetInfo;
1846                      int container;
1847                      long id;
1848                      Intent intent;
1849  
1850                      while (!mStopped &amp;&amp; c.moveToNext()) {
1851                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1852                          try {
1853                              int itemType = c.getInt(itemTypeIndex);
1854                              boolean restored = 0 != c.getInt(restoredIndex);
1855  
1856                              switch (itemType) {
1857                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1858                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1859                                  id = c.getLong(idIndex);
1860                                  intentDescription = c.getString(intentIndex);
1861                                  try {
1862                                      intent = Intent.parseUri(intentDescription, 0);
1863                                      ComponentName cn = intent.getComponent();
1864                                      if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {
1865                                          if (restored) {
1866                                              // might be installed later
1867                                              Launcher.addDumpLog(TAG,
1868                                                      &quot;package not yet restored: &quot; + cn, true);
1869                                          } else {
1870                                              if (!mAppsCanBeOnRemoveableStorage) {
1871                                                  // Log the invalid package, and remove it
1872                                                  Launcher.addDumpLog(TAG,
1873                                                          &quot;Invalid package removed: &quot; + cn, true);
1874                                                  itemsToRemove.add(id);
1875                                              } else {
1876                                                  // If apps can be on external storage, then we just
1877                                                  // leave them for the user to remove (maybe add
1878                                                  // visual treatment to it)
1879                                                  Launcher.addDumpLog(TAG,
1880                                                          &quot;Invalid package found: &quot; + cn, true);
1881                                              }
1882                                              continue;
1883                                          }
1884                                      } else if (restored) {
1885                                          // no special handling necessary for this restored item
1886                                          restoredRows.add(id);
1887                                          restored = false;
1888                                      }
1889                                  } catch (URISyntaxException e) {
1890                                      Launcher.addDumpLog(TAG,
1891                                              &quot;Invalid uri: &quot; + intentDescription, true);
1892                                      continue;
1893                                  }
1894  
1895                                  if (restored) {
1896                                      Launcher.addDumpLog(TAG,
1897                                              &quot;constructing info for partially restored package&quot;,
1898                                              true);
1899                                      info = getRestoredItemInfo(c, titleIndex, intent);

1900                                      intent = getRestoredItemIntent(c, context, intent);
1901                                  } else if (itemType ==
1902                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
1903                                      info = getShortcutInfo(manager, intent, context, c, iconIndex,
1904                                              titleIndex, mLabelCache);
1905                                  } else {
1906                                      info = getShortcutInfo(c, context, iconTypeIndex,
1907                                              iconPackageIndex, iconResourceIndex, iconIndex,
1908                                              titleIndex);
1909  
1910                                      // App shortcuts that used to be automatically added to Launcher
1911                                      // didn&#x27;t always have the correct intent flags set, so do that
1912                                      // here
1913                                      if (intent.getAction() != null &amp;&amp;
1914                                          intent.getCategories() != null &amp;&amp;
1915                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
1916                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
1917                                          intent.addFlags(
1918                                              Intent.FLAG_ACTIVITY_NEW_TASK |
1919                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
1920                                      }
1921                                  }
1922  
1923                                  if (info != null) {
1924                                      info.id = id;
1925                                      info.intent = intent;
1926                                      container = c.getInt(containerIndex);
1927                                      info.container = container;
1928                                      info.screenId = c.getInt(screenIndex);
1929                                      info.cellX = c.getInt(cellXIndex);
1930                                      info.cellY = c.getInt(cellYIndex);
1931                                      info.spanX = 1;
1932                                      info.spanY = 1;
1933  
1934                                      // check &amp; update map of what&#x27;s occupied
1935                                      deleteOnInvalidPlacement.set(false);
1936                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
1937                                          if (deleteOnInvalidPlacement.get()) {
1938                                              itemsToRemove.add(id);
1939                                          }
1940                                          break;
1941                                      }
1942  
1943                                      switch (container) {
1944                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1945                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1946                                          sBgWorkspaceItems.add(info);
1947                                          break;
1948                                      default:
1949                                          // Item is in a user folder
1950                                          FolderInfo folderInfo =
1951                                                  findOrMakeFolder(sBgFolders, container);
1952                                          folderInfo.add(info);
1953                                          break;
1954                                      }
1955                                      sBgItemsIdMap.put(info.id, info);
1956  
1957                                      // now that we&#x27;ve loaded everthing re-save it with the
1958                                      // icon in case it disappears somehow.
1959                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1960                                  } else {
1961                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1962                                  }
1963                                  break;
1964  
1965                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1966                                  id = c.getLong(idIndex);
1967                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1968  
1969                                  folderInfo.title = c.getString(titleIndex);
1970                                  folderInfo.id = id;
1971                                  container = c.getInt(containerIndex);
1972                                  folderInfo.container = container;
1973                                  folderInfo.screenId = c.getInt(screenIndex);
1974                                  folderInfo.cellX = c.getInt(cellXIndex);
1975                                  folderInfo.cellY = c.getInt(cellYIndex);
1976                                  folderInfo.spanX = 1;
1977                                  folderInfo.spanY = 1;
1978  
1979                                  // check &amp; update map of what&#x27;s occupied
1980                                  deleteOnInvalidPlacement.set(false);
1981                                  if (!checkItemPlacement(occupied, folderInfo,
1982                                          deleteOnInvalidPlacement)) {
1983                                      if (deleteOnInvalidPlacement.get()) {
1984                                          itemsToRemove.add(id);
1985                                      }
1986                                      break;
1987                                  }
1988  
1989                                  switch (container) {
1990                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
1991                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
1992                                          sBgWorkspaceItems.add(folderInfo);
1993                                          break;
1994                                  }
1995  
1996                                  if (restored) {
1997                                      // no special handling required for restored folders
1998                                      restoredRows.add(id);
1999                                  }
2000  
2001                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2002                                  sBgFolders.put(folderInfo.id, folderInfo);
2003                                  break;
2004  
2005                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2006                                  // Read all Launcher-specific widget details
2007                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2008                                  String savedProvider = c.getString(appWidgetProviderIndex);
2009  
2010                                  id = c.getLong(idIndex);
2011  
2012                                  final AppWidgetProviderInfo provider =
2013                                          widgets.getAppWidgetInfo(appWidgetId);
2014  
2015                                  if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||
2016                                          provider.provider.getPackageName() == null)) {
2017                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;
2018                                          + id + &quot; appWidgetId=&quot; + appWidgetId;
2019                                      Log.e(TAG, log);
2020                                      Launcher.addDumpLog(TAG, log, false);
2021                                      itemsToRemove.add(id);
2022                                  } else {
2023                                      appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2024                                              provider.provider);
2025                                      appWidgetInfo.id = id;
2026                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2027                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2028                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2029                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2030                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
2031                                      int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
2032                                      appWidgetInfo.minSpanX = minSpan[0];
2033                                      appWidgetInfo.minSpanY = minSpan[1];
2034  
2035                                      container = c.getInt(containerIndex);
2036                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2037                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2038                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2039                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2040                                          continue;
2041                                      }
2042  
2043                                      appWidgetInfo.container = c.getInt(containerIndex);
2044                                      // check &amp; update map of what&#x27;s occupied
2045                                      deleteOnInvalidPlacement.set(false);
2046                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2047                                              deleteOnInvalidPlacement)) {
2048                                          if (deleteOnInvalidPlacement.get()) {
2049                                              itemsToRemove.add(id);
2050                                          }
2051                                          break;
2052                                      }
2053                                      String providerName = provider.provider.flattenToString();
2054                                      if (!providerName.equals(savedProvider)) {
2055                                          ContentValues values = new ContentValues();
2056                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2057                                                  providerName);
2058                                          String where = BaseColumns._ID + &quot;= ?&quot;;
2059                                          String[] args = {Integer.toString(c.getInt(idIndex))};
2060                                          contentResolver.update(contentUri, values, where, args);
2061                                      }
2062                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2063                                      sBgAppWidgets.add(appWidgetInfo);
2064                                  }
2065                                  break;
2066                              }
2067                          } catch (Exception e) {
2068                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2069                          }
2070                      }
2071                  } finally {
2072                      if (c != null) {
2073                          c.close();
2074                      }
2075                  }
2076  
2077                  // Break early if we&#x27;ve stopped loading
2078                  if (mStopped) {
2079                      clearSBgDataStructures();
2080                      return false;
2081                  }
2082  
2083                  if (itemsToRemove.size() &gt; 0) {
2084                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
2085                              LauncherSettings.Favorites.CONTENT_URI);
2086                      // Remove dead items
2087                      for (long id : itemsToRemove) {
2088                          if (DEBUG_LOADERS) {
2089                              Log.d(TAG, &quot;Removed id = &quot; + id);
2090                          }
2091                          // Don&#x27;t notify content observers
2092                          try {
2093                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2094                                      null, null);
2095                          } catch (RemoteException e) {
2096                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2097                          }
2098                      }
2099                  }
2100  
2101                  if (restoredRows.size() &gt; 0) {
2102                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2103                              LauncherSettings.Favorites.CONTENT_URI);
2104                      // Update restored items that no longer require special handling
2105                      try {
2106                          StringBuilder selectionBuilder = new StringBuilder();
2107                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2108                          selectionBuilder.append(&quot; IN (&quot;);
2109                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2110                          selectionBuilder.append(&quot;)&quot;);
2111                          ContentValues values = new ContentValues();
2112                          values.put(LauncherSettings.Favorites.RESTORED, 0);
2113                          updater.update(LauncherSettings.Favorites.CONTENT_URI,
2114                                  values, selectionBuilder.toString(), null);
2115                      } catch (RemoteException e) {
2116                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2117                      }
2118                  }
2119  
2120                  if (loadedOldDb) {
2121                      long maxScreenId = 0;
2122                      // If we&#x27;re importing we use the old screen order.
2123                      for (ItemInfo item: sBgItemsIdMap.values()) {
2124                          long screenId = item.screenId;
2125                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2126                                  !sBgWorkspaceScreens.contains(screenId)) {
2127                              sBgWorkspaceScreens.add(screenId);
2128                              if (screenId &gt; maxScreenId) {
2129                                  maxScreenId = screenId;
2130                              }
2131                          }
2132                      }
2133                      Collections.sort(sBgWorkspaceScreens);
2134                      // Log to disk
2135                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2136                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2137                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2138  
2139                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2140                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2141  
2142                      // Update the max item id after we load an old db
2143                      long maxItemId = 0;
2144                      // If we&#x27;re importing we use the old screen order.
2145                      for (ItemInfo item: sBgItemsIdMap.values()) {
2146                          maxItemId = Math.max(maxItemId, item.id);
2147                      }
2148                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2149                  } else {
2150                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2151                      for (Integer i : orderedScreens.keySet()) {
2152                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2153                      }
2154                      // Log to disk
2155                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2156                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2157  
2158                      // Remove any empty screens
2159                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2160                      for (ItemInfo item: sBgItemsIdMap.values()) {
2161                          long screenId = item.screenId;
2162                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2163                                  unusedScreens.contains(screenId)) {
2164                              unusedScreens.remove(screenId);
2165                          }
2166                      }
2167  
2168                      // If there are any empty screens remove them, and update.
2169                      if (unusedScreens.size() != 0) {
2170                          // Log to disk
2171                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2172                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2173  
2174                          sBgWorkspaceScreens.removeAll(unusedScreens);
2175                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2176                      }
2177                  }
2178  
2179                  if (DEBUG_LOADERS) {
2180                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2181                      Log.d(TAG, &quot;workspace layout: &quot;);
2182                      int nScreens = occupied.size();
2183                      for (int y = 0; y &lt; countY; y++) {
2184                          String line = &quot;&quot;;
2185  
2186                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2187                          while (iter.hasNext()) {
2188                              long screenId = iter.next();
2189                              if (screenId &gt; 0) {
2190                                  line += &quot; | &quot;;
2191                              }
2192                              for (int x = 0; x &lt; countX; x++) {
2193                                  line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);
2194                              }
2195                          }
2196                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2197                      }
2198                  }
2199              }
2200              return loadedOldDb;
2201          }
2202  
2203          /** Filters the set of items who are directly or indirectly (via another container) on the
2204           * specified screen. */
2205          private void filterCurrentWorkspaceItems(long currentScreenId,
2206                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2207                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2208                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2209              // Purge any null ItemInfos
2210              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2211              while (iter.hasNext()) {
2212                  ItemInfo i = iter.next();
2213                  if (i == null) {
2214                      iter.remove();
2215                  }
2216              }
2217  
2218              // Order the set of items by their containers first, this allows use to walk through the
2219              // list sequentially, build up a list of containers that are in the specified screen,
2220              // as well as all items in those containers.
2221              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2222              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2223                  @Override
2224                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2225                      return (int) (lhs.container - rhs.container);
2226                  }
2227              });
2228              for (ItemInfo info : allWorkspaceItems) {
2229                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2230                      if (info.screenId == currentScreenId) {
2231                          currentScreenItems.add(info);
2232                          itemsOnScreen.add(info.id);
2233                      } else {
2234                          otherScreenItems.add(info);
2235                      }
2236                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2237                      currentScreenItems.add(info);
2238                      itemsOnScreen.add(info.id);
2239                  } else {
2240                      if (itemsOnScreen.contains(info.container)) {
2241                          currentScreenItems.add(info);
2242                          itemsOnScreen.add(info.id);
2243                      } else {
2244                          otherScreenItems.add(info);
2245                      }
2246                  }
2247              }
2248          }
2249  
2250          /** Filters the set of widgets which are on the specified screen. */
2251          private void filterCurrentAppWidgets(long currentScreenId,
2252                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2253                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2254                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2255  
2256              for (LauncherAppWidgetInfo widget : appWidgets) {
2257                  if (widget == null) continue;
2258                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2259                          widget.screenId == currentScreenId) {
2260                      currentScreenWidgets.add(widget);
2261                  } else {
2262                      otherScreenWidgets.add(widget);
2263                  }
2264              }
2265          }
2266  
2267          /** Filters the set of folders which are on the specified screen. */
2268          private void filterCurrentFolders(long currentScreenId,
2269                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2270                  HashMap&lt;Long, FolderInfo&gt; folders,
2271                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2272                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2273  
2274              for (long id : folders.keySet()) {
2275                  ItemInfo info = itemsIdMap.get(id);
2276                  FolderInfo folder = folders.get(id);
2277                  if (info == null || folder == null) continue;
2278                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2279                          info.screenId == currentScreenId) {
2280                      currentScreenFolders.put(id, folder);
2281                  } else {
2282                      otherScreenFolders.put(id, folder);
2283                  }
2284              }
2285          }
2286  
2287          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2288           * right) */
2289          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2290              final LauncherAppState app = LauncherAppState.getInstance();
2291              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2292              // XXX: review this
2293              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2294                  @Override
2295                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2296                      int cellCountX = (int) grid.numColumns;
2297                      int cellCountY = (int) grid.numRows;
2298                      int screenOffset = cellCountX * cellCountY;
2299                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2300                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2301                              lhs.cellY * cellCountX + lhs.cellX);
2302                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2303                              rhs.cellY * cellCountX + rhs.cellX);
2304                      return (int) (lr - rr);
2305                  }
2306              });
2307          }
2308  
2309          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2310                  final ArrayList&lt;Long&gt; orderedScreens) {
2311              final Runnable r = new Runnable() {
2312                  @Override
2313                  public void run() {
2314                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2315                      if (callbacks != null) {
2316                          callbacks.bindScreens(orderedScreens);
2317                      }
2318                  }
2319              };
2320              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2321          }
2322  
2323          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2324                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2325                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2326                  final HashMap&lt;Long, FolderInfo&gt; folders,
2327                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2328  
2329              final boolean postOnMainThread = (deferredBindRunnables != null);
2330  
2331              // Bind the workspace items
2332              int N = workspaceItems.size();
2333              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2334                  final int start = i;
2335                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2336                  final Runnable r = new Runnable() {
2337                      @Override
2338                      public void run() {
2339                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2340                          if (callbacks != null) {
2341                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2342                                      false);
2343                          }
2344                      }
2345                  };
2346                  if (postOnMainThread) {
2347                      deferredBindRunnables.add(r);
2348                  } else {
2349                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2350                  }
2351              }
2352  
2353              // Bind the folders
2354              if (!folders.isEmpty()) {
2355                  final Runnable r = new Runnable() {
2356                      public void run() {
2357                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2358                          if (callbacks != null) {
2359                              callbacks.bindFolders(folders);
2360                          }
2361                      }
2362                  };
2363                  if (postOnMainThread) {
2364                      deferredBindRunnables.add(r);
2365                  } else {
2366                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2367                  }
2368              }
2369  
2370              // Bind the widgets, one at a time
2371              N = appWidgets.size();
2372              for (int i = 0; i &lt; N; i++) {
2373                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2374                  final Runnable r = new Runnable() {
2375                      public void run() {
2376                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2377                          if (callbacks != null) {
2378                              callbacks.bindAppWidget(widget);
2379                          }
2380                      }
2381                  };
2382                  if (postOnMainThread) {
2383                      deferredBindRunnables.add(r);
2384                  } else {
2385                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2386                  }
2387              }
2388          }
2389  
2390          /**
2391           * Binds all loaded data to actual views on the main thread.
2392           */
2393          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2394              final long t = SystemClock.uptimeMillis();
2395              Runnable r;
2396  
2397              // Don&#x27;t use these two variables in any of the callback runnables.
2398              // Otherwise we hold a reference to them.
2399              final Callbacks oldCallbacks = mCallbacks.get();
2400              if (oldCallbacks == null) {
2401                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2402                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2403                  return;
2404              }
2405  
2406              // Save a copy of all the bg-thread collections
2407              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2408              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2409                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2410              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2411              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2412              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2413              synchronized (sBgLock) {
2414                  workspaceItems.addAll(sBgWorkspaceItems);
2415                  appWidgets.addAll(sBgAppWidgets);
2416                  folders.putAll(sBgFolders);
2417                  itemsIdMap.putAll(sBgItemsIdMap);
2418                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2419              }
2420  
2421              final boolean isLoadingSynchronously =
2422                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2423              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2424                  oldCallbacks.getCurrentWorkspaceScreen();
2425              if (currScreen &gt;= orderedScreenIds.size()) {
2426                  // There may be no workspace screens (just hotseat items and an empty page).
2427                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2428              }
2429              final int currentScreen = currScreen;
2430              final long currentScreenId = currentScreen &lt; 0
2431                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2432  
2433              // Load all the items that are on the current page first (and in the process, unbind
2434              // all the existing workspace items before we call startBinding() below.
2435              unbindWorkspaceItemsOnMainThread();
2436  
2437              // Separate the items that are on the current screen, and all the other remaining items
2438              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2439              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2440              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2441                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2442              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2443                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2444              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2445              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2446  
2447              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2448                      otherWorkspaceItems);
2449              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2450                      otherAppWidgets);
2451              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2452                      otherFolders);
2453              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2454              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2455  
2456              // Tell the workspace that we&#x27;re about to start binding items
2457              r = new Runnable() {
2458                  public void run() {
2459                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2460                      if (callbacks != null) {
2461                          callbacks.startBinding();
2462                      }
2463                  }
2464              };
2465              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2466  
2467              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2468  
2469              // Load items on the current page
2470              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2471                      currentFolders, null);
2472              if (isLoadingSynchronously) {
2473                  r = new Runnable() {
2474                      public void run() {
2475                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2476                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2477                              callbacks.onPageBoundSynchronously(currentScreen);
2478                          }
2479                      }
2480                  };
2481                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2482              }
2483  
2484              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2485              // work until after the first render)
2486              mDeferredBindRunnables.clear();
2487              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2488                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2489  
2490              // Tell the workspace that we&#x27;re done binding items
2491              r = new Runnable() {
2492                  public void run() {
2493                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2494                      if (callbacks != null) {
2495                          callbacks.finishBindingItems(isUpgradePath);
2496                      }
2497  
2498                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2499                      if (DEBUG_LOADERS) {
2500                          Log.d(TAG, &quot;bound workspace in &quot;
2501                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2502                      }
2503  
2504                      mIsLoadingAndBindingWorkspace = false;
2505                  }
2506              };
2507              if (isLoadingSynchronously) {
2508                  mDeferredBindRunnables.add(r);
2509              } else {
2510                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2511              }
2512          }
2513  
2514          private void loadAndBindAllApps() {
2515              if (DEBUG_LOADERS) {
2516                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2517              }
2518              if (!mAllAppsLoaded) {
2519                  loadAllApps();
2520                  synchronized (LoaderTask.this) {
2521                      if (mStopped) {
2522                          return;
2523                      }
2524                      mAllAppsLoaded = true;
2525                  }
2526              } else {
2527                  onlyBindAllApps();
2528              }
2529          }
2530  
2531          private void onlyBindAllApps() {
2532              final Callbacks oldCallbacks = mCallbacks.get();
2533              if (oldCallbacks == null) {
2534                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2535                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2536                  return;
2537              }
2538  
2539              // shallow copy
2540              @SuppressWarnings(&quot;unchecked&quot;)
2541              final ArrayList&lt;AppInfo&gt; list
2542                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2543              Runnable r = new Runnable() {
2544                  public void run() {
2545                      final long t = SystemClock.uptimeMillis();
2546                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2547                      if (callbacks != null) {
2548                          callbacks.bindAllApplications(list);
2549                      }
2550                      if (DEBUG_LOADERS) {
2551                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2552                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2553                      }
2554                  }
2555              };
2556              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2557              if (isRunningOnMainThread) {
2558                  r.run();
2559              } else {
2560                  mHandler.post(r);
2561              }
2562          }
2563  
2564          private void loadAllApps() {
2565              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2566  
2567              final Callbacks oldCallbacks = mCallbacks.get();
2568              if (oldCallbacks == null) {
2569                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2570                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2571                  return;
2572              }
2573  
2574              final PackageManager packageManager = mContext.getPackageManager();
2575              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2576              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2577  
2578              // Clear the list of apps
2579              mBgAllAppsList.clear();
2580  
2581              // Query for the set of apps
2582              final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2583              List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);
2584              if (DEBUG_LOADERS) {
2585                  Log.d(TAG, &quot;queryIntentActivities took &quot;
2586                          + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);
2587                  Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);
2588              }
2589              // Fail if we don&#x27;t have any apps
2590              if (apps == null || apps.isEmpty()) {
2591                  return;
2592              }
2593              // Sort the applications by name
2594              final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2595              Collections.sort(apps,
2596                      new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
2597              if (DEBUG_LOADERS) {
2598                  Log.d(TAG, &quot;sort took &quot;
2599                          + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2600              }
2601  
2602              // Create the ApplicationInfos
2603              for (int i = 0; i &lt; apps.size(); i++) {
2604                  ResolveInfo app = apps.get(i);
2605                  // This builds the icon bitmaps.
2606                  mBgAllAppsList.add(new AppInfo(packageManager, app,
2607                          mIconCache, mLabelCache));
2608              }
2609  
2610              // Huh? Shouldn&#x27;t this be inside the Runnable below?
2611              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2612              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2613  
2614              // Post callback on main thread
2615              mHandler.post(new Runnable() {
2616                  public void run() {
2617                      final long bindTime = SystemClock.uptimeMillis();
2618                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2619                      if (callbacks != null) {
2620                          callbacks.bindAllApplications(added);
2621                          if (DEBUG_LOADERS) {
2622                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2623                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2624                          }
2625                      } else {
2626                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2627                      }
2628                  }
2629              });
2630  
2631              if (DEBUG_LOADERS) {
2632                  Log.d(TAG, &quot;Icons processed in &quot;
2633                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2634              }
2635          }
2636  
2637          public void dumpState() {
2638              synchronized (sBgLock) {
2639                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2640                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2641                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2642                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2643                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2644              }
2645          }
2646      }
2647  
2648      void enqueuePackageUpdated(PackageUpdatedTask task) {
2649          sWorker.post(task);
2650      }
2651  
2652      private class PackageUpdatedTask implements Runnable {
2653          int mOp;
2654          String[] mPackages;
2655  
2656          public static final int OP_NONE = 0;
2657          public static final int OP_ADD = 1;
2658          public static final int OP_UPDATE = 2;
2659          public static final int OP_REMOVE = 3; // uninstlled
2660          public static final int OP_UNAVAILABLE = 4; // external media unmounted
2661  
2662  
2663          public PackageUpdatedTask(int op, String[] packages) {
2664              mOp = op;
2665              mPackages = packages;
2666          }
2667  
2668          public void run() {
2669              final Context context = mApp.getContext();
2670  
2671              final String[] packages = mPackages;
2672              final int N = packages.length;
2673              switch (mOp) {
2674                  case OP_ADD:
2675                      for (int i=0; i&lt;N; i++) {
2676                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2677 +                        mIconCache.remove(packages[i]);</span>
2678                          mBgAllAppsList.addPackage(context, packages[i]);
2679                      }
2680                      break;
2681                  case OP_UPDATE:
2682                      for (int i=0; i&lt;N; i++) {
2683                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2684                          mBgAllAppsList.updatePackage(context, packages[i]);
2685                          WidgetPreviewLoader.removePackageFromDb(
2686                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
2687                      }
2688                      break;
2689                  case OP_REMOVE:
2690                  case OP_UNAVAILABLE:
2691                      for (int i=0; i&lt;N; i++) {
2692                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2693                          mBgAllAppsList.removePackage(packages[i]);
2694                          WidgetPreviewLoader.removePackageFromDb(
2695                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
2696                      }
2697                      break;
2698              }
2699  
2700              ArrayList&lt;AppInfo&gt; added = null;
2701              ArrayList&lt;AppInfo&gt; modified = null;
2702              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2703  
2704              if (mBgAllAppsList.added.size() &gt; 0) {
2705                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2706                  mBgAllAppsList.added.clear();
2707              }
2708              if (mBgAllAppsList.modified.size() &gt; 0) {
2709                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2710                  mBgAllAppsList.modified.clear();
2711              }
2712              if (mBgAllAppsList.removed.size() &gt; 0) {
2713                  removedApps.addAll(mBgAllAppsList.removed);
2714                  mBgAllAppsList.removed.clear();
2715              }
2716  
2717              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2718              if (callbacks == null) {
2719                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2720                  return;
2721              }
2722  
2723              if (added != null) {
2724                  // Ensure that we add all the workspace applications to the db
2725                  if (LauncherAppState.isDisableAllApps()) {




2726                      final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2727                      addAndBindAddedWorkspaceApps(context, addedInfos);
2728                  } else {
2729                      addAppsToAllApps(context, added);
2730                  }
2731              }
2732  



2733              if (modified != null) {
2734                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2735  
2736                  // Update the launcher db to reflect the changes
2737                  for (AppInfo a : modifiedFinal) {
2738                      ArrayList&lt;ItemInfo&gt; infos =
2739                              getItemInfoForComponentName(a.componentName);
2740                      for (ItemInfo i : infos) {
2741                          if (isShortcutInfoUpdateable(i)) {
2742                              ShortcutInfo info = (ShortcutInfo) i;
2743                              info.title = a.title.toString();
2744                              updateItemInDatabase(context, info);
2745                          }
2746                      }
2747                  }
2748  
2749                  mHandler.post(new Runnable() {
2750                      public void run() {
2751                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2752                          if (callbacks == cb &amp;&amp; cb != null) {
2753                              callbacks.bindAppsUpdated(modifiedFinal);
2754                          }
2755                      }
2756                  });
2757              }
2758  
2759              final ArrayList&lt;String&gt; removedPackageNames =
2760                      new ArrayList&lt;String&gt;();
2761              if (mOp == OP_REMOVE) {
2762                  // Mark all packages in the broadcast to be removed
2763                  removedPackageNames.addAll(Arrays.asList(packages));
2764              } else if (mOp == OP_UPDATE) {
2765                  // Mark disabled packages in the broadcast to be removed
2766                  final PackageManager pm = context.getPackageManager();
2767                  for (int i=0; i&lt;N; i++) {
2768                      if (isPackageDisabled(pm, packages[i])) {
2769                          removedPackageNames.add(packages[i]);
2770                      }
2771                  }
2772              }
2773              // Remove all the components associated with this package
2774              for (String pn : removedPackageNames) {
2775                  ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);
2776                  for (ItemInfo i : infos) {
2777                      deleteItemFromDatabase(context, i);
2778                  }
2779              }
2780              // Remove all the specific components
2781              for (AppInfo a : removedApps) {
2782                  ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);
2783                  for (ItemInfo i : infos) {
2784                      deleteItemFromDatabase(context, i);
2785                  }
2786              }
2787              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
2788                  // Remove any queued items from the install queue
2789                  String spKey = LauncherAppState.getSharedPreferencesKey();
2790                  SharedPreferences sp =
2791                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2792                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2793                  // Call the components-removed callback
2794                  mHandler.post(new Runnable() {
2795                      public void run() {
2796                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2797                          if (callbacks == cb &amp;&amp; cb != null) {
2798                              callbacks.bindComponentsRemoved(removedPackageNames, removedApps);
2799                          }
2800                      }
2801                  });
2802              }
2803  
2804              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
2805                  getSortedWidgetsAndShortcuts(context);
2806              mHandler.post(new Runnable() {
2807                  @Override
2808                  public void run() {
2809                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2810                      if (callbacks == cb &amp;&amp; cb != null) {
2811                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2812                      }
2813                  }
2814              });
2815  
2816              // Write all the logs to disk
2817              mHandler.post(new Runnable() {
2818                  public void run() {
2819                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2820                      if (callbacks == cb &amp;&amp; cb != null) {
2821                          callbacks.dumpLogsToLocalData();
2822                      }
2823                  }
2824              });
2825          }
2826      }
2827  
2828      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2829      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2830          PackageManager packageManager = context.getPackageManager();
2831          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2832          widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());
2833          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2834          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2835          Collections.sort(widgetsAndShortcuts,
2836              new LauncherModel.WidgetAndShortcutNameComparator(packageManager));
2837          return widgetsAndShortcuts;
2838      }
2839  
2840      private static boolean isPackageDisabled(PackageManager pm, String packageName) {
2841          try {
2842              PackageInfo pi = pm.getPackageInfo(packageName, 0);
2843              return !pi.applicationInfo.enabled;
2844          } catch (NameNotFoundException e) {
2845              // Fall through
2846          }
2847          return false;
2848      }
2849  
2850      public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {
2851          if (cn == null) {
2852              return false;
2853          }
2854          if (isPackageDisabled(pm, cn.getPackageName())) {
2855              return false;
2856          }
2857  
2858          try {
2859              // Check the activity
2860              PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);
2861              return (pm.getActivityInfo(cn, 0) != null);
2862          } catch (NameNotFoundException e) {
2863              return false;
2864          }
2865      }
2866  
2867      /**
2868       * Make an ShortcutInfo object for a restored application or shortcut item that points
2869       * to a package that is not yet installed on the system.
2870       */
2871      public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent) {

2872          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2873 -        info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2874 -        info.setIcon(getFallbackIcon());</span>
2875          if (cursor != null) {
2876              info.title =  cursor.getString(titleIndex);
2877          } else {
2878              info.title = &quot;&quot;;
2879          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2880 +        info.setIcon(mIconCache.getIcon(intent, info.title.toString()));</span>
2881          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2882          info.restoredIntent = intent;
2883          return info;
2884      }
2885  
2886      /**
2887       * Make an Intent object for a restored application or shortcut item that points
2888       * to the market page for the item.
2889       */
2890      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2891          final boolean debug = false;
2892          ComponentName componentName = intent.getComponent();
2893          Intent marketIntent = new Intent(Intent.ACTION_VIEW);
2894          Uri marketUri = new Uri.Builder()
2895                  .scheme(&quot;market&quot;)
2896                  .authority(&quot;details&quot;)
2897                  .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())
2898                  .build();
2899          if (debug) Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());

2900          marketIntent.setData(marketUri);
2901          return marketIntent;
2902      }
2903  
2904      /**
2905       * This is called from the code that adds shortcuts from the intent receiver.  This
2906       * doesn&#x27;t have a Cursor, but
2907       */
2908      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {
2909          return getShortcutInfo(manager, intent, context, null, -1, -1, null);
2910      }
2911  
2912      /**
2913       * Make an ShortcutInfo object for a shortcut that is an application.
2914       *
2915       * If c is not null, then it will be used to fill in missing data like the title and icon.
2916       */
2917      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,
2918              Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {
2919          ComponentName componentName = intent.getComponent();
2920          final ShortcutInfo info = new ShortcutInfo();
2921          if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {
2922              Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);
2923              return null;
2924          } else {
2925              try {
2926                  PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);
2927                  info.initFlagsAndFirstInstallTime(pi);
2928              } catch (NameNotFoundException e) {
2929                  Log.d(TAG, &quot;getPackInfo failed for package &quot; +
2930                          componentName.getPackageName());
2931              }
2932          }
2933  
2934          // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t
2935          // then return null &amp; delete this.
2936  
2937          // the resource -- This may implicitly give us back the fallback icon,
2938          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2939          // to avoid saving lots of copies of that in the database, and most apps
2940          // have icons anyway.
2941  
2942          // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and
2943          // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info
2944          // via resolveActivity().
2945          Bitmap icon = null;
2946          ResolveInfo resolveInfo = null;
2947          ComponentName oldComponent = intent.getComponent();
2948          Intent newIntent = new Intent(intent.getAction(), null);
2949          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2950          newIntent.setPackage(oldComponent.getPackageName());
2951          List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);
2952          for (ResolveInfo i : infos) {
2953              ComponentName cn = new ComponentName(i.activityInfo.packageName,
2954                      i.activityInfo.name);
2955              if (cn.equals(oldComponent)) {
2956                  resolveInfo = i;
2957              }
2958          }
2959          if (resolveInfo == null) {
2960              resolveInfo = manager.resolveActivity(intent, 0);
2961          }
2962          if (resolveInfo != null) {
2963              icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);
2964          }
2965          // the db
2966          if (icon == null) {
2967              if (c != null) {
2968                  icon = getIconFromCursor(c, iconIndex, context);
2969              }
2970          }
2971          // the fallback icon
2972          if (icon == null) {
2973              icon = getFallbackIcon();
2974              info.usingFallbackIcon = true;
2975          }
2976          info.setIcon(icon);
2977  
2978          // from the resource
2979          if (resolveInfo != null) {
2980              ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);
2981              if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {
2982                  info.title = labelCache.get(key);
2983              } else {
2984                  info.title = resolveInfo.activityInfo.loadLabel(manager);
2985                  if (labelCache != null) {
2986                      labelCache.put(key, info.title);
2987                  }
2988              }
2989          }
2990          // from the db
2991          if (info.title == null) {
2992              if (c != null) {
2993                  info.title =  c.getString(titleIndex);
2994              }
2995          }
2996          // fall back to the class name of the activity
2997          if (info.title == null) {
2998              info.title = componentName.getClassName();
2999          }
3000          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3001          return info;
3002      }
3003  
3004      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3005              ItemInfoFilter f) {
3006          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3007          for (ItemInfo i : infos) {
3008              if (i instanceof ShortcutInfo) {
3009                  ShortcutInfo info = (ShortcutInfo) i;
3010                  ComponentName cn = info.intent.getComponent();
3011                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3012                      filtered.add(info);
3013                  }
3014              } else if (i instanceof FolderInfo) {
3015                  FolderInfo info = (FolderInfo) i;
3016                  for (ShortcutInfo s : info.contents) {
3017                      ComponentName cn = s.intent.getComponent();
3018                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3019                          filtered.add(s);
3020                      }
3021                  }
3022              } else if (i instanceof LauncherAppWidgetInfo) {
3023                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3024                  ComponentName cn = info.providerName;
3025                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3026                      filtered.add(info);
3027                  }
3028              }
3029          }
3030          return new ArrayList&lt;ItemInfo&gt;(filtered);
3031      }
3032  
3033      private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {
3034          ItemInfoFilter filter  = new ItemInfoFilter() {
3035              @Override
3036              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3037                  return cn.getPackageName().equals(pn);
3038              }
3039          };
3040          return filterItemInfos(sBgItemsIdMap.values(), filter);
3041      }
3042  
3043      private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {
3044          ItemInfoFilter filter  = new ItemInfoFilter() {
3045              @Override
3046              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3047                  return cn.equals(cname);
3048              }
3049          };
3050          return filterItemInfos(sBgItemsIdMap.values(), filter);
3051      }
3052  
3053      public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3054          if (i instanceof ShortcutInfo) {
3055              ShortcutInfo info = (ShortcutInfo) i;
3056              // We need to check for ACTION_MAIN otherwise getComponent() might
3057              // return null for some shortcuts (for instance, for shortcuts to
3058              // web pages.)
3059              Intent intent = info.intent;
3060              ComponentName name = intent.getComponent();
3061              if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3062                      Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3063                  return true;
3064              }
3065              // placeholder shortcuts get special treatment, let them through too.
3066              if (info.getRestoredIntent() != null) {
3067                  return true;
3068              }
3069          }
3070          return false;
3071      }
3072  
3073      /**
3074       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3075       */
3076      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3077              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3078              int titleIndex) {
3079  
3080          Bitmap icon = null;
3081          final ShortcutInfo info = new ShortcutInfo();
3082          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3083  
3084          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3085  
3086          info.title = c.getString(titleIndex);
3087  
3088          int iconType = c.getInt(iconTypeIndex);
3089          switch (iconType) {
3090          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3091              String packageName = c.getString(iconPackageIndex);
3092              String resourceName = c.getString(iconResourceIndex);
3093              PackageManager packageManager = context.getPackageManager();
3094              info.customIcon = false;
3095              // the resource
3096              try {
3097                  Resources resources = packageManager.getResourcesForApplication(packageName);
3098                  if (resources != null) {
3099                      final int id = resources.getIdentifier(resourceName, null, null);
3100                      icon = Utilities.createIconBitmap(
3101                              mIconCache.getFullResIcon(resources, id), context);
3102                  }
3103              } catch (Exception e) {
3104                  // drop this.  we have other places to look for icons
3105              }
3106              // the db
3107              if (icon == null) {
3108                  icon = getIconFromCursor(c, iconIndex, context);
3109              }
3110              // the fallback icon
3111              if (icon == null) {
3112                  icon = getFallbackIcon();
3113                  info.usingFallbackIcon = true;
3114              }
3115              break;
3116          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3117              icon = getIconFromCursor(c, iconIndex, context);
3118              if (icon == null) {
3119                  icon = getFallbackIcon();
3120                  info.customIcon = false;
3121                  info.usingFallbackIcon = true;
3122              } else {
3123                  info.customIcon = true;
3124              }
3125              break;
3126          default:
3127              icon = getFallbackIcon();
3128              info.usingFallbackIcon = true;
3129              info.customIcon = false;
3130              break;
3131          }
3132          info.setIcon(icon);
3133          return info;
3134      }
3135  
3136      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3137          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3138          final boolean debug = false;
3139          if (debug) {
3140              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3141                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3142          }
3143          byte[] data = c.getBlob(iconIndex);
3144          try {
3145              return Utilities.createIconBitmap(
3146                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3147          } catch (Exception e) {
3148              return null;
3149          }
3150      }
3151  
3152      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3153              int cellX, int cellY, boolean notify) {
3154          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3155          if (info == null) {
3156              return null;
3157          }
3158          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3159  
3160          return info;
3161      }
3162  
3163      /**
3164       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3165       */
3166      AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3167              ComponentName component) {
3168          List&lt;AppWidgetProviderInfo&gt; widgets =
3169              AppWidgetManager.getInstance(context).getInstalledProviders();
3170          for (AppWidgetProviderInfo info : widgets) {
3171              if (info.provider.equals(component)) {
3172                  return info;
3173              }
3174          }
3175          return null;
3176      }
3177  
3178      /**
3179       * Returns a list of all the widgets that can handle configuration with a particular mimeType.
3180       */
3181      List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {
3182          final PackageManager packageManager = context.getPackageManager();
3183          final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =
3184              new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();
3185  
3186          final Intent supportsIntent =
3187              new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);
3188          supportsIntent.setType(mimeType);
3189  
3190          // Create a set of widget configuration components that we can test against
3191          final List&lt;AppWidgetProviderInfo&gt; widgets =
3192              AppWidgetManager.getInstance(context).getInstalledProviders();
3193          final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =
3194              new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();
3195          for (AppWidgetProviderInfo info : widgets) {
3196              configurationComponentToWidget.put(info.configure, info);
3197          }
3198  
3199          // Run through each of the intents that can handle this type of clip data, and cross
3200          // reference them with the components that are actual configuration components
3201          final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,
3202                  PackageManager.MATCH_DEFAULT_ONLY);
3203          for (ResolveInfo info : activities) {
3204              final ActivityInfo activityInfo = info.activityInfo;
3205              final ComponentName infoComponent = new ComponentName(activityInfo.packageName,
3206                      activityInfo.name);
3207              if (configurationComponentToWidget.containsKey(infoComponent)) {
3208                  supportedConfigurationActivities.add(
3209                          new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,
3210                                  configurationComponentToWidget.get(infoComponent)));
3211              }
3212          }
3213          return supportedConfigurationActivities;
3214      }
3215  
3216      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3217          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3218          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3219          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3220  
3221          if (intent == null) {
3222              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3223              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3224              return null;
3225          }
3226  
3227          Bitmap icon = null;
3228          boolean customIcon = false;
3229          ShortcutIconResource iconResource = null;
3230  
3231          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3232              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3233              customIcon = true;
3234          } else {
3235              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3236              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3237                  try {
3238                      iconResource = (ShortcutIconResource) extra;
3239                      final PackageManager packageManager = context.getPackageManager();
3240                      Resources resources = packageManager.getResourcesForApplication(
3241                              iconResource.packageName);
3242                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3243                      icon = Utilities.createIconBitmap(
3244                              mIconCache.getFullResIcon(resources, id), context);
3245                  } catch (Exception e) {
3246                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3247                  }
3248              }
3249          }
3250  
3251          final ShortcutInfo info = new ShortcutInfo();
3252  
3253          if (icon == null) {
3254              if (fallbackIcon != null) {
3255                  icon = fallbackIcon;
3256              } else {
3257                  icon = getFallbackIcon();
3258                  info.usingFallbackIcon = true;
3259              }
3260          }
3261          info.setIcon(icon);
3262  
3263          info.title = name;
3264          info.intent = intent;
3265          info.customIcon = customIcon;
3266          info.iconResource = iconResource;
3267  
3268          return info;
3269      }
3270  
3271      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3272              int iconIndex) {
3273          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3274          if (!mAppsCanBeOnRemoveableStorage) {
3275              return false;
3276          }
3277          // If this icon doesn&#x27;t have a custom icon, check to see
3278          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3279          // we&#x27;re going to show, store what we are going to show back
3280          // into the DB.  We do this so when we&#x27;re loading, if the
3281          // package manager can&#x27;t find an icon (for example because
3282          // the app is on SD) then we can use that instead.
3283          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3284              cache.put(info, c.getBlob(iconIndex));
3285              return true;
3286          }
3287          return false;
3288      }
3289      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3290          boolean needSave = false;
3291          try {
3292              if (data != null) {
3293                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3294                  Bitmap loaded = info.getIcon(mIconCache);
3295                  needSave = !saved.sameAs(loaded);
3296              } else {
3297                  needSave = true;
3298              }
3299          } catch (Exception e) {
3300              needSave = true;
3301          }
3302          if (needSave) {
3303              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3304              // This is slower than is ideal, but this only happens once
3305              // or when the app is updated with a new icon.
3306              updateItemInDatabase(context, info);
3307          }
3308      }
3309  
3310      /**
3311       * Return an existing FolderInfo object if we have encountered this ID previously,
3312       * or make a new one.
3313       */
3314      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3315          // See if a placeholder was created for us already
3316          FolderInfo folderInfo = folders.get(id);
3317          if (folderInfo == null) {
3318              // No placeholder -- create a new instance
3319              folderInfo = new FolderInfo();
3320              folders.put(id, folderInfo);
3321          }
3322          return folderInfo;
3323      }
3324  
3325      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3326          final Collator collator = Collator.getInstance();
3327          return new Comparator&lt;AppInfo&gt;() {
3328              public final int compare(AppInfo a, AppInfo b) {
3329                  int result = collator.compare(a.title.toString().trim(),
3330                          b.title.toString().trim());
3331                  if (result == 0) {
3332                      result = a.componentName.compareTo(b.componentName);
3333                  }
3334                  return result;
3335              }
3336          };
3337      }
3338      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3339              = new Comparator&lt;AppInfo&gt;() {
3340          public final int compare(AppInfo a, AppInfo b) {
3341              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3342              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3343              return 0;
3344          }
3345      };
3346      public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {
3347          final Collator collator = Collator.getInstance();
3348          return new Comparator&lt;AppWidgetProviderInfo&gt;() {
3349              public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {
3350                  return collator.compare(a.label.toString().trim(), b.label.toString().trim());
3351              }
3352          };
3353      }
3354      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3355          if (info.activityInfo != null) {
3356              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3357          } else {
3358              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3359          }
3360      }
3361      public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {
3362          private Collator mCollator;
3363          private PackageManager mPackageManager;
3364          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3365          ShortcutNameComparator(PackageManager pm) {
3366              mPackageManager = pm;
3367              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3368              mCollator = Collator.getInstance();
3369          }
3370          ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {
3371              mPackageManager = pm;
3372              mLabelCache = labelCache;
3373              mCollator = Collator.getInstance();
3374          }
3375          public final int compare(ResolveInfo a, ResolveInfo b) {
3376              CharSequence labelA, labelB;
3377              ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);
3378              ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);
3379              if (mLabelCache.containsKey(keyA)) {
3380                  labelA = mLabelCache.get(keyA);
3381              } else {
3382                  labelA = a.loadLabel(mPackageManager).toString().trim();
3383  
3384                  mLabelCache.put(keyA, labelA);
3385              }
3386              if (mLabelCache.containsKey(keyB)) {
3387                  labelB = mLabelCache.get(keyB);
3388              } else {
3389                  labelB = b.loadLabel(mPackageManager).toString().trim();
3390  
3391                  mLabelCache.put(keyB, labelB);
3392              }
3393              return mCollator.compare(labelA, labelB);
3394          }
3395      };
3396      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3397          private Collator mCollator;
3398          private PackageManager mPackageManager;
3399          private HashMap&lt;Object, String&gt; mLabelCache;
3400          WidgetAndShortcutNameComparator(PackageManager pm) {
3401              mPackageManager = pm;
3402              mLabelCache = new HashMap&lt;Object, String&gt;();
3403              mCollator = Collator.getInstance();
3404          }
3405          public final int compare(Object a, Object b) {
3406              String labelA, labelB;
3407              if (mLabelCache.containsKey(a)) {
3408                  labelA = mLabelCache.get(a);
3409              } else {
3410                  labelA = (a instanceof AppWidgetProviderInfo) ?
3411                      ((AppWidgetProviderInfo) a).label :
3412                      ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3413                  mLabelCache.put(a, labelA);
3414              }
3415              if (mLabelCache.containsKey(b)) {
3416                  labelB = mLabelCache.get(b);
3417              } else {
3418                  labelB = (b instanceof AppWidgetProviderInfo) ?
3419                      ((AppWidgetProviderInfo) b).label :
3420                      ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3421                  mLabelCache.put(b, labelB);
3422              }
3423              return mCollator.compare(labelA, labelB);
3424          }
3425      };
3426  
3427      public void dumpState() {
3428          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3429          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3430          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3431          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3432          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3433          if (mLoaderTask != null) {
3434              mLoaderTask.dumpState();
3435          } else {
3436              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3437          }
3438      }
3439  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            