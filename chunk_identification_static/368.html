<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>368</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    368
                    <a href="367.html">prev</a>
                    <a href="369.html">next</a>
                    <a href="368_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_21b0e2ad2fb2e40fe8aea28c453f6ab209e5f1af_core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;21b0e2ad2fb2e40fe8aea28c453f6ab209e5f1af:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;21b0e2ad2fb2e40fe8aea28c453f6ab209e5f1af^1:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;21b0e2ad2fb2e40fe8aea28c453f6ab209e5f1af^2:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;210b9c3cb61e84b04c5f09f8f0fccec9c746acb0:core/src/main/java/com/dtstack/flink/sql/format/dtnest/DtNestRowDeserializationSchema.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [j]], subset: [[b], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.format.dtnest;
  20 
  21 import com.dtstack.flink.sql.table.AbstractTableInfo;
  22 import com.google.common.base.Strings;
  23 import com.google.common.collect.Maps;
  24 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25 import org.apache.flink.api.common.typeinfo.TypeInformation;
  26 import org.apache.flink.api.common.typeinfo.Types;
  27 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  29 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  30 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  31 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  32 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  33 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  34 import org.apache.flink.types.Row;
  35 
  36 import java.io.IOException;
  37 import java.sql.Date;
  38 import java.sql.Time;
  39 import java.sql.Timestamp;
  40 import java.util.Iterator;
  41 import java.util.List;
  42 import java.util.Map;
  43 
  44 /**
  45  * source data parse to json format
  46  *
  47  * Date: 2019/12/12
  48  * Company: www.dtstack.com
  49  *
  50  * @author maqi
  51  */
  52 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  53 
  54     private final ObjectMapper objectMapper = new ObjectMapper();
  55 
  56     private Map&lt;String, String&gt; rowAndFieldMapping;
  57     private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  58 
  59     private final String[] fieldNames;
  60     private final TypeInformation&lt;?&gt;[] fieldTypes;
  61 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  62     private List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  63     private String charsetName;</span>
  64 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  65     private List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  66 </span>
  67 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  68     private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
  69 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  70 
  71 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  72     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,">  72     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73                                           List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  74                                           String charsetName) {</span>
  75 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  76         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  77         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  78         this.rowAndFieldMapping = rowAndFieldMapping;</span>
  79 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  80     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  80     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
  81 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  82         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  83         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  84         this.rowAndFieldMapping = rowAndFieldMapping;
  85         this.fieldExtraInfos = fieldExtraInfos;
  86         this.charsetName = charsetName;
  87     }
  88 
  89     @Override
  90     public Row deserialize(byte[] message) throws IOException {
  91         String decoderStr = new String(message, charsetName);
  92         JsonNode root = objectMapper.readTree(decoderStr);
  93         this.parseTree(root, null);
  94         Row row = new Row(fieldNames.length);
  95 
  96         try {
  97             for (int i = 0; i &lt; fieldNames.length; i++) {
  98                 JsonNode node = getIgnoreCase(fieldNames[i]);
  99                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
 100 
 101                 if (node == null) {
 102                     if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
 103                         throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
 104                                 + fieldNames[i] + &quot;&#x27;.&quot;);
 105                     } else {
 106                         row.setField(i, null);
 107                     }
 108                 } else {
 109                     // Read the value as specified type
 110                     Object value = convert(node, fieldTypes[i]);
 111                     row.setField(i, value);
 112                 }
 113             }
 114             return row;
 115         } finally {
 116             nodeAndJsonNodeMapping.clear();
 117         }
 118     }
 119 
 120     private void parseTree(JsonNode jsonNode, String prefix){
 121         if (jsonNode.isArray()) {
 122             ArrayNode array = (ArrayNode) jsonNode;
 123             for (int i = 0; i &lt; array.size(); i++) {
 124                 JsonNode child = array.get(i);
 125                 String nodeKey = getNodeKey(prefix, i);
 126 
 127                 if (child.isValueNode()) {
 128                     nodeAndJsonNodeMapping.put(nodeKey, child);
 129                 } else {
 130                     if (rowAndFieldMapping.containsValue(nodeKey)) {
 131                         nodeAndJsonNodeMapping.put(nodeKey, child);
 132                     }
 133                     parseTree(child, nodeKey);
 134                 }
 135             }
 136             return;
 137         }
 138         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 139         while (iterator.hasNext()){
 140             String next = iterator.next();
 141             JsonNode child = jsonNode.get(next);
 142             String nodeKey = getNodeKey(prefix, next);
 143 
 144             nodeAndJsonNodeMapping.put(nodeKey, child);
 145             if(child.isArray()){
 146                 parseTree(child, nodeKey);
 147             }else {
 148                 parseTree(child, nodeKey);
 149             }
 150         }
 151     }
 152 
 153     private JsonNode getIgnoreCase(String key) {
 154         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 155         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 156     }
 157 
 158     private String getNodeKey(String prefix, String nodeName){
 159         if(Strings.isNullOrEmpty(prefix)){
 160             return nodeName;
 161         }
 162         return prefix + &quot;.&quot; + nodeName;
 163     }
 164 
 165     private String getNodeKey(String prefix, int i) {
 166         if (Strings.isNullOrEmpty(prefix)) {
 167             return &quot;[&quot; + i + &quot;]&quot;;
 168         }
 169         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 170     }
 171 
 172     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 173         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 174             return node.asBoolean();
 175         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 176             if (node instanceof ObjectNode) {
 177                 return node.toString();
 178             } else if (node instanceof NullNode) {
 179                 return null;
 180             } else {
 181                 return node.asText();
 182             }
 183         }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 184             return Date.valueOf(node.asText());
 185         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 186             // local zone
 187             return Time.valueOf(node.asText());
 188         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 189             // local zone
 190             return Timestamp.valueOf(node.asText());
 191         }  else {
 192             // for types that were specified without JSON schema
 193             // e.g. POJOs
 194             try {
 195                 return objectMapper.treeToValue(node, info.getTypeClass());
 196             } catch (JsonProcessingException e) {
<abbr title=" 197                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);"> 197                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; ðŸ”µ</abbr>
 198             }
 199         }
 200     }
 201 
 202 
 203 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.format.dtnest;
  20 
  21 import com.dtstack.flink.sql.table.AbstractTableInfo;
  22 import com.google.common.base.Strings;
  23 import com.google.common.collect.Maps;
  24 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25 import org.apache.flink.api.common.typeinfo.TypeInformation;
  26 import org.apache.flink.api.common.typeinfo.Types;
  27 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  29 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  30 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  31 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  32 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  33 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  34 import org.apache.flink.types.Row;
  35 
  36 import java.io.IOException;
  37 import java.sql.Date;
  38 import java.sql.Time;
  39 import java.sql.Timestamp;
  40 import java.util.Iterator;
  41 import java.util.List;
  42 import java.util.Map;
  43 
  44 /**
  45  * source data parse to json format
  46  *
  47  * Date: 2019/12/12
  48  * Company: www.dtstack.com
  49  *
  50  * @author maqi
  51  */
  52 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  53 
  54     private final ObjectMapper objectMapper = new ObjectMapper();
  55 
  56     private Map&lt;String, String&gt; rowAndFieldMapping;
  57     private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  58 
  59     private final String[] fieldNames;
  60     private final TypeInformation&lt;?&gt;[] fieldTypes;
  61     private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;
  62     private String charsetName;
  63 
  64 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title="  65     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,">  65     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  66                                           List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  67                                           String charsetName) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  68         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  69         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  70         this.rowAndFieldMapping = rowAndFieldMapping;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71         this.fieldExtraInfos = fieldExtraInfos;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  72         this.charsetName = charsetName;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73     }</span>
  74 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="  75     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  75     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  76         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  77         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  78         this.rowAndFieldMapping = rowAndFieldMapping;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  79         this.fieldExtraInfos = fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80     }</span>
  81 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title="  82     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  82     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  83         this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  84         this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  85         this.rowAndFieldMapping = rowAndFieldMapping;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  86         this.fieldExtraInfos = fieldExtraInfos;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87     }</span>
  88 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
  89 
  90     @Override
  91     public Row deserialize(byte[] message) throws IOException {
  92         String decoderStr = new String(message, charsetName);
  93         JsonNode root = objectMapper.readTree(decoderStr);
  94         this.parseTree(root, null);
  95         Row row = new Row(fieldNames.length);
  96 
  97         try {
  98             for (int i = 0; i &lt; fieldNames.length; i++) {
  99                 JsonNode node = getIgnoreCase(fieldNames[i]);
 100                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
 101 
 102                 if (node == null) {
 103                     if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
 104                         throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
 105                                 + fieldNames[i] + &quot;&#x27;.&quot;);
 106                     } else {
 107                         row.setField(i, null);
 108                     }
 109                 } else {
 110                     // Read the value as specified type
 111                     Object value = convert(node, fieldTypes[i]);
 112                     row.setField(i, value);
 113                 }
 114             }
 115             return row;
 116         } finally {
 117             nodeAndJsonNodeMapping.clear();
 118         }
 119     }
 120 
 121     private void parseTree(JsonNode jsonNode, String prefix){
 122         if (jsonNode.isArray()) {
 123             ArrayNode array = (ArrayNode) jsonNode;
 124             for (int i = 0; i &lt; array.size(); i++) {
 125                 JsonNode child = array.get(i);
 126                 String nodeKey = getNodeKey(prefix, i);
 127 
 128                 if (child.isValueNode()) {
 129                     nodeAndJsonNodeMapping.put(nodeKey, child);
 130                 } else {
 131                     if (rowAndFieldMapping.containsValue(nodeKey)) {
 132                         nodeAndJsonNodeMapping.put(nodeKey, child);
 133                     }
 134                     parseTree(child, nodeKey);
 135                 }
 136             }
 137             return;
 138         }
 139         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 140         while (iterator.hasNext()){
 141             String next = iterator.next();
 142             JsonNode child = jsonNode.get(next);
 143             String nodeKey = getNodeKey(prefix, next);
 144 
 145             nodeAndJsonNodeMapping.put(nodeKey, child);
 146             if(child.isArray()){
 147                 parseTree(child, nodeKey);
 148             }else {
 149                 parseTree(child, nodeKey);
 150             }
 151         }
 152     }
 153 
 154     private JsonNode getIgnoreCase(String key) {
 155         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 156         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 157     }
 158 
 159     private String getNodeKey(String prefix, String nodeName){
 160         if(Strings.isNullOrEmpty(prefix)){
 161             return nodeName;
 162         }
 163         return prefix + &quot;.&quot; + nodeName;
 164     }
 165 
 166     private String getNodeKey(String prefix, int i) {
 167         if (Strings.isNullOrEmpty(prefix)) {
 168             return &quot;[&quot; + i + &quot;]&quot;;
 169         }
 170         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 171     }
 172 
 173     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 174         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 175             return node.asBoolean();
 176         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 177             if (node instanceof ObjectNode) {
 178                 return node.toString();
 179             } else if (node instanceof NullNode) {
 180                 return null;
 181             } else {
 182                 return node.asText();
 183             }
 184         }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 185             return Date.valueOf(node.asText());
 186         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 187             // local zone
 188             return Time.valueOf(node.asText());
 189         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 190             // local zone
 191             return Timestamp.valueOf(node.asText());
 192         }  else {
 193             // for types that were specified without JSON schema
 194             // e.g. POJOs
 195             try {
 196                 return objectMapper.treeToValue(node, info.getTypeClass());
 197             } catch (JsonProcessingException e) {
<abbr title=" 198                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);"> 198                 throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; ðŸ”µ</abbr>
 199             }
 200         }
 201     }
 202 
 203 
 204 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.format.dtnest;
  19 
  20 import com.dtstack.flink.sql.table.AbstractTableInfo;
  21 import com.google.common.base.Strings;
  22 import com.google.common.collect.Maps;
  23 import java.io.IOException;
  24 import java.sql.Date;
  25 import java.sql.Time;
  26 import java.sql.Timestamp;
  27 import java.util.Iterator;
  28 import java.util.List;
  29 import java.util.Map;
  30 import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  31 import org.apache.flink.api.common.typeinfo.TypeInformation;
  32 import org.apache.flink.api.common.typeinfo.Types;
  33 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  34 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  35 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  36 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  37 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
  38 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;
  39 import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;
  40 import org.apache.flink.types.Row;
  41 
  42 
  43 /**
  44  * source data parse to json format
  45  *
  46  * Date: 2019/12/12
  47  * Company: www.dtstack.com
  48  *
  49  * @author maqi
  50  */
  51 public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  52     private final ObjectMapper objectMapper = new ObjectMapper();
  53 
  54     private Map&lt;String, String&gt; rowAndFieldMapping;
  55 
  56     private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  57 
  58     private final String[] fieldNames;
  59 
  60     private final TypeInformation&lt;?&gt;[] fieldTypes;
  61 
  62     private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;
  63 
  64     private String charsetName;
  65 
<abbr title="  66     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos, String charsetName) {">  66     public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMðŸ”µ</abbr>
  67         this.fieldNames = ((RowTypeInfo) (typeInfo)).getFieldNames();
  68         this.fieldTypes = ((RowTypeInfo) (typeInfo)).getFieldTypes();
  69         this.rowAndFieldMapping = rowAndFieldMapping;
  70         this.fieldExtraInfos = fieldExtraInfos;
  71         this.charsetName = charsetName;
  72     }
  73 
  74     @Override
  75     public Row deserialize(byte[] message) throws IOException {
  76         String decoderStr = new String(message, charsetName);
  77         JsonNode root = objectMapper.readTree(decoderStr);
  78         this.parseTree(root, null);
  79         Row row = new Row(fieldNames.length);
  80         try {
  81             for (int i = 0; i &lt; fieldNames.length; i++) {
  82                 JsonNode node = getIgnoreCase(fieldNames[i]);
  83                 AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);
  84                 if (node == null) {
  85                     if ((fieldExtraInfo != null) &amp;&amp; fieldExtraInfo.getNotNull()) {
<abbr title="  86                         throw new IllegalStateException((&quot;Failed to find field with name &#x27;&quot; + fieldNames[i]) + &quot;&#x27;.&quot;);">  86                         throw new IllegalStateException((&quot;Failed to find field with name &#x27;&quot; + fieldNames[ðŸ”µ</abbr>
  87                     } else {
  88                         row.setField(i, null);
  89                     }
  90                 } else {
  91                     // Read the value as specified type
  92                     Object value = convert(node, fieldTypes[i]);
  93                     row.setField(i, value);
  94                 }
  95             }
  96             return row;
  97         } finally {
  98             nodeAndJsonNodeMapping.clear();
  99         }
 100     }
 101 
 102     private void parseTree(JsonNode jsonNode, String prefix){
 103         if (jsonNode.isArray()) {
 104             ArrayNode array = (ArrayNode) jsonNode;
 105             for (int i = 0; i &lt; array.size(); i++) {
 106                 JsonNode child = array.get(i);
 107                 String nodeKey = getNodeKey(prefix, i);
 108 
 109                 if (child.isValueNode()) {
 110                     nodeAndJsonNodeMapping.put(nodeKey, child);
 111                 } else {
 112                     if (rowAndFieldMapping.containsValue(nodeKey)) {
 113                         nodeAndJsonNodeMapping.put(nodeKey, child);
 114                     }
 115                     parseTree(child, nodeKey);
 116                 }
 117             }
 118             return;
 119         }
 120         Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 121         while (iterator.hasNext()){
 122             String next = iterator.next();
 123             JsonNode child = jsonNode.get(next);
 124             String nodeKey = getNodeKey(prefix, next);
 125 
 126             nodeAndJsonNodeMapping.put(nodeKey, child);
 127             if(child.isArray()){
 128                 parseTree(child, nodeKey);
 129             }else {
 130                 parseTree(child, nodeKey);
 131             }
 132         }
 133     }
 134 
 135     private JsonNode getIgnoreCase(String key) {
 136         String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 137         return nodeAndJsonNodeMapping.get(nodeMappingKey);
 138     }
 139 
 140     private String getNodeKey(String prefix, String nodeName){
 141         if(Strings.isNullOrEmpty(prefix)){
 142             return nodeName;
 143         }
 144         return prefix + &quot;.&quot; + nodeName;
 145     }
 146 
 147     private String getNodeKey(String prefix, int i) {
 148         if (Strings.isNullOrEmpty(prefix)) {
 149             return &quot;[&quot; + i + &quot;]&quot;;
 150         }
 151         return prefix + &quot;[&quot; + i + &quot;]&quot;;
 152     }
 153 
 154     private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 155         if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 156             return node.asBoolean();
 157         } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 158             if (node instanceof ObjectNode) {
 159                 return node.toString();
 160             } else if (node instanceof NullNode) {
 161                 return null;
 162             } else {
 163                 return node.asText();
 164             }
 165         } else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 166             return Date.valueOf(node.asText());
 167         } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 168             // local zone
 169             return Time.valueOf(node.asText());
 170         } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 171             // local zone
 172             return Timestamp.valueOf(node.asText());
 173         } else {
 174             // for types that were specified without JSON schema
 175             // e.g. POJOs
 176             try {
 177                 return objectMapper.treeToValue(node, info.getTypeClass());
 178             } catch (JsonProcessingException e) {
<abbr title=" 179                 throw new IllegalStateException(((&quot;Unsupported type information &#x27;&quot; + info) + &quot;&#x27; for node: &quot;) + node);"> 179                 throw new IllegalStateException(((&quot;Unsupported type information &#x27;&quot; + info) + &quot;&#x27; for node:ðŸ”µ</abbr>
 180             }
 181         }
 182     }
 183 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.format.dtnest;
  20  
  21  import com.dtstack.flink.sql.table.TableInfo;

  22  import com.google.common.base.Strings;
  23  import com.google.common.collect.Maps;
  24  import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  25  import org.apache.flink.api.common.typeinfo.TypeInformation;
  26  import org.apache.flink.api.common.typeinfo.Types;
  27  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  28  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  29  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  30  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
  31  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.*;
  32  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;


  33  import org.apache.flink.types.Row;
  34  
  35  import java.io.IOException;
  36  import java.sql.Date;
  37  import java.sql.Time;
  38  import java.sql.Timestamp;
  39  import java.util.Iterator;
  40  import java.util.List;
  41  import java.util.Map;
  42  
  43  /**
  44   * source data parse to json format
  45   *
  46   * Date: 2019/12/12
  47   * Company: www.dtstack.com
  48   *
  49   * @author maqi
  50   */
  51  public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  52  
  53      private final ObjectMapper objectMapper = new ObjectMapper();
  54  
  55      private Map&lt;String, String&gt; rowAndFieldMapping;
  56      private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  57  
  58      private final String[] fieldNames;
  59      private final TypeInformation&lt;?&gt;[] fieldTypes;
  60      private List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +    private String charsetName;</span>
  62  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  63 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  63 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, LðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +                                          List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +                                          String charsetName) {</span>
  67          this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  68          this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  69          this.rowAndFieldMapping = rowAndFieldMapping;
  70          this.fieldExtraInfos = fieldExtraInfos;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +        this.charsetName = charsetName;</span>
  72      }
  73  
  74      @Override
  75      public Row deserialize(byte[] message) throws IOException {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -        JsonNode root = objectMapper.readTree(message);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +        String decoderStr = new String(message, charsetName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +        JsonNode root = objectMapper.readTree(decoderStr);</span>
  79          this.parseTree(root, null);
  80          Row row = new Row(fieldNames.length);
  81  
  82          try {
  83              for (int i = 0; i &lt; fieldNames.length; i++) {
  84                  JsonNode node = getIgnoreCase(fieldNames[i]);
  85                  TableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);

  86  
  87                  if (node == null) {
  88                      if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
  89                          throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
  90                                  + fieldNames[i] + &quot;&#x27;.&quot;);
  91                      } else {
  92                          row.setField(i, null);
  93                      }
  94                  } else {
  95                      // Read the value as specified type
  96                      Object value = convert(node, fieldTypes[i]);
  97                      row.setField(i, value);
  98                  }
  99              }
 100              return row;
 101          } finally {
 102              nodeAndJsonNodeMapping.clear();
 103          }
 104      }
 105  
 106      private void parseTree(JsonNode jsonNode, String prefix){
 107          if (jsonNode.isArray()) {
 108              ArrayNode array = (ArrayNode) jsonNode;
 109              for (int i = 0; i &lt; array.size(); i++) {
 110                  JsonNode child = array.get(i);
 111                  String nodeKey = getNodeKey(prefix, i);
 112  
 113                  if (child.isValueNode()) {
 114                      nodeAndJsonNodeMapping.put(nodeKey, child);
 115                  } else {
 116                      if (rowAndFieldMapping.containsValue(nodeKey)) {
 117                          nodeAndJsonNodeMapping.put(nodeKey, child);
 118                      }
 119                      parseTree(child, nodeKey);
 120                  }
 121              }
 122              return;
 123          }
 124          Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 125          while (iterator.hasNext()){
 126              String next = iterator.next();
 127              JsonNode child = jsonNode.get(next);
 128              String nodeKey = getNodeKey(prefix, next);
 129  
 130              nodeAndJsonNodeMapping.put(nodeKey, child);
 131              if(child.isArray()){
 132                  parseTree(child, nodeKey);
 133              }else {
 134                  parseTree(child, nodeKey);
 135              }
 136          }
 137      }
 138  
 139      private JsonNode getIgnoreCase(String key) {
 140          String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 141          return nodeAndJsonNodeMapping.get(nodeMappingKey);
 142      }
 143  
 144      private String getNodeKey(String prefix, String nodeName){
 145          if(Strings.isNullOrEmpty(prefix)){
 146              return nodeName;
 147          }
 148          return prefix + &quot;.&quot; + nodeName;
 149      }
 150  
 151      private String getNodeKey(String prefix, int i) {
 152          if (Strings.isNullOrEmpty(prefix)) {
 153              return &quot;[&quot; + i + &quot;]&quot;;
 154          }
 155          return prefix + &quot;[&quot; + i + &quot;]&quot;;
 156      }
 157  
 158      private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 159          if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 160              return node.asBoolean();
 161          } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 162              if (node instanceof ObjectNode) {
 163                  return node.toString();
 164              } else if (node instanceof NullNode) {
 165                  return null;
 166              } else {
 167                  return node.asText();
 168              }
 169          }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 170              return Date.valueOf(node.asText());
 171          } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 172              // local zone
 173              return Time.valueOf(node.asText());
 174          } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 175              // local zone
 176              return Timestamp.valueOf(node.asText());
 177          }  else {
 178              // for types that were specified without JSON schema
 179              // e.g. POJOs
 180              try {
 181                  return objectMapper.treeToValue(node, info.getTypeClass());
 182              } catch (JsonProcessingException e) {
 183                  throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);
 184              }
 185          }
 186      }
 187  
 188  
 189  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.format.dtnest;
  20  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import com.dtstack.flink.sql.table.TableInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import com.dtstack.flink.sql.table.AbstractTableInfo;</span>
  23  import com.google.common.base.Strings;
  24  import com.google.common.collect.Maps;
  25  import org.apache.flink.api.common.serialization.AbstractDeserializationSchema;
  26  import org.apache.flink.api.common.typeinfo.TypeInformation;
  27  import org.apache.flink.api.common.typeinfo.Types;
  28  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  29  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
  30  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;
  31  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.*;</span>
  33  import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.NullNode;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;</span>
  36  import org.apache.flink.types.Row;
  37  
  38  import java.io.IOException;
  39  import java.sql.Date;
  40  import java.sql.Time;
  41  import java.sql.Timestamp;
  42  import java.util.Iterator;
  43  import java.util.List;
  44  import java.util.Map;
  45  
  46  /**
  47   * source data parse to json format
  48   *
  49   * Date: 2019/12/12
  50   * Company: www.dtstack.com
  51   *
  52   * @author maqi
  53   */
  54  public class DtNestRowDeserializationSchema extends AbstractDeserializationSchema&lt;Row&gt; {
  55  
  56      private final ObjectMapper objectMapper = new ObjectMapper();
  57  
  58      private Map&lt;String, String&gt; rowAndFieldMapping;
  59      private Map&lt;String, JsonNode&gt; nodeAndJsonNodeMapping = Maps.newHashMap();
  60  
  61      private final String[] fieldNames;
  62      private final TypeInformation&lt;?&gt;[] fieldTypes;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  63 -    private List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +    private List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos;</span>
  65  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  66 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;TableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  66 -    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, LðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  67 +    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, List&lt;AbstractTableInfo.FieldExtraInfo&gt; fieldExtraInfos) {">  67 +    public DtNestRowDeserializationSchema(TypeInformation&lt;Row&gt; typeInfo, Map&lt;String, String&gt; rowAndFieldMapping, LðŸ”µ</abbr></span>


  68          this.fieldNames = ((RowTypeInfo) typeInfo).getFieldNames();
  69          this.fieldTypes = ((RowTypeInfo) typeInfo).getFieldTypes();
  70          this.rowAndFieldMapping = rowAndFieldMapping;
  71          this.fieldExtraInfos = fieldExtraInfos;

  72      }
  73  
  74      @Override
  75      public Row deserialize(byte[] message) throws IOException {
  76          JsonNode root = objectMapper.readTree(message);


  77          this.parseTree(root, null);
  78          Row row = new Row(fieldNames.length);
  79  
  80          try {
  81              for (int i = 0; i &lt; fieldNames.length; i++) {
  82                  JsonNode node = getIgnoreCase(fieldNames[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -                TableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +                AbstractTableInfo.FieldExtraInfo fieldExtraInfo = fieldExtraInfos.get(i);</span>
  85  
  86                  if (node == null) {
  87                      if (fieldExtraInfo != null &amp;&amp; fieldExtraInfo.getNotNull()) {
  88                          throw new IllegalStateException(&quot;Failed to find field with name &#x27;&quot;
  89                                  + fieldNames[i] + &quot;&#x27;.&quot;);
  90                      } else {
  91                          row.setField(i, null);
  92                      }
  93                  } else {
  94                      // Read the value as specified type
  95                      Object value = convert(node, fieldTypes[i]);
  96                      row.setField(i, value);
  97                  }
  98              }
  99              return row;
 100          } finally {
 101              nodeAndJsonNodeMapping.clear();
 102          }
 103      }
 104  
 105      private void parseTree(JsonNode jsonNode, String prefix){
 106          if (jsonNode.isArray()) {
 107              ArrayNode array = (ArrayNode) jsonNode;
 108              for (int i = 0; i &lt; array.size(); i++) {
 109                  JsonNode child = array.get(i);
 110                  String nodeKey = getNodeKey(prefix, i);
 111  
 112                  if (child.isValueNode()) {
 113                      nodeAndJsonNodeMapping.put(nodeKey, child);
 114                  } else {
 115                      if (rowAndFieldMapping.containsValue(nodeKey)) {
 116                          nodeAndJsonNodeMapping.put(nodeKey, child);
 117                      }
 118                      parseTree(child, nodeKey);
 119                  }
 120              }
 121              return;
 122          }
 123          Iterator&lt;String&gt; iterator = jsonNode.fieldNames();
 124          while (iterator.hasNext()){
 125              String next = iterator.next();
 126              JsonNode child = jsonNode.get(next);
 127              String nodeKey = getNodeKey(prefix, next);
 128  
 129              nodeAndJsonNodeMapping.put(nodeKey, child);
 130              if(child.isArray()){
 131                  parseTree(child, nodeKey);
 132              }else {
 133                  parseTree(child, nodeKey);
 134              }
 135          }
 136      }
 137  
 138      private JsonNode getIgnoreCase(String key) {
 139          String nodeMappingKey = rowAndFieldMapping.getOrDefault(key, key);
 140          return nodeAndJsonNodeMapping.get(nodeMappingKey);
 141      }
 142  
 143      private String getNodeKey(String prefix, String nodeName){
 144          if(Strings.isNullOrEmpty(prefix)){
 145              return nodeName;
 146          }
 147          return prefix + &quot;.&quot; + nodeName;
 148      }
 149  
 150      private String getNodeKey(String prefix, int i) {
 151          if (Strings.isNullOrEmpty(prefix)) {
 152              return &quot;[&quot; + i + &quot;]&quot;;
 153          }
 154          return prefix + &quot;[&quot; + i + &quot;]&quot;;
 155      }
 156  
 157      private Object convert(JsonNode node, TypeInformation&lt;?&gt; info) {
 158          if (info.getTypeClass().equals(Types.BOOLEAN.getTypeClass())) {
 159              return node.asBoolean();
 160          } else if (info.getTypeClass().equals(Types.STRING.getTypeClass())) {
 161              if (node instanceof ObjectNode) {
 162                  return node.toString();
 163              } else if (node instanceof NullNode) {
 164                  return null;
 165              } else {
 166                  return node.asText();
 167              }
 168          }  else if (info.getTypeClass().equals(Types.SQL_DATE.getTypeClass())) {
 169              return Date.valueOf(node.asText());
 170          } else if (info.getTypeClass().equals(Types.SQL_TIME.getTypeClass())) {
 171              // local zone
 172              return Time.valueOf(node.asText());
 173          } else if (info.getTypeClass().equals(Types.SQL_TIMESTAMP.getTypeClass())) {
 174              // local zone
 175              return Timestamp.valueOf(node.asText());
 176          }  else {
 177              // for types that were specified without JSON schema
 178              // e.g. POJOs
 179              try {
 180                  return objectMapper.treeToValue(node, info.getTypeClass());
 181              } catch (JsonProcessingException e) {
 182                  throw new IllegalStateException(&quot;Unsupported type information &#x27;&quot; + info + &quot;&#x27; for node: &quot; + node);
 183              }
 184          }
 185      }
 186  
 187  
 188  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            