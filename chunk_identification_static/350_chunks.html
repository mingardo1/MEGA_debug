<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>350 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.rmi.RemoteException;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public ImpalaOutputFormat(\n&#x27;
                         &#x27;            JDBCOptions options,\n&#x27;
                         &#x27;            String[] fieldNames,\n&#x27;
                         &#x27;            String[] keyFields,\n&#x27;
                         &#x27;            String[] partitionFields,\n&#x27;
                         &#x27;            int[] fieldTypes,\n&#x27;
                         &#x27;            int flushMaxSize,\n&#x27;
                         &#x27;            long flushIntervalMills,\n&#x27;
                         &#x27;            boolean allReplace,\n&#x27;
                         &#x27;            String updateMode,\n&#x27;
                         &#x27;            Integer authMech,\n&#x27;
                         &#x27;            String keytabPath,\n&#x27;
                         &#x27;            String krb5confPath,\n&#x27;
                         &#x27;            String principal) {\n&#x27;
                         &#x27;        super(options,\n&#x27;
                         &#x27;                fieldNames,\n&#x27;
                         &#x27;                keyFields,\n&#x27;
                         &#x27;                partitionFields,\n&#x27;
                         &#x27;                fieldTypes,\n&#x27;
                         &#x27;                flushMaxSize,\n&#x27;
                         &#x27;                flushIntervalMills,\n&#x27;
                         &#x27;                allReplace,\n&#x27;
                         &#x27;                updateMode);\n&#x27;
                         &#x27;        this.authMech = authMech;\n&#x27;
                         &#x27;        this.keytabPath = keytabPath;\n&#x27;
                         &#x27;        this.krb5confPath = krb5confPath;\n&#x27;
                         &#x27;        this.principal = principal;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(ImpalaOutputFormat.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // ${field}\n&#x27;
                           &#x27;    private static final Pattern &#x27;
                           &#x27;STATIC_PARTITION_PATTERN = &#x27;
                           &#x27;Pattern.compile(&quot;\\\\$\\\\{([^}]*)}&quot;);\n&#x27;
                           &quot;    // cast(value as string) -&gt; cast(&#x27;value&#x27; as &quot;
                           &quot;string)  cast(value as timestamp) -&gt; cast(&#x27;value&#x27; &quot;
                           &#x27;as timestamp)\n&#x27;
                           &#x27;    private static final Pattern TYPE_PATTERN = &#x27;
                           &#x27;Pattern.compile(&quot;cast\\\\((.*) as (.*)\\\\)&quot;);\n&#x27;
                           &#x27;    //specific type which values need to be &#x27;
                           &#x27;quoted\n&#x27;
                           &#x27;    private static final String[] NEED_QUOTE_TYPE &#x27;
                           &#x27;= {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Integer &#x27;
                           &#x27;DEFAULT_CONN_TIME_OUT = 60;\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;RECEIVE_DATA_PRINT_FREQUENCY = 1000;\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;DIRTY_DATA_PRINT_FREQUENCY = 1000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String KUDU_TYPE = &#x27;
                           &#x27;&quot;kudu&quot;;\n&#x27;
                           &#x27;    private static final String UPDATE_MODE = &#x27;
                           &#x27;&quot;update&quot;;\n&#x27;
                           &#x27;    private static final String PARTITION_CONSTANT &#x27;
                           &#x27;= &quot;PARTITION&quot;;\n&#x27;
                           &#x27;    private static final String DRIVER_NAME = &#x27;
                           &#x27;&quot;com.cloudera.impala.jdbc41.Driver&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String VALUES_CONDITION = &#x27;
                           &#x27;&quot;${valuesCondition}&quot;;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;PARTITION_CONDITION = &quot;${partitionCondition}&quot;;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;TABLE_FIELDS_CONDITION = &#x27;
                           &#x27;&quot;${tableFieldsCondition}&quot;;\n&#x27;
                           &#x27;    private static final String NO_PARTITION = &#x27;
                           &#x27;&quot;noPartition&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    protected transient Connection connection;\n&#x27;
                           &#x27;    protected transient Statement statement;\n&#x27;
                           &#x27;    protected transient PreparedStatement &#x27;
                           &#x27;updateStatement;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private transient volatile boolean closed = &#x27;
                           &#x27;false;\n&#x27;
                           &#x27;    private int batchCount = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // |   partitionCondition   |Array of &#x27;
                           &#x27;valueCondition|\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, &#x27;
                           &#x27;v4, v5)]|   DP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne = v1, ptTwo = v2 | [(v3, v4, &#x27;
                           &#x27;v5)]        |   SP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne, ptTwo = v2      | [(v1, v3, v4, &#x27;
                           &#x27;v5)]    |   DP and SP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | noPartition            | [(v1, v2, v3, &#x27;
                           &#x27;v4, v5)]|   kudu or disablePartition\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    private transient Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    protected String keytabPath;\n&#x27;
                           &#x27;    protected String krb5confPath;\n&#x27;
                           &#x27;    protected String principal;\n&#x27;
                           &#x27;    protected Integer authMech;\n&#x27;
                           &#x27;    protected String dbUrl;\n&#x27;
                           &#x27;    protected String userName;\n&#x27;
                           &#x27;    protected String password;\n&#x27;
                           &#x27;    protected int batchSize = 100;\n&#x27;
                           &#x27;    protected long batchWaitInterval = 60 * &#x27;
                           &#x27;1000L;\n&#x27;
                           &#x27;    protected String tableName;\n&#x27;
                           &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                           &#x27;    protected String partitionFields;\n&#x27;
                           &#x27;    protected Boolean enablePartition;\n&#x27;
                           &#x27;    protected String schema;\n&#x27;
                           &#x27;    protected String storeType;\n&#x27;
                           &#x27;    protected String updateMode;\n&#x27;
                           &#x27;    public List&lt;String&gt; fieldNames;\n&#x27;
                           &#x27;    public List&lt;String&gt; fieldTypes;\n&#x27;
                           &#x27;    public List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfoList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // partition field of static partition which &#x27;
                           &#x27;matched by ${field}\n&#x27;
                           &#x27;    private final List&lt;String&gt; &#x27;
                           &#x27;staticPartitionFields = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row &#x27;
                           &#x27;data字段值对应\n&#x27;
                           &#x27;    // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, &#x27;
                           &#x27;id)，但是因为partition，写入的SQL为\n&#x27;
                           &#x27;    // INSERT INTO tableName(name, id) &#x27;
                           &#x27;PARTITION(age) VALUES(?, ?, ?)\n&#x27;
                           &#x27;    // 那么实际executeSql设置字段的顺序应该为(name, id, &#x27;
                           &#x27;age)，同时，字段对应的type顺序也需要重组\n&#x27;
                           &#x27;    private List&lt;String&gt; valueFieldNames;\n&#x27;
                           &#x27;    private transient &#x27;
                           &#x27;AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;\n&#x27;
                           &#x27;    private List&lt;Row&gt; rows;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private transient ScheduledExecutorService &#x27;
                           &#x27;scheduler;\n&#x27;
                           &#x27;    private transient ScheduledFuture&lt;?&gt; &#x27;
                           &#x27;scheduledFuture;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public static Builder impalaBuilder() {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    /**\n&#x27;
                           &#x27;     * get jdbc connection\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void openJdbc() {\n&#x27;
                           &#x27;        JDBCUtils.forName(DRIVER_NAME, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbUrl, userName, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;            statement = &#x27;
                           &#x27;connection.createStatement();\n&#x27;
                           &#x27;            connection.setAutoCommit(false);\n&#x27;
                           &#x27;        } catch (SQLException sqlException) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;get impala &#x27;
                           &#x27;jdbc connection failed!&quot;, sqlException);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void flush() throws Exception {\n&#x27;
                           &#x27;        if (batchCount &gt; 0) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(updateMode.equalsIgnoreCase(UPDATE_MODE)) {\n&#x27;
                           &#x27;                executeUpdateBatch();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (!rowDataMap.isEmpty()) {\n&#x27;
                           &#x27;                String templateSql =\n&#x27;
                           &#x27;                        &quot;INSERT INTO tableName &#x27;
                           &#x27;${tableFieldsCondition} PARTITION &#x27;
                           &#x27;${partitionCondition} VALUES ${valuesCondition}&quot;;\n&#x27;
                           &#x27;                executeBatchSql(\n&#x27;
                           &#x27;                        statement,\n&#x27;
                           &#x27;                        templateSql,\n&#x27;
                           &#x27;                        schema,\n&#x27;
                           &#x27;                        tableName,\n&#x27;
                           &#x27;                        storeType,\n&#x27;
                           &#x27;                        enablePartition,\n&#x27;
                           &#x27;                        valueFieldNames,\n&#x27;
                           &#x27;                        partitionFields,\n&#x27;
                           &#x27;                        rowDataMap\n&#x27;
                           &#x27;                );\n&#x27;
                           &#x27;                rowDataMap.clear();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        batchCount = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * execute batch update statement\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws SQLException throw sql exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void executeUpdateBatch() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            rows.forEach(row -&gt; {\n&#x27;
                           &#x27;                try {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;JDBCTypeConvertUtils.setRecordToStatement(\n&#x27;
                           &#x27;                            updateStatement,\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),\n&#x27;
                           &#x27;                            row,\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()\n&#x27;
                           &#x27;                    );\n&#x27;
                           &#x27;                    updateStatement.addBatch();\n&#x27;
                           &#x27;                } catch (Exception e) {\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;impala jdbc execute batch &#x27;
                           &#x27;error!&quot;, e);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;            updateStatement.executeBatch();\n&#x27;
                           &#x27;            connection.commit();\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            LOG.debug(&quot;impala jdbc execute batch &#x27;
                           &#x27;error &quot;, e);\n&#x27;
                           &#x27;            connection.rollback();\n&#x27;
                           &#x27;            connection.commit();\n&#x27;
                           &#x27;            updateStatement.clearBatch();\n&#x27;
                           &#x27;            executeUpdate(connection);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void executeUpdate(Connection &#x27;
                           &#x27;connection) {\n&#x27;
                           &#x27;        rows.forEach(row -&gt; {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;setRecordToStatement(updateStatement, &#x27;
                           &#x27;JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;                updateStatement.executeUpdate();\n&#x27;
                           &#x27;                connection.commit();\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                try {\n&#x27;
                           &#x27;                    connection.rollback();\n&#x27;
                           &#x27;                    connection.commit();\n&#x27;
                           &#x27;                } catch (SQLException e1) {\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(e1);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(metricOutputFormat.outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_DATA_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                    LOG.error(&quot;record insert &#x27;
                           &#x27;failed ,this row is {}&quot;, row.toString());\n&#x27;
                           &#x27;                    LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;metricOutputFormat.outDirtyRecords.inc();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        });\n&#x27;
                           &#x27;        rows.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void putRowIntoMap(Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, &#x27;
                           &#x27;String&gt; rowData) {\n&#x27;
                           &#x27;        Set&lt;String&gt; keySet = rowDataMap.keySet();\n&#x27;
                           &#x27;        ArrayList&lt;String&gt; tempRowArray;\n&#x27;
                           &#x27;        if (keySet.contains(rowData.f0)) {\n&#x27;
                           &#x27;            tempRowArray = &#x27;
                           &#x27;rowDataMap.get(rowData.f0);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            tempRowArray = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tempRowArray.add(rowData.f1);\n&#x27;
                           &#x27;        rowDataMap.put(rowData.f0, tempRowArray);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private List&lt;String&gt; &#x27;
                           &#x27;rebuildFieldNameListAndTypeList(List&lt;String&gt; &#x27;
                           &#x27;fieldNames, List&lt;String&gt; staticPartitionFields, &#x27;
                           &#x27;List&lt;String&gt; fieldTypes, String partitionFields) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        if (partitionFields.isEmpty()) {\n&#x27;
                           &#x27;            return fieldNames;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; valueFields = new &#x27;
                           &#x27;ArrayList&lt;&gt;(fieldNames);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = valueFields.size() - 1; i &gt;= &#x27;
                           &#x27;0; i--) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(staticPartitionFields.contains(fieldNames.get(i))) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                valueFields.remove(i);\n&#x27;
                           &#x27;                fieldTypes.remove(i);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; valueFields.size(); &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(partitionFields.contains(fieldNames.get(i))) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;valueFields.add(valueFields.remove(i));\n&#x27;
                           &#x27;                &#x27;
                           &#x27;fieldTypes.add(fieldTypes.remove(i));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return valueFields;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Quote a specific type of value, like &#x27;
                           &#x27;string, timestamp\n&#x27;
                           &#x27;     * before: 1, cast(tiezhu as string), &#x27;
                           &#x27;cast(2001-01-09 01:05:01 as timestamp), cast(123 &#x27;
                           &#x27;as int)\n&#x27;
                           &quot;     * after: 1, cast(&#x27;tiezhu&#x27; as string), &quot;
                           &quot;cast(&#x27;2001-01-09 01:05:01&#x27; as timestamp), cast(123 &quot;
                           &#x27;as int)\n&#x27;
                           &#x27;     * if cast value is null, then cast(null as &#x27;
                           &#x27;type)\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param valueCondition original value &#x27;
                           &#x27;condition\n&#x27;
                           &#x27;     * @return quoted condition\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;valueConditionAddQuotation(String valueCondition) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        String[] temps = &#x27;
                           &#x27;valueCondition.split(&quot;,&quot;);\n&#x27;
                           &#x27;        List&lt;String&gt; replacedItem = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        Arrays.stream(temps).forEach(\n&#x27;
                           &#x27;                item -&gt; {\n&#x27;
                           &#x27;                    Matcher matcher = &#x27;
                           &#x27;TYPE_PATTERN.matcher(item);\n&#x27;
                           &#x27;                    while (matcher.find()) {\n&#x27;
                           &#x27;                        String value = &#x27;
                           &#x27;matcher.group(1);\n&#x27;
                           &#x27;                        String type = &#x27;
                           &#x27;matcher.group(2);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        for (String needQuoteType &#x27;
                           &#x27;: NEED_QUOTE_TYPE) {\n&#x27;
                           &#x27;                            if &#x27;
                           &#x27;(type.contains(needQuoteType)) {\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!&quot;null&quot;.equals(value)) {\n&#x27;
                           &#x27;                                    item = &#x27;
                           &#x27;item.replace(value, &quot;\&#x27;&quot; + value + &quot;\&#x27;&quot;);\n&#x27;
                           &#x27;                                }\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    replacedItem.add(item);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;        );\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &quot;(&quot; + String.join(&quot;, &quot;, &#x27;
                           &#x27;replacedItem) + &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;record) throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (!record.f0) {\n&#x27;
                           &#x27;                return;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;RECEIVE_DATA_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;record);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(updateMode.equalsIgnoreCase(UPDATE_MODE)) {\n&#x27;
                           &#x27;                rows.add(Row.copy(record.f1));\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                Map&lt;String, Object&gt; valueMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;                Row row = Row.copy(record.f1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;row.getArity(); i++) {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;valueMap.put(fieldNames.get(i), row.getField(i));\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Tuple2&lt;String, String&gt; rowTuple2 = &#x27;
                           &#x27;new Tuple2&lt;&gt;();\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(storeType.equalsIgnoreCase(KUDU_TYPE) || &#x27;
                           &#x27;!enablePartition) {\n&#x27;
                           &#x27;                    rowTuple2.f0 = NO_PARTITION;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    rowTuple2.f0 = &#x27;
                           &#x27;buildPartitionCondition(valueMap, partitionFields, &#x27;
                           &#x27;staticPartitionFields);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                // 根据字段名对 row data 重组, 比如，原始 row &#x27;
                           &#x27;data : (1, xxx, 20) -&gt; (id, name, age)\n&#x27;
                           &#x27;                // 但是由于 partition，写入的field 顺序变成了 &#x27;
                           &#x27;(name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)\n&#x27;
                           &#x27;                Row rowValue = new &#x27;
                           &#x27;Row(fieldTypes.size());\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;fieldTypes.size(); i++) {\n&#x27;
                           &#x27;                    rowValue.setField(i, &#x27;
                           &#x27;valueMap.get(valueFieldNames.get(i)));\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                rowTuple2.f1 = &#x27;
                           &#x27;valueConditionAddQuotation(buildValuesCondition(fieldTypes, &#x27;
                           &#x27;rowValue));\n&#x27;
                           &#x27;                putRowIntoMap(rowDataMap, &#x27;
                           &#x27;rowTuple2);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            batchCount++;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchCount &gt;= batchSize) {\n&#x27;
                           &#x27;                flush();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            // Receive data\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new IOException(&quot;Writing records &#x27;
                           &#x27;to impala failed.&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        if (closed) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // 将还未执行的SQL flush\n&#x27;
                           &#x27;        if (batchCount &gt; 0) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                flush();\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;Writing records to impala &#x27;
                           &#x27;failed.&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // cancel scheduled task\n&#x27;
                           &#x27;        if (this.scheduledFuture != null) {\n&#x27;
                           &#x27;            scheduledFuture.cancel(false);\n&#x27;
                           &#x27;            this.scheduler.shutdown();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // close connection\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (connection != null &amp;&amp; &#x27;
                           &#x27;connection.isValid(DEFAULT_CONN_TIME_OUT)) {\n&#x27;
                           &#x27;                connection.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (statement != null &amp;&amp; &#x27;
                           &#x27;!statement.isClosed()) {\n&#x27;
                           &#x27;                statement.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (updateStatement != null &amp;&amp; &#x27;
                           &#x27;!updateStatement.isClosed()) {\n&#x27;
                           &#x27;                updateStatement.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;impala &#x27;
                           &#x27;connection close failed!&quot;, e);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            connection = null;\n&#x27;
                           &#x27;            statement = null;\n&#x27;
                           &#x27;            updateStatement = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        closed = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * execute batch sql from row data map\n&#x27;
                           &quot;     * sql like &#x27;insert into tableName(f1, f2, f3) &quot;
                           &#x27;${partitionCondition} values(v1, v2, v3), (v4, v5, &#x27;
                           &#x27;v6)....\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param statement       execute statement\n&#x27;
                           &#x27;     * @param tempSql         template sql\n&#x27;
                           &#x27;     * @param storeType       the store type of &#x27;
                           &#x27;data\n&#x27;
                           &#x27;     * @param enablePartition enable partition or &#x27;
                           &#x27;not\n&#x27;
                           &#x27;     * @param fieldNames      field name list\n&#x27;
                           &#x27;     * @param partitionFields partition fields\n&#x27;
                           &#x27;     * @param rowDataMap      row data map\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void executeBatchSql(Statement &#x27;
                           &#x27;statement,\n&#x27;
                           &#x27;                                 String tempSql,\n&#x27;
                           &#x27;                                 String schema,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;tableName,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;storeType,\n&#x27;
                           &#x27;                                 Boolean &#x27;
                           &#x27;enablePartition,\n&#x27;
                           &#x27;                                 List&lt;String&gt; &#x27;
                           &#x27;fieldNames,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;partitionFields,\n&#x27;
                           &#x27;                                 Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap) {\n&#x27;
                           &#x27;        StringBuilder valuesCondition = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;        StringBuilder partitionCondition = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;        String tableFieldsCondition = &#x27;
                           &#x27;buildTableFieldsCondition(fieldNames, &#x27;
                           &#x27;partitionFields);\n&#x27;
                           &#x27;        ArrayList&lt;String&gt; rowData;\n&#x27;
                           &#x27;        String tableNameInfo = &#x27;
                           &#x27;Objects.isNull(schema) ?\n&#x27;
                           &#x27;                tableName : &#x27;
                           &#x27;quoteIdentifier(schema) + &quot;.&quot; + tableName;\n&#x27;
                           &#x27;        tempSql = tempSql.replace(&quot;tableName&quot;, &#x27;
                           &#x27;tableNameInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // kudu ${partitionCondition} is null\n&#x27;
                           &#x27;        if (storeType.equalsIgnoreCase(KUDU_TYPE) &#x27;
                           &#x27;|| !enablePartition) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                rowData = &#x27;
                           &#x27;rowDataMap.get(NO_PARTITION);\n&#x27;
                           &#x27;                rowData.forEach(row -&gt; &#x27;
                           &#x27;valuesCondition.append(row).append(&quot;, &quot;));\n&#x27;
                           &#x27;                String executeSql = &#x27;
                           &#x27;tempSql.replace(VALUES_CONDITION, &#x27;
                           &#x27;valuesCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(PARTITION_CONDITION, &#x27;
                           &#x27;partitionCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(PARTITION_CONSTANT, &quot;&quot;)\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(TABLE_FIELDS_CONDITION, &#x27;
                           &#x27;tableFieldsCondition);\n&#x27;
                           &#x27;                String substring = &#x27;
                           &#x27;executeSql.substring(0, executeSql.length() - 2);\n&#x27;
                           &#x27;                statement.execute(substring);\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;execute impala SQL error!&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // partition sql\n&#x27;
                           &#x27;        Set&lt;String&gt; keySet = rowDataMap.keySet();\n&#x27;
                           &#x27;        String finalTempSql = tempSql;\n&#x27;
                           &#x27;        for (String key : keySet) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                String executeSql = &#x27;
                           &#x27;String.copyValueOf(finalTempSql.toCharArray());\n&#x27;
                           &#x27;                ArrayList&lt;String&gt; &#x27;
                           &#x27;valuesConditionList = rowDataMap.get(key);\n&#x27;
                           &#x27;                partitionCondition.append(key);\n&#x27;
                           &#x27;                executeSql = &#x27;
                           &#x27;executeSql.replace(PARTITION_CONDITION, &#x27;
                           &#x27;partitionCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(TABLE_FIELDS_CONDITION, &#x27;
                           &#x27;tableFieldsCondition)\n&#x27;
                           &#x27;                        .replace(VALUES_CONDITION, &#x27;
                           &#x27;String.join(&quot;, &quot;, valuesConditionList));\n&#x27;
                           &#x27;                statement.execute(executeSql);\n&#x27;
                           &#x27;                partitionCondition.delete(0, &#x27;
                           &#x27;partitionCondition.length());\n&#x27;
                           &#x27;            } catch (SQLException sqlException) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;execute impala SQL error! &quot;, &#x27;
                           &#x27;sqlException);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * build partition condition with row data\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param rowData              row data\n&#x27;
                           &#x27;     * @param partitionFields      partition &#x27;
                           &#x27;fields\n&#x27;
                           &#x27;     * @param staticPartitionField static &#x27;
                           &#x27;partition fields\n&#x27;
                           &quot;     * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildPartitionCondition(Map&lt;String, Object&gt; &#x27;
                           &#x27;rowData, String partitionFields, List&lt;String&gt; &#x27;
                           &#x27;staticPartitionField) {\n&#x27;
                           &#x27;        for (String key : staticPartitionField) {\n&#x27;
                           &#x27;            StringBuilder sb = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;            Object value = rowData.get(key);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(value);\n&#x27;
                           &#x27;            partitionFields = &#x27;
                           &#x27;partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, &#x27;
                           &#x27;sb.toString());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &quot;(&quot; + partitionFields + &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * build field condition according to field &#x27;
                           &#x27;names\n&#x27;
                           &#x27;     * replace ${tableFieldCondition}\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param fieldNames      the selected field &#x27;
                           &#x27;names\n&#x27;
                           &#x27;     * @param partitionFields the partition &#x27;
                           &#x27;fields\n&#x27;
                           &quot;     * @return condition like &#x27;(id, name, age)&#x27;\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildTableFieldsCondition(List&lt;String&gt; fieldNames, &#x27;
                           &#x27;String partitionFields) {\n&#x27;
                           &#x27;        return &quot;(&quot; + fieldNames.stream()\n&#x27;
                           &#x27;                .filter(f -&gt; &#x27;
                           &#x27;!partitionFields.contains(f))\n&#x27;
                           &#x27;                .map(this::quoteIdentifier)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &quot;)) &#x27;
                           &#x27;+ &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * according to field types, build the values &#x27;
                           &#x27;condition\n&#x27;
                           &#x27;     * replace ${valuesCondition}\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param fieldTypes field types\n&#x27;
                           &quot;     * @return condition like &#x27;(?, ?, cast(? as &quot;
                           &quot;string))&#x27; and &#x27;?&#x27; will be replaced with row data\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildValuesCondition(List&lt;String&gt; fieldTypes, Row &#x27;
                           &#x27;row) {\n&#x27;
                           &#x27;        String valuesCondition = &#x27;
                           &#x27;fieldTypes.stream().map(\n&#x27;
                           &#x27;                f -&gt; {\n&#x27;
                           &#x27;                    for (String item : &#x27;
                           &#x27;NEED_QUOTE_TYPE) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(f.toLowerCase().contains(item)) {\n&#x27;
                           &#x27;                            return &#x27;
                           &#x27;String.format(&quot;cast(? as %s)&quot;, f.toLowerCase());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    return &quot;?&quot;;\n&#x27;
                           &#x27;                }).collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;        for (int i = 0; i &lt; row.getArity(); i++) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            valuesCondition = &#x27;
                           &#x27;valuesCondition.replaceFirst(&quot;\\\\?&quot;, &#x27;
                           &#x27;Objects.isNull(row.getField(i)) ? &quot;null&quot; : &#x27;
                           &#x27;row.getField(i).toString());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return valuesCondition;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * impala update mode SQL\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @return UPDATE tableName SET setCondition &#x27;
                           &#x27;WHERE whereCondition\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private String buildUpdateSql(String schema, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fieldNames, &#x27;
                           &#x27;List&lt;String&gt; primaryKeys) {\n&#x27;
                           &#x27;        //跳过primary key字段\n&#x27;
                           &#x27;        String setClause = fieldNames.stream()\n&#x27;
                           &#x27;                .filter(f -&gt; &#x27;
                           &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                           &#x27;!primaryKeys.contains(f))\n&#x27;
                           &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                           &#x27;&quot;=?&quot;)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String conditionClause = &#x27;
                           &#x27;primaryKeys.stream()\n&#x27;
                           &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                           &#x27;&quot;=?&quot;)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &quot;UPDATE &quot; + (Objects.isNull(schema) &#x27;
                           &#x27;? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)\n&#x27;
                           &#x27;                + quoteIdentifier(tableName) + &quot; &#x27;
                           &#x27;SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String quoteIdentifier(String &#x27;
                           &#x27;identifier) {\n&#x27;
                           &#x27;        return &quot;`&quot; + identifier + &quot;`&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static Builder getImpalaBuilder() {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        public Builder setKrb5confPath(String &#x27;
                         &#x27;krb5confPath) {\n&#x27;
                         &#x27;            this.krb5confPath = krb5confPath;\n&#x27;
                         &#x27;            return this;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        public Builder setPrincipal(String &#x27;
                         &#x27;principal) {\n&#x27;
                         &#x27;            this.principal = principal;\n&#x27;
                         &#x27;            return this;\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            checkNotNull(options, &quot;No options &#x27;
                         &#x27;supplied.&quot;);\n&#x27;
                         &#x27;            checkNotNull(fieldNames, &quot;No fieldNames &#x27;
                         &#x27;supplied.&quot;);\n&#x27;
                         &#x27;            return new ImpalaOutputFormat(\n&#x27;
                         &#x27;                    options,\n&#x27;
                         &#x27;                    fieldNames,\n&#x27;
                         &#x27;                    keyFields,\n&#x27;
                         &#x27;                    partitionFields,\n&#x27;
                         &#x27;                    fieldTypes,\n&#x27;
                         &#x27;                    flushMaxSize,\n&#x27;
                         &#x27;                    flushIntervalMills,\n&#x27;
                         &#x27;                    allReplace,\n&#x27;
                         &#x27;                    updateMode,\n&#x27;
                         &#x27;                    authMech,\n&#x27;
                         &#x27;                    keytabPath,\n&#x27;
                         &#x27;                    krb5confPath,\n&#x27;
                         &#x27;                    principal);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            if (!canHandle(format.dbUrl)) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;impala dbUrl is illegal, &#x27;
                           &#x27;check url: &quot; + format.dbUrl);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.Kerberos.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.krb5confPath,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, krb5confPath is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.principal,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, principal is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.keytabPath,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, keytabPath is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.UserName.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.userName, &#x27;
                           &#x27;&quot;userName is required!&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.NameANDPassword.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.userName, &#x27;
                           &#x27;&quot;userName is required!&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.password, &#x27;
                           &#x27;&quot;password is required!&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            checkNotNull(format.storeType, &#x27;
                           &#x27;&quot;storeType is required!&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return format;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (authMech == 1) {\n&#x27;
                         &#x27;            UserGroupInformation ugi = &#x27;
                         &#x27;KrbUtils.loginAndReturnUgi(principal, keytabPath, &#x27;
                         &#x27;krb5confPath);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.rmi.RemoteException;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public ImpalaOutputFormat(\n&#x27;
                         &#x27;            JDBCOptions options,\n&#x27;
                         &#x27;            String[] fieldNames,\n&#x27;
                         &#x27;            String[] keyFields,\n&#x27;
                         &#x27;            String[] partitionFields,\n&#x27;
                         &#x27;            int[] fieldTypes,\n&#x27;
                         &#x27;            int flushMaxSize,\n&#x27;
                         &#x27;            long flushIntervalMills,\n&#x27;
                         &#x27;            boolean allReplace,\n&#x27;
                         &#x27;            String updateMode,\n&#x27;
                         &#x27;            Integer authMech,\n&#x27;
                         &#x27;            String keytabPath,\n&#x27;
                         &#x27;            String krb5confPath,\n&#x27;
                         &#x27;            String principal) {\n&#x27;
                         &#x27;        super(options,\n&#x27;
                         &#x27;                fieldNames,\n&#x27;
                         &#x27;                keyFields,\n&#x27;
                         &#x27;                partitionFields,\n&#x27;
                         &#x27;                fieldTypes,\n&#x27;
                         &#x27;                flushMaxSize,\n&#x27;
                         &#x27;                flushIntervalMills,\n&#x27;
                         &#x27;                allReplace,\n&#x27;
                         &#x27;                updateMode);\n&#x27;
                         &#x27;        this.authMech = authMech;\n&#x27;
                         &#x27;        this.keytabPath = keytabPath;\n&#x27;
                         &#x27;        this.krb5confPath = krb5confPath;\n&#x27;
                         &#x27;        this.principal = principal;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private static final Logger LOG = &#x27;
                           &#x27;LoggerFactory.getLogger(ImpalaOutputFormat.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;1L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // ${field}\n&#x27;
                           &#x27;    private static final Pattern &#x27;
                           &#x27;STATIC_PARTITION_PATTERN = &#x27;
                           &#x27;Pattern.compile(&quot;\\\\$\\\\{([^}]*)}&quot;);\n&#x27;
                           &quot;    // cast(value as string) -&gt; cast(&#x27;value&#x27; as &quot;
                           &quot;string)  cast(value as timestamp) -&gt; cast(&#x27;value&#x27; &quot;
                           &#x27;as timestamp)\n&#x27;
                           &#x27;    private static final Pattern TYPE_PATTERN = &#x27;
                           &#x27;Pattern.compile(&quot;cast\\\\((.*) as (.*)\\\\)&quot;);\n&#x27;
                           &#x27;    //specific type which values need to be &#x27;
                           &#x27;quoted\n&#x27;
                           &#x27;    private static final String[] NEED_QUOTE_TYPE &#x27;
                           &#x27;= {&quot;string&quot;, &quot;timestamp&quot;, &quot;varchar&quot;};\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final Integer &#x27;
                           &#x27;DEFAULT_CONN_TIME_OUT = 60;\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;RECEIVE_DATA_PRINT_FREQUENCY = 1000;\n&#x27;
                           &#x27;    private static final int &#x27;
                           &#x27;DIRTY_DATA_PRINT_FREQUENCY = 1000;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String KUDU_TYPE = &#x27;
                           &#x27;&quot;kudu&quot;;\n&#x27;
                           &#x27;    private static final String UPDATE_MODE = &#x27;
                           &#x27;&quot;update&quot;;\n&#x27;
                           &#x27;    private static final String PARTITION_CONSTANT &#x27;
                           &#x27;= &quot;PARTITION&quot;;\n&#x27;
                           &#x27;    private static final String DRIVER_NAME = &#x27;
                           &#x27;&quot;com.cloudera.impala.jdbc41.Driver&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final String VALUES_CONDITION = &#x27;
                           &#x27;&quot;${valuesCondition}&quot;;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;PARTITION_CONDITION = &quot;${partitionCondition}&quot;;\n&#x27;
                           &#x27;    private static final String &#x27;
                           &#x27;TABLE_FIELDS_CONDITION = &#x27;
                           &#x27;&quot;${tableFieldsCondition}&quot;;\n&#x27;
                           &#x27;    private static final String NO_PARTITION = &#x27;
                           &#x27;&quot;noPartition&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    protected transient Connection connection;\n&#x27;
                           &#x27;    protected transient Statement statement;\n&#x27;
                           &#x27;    protected transient PreparedStatement &#x27;
                           &#x27;updateStatement;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private transient volatile boolean closed = &#x27;
                           &#x27;false;\n&#x27;
                           &#x27;    private int batchCount = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // |   partitionCondition   |Array of &#x27;
                           &#x27;valueCondition|\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne, ptTwo, ptThree  | [(v1, v2, v3, &#x27;
                           &#x27;v4, v5)]|   DP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne = v1, ptTwo = v2 | [(v3, v4, &#x27;
                           &#x27;v5)]        |   SP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | ptOne, ptTwo = v2      | [(v1, v3, v4, &#x27;
                           &#x27;v5)]    |   DP and SP\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    // | noPartition            | [(v1, v2, v3, &#x27;
                           &#x27;v4, v5)]|   kudu or disablePartition\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;|------------------------------------------------|\n&#x27;
                           &#x27;    private transient Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    protected String keytabPath;\n&#x27;
                           &#x27;    protected String krb5confPath;\n&#x27;
                           &#x27;    protected String principal;\n&#x27;
                           &#x27;    protected Integer authMech;\n&#x27;
                           &#x27;    protected String dbUrl;\n&#x27;
                           &#x27;    protected String userName;\n&#x27;
                           &#x27;    protected String password;\n&#x27;
                           &#x27;    protected int batchSize = 100;\n&#x27;
                           &#x27;    protected long batchWaitInterval = 60 * &#x27;
                           &#x27;1000L;\n&#x27;
                           &#x27;    protected String tableName;\n&#x27;
                           &#x27;    protected List&lt;String&gt; primaryKeys;\n&#x27;
                           &#x27;    protected String partitionFields;\n&#x27;
                           &#x27;    protected Boolean enablePartition;\n&#x27;
                           &#x27;    protected String schema;\n&#x27;
                           &#x27;    protected String storeType;\n&#x27;
                           &#x27;    protected String updateMode;\n&#x27;
                           &#x27;    public List&lt;String&gt; fieldNames;\n&#x27;
                           &#x27;    public List&lt;String&gt; fieldTypes;\n&#x27;
                           &#x27;    public List&lt;AbstractTableInfo.FieldExtraInfo&gt; &#x27;
                           &#x27;fieldExtraInfoList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // partition field of static partition which &#x27;
                           &#x27;matched by ${field}\n&#x27;
                           &#x27;    private final List&lt;String&gt; &#x27;
                           &#x27;staticPartitionFields = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // valueFieldsName -&gt; 重组之后的fieldNames，为了重组row &#x27;
                           &#x27;data字段值对应\n&#x27;
                           &#x27;    // 需要对partition字段做特殊处理，比如原来的字段顺序为(age, name, &#x27;
                           &#x27;id)，但是因为partition，写入的SQL为\n&#x27;
                           &#x27;    // INSERT INTO tableName(name, id) &#x27;
                           &#x27;PARTITION(age) VALUES(?, ?, ?)\n&#x27;
                           &#x27;    // 那么实际executeSql设置字段的顺序应该为(name, id, &#x27;
                           &#x27;age)，同时，字段对应的type顺序也需要重组\n&#x27;
                           &#x27;    private List&lt;String&gt; valueFieldNames;\n&#x27;
                           &#x27;    private transient &#x27;
                           &#x27;AbstractDtRichOutputFormat&lt;?&gt; metricOutputFormat;\n&#x27;
                           &#x27;    private List&lt;Row&gt; rows;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private transient ScheduledExecutorService &#x27;
                           &#x27;scheduler;\n&#x27;
                           &#x27;    private transient ScheduledFuture&lt;?&gt; &#x27;
                           &#x27;scheduledFuture;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void configure(Configuration &#x27;
                           &#x27;parameters) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public static Builder impalaBuilder() {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    /**\n&#x27;
                           &#x27;     * get jdbc connection\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void openJdbc() {\n&#x27;
                           &#x27;        JDBCUtils.forName(DRIVER_NAME, &#x27;
                           &#x27;getClass().getClassLoader());\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            connection = &#x27;
                           &#x27;DriverManager.getConnection(dbUrl, userName, &#x27;
                           &#x27;password);\n&#x27;
                           &#x27;            statement = &#x27;
                           &#x27;connection.createStatement();\n&#x27;
                           &#x27;            connection.setAutoCommit(false);\n&#x27;
                           &#x27;        } catch (SQLException sqlException) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;get impala &#x27;
                           &#x27;jdbc connection failed!&quot;, sqlException);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void flush() throws Exception {\n&#x27;
                           &#x27;        if (batchCount &gt; 0) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(updateMode.equalsIgnoreCase(UPDATE_MODE)) {\n&#x27;
                           &#x27;                executeUpdateBatch();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if (!rowDataMap.isEmpty()) {\n&#x27;
                           &#x27;                String templateSql =\n&#x27;
                           &#x27;                        &quot;INSERT INTO tableName &#x27;
                           &#x27;${tableFieldsCondition} PARTITION &#x27;
                           &#x27;${partitionCondition} VALUES ${valuesCondition}&quot;;\n&#x27;
                           &#x27;                executeBatchSql(\n&#x27;
                           &#x27;                        statement,\n&#x27;
                           &#x27;                        templateSql,\n&#x27;
                           &#x27;                        schema,\n&#x27;
                           &#x27;                        tableName,\n&#x27;
                           &#x27;                        storeType,\n&#x27;
                           &#x27;                        enablePartition,\n&#x27;
                           &#x27;                        valueFieldNames,\n&#x27;
                           &#x27;                        partitionFields,\n&#x27;
                           &#x27;                        rowDataMap\n&#x27;
                           &#x27;                );\n&#x27;
                           &#x27;                rowDataMap.clear();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        batchCount = 0;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * execute batch update statement\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @throws SQLException throw sql exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void executeUpdateBatch() throws &#x27;
                           &#x27;SQLException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            rows.forEach(row -&gt; {\n&#x27;
                           &#x27;                try {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;JDBCTypeConvertUtils.setRecordToStatement(\n&#x27;
                           &#x27;                            updateStatement,\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes),\n&#x27;
                           &#x27;                            row,\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;primaryKeys.stream().mapToInt(fieldNames::indexOf).toArray()\n&#x27;
                           &#x27;                    );\n&#x27;
                           &#x27;                    updateStatement.addBatch();\n&#x27;
                           &#x27;                } catch (Exception e) {\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;impala jdbc execute batch &#x27;
                           &#x27;error!&quot;, e);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;            updateStatement.executeBatch();\n&#x27;
                           &#x27;            connection.commit();\n&#x27;
                           &#x27;            rows.clear();\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            LOG.debug(&quot;impala jdbc execute batch &#x27;
                           &#x27;error &quot;, e);\n&#x27;
                           &#x27;            connection.rollback();\n&#x27;
                           &#x27;            connection.commit();\n&#x27;
                           &#x27;            updateStatement.clearBatch();\n&#x27;
                           &#x27;            executeUpdate(connection);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public void executeUpdate(Connection &#x27;
                           &#x27;connection) {\n&#x27;
                           &#x27;        rows.forEach(row -&gt; {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;setRecordToStatement(updateStatement, &#x27;
                           &#x27;JDBCTypeConvertUtils.getSqlTypeFromFieldType(fieldTypes), &#x27;
                           &#x27;row);\n&#x27;
                           &#x27;                updateStatement.executeUpdate();\n&#x27;
                           &#x27;                connection.commit();\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                try {\n&#x27;
                           &#x27;                    connection.rollback();\n&#x27;
                           &#x27;                    connection.commit();\n&#x27;
                           &#x27;                } catch (SQLException e1) {\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(e1);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(metricOutputFormat.outDirtyRecords.getCount() % &#x27;
                           &#x27;DIRTY_DATA_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                    LOG.error(&quot;record insert &#x27;
                           &#x27;failed ,this row is {}&quot;, row.toString());\n&#x27;
                           &#x27;                    LOG.error(&quot;&quot;, e);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;metricOutputFormat.outDirtyRecords.inc();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        });\n&#x27;
                           &#x27;        rows.clear();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void putRowIntoMap(Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap, Tuple2&lt;String, &#x27;
                           &#x27;String&gt; rowData) {\n&#x27;
                           &#x27;        Set&lt;String&gt; keySet = rowDataMap.keySet();\n&#x27;
                           &#x27;        ArrayList&lt;String&gt; tempRowArray;\n&#x27;
                           &#x27;        if (keySet.contains(rowData.f0)) {\n&#x27;
                           &#x27;            tempRowArray = &#x27;
                           &#x27;rowDataMap.get(rowData.f0);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            tempRowArray = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        tempRowArray.add(rowData.f1);\n&#x27;
                           &#x27;        rowDataMap.put(rowData.f0, tempRowArray);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private List&lt;String&gt; &#x27;
                           &#x27;rebuildFieldNameListAndTypeList(List&lt;String&gt; &#x27;
                           &#x27;fieldNames, List&lt;String&gt; staticPartitionFields, &#x27;
                           &#x27;List&lt;String&gt; fieldTypes, String partitionFields) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        if (partitionFields.isEmpty()) {\n&#x27;
                           &#x27;            return fieldNames;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; valueFields = new &#x27;
                           &#x27;ArrayList&lt;&gt;(fieldNames);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = valueFields.size() - 1; i &gt;= &#x27;
                           &#x27;0; i--) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(staticPartitionFields.contains(fieldNames.get(i))) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                valueFields.remove(i);\n&#x27;
                           &#x27;                fieldTypes.remove(i);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; valueFields.size(); &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(partitionFields.contains(fieldNames.get(i))) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;valueFields.add(valueFields.remove(i));\n&#x27;
                           &#x27;                &#x27;
                           &#x27;fieldTypes.add(fieldTypes.remove(i));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return valueFields;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Quote a specific type of value, like &#x27;
                           &#x27;string, timestamp\n&#x27;
                           &#x27;     * before: 1, cast(tiezhu as string), &#x27;
                           &#x27;cast(2001-01-09 01:05:01 as timestamp), cast(123 &#x27;
                           &#x27;as int)\n&#x27;
                           &quot;     * after: 1, cast(&#x27;tiezhu&#x27; as string), &quot;
                           &quot;cast(&#x27;2001-01-09 01:05:01&#x27; as timestamp), cast(123 &quot;
                           &#x27;as int)\n&#x27;
                           &#x27;     * if cast value is null, then cast(null as &#x27;
                           &#x27;type)\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param valueCondition original value &#x27;
                           &#x27;condition\n&#x27;
                           &#x27;     * @return quoted condition\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;valueConditionAddQuotation(String valueCondition) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        String[] temps = &#x27;
                           &#x27;valueCondition.split(&quot;,&quot;);\n&#x27;
                           &#x27;        List&lt;String&gt; replacedItem = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        Arrays.stream(temps).forEach(\n&#x27;
                           &#x27;                item -&gt; {\n&#x27;
                           &#x27;                    Matcher matcher = &#x27;
                           &#x27;TYPE_PATTERN.matcher(item);\n&#x27;
                           &#x27;                    while (matcher.find()) {\n&#x27;
                           &#x27;                        String value = &#x27;
                           &#x27;matcher.group(1);\n&#x27;
                           &#x27;                        String type = &#x27;
                           &#x27;matcher.group(2);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        for (String needQuoteType &#x27;
                           &#x27;: NEED_QUOTE_TYPE) {\n&#x27;
                           &#x27;                            if &#x27;
                           &#x27;(type.contains(needQuoteType)) {\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!&quot;null&quot;.equals(value)) {\n&#x27;
                           &#x27;                                    item = &#x27;
                           &#x27;item.replace(value, &quot;\&#x27;&quot; + value + &quot;\&#x27;&quot;);\n&#x27;
                           &#x27;                                }\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    replacedItem.add(item);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;        );\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &quot;(&quot; + String.join(&quot;, &quot;, &#x27;
                           &#x27;replacedItem) + &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void writeRecord(Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;record) throws IOException {\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (!record.f0) {\n&#x27;
                           &#x27;                return;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (outRecords.getCount() % &#x27;
                           &#x27;RECEIVE_DATA_PRINT_FREQUENCY == 0 || &#x27;
                           &#x27;LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;Receive data : {}&quot;, &#x27;
                           &#x27;record);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(updateMode.equalsIgnoreCase(UPDATE_MODE)) {\n&#x27;
                           &#x27;                rows.add(Row.copy(record.f1));\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                Map&lt;String, Object&gt; valueMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;                Row row = Row.copy(record.f1);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;row.getArity(); i++) {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;valueMap.put(fieldNames.get(i), row.getField(i));\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Tuple2&lt;String, String&gt; rowTuple2 = &#x27;
                           &#x27;new Tuple2&lt;&gt;();\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(storeType.equalsIgnoreCase(KUDU_TYPE) || &#x27;
                           &#x27;!enablePartition) {\n&#x27;
                           &#x27;                    rowTuple2.f0 = NO_PARTITION;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    rowTuple2.f0 = &#x27;
                           &#x27;buildPartitionCondition(valueMap, partitionFields, &#x27;
                           &#x27;staticPartitionFields);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                // 根据字段名对 row data 重组, 比如，原始 row &#x27;
                           &#x27;data : (1, xxx, 20) -&gt; (id, name, age)\n&#x27;
                           &#x27;                // 但是由于 partition，写入的field 顺序变成了 &#x27;
                           &#x27;(name, id, age)，则需要对 row data 重组变成 (xxx, 1, 20)\n&#x27;
                           &#x27;                Row rowValue = new &#x27;
                           &#x27;Row(fieldTypes.size());\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;fieldTypes.size(); i++) {\n&#x27;
                           &#x27;                    rowValue.setField(i, &#x27;
                           &#x27;valueMap.get(valueFieldNames.get(i)));\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                rowTuple2.f1 = &#x27;
                           &#x27;valueConditionAddQuotation(buildValuesCondition(fieldTypes, &#x27;
                           &#x27;rowValue));\n&#x27;
                           &#x27;                putRowIntoMap(rowDataMap, &#x27;
                           &#x27;rowTuple2);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            batchCount++;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (batchCount &gt;= batchSize) {\n&#x27;
                           &#x27;                flush();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            // Receive data\n&#x27;
                           &#x27;            outRecords.inc();\n&#x27;
                           &#x27;        } catch (Exception e) {\n&#x27;
                           &#x27;            throw new IOException(&quot;Writing records &#x27;
                           &#x27;to impala failed.&quot;, e);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void close() throws IOException {\n&#x27;
                           &#x27;        if (closed) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // 将还未执行的SQL flush\n&#x27;
                           &#x27;        if (batchCount &gt; 0) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                flush();\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;Writing records to impala &#x27;
                           &#x27;failed.&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // cancel scheduled task\n&#x27;
                           &#x27;        if (this.scheduledFuture != null) {\n&#x27;
                           &#x27;            scheduledFuture.cancel(false);\n&#x27;
                           &#x27;            this.scheduler.shutdown();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        // close connection\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            if (connection != null &amp;&amp; &#x27;
                           &#x27;connection.isValid(DEFAULT_CONN_TIME_OUT)) {\n&#x27;
                           &#x27;                connection.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (statement != null &amp;&amp; &#x27;
                           &#x27;!statement.isClosed()) {\n&#x27;
                           &#x27;                statement.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (updateStatement != null &amp;&amp; &#x27;
                           &#x27;!updateStatement.isClosed()) {\n&#x27;
                           &#x27;                updateStatement.close();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } catch (SQLException e) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;impala &#x27;
                           &#x27;connection close failed!&quot;, e);\n&#x27;
                           &#x27;        } finally {\n&#x27;
                           &#x27;            connection = null;\n&#x27;
                           &#x27;            statement = null;\n&#x27;
                           &#x27;            updateStatement = null;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        closed = true;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * execute batch sql from row data map\n&#x27;
                           &quot;     * sql like &#x27;insert into tableName(f1, f2, f3) &quot;
                           &#x27;${partitionCondition} values(v1, v2, v3), (v4, v5, &#x27;
                           &#x27;v6)....\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param statement       execute statement\n&#x27;
                           &#x27;     * @param tempSql         template sql\n&#x27;
                           &#x27;     * @param storeType       the store type of &#x27;
                           &#x27;data\n&#x27;
                           &#x27;     * @param enablePartition enable partition or &#x27;
                           &#x27;not\n&#x27;
                           &#x27;     * @param fieldNames      field name list\n&#x27;
                           &#x27;     * @param partitionFields partition fields\n&#x27;
                           &#x27;     * @param rowDataMap      row data map\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void executeBatchSql(Statement &#x27;
                           &#x27;statement,\n&#x27;
                           &#x27;                                 String tempSql,\n&#x27;
                           &#x27;                                 String schema,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;tableName,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;storeType,\n&#x27;
                           &#x27;                                 Boolean &#x27;
                           &#x27;enablePartition,\n&#x27;
                           &#x27;                                 List&lt;String&gt; &#x27;
                           &#x27;fieldNames,\n&#x27;
                           &#x27;                                 String &#x27;
                           &#x27;partitionFields,\n&#x27;
                           &#x27;                                 Map&lt;String, &#x27;
                           &#x27;ArrayList&lt;String&gt;&gt; rowDataMap) {\n&#x27;
                           &#x27;        StringBuilder valuesCondition = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;        StringBuilder partitionCondition = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;        String tableFieldsCondition = &#x27;
                           &#x27;buildTableFieldsCondition(fieldNames, &#x27;
                           &#x27;partitionFields);\n&#x27;
                           &#x27;        ArrayList&lt;String&gt; rowData;\n&#x27;
                           &#x27;        String tableNameInfo = &#x27;
                           &#x27;Objects.isNull(schema) ?\n&#x27;
                           &#x27;                tableName : &#x27;
                           &#x27;quoteIdentifier(schema) + &quot;.&quot; + tableName;\n&#x27;
                           &#x27;        tempSql = tempSql.replace(&quot;tableName&quot;, &#x27;
                           &#x27;tableNameInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // kudu ${partitionCondition} is null\n&#x27;
                           &#x27;        if (storeType.equalsIgnoreCase(KUDU_TYPE) &#x27;
                           &#x27;|| !enablePartition) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                rowData = &#x27;
                           &#x27;rowDataMap.get(NO_PARTITION);\n&#x27;
                           &#x27;                rowData.forEach(row -&gt; &#x27;
                           &#x27;valuesCondition.append(row).append(&quot;, &quot;));\n&#x27;
                           &#x27;                String executeSql = &#x27;
                           &#x27;tempSql.replace(VALUES_CONDITION, &#x27;
                           &#x27;valuesCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(PARTITION_CONDITION, &#x27;
                           &#x27;partitionCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(PARTITION_CONSTANT, &quot;&quot;)\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(TABLE_FIELDS_CONDITION, &#x27;
                           &#x27;tableFieldsCondition);\n&#x27;
                           &#x27;                String substring = &#x27;
                           &#x27;executeSql.substring(0, executeSql.length() - 2);\n&#x27;
                           &#x27;                statement.execute(substring);\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;execute impala SQL error!&quot;, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // partition sql\n&#x27;
                           &#x27;        Set&lt;String&gt; keySet = rowDataMap.keySet();\n&#x27;
                           &#x27;        String finalTempSql = tempSql;\n&#x27;
                           &#x27;        for (String key : keySet) {\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                String executeSql = &#x27;
                           &#x27;String.copyValueOf(finalTempSql.toCharArray());\n&#x27;
                           &#x27;                ArrayList&lt;String&gt; &#x27;
                           &#x27;valuesConditionList = rowDataMap.get(key);\n&#x27;
                           &#x27;                partitionCondition.append(key);\n&#x27;
                           &#x27;                executeSql = &#x27;
                           &#x27;executeSql.replace(PARTITION_CONDITION, &#x27;
                           &#x27;partitionCondition.toString())\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;.replace(TABLE_FIELDS_CONDITION, &#x27;
                           &#x27;tableFieldsCondition)\n&#x27;
                           &#x27;                        .replace(VALUES_CONDITION, &#x27;
                           &#x27;String.join(&quot;, &quot;, valuesConditionList));\n&#x27;
                           &#x27;                statement.execute(executeSql);\n&#x27;
                           &#x27;                partitionCondition.delete(0, &#x27;
                           &#x27;partitionCondition.length());\n&#x27;
                           &#x27;            } catch (SQLException sqlException) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;RuntimeException(&quot;execute impala SQL error! &quot;, &#x27;
                           &#x27;sqlException);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * build partition condition with row data\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param rowData              row data\n&#x27;
                           &#x27;     * @param partitionFields      partition &#x27;
                           &#x27;fields\n&#x27;
                           &#x27;     * @param staticPartitionField static &#x27;
                           &#x27;partition fields\n&#x27;
                           &quot;     * @return condition like &#x27;(ptOne, ptTwo=v2)&#x27;\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildPartitionCondition(Map&lt;String, Object&gt; &#x27;
                           &#x27;rowData, String partitionFields, List&lt;String&gt; &#x27;
                           &#x27;staticPartitionField) {\n&#x27;
                           &#x27;        for (String key : staticPartitionField) {\n&#x27;
                           &#x27;            StringBuilder sb = new &#x27;
                           &#x27;StringBuilder();\n&#x27;
                           &#x27;            Object value = rowData.get(key);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;sb.append(key).append(&quot;=&quot;).append(value);\n&#x27;
                           &#x27;            partitionFields = &#x27;
                           &#x27;partitionFields.replace(&quot;${&quot; + key + &quot;}&quot;, &#x27;
                           &#x27;sb.toString());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return &quot;(&quot; + partitionFields + &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * build field condition according to field &#x27;
                           &#x27;names\n&#x27;
                           &#x27;     * replace ${tableFieldCondition}\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param fieldNames      the selected field &#x27;
                           &#x27;names\n&#x27;
                           &#x27;     * @param partitionFields the partition &#x27;
                           &#x27;fields\n&#x27;
                           &quot;     * @return condition like &#x27;(id, name, age)&#x27;\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildTableFieldsCondition(List&lt;String&gt; fieldNames, &#x27;
                           &#x27;String partitionFields) {\n&#x27;
                           &#x27;        return &quot;(&quot; + fieldNames.stream()\n&#x27;
                           &#x27;                .filter(f -&gt; &#x27;
                           &#x27;!partitionFields.contains(f))\n&#x27;
                           &#x27;                .map(this::quoteIdentifier)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &quot;)) &#x27;
                           &#x27;+ &quot;)&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * according to field types, build the values &#x27;
                           &#x27;condition\n&#x27;
                           &#x27;     * replace ${valuesCondition}\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param fieldTypes field types\n&#x27;
                           &quot;     * @return condition like &#x27;(?, ?, cast(? as &quot;
                           &quot;string))&#x27; and &#x27;?&#x27; will be replaced with row data\n&quot;
                           &#x27;     */\n&#x27;
                           &#x27;    private String &#x27;
                           &#x27;buildValuesCondition(List&lt;String&gt; fieldTypes, Row &#x27;
                           &#x27;row) {\n&#x27;
                           &#x27;        String valuesCondition = &#x27;
                           &#x27;fieldTypes.stream().map(\n&#x27;
                           &#x27;                f -&gt; {\n&#x27;
                           &#x27;                    for (String item : &#x27;
                           &#x27;NEED_QUOTE_TYPE) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(f.toLowerCase().contains(item)) {\n&#x27;
                           &#x27;                            return &#x27;
                           &#x27;String.format(&quot;cast(? as %s)&quot;, f.toLowerCase());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    return &quot;?&quot;;\n&#x27;
                           &#x27;                }).collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;        for (int i = 0; i &lt; row.getArity(); i++) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            valuesCondition = &#x27;
                           &#x27;valuesCondition.replaceFirst(&quot;\\\\?&quot;, &#x27;
                           &#x27;Objects.isNull(row.getField(i)) ? &quot;null&quot; : &#x27;
                           &#x27;row.getField(i).toString());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return valuesCondition;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * impala update mode SQL\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @return UPDATE tableName SET setCondition &#x27;
                           &#x27;WHERE whereCondition\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private String buildUpdateSql(String schema, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fieldNames, &#x27;
                           &#x27;List&lt;String&gt; primaryKeys) {\n&#x27;
                           &#x27;        //跳过primary key字段\n&#x27;
                           &#x27;        String setClause = fieldNames.stream()\n&#x27;
                           &#x27;                .filter(f -&gt; &#x27;
                           &#x27;!CollectionUtils.isNotEmpty(primaryKeys) || &#x27;
                           &#x27;!primaryKeys.contains(f))\n&#x27;
                           &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                           &#x27;&quot;=?&quot;)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String conditionClause = &#x27;
                           &#x27;primaryKeys.stream()\n&#x27;
                           &#x27;                .map(f -&gt; quoteIdentifier(f) + &#x27;
                           &#x27;&quot;=?&quot;)\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot; AND &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return &quot;UPDATE &quot; + (Objects.isNull(schema) &#x27;
                           &#x27;? &quot;&quot; : quoteIdentifier(schema) + &quot;.&quot;)\n&#x27;
                           &#x27;                + quoteIdentifier(tableName) + &quot; &#x27;
                           &#x27;SET &quot; + setClause + &quot; WHERE &quot; + conditionClause;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String quoteIdentifier(String &#x27;
                           &#x27;identifier) {\n&#x27;
                           &#x27;        return &quot;`&quot; + identifier + &quot;`&quot;;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public static Builder getImpalaBuilder() {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        public Builder setKrb5confPath(String &#x27;
                         &#x27;krb5confPath) {\n&#x27;
                         &#x27;            this.krb5confPath = krb5confPath;\n&#x27;
                         &#x27;            return this;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        public Builder setPrincipal(String &#x27;
                         &#x27;principal) {\n&#x27;
                         &#x27;            this.principal = principal;\n&#x27;
                         &#x27;            return this;\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            checkNotNull(options, &quot;No options &#x27;
                         &#x27;supplied.&quot;);\n&#x27;
                         &#x27;            checkNotNull(fieldNames, &quot;No fieldNames &#x27;
                         &#x27;supplied.&quot;);\n&#x27;
                         &#x27;            return new ImpalaOutputFormat(\n&#x27;
                         &#x27;                    options,\n&#x27;
                         &#x27;                    fieldNames,\n&#x27;
                         &#x27;                    keyFields,\n&#x27;
                         &#x27;                    partitionFields,\n&#x27;
                         &#x27;                    fieldTypes,\n&#x27;
                         &#x27;                    flushMaxSize,\n&#x27;
                         &#x27;                    flushIntervalMills,\n&#x27;
                         &#x27;                    allReplace,\n&#x27;
                         &#x27;                    updateMode,\n&#x27;
                         &#x27;                    authMech,\n&#x27;
                         &#x27;                    keytabPath,\n&#x27;
                         &#x27;                    krb5confPath,\n&#x27;
                         &#x27;                    principal);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            if (!canHandle(format.dbUrl)) {\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalArgumentException(&quot;impala dbUrl is illegal, &#x27;
                           &#x27;check url: &quot; + format.dbUrl);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.Kerberos.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.krb5confPath,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, krb5confPath is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.principal,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, principal is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.keytabPath,\n&#x27;
                           &#x27;                        &quot;When kerberos &#x27;
                           &#x27;authentication is enabled, keytabPath is &#x27;
                           &#x27;required！&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.UserName.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.userName, &#x27;
                           &#x27;&quot;userName is required!&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (format.authMech == &#x27;
                           &#x27;EAuthMech.NameANDPassword.getType()) {\n&#x27;
                           &#x27;                checkNotNull(format.userName, &#x27;
                           &#x27;&quot;userName is required!&quot;);\n&#x27;
                           &#x27;                checkNotNull(format.password, &#x27;
                           &#x27;&quot;password is required!&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            checkNotNull(format.storeType, &#x27;
                           &#x27;&quot;storeType is required!&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return format;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (authMech == 1) {\n&#x27;
                         &#x27;            UserGroupInformation ugi = &#x27;
                         &#x27;KrbUtils.loginAndReturnUgi(principal, keytabPath, &#x27;
                         &#x27;krb5confPath);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        