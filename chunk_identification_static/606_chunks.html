<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>606 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.exec.FlinkSQLExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.FlinkPlanner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.SourceTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                           &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import com.google.common.collect.Sets;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.exec.ExecuteProcessHelper;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.exec.ParamsInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.calcite.FlinkPlannerImpl;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.lang.reflect.InvocationTargetException;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLClassLoader;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        ParamsInfo paramsInfo = &#x27;
                         &#x27;ExecuteProcessHelper.parseParams(args);\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExecution(paramsInfo);\n&#x27;
                         &#x27;        env.execute(paramsInfo.getName());\n&#x27;
                         &#x27;        LOG.info(&quot;program {} execution success&quot;, &#x27;
                         &#x27;paramsInfo.getName());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;        String sql = options.getSql();\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String addJarListStr = &#x27;
                           &#x27;options.getAddjar();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;        String confProp = options.getConfProp();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sql = URLDecoder.decode(sql, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(localSqlPluginPath);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (!Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            addJarListStr = &#x27;
                           &#x27;URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;            addJarFileList = &#x27;
                           &#x27;objMapper.readValue(addJarListStr, List.class);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        confProp = URLDecoder.decode(confProp, &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;getStreamExeEnv(confProperties, deployMode);\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv =  &#x27;
                           &#x27;StreamTableEnvironment.getTableEnvironment(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        // init global flinkPlanner\n&#x27;
                           &#x27;        &#x27;
                           &#x27;FlinkPlanner.createFlinkPlanner(tableEnv.getFrameworkConfig(), &#x27;
                           &#x27;tableEnv.getPlanner(), &#x27;
                           &#x27;tableEnv.getTypeFactory());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(sql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            File tmpFile = new File(addJarPath);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;jarURList.add(tmpFile.toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;jarURList, tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;registerTable(sqlTree, env, tableEnv, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode, sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sqlTranslation(localSqlPluginPath, &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        env.execute(name);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                                       SqlTree &#x27;
                           &#x27;sqlTree,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;Table&gt; registerTableCache,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;                    FlinkPlannerImpl flinkPlanner &#x27;
                           &#x27;= FlinkPlanner.getFlinkPlanner();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;flinkPlanner.parse(realSql);\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot; );\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                            System.out.println();\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void &#x27;
                           &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                           &#x27;List&lt;URL&gt; jarURList, TableEnvironment tableEnv)\n&#x27;
                           &#x27;            throws IllegalAccessException, &#x27;
                           &#x27;InvocationTargetException {\n&#x27;
                           &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                           &#x27;        ClassLoader levelClassLoader = &#x27;
                           &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                           &#x27;        URLClassLoader classLoader = null;\n&#x27;
                           &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                           &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                           &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                           &#x27;funcInfo : funcList) {\n&#x27;
                           &#x27;            //classloader\n&#x27;
                           &#x27;            if (classLoader == null) {\n&#x27;
                           &#x27;                classLoader = &#x27;
                           &#x27;ClassLoaderManager.loadExtraJar(jarURList, &#x27;
                           &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                           &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                           &#x27;tableEnv, classLoader);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                           &#x27;     * @param sqlTree\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param tableEnv\n&#x27;
                           &#x27;     * @param localSqlPluginPath\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                           &#x27;shipfile\n&#x27;
                           &#x27;     * @param sideTableMap\n&#x27;
                           &#x27;     * @param registerTableCache\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     * @throws Exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                           &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                           &#x27;StreamTableEnvironment tableEnv, String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                           &#x27;Map&lt;String, SideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                           &#x27;Sets.newHashSet();\n&#x27;
                           &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                           &#x27;new WaterMarkerAssigner();\n&#x27;
                           &#x27;        for (TableInfo tableInfo : &#x27;
                           &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (tableInfo instanceof &#x27;
                           &#x27;SourceTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SourceTableInfo sourceTableInfo = &#x27;
                           &#x27;(SourceTableInfo) tableInfo;\n&#x27;
                           &#x27;                Table table = &#x27;
                           &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                           &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                //Note --- parameter conversion &#x27;
                           &#x27;function can not be used inside a function of the &#x27;
                           &#x27;type of polymerization\n&#x27;
                           &#x27;                //Create table in which the &#x27;
                           &#x27;function is arranged only need adaptation sql\n&#x27;
                           &#x27;                String adaptSql = &#x27;
                           &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                           &#x27;                Table adaptTable = adaptSql == &#x27;
                           &#x27;null ? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(adaptTable.getSchema().getTypes(), &#x27;
                           &#x27;adaptTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;                DataStream adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                           &#x27;                        .filter((Tuple2&lt;Boolean, &#x27;
                           &#x27;Row&gt; f0) -&gt; f0.f0)\n&#x27;
                           &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;f0) -&gt; f0.f1)\n&#x27;
                           &#x27;                        .returns(typeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                           &#x27;typeInfo.getFieldNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    adaptStream = &#x27;
                           &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                           &#x27;typeInfo, sourceTableInfo);\n&#x27;
                           &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    fields += &#x27;
                           &#x27;&quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Table regTable = &#x27;
                           &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;registe table {} &#x27;
                           &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sourceTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;SourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;TargetTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                TableSink tableSink = &#x27;
                           &#x27;StreamSinkFactory.getTableSink((TargetTableInfo) &#x27;
                           &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                           &#x27;                TypeInformation[] flinkTypes = &#x27;
                           &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                           &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sinkTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;TargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;SideTableInfo) {\n&#x27;
                           &#x27;                String sideOperator = &#x27;
                           &#x27;ECacheType.ALL.name().equals(((SideTableInfo) &#x27;
                           &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                           &#x27;(SideTableInfo) tableInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sideTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;sideOperator, SideTableInfo.TARGET_SUFFIX, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;not &#x27;
                           &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return pluginClassPatshSets;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param classPathSet\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static void &#x27;
                           &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                           &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                           &#x27;        int i = 0;\n&#x27;
                           &#x27;        for (URL url : classPathSet) {\n&#x27;
                           &#x27;            String classFileName = &#x27;
                           &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                           &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                           &#x27;classFileName, true);\n&#x27;
                           &#x27;            i++;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                           &#x27;deployMode) throws Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                           &#x27;                &#x27;
                           &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                           &#x27;:\n&#x27;
                           &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        return env;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        ParamsInfo paramsInfo = &#x27;
                         &#x27;ExecuteProcessHelper.parseParams(args);\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExecution(paramsInfo);\n&#x27;
                         &#x27;        env.execute(paramsInfo.getName());\n&#x27;
                         &#x27;        LOG.info(&quot;program {} execution success&quot;, &#x27;
                         &#x27;paramsInfo.getName());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;        String sql = options.getSql();\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String addJarListStr = &#x27;
                           &#x27;options.getAddjar();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;        String confProp = options.getConfProp();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sql = URLDecoder.decode(sql, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(localSqlPluginPath);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (!Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            addJarListStr = &#x27;
                           &#x27;URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;            addJarFileList = &#x27;
                           &#x27;objMapper.readValue(addJarListStr, List.class);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        confProp = URLDecoder.decode(confProp, &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;getStreamExeEnv(confProperties, deployMode);\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv =  &#x27;
                           &#x27;StreamTableEnvironment.getTableEnvironment(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        // init global flinkPlanner\n&#x27;
                           &#x27;        &#x27;
                           &#x27;FlinkPlanner.createFlinkPlanner(tableEnv.getFrameworkConfig(), &#x27;
                           &#x27;tableEnv.getPlanner(), &#x27;
                           &#x27;tableEnv.getTypeFactory());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(sql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            File tmpFile = new File(addJarPath);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;jarURList.add(tmpFile.toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;jarURList, tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;registerTable(sqlTree, env, tableEnv, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode, sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sqlTranslation(localSqlPluginPath, &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        env.execute(name);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                                       SqlTree &#x27;
                           &#x27;sqlTree,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;Table&gt; registerTableCache,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;                    FlinkPlannerImpl flinkPlanner &#x27;
                           &#x27;= FlinkPlanner.getFlinkPlanner();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;flinkPlanner.parse(realSql);\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot; );\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                            System.out.println();\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.classloader.ClassLoaderManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ClusterMode;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.MyLocalStreamEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.environment.StreamEnvConfigManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.exec.FlinkSQLExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.OptionParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateFuncParser;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.CreateTmpTableParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.FlinkPlanner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.parser.InsertSqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlParser;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.parser.SqlTree;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideSqlExec;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.side.SideTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.SourceTableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.table.TargetTableInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.StreamSinkFactory;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.source.StreamSourceFactory;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.watermarker.WaterMarkerAssigner;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.function.FunctionManager;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.PluginUtil;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlInsert;\n&#x27;
                           &#x27;import org.apache.calcite.sql.SqlNode;\n&#x27;
                           &#x27;import org.apache.commons.io.Charsets;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import org.apache.flink.api.java.tuple.Tuple2;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import com.google.common.base.Strings;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;import com.google.common.collect.Maps;\n&#x27;
                           &#x27;import com.google.common.collect.Sets;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.streaming.api.datastream.DataStream;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.exec.ExecuteProcessHelper;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.exec.ParamsInfo;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.StreamQueryConfig;\n&#x27;
                           &#x27;import org.apache.flink.table.api.Table;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.TableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.api.java.StreamTableEnvironment;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.calcite.FlinkPlannerImpl;\n&#x27;
                           &#x27;import org.apache.flink.table.sinks.TableSink;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;java.lang.reflect.InvocationTargetException;\n&#x27;
                           &#x27;import java.net.URL;\n&#x27;
                           &#x27;import java.net.URLClassLoader;\n&#x27;
                           &#x27;import java.net.URLDecoder;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.Properties;\n&#x27;
                           &#x27;import java.util.Set;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.option.Options;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        ParamsInfo paramsInfo = &#x27;
                         &#x27;ExecuteProcessHelper.parseParams(args);\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExecution(paramsInfo);\n&#x27;
                         &#x27;        env.execute(paramsInfo.getName());\n&#x27;
                         &#x27;        LOG.info(&quot;program {} execution success&quot;, &#x27;
                         &#x27;paramsInfo.getName());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;        String sql = options.getSql();\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String addJarListStr = &#x27;
                           &#x27;options.getAddjar();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;        String confProp = options.getConfProp();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sql = URLDecoder.decode(sql, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(localSqlPluginPath);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (!Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            addJarListStr = &#x27;
                           &#x27;URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;            addJarFileList = &#x27;
                           &#x27;objMapper.readValue(addJarListStr, List.class);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        confProp = URLDecoder.decode(confProp, &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;getStreamExeEnv(confProperties, deployMode);\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv =  &#x27;
                           &#x27;StreamTableEnvironment.getTableEnvironment(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        // init global flinkPlanner\n&#x27;
                           &#x27;        &#x27;
                           &#x27;FlinkPlanner.createFlinkPlanner(tableEnv.getFrameworkConfig(), &#x27;
                           &#x27;tableEnv.getPlanner(), &#x27;
                           &#x27;tableEnv.getTypeFactory());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(sql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            File tmpFile = new File(addJarPath);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;jarURList.add(tmpFile.toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;jarURList, tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;registerTable(sqlTree, env, tableEnv, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode, sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sqlTranslation(localSqlPluginPath, &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        env.execute(name);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                                       SqlTree &#x27;
                           &#x27;sqlTree,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;Table&gt; registerTableCache,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;                    FlinkPlannerImpl flinkPlanner &#x27;
                           &#x27;= FlinkPlanner.getFlinkPlanner();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;flinkPlanner.parse(realSql);\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot; );\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                            System.out.println();\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static void &#x27;
                           &#x27;registerUserDefinedFunction(SqlTree sqlTree, &#x27;
                           &#x27;List&lt;URL&gt; jarURList, TableEnvironment tableEnv)\n&#x27;
                           &#x27;            throws IllegalAccessException, &#x27;
                           &#x27;InvocationTargetException {\n&#x27;
                           &#x27;        // udf和tableEnv须由同一个类加载器加载\n&#x27;
                           &#x27;        ClassLoader levelClassLoader = &#x27;
                           &#x27;tableEnv.getClass().getClassLoader();\n&#x27;
                           &#x27;        URLClassLoader classLoader = null;\n&#x27;
                           &#x27;        List&lt;CreateFuncParser.SqlParserResult&gt; &#x27;
                           &#x27;funcList = sqlTree.getFunctionList();\n&#x27;
                           &#x27;        for (CreateFuncParser.SqlParserResult &#x27;
                           &#x27;funcInfo : funcList) {\n&#x27;
                           &#x27;            //classloader\n&#x27;
                           &#x27;            if (classLoader == null) {\n&#x27;
                           &#x27;                classLoader = &#x27;
                           &#x27;ClassLoaderManager.loadExtraJar(jarURList, &#x27;
                           &#x27;(URLClassLoader) levelClassLoader);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            &#x27;
                           &#x27;FunctionManager.registerUDF(funcInfo.getType(), &#x27;
                           &#x27;funcInfo.getClassName(), funcInfo.getName(), &#x27;
                           &#x27;tableEnv, classLoader);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *    向Flink注册源表和结果表，返回执行时插件包的全路径\n&#x27;
                           &#x27;     * @param sqlTree\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param tableEnv\n&#x27;
                           &#x27;     * @param localSqlPluginPath\n&#x27;
                           &#x27;     * @param remoteSqlPluginPath\n&#x27;
                           &#x27;     * @param pluginLoadMode   插件加载模式 classpath or &#x27;
                           &#x27;shipfile\n&#x27;
                           &#x27;     * @param sideTableMap\n&#x27;
                           &#x27;     * @param registerTableCache\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     * @throws Exception\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static Set&lt;URL&gt; registerTable(SqlTree &#x27;
                           &#x27;sqlTree, StreamExecutionEnvironment env, &#x27;
                           &#x27;StreamTableEnvironment tableEnv, String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                          String &#x27;
                           &#x27;remoteSqlPluginPath, String pluginLoadMode, &#x27;
                           &#x27;Map&lt;String, SideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;Map&lt;String, Table&gt; registerTableCache) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;        Set&lt;URL&gt; pluginClassPatshSets = &#x27;
                           &#x27;Sets.newHashSet();\n&#x27;
                           &#x27;        WaterMarkerAssigner waterMarkerAssigner = &#x27;
                           &#x27;new WaterMarkerAssigner();\n&#x27;
                           &#x27;        for (TableInfo tableInfo : &#x27;
                           &#x27;sqlTree.getTableInfoMap().values()) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if (tableInfo instanceof &#x27;
                           &#x27;SourceTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SourceTableInfo sourceTableInfo = &#x27;
                           &#x27;(SourceTableInfo) tableInfo;\n&#x27;
                           &#x27;                Table table = &#x27;
                           &#x27;StreamSourceFactory.getStreamSource(sourceTableInfo, &#x27;
                           &#x27;env, tableEnv, localSqlPluginPath);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(sourceTableInfo.getAdaptName(), &#x27;
                           &#x27;table);\n&#x27;
                           &#x27;                //Note --- parameter conversion &#x27;
                           &#x27;function can not be used inside a function of the &#x27;
                           &#x27;type of polymerization\n&#x27;
                           &#x27;                //Create table in which the &#x27;
                           &#x27;function is arranged only need adaptation sql\n&#x27;
                           &#x27;                String adaptSql = &#x27;
                           &#x27;sourceTableInfo.getAdaptSelectSql();\n&#x27;
                           &#x27;                Table adaptTable = adaptSql == &#x27;
                           &#x27;null ? table : tableEnv.sqlQuery(adaptSql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(adaptTable.getSchema().getTypes(), &#x27;
                           &#x27;adaptTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;                DataStream adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(adaptTable, typeInfo)\n&#x27;
                           &#x27;                        .filter((Tuple2&lt;Boolean, &#x27;
                           &#x27;Row&gt; f0) -&gt; f0.f0)\n&#x27;
                           &#x27;                        .map((Tuple2&lt;Boolean, Row&gt; &#x27;
                           &#x27;f0) -&gt; f0.f1)\n&#x27;
                           &#x27;                        .returns(typeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                String fields = String.join(&quot;,&quot;, &#x27;
                           &#x27;typeInfo.getFieldNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(waterMarkerAssigner.checkNeedAssignWaterMarker(sourceTableInfo)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    adaptStream = &#x27;
                           &#x27;waterMarkerAssigner.assignWaterMarker(adaptStream, &#x27;
                           &#x27;typeInfo, sourceTableInfo);\n&#x27;
                           &#x27;                    fields += &quot;,ROWTIME.ROWTIME&quot;;\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    fields += &#x27;
                           &#x27;&quot;,PROCTIME.PROCTIME&quot;;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                Table regTable = &#x27;
                           &#x27;tableEnv.fromDataStream(adaptStream, fields);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTable(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;                if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                    LOG.info(&quot;registe table {} &#x27;
                           &#x27;success.&quot;, tableInfo.getName());\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                &#x27;
                           &#x27;registerTableCache.put(tableInfo.getName(), &#x27;
                           &#x27;regTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sourceTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;SourceTableInfo.SOURCE_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sourceTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;TargetTableInfo) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                TableSink tableSink = &#x27;
                           &#x27;StreamSinkFactory.getTableSink((TargetTableInfo) &#x27;
                           &#x27;tableInfo, localSqlPluginPath);\n&#x27;
                           &#x27;                TypeInformation[] flinkTypes = &#x27;
                           &#x27;FunctionManager.transformTypes(tableInfo.getFieldClasses());\n&#x27;
                           &#x27;                &#x27;
                           &#x27;tableEnv.registerTableSink(tableInfo.getName(), &#x27;
                           &#x27;tableInfo.getFields(), flinkTypes, tableSink);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sinkTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSourceAndSinkPathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;TargetTableInfo.TARGET_SUFFIX, localSqlPluginPath, &#x27;
                           &#x27;remoteSqlPluginPath, pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sinkTablePathUrl);\n&#x27;
                           &#x27;            } else if (tableInfo instanceof &#x27;
                           &#x27;SideTableInfo) {\n&#x27;
                           &#x27;                String sideOperator = &#x27;
                           &#x27;ECacheType.ALL.name().equals(((SideTableInfo) &#x27;
                           &#x27;tableInfo).getCacheType()) ? &quot;all&quot; : &quot;async&quot;;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;sideTableMap.put(tableInfo.getName(), &#x27;
                           &#x27;(SideTableInfo) tableInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                URL sideTablePathUrl = &#x27;
                           &#x27;PluginUtil.buildSidePathByLoadMode(tableInfo.getType(), &#x27;
                           &#x27;sideOperator, SideTableInfo.TARGET_SUFFIX, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode);\n&#x27;
                           &#x27;                &#x27;
                           &#x27;pluginClassPatshSets.add(sideTablePathUrl);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;not &#x27;
                           &#x27;support table type:&quot; + tableInfo.getType());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return pluginClassPatshSets;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   &#x27;
                           &#x27;perjob模式将job依赖的插件包路径存储到cacheFile，在外围将插件包路径传递给jobgraph\n&#x27;
                           &#x27;     * @param env\n&#x27;
                           &#x27;     * @param classPathSet\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private static void &#x27;
                           &#x27;registerPluginUrlToCachedFile(StreamExecutionEnvironment &#x27;
                           &#x27;env, Set&lt;URL&gt; classPathSet) {\n&#x27;
                           &#x27;        int i = 0;\n&#x27;
                           &#x27;        for (URL url : classPathSet) {\n&#x27;
                           &#x27;            String classFileName = &#x27;
                           &#x27;String.format(CLASS_FILE_NAME_FMT, i);\n&#x27;
                           &#x27;            env.registerCachedFile(url.getPath(), &#x27;
                           &#x27;classFileName, true);\n&#x27;
                           &#x27;            i++;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static StreamExecutionEnvironment &#x27;
                           &#x27;getStreamExeEnv(Properties confProperties, String &#x27;
                           &#x27;deployMode) throws Exception {\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;!ClusterMode.local.name().equals(deployMode) ?\n&#x27;
                           &#x27;                &#x27;
                           &#x27;StreamExecutionEnvironment.getExecutionEnvironment() &#x27;
                           &#x27;:\n&#x27;
                           &#x27;                new MyLocalStreamEnvironment();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;StreamEnvConfigManager.streamExecutionEnvironmentConfig(env, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        return env;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        ParamsInfo paramsInfo = &#x27;
                         &#x27;ExecuteProcessHelper.parseParams(args);\n&#x27;
                         &#x27;        StreamExecutionEnvironment env = &#x27;
                         &#x27;ExecuteProcessHelper.getStreamExecution(paramsInfo);\n&#x27;
                         &#x27;        env.execute(paramsInfo.getName());\n&#x27;
                         &#x27;        LOG.info(&quot;program {} execution success&quot;, &#x27;
                         &#x27;paramsInfo.getName());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        OptionParser optionParser = new &#x27;
                           &#x27;OptionParser(args);\n&#x27;
                           &#x27;        Options options = &#x27;
                           &#x27;optionParser.getOptions();\n&#x27;
                           &#x27;        String sql = options.getSql();\n&#x27;
                           &#x27;        String name = options.getName();\n&#x27;
                           &#x27;        String addJarListStr = &#x27;
                           &#x27;options.getAddjar();\n&#x27;
                           &#x27;        String localSqlPluginPath = &#x27;
                           &#x27;options.getLocalSqlPluginPath();\n&#x27;
                           &#x27;        String remoteSqlPluginPath = &#x27;
                           &#x27;options.getRemoteSqlPluginPath();\n&#x27;
                           &#x27;        String pluginLoadMode = &#x27;
                           &#x27;options.getPluginLoadMode();\n&#x27;
                           &#x27;        String deployMode = options.getMode();\n&#x27;
                           &#x27;        String confProp = options.getConfProp();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sql = URLDecoder.decode(sql, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;SqlParser.setLocalSqlPluginRoot(localSqlPluginPath);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; addJarFileList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if (!Strings.isNullOrEmpty(addJarListStr)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            addJarListStr = &#x27;
                           &#x27;URLDecoder.decode(addJarListStr, &#x27;
                           &#x27;Charsets.UTF_8.name());\n&#x27;
                           &#x27;            addJarFileList = &#x27;
                           &#x27;objMapper.readValue(addJarListStr, List.class);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        confProp = URLDecoder.decode(confProp, &#x27;
                           &#x27;Charsets.UTF_8.toString());\n&#x27;
                           &#x27;        Properties confProperties = &#x27;
                           &#x27;PluginUtil.jsonStrToObject(confProp, &#x27;
                           &#x27;Properties.class);\n&#x27;
                           &#x27;        StreamExecutionEnvironment env = &#x27;
                           &#x27;getStreamExeEnv(confProperties, deployMode);\n&#x27;
                           &#x27;        StreamTableEnvironment tableEnv =  &#x27;
                           &#x27;StreamTableEnvironment.getTableEnvironment(env);\n&#x27;
                           &#x27;        StreamQueryConfig streamQueryConfig = &#x27;
                           &#x27;StreamEnvConfigManager.getStreamQueryConfig(tableEnv, &#x27;
                           &#x27;confProperties);\n&#x27;
                           &#x27;        // init global flinkPlanner\n&#x27;
                           &#x27;        &#x27;
                           &#x27;FlinkPlanner.createFlinkPlanner(tableEnv.getFrameworkConfig(), &#x27;
                           &#x27;tableEnv.getPlanner(), &#x27;
                           &#x27;tableEnv.getTypeFactory());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;URL&gt; jarURList = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        SqlTree sqlTree = &#x27;
                           &#x27;SqlParser.parseSql(sql);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //Get External jar to load\n&#x27;
                           &#x27;        for (String addJarPath : addJarFileList) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            File tmpFile = new File(addJarPath);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;jarURList.add(tmpFile.toURI().toURL());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Map&lt;String, SideTableInfo&gt; sideTableMap = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;        Map&lt;String, Table&gt; registerTableCache = &#x27;
                           &#x27;Maps.newHashMap();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //register udf\n&#x27;
                           &#x27;        registerUserDefinedFunction(sqlTree, &#x27;
                           &#x27;jarURList, tableEnv);\n&#x27;
                           &#x27;        //register table schema\n&#x27;
                           &#x27;        Set&lt;URL&gt; classPathSets = &#x27;
                           &#x27;registerTable(sqlTree, env, tableEnv, &#x27;
                           &#x27;localSqlPluginPath, remoteSqlPluginPath, &#x27;
                           &#x27;pluginLoadMode, sideTableMap, &#x27;
                           &#x27;registerTableCache);\n&#x27;
                           &#x27;        // cache classPathSets\n&#x27;
                           &#x27;        registerPluginUrlToCachedFile(env, &#x27;
                           &#x27;classPathSets);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sqlTranslation(localSqlPluginPath, &#x27;
                           &#x27;tableEnv, sqlTree, sideTableMap, &#x27;
                           &#x27;registerTableCache, streamQueryConfig);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (env instanceof &#x27;
                           &#x27;MyLocalStreamEnvironment) {\n&#x27;
                           &#x27;            ((MyLocalStreamEnvironment) &#x27;
                           &#x27;env).setClasspaths(ClassLoaderManager.getClassPath());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        env.execute(name);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private static void sqlTranslation(String &#x27;
                           &#x27;localSqlPluginPath,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                                       SqlTree &#x27;
                           &#x27;sqlTree,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;SideTableInfo&gt; sideTableMap,\n&#x27;
                           &#x27;                                       Map&lt;String, &#x27;
                           &#x27;Table&gt; registerTableCache,\n&#x27;
                           &#x27;                                       &#x27;
                           &#x27;StreamQueryConfig queryConfig) throws Exception {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SideSqlExec sideSqlExec = new &#x27;
                           &#x27;SideSqlExec();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;sideSqlExec.setLocalSqlPluginPath(localSqlPluginPath);\n&#x27;
                           &#x27;        for (CreateTmpTableParser.SqlParserResult &#x27;
                           &#x27;result : sqlTree.getTmpSqlList()) {\n&#x27;
                           &#x27;            sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, result);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (InsertSqlParser.SqlParseResult result &#x27;
                           &#x27;: sqlTree.getExecSqlList()) {\n&#x27;
                           &#x27;            if (LOG.isInfoEnabled()) {\n&#x27;
                           &#x27;                LOG.info(&quot;exe-sql:\\n&quot; + &#x27;
                           &#x27;result.getExecSql());\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            boolean isSide = false;\n&#x27;
                           &#x27;            for (String tableName : &#x27;
                           &#x27;result.getTargetTableList()) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(sqlTree.getTmpTableMap().containsKey(tableName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult tmp = &#x27;
                           &#x27;sqlTree.getTmpTableMap().get(tableName);\n&#x27;
                           &#x27;                    String realSql = &#x27;
                           &#x27;DtStringUtil.replaceIgnoreQuota(result.getExecSql(), &#x27;
                           &#x27;&quot;`&quot;, &quot;&quot;);\n&#x27;
                           &#x27;                    FlinkPlannerImpl flinkPlanner &#x27;
                           &#x27;= FlinkPlanner.getFlinkPlanner();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    SqlNode sqlNode = &#x27;
                           &#x27;flinkPlanner.parse(realSql);\n&#x27;
                           &#x27;                    String tmpSql = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource().toString();\n&#x27;
                           &#x27;                    tmp.setExecSql(tmpSql);\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;sideSqlExec.exec(tmp.getExecSql(), sideTableMap, &#x27;
                           &#x27;tableEnv, registerTableCache, queryConfig, tmp);\n&#x27;
                           &#x27;                } else {\n&#x27;
                           &#x27;                    for (String sourceTable : &#x27;
                           &#x27;result.getSourceTableList()) {\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sideTableMap.containsKey(sourceTable)) {\n&#x27;
                           &#x27;                            isSide = true;\n&#x27;
                           &#x27;                            break;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                    if (isSide) {\n&#x27;
                           &#x27;                        //sql-dimensional table &#x27;
                           &#x27;contains the dimension table of execution\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sideSqlExec.exec(result.getExecSql(), &#x27;
                           &#x27;sideTableMap, tableEnv, registerTableCache, &#x27;
                           &#x27;queryConfig, null);\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------exec sql without &#x27;
                           &#x27;dimension join-----------&quot; );\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(&quot;----------real sql exec &#x27;
                           &#x27;is--------------------------&quot;);\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;System.out.println(result.getExecSql());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;FlinkSQLExec.sqlUpdate(tableEnv, &#x27;
                           &#x27;result.getExecSql(), queryConfig);\n&#x27;
                           &#x27;                        if(LOG.isInfoEnabled()){\n&#x27;
                           &#x27;                            System.out.println();\n&#x27;
                           &#x27;                            LOG.info(&quot;exec sql: &quot; &#x27;
                           &#x27;+ result.getExecSql());\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        