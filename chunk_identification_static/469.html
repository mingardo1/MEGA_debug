<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>469</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    469
                    <a href="468.html">prev</a>
                    <a href="470.html">next</a>
                    <a href="469_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_cb68efb9e51ba697e771581059b9c11c3fe66ccb_rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^1:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^2:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;828062ef514a8028632086b1c19ef248140da519:rdb/rdb-side/src/main/java/com/dtstack/flink/sql/side/rdb/async/RdbAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.factory.DTThreadFactory;
  24 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25 import com.dtstack.flink.sql.side.BaseSideInfo;
  26 import com.dtstack.flink.sql.side.CacheMissVal;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  29 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  30 import com.dtstack.flink.sql.util.DateUtil;
  31 import com.google.common.collect.Lists;
  32 import com.google.common.collect.Maps;
  33 import io.vertx.core.json.JsonArray;
  34 import io.vertx.core.json.JsonObject;
  35 import io.vertx.ext.sql.SQLClient;
  36 import io.vertx.ext.sql.SQLConnection;
  37 import org.apache.commons.lang3.StringUtils;
  38 import org.apache.flink.configuration.Configuration;
  39 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  40 import org.apache.flink.types.Row;
  41 import org.slf4j.Logger;
  42 import org.slf4j.LoggerFactory;
  43 
  44 import java.math.BigDecimal;
  45 import java.sql.Timestamp;
  46 import java.time.Instant;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.*;
  50 import java.util.concurrent.atomic.AtomicBoolean;
  51 import java.util.concurrent.atomic.AtomicLong;
  52 import org.apache.flink.api.java.tuple.Tuple2;
  53 
  54 /**
  55  * Date: 2018/11/26
  56  * Company: www.dtstack.com
  57  *
  58  * @author maqi
  59  */
  60 
  61 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  62 
  63     private static final long serialVersionUID = 2098635244857937720L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  66 
  67     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  68 
<abbr title="  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *🔵</abbr>
  70 
<abbr title="  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERT🔵</abbr>
  72 
  73     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  74 
  75     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  76 
  77     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  78 
<abbr title="  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSou🔵</abbr>
  80 
  81     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1&quot;;
  82 
  83     private transient SQLClient rdbSqlClient;
  84 
  85     private AtomicBoolean connectionStatus = new AtomicBoolean(true);
  86 
  87     private transient ThreadPoolExecutor executor;
  88 
  89     private final static int MAX_TASK_QUEUE_SIZE = 100000;
  90 
  91     @Override
  92     public void open(Configuration parameters) throws Exception {
  93         super.open(parameters);
<abbr title="  94         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,">  94         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, Ti🔵</abbr>
<abbr title="  95                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new ThreadPoolExecutor.CallerRunsPolicy());">  95                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new 🔵</abbr>
  96     }
  97 
  98     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  99         super(sideInfo);
 100         init(sideInfo);
 101     }
 102 
 103     protected void init(BaseSideInfo sideInfo) {
 104         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 105         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title=" 106         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 106         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :🔵</abbr>
 107         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 108     }
 109 
 110     @Override
 111     protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){
 112 
 113     }
 114 
 115     @Override
<abbr title=" 116     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 116     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 117 
 118         AtomicLong networkLogCounter = new AtomicLong(0L);
 119         while (!connectionStatus.get()){//network is unhealth
 120             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 121                 LOG.info(&quot;network unhealth to block task&quot;);
 122             }
 123             Thread.sleep(100);
 124         }
 125         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 126         executor.execute(() -&gt; connectWithRetry(params, input, resultFuture, rdbSqlClient));
 127     }
 128 
<abbr title=" 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, SQLClient rdbSqlClient) {"> 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 130         AtomicLong failCounter = new AtomicLong(0);
 131         AtomicBoolean finishFlag = new AtomicBoolean(false);
 132         while(!finishFlag.get()){
 133             try{
 134                 CountDownLatch latch = new CountDownLatch(1);
 135                 rdbSqlClient.getConnection(conn -&gt; {
 136                     try {
 137                         if(conn.failed()){
 138                             connectionStatus.set(false);
 139                             if(failCounter.getAndIncrement() % 1000 == 0){
 140                                 LOG.error(&quot;getConnection error&quot;, conn.cause());
 141                             }
<abbr title=" 142                             if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)){"> 142                             if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100🔵</abbr>
 143                                 resultFuture.completeExceptionally(conn.cause());
 144                                 finishFlag.set(true);
 145                             }
 146                             return;
 147                         }
 148                         connectionStatus.set(true);
 149                         ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);
 150                         cancelTimerWhenComplete(resultFuture, timerFuture);
 151                         handleQuery(conn.result(), inputParams, input, resultFuture);
 152                         finishFlag.set(true);
 153                     } catch (Exception e) {
 154                         dealFillDataError(input, resultFuture, e);
 155                     } finally {
 156                         latch.countDown();
 157                     }
 158 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 159                     connectionStatus.set(true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 160                     registerTimerAndAddToHandler(input, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 161 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162                     handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163                     finishFlag.set(true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 164                 } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 165                     dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 166                 } finally {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 167                     latch.countDown();</span>
 168 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170                     connectionStatus.set(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 171                     ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172                     cancelTimerWhenComplete(resultFuture, timerFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 173                     handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 174                     finishFlag.set(true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 175                 } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 176                     dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 177                 } finally {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 178                     latch.countDown();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 179                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182                 latch.await();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183             } catch (InterruptedException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184                 LOG.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186             if(!finishFlag.get()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188                     Thread.sleep(3000);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 189                 } catch (Exception e){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190                     LOG.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195 </span>
 196 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 197                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 198                 try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 199                     latch.await();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 200                 } catch (InterruptedException e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201                     LOG.error(&quot;&quot;, e);</span>
 202 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 203                 }
 204 
 205             } catch (Exception e){
 206                 //数据源队列溢出情况
 207                 connectionStatus.set(false);
 208             }
 209             if(!finishFlag.get()){
 210                 try {
 211                     Thread.sleep(3000);
 212                 } catch (Exception e){
 213                     LOG.error(&quot;&quot;, e);
 214                 }
 215             }
 216         }
 217     }
 218 
 219 
 220     private Object convertDataType(Object val) {
 221         if (val == null) {
 222             // OK
 223         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 224             // OK
 225         } else if (val instanceof Boolean) {
 226             // OK
 227         } else if (val instanceof String) {
 228             // OK
 229         } else if (val instanceof Character) {
 230             // OK
 231         } else if (val instanceof CharSequence) {
 232 
 233         } else if (val instanceof JsonObject) {
 234 
 235         } else if (val instanceof JsonArray) {
 236 
 237         } else if (val instanceof Map) {
 238 
 239         } else if (val instanceof List) {
 240 
 241         } else if (val instanceof byte[]) {
 242 
 243         } else if (val instanceof Instant) {
 244 
 245         } else if (val instanceof Timestamp) {
 246             val = DateUtil.timestampToString((Timestamp) val);
 247         } else if (val instanceof java.util.Date) {
 248             val = DateUtil.dateToString((java.sql.Date) val);
 249         } else {
 250             val = val.toString();
 251         }
 252         return val;
 253 
 254     }
 255 
 256     @Override
 257     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 258         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 259     }
 260 
 261     @Override
 262     public Row fillData(Row input, Object line) {
 263         JsonArray jsonArray = (JsonArray) line;
 264         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 265         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 266             Object obj = input.getField(entry.getValue());
 267             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 268             row.setField(entry.getKey(), obj);
 269         }
 270 
 271         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 272             if (jsonArray == null) {
 273                 row.setField(entry.getKey(), null);
 274             } else {
 275                 String fieldType = sideInfo.getSelectSideFieldType(entry.getValue());
 276                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fieldType);
 277                 row.setField(entry.getKey(), object);
 278             }
 279         }
 280 
 281         return row;
 282     }
 283 
 284 
 285     @Override
 286     public void close() throws Exception {
 287         super.close();
 288         if (rdbSqlClient != null) {
 289             rdbSqlClient.close();
 290         }
 291 
 292         if(executor != null){
 293             executor.shutdown();
 294         }
 295 
 296     }
 297 
 298     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 299         this.rdbSqlClient = rdbSqlClient;
 300     }
 301 
 302 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 303     public void setExecutor(ThreadPoolExecutor executor) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 304         this.executor = executor;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 305     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 306 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 307     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 307     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, R🔵</abbr></span>
 308 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 309 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 310     public void setRdbSqlClient(SQLClient rdbSqlClient) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 311         this.rdbSqlClient = rdbSqlClient;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 312     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 313 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 314     public void setExecutor(ThreadPoolExecutor executor) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 315         this.executor = executor;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 316     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 317 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 318     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 318     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, Resul🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 319         String key = buildCacheKey(inputParams);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 320         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 321         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 322             if (rs.failed()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 323                 dealFillDataError(input, resultFuture, rs.cause());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 324                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 325             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 326 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 327             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 328 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 329             int resultSize = rs.result().getResults().size();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 330             if (resultSize &gt; 0) {</span>
 331 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 332     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 332     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, Resul🔵</abbr></span>
 333 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 334         String key = buildCacheKey(inputParams);
 335         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 336         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 337             if (rs.failed()) {
 338                 dealFillDataError(input, resultFuture, rs.cause());
 339                 return;
 340             }
 341 
 342             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 343 
 344             int resultSize = rs.result().getResults().size();
 345             if (resultSize &gt; 0) {
 346                 List&lt;Tuple2&lt;Boolean, Row&gt;&gt; rowList = Lists.newArrayList();
 347 
 348                 for (JsonArray line : rs.result().getResults()) {
 349                     Row row = fillData(input.f1, line);
 350                     if (openCache()) {
 351                         cacheContent.add(line);
 352                     }
 353                     rowList.add(new Tuple2&lt;Boolean, Row&gt;(input.f0, row));
 354                 }
 355 
 356                 if (openCache()) {
 357                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 358                 }
 359 
 360                 resultFuture.complete(rowList);
 361             } else {
 362                 dealMissKey(input, resultFuture);
 363                 if (openCache()) {
 364                     putCache(key, CacheMissVal.getMissKeyObj());
 365                 }
 366             }
 367 
 368             // and close the connection
 369             connection.close(done -&gt; {
 370                 if (done.failed()) {
 371                     throw new RuntimeException(done.cause());
 372                 }
 373             });
 374         });
 375     }
 376 
 377     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 378         Map&lt;String, Object&gt; result = Maps.newHashMap();
 379         inputParam.forEach((k,v) -&gt; {
 380             result.put(k, convertDataType(v));
 381         });
 382         return result;
 383     }
 384 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side.rdb.async;
  21 
  22 import com.dtstack.flink.sql.enums.ECacheContentType;
  23 import com.dtstack.flink.sql.factory.DTThreadFactory;
  24 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25 import com.dtstack.flink.sql.side.BaseSideInfo;
  26 import com.dtstack.flink.sql.side.CacheMissVal;
  27 import com.dtstack.flink.sql.side.cache.CacheObj;
  28 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  29 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  30 import com.dtstack.flink.sql.util.DateUtil;
  31 import com.google.common.collect.Lists;
  32 import com.google.common.collect.Maps;
  33 import io.vertx.core.json.JsonArray;
  34 import io.vertx.core.json.JsonObject;
  35 import io.vertx.ext.sql.SQLClient;
  36 import io.vertx.ext.sql.SQLConnection;
  37 import org.apache.commons.lang3.StringUtils;
  38 import org.apache.flink.configuration.Configuration;
  39 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  40 import org.apache.flink.types.Row;
  41 import org.slf4j.Logger;
  42 import org.slf4j.LoggerFactory;
  43 
  44 import java.math.BigDecimal;
  45 import java.sql.Timestamp;
  46 import java.time.Instant;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.*;
  50 import java.util.concurrent.atomic.AtomicBoolean;
  51 import java.util.concurrent.atomic.AtomicLong;
  52 import org.apache.flink.api.java.tuple.Tuple2;
  53 
  54 /**
  55  * Date: 2018/11/26
  56  * Company: www.dtstack.com
  57  *
  58  * @author maqi
  59  */
  60 
  61 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  62 
  63     private static final long serialVersionUID = 2098635244857937720L;
  64 
  65     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  66 
  67     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  68 
<abbr title="  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  69     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *🔵</abbr>
  70 
<abbr title="  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  71     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERT🔵</abbr>
  72 
  73     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  74 
  75     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  76 
  77     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  78 
<abbr title="  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  79     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSou🔵</abbr>
  80 
  81     public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1&quot;;
  82 
  83     private transient SQLClient rdbSqlClient;
  84 
  85     private AtomicBoolean connectionStatus = new AtomicBoolean(true);
  86 
  87     private transient ThreadPoolExecutor executor;
  88 
  89     private final static int MAX_TASK_QUEUE_SIZE = 100000;
  90 
  91     @Override
  92     public void open(Configuration parameters) throws Exception {
  93         super.open(parameters);
<abbr title="  94         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,">  94         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, Ti🔵</abbr>
<abbr title="  95                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new ThreadPoolExecutor.CallerRunsPolicy());">  95                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new 🔵</abbr>
  96     }
  97 
  98     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  99         super(sideInfo);
 100         init(sideInfo);
 101     }
 102 
 103     protected void init(BaseSideInfo sideInfo) {
 104         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 105         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title=" 106         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 106         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :🔵</abbr>
 107         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 108     }
 109 
 110     @Override
 111     protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){
 112 
 113     }
 114 
 115     @Override
<abbr title=" 116     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 116     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 117 
 118         AtomicLong networkLogCounter = new AtomicLong(0L);
 119         while (!connectionStatus.get()){//network is unhealth
 120             if(networkLogCounter.getAndIncrement() % 1000 == 0){
 121                 LOG.info(&quot;network unhealth to block task&quot;);
 122             }
 123             Thread.sleep(100);
 124         }
 125         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 126         executor.execute(() -&gt; connectWithRetry(params, input, resultFuture, rdbSqlClient));
 127     }
 128 
<abbr title=" 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, SQLClient rdbSqlClient) {"> 129     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 130         AtomicLong failCounter = new AtomicLong(0);
 131         AtomicBoolean finishFlag = new AtomicBoolean(false);
 132         while(!finishFlag.get()){
 133             try{
 134             CountDownLatch latch = new CountDownLatch(1);
 135             rdbSqlClient.getConnection(conn -&gt; {
 136                 try {
 137                     if(conn.failed()){
 138                         connectionStatus.set(false);
 139                         if(failCounter.getAndIncrement() % 1000 == 0){
 140                             LOG.error(&quot;getConnection error&quot;, conn.cause());
 141                         }
 142                         if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)){
 143                             resultFuture.completeExceptionally(conn.cause());
 144                             finishFlag.set(true);
 145                         }
 146                         return;
 147                     }
 148                     connectionStatus.set(true);
 149                     registerTimerAndAddToHandler(input, resultFuture);
 150 
 151                     handleQuery(conn.result(), inputParams, input, resultFuture);
 152                     finishFlag.set(true);
 153                 } catch (Exception e) {
 154                     dealFillDataError(input, resultFuture, e);
 155                 } finally {
 156                     latch.countDown();
 157                 }
 158             });
 159             try {
 160                 latch.await();
 161             } catch (InterruptedException e) {
 162                 LOG.error(&quot;&quot;, e);
 163             }
 164 
 165             } catch (Exception e){
 166                 //数据源队列溢出情况
 167                 connectionStatus.set(false);
 168             }
 169             if(!finishFlag.get()){
 170                 try {
 171                     Thread.sleep(3000);
 172                 } catch (Exception e){
 173                     LOG.error(&quot;&quot;, e);
 174                 }
 175             }
 176         }
 177     }
 178 
 179 
 180     private Object convertDataType(Object val) {
 181         if (val == null) {
 182             // OK
 183         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 184             // OK
 185         } else if (val instanceof Boolean) {
 186             // OK
 187         } else if (val instanceof String) {
 188             // OK
 189         } else if (val instanceof Character) {
 190             // OK
 191         } else if (val instanceof CharSequence) {
 192 
 193         } else if (val instanceof JsonObject) {
 194 
 195         } else if (val instanceof JsonArray) {
 196 
 197         } else if (val instanceof Map) {
 198 
 199         } else if (val instanceof List) {
 200 
 201         } else if (val instanceof byte[]) {
 202 
 203         } else if (val instanceof Instant) {
 204 
 205         } else if (val instanceof Timestamp) {
 206             val = DateUtil.timestampToString((Timestamp) val);
 207         } else if (val instanceof java.util.Date) {
 208             val = DateUtil.dateToString((java.sql.Date) val);
 209         } else {
 210             val = val.toString();
 211         }
 212         return val;
 213 
 214     }
 215 
 216     @Override
 217     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 218         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 219     }
 220 
 221     @Override
 222     public Row fillData(Row input, Object line) {
 223         JsonArray jsonArray = (JsonArray) line;
 224         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 225         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 226             Object obj = input.getField(entry.getValue());
 227             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 228             row.setField(entry.getKey(), obj);
 229         }
 230 
 231         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 232             if (jsonArray == null) {
 233                 row.setField(entry.getKey(), null);
 234             } else {
 235                 String fieldType = sideInfo.getSelectSideFieldType(entry.getValue());
 236                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fieldType);
 237                 row.setField(entry.getKey(), object);
 238             }
 239         }
 240 
 241         return row;
 242     }
 243 
 244 
 245     @Override
 246     public void close() throws Exception {
 247         super.close();
 248         if (rdbSqlClient != null) {
 249             rdbSqlClient.close();
 250         }
 251 
 252         if(executor != null){
 253             executor.shutdown();
 254         }
 255 
 256     }
 257 
 258     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 259         this.rdbSqlClient = rdbSqlClient;
 260     }
 261 
<abbr title=" 262     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 262     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, R🔵</abbr>
 263         String key = buildCacheKey(inputParams);
 264         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 265         connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 266             if (rs.failed()) {
 267                 dealFillDataError(input, resultFuture, rs.cause());
 268                 return;
 269             }
 270 
 271             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 272 
 273             int resultSize = rs.result().getResults().size();
 274             if (resultSize &gt; 0) {
 275                 List&lt;Tuple2&lt;Boolean, Row&gt;&gt; rowList = Lists.newArrayList();
 276 
 277                 for (JsonArray line : rs.result().getResults()) {
 278                     Row row = fillData(input.f1, line);
 279                     if (openCache()) {
 280                         cacheContent.add(line);
 281                     }
 282                     rowList.add(new Tuple2&lt;Boolean, Row&gt;(input.f0, row));
 283                 }
 284 
 285                 if (openCache()) {
 286                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 287                 }
 288 
 289                 resultFuture.complete(rowList);
 290             } else {
 291                 dealMissKey(input, resultFuture);
 292                 if (openCache()) {
 293                     putCache(key, CacheMissVal.getMissKeyObj());
 294                 }
 295             }
 296 
 297             // and close the connection
 298             connection.close(done -&gt; {
 299                 if (done.failed()) {
 300                     throw new RuntimeException(done.cause());
 301                 }
 302             });
 303         });
 304     }
 305 
 306     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 307         Map&lt;String, Object&gt; result = Maps.newHashMap();
 308         inputParam.forEach((k,v) -&gt; {
 309             result.put(k, convertDataType(v));
 310         });
 311         return result;
 312     }
 313 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.rdb.async;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.factory.DTThreadFactory;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 import com.dtstack.flink.sql.side.BaseSideInfo;
  24 import com.dtstack.flink.sql.side.CacheMissVal;
  25 import com.dtstack.flink.sql.side.cache.CacheObj;
  26 import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  27 import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  28 import com.dtstack.flink.sql.util.DateUtil;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import io.vertx.core.json.JsonArray;
  32 import io.vertx.core.json.JsonObject;
  33 import io.vertx.ext.sql.SQLClient;
  34 import io.vertx.ext.sql.SQLConnection;
  35 import java.math.BigDecimal;
  36 import java.sql.Timestamp;
  37 import java.time.Instant;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.concurrent.*;
  41 import java.util.concurrent.atomic.AtomicBoolean;
  42 import java.util.concurrent.atomic.AtomicLong;
  43 import org.apache.commons.lang3.StringUtils;
  44 import org.apache.flink.api.java.tuple.Tuple2;
  45 import org.apache.flink.configuration.Configuration;
  46 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  47 import org.apache.flink.types.Row;
  48 import org.slf4j.Logger;
  49 import org.slf4j.LoggerFactory;
  50 
  51 
  52 /**
  53  * Date: 2018/11/26
  54  * Company: www.dtstack.com
  55  *
  56  * @author maqi
  57  */
  58 public class RdbAsyncReqRow extends BaseAsyncReqRow {
  59     private static final long serialVersionUID = 2098635244857937720L;
  60 
  61     private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  62 
  63     public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  64 
<abbr title="  65     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;">  65     public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() *🔵</abbr>
  66 
<abbr title="  67     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  67     public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERT🔵</abbr>
  68 
  69     public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  70 
  71     public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  72 
  73     public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  74 
<abbr title="  75     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  75     public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSou🔵</abbr>
  76 
  77     public static final String PREFERRED_TEST_QUERY_SQL = &quot;select 1&quot;;
  78 
  79     private transient SQLClient rdbSqlClient;
  80 
  81     private AtomicBoolean connectionStatus = new AtomicBoolean(true);
  82 
  83     private transient ThreadPoolExecutor executor;
  84 
  85     private final static int MAX_TASK_QUEUE_SIZE = 100000;
  86 
  87     @Override
  88     public void open(Configuration parameters) throws Exception {
  89         super.open(parameters);
<abbr title="  90         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new ThreadPoolExecutor.CallerRunsPolicy());">  90         executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, Ti🔵</abbr>
  91     }
  92 
  93     public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  94         super(sideInfo);
  95         init(sideInfo);
  96     }
  97 
  98     protected void init(BaseSideInfo sideInfo) {
  99         RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 100         int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title=" 101         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 101         int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() :🔵</abbr>
 102         rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 103     }
 104 
 105     @Override
<abbr title=" 106     protected void preInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 106     protected void preInvoke(Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture)🔵</abbr>
 107     }
 108 
 109     @Override
<abbr title=" 110     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 110     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 111         AtomicLong networkLogCounter = new AtomicLong(0L);
 112         while (!connectionStatus.get()) {
 113             // network is unhealth
 114             if ((networkLogCounter.getAndIncrement() % 1000) == 0) {
 115                 LOG.info(&quot;network unhealth to block task&quot;);
 116             }
 117             Thread.sleep(100);
 118         }
 119         Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 120         executor.execute(() -&gt; connectWithRetry(params, input, resultFuture, rdbSqlClient));
 121     }
 122 
<abbr title=" 123     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, SQLClient rdbSqlClient) {"> 123     private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutu🔵</abbr>
 124         AtomicLong failCounter = new AtomicLong(0);
 125         AtomicBoolean finishFlag = new AtomicBoolean(false);
 126         while (!finishFlag.get()) {
 127             try {
 128                 CountDownLatch latch = new CountDownLatch(1);
 129                 rdbSqlClient.getConnection(( conn) -&gt; {
 130                     try {
 131                         if (conn.failed()) {
 132                             connectionStatus.set(false);
 133                             if ((failCounter.getAndIncrement() % 1000) == 0) {
 134                                 LOG.error(&quot;getConnection error&quot;, conn.cause());
 135                             }
<abbr title=" 136                             if (failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)) {"> 136                             if (failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(10🔵</abbr>
 137                                 resultFuture.completeExceptionally(conn.cause());
 138                                 finishFlag.set(true);
 139                             }
 140                             return;
 141                         }
 142                         connectionStatus.set(true);
 143                         registerTimerAndAddToHandler(input, resultFuture);
 144                         handleQuery(conn.result(), inputParams, input, resultFuture);
 145                         finishFlag.set(true);
 146                     } catch ( e) {
 147                         dealFillDataError(input, resultFuture, e);
 148                     } finally {
 149                         latch.countDown();
 150                     }
 151                 });
 152                 try {
 153                     latch.await();
 154                 } catch (java.lang.InterruptedException e) {
 155                     LOG.error(&quot;&quot;, e);
 156                 }
 157             } catch (java.lang.Exception e) {
 158                 // 数据源队列溢出情况
 159                 connectionStatus.set(false);
 160             }
 161             if (!finishFlag.get()) {
 162                 try {
 163                     Thread.sleep(3000);
 164                 } catch (java.lang.Exception e) {
 165                     LOG.error(&quot;&quot;, e);
 166                 }
 167             }
 168         }
 169     }
 170 
 171     private Object convertDataType(Object val) {
 172         if (val == null) {
 173             // OK
 174         } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 175             // OK
 176         } else if (val instanceof Boolean) {
 177             // OK
 178         } else if (val instanceof String) {
 179             // OK
 180         } else if (val instanceof Character) {
 181             // OK
 182         } else if (val instanceof CharSequence) {
 183 
 184         } else if (val instanceof JsonObject) {
 185 
 186         } else if (val instanceof JsonArray) {
 187 
 188         } else if (val instanceof Map) {
 189 
 190         } else if (val instanceof List) {
 191 
 192         } else if (val instanceof byte[]) {
 193 
 194         } else if (val instanceof Instant) {
 195 
 196         } else if (val instanceof Timestamp) {
 197             val = DateUtil.timestampToString((Timestamp) val);
 198         } else if (val instanceof java.util.Date) {
 199             val = DateUtil.dateToString((java.sql.Date) val);
 200         } else {
 201             val = val.toString();
 202         }
 203         return val;
 204 
 205     }
 206 
 207     @Override
 208     public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 209         return StringUtils.join(inputParam.values(),&quot;_&quot;);
 210     }
 211 
 212     @Override
 213     public Row fillData(Row input, Object line) {
 214         JsonArray jsonArray = ((JsonArray) (line));
 215         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 216         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 217             Object obj = input.getField(entry.getValue());
 218             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 219             row.setField(entry.getKey(), obj);
 220         }
 221         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 222             if (jsonArray == null) {
 223                 row.setField(entry.getKey(), null);
 224             } else {
 225                 String fieldType = sideInfo.getSelectSideFieldType(entry.getValue());
 226                 Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fieldType);
 227                 row.setField(entry.getKey(), object);
 228             }
 229         }
 230         return row;
 231     }
 232 
 233     @Override
 234     public void close() throws Exception {
 235         super.close();
 236         if (rdbSqlClient != null) {
 237             rdbSqlClient.close();
 238         }
 239 
 240         if(executor != null){
 241             executor.shutdown();
 242         }
 243 
 244     }
 245 
 246     public void setRdbSqlClient(SQLClient rdbSqlClient) {
 247         this.rdbSqlClient = rdbSqlClient;
 248     }
 249 
<abbr title=" 250     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) {"> 250     private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, R🔵</abbr>
 251         String key = buildCacheKey(inputParams);
 252         JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 253         connection.queryWithParams(sideInfo.getSqlCondition(), params, ( rs) -&gt; {
 254             if (rs.failed()) {
 255                 dealFillDataError(input, resultFuture, rs.cause());
 256                 return;
 257             }
 258             List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 259             int resultSize = rs.result().getResults().size();
 260             if (resultSize &gt; 0) {
 261                 List&lt;Tuple2&lt;Boolean, Row&gt;&gt; rowList = Lists.newArrayList();
 262                 for (JsonArray line : rs.result().getResults()) {
 263                     Row row = fillData(input.f1, line);
 264                     if (openCache()) {
 265                         cacheContent.add(line);
 266                     }
 267                     rowList.add(new Tuple2&lt;Boolean, Row&gt;(input.f0, row));
 268                 }
 269                 if (openCache()) {
 270                     putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 271                 }
 272                 resultFuture.complete(rowList);
 273             } else {
 274                 dealMissKey(input, resultFuture);
 275                 if (openCache()) {
 276                     putCache(key, CacheMissVal.getMissKeyObj());
 277                 }
 278             }
 279             // and close the connection
 280             connection.close(( done) -&gt; {
 281                 if (done.failed()) {
 282                     throw new RuntimeException(done.cause());
 283                 }
 284             });
 285         });
 286     }
 287 
 288     private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 289         Map&lt;String, Object&gt; result = Maps.newHashMap();
 290         inputParam.forEach((k,v) -&gt; {
 291             result.put(k, convertDataType(v));
 292         });
 293         return result;
 294     }
 295 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.factory.DTThreadFactory;
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.BaseSideInfo;
  26  import com.dtstack.flink.sql.side.CacheMissVal;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
  28  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  29  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  30  import com.dtstack.flink.sql.util.DateUtil;
  31  import com.google.common.collect.Lists;
  32  import com.google.common.collect.Maps;
  33  import io.vertx.core.json.JsonArray;
  34  import io.vertx.core.json.JsonObject;
  35  import io.vertx.ext.sql.SQLClient;
  36  import io.vertx.ext.sql.SQLConnection;
  37  import org.apache.commons.lang3.StringUtils;

  38  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  41  import org.apache.flink.types.Row;
  42  import org.slf4j.Logger;
  43  import org.slf4j.LoggerFactory;
  44  
  45  import java.math.BigDecimal;
  46  import java.sql.Timestamp;
  47  import java.time.Instant;
  48  import java.util.List;
  49  import java.util.Map;
  50  import java.util.concurrent.*;
  51  import java.util.concurrent.atomic.AtomicBoolean;
  52  import java.util.concurrent.atomic.AtomicLong;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  54  
  55  /**
  56   * Date: 2018/11/26
  57   * Company: www.dtstack.com
  58   *
  59   * @author maqi
  60   */
  61  
  62  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  63  
  64      private static final long serialVersionUID = 2098635244857937720L;
  65  
  66      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  67  
  68      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  69  
  70      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  71  
<abbr title="  72      public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  72      public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_🔵</abbr>
  73  
  74      public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  75  
  76      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  77  
  78      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  79  
<abbr title="  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvid🔵</abbr>
  81  
  82      public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;

  83  
  84      private transient SQLClient rdbSqlClient;
  85  
  86      private AtomicBoolean connectionStatus = new AtomicBoolean(true);
  87  
  88      private transient ThreadPoolExecutor executor;









  89  
  90      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
  91          super(sideInfo);
  92          init(sideInfo);
  93      }
  94  
  95      protected void init(BaseSideInfo sideInfo) {
  96          RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
  97          int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title="  98          int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;">  98          int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultA🔵</abbr>
  99          rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 100      }
 101  
 102      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -    protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 108 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 108 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) th🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +    protected void preInvoke(Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 114 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 114 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2🔵</abbr></span>
 115  
 116          AtomicLong networkLogCounter = new AtomicLong(0L);
 117          while (!connectionStatus.get()){//network is unhealth
 118              if(networkLogCounter.getAndIncrement() % 1000 == 0){
 119                  LOG.info(&quot;network unhealth to block task&quot;);
 120              }
 121              Thread.sleep(100);
 122          }
 123          Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 124          executor.execute(() -&gt; connectWithRetry(params, input, resultFuture, rdbSqlClient));
 125      }
 126  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 127 -    private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 127 -    private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQ🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 128 +    private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture, SQLClient rdbSqlClient) {"> 128 +    private void connectWithRetry(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2🔵</abbr></span>
 129          AtomicLong failCounter = new AtomicLong(0);
 130          AtomicBoolean finishFlag = new AtomicBoolean(false);
 131          while(!finishFlag.get()){
 132              CountDownLatch latch = new CountDownLatch(1);
 133              rdbSqlClient.getConnection(conn -&gt; {


























 134                  try {
 135                      if(conn.failed()){
 136                          connectionStatus.set(false);
 137                          if(failCounter.getAndIncrement() % 1000 == 0){
 138                              LOG.error(&quot;getConnection error&quot;, conn.cause());
 139                          }
 140                          if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)){
 141                              resultFuture.completeExceptionally(conn.cause());
 142                              finishFlag.set(true);
 143                          }
 144                          return;
 145                      }
 146                      connectionStatus.set(true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                    ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -                    cancelTimerWhenComplete(resultFuture, timerFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +                    registerTimerAndAddToHandler(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +</span>
 151                      handleQuery(conn.result(), inputParams, input, resultFuture);
 152                      finishFlag.set(true);
 153                  } catch (Exception e) {
 154                      dealFillDataError(input, resultFuture, e);
 155                  } finally {
 156                      latch.countDown();
 157                  }
 158              });
 159              try {
 160                  latch.await();
 161              } catch (InterruptedException e) {
 162                  LOG.error(&quot;&quot;, e);








 163              }
 164              if(!finishFlag.get()){
 165                  try {
 166                      Thread.sleep(3000);
 167                  } catch (Exception e){
 168                      LOG.error(&quot;&quot;, e);
 169                  }
 170              }
 171          }
 172      }
 173  
 174  
 175      private Object convertDataType(Object val) {
 176          if (val == null) {
 177              // OK
 178          } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 179              // OK
 180          } else if (val instanceof Boolean) {
 181              // OK
 182          } else if (val instanceof String) {
 183              // OK
 184          } else if (val instanceof Character) {
 185              // OK
 186          } else if (val instanceof CharSequence) {
 187  
 188          } else if (val instanceof JsonObject) {
 189  
 190          } else if (val instanceof JsonArray) {
 191  
 192          } else if (val instanceof Map) {
 193  
 194          } else if (val instanceof List) {
 195  
 196          } else if (val instanceof byte[]) {
 197  
 198          } else if (val instanceof Instant) {
 199  
 200          } else if (val instanceof Timestamp) {
 201              val = DateUtil.timestampToString((Timestamp) val);
 202          } else if (val instanceof java.util.Date) {
 203              val = DateUtil.dateToString((java.sql.Date) val);
 204          } else {
 205              val = val.toString();
 206          }
 207          return val;
 208  
 209      }
 210  
 211      @Override
 212      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 213          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 214      }
 215  
 216      @Override
 217      public Row fillData(Row input, Object line) {
 218          JsonArray jsonArray = (JsonArray) line;
 219          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 220          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 221              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 222 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 222 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -                obj = ((Timestamp) obj).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 226 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
 228              row.setField(entry.getKey(), obj);
 229          }
 230  
 231          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 232              if (jsonArray == null) {
 233                  row.setField(entry.getKey(), null);
 234              } else {
 235                  String fieldType = sideInfo.getSelectSideFieldType(entry.getValue());
 236                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fieldType);
 237                  row.setField(entry.getKey(), object);
 238              }
 239          }
 240  
 241          return row;
 242      }
 243  
 244  
 245      @Override
 246      public void close() throws Exception {
 247          super.close();
 248          if (rdbSqlClient != null) {
 249              rdbSqlClient.close();
 250          }
 251  
 252          if(executor != null){
 253              executor.shutdown();
 254          }
 255  
 256      }
 257  
 258      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 259          this.rdbSqlClient = rdbSqlClient;
 260      }
 261  
 262      public void setExecutor(ThreadPoolExecutor executor) {
 263          this.executor = executor;
 264      }
 265  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 266 -    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 266 -    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;C🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 267 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture){"> 267 +    private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input🔵</abbr></span>
 268          String key = buildCacheKey(inputParams);
 269          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 270          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 271              if (rs.failed()) {
 272                  dealFillDataError(input, resultFuture, rs.cause());
 273                  return;
 274              }
 275  
 276              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 277  
 278              int resultSize = rs.result().getResults().size();
 279              if (resultSize &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -                List&lt;CRow&gt; rowList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +                List&lt;Tuple2&lt;Boolean, Row&gt;&gt; rowList = Lists.newArrayList();</span>
 282  
 283                  for (JsonArray line : rs.result().getResults()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 284 -                    Row row = fillData(input.row(), line);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +                    Row row = fillData(input.f1, line);</span>
 286                      if (openCache()) {
 287                          cacheContent.add(line);
 288                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -                    rowList.add(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +                    rowList.add(new Tuple2&lt;Boolean, Row&gt;(input.f0, row));</span>
 291                  }
 292  
 293                  if (openCache()) {
 294                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 295                  }
 296  
 297                  resultFuture.complete(rowList);
 298              } else {
 299                  dealMissKey(input, resultFuture);
 300                  if (openCache()) {
 301                      putCache(key, CacheMissVal.getMissKeyObj());
 302                  }
 303              }
 304  
 305              // and close the connection
 306              connection.close(done -&gt; {
 307                  if (done.failed()) {
 308                      throw new RuntimeException(done.cause());
 309                  }
 310              });
 311          });
 312      }
 313  
 314      private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 315          Map&lt;String, Object&gt; result = Maps.newHashMap();
 316          inputParam.forEach((k,v) -&gt; {
 317              result.put(k, convertDataType(v));
 318          });
 319          return result;
 320      }
 321  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side.rdb.async;
  21  
  22  import com.dtstack.flink.sql.enums.ECacheContentType;
  23  import com.dtstack.flink.sql.factory.DTThreadFactory;
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.BaseSideInfo;
  26  import com.dtstack.flink.sql.side.CacheMissVal;
  27  import com.dtstack.flink.sql.side.cache.CacheObj;
  28  import com.dtstack.flink.sql.side.rdb.table.RdbSideTableInfo;
  29  import com.dtstack.flink.sql.side.rdb.util.SwitchUtil;
  30  import com.dtstack.flink.sql.util.DateUtil;
  31  import com.google.common.collect.Lists;
  32  import com.google.common.collect.Maps;
  33  import io.vertx.core.json.JsonArray;
  34  import io.vertx.core.json.JsonObject;
  35  import io.vertx.ext.sql.SQLClient;
  36  import io.vertx.ext.sql.SQLConnection;
  37  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import org.apache.flink.configuration.Configuration;</span>
  39  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  40  import org.apache.flink.table.runtime.types.CRow;
  41  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  42  import org.apache.flink.types.Row;
  43  import org.slf4j.Logger;
  44  import org.slf4j.LoggerFactory;
  45  
  46  import java.math.BigDecimal;
  47  import java.sql.Timestamp;
  48  import java.time.Instant;
  49  import java.util.List;
  50  import java.util.Map;
  51  import java.util.concurrent.*;
  52  import java.util.concurrent.atomic.AtomicBoolean;
  53  import java.util.concurrent.atomic.AtomicLong;

  54  
  55  /**
  56   * Date: 2018/11/26
  57   * Company: www.dtstack.com
  58   *
  59   * @author maqi
  60   */
  61  
  62  public class RdbAsyncReqRow extends BaseAsyncReqRow {
  63  
  64      private static final long serialVersionUID = 2098635244857937720L;
  65  
  66      private static final Logger LOG = LoggerFactory.getLogger(RdbAsyncReqRow.class);
  67  
  68      public final static int DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE = 1;
  69  
  70      public final static int DEFAULT_VERTX_WORKER_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
  71  
<abbr title="  72      public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_POOL_SIZE;">  72      public final static int DEFAULT_DB_CONN_POOL_SIZE = DEFAULT_VERTX_EVENT_LOOP_POOL_SIZE + DEFAULT_VERTX_WORKER_🔵</abbr>
  73  
  74      public final static int MAX_DB_CONN_POOL_SIZE_LIMIT = 20;
  75  
  76      public final static int DEFAULT_IDLE_CONNECTION_TEST_PEROID = 60;
  77  
  78      public final static boolean DEFAULT_TEST_CONNECTION_ON_CHECKIN = true;
  79  
<abbr title="  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvider&quot;;">  80      public final static String DT_PROVIDER_CLASS = &quot;com.dtstack.flink.sql.side.rdb.provider.DTC3P0DataSourceProvid🔵</abbr>
  81  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -    public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1 from dual&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    public final static String PREFERRED_TEST_QUERY_SQL = &quot;select 1&quot;;</span>
  84  
  85      private transient SQLClient rdbSqlClient;
  86  
  87      private AtomicBoolean connectionStatus = new AtomicBoolean(true);
  88  
  89      private transient ThreadPoolExecutor executor;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +    private final static int MAX_TASK_QUEUE_SIZE = 100000;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +    public void open(Configuration parameters) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +        super.open(parameters);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  96 +        executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,">  96 +        executor = new ThreadPoolExecutor(MAX_DB_CONN_POOL_SIZE_LIMIT, MAX_DB_CONN_POOL_SIZE_LIMIT, 0, TimeUnit.MI🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  97 +                new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new ThreadPoolExecutor.CallerRunsPolicy());">  97 +                new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;rdbAsyncExec&quot;), new ThreadPoo🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +    }</span>
  99  
 100      public RdbAsyncReqRow(BaseSideInfo sideInfo) {
 101          super(sideInfo);
 102          init(sideInfo);
 103      }
 104  
 105      protected void init(BaseSideInfo sideInfo) {
 106          RdbSideTableInfo rdbSideTableInfo = (RdbSideTableInfo) sideInfo.getSideTableInfo();
 107          int defaultAsyncPoolSize = Math.min(MAX_DB_CONN_POOL_SIZE_LIMIT, DEFAULT_DB_CONN_POOL_SIZE);
<abbr title=" 108          int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultAsyncPoolSize;"> 108          int rdbPoolSize = rdbSideTableInfo.getAsyncPoolSize() &gt; 0 ? rdbSideTableInfo.getAsyncPoolSize() : defaultA🔵</abbr>
 109          rdbSideTableInfo.setAsyncPoolSize(rdbPoolSize);
 110      }
 111  
 112      @Override
 113      protected void preInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture){
 114  
 115      }
 116  
 117      @Override
<abbr title=" 118      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 118      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) th🔵</abbr>






 119  
 120          AtomicLong networkLogCounter = new AtomicLong(0L);
 121          while (!connectionStatus.get()){//network is unhealth
 122              if(networkLogCounter.getAndIncrement() % 1000 == 0){
 123                  LOG.info(&quot;network unhealth to block task&quot;);
 124              }
 125              Thread.sleep(100);
 126          }
 127          Map&lt;String, Object&gt; params = formatInputParam(inputParams);
 128          executor.execute(() -&gt; connectWithRetry(params, input, resultFuture, rdbSqlClient));
 129      }
 130  
<abbr title=" 131      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQLClient rdbSqlClient) {"> 131      private void connectWithRetry(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture, SQ🔵</abbr>

 132          AtomicLong failCounter = new AtomicLong(0);
 133          AtomicBoolean finishFlag = new AtomicBoolean(false);
 134          while(!finishFlag.get()){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -            CountDownLatch latch = new CountDownLatch(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -            rdbSqlClient.getConnection(conn -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +            try{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +                CountDownLatch latch = new CountDownLatch(1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +                rdbSqlClient.getConnection(conn -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +                        if(conn.failed()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +                            connectionStatus.set(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +                            if(failCounter.getAndIncrement() % 1000 == 0){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +                                LOG.error(&quot;getConnection error&quot;, conn.cause());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +                            if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +                                resultFuture.completeExceptionally(conn.cause());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +                                finishFlag.set(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +                            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +                        connectionStatus.set(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +                        ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +                        cancelTimerWhenComplete(resultFuture, timerFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +                        handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +                        finishFlag.set(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +                        dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                    } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +                        latch.countDown();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +                });</span>
 163                  try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -                    if(conn.failed()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -                        connectionStatus.set(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -                        if(failCounter.getAndIncrement() % 1000 == 0){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -                            LOG.error(&quot;getConnection error&quot;, conn.cause());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -                        if(failCounter.get() &gt;= sideInfo.getSideTableInfo().getConnectRetryMaxNum(100)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -                            resultFuture.completeExceptionally(conn.cause());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 171 -                            finishFlag.set(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -                        return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -                    connectionStatus.set(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -                    ScheduledFuture&lt;?&gt; timerFuture = registerTimer(input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -                    cancelTimerWhenComplete(resultFuture, timerFuture);</span>


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -                    handleQuery(conn.result(), inputParams, input, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -                    finishFlag.set(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -                } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -                    dealFillDataError(input, resultFuture, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -                    latch.countDown();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -                latch.await();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -            } catch (InterruptedException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -                LOG.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +                    latch.await();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                } catch (InterruptedException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +                    LOG.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +            } catch (Exception e){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +                //数据源队列溢出情况</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +                connectionStatus.set(false);</span>
 198              }
 199              if(!finishFlag.get()){
 200                  try {
 201                      Thread.sleep(3000);
 202                  } catch (Exception e){
 203                      LOG.error(&quot;&quot;, e);
 204                  }
 205              }
 206          }
 207      }
 208  
 209  
 210      private Object convertDataType(Object val) {
 211          if (val == null) {
 212              // OK
 213          } else if (val instanceof Number &amp;&amp; !(val instanceof BigDecimal)) {
 214              // OK
 215          } else if (val instanceof Boolean) {
 216              // OK
 217          } else if (val instanceof String) {
 218              // OK
 219          } else if (val instanceof Character) {
 220              // OK
 221          } else if (val instanceof CharSequence) {
 222  
 223          } else if (val instanceof JsonObject) {
 224  
 225          } else if (val instanceof JsonArray) {
 226  
 227          } else if (val instanceof Map) {
 228  
 229          } else if (val instanceof List) {
 230  
 231          } else if (val instanceof byte[]) {
 232  
 233          } else if (val instanceof Instant) {
 234  
 235          } else if (val instanceof Timestamp) {
 236              val = DateUtil.timestampToString((Timestamp) val);
 237          } else if (val instanceof java.util.Date) {
 238              val = DateUtil.dateToString((java.sql.Date) val);
 239          } else {
 240              val = val.toString();
 241          }
 242          return val;
 243  
 244      }
 245  
 246      @Override
 247      public String buildCacheKey(Map&lt;String, Object&gt; inputParam) {
 248          return StringUtils.join(inputParam.values(),&quot;_&quot;);
 249      }
 250  
 251      @Override
 252      public Row fillData(Row input, Object line) {
 253          JsonArray jsonArray = (JsonArray) line;
 254          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 255          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 256              Object obj = input.getField(entry.getValue());
<abbr title=" 257              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 257              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr>
 258              if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {
 259                  obj = ((Timestamp) obj).getTime();
 260              }
 261  

 262              row.setField(entry.getKey(), obj);
 263          }
 264  
 265          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 266              if (jsonArray == null) {
 267                  row.setField(entry.getKey(), null);
 268              } else {
 269                  String fieldType = sideInfo.getSelectSideFieldType(entry.getValue());
 270                  Object object = SwitchUtil.getTarget(jsonArray.getValue(entry.getValue()), fieldType);
 271                  row.setField(entry.getKey(), object);
 272              }
 273          }
 274  
 275          return row;
 276      }
 277  
 278  
 279      @Override
 280      public void close() throws Exception {
 281          super.close();
 282          if (rdbSqlClient != null) {
 283              rdbSqlClient.close();
 284          }
 285  
 286          if(executor != null){
 287              executor.shutdown();
 288          }
 289  
 290      }
 291  
 292      public void setRdbSqlClient(SQLClient rdbSqlClient) {
 293          this.rdbSqlClient = rdbSqlClient;
 294      }
 295  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 296 -    public void setExecutor(ThreadPoolExecutor executor) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 297 -        this.executor = executor;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 298 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -</span>
<abbr title=" 300      private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture){"> 300      private void handleQuery(SQLConnection connection, Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;C🔵</abbr>

 301          String key = buildCacheKey(inputParams);
 302          JsonArray params = new JsonArray(Lists.newArrayList(inputParams.values()));
 303          connection.queryWithParams(sideInfo.getSqlCondition(), params, rs -&gt; {
 304              if (rs.failed()) {
 305                  dealFillDataError(input, resultFuture, rs.cause());
 306                  return;
 307              }
 308  
 309              List&lt;JsonArray&gt; cacheContent = Lists.newArrayList();
 310  
 311              int resultSize = rs.result().getResults().size();
 312              if (resultSize &gt; 0) {
 313                  List&lt;CRow&gt; rowList = Lists.newArrayList();

 314  
 315                  for (JsonArray line : rs.result().getResults()) {
 316                      Row row = fillData(input.row(), line);

 317                      if (openCache()) {
 318                          cacheContent.add(line);
 319                      }
 320                      rowList.add(new CRow(row, input.change()));

 321                  }
 322  
 323                  if (openCache()) {
 324                      putCache(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, cacheContent));
 325                  }
 326  
 327                  resultFuture.complete(rowList);
 328              } else {
 329                  dealMissKey(input, resultFuture);
 330                  if (openCache()) {
 331                      putCache(key, CacheMissVal.getMissKeyObj());
 332                  }
 333              }
 334  
 335              // and close the connection
 336              connection.close(done -&gt; {
 337                  if (done.failed()) {
 338                      throw new RuntimeException(done.cause());
 339                  }
 340              });
 341          });
 342      }
 343  
 344      private Map&lt;String, Object&gt; formatInputParam(Map&lt;String, Object&gt; inputParam){
 345          Map&lt;String, Object&gt; result = Maps.newHashMap();
 346          inputParam.forEach((k,v) -&gt; {
 347              result.put(k, convertDataType(v));
 348          });
 349          return result;
 350      }
 351  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            