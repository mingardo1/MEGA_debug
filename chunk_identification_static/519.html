<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>519</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    519
                    <a href="518.html">prev</a>
                    <a href="520.html">next</a>
                    <a href="519_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_02b3a8ca1f9dac40677dcdee2fc88307b99cc15d_src/com/android/launcher3/PagedView.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;02b3a8ca1f9dac40677dcdee2fc88307b99cc15d:src/com/android/launcher3/PagedView.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;02b3a8ca1f9dac40677dcdee2fc88307b99cc15d^1:src/com/android/launcher3/PagedView.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;02b3a8ca1f9dac40677dcdee2fc88307b99cc15d^2:src/com/android/launcher3/PagedView.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;b5da44583957ffe9b0311074eeb77d33e753a9e5:src/com/android/launcher3/PagedView.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[sbj]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2012 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.ObjectAnimator;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.content.Context;
  27 import android.content.res.Resources;
  28 import android.content.res.TypedArray;
  29 import android.graphics.Canvas;
  30 import android.graphics.Matrix;
  31 import android.graphics.PointF;
  32 import android.graphics.Rect;
  33 import android.os.Bundle;
  34 import android.os.Parcel;
  35 import android.os.Parcelable;
  36 import android.util.AttributeSet;
  37 import android.util.DisplayMetrics;
  38 import android.util.Log;
  39 import android.view.InputDevice;
  40 import android.view.KeyEvent;
  41 import android.view.MotionEvent;
  42 import android.view.VelocityTracker;
  43 import android.view.View;
  44 import android.view.ViewConfiguration;
  45 import android.view.ViewGroup;
  46 import android.view.ViewParent;
  47 import android.view.ViewGroup.LayoutParams;
  48 import android.view.accessibility.AccessibilityEvent;
  49 import android.view.accessibility.AccessibilityManager;
  50 import android.view.accessibility.AccessibilityNodeInfo;
  51 import android.view.animation.AnimationUtils;
  52 import android.view.animation.DecelerateInterpolator;
  53 import android.view.animation.Interpolator;
  54 import android.view.animation.LinearInterpolator;
  55 import android.widget.FrameLayout;
  56 import android.widget.Scroller;
  57 
  58 import java.util.ArrayList;
  59 
  60 /**
  61  * An abstraction of the original Workspace which supports browsing through a
  62  * sequential list of &quot;pages&quot;
  63  */
  64 public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
  65     private static final String TAG = &quot;PagedView&quot;;
  66     private static final boolean DEBUG = false;
  67     protected static final int INVALID_PAGE = -1;
  68 
  69     // the min drag distance for a fling to register, to prevent random page shifts
  70     private static final int MIN_LENGTH_FOR_FLING = 25;
  71 
  72     protected static final int PAGE_SNAP_ANIMATION_DURATION = 750;
  73     protected static final int SLOW_PAGE_SNAP_ANIMATION_DURATION = 950;
  74     protected static final float NANOTIME_DIV = 1000000000.0f;
  75 
  76     private static final float OVERSCROLL_ACCELERATE_FACTOR = 2;
  77     private static final float OVERSCROLL_DAMP_FACTOR = 0.14f;
  78 
  79     private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD = 0.33f;
  80     // The page is moved more than halfway, automatically move to the next page on touch up.
  81     private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
  82 
  83     // The following constants need to be scaled based on density. The scaled versions will be
  84     // assigned to the corresponding member variables below.
  85     private static final int FLING_THRESHOLD_VELOCITY = 500;
  86     private static final int MIN_SNAP_VELOCITY = 1500;
  87     private static final int MIN_FLING_VELOCITY = 250;
  88 
  89     // We are disabling touch interaction of the widget region for factory ROM.
  90     private static final boolean DISABLE_TOUCH_INTERACTION = false;
  91     private static final boolean DISABLE_TOUCH_SIDE_PAGES = false;
  92     private static final boolean DISABLE_FLING_TO_DELETE = true;
  93 
  94     static final int AUTOMATIC_PAGE_SPACING = -1;
  95 
  96     protected int mFlingThresholdVelocity;
  97     protected int mMinFlingVelocity;
  98     protected int mMinSnapVelocity;
  99 
 100     protected float mDensity;
 101     protected float mSmoothingTime;
 102     protected float mTouchX;
 103 
 104     protected boolean mFirstLayout = true;
 105 
 106     protected int mCurrentPage;
 107     protected int mChildCountOnLastMeasure;
 108 
 109     protected int mNextPage = INVALID_PAGE;
 110     protected int mMaxScrollX;
 111     protected Scroller mScroller;
 112     private VelocityTracker mVelocityTracker;
 113 
 114     private float mParentDownMotionX;
 115     private float mParentDownMotionY;
 116     private float mDownMotionX;
 117     private float mDownMotionY;
 118     private float mDownScrollX;
 119     protected float mLastMotionX;
 120     protected float mLastMotionXRemainder;
 121     protected float mLastMotionY;
 122     protected float mTotalMotionX;
 123     private int mLastScreenCenter = -1;
 124     private int[] mChildOffsets;
 125     private int[] mChildRelativeOffsets;
 126 
 127     protected final static int TOUCH_STATE_REST = 0;
 128     protected final static int TOUCH_STATE_SCROLLING = 1;
 129     protected final static int TOUCH_STATE_PREV_PAGE = 2;
 130     protected final static int TOUCH_STATE_NEXT_PAGE = 3;
 131     protected final static int TOUCH_STATE_REORDERING = 4;
 132 
 133     protected final static float ALPHA_QUANTIZE_LEVEL = 0.0001f;
 134 
 135     protected int mTouchState = TOUCH_STATE_REST;
 136     protected boolean mForceScreenScrolled = false;
 137 
 138     protected OnLongClickListener mLongClickListener;
 139 
 140     protected int mTouchSlop;
 141     private int mPagingTouchSlop;
 142     private int mMaximumVelocity;
 143     protected int mPageSpacing;
 144     protected int mPageLayoutPaddingTop;
 145     protected int mPageLayoutPaddingBottom;
 146     protected int mPageLayoutPaddingLeft;
 147     protected int mPageLayoutPaddingRight;
 148     protected int mPageLayoutWidthGap;
 149     protected int mPageLayoutHeightGap;
 150     protected int mCellCountX = 0;
 151     protected int mCellCountY = 0;
 152     protected boolean mCenterPagesVertically;
 153     protected boolean mAllowOverScroll = true;
 154     protected int mUnboundedScrollX;
 155     protected int[] mTempVisiblePagesRange = new int[2];
 156     protected boolean mForceDrawAllChildrenNextFrame;
 157 
 158     // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 159     // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 160     // the screens from continuing to translate beyond the normal bounds.
 161     protected int mOverScrollX;
 162 
 163     protected static final int INVALID_POINTER = -1;
 164 
 165     protected int mActivePointerId = INVALID_POINTER;
 166 
 167     private PageSwitchListener mPageSwitchListener;
 168 
 169     protected ArrayList&lt;Boolean&gt; mDirtyPageContent;
 170 
 171     // If true, syncPages and syncPageItems will be called to refresh pages
 172     protected boolean mContentIsRefreshable = true;
 173 
 174     // If true, modify alpha of neighboring pages as user scrolls left/right
 175     protected boolean mFadeInAdjacentScreens = false;
 176 
 177     // It true, use a different slop parameter (pagingTouchSlop = 2 * touchSlop) for deciding
 178     // to switch to a new page
 179     protected boolean mUsePagingTouchSlop = true;
 180 
 181     // If true, the subclass should directly update scrollX itself in its computeScroll method
 182     // (SmoothPagedView does this)
 183     protected boolean mDeferScrollUpdate = false;
 184 
 185     protected boolean mIsPageMoving = false;
 186 
 187     // All syncs and layout passes are deferred until data is ready.
 188     protected boolean mIsDataReady = false;
 189 
 190     protected boolean mAllowLongPress = true;
 191 
 192     // Page Indicator
 193     private int mPageIndicatorViewId;
 194     private PageIndicator mPageIndicator;
 195 
 196     // The viewport whether the pages are to be contained (the actual view may be larger than the
 197     // viewport)
 198     private Rect mViewport = new Rect();
 199 
 200     // Reordering
 201     // We use the min scale to determine how much to expand the actually PagedView measured
 202     // dimensions such that when we are zoomed out, the view is not clipped
 203     private int REORDERING_DROP_REPOSITION_DURATION = 200;
 204     protected int REORDERING_REORDER_REPOSITION_DURATION = 300;
 205     protected int REORDERING_ZOOM_IN_OUT_DURATION = 250;
 206     private int REORDERING_SIDE_PAGE_HOVER_TIMEOUT = 300;
 207     private float REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE = 0.1f;
 208     private long REORDERING_DELETE_DROP_TARGET_FADE_DURATION = 150;
 209     private float mMinScale = 1f;
 210     protected View mDragView;
 211     protected AnimatorSet mZoomInOutAnim;
 212     private Runnable mSidePageHoverRunnable;
 213     private int mSidePageHoverIndex = -1;
 214     // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 215     private boolean mReorderingStarted = false;
 216     // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 217     // animation after endReordering()
 218     private boolean mIsReordering;
 219     // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 220     private int NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT = 2;
 221     private int mPostReorderingPreZoomInRemainingAnimationCount;
 222     private Runnable mPostReorderingPreZoomInRunnable;
 223 
 224     // Edge swiping
 225     private boolean mOnlyAllowEdgeSwipes = false;
 226     private boolean mDownEventOnEdge = false;
 227     private int mEdgeSwipeRegionSize = 0;
 228 
 229     // Convenience/caching
 230     private Matrix mTmpInvMatrix = new Matrix();
 231     private float[] mTmpPoint = new float[2];
 232     private Rect mTmpRect = new Rect();
 233     private Rect mAltTmpRect = new Rect();
 234 
 235     // Fling to delete
 236     private int FLING_TO_DELETE_FADE_OUT_DURATION = 350;
 237     private float FLING_TO_DELETE_FRICTION = 0.035f;
 238     // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 239     private float FLING_TO_DELETE_MAX_FLING_DEGREES = 65f;
 240     protected int mFlingToDeleteThresholdVelocity = -1400;
 241     // Drag to delete
 242     private boolean mDeferringForDelete = false;
 243     private int DELETE_SLIDE_IN_SIDE_PAGE_DURATION = 250;
 244     private int DRAG_TO_DELETE_FADE_OUT_DURATION = 350;
 245 
 246     // Drop to delete
 247     private View mDeleteDropTarget;
 248 
 249     private boolean mAutoComputePageSpacing = false;
 250     private boolean mRecomputePageSpacing = false;
 251 
 252     // Bouncer
 253     private boolean mTopAlignPageWhenShrinkingForBouncer = false;
 254 
 255     public interface PageSwitchListener {
 256         void onPageSwitch(View newPage, int newPageIndex);
 257     }
 258 
 259     public PagedView(Context context) {
 260         this(context, null);
 261     }
 262 
 263     public PagedView(Context context, AttributeSet attrs) {
 264         this(context, attrs, 0);
 265     }
 266 
 267     public PagedView(Context context, AttributeSet attrs, int defStyle) {
 268         super(context, attrs, defStyle);
 269         TypedArray a = context.obtainStyledAttributes(attrs,
 270                 R.styleable.PagedView, defStyle, 0);
 271         setPageSpacing(a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing, 0));
 272         if (mPageSpacing &lt; 0) {
 273             mAutoComputePageSpacing = mRecomputePageSpacing = true;
 274         }
 275         mPageLayoutPaddingTop = a.getDimensionPixelSize(
 276                 R.styleable.PagedView_pageLayoutPaddingTop, 0);
 277         mPageLayoutPaddingBottom = a.getDimensionPixelSize(
 278                 R.styleable.PagedView_pageLayoutPaddingBottom, 0);
 279         mPageLayoutPaddingLeft = a.getDimensionPixelSize(
 280                 R.styleable.PagedView_pageLayoutPaddingLeft, 0);
 281         mPageLayoutPaddingRight = a.getDimensionPixelSize(
 282                 R.styleable.PagedView_pageLayoutPaddingRight, 0);
 283         mPageLayoutWidthGap = a.getDimensionPixelSize(
 284                 R.styleable.PagedView_pageLayoutWidthGap, 0);
 285         mPageLayoutHeightGap = a.getDimensionPixelSize(
 286                 R.styleable.PagedView_pageLayoutHeightGap, 0);
 287         mPageIndicatorViewId = a.getResourceId(R.styleable.PagedView_pageIndicator, -1);
 288         a.recycle();
 289 
 290         setHapticFeedbackEnabled(false);
 291         init();
 292     }
 293 
 294     /**
 295      * Initializes various states for this workspace.
 296      */
 297     protected void init() {
 298         mDirtyPageContent = new ArrayList&lt;Boolean&gt;();
 299         mDirtyPageContent.ensureCapacity(32);
 300         mScroller = new Scroller(getContext(), new ScrollInterpolator());
 301         mCurrentPage = 0;
 302         mCenterPagesVertically = true;
 303 
 304         final ViewConfiguration configuration = ViewConfiguration.get(getContext());
 305         mTouchSlop = configuration.getScaledPagingTouchSlop();
 306         mPagingTouchSlop = configuration.getScaledPagingTouchSlop();
 307         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
 308         mDensity = getResources().getDisplayMetrics().density;
 309 
 310         // Scale the fling-to-delete threshold by the density
 311         mFlingToDeleteThresholdVelocity =
 312                 (int) (mFlingToDeleteThresholdVelocity * mDensity);
 313 
 314         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 315         mMinFlingVelocity = (int) (MIN_FLING_VELOCITY * mDensity);
 316         mMinSnapVelocity = (int) (MIN_SNAP_VELOCITY * mDensity);
 317         setOnHierarchyChangeListener(this);
 318     }
 319 
 320     protected void onAttachedToWindow() {
 321         // Hook up the page indicator
 322         ViewGroup parent = (ViewGroup) getParent();
 323         if (mPageIndicator == null &amp;&amp; mPageIndicatorViewId &gt; -1) {
 324             mPageIndicator = (PageIndicator) parent.findViewById(mPageIndicatorViewId);
 325             mPageIndicator.removeAllMarkers();
 326             mPageIndicator.addMarkers(getChildCount());
 327         }
 328     }
 329 
 330     protected void onDetachedFromWindow() {
 331         // Unhook the page indicator
 332         mPageIndicator = null;
 333     }
 334 
 335     void setDeleteDropTarget(View v) {
 336         mDeleteDropTarget = v;
 337     }
 338 
 339     // Convenience methods to map points from self to parent and vice versa
 340     float[] mapPointFromViewToParent(View v, float x, float y) {
 341         mTmpPoint[0] = x;
 342         mTmpPoint[1] = y;
 343         v.getMatrix().mapPoints(mTmpPoint);
 344         mTmpPoint[0] += v.getLeft();
 345         mTmpPoint[1] += v.getTop();
 346         return mTmpPoint;
 347     }
 348     float[] mapPointFromParentToView(View v, float x, float y) {
 349         mTmpPoint[0] = x - v.getLeft();
 350         mTmpPoint[1] = y - v.getTop();
 351         v.getMatrix().invert(mTmpInvMatrix);
 352         mTmpInvMatrix.mapPoints(mTmpPoint);
 353         return mTmpPoint;
 354     }
 355 
 356     void updateDragViewTranslationDuringDrag() {
 357         float x = mLastMotionX - mDownMotionX + getScrollX() - mDownScrollX;
 358         float y = mLastMotionY - mDownMotionY;
 359         mDragView.setTranslationX(x);
 360         mDragView.setTranslationY(y);
 361 
 362         if (DEBUG) Log.d(TAG, &quot;PagedView.updateDragViewTranslationDuringDrag(): &quot; + x + &quot;, &quot; + y);
 363     }
 364 
 365     public void setMinScale(float f) {
 366         mMinScale = f;
 367         requestLayout();
 368     }
 369 
 370     @Override
 371     public void setScaleX(float scaleX) {
 372         super.setScaleX(scaleX);
 373         if (isReordering(true)) {
 374             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 375             mLastMotionX = p[0];
 376             mLastMotionY = p[1];
 377             updateDragViewTranslationDuringDrag();
 378         }
 379     }
 380 
 381     // Convenience methods to get the actual width/height of the PagedView (since it is measured
 382     // to be larger to account for the minimum possible scale)
 383     int getViewportWidth() {
 384         return mViewport.width();
 385     }
 386     int getViewportHeight() {
 387         return mViewport.height();
 388     }
 389 
 390     // Convenience methods to get the offset ASSUMING that we are centering the pages in the
 391     // PagedView both horizontally and vertically
 392     int getViewportOffsetX() {
 393         return (getMeasuredWidth() - getViewportWidth()) / 2;
 394     }
 395 
 396     int getViewportOffsetY() {
 397         return (getMeasuredHeight() - getViewportHeight()) / 2;
 398     }
 399 
 400     public void setPageSwitchListener(PageSwitchListener pageSwitchListener) {
 401         mPageSwitchListener = pageSwitchListener;
 402         if (mPageSwitchListener != null) {
 403             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 404         }
 405     }
 406 
 407     /**
 408      * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.
 409      */
 410     public boolean isLayoutRtl() {
 411         return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
 412     }
 413 
 414     /**
 415      * Called by subclasses to mark that data is ready, and that we can begin loading and laying
 416      * out pages.
 417      */
 418     protected void setDataIsReady() {
 419         mIsDataReady = true;
 420     }
 421 
 422     protected boolean isDataReady() {
 423         return mIsDataReady;
 424     }
 425 
 426     /**
 427      * Returns the index of the currently displayed page.
 428      *
 429      * @return The index of the currently displayed page.
 430      */
 431     int getCurrentPage() {
 432         return mCurrentPage;
 433     }
 434 
 435     int getNextPage() {
 436         return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
 437     }
 438 
 439     int getPageCount() {
 440         return getChildCount();
 441     }
 442 
 443     View getPageAt(int index) {
 444         return getChildAt(index);
 445     }
 446 
 447     protected int indexToPage(int index) {
 448         return index;
 449     }
 450 
 451     /**
 452      * Updates the scroll of the current page immediately to its final scroll position.  We use this
 453      * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of
 454      * the previous tab page.
 455      */
 456     protected void updateCurrentPageScroll() {
 457         // If the current page is invalid, just reset the scroll position to zero
 458         int newX = 0;
 459         if (0 &lt;= mCurrentPage &amp;&amp; mCurrentPage &lt; getPageCount()) {
 460             int offset = getChildOffset(mCurrentPage);
 461             int relOffset = getRelativeChildOffset(mCurrentPage);
 462             newX = offset - relOffset;
 463         }
 464         scrollTo(newX, 0);
 465         mScroller.setFinalX(newX);
 466         mScroller.forceFinished(true);
 467     }
 468 
 469     /**
 470      * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation
 471      * ends, {@link #resumeScrolling()} should be called, along with
 472      * {@link #updateCurrentPageScroll()} to correctly set the final state and re-enable scrolling.
 473      */
 474     void pauseScrolling() {
 475         mScroller.forceFinished(true);
 476     }
 477 
 478     /**
 479      * Enables scrolling again.
 480      * @see #pauseScrolling()
 481      */
 482     void resumeScrolling() {
 483     }
 484     /**
 485      * Sets the current page.
 486      */
 487     void setCurrentPage(int currentPage) {
 488         if (!mScroller.isFinished()) {
 489             mScroller.abortAnimation();
 490         }
 491         // don&#x27;t introduce any checks like mCurrentPage == currentPage here-- if we change the
 492         // the default
 493         if (getChildCount() == 0) {
 494             return;
 495         }
 496 
 497         mForceScreenScrolled = true;
 498         mCurrentPage = Math.max(0, Math.min(currentPage, getPageCount() - 1));
 499         notifyPageSwitchListener();
 500         invalidate();
 501     }
 502 
 503     protected void notifyPageSwitchListener() {
 504         if (mPageSwitchListener != null) {
 505             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 506         }
 507 
 508         // Update the page indicator (when we aren&#x27;t reordering)
 509         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 510             mPageIndicator.setActiveMarker(getNextPage());
 511         }
 512     }
 513     protected void pageBeginMoving() {
 514         if (!mIsPageMoving) {
 515             mIsPageMoving = true;
 516             onPageBeginMoving();
 517         }
 518     }
 519 
 520     protected void pageEndMoving() {
 521         if (mIsPageMoving) {
 522             mIsPageMoving = false;
 523             onPageEndMoving();
 524         }
 525     }
 526 
 527     protected boolean isPageMoving() {
 528         return mIsPageMoving;
 529     }
 530 
 531     // a method that subclasses can override to add behavior
 532     protected void onPageBeginMoving() {
 533     }
 534 
 535     // a method that subclasses can override to add behavior
 536     protected void onPageEndMoving() {
 537     }
 538 
 539     /**
 540      * Registers the specified listener on each page contained in this workspace.
 541      *
 542      * @param l The listener used to respond to long clicks.
 543      */
 544     @Override
 545     public void setOnLongClickListener(OnLongClickListener l) {
 546         mLongClickListener = l;
 547         final int count = getPageCount();
 548         for (int i = 0; i &lt; count; i++) {
 549             getPageAt(i).setOnLongClickListener(l);
 550         }
 551     }
 552 
 553     @Override
 554     public void scrollBy(int x, int y) {
 555         scrollTo(mUnboundedScrollX + x, getScrollY() + y);
 556     }
 557 
 558     @Override
 559     public void scrollTo(int x, int y) {
 560         final boolean isRtl = isLayoutRtl();
 561         mUnboundedScrollX = x;
 562 
 563         boolean isXBeforeFirstPage = isRtl ? (x &gt; mMaxScrollX) : (x &lt; 0);
 564         boolean isXAfterLastPage = isRtl ? (x &lt; 0) : (x &gt; mMaxScrollX);
 565         if (isXBeforeFirstPage) {
 566             super.scrollTo(0, y);
 567             if (mAllowOverScroll) {
 568                 if (isRtl) {
 569                     overScroll(x - mMaxScrollX);
 570                 } else {
 571                     overScroll(x);
 572                 }
 573             }
 574         } else if (isXAfterLastPage) {
 575             super.scrollTo(mMaxScrollX, y);
 576             if (mAllowOverScroll) {
 577                 if (isRtl) {
 578                     overScroll(x);
 579                 } else {
 580                     overScroll(x - mMaxScrollX);
 581                 }
 582             }
 583         } else {
 584             mOverScrollX = x;
 585             super.scrollTo(x, y);
 586         }
 587 
 588         mTouchX = x;
 589         mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
 590 
 591         // Update the last motion events when scrolling
 592         if (isReordering(true)) {
 593             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 594             mLastMotionX = p[0];
 595             mLastMotionY = p[1];
 596             updateDragViewTranslationDuringDrag();
 597         }
 598     }
 599 
 600     // we moved this functionality to a helper function so SmoothPagedView can reuse it
 601     protected boolean computeScrollHelper() {
 602         if (mScroller.computeScrollOffset()) {
 603             // Don&#x27;t bother scrolling if the page does not need to be moved
 604             if (getScrollX() != mScroller.getCurrX()
 605                 || getScrollY() != mScroller.getCurrY()
 606                 || mOverScrollX != mScroller.getCurrX()) {
 607                 scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
 608             }
 609             invalidate();
 610             return true;
 611         } else if (mNextPage != INVALID_PAGE) {
 612             mCurrentPage = Math.max(0, Math.min(mNextPage, getPageCount() - 1));
 613             mNextPage = INVALID_PAGE;
 614             notifyPageSwitchListener();
 615 
 616             // We don&#x27;t want to trigger a page end moving unless the page has settled
 617             // and the user has stopped scrolling
 618             if (mTouchState == TOUCH_STATE_REST) {
 619                 pageEndMoving();
 620             }
 621 
 622             onPostReorderingAnimationCompleted();
 623             // Notify the user when the page changes
 624             AccessibilityManager accessibilityManager = (AccessibilityManager)
 625                     getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
 626             if (accessibilityManager.isEnabled()) {
 627                 AccessibilityEvent ev =
 628                     AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
 629                 ev.getText().add(getCurrentPageDescription());
 630                 sendAccessibilityEventUnchecked(ev);
 631             }
 632             return true;
 633         }
 634         return false;
 635     }
 636 
 637     @Override
 638     public void computeScroll() {
 639         computeScrollHelper();
 640     }
 641 
 642     protected boolean shouldSetTopAlignedPivotForWidget(int childIndex) {
 643         return mTopAlignPageWhenShrinkingForBouncer;
 644     }
 645 
 646     public static class LayoutParams extends ViewGroup.LayoutParams {
 647         public boolean isFullScreenPage = false;
 648 
 649         /**
 650          * {@inheritDoc}
 651          */
 652         public LayoutParams(int width, int height) {
 653             super(width, height);
 654         }
 655 
 656         public LayoutParams(ViewGroup.LayoutParams source) {
 657             super(source);
 658         }
 659     }
 660 
 661     protected LayoutParams generateDefaultLayoutParams() {
 662         return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
 663     }
 664 
 665     public void addFullScreenPage(View page, int width, int height) {
 666         LayoutParams lp = generateDefaultLayoutParams();
 667         lp.isFullScreenPage = true;
 668         super.addView(page, 0, lp);
 669     }
 670 
 671     @Override
 672     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 673         if (!mIsDataReady || getChildCount() == 0) {
 674             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 675             return;
 676         }
 677 
 678         // We measure the dimensions of the PagedView to be larger than the pages so that when we
 679         // zoom out (and scale down), the view is still contained in the parent
 680         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
 681         int widthSize = MeasureSpec.getSize(widthMeasureSpec);
 682         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
 683         int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 684         // NOTE: We multiply by 1.5f to account for the fact that depending on the offset of the
 685         // viewport, we can be at most one and a half screens offset once we scale down
 686         DisplayMetrics dm = getResources().getDisplayMetrics();
 687         int maxSize = Math.max(dm.widthPixels, dm.heightPixels);
 688         int parentWidthSize = (int) (1.5f * maxSize);
 689         int parentHeightSize = maxSize;
 690         int scaledWidthSize = (int) (parentWidthSize / mMinScale);
 691         int scaledHeightSize = (int) (parentHeightSize / mMinScale);
 692         mViewport.set(0, 0, widthSize, heightSize);
 693 
 694         if (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {
 695             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 696             return;
 697         }
 698 
 699         // Return early if we aren&#x27;t given a proper dimension
 700         if (widthSize &lt;= 0 || heightSize &lt;= 0) {
 701             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 702             return;
 703         }
 704 
 705         /* Allow the height to be set as WRAP_CONTENT. This allows the particular case
 706          * of the All apps view on XLarge displays to not take up more space then it needs. Width
 707          * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect
 708          * each page to have the same width.
 709          */
 710         final int verticalPadding = getPaddingTop() + getPaddingBottom();
 711         final int horizontalPadding = getPaddingLeft() + getPaddingRight();
 712 
 713         // The children are given the same width and height as the workspace
 714         // unless they were set to WRAP_CONTENT
 715         if (DEBUG) Log.d(TAG, &quot;PagedView.onMeasure(): &quot; + widthSize + &quot;, &quot; + heightSize);
 716         if (DEBUG) Log.d(TAG, &quot;PagedView.scaledSize: &quot; + scaledWidthSize + &quot;, &quot; + scaledHeightSize);
 717         if (DEBUG) Log.d(TAG, &quot;PagedView.parentSize: &quot; + parentWidthSize + &quot;, &quot; + parentHeightSize);
 718         if (DEBUG) Log.d(TAG, &quot;PagedView.horizontalPadding: &quot; + horizontalPadding);
 719         if (DEBUG) Log.d(TAG, &quot;PagedView.verticalPadding: &quot; + verticalPadding);
 720         final int childCount = getChildCount();
 721         for (int i = 0; i &lt; childCount; i++) {
 722             // disallowing padding in paged view (just pass 0)
 723             final View child = getPageAt(i);
 724             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 725 
 726             int childWidthMode;
 727             int childHeightMode;
 728             int childWidth;
 729             int childHeight;
 730 
 731             if (!lp.isFullScreenPage) {
 732                 if (lp.width == LayoutParams.WRAP_CONTENT) {
 733                     childWidthMode = MeasureSpec.AT_MOST;
 734                 } else {
 735                     childWidthMode = MeasureSpec.EXACTLY;
 736                 }
 737 
 738                 if (lp.height == LayoutParams.WRAP_CONTENT) {
 739                     childHeightMode = MeasureSpec.AT_MOST;
 740                 } else {
 741                     childHeightMode = MeasureSpec.EXACTLY;
 742                 }
 743 
 744                 childWidth = widthSize - horizontalPadding;
 745                 childHeight = heightSize - verticalPadding;
 746 
 747             } else {
 748                 childWidthMode = MeasureSpec.EXACTLY;
 749                 childHeightMode = MeasureSpec.EXACTLY;
 750 
 751                 childWidth = getViewportWidth();
 752                 childHeight = getViewportHeight();
 753             }
 754 
 755             final int childWidthMeasureSpec =
 756                     MeasureSpec.makeMeasureSpec(childWidth, childWidthMode);
 757                 final int childHeightMeasureSpec =
 758                     MeasureSpec.makeMeasureSpec(childHeight, childHeightMode);
 759             child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 760         }
 761         setMeasuredDimension(scaledWidthSize, scaledHeightSize);
 762 
 763         // We can&#x27;t call getChildOffset/getRelativeChildOffset until we set the measured dimensions.
 764         // We also wait until we set the measured dimensions before flushing the cache as well, to
 765         // ensure that the cache is filled with good values.
 766         invalidateCachedOffsets();
 767 
 768         if (childCount &gt; 0) {
 769             if (DEBUG) Log.d(TAG, &quot;getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
 770                     + getChildWidth(0));
 771 
 772             // Calculate the variable page spacing if necessary
 773             if (mAutoComputePageSpacing &amp;&amp; mRecomputePageSpacing) {
 774                 // The gap between pages in the PagedView should be equal to the gap from the page
 775                 // to the edge of the screen (so it is not visible in the current screen).  To
 776                 // account for unequal padding on each side of the paged view, we take the maximum
 777                 // of the left/right gap and use that as the gap between each page.
 778                 int offset = getRelativeChildOffset(0);
 779                 int spacing = Math.max(offset, widthSize - offset -
 780                         getChildAt(0).getMeasuredWidth());
 781                 setPageSpacing(spacing);
 782                 mRecomputePageSpacing = false;
 783             }
 784         }
 785 
 786 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 787 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 788             final int index = isLayoutRtl() ? 0 : childCount - 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 789             mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 790         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 791             mMaxScrollX = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 792         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 793     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 794 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 795     public void setPageSpacing(int pageSpacing) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 796         mPageSpacing = pageSpacing;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 797         invalidateCachedOffsets();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 798     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 799 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 800     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 801     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 802         if (!mIsDataReady || getChildCount() == 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 803             return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 804         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 805 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 806         if (DEBUG) Log.d(TAG, &quot;PagedView.onLayout()&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 807         final int childCount = getChildCount();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 808 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 809         int offsetX = getViewportOffsetX();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 810         int offsetY = getViewportOffsetY();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 811 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 812         // Update the viewport offsets</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 813         mViewport.offset(offsetX,  offsetY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 814 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 815         final boolean isRtl = isLayoutRtl();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 816 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 817         final int startIndex = isRtl ? childCount - 1 : 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 818         final int endIndex = isRtl ? -1 : childCount;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 819         final int delta = isRtl ? -1 : 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 820 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 821         int verticalPadding = getPaddingTop() + getPaddingBottom();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 822         int childLeft = offsetX + getRelativeChildOffset(startIndex);</span>
 823 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 824         if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 825                 !mDeferringForDelete) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 826             setCurrentPage(getNextPage());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 827         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 828         mChildCountOnLastMeasure = getChildCount();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 829 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 830         updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 831 </span>
 832 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 833         if (childCount &gt; 0) {
 834             final int index = isLayoutRtl() ? 0 : childCount - 1;
 835             mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);
 836         } else {
 837             mMaxScrollX = 0;
 838         }
 839     }
 840 
 841     public void setPageSpacing(int pageSpacing) {
 842         mPageSpacing = pageSpacing;
 843         invalidateCachedOffsets();
 844     }
 845 
 846     @Override
 847     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 848         if (!mIsDataReady || getChildCount() == 0) {
 849             return;
 850         }
 851 
 852         if (DEBUG) Log.d(TAG, &quot;PagedView.onLayout()&quot;);
 853         final int childCount = getChildCount();
 854 
 855         int offsetX = getViewportOffsetX();
 856         int offsetY = getViewportOffsetY();
 857 
 858         // Update the viewport offsets
 859         mViewport.offset(offsetX,  offsetY);
 860 
 861         final boolean isRtl = isLayoutRtl();
 862 
 863         final int startIndex = isRtl ? childCount - 1 : 0;
 864         final int endIndex = isRtl ? -1 : childCount;
 865         final int delta = isRtl ? -1 : 1;
 866 
 867         int verticalPadding = getPaddingTop() + getPaddingBottom();
 868         int childLeft = offsetX + getRelativeChildOffset(startIndex);
 869         for (int i = startIndex; i != endIndex; i += delta) {
 870             final View child = getPageAt(i);
 871             LayoutParams lp = (LayoutParams) child.getLayoutParams();
 872             int childTop;
 873 
 874             if (lp.isFullScreenPage) {
 875                 childTop = offsetY;
 876             } else {
 877                 childTop = offsetY + getPaddingTop();
 878                 if (mCenterPagesVertically) {
<abbr title=" 879                     childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;"> 879                     childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2🔵</abbr>
 880                 }
 881             }
 882 
 883             if (child.getVisibility() != View.GONE) {
 884                 final int childWidth = child.getMeasuredWidth();
 885                 final int childHeight = child.getMeasuredHeight();
 886 
 887                 if (DEBUG) Log.d(TAG, &quot;\tlayout-child&quot; + i + &quot;: &quot; + childLeft + &quot;, &quot; + childTop);
 888                 child.layout(childLeft, childTop,
 889                         childLeft + child.getMeasuredWidth(), childTop + childHeight);
 890                 childLeft += childWidth + mPageSpacing;
 891             }
 892         }
 893 
 894         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
 895             setHorizontalScrollBarEnabled(false);
 896             updateCurrentPageScroll();
 897             setHorizontalScrollBarEnabled(true);
 898             mFirstLayout = false;
 899         }
 900     }
 901 
 902     protected void screenScrolled(int screenCenter) {
 903         boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
 904 
 905         if (mFadeInAdjacentScreens &amp;&amp; !isInOverscroll) {
 906             for (int i = 0; i &lt; getChildCount(); i++) {
 907                 View child = getChildAt(i);
 908                 if (child != null) {
 909                     float scrollProgress = getScrollProgress(screenCenter, child, i);
 910                     float alpha = 1 - Math.abs(scrollProgress);
 911                     child.setAlpha(alpha);
 912                 }
 913             }
 914             invalidate();
 915         }
 916     }
 917 
 918     @Override
 919     public void onChildViewAdded(View parent, View child) {
 920         // Update the page indicator, we don&#x27;t update the page indicator as we
 921         // add/remove pages
 922         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 923             mPageIndicator.addMarker(indexOfChild(child));
 924         }
 925 
 926         // This ensures that when children are added, they get the correct transforms / alphas
 927         // in accordance with any scroll effects.
 928         mForceScreenScrolled = true;
 929         mRecomputePageSpacing = true;
 930 
 931         invalidate();
 932         invalidateCachedOffsets();
 933     }
 934 
 935     @Override
 936     public void onChildViewRemoved(View parent, View child) {
 937         mForceScreenScrolled = true;
 938         invalidate();
 939         invalidateCachedOffsets();
 940     }
 941 
 942     private void removeMarkerForView(int index) {
 943         // Update the page indicator, we don&#x27;t update the page indicator as we
 944         // add/remove pages
 945         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 946             mPageIndicator.removeMarker(index);
 947         }
 948     }
 949 
 950     @Override
 951     public void removeView(View v) {
 952         // XXX: We should find a better way to hook into this before the view
 953         // gets removed form its parent...
 954         removeMarkerForView(indexOfChild(v));
 955         super.removeView(v);
 956     }
 957     @Override
 958     public void removeViewInLayout(View v) {
 959         // XXX: We should find a better way to hook into this before the view
 960         // gets removed form its parent...
 961         removeMarkerForView(indexOfChild(v));
 962         super.removeViewInLayout(v);
 963     }
 964     @Override
 965     public void removeViewAt(int index) {
 966         // XXX: We should find a better way to hook into this before the view
 967         // gets removed form its parent...
 968         removeViewAt(index);
 969         super.removeViewAt(index);
 970     }
 971     @Override
 972     public void removeAllViewsInLayout() {
 973         // Update the page indicator, we don&#x27;t update the page indicator as we
 974         // add/remove pages
 975         if (mPageIndicator != null) {
 976             mPageIndicator.removeAllMarkers();
 977         }
 978 
 979         super.removeAllViewsInLayout();
 980     }
 981 
 982     protected void invalidateCachedOffsets() {
 983         int count = getChildCount();
 984         if (count == 0) {
 985             mChildOffsets = null;
 986             mChildRelativeOffsets = null;
 987             return;
 988         }
 989 
 990         mChildOffsets = new int[count];
 991         mChildRelativeOffsets = new int[count];
 992         for (int i = 0; i &lt; count; i++) {
 993             mChildOffsets[i] = -1;
 994             mChildRelativeOffsets[i] = -1;
 995         }
 996     }
 997 
 998     protected int getChildOffset(int index) {
 999         if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
1000 
1001         final boolean isRtl = isLayoutRtl();
1002         int[] childOffsets = mChildOffsets;
1003 
1004         if (childOffsets != null &amp;&amp; childOffsets[index] != -1) {
1005             return childOffsets[index];
1006         } else {
1007             if (getChildCount() == 0)
1008                 return 0;
1009 
1010             final int startIndex = isRtl ? getChildCount() - 1 : 0;
1011             final int endIndex = isRtl ? index : index;
1012             final int delta = isRtl ? -1 : 1;
1013 
1014             int offset = getRelativeChildOffset(startIndex);
1015             for (int i = startIndex; i != endIndex; i += delta) {
1016                 offset += getPageAt(i).getMeasuredWidth() + mPageSpacing;
1017             }
1018             if (childOffsets != null) {
1019                 childOffsets[index] = offset;
1020             }
1021             return offset;
1022         }
1023 
1024     }
1025 
1026     protected int getRelativeChildOffset(int index) {
1027         if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
1028 
1029         if (mChildRelativeOffsets != null &amp;&amp; mChildRelativeOffsets[index] != -1) {
1030             return mChildRelativeOffsets[index];
1031         } else {
1032             final int padding = getPaddingLeft() + getPaddingRight();
1033             final int offset = getPaddingLeft() +
1034                     (getViewportWidth() - padding - getChildWidth(index)) / 2;
1035             if (mChildRelativeOffsets != null) {
1036                 mChildRelativeOffsets[index] = offset;
1037             }
1038             return offset;
1039         }
1040     }
1041 
1042     void boundByReorderablePages(boolean isReordering, int[] range) {
1043         // Do nothing
1044     }
1045 
1046     // TODO: Fix this
1047     protected void getVisiblePages(int[] range) {
1048         range[0] = 0;
1049         range[1] = getPageCount() - 1;
1050 
1051         /*
1052         final int pageCount = getChildCount();
1053 
1054         if (pageCount &gt; 0) {
1055             final int screenWidth = getViewportWidth();
1056             int leftScreen = 0;
1057             int rightScreen = 0;
1058             int offsetX = getViewportOffsetX() + getScrollX();
1059             View currPage = getPageAt(leftScreen);
1060             while (leftScreen &lt; pageCount - 1 &amp;&amp;
1061                     currPage.getX() + currPage.getWidth() -
1062                     currPage.getPaddingRight() &lt; offsetX) {
1063                 leftScreen++;
1064                 currPage = getPageAt(leftScreen);
1065             }
1066             rightScreen = leftScreen;
1067             currPage = getPageAt(rightScreen + 1);
1068             while (rightScreen &lt; pageCount - 1 &amp;&amp;
1069                     currPage.getX() - currPage.getPaddingLeft() &lt; offsetX + screenWidth) {
1070                 rightScreen++;
1071                 currPage = getPageAt(rightScreen + 1);
1072             }
1073 
1074             // TEMP: this is a hacky way to ensure that animations to new pages are not clipped
1075             // because we don&#x27;t draw them while scrolling?
1076             range[0] = Math.max(0, leftScreen - 1);
1077             range[1] = Math.min(rightScreen + 1, getChildCount() - 1);
1078         } else {
1079             range[0] = -1;
1080             range[1] = -1;
1081         }
1082         */
1083     }
1084 
1085     protected boolean shouldDrawChild(View child) {
1086         return child.getAlpha() &gt; 0;
1087     }
1088 
1089     @Override
1090     protected void dispatchDraw(Canvas canvas) {
1091         int halfScreenSize = getViewportWidth() / 2;
1092         // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range.
1093         // Otherwise it is equal to the scaled overscroll position.
1094         int screenCenter = mOverScrollX + halfScreenSize;
1095 
1096         if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
1097             // set mForceScreenScrolled before calling screenScrolled so that screenScrolled can
1098             // set it for the next frame
1099             mForceScreenScrolled = false;
1100             screenScrolled(screenCenter);
1101             mLastScreenCenter = screenCenter;
1102         }
1103 
1104         // Find out which screens are visible; as an optimization we only call draw on them
1105         final int pageCount = getChildCount();
1106         if (pageCount &gt; 0) {
1107             getVisiblePages(mTempVisiblePagesRange);
1108             final int leftScreen = mTempVisiblePagesRange[0];
1109             final int rightScreen = mTempVisiblePagesRange[1];
1110             if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1111                 final long drawingTime = getDrawingTime();
1112                 // Clip to the bounds
1113                 canvas.save();
1114                 canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
1115                         getScrollY() + getBottom() - getTop());
1116 
1117                 // Draw all the children, leaving the drag view for last
1118                 for (int i = pageCount - 1; i &gt;= 0; i--) {
1119                     final View v = getPageAt(i);
1120                     if (v == mDragView) continue;
1121                     if (mForceDrawAllChildrenNextFrame ||
1122                                (leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(v))) {
1123                         drawChild(canvas, v, drawingTime);
1124                     }
1125                 }
1126                 // Draw the drag view on top (if there is one)
1127                 if (mDragView != null) {
1128                     drawChild(canvas, mDragView, drawingTime);
1129                 }
1130 
1131                 mForceDrawAllChildrenNextFrame = false;
1132                 canvas.restore();
1133             }
1134         }
1135     }
1136 
1137     @Override
1138     public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
1139         int page = indexToPage(indexOfChild(child));
1140         if (page != mCurrentPage || !mScroller.isFinished()) {
1141             snapToPage(page);
1142             return true;
1143         }
1144         return false;
1145     }
1146 
1147     @Override
1148     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1149         int focusablePage;
1150         if (mNextPage != INVALID_PAGE) {
1151             focusablePage = mNextPage;
1152         } else {
1153             focusablePage = mCurrentPage;
1154         }
1155         View v = getPageAt(focusablePage);
1156         if (v != null) {
1157             return v.requestFocus(direction, previouslyFocusedRect);
1158         }
1159         return false;
1160     }
1161 
1162     @Override
1163     public boolean dispatchUnhandledMove(View focused, int direction) {
1164         // XXX-RTL: This will be fixed in a future CL
1165         if (direction == View.FOCUS_LEFT) {
1166             if (getCurrentPage() &gt; 0) {
1167                 snapToPage(getCurrentPage() - 1);
1168                 return true;
1169             }
1170         } else if (direction == View.FOCUS_RIGHT) {
1171             if (getCurrentPage() &lt; getPageCount() - 1) {
1172                 snapToPage(getCurrentPage() + 1);
1173                 return true;
1174             }
1175         }
1176         return super.dispatchUnhandledMove(focused, direction);
1177     }
1178 
1179     @Override
1180     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1181         // XXX-RTL: This will be fixed in a future CL
1182         if (mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getPageCount()) {
1183             getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
1184         }
1185         if (direction == View.FOCUS_LEFT) {
1186             if (mCurrentPage &gt; 0) {
1187                 getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
1188             }
1189         } else if (direction == View.FOCUS_RIGHT){
1190             if (mCurrentPage &lt; getPageCount() - 1) {
1191                 getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
1192             }
1193         }
1194     }
1195 
1196     /**
1197      * If one of our descendant views decides that it could be focused now, only
1198      * pass that along if it&#x27;s on the current page.
1199      *
1200      * This happens when live folders requery, and if they&#x27;re off page, they
1201      * end up calling requestFocus, which pulls it on page.
1202      */
1203     @Override
1204     public void focusableViewAvailable(View focused) {
1205         View current = getPageAt(mCurrentPage);
1206         View v = focused;
1207         while (true) {
1208             if (v == current) {
1209                 super.focusableViewAvailable(focused);
1210                 return;
1211             }
1212             if (v == this) {
1213                 return;
1214             }
1215             ViewParent parent = v.getParent();
1216             if (parent instanceof View) {
1217                 v = (View)v.getParent();
1218             } else {
1219                 return;
1220             }
1221         }
1222     }
1223 
1224     /**
1225      * {@inheritDoc}
1226      */
1227     @Override
1228     public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
1229         if (disallowIntercept) {
1230             // We need to make sure to cancel our long press if
1231             // a scrollable widget takes over touch events
1232             final View currentPage = getPageAt(mCurrentPage);
1233             currentPage.cancelLongPress();
1234         }
1235         super.requestDisallowInterceptTouchEvent(disallowIntercept);
1236     }
1237 
1238     /**
1239      * Return true if a tap at (x, y) should trigger a flip to the previous page.
1240      */
1241     protected boolean hitsPreviousPage(float x, float y) {
1242         if (isLayoutRtl()) {
1243             return (x &gt; (getViewportOffsetX() + getViewportWidth() -
1244                     getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1245         }
1246         return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1247     }
1248 
1249     /**
1250      * Return true if a tap at (x, y) should trigger a flip to the next page.
1251      */
1252     protected boolean hitsNextPage(float x, float y) {
1253         if (isLayoutRtl()) {
1254             return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1255         }
1256         return  (x &gt; (getViewportOffsetX() + getViewportWidth() -
1257                 getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1258     }
1259 
1260     /** Returns whether x and y originated within the buffered viewport */
1261     private boolean isTouchPointInViewportWithBuffer(int x, int y) {
1262         mTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top,
1263                 mViewport.right + mViewport.width() / 2, mViewport.bottom);
1264         return mTmpRect.contains(x, y);
1265     }
1266 
1267     /** Returns whether x and y originated within the current page view bounds */
1268     private boolean isTouchPointInCurrentPage(int x, int y) {
1269         View v = getPageAt(getCurrentPage());
1270         if (v != null) {
1271             mTmpRect.set((v.getLeft() - getScrollX()), 0, (v.getRight() - getScrollX()),
1272                     v.getBottom());
1273             return mTmpRect.contains(x, y);
1274         }
1275         return false;
1276     }
1277 
1278     @Override
1279     public boolean onInterceptTouchEvent(MotionEvent ev) {
1280         if (DISABLE_TOUCH_INTERACTION) {
1281             return false;
1282         }
1283 
1284         /*
1285          * This method JUST determines whether we want to intercept the motion.
1286          * If we return true, onTouchEvent will be called and we do the actual
1287          * scrolling there.
1288          */
1289         acquireVelocityTrackerAndAddMovement(ev);
1290 
1291         // Skip touch handling if there are no pages to swipe
1292         if (getChildCount() &lt;= 0) return super.onInterceptTouchEvent(ev);
1293 
1294         /*
1295          * Shortcut the most recurring case: the user is in the dragging
1296          * state and he is moving his finger.  We want to intercept this
1297          * motion.
1298          */
1299         final int action = ev.getAction();
1300         if ((action == MotionEvent.ACTION_MOVE) &amp;&amp;
1301                 (mTouchState == TOUCH_STATE_SCROLLING)) {
1302             return true;
1303         }
1304 
1305         switch (action &amp; MotionEvent.ACTION_MASK) {
1306             case MotionEvent.ACTION_MOVE: {
1307                 /*
1308                  * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
1309                  * whether the user has moved far enough from his original down touch.
1310                  */
1311                 if (mActivePointerId != INVALID_POINTER) {
1312                     determineScrollingStart(ev);
1313                     break;
1314                 }
1315                 // if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN
1316                 // event. in that case, treat the first occurence of a move event as a ACTION_DOWN
1317                 // i.e. fall through to the next case (don&#x27;t break)
1318                 // (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events
1319                 // while it&#x27;s small- this was causing a crash before we checked for INVALID_POINTER)
1320             }
1321 
1322             case MotionEvent.ACTION_DOWN: {
1323                 final float x = ev.getX();
1324                 final float y = ev.getY();
1325                 // Remember location of down touch
1326                 mDownMotionX = x;
1327                 mDownMotionY = y;
1328                 mDownScrollX = getScrollX();
1329                 mLastMotionX = x;
1330                 mLastMotionY = y;
1331                 float[] p = mapPointFromViewToParent(this, x, y);
1332                 mParentDownMotionX = p[0];
1333                 mParentDownMotionY = p[1];
1334                 mLastMotionXRemainder = 0;
1335                 mTotalMotionX = 0;
1336                 mActivePointerId = ev.getPointerId(0);
1337 
1338                 // Determine if the down event is within the threshold to be an edge swipe
1339                 int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1340                 int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1341                 if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1342                     mDownEventOnEdge = true;
1343                 }
1344 
1345                 /*
1346                  * If being flinged and user touches the screen, initiate drag;
1347                  * otherwise don&#x27;t.  mScroller.isFinished should be false when
1348                  * being flinged.
1349                  */
1350                 final int xDist = Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
1351                 final boolean finishedScrolling = (mScroller.isFinished() || xDist &lt; mTouchSlop);
1352                 if (finishedScrolling) {
1353                     mTouchState = TOUCH_STATE_REST;
1354                     mScroller.abortAnimation();
1355                 } else {
1356                     if (isTouchPointInViewportWithBuffer((int) mDownMotionX, (int) mDownMotionY)) {
1357                         mTouchState = TOUCH_STATE_SCROLLING;
1358                     } else {
1359                         mTouchState = TOUCH_STATE_REST;
1360                     }
1361                 }
1362 
1363                 // check if this can be the beginning of a tap on the side of the pages
1364                 // to scroll the current page
1365                 if (!DISABLE_TOUCH_SIDE_PAGES) {
1366                     if (mTouchState != TOUCH_STATE_PREV_PAGE &amp;&amp; mTouchState != TOUCH_STATE_NEXT_PAGE) {
1367                         if (getChildCount() &gt; 0) {
1368                             if (hitsPreviousPage(x, y)) {
1369                                 mTouchState = TOUCH_STATE_PREV_PAGE;
1370                             } else if (hitsNextPage(x, y)) {
1371                                 mTouchState = TOUCH_STATE_NEXT_PAGE;
1372                             }
1373                         }
1374                     }
1375                 }
1376                 break;
1377             }
1378 
1379             case MotionEvent.ACTION_UP:
1380             case MotionEvent.ACTION_CANCEL:
1381                 resetTouchState();
1382                 // Just intercept the touch event on up if we tap outside the strict viewport
1383                 if (!isTouchPointInCurrentPage((int) mLastMotionX, (int) mLastMotionY)) {
1384                     return true;
1385                 }
1386                 break;
1387 
1388             case MotionEvent.ACTION_POINTER_UP:
1389                 onSecondaryPointerUp(ev);
1390                 releaseVelocityTracker();
1391                 break;
1392         }
1393 
1394         /*
1395          * The only time we want to intercept motion events is if we are in the
1396          * drag mode.
1397          */
1398         return mTouchState != TOUCH_STATE_REST;
1399     }
1400 
1401     protected void determineScrollingStart(MotionEvent ev) {
1402         determineScrollingStart(ev, 1.0f);
1403     }
1404 
1405     /*
1406      * Determines if we should change the touch state to start scrolling after the
1407      * user moves their touch point too far.
1408      */
1409     protected void determineScrollingStart(MotionEvent ev, float touchSlopScale) {
1410         // Disallow scrolling if we don&#x27;t have a valid pointer index
1411         final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1412         if (pointerIndex == -1) return;
1413 
1414         // Disallow scrolling if we started the gesture from outside the viewport
1415         final float x = ev.getX(pointerIndex);
1416         final float y = ev.getY(pointerIndex);
1417         if (!isTouchPointInViewportWithBuffer((int) x, (int) y)) return;
1418 
1419         // If we&#x27;re only allowing edge swipes, we break out early if the down event wasn&#x27;t
1420         // at the edge.
1421         if (mOnlyAllowEdgeSwipes &amp;&amp; !mDownEventOnEdge) return;
1422 
1423         final int xDiff = (int) Math.abs(x - mLastMotionX);
1424         final int yDiff = (int) Math.abs(y - mLastMotionY);
1425 
1426         final int touchSlop = Math.round(touchSlopScale * mTouchSlop);
1427         boolean xPaged = xDiff &gt; mPagingTouchSlop;
1428         boolean xMoved = xDiff &gt; touchSlop;
1429         boolean yMoved = yDiff &gt; touchSlop;
1430 
1431         if (xMoved || xPaged || yMoved) {
1432             if (mUsePagingTouchSlop ? xPaged : xMoved) {
1433                 // Scroll if the user moved far enough along the X axis
1434                 mTouchState = TOUCH_STATE_SCROLLING;
1435                 mTotalMotionX += Math.abs(mLastMotionX - x);
1436                 mLastMotionX = x;
1437                 mLastMotionXRemainder = 0;
1438                 mTouchX = getViewportOffsetX() + getScrollX();
1439                 mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1440                 pageBeginMoving();
1441             }
1442         }
1443     }
1444 
1445     protected float getMaxScrollProgress() {
1446         return 1.0f;
1447     }
1448 
1449     protected void cancelCurrentPageLongPress() {
1450         if (mAllowLongPress) {
1451             //mAllowLongPress = false;
1452             // Try canceling the long press. It could also have been scheduled
1453             // by a distant descendant, so use the mAllowLongPress flag to block
1454             // everything
1455             final View currentPage = getPageAt(mCurrentPage);
1456             if (currentPage != null) {
1457                 currentPage.cancelLongPress();
1458             }
1459         }
1460     }
1461 
1462     protected float getBoundedScrollProgress(int screenCenter, View v, int page) {
1463         final int halfScreenSize = getViewportWidth() / 2;
1464 
1465         screenCenter = Math.min(getScrollX() + halfScreenSize, screenCenter);
1466         screenCenter = Math.max(halfScreenSize,  screenCenter);
1467 
1468         return getScrollProgress(screenCenter, v, page);
1469     }
1470 
1471     protected float getScrollProgress(int screenCenter, View v, int page) {
1472         final int halfScreenSize = getViewportWidth() / 2;
1473 
1474         int totalDistance = v.getMeasuredWidth() + mPageSpacing;
1475         int delta = screenCenter - (getChildOffset(page) -
1476                 getRelativeChildOffset(page) + halfScreenSize);
1477 
1478         float scrollProgress = delta / (totalDistance * 1.0f);
1479         scrollProgress = Math.min(scrollProgress, getMaxScrollProgress());
1480         scrollProgress = Math.max(scrollProgress, - getMaxScrollProgress());
1481         return scrollProgress;
1482     }
1483 
1484     // This curve determines how the effect of scrolling over the limits of the page dimishes
1485     // as the user pulls further and further from the bounds
1486     private float overScrollInfluenceCurve(float f) {
1487         f -= 1.0f;
1488         return f * f * f + 1.0f;
1489     }
1490 
1491     protected void acceleratedOverScroll(float amount) {
1492         int screenSize = getViewportWidth();
1493 
1494         // We want to reach the max over scroll effect when the user has
1495         // over scrolled half the size of the screen
1496         float f = OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
1497 
1498         if (f == 0) return;
1499 
1500         // Clamp this factor, f, to -1 &lt; f &lt; 1
1501         if (Math.abs(f) &gt;= 1) {
1502             f /= Math.abs(f);
1503         }
1504 
1505         int overScrollAmount = (int) Math.round(f * screenSize);
1506         if (amount &lt; 0) {
1507             mOverScrollX = overScrollAmount;
1508             super.scrollTo(0, getScrollY());
1509         } else {
1510             mOverScrollX = mMaxScrollX + overScrollAmount;
1511             super.scrollTo(mMaxScrollX, getScrollY());
1512         }
1513         invalidate();
1514     }
1515 
1516     protected void dampedOverScroll(float amount) {
1517         int screenSize = getViewportWidth();
1518 
1519         float f = (amount / screenSize);
1520 
1521         if (f == 0) return;
1522         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1523 
1524         // Clamp this factor, f, to -1 &lt; f &lt; 1
1525         if (Math.abs(f) &gt;= 1) {
1526             f /= Math.abs(f);
1527         }
1528 
1529         int overScrollAmount = (int) Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
1530         if (amount &lt; 0) {
1531             mOverScrollX = overScrollAmount;
1532             super.scrollTo(0, getScrollY());
1533         } else {
1534             mOverScrollX = mMaxScrollX + overScrollAmount;
1535             super.scrollTo(mMaxScrollX, getScrollY());
1536         }
1537         invalidate();
1538     }
1539 
1540     protected void overScroll(float amount) {
1541         dampedOverScroll(amount);
1542     }
1543 
1544     protected float maxOverScroll() {
1545         // Using the formula in overScroll, assuming that f = 1.0 (which it should generally not
1546         // exceed). Used to find out how much extra wallpaper we need for the over scroll effect
1547         float f = 1.0f;
1548         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1549         return OVERSCROLL_DAMP_FACTOR * f;
1550     }
1551 
1552     @Override
1553     public boolean onTouchEvent(MotionEvent ev) {
1554         if (DISABLE_TOUCH_INTERACTION) {
1555             return false;
1556         }
1557 
1558         // Skip touch handling if there are no pages to swipe
1559         if (getChildCount() &lt;= 0) return super.onTouchEvent(ev);
1560 
1561         acquireVelocityTrackerAndAddMovement(ev);
1562 
1563         final int action = ev.getAction();
1564 
1565         switch (action &amp; MotionEvent.ACTION_MASK) {
1566         case MotionEvent.ACTION_DOWN:
1567             /*
1568              * If being flinged and user touches, stop the fling. isFinished
1569              * will be false if being flinged.
1570              */
1571             if (!mScroller.isFinished()) {
1572                 mScroller.abortAnimation();
1573             }
1574 
1575             // Remember where the motion event started
1576             mDownMotionX = mLastMotionX = ev.getX();
1577             mDownMotionY = mLastMotionY = ev.getY();
1578             mDownScrollX = getScrollX();
1579             float[] p = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1580             mParentDownMotionX = p[0];
1581             mParentDownMotionY = p[1];
1582             mLastMotionXRemainder = 0;
1583             mTotalMotionX = 0;
1584             mActivePointerId = ev.getPointerId(0);
1585 
1586             // Determine if the down event is within the threshold to be an edge swipe
1587             int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1588             int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1589             if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1590                 mDownEventOnEdge = true;
1591             }
1592 
1593             if (mTouchState == TOUCH_STATE_SCROLLING) {
1594                 pageBeginMoving();
1595             }
1596             break;
1597 
1598         case MotionEvent.ACTION_MOVE:
1599             if (mTouchState == TOUCH_STATE_SCROLLING) {
1600                 // Scroll to follow the motion event
1601                 final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1602 
1603                 if (pointerIndex == -1) return true;
1604 
1605                 final float x = ev.getX(pointerIndex);
1606                 final float deltaX = mLastMotionX + mLastMotionXRemainder - x;
1607 
1608                 mTotalMotionX += Math.abs(deltaX);
1609 
1610                 // Only scroll and update mLastMotionX if we have moved some discrete amount.  We
1611                 // keep the remainder because we are actually testing if we&#x27;ve moved from the last
1612                 // scrolled position (which is discrete).
1613                 if (Math.abs(deltaX) &gt;= 1.0f) {
1614                     mTouchX += deltaX;
1615                     mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1616                     if (!mDeferScrollUpdate) {
1617                         scrollBy((int) deltaX, 0);
1618                         if (DEBUG) Log.d(TAG, &quot;onTouchEvent().Scrolling: &quot; + deltaX);
1619                     } else {
1620                         invalidate();
1621                     }
1622                     mLastMotionX = x;
1623                     mLastMotionXRemainder = deltaX - (int) deltaX;
1624                 } else {
1625                     awakenScrollBars();
1626                 }
1627             } else if (mTouchState == TOUCH_STATE_REORDERING) {
1628                 // Update the last motion position
1629                 mLastMotionX = ev.getX();
1630                 mLastMotionY = ev.getY();
1631 
1632                 // Update the parent down so that our zoom animations take this new movement into
1633                 // account
1634                 float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1635                 mParentDownMotionX = pt[0];
1636                 mParentDownMotionY = pt[1];
1637                 updateDragViewTranslationDuringDrag();
1638 
1639                 // Find the closest page to the touch point
1640                 final int dragViewIndex = indexOfChild(mDragView);
1641                 int bufferSize = (int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE *
1642                     getViewportWidth());
1643                 int leftBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.left, 0)[0]
1644                         + bufferSize);
1645                 int rightBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.right, 0)[0]
1646                         - bufferSize);
1647 
1648                 // Change the drag view if we are hovering over the drop target
1649                 boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(
1650                         (int) mParentDownMotionX, (int) mParentDownMotionY);
1651                 setPageHoveringOverDeleteDropTarget(dragViewIndex, isHoveringOverDelete);
1652 
1653                 if (DEBUG) Log.d(TAG, &quot;leftBufferEdge: &quot; + leftBufferEdge);
1654                 if (DEBUG) Log.d(TAG, &quot;rightBufferEdge: &quot; + rightBufferEdge);
1655                 if (DEBUG) Log.d(TAG, &quot;mLastMotionX: &quot; + mLastMotionX);
1656                 if (DEBUG) Log.d(TAG, &quot;mLastMotionY: &quot; + mLastMotionY);
1657                 if (DEBUG) Log.d(TAG, &quot;mParentDownMotionX: &quot; + mParentDownMotionX);
1658                 if (DEBUG) Log.d(TAG, &quot;mParentDownMotionY: &quot; + mParentDownMotionY);
1659 
1660                 float parentX = mParentDownMotionX;
1661                 int pageIndexToSnapTo = -1;
1662                 if (parentX &lt; leftBufferEdge &amp;&amp; dragViewIndex &gt; 0) {
1663                     pageIndexToSnapTo = dragViewIndex - 1;
1664                 } else if (parentX &gt; rightBufferEdge &amp;&amp; dragViewIndex &lt; getChildCount() - 1) {
1665                     pageIndexToSnapTo = dragViewIndex + 1;
1666                 }
1667 
1668                 final int pageUnderPointIndex = pageIndexToSnapTo;
1669                 if (pageUnderPointIndex &gt; -1 &amp;&amp; !isHoveringOverDelete) {
1670                     mTempVisiblePagesRange[0] = 0;
1671                     mTempVisiblePagesRange[1] = getPageCount() - 1;
1672                     boundByReorderablePages(true, mTempVisiblePagesRange);
1673                     if (mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex &amp;&amp;
1674                             pageUnderPointIndex &lt;= mTempVisiblePagesRange[1] &amp;&amp;
1675                             pageUnderPointIndex != mSidePageHoverIndex &amp;&amp; mScroller.isFinished()) {
1676                         mSidePageHoverIndex = pageUnderPointIndex;
1677                         mSidePageHoverRunnable = new Runnable() {
1678                             @Override
1679                             public void run() {
1680                                 // Update the down scroll position to account for the fact that the
1681                                 // current page is moved
1682                                 mDownScrollX = getChildOffset(pageUnderPointIndex)
1683                                         - getRelativeChildOffset(pageUnderPointIndex);
1684 
1685                                 // Setup the scroll to the correct page before we swap the views
1686                                 snapToPage(pageUnderPointIndex);
1687 
1688                                 // For each of the pages between the paged view and the drag view,
1689                                 // animate them from the previous position to the new position in
1690                                 // the layout (as a result of the drag view moving in the layout)
1691                                 int shiftDelta = (dragViewIndex &lt; pageUnderPointIndex) ? -1 : 1;
1692                                 int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ?
1693                                         dragViewIndex + 1 : pageUnderPointIndex;
1694                                 int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ?
1695                                         dragViewIndex - 1 : pageUnderPointIndex;
1696                                 for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
1697                                     View v = getChildAt(i);
1698                                     // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
1699                                     // drag view all subsequent views to pageUnderPointIndex will
1700                                     // shift down.
1701                                     int oldX = getViewportOffsetX() + getChildOffset(i);
1702                                     int newX = getViewportOffsetX() + getChildOffset(i + shiftDelta);
1703 
1704                                     // Animate the view translation from its old position to its new
1705                                     // position
1706                                     AnimatorSet anim = (AnimatorSet) v.getTag(ANIM_TAG_KEY);
1707                                     if (anim != null) {
1708                                         anim.cancel();
1709                                     }
1710 
1711                                     v.setTranslationX(oldX - newX);
1712                                     anim = new AnimatorSet();
1713                                     anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
1714                                     anim.playTogether(
1715                                             ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f));
1716                                     anim.start();
1717                                     v.setTag(anim);
1718                                 }
1719 
1720                                 removeView(mDragView);
1721                                 onRemoveView(mDragView, false);
1722                                 addView(mDragView, pageUnderPointIndex);
1723                                 onAddView(mDragView, pageUnderPointIndex);
1724                                 mSidePageHoverIndex = -1;
1725                                 mPageIndicator.setActiveMarker(getNextPage());
1726                             }
1727                         };
1728                         postDelayed(mSidePageHoverRunnable, REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
1729                     }
1730                 } else {
1731                     removeCallbacks(mSidePageHoverRunnable);
1732                     mSidePageHoverIndex = -1;
1733                 }
1734             } else {
1735                 determineScrollingStart(ev);
1736             }
1737             break;
1738 
1739         case MotionEvent.ACTION_UP:
1740             if (mTouchState == TOUCH_STATE_SCROLLING) {
1741                 final int activePointerId = mActivePointerId;
1742                 final int pointerIndex = ev.findPointerIndex(activePointerId);
1743                 final float x = ev.getX(pointerIndex);
1744                 final VelocityTracker velocityTracker = mVelocityTracker;
1745                 velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
1746                 int velocityX = (int) velocityTracker.getXVelocity(activePointerId);
1747                 final int deltaX = (int) (x - mDownMotionX);
1748                 final int pageWidth = getPageAt(mCurrentPage).getMeasuredWidth();
1749                 boolean isSignificantMove = Math.abs(deltaX) &gt; pageWidth *
1750                         SIGNIFICANT_MOVE_THRESHOLD;
1751 
1752                 mTotalMotionX += Math.abs(mLastMotionX + mLastMotionXRemainder - x);
1753 
1754                 boolean isFling = mTotalMotionX &gt; MIN_LENGTH_FOR_FLING &amp;&amp;
1755                         Math.abs(velocityX) &gt; mFlingThresholdVelocity;
1756 
1757                 // In the case that the page is moved far to one direction and then is flung
1758                 // in the opposite direction, we use a threshold to determine whether we should
1759                 // just return to the starting page, or if we should skip one further.
1760                 boolean returnToOriginalPage = false;
1761                 if (Math.abs(deltaX) &gt; pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD &amp;&amp;
1762                         Math.signum(velocityX) != Math.signum(deltaX) &amp;&amp; isFling) {
1763                     returnToOriginalPage = true;
1764                 }
1765 
1766                 int finalPage;
1767                 // We give flings precedence over large moves, which is why we short-circuit our
1768                 // test for a large move if a fling has been registered. That is, a large
1769                 // move to the left and fling to the right will register as a fling to the right.
1770                 final boolean isRtl = isLayoutRtl();
1771                 boolean isDeltaXLeft = isRtl ? deltaX &gt; 0 : deltaX &lt; 0;
1772                 boolean isVelocityXLeft = isRtl ? velocityX &gt; 0 : velocityX &lt; 0;
1773                 if (((isSignificantMove &amp;&amp; !isDeltaXLeft &amp;&amp; !isFling) ||
1774                         (isFling &amp;&amp; !isVelocityXLeft)) &amp;&amp; mCurrentPage &gt; 0) {
1775                     finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
1776                     snapToPageWithVelocity(finalPage, velocityX);
1777                 } else if (((isSignificantMove &amp;&amp; isDeltaXLeft &amp;&amp; !isFling) ||
1778                         (isFling &amp;&amp; isVelocityXLeft)) &amp;&amp;
1779                         mCurrentPage &lt; getChildCount() - 1) {
1780                     finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
1781                     snapToPageWithVelocity(finalPage, velocityX);
1782                 } else {
1783                     snapToDestination();
1784                 }            } else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
1785                 // at this point we have not moved beyond the touch slop
1786                 // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1787                 // we can just page
1788                 int nextPage = Math.max(0, mCurrentPage - 1);
1789                 if (nextPage != mCurrentPage) {
1790                     snapToPage(nextPage);
1791                 } else {
1792                     snapToDestination();
1793                 }
1794             } else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
1795                 // at this point we have not moved beyond the touch slop
1796                 // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1797                 // we can just page
1798                 int nextPage = Math.min(getChildCount() - 1, mCurrentPage + 1);
1799                 if (nextPage != mCurrentPage) {
1800                     snapToPage(nextPage);
1801                 } else {
1802                     snapToDestination();
1803                 }
1804             } else if (mTouchState == TOUCH_STATE_REORDERING) {
1805                 // Update the last motion position
1806                 mLastMotionX = ev.getX();
1807                 mLastMotionY = ev.getY();
1808 
1809                 // Update the parent down so that our zoom animations take this new movement into
1810                 // account
1811                 float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1812                 mParentDownMotionX = pt[0];
1813                 mParentDownMotionY = pt[1];
1814                 updateDragViewTranslationDuringDrag();
1815                 boolean handledFling = false;
1816                 if (!DISABLE_FLING_TO_DELETE) {
1817                     // Check the velocity and see if we are flinging-to-delete
1818                     PointF flingToDeleteVector = isFlingingToDelete();
1819                     if (flingToDeleteVector != null) {
1820                         onFlingToDelete(flingToDeleteVector);
1821                         handledFling = true;
1822                     }
1823                 }
1824                 if (!handledFling &amp;&amp; isHoveringOverDeleteDropTarget((int) mParentDownMotionX,
1825                         (int) mParentDownMotionY)) {
1826                     onDropToDelete();
1827                 }
1828             } else {
1829                 onUnhandledTap(ev);
1830             }
1831 
1832             // Remove the callback to wait for the side page hover timeout
1833             removeCallbacks(mSidePageHoverRunnable);
1834             // End any intermediate reordering states
1835             resetTouchState();
1836             break;
1837 
1838         case MotionEvent.ACTION_CANCEL:
1839             if (mTouchState == TOUCH_STATE_SCROLLING) {
1840                 snapToDestination();
1841             }
1842             resetTouchState();
1843             break;
1844 
1845         case MotionEvent.ACTION_POINTER_UP:
1846             onSecondaryPointerUp(ev);
1847             break;
1848         }
1849 
1850         return true;
1851     }
1852 
1853     public void onFlingToDelete(View v) {}
1854     public void onRemoveView(View v, boolean deletePermanently) {}
1855     public void onRemoveViewAnimationCompleted() {}
1856     public void onAddView(View v, int index) {}
1857 
1858     private void resetTouchState() {
1859         releaseVelocityTracker();
1860         endReordering();
1861         mTouchState = TOUCH_STATE_REST;
1862         mActivePointerId = INVALID_POINTER;
1863         mDownEventOnEdge = false;
1864     }
1865 
1866     protected void onUnhandledTap(MotionEvent ev) {}
1867 
1868     @Override
1869     public boolean onGenericMotionEvent(MotionEvent event) {
1870         if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
1871             switch (event.getAction()) {
1872                 case MotionEvent.ACTION_SCROLL: {
1873                     // Handle mouse (or ext. device) by shifting the page depending on the scroll
1874                     final float vscroll;
1875                     final float hscroll;
1876                     if ((event.getMetaState() &amp; KeyEvent.META_SHIFT_ON) != 0) {
1877                         vscroll = 0;
1878                         hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1879                     } else {
1880                         vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1881                         hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
1882                     }
1883                     if (hscroll != 0 || vscroll != 0) {
1884                         boolean isForwardScroll = isLayoutRtl() ? (hscroll &lt; 0 || vscroll &lt; 0)
1885                                                          : (hscroll &gt; 0 || vscroll &gt; 0);
1886                         if (isForwardScroll) {
1887                             scrollRight();
1888                         } else {
1889                             scrollLeft();
1890                         }
1891                         return true;
1892                     }
1893                 }
1894             }
1895         }
1896         return super.onGenericMotionEvent(event);
1897     }
1898 
1899     private void acquireVelocityTrackerAndAddMovement(MotionEvent ev) {
1900         if (mVelocityTracker == null) {
1901             mVelocityTracker = VelocityTracker.obtain();
1902         }
1903         mVelocityTracker.addMovement(ev);
1904     }
1905 
1906     private void releaseVelocityTracker() {
1907         if (mVelocityTracker != null) {
1908             mVelocityTracker.recycle();
1909             mVelocityTracker = null;
1910         }
1911     }
1912 
1913     private void onSecondaryPointerUp(MotionEvent ev) {
1914         final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;
1915                 MotionEvent.ACTION_POINTER_INDEX_SHIFT;
1916         final int pointerId = ev.getPointerId(pointerIndex);
1917         if (pointerId == mActivePointerId) {
1918             // This was our active pointer going up. Choose a new
1919             // active pointer and adjust accordingly.
1920             // TODO: Make this decision more intelligent.
1921             final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
1922             mLastMotionX = mDownMotionX = ev.getX(newPointerIndex);
1923             mLastMotionY = ev.getY(newPointerIndex);
1924             mLastMotionXRemainder = 0;
1925             mActivePointerId = ev.getPointerId(newPointerIndex);
1926             if (mVelocityTracker != null) {
1927                 mVelocityTracker.clear();
1928             }
1929         }
1930     }
1931 
1932     @Override
1933     public void requestChildFocus(View child, View focused) {
1934         super.requestChildFocus(child, focused);
1935         int page = indexToPage(indexOfChild(child));
1936         if (page &gt;= 0 &amp;&amp; page != getCurrentPage() &amp;&amp; !isInTouchMode()) {
1937             snapToPage(page);
1938         }
1939     }
1940 
1941     protected int getChildWidth(int index) {
1942         return getPageAt(index).getMeasuredWidth();
1943     }
1944 
1945     int getPageNearestToPoint(float x) {
1946         int index = 0;
1947         for (int i = 0; i &lt; getChildCount(); ++i) {
1948             if (x &lt; getChildAt(i).getRight() - getScrollX()) {
1949                 return index;
1950             } else {
1951                 index++;
1952             }
1953         }
1954         return Math.min(index, getChildCount() - 1);
1955     }
1956 
1957     int getPageNearestToCenterOfScreen() {
1958         int minDistanceFromScreenCenter = Integer.MAX_VALUE;
1959         int minDistanceFromScreenCenterIndex = -1;
1960         int screenCenter = getViewportOffsetX() + getScrollX() + (getViewportWidth() / 2);
1961         final int childCount = getChildCount();
1962         for (int i = 0; i &lt; childCount; ++i) {
1963             View layout = (View) getPageAt(i);
1964             int childWidth = layout.getMeasuredWidth();
1965             int halfChildWidth = (childWidth / 2);
1966             int childCenter = getViewportOffsetX() + getChildOffset(i) + halfChildWidth;
1967             int distanceFromScreenCenter = Math.abs(childCenter - screenCenter);
1968             if (distanceFromScreenCenter &lt; minDistanceFromScreenCenter) {
1969                 minDistanceFromScreenCenter = distanceFromScreenCenter;
1970                 minDistanceFromScreenCenterIndex = i;
1971             }
1972         }
1973         return minDistanceFromScreenCenterIndex;
1974     }
1975 
1976     protected void snapToDestination() {
1977         snapToPage(getPageNearestToCenterOfScreen(), PAGE_SNAP_ANIMATION_DURATION);
1978     }
1979 
1980     private static class ScrollInterpolator implements Interpolator {
1981         public ScrollInterpolator() {
1982         }
1983 
1984         public float getInterpolation(float t) {
1985             t -= 1.0f;
1986             return t*t*t*t*t + 1;
1987         }
1988     }
1989 
1990     // We want the duration of the page snap animation to be influenced by the distance that
1991     // the screen has to travel, however, we don&#x27;t want this duration to be effected in a
1992     // purely linear fashion. Instead, we use this method to moderate the effect that the distance
1993     // of travel has on the overall snap duration.
1994     float distanceInfluenceForSnapDuration(float f) {
1995         f -= 0.5f; // center the values about 0.
1996         f *= 0.3f * Math.PI / 2.0f;
1997         return (float) Math.sin(f);
1998     }
1999 
2000     protected void snapToPageWithVelocity(int whichPage, int velocity) {
2001         whichPage = Math.max(0, Math.min(whichPage, getChildCount() - 1));
2002         int halfScreenSize = getViewportWidth() / 2;
2003 
2004         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2005         if (DEBUG) Log.d(TAG, &quot;snapToPageWithVelocity.getRelativeChildOffset(): &quot;
2006                 + getViewportWidth() + &quot;, &quot; + getChildWidth(whichPage));
2007         final int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2008         int delta = newX - mUnboundedScrollX;
2009         int duration = 0;
2010 
2011         if (Math.abs(velocity) &lt; mMinFlingVelocity) {
2012             // If the velocity is low enough, then treat this more as an automatic page advance
2013             // as opposed to an apparent physical response to flinging
2014             snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2015             return;
2016         }
2017 
2018         // Here we compute a &quot;distance&quot; that will be used in the computation of the overall
2019         // snap duration. This is a function of the actual distance that needs to be traveled;
2020         // we keep this value close to half screen size in order to reduce the variance in snap
2021         // duration as a function of the distance the page needs to travel.
2022         float distanceRatio = Math.min(1f, 1.0f * Math.abs(delta) / (2 * halfScreenSize));
2023         float distance = halfScreenSize + halfScreenSize *
2024                 distanceInfluenceForSnapDuration(distanceRatio);
2025 
2026         velocity = Math.abs(velocity);
2027         velocity = Math.max(mMinSnapVelocity, velocity);
2028 
2029         // we want the page&#x27;s snap velocity to approximately match the velocity at which the
2030         // user flings, so we scale the duration by a value near to the derivative of the scroll
2031         // interpolator at zero, ie. 5. We use 4 to make it a little slower.
2032         duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
2033 
2034         snapToPage(whichPage, delta, duration);
2035     }
2036 
2037     protected void snapToPage(int whichPage) {
2038         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2039     }
2040 
2041     protected void snapToPageImmediately(int whichPage) {
2042         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION, true);
2043     }
2044 
2045     protected void snapToPage(int whichPage, int duration) {
2046         snapToPage(whichPage, duration, false);
2047     }
2048 
2049     protected void snapToPage(int whichPage, int duration, boolean immediate) {
2050         whichPage = Math.max(0, Math.min(whichPage, getPageCount() - 1));
2051 
2052         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2053         if (DEBUG) Log.d(TAG, &quot;snapToPage.getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
2054                 + getChildWidth(whichPage));
2055         int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2056         final int sX = mUnboundedScrollX;
2057         final int delta = newX - sX;
2058         snapToPage(whichPage, delta, duration, immediate);
2059     }
2060 
2061     protected void snapToPage(int whichPage, int delta, int duration) {
2062         snapToPage(whichPage, delta, duration, false);
2063     }
2064 
2065     protected void snapToPage(int whichPage, int delta, int duration, boolean immediate) {
2066         mNextPage = whichPage;
2067         View focusedChild = getFocusedChild();
2068         if (focusedChild != null &amp;&amp; whichPage != mCurrentPage &amp;&amp;
2069                 focusedChild == getPageAt(mCurrentPage)) {
2070             focusedChild.clearFocus();
2071         }
2072 
2073         pageBeginMoving();
2074         awakenScrollBars(duration);
2075         if (immediate) {
2076             duration = 0;
2077         } else if (duration == 0) {
2078             duration = Math.abs(delta);
2079         }
2080 
2081         if (!mScroller.isFinished()) mScroller.abortAnimation();
2082         mScroller.startScroll(mUnboundedScrollX, 0, delta, 0, duration);
2083 
2084         notifyPageSwitchListener();
2085 
2086         // Trigger a compute() to finish switching pages if necessary
2087         if (immediate) {
2088             computeScroll();
2089         }
2090 
2091         mForceScreenScrolled = true;
2092         invalidate();
2093     }
2094 
2095     public void scrollLeft() {
2096         if (mScroller.isFinished()) {
2097             if (mCurrentPage &gt; 0) snapToPage(mCurrentPage - 1);
2098         } else {
2099             if (mNextPage &gt; 0) snapToPage(mNextPage - 1);
2100         }
2101     }
2102 
2103     public void scrollRight() {
2104         if (mScroller.isFinished()) {
2105             if (mCurrentPage &lt; getChildCount() -1) snapToPage(mCurrentPage + 1);
2106         } else {
2107             if (mNextPage &lt; getChildCount() -1) snapToPage(mNextPage + 1);
2108         }
2109     }
2110 
2111     public int getPageForView(View v) {
2112         int result = -1;
2113         if (v != null) {
2114             ViewParent vp = v.getParent();
2115             int count = getChildCount();
2116             for (int i = 0; i &lt; count; i++) {
2117                 if (vp == getPageAt(i)) {
2118                     return i;
2119                 }
2120             }
2121         }
2122         return result;
2123     }
2124 
2125     /**
2126      * @return True is long presses are still allowed for the current touch
2127      */
2128     public boolean allowLongPress() {
2129         return mAllowLongPress;
2130     }
2131 
2132     /**
2133      * Set true to allow long-press events to be triggered, usually checked by
2134      * {@link Launcher} to accept or block dpad-initiated long-presses.
2135      */
2136     public void setAllowLongPress(boolean allowLongPress) {
2137         mAllowLongPress = allowLongPress;
2138     }
2139 
2140     public static class SavedState extends BaseSavedState {
2141         int currentPage = -1;
2142 
2143         SavedState(Parcelable superState) {
2144             super(superState);
2145         }
2146 
2147         private SavedState(Parcel in) {
2148             super(in);
2149             currentPage = in.readInt();
2150         }
2151 
2152         @Override
2153         public void writeToParcel(Parcel out, int flags) {
2154             super.writeToParcel(out, flags);
2155             out.writeInt(currentPage);
2156         }
2157 
2158         public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
2159                 new Parcelable.Creator&lt;SavedState&gt;() {
2160             public SavedState createFromParcel(Parcel in) {
2161                 return new SavedState(in);
2162             }
2163 
2164             public SavedState[] newArray(int size) {
2165                 return new SavedState[size];
2166             }
2167         };
2168     }
2169 
2170     protected void loadAssociatedPages(int page) {
2171         loadAssociatedPages(page, false);
2172     }
2173     protected void loadAssociatedPages(int page, boolean immediateAndOnly) {
2174         if (mContentIsRefreshable) {
2175             final int count = getChildCount();
2176             if (page &lt; count) {
2177                 int lowerPageBound = getAssociatedLowerPageBound(page);
2178                 int upperPageBound = getAssociatedUpperPageBound(page);
2179                 if (DEBUG) Log.d(TAG, &quot;loadAssociatedPages: &quot; + lowerPageBound + &quot;/&quot;
2180                         + upperPageBound);
2181                 // First, clear any pages that should no longer be loaded
2182                 for (int i = 0; i &lt; count; ++i) {
2183                     Page layout = (Page) getPageAt(i);
2184                     if ((i &lt; lowerPageBound) || (i &gt; upperPageBound)) {
2185                         if (layout.getPageChildCount() &gt; 0) {
2186                             layout.removeAllViewsOnPage();
2187                         }
2188                         mDirtyPageContent.set(i, true);
2189                     }
2190                 }
2191                 // Next, load any new pages
2192                 for (int i = 0; i &lt; count; ++i) {
2193                     if ((i != page) &amp;&amp; immediateAndOnly) {
2194                         continue;
2195                     }
2196                     if (lowerPageBound &lt;= i &amp;&amp; i &lt;= upperPageBound) {
2197                         if (mDirtyPageContent.get(i)) {
2198                             syncPageItems(i, (i == page) &amp;&amp; immediateAndOnly);
2199                             mDirtyPageContent.set(i, false);
2200                         }
2201                     }
2202                 }
2203             }
2204         }
2205     }
2206 
2207     protected int getAssociatedLowerPageBound(int page) {
2208         return Math.max(0, page - 1);
2209     }
2210     protected int getAssociatedUpperPageBound(int page) {
2211         final int count = getChildCount();
2212         return Math.min(page + 1, count - 1);
2213     }
2214 
2215     /**
2216      * This method is called ONLY to synchronize the number of pages that the paged view has.
2217      * To actually fill the pages with information, implement syncPageItems() below.  It is
2218      * guaranteed that syncPageItems() will be called for a particular page before it is shown,
2219      * and therefore, individual page items do not need to be updated in this method.
2220      */
2221     public abstract void syncPages();
2222 
2223     /**
2224      * This method is called to synchronize the items that are on a particular page.  If views on
2225      * the page can be reused, then they should be updated within this method.
2226      */
2227     public abstract void syncPageItems(int page, boolean immediate);
2228 
2229     protected void invalidatePageData() {
2230         invalidatePageData(-1, false);
2231     }
2232     protected void invalidatePageData(int currentPage) {
2233         invalidatePageData(currentPage, false);
2234     }
2235     protected void invalidatePageData(int currentPage, boolean immediateAndOnly) {
2236         if (!mIsDataReady) {
2237             return;
2238         }
2239 
2240         if (mContentIsRefreshable) {
2241             // Force all scrolling-related behavior to end
2242             mScroller.forceFinished(true);
2243             mNextPage = INVALID_PAGE;
2244 
2245             // Update all the pages
2246             syncPages();
2247 
2248             // We must force a measure after we&#x27;ve loaded the pages to update the content width and
2249             // to determine the full scroll width
2250             measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
2251                     MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
2252 
2253             // Set a new page as the current page if necessary
2254             if (currentPage &gt; -1) {
2255                 setCurrentPage(Math.min(getPageCount() - 1, currentPage));
2256             }
2257 
2258             // Mark each of the pages as dirty
2259             final int count = getChildCount();
2260             mDirtyPageContent.clear();
2261             for (int i = 0; i &lt; count; ++i) {
2262                 mDirtyPageContent.add(true);
2263             }
2264 
2265             // Load any pages that are necessary for the current window of views
2266             loadAssociatedPages(mCurrentPage, immediateAndOnly);
2267             requestLayout();
2268         }
2269     }
2270 
2271     // Animate the drag view back to the original position
2272     void animateDragViewToOriginalPosition() {
2273         if (mDragView != null) {
2274             AnimatorSet anim = new AnimatorSet();
2275             anim.setDuration(REORDERING_DROP_REPOSITION_DURATION);
2276             anim.playTogether(
2277                     ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0f),
2278                     ObjectAnimator.ofFloat(mDragView, &quot;translationY&quot;, 0f));
2279             anim.addListener(new AnimatorListenerAdapter() {
2280                 @Override
2281                 public void onAnimationEnd(Animator animation) {
2282                     onPostReorderingAnimationCompleted();
2283                 }
2284             });
2285             anim.start();
2286         }
2287     }
2288 
2289     // &quot;Zooms out&quot; the PagedView to reveal more side pages
2290     protected boolean zoomOut() {
2291         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2292             mZoomInOutAnim.cancel();
2293         }
2294 
2295         if (!(getScaleX() &lt; 1f || getScaleY() &lt; 1f)) {
2296             mZoomInOutAnim = new AnimatorSet();
2297             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2298             mZoomInOutAnim.playTogether(
2299                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, mMinScale),
2300                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, mMinScale));
2301             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2302                 @Override
2303                 public void onAnimationStart(Animator animation) {
2304                     // Show the delete drop target
2305                     if (mDeleteDropTarget != null) {
2306                         mDeleteDropTarget.setVisibility(View.VISIBLE);
2307                         mDeleteDropTarget.animate().alpha(1f)
2308                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2309                             .setListener(new AnimatorListenerAdapter() {
2310                                 @Override
2311                                 public void onAnimationStart(Animator animation) {
2312                                     mDeleteDropTarget.setAlpha(0f);
2313                                 }
2314                             });
2315                     }
2316                 }
2317             });
2318             mZoomInOutAnim.start();
2319             return true;
2320         }
2321         return false;
2322     }
2323 
2324     protected void onStartReordering() {
2325         // Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)
2326         mTouchState = TOUCH_STATE_REORDERING;
2327         mIsReordering = true;
2328 
2329         // Mark all the non-widget pages as invisible
2330         getVisiblePages(mTempVisiblePagesRange);
2331         boundByReorderablePages(true, mTempVisiblePagesRange);
2332         for (int i = 0; i &lt; getPageCount(); ++i) {
2333             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2334                 getPageAt(i).setAlpha(0f);
2335             }
2336         }
2337 
2338         // We must invalidate to trigger a redraw to update the layers such that the drag view
2339         // is always drawn on top
2340         invalidate();
2341     }
2342 
2343     private void onPostReorderingAnimationCompleted() {
2344         // Trigger the callback when reordering has settled
2345         --mPostReorderingPreZoomInRemainingAnimationCount;
2346         if (mPostReorderingPreZoomInRunnable != null &amp;&amp;
2347                 mPostReorderingPreZoomInRemainingAnimationCount == 0) {
2348             mPostReorderingPreZoomInRunnable.run();
2349             mPostReorderingPreZoomInRunnable = null;
2350         }
2351     }
2352 
2353     protected void onEndReordering() {
2354         mIsReordering = false;
2355 
2356         // Mark all the non-widget pages as visible again
2357         getVisiblePages(mTempVisiblePagesRange);
2358         boundByReorderablePages(true, mTempVisiblePagesRange);
2359         for (int i = 0; i &lt; getPageCount(); ++i) {
2360             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2361                 getPageAt(i).setAlpha(1f);
2362             }
2363         }
2364     }
2365 
2366     public boolean startReordering() {
2367         int dragViewIndex = getPageNearestToCenterOfScreen();
2368         mTempVisiblePagesRange[0] = 0;
2369         mTempVisiblePagesRange[1] = getPageCount() - 1;
2370         boundByReorderablePages(true, mTempVisiblePagesRange);
2371         mReorderingStarted = true;
2372 
2373         // Check if we are within the reordering range
2374         if (mTempVisiblePagesRange[0] &lt;= dragViewIndex &amp;&amp;
2375                 dragViewIndex &lt;= mTempVisiblePagesRange[1]) {
2376             if (zoomOut()) {
2377                 // Find the drag view under the pointer
2378                 mDragView = getChildAt(dragViewIndex);
2379 
2380                 onStartReordering();
2381             }
2382             return true;
2383         }
2384         return false;
2385     }
2386 
2387     boolean isReordering(boolean testTouchState) {
2388         boolean state = mIsReordering;
2389         if (testTouchState) {
2390             state &amp;= (mTouchState == TOUCH_STATE_REORDERING);
2391         }
2392         return state;
2393     }
2394     void endReordering() {
2395         // For simplicity, we call endReordering sometimes even if reordering was never started.
2396         // In that case, we don&#x27;t want to do anything.
2397         if (!mReorderingStarted) return;
2398         mReorderingStarted = false;
2399 
2400         // If we haven&#x27;t flung-to-delete the current child, then we just animate the drag view
2401         // back into position
2402         final Runnable onCompleteRunnable = new Runnable() {
2403             @Override
2404             public void run() {
2405                 onEndReordering();
2406             }
2407         };
2408         if (!mDeferringForDelete) {
2409             mPostReorderingPreZoomInRunnable = new Runnable() {
2410                 public void run() {
2411                     zoomIn(onCompleteRunnable);
2412                 };
2413             };
2414 
2415             mPostReorderingPreZoomInRemainingAnimationCount =
2416                     NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT;
2417             // Snap to the current page
2418             snapToPage(indexOfChild(mDragView), 0);
2419             // Animate the drag view back to the front position
2420             animateDragViewToOriginalPosition();
2421         } else {
2422             // Handled in post-delete-animation-callbacks
2423         }
2424     }
2425 
2426     // &quot;Zooms in&quot; the PagedView to highlight the current page
2427     protected boolean zoomIn(final Runnable onCompleteRunnable) {
2428         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2429             mZoomInOutAnim.cancel();
2430         }
2431         if (getScaleX() &lt; 1f || getScaleY() &lt; 1f) {
2432             mZoomInOutAnim = new AnimatorSet();
2433             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2434             mZoomInOutAnim.playTogether(
2435                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 1f),
2436                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, 1f));
2437             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2438                 @Override
2439                 public void onAnimationStart(Animator animation) {
2440                     // Hide the delete drop target
2441                     if (mDeleteDropTarget != null) {
2442                         mDeleteDropTarget.animate().alpha(0f)
2443                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2444                             .setListener(new AnimatorListenerAdapter() {
2445                                 @Override
2446                                 public void onAnimationEnd(Animator animation) {
2447                                     mDeleteDropTarget.setVisibility(View.GONE);
2448                                 }
2449                             });
2450                     }
2451                 }
2452                 @Override
2453                 public void onAnimationCancel(Animator animation) {
2454                     mDragView = null;
2455                 }
2456                 @Override
2457                 public void onAnimationEnd(Animator animation) {
2458                     mDragView = null;
2459                     if (onCompleteRunnable != null) {
2460                         onCompleteRunnable.run();
2461                     }
2462                 }
2463             });
2464             mZoomInOutAnim.start();
2465             return true;
2466         } else {
2467             if (onCompleteRunnable != null) {
2468                 onCompleteRunnable.run();
2469             }
2470         }
2471         return false;
2472     }
2473 
2474     /*
2475      * Flinging to delete - IN PROGRESS
2476      */
2477     private PointF isFlingingToDelete() {
2478         ViewConfiguration config = ViewConfiguration.get(getContext());
2479         mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());
2480 
2481         if (mVelocityTracker.getYVelocity() &lt; mFlingToDeleteThresholdVelocity) {
2482             // Do a quick dot product test to ensure that we are flinging upwards
2483             PointF vel = new PointF(mVelocityTracker.getXVelocity(),
2484                     mVelocityTracker.getYVelocity());
2485             PointF upVec = new PointF(0f, -1f);
2486             float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) /
2487                     (vel.length() * upVec.length()));
2488             if (theta &lt;= Math.toRadians(FLING_TO_DELETE_MAX_FLING_DEGREES)) {
2489                 return vel;
2490             }
2491         }
2492         return null;
2493     }
2494 
2495     /**
2496      * Creates an animation from the current drag view along its current velocity vector.
2497      * For this animation, the alpha runs for a fixed duration and we update the position
2498      * progressively.
2499      */
2500     private static class FlingAlongVectorAnimatorUpdateListener implements AnimatorUpdateListener {
2501         private View mDragView;
2502         private PointF mVelocity;
2503         private Rect mFrom;
2504         private long mPrevTime;
2505         private float mFriction;
2506 
2507         private final TimeInterpolator mAlphaInterpolator = new DecelerateInterpolator(0.75f);
2508 
2509         public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from,
2510                 long startTime, float friction) {
2511             mDragView = dragView;
2512             mVelocity = vel;
2513             mFrom = from;
2514             mPrevTime = startTime;
2515             mFriction = 1f - (mDragView.getResources().getDisplayMetrics().density * friction);
2516         }
2517 
2518         @Override
2519         public void onAnimationUpdate(ValueAnimator animation) {
2520             float t = ((Float) animation.getAnimatedValue()).floatValue();
2521             long curTime = AnimationUtils.currentAnimationTimeMillis();
2522 
2523             mFrom.left += (mVelocity.x * (curTime - mPrevTime) / 1000f);
2524             mFrom.top += (mVelocity.y * (curTime - mPrevTime) / 1000f);
2525 
2526             mDragView.setTranslationX(mFrom.left);
2527             mDragView.setTranslationY(mFrom.top);
2528             mDragView.setAlpha(1f - mAlphaInterpolator.getInterpolation(t));
2529 
2530             mVelocity.x *= mFriction;
2531             mVelocity.y *= mFriction;
2532             mPrevTime = curTime;
2533         }
2534     };
2535 
2536     private static final int ANIM_TAG_KEY = 100;
2537 
2538     private Runnable createPostDeleteAnimationRunnable(final View dragView) {
2539         return new Runnable() {
2540             @Override
2541             public void run() {
2542                 int dragViewIndex = indexOfChild(dragView);
2543 
2544                 // For each of the pages around the drag view, animate them from the previous
2545                 // position to the new position in the layout (as a result of the drag view moving
2546                 // in the layout)
2547                 // NOTE: We can make an assumption here because we have side-bound pages that we
2548                 //       will always have pages to animate in from the left
2549                 getVisiblePages(mTempVisiblePagesRange);
2550                 boundByReorderablePages(true, mTempVisiblePagesRange);
2551                 boolean isLastWidgetPage = (mTempVisiblePagesRange[0] == mTempVisiblePagesRange[1]);
2552                 boolean slideFromLeft = (isLastWidgetPage ||
2553                         dragViewIndex &gt; mTempVisiblePagesRange[0]);
2554 
2555                 // Setup the scroll to the correct page before we swap the views
2556                 if (slideFromLeft) {
2557                     snapToPageImmediately(dragViewIndex - 1);
2558                 }
2559 
2560                 int firstIndex = (isLastWidgetPage ? 0 : mTempVisiblePagesRange[0]);
2561                 int lastIndex = Math.min(mTempVisiblePagesRange[1], getPageCount() - 1);
2562                 int lowerIndex = (slideFromLeft ? firstIndex : dragViewIndex + 1 );
2563                 int upperIndex = (slideFromLeft ? dragViewIndex - 1 : lastIndex);
2564                 ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2565                 for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
2566                     View v = getChildAt(i);
2567                     // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
2568                     // drag view all subsequent views to pageUnderPointIndex will
2569                     // shift down.
2570                     int oldX = 0;
2571                     int newX = 0;
2572                     if (slideFromLeft) {
2573                         if (i == 0) {
2574                             // Simulate the page being offscreen with the page spacing
2575                             oldX = getViewportOffsetX() + getChildOffset(i) - getChildWidth(i)
2576                                     - mPageSpacing;
2577                         } else {
2578                             oldX = getViewportOffsetX() + getChildOffset(i - 1);
2579                         }
2580                         newX = getViewportOffsetX() + getChildOffset(i);
2581                     } else {
2582                         oldX = getChildOffset(i) - getChildOffset(i - 1);
2583                         newX = 0;
2584                     }
2585 
2586                     // Animate the view translation from its old position to its new
2587                     // position
2588                     AnimatorSet anim = (AnimatorSet) v.getTag();
2589                     if (anim != null) {
2590                         anim.cancel();
2591                     }
2592 
2593                     // Note: Hacky, but we want to skip any optimizations to not draw completely
2594                     // hidden views
2595                     v.setAlpha(Math.max(v.getAlpha(), 0.01f));
2596                     v.setTranslationX(oldX - newX);
2597                     anim = new AnimatorSet();
2598                     anim.playTogether(
2599                             ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f),
2600                             ObjectAnimator.ofFloat(v, &quot;alpha&quot;, 1f));
2601                     animations.add(anim);
2602                     v.setTag(ANIM_TAG_KEY, anim);
2603                 }
2604 
2605                 AnimatorSet slideAnimations = new AnimatorSet();
2606                 slideAnimations.playTogether(animations);
2607                 slideAnimations.setDuration(DELETE_SLIDE_IN_SIDE_PAGE_DURATION);
2608                 slideAnimations.addListener(new AnimatorListenerAdapter() {
2609                     @Override
2610                     public void onAnimationEnd(Animator animation) {
2611                         final Runnable onCompleteRunnable = new Runnable() {
2612                             @Override
2613                             public void run() {
2614                                 mDeferringForDelete = false;
2615                                 onEndReordering();
2616                                 onRemoveViewAnimationCompleted();
2617                             }
2618                         };
2619                         zoomIn(onCompleteRunnable);
2620                     }
2621                 });
2622                 slideAnimations.start();
2623 
2624                 removeView(dragView);
2625                 onRemoveView(dragView, true);
2626             }
2627         };
2628     }
2629 
2630     public void onFlingToDelete(PointF vel) {
2631         final long startTime = AnimationUtils.currentAnimationTimeMillis();
2632 
2633         // NOTE: Because it takes time for the first frame of animation to actually be
2634         // called and we expect the animation to be a continuation of the fling, we have
2635         // to account for the time that has elapsed since the fling finished.  And since
2636         // we don&#x27;t have a startDelay, we will always get call to update when we call
2637         // start() (which we want to ignore).
2638         final TimeInterpolator tInterpolator = new TimeInterpolator() {
2639             private int mCount = -1;
2640             private long mStartTime;
2641             private float mOffset;
2642             /* Anonymous inner class ctor */ {
2643                 mStartTime = startTime;
2644             }
2645 
2646             @Override
2647             public float getInterpolation(float t) {
2648                 if (mCount &lt; 0) {
2649                     mCount++;
2650                 } else if (mCount == 0) {
2651                     mOffset = Math.min(0.5f, (float) (AnimationUtils.currentAnimationTimeMillis() -
2652                             mStartTime) / FLING_TO_DELETE_FADE_OUT_DURATION);
2653                     mCount++;
2654                 }
2655                 return Math.min(1f, mOffset + t);
2656             }
2657         };
2658 
2659         final Rect from = new Rect();
2660         final View dragView = mDragView;
2661         from.left = (int) dragView.getTranslationX();
2662         from.top = (int) dragView.getTranslationY();
2663         AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel,
2664                 from, startTime, FLING_TO_DELETE_FRICTION);
2665 
2666         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2667 
2668         // Create and start the animation
2669         ValueAnimator mDropAnim = new ValueAnimator();
2670         mDropAnim.setInterpolator(tInterpolator);
2671         mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
2672         mDropAnim.setFloatValues(0f, 1f);
2673         mDropAnim.addUpdateListener(updateCb);
2674         mDropAnim.addListener(new AnimatorListenerAdapter() {
2675             public void onAnimationEnd(Animator animation) {
2676                 onAnimationEndRunnable.run();
2677             }
2678         });
2679         mDropAnim.start();
2680         mDeferringForDelete = true;
2681     }
2682 
2683     /* Drag to delete */
2684     private boolean isHoveringOverDeleteDropTarget(int x, int y) {
2685         if (mDeleteDropTarget != null) {
2686             mAltTmpRect.set(0, 0, 0, 0);
2687             View parent = (View) mDeleteDropTarget.getParent();
2688             if (parent != null) {
2689                 parent.getGlobalVisibleRect(mAltTmpRect);
2690             }
2691             mDeleteDropTarget.getGlobalVisibleRect(mTmpRect);
2692             mTmpRect.offset(-mAltTmpRect.left, -mAltTmpRect.top);
2693             return mTmpRect.contains(x, y);
2694         }
2695         return false;
2696     }
2697 
2698     protected void setPageHoveringOverDeleteDropTarget(int viewIndex, boolean isHovering) {}
2699 
2700     private void onDropToDelete() {
2701         final View dragView = mDragView;
2702 
2703         final float toScale = 0f;
2704         final float toAlpha = 0f;
2705 
2706         // Create and start the complex animation
2707         ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2708         AnimatorSet motionAnim = new AnimatorSet();
2709         motionAnim.setInterpolator(new DecelerateInterpolator(2));
2710         motionAnim.playTogether(
2711                 ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale),
2712                 ObjectAnimator.ofFloat(dragView, &quot;scaleY&quot;, toScale));
2713         animations.add(motionAnim);
2714 
2715         AnimatorSet alphaAnim = new AnimatorSet();
2716         alphaAnim.setInterpolator(new LinearInterpolator());
2717         alphaAnim.playTogether(
2718                 ObjectAnimator.ofFloat(dragView, &quot;alpha&quot;, toAlpha));
2719         animations.add(alphaAnim);
2720 
2721         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2722 
2723         AnimatorSet anim = new AnimatorSet();
2724         anim.playTogether(animations);
2725         anim.setDuration(DRAG_TO_DELETE_FADE_OUT_DURATION);
2726         anim.addListener(new AnimatorListenerAdapter() {
2727             public void onAnimationEnd(Animator animation) {
2728                 onAnimationEndRunnable.run();
2729             }
2730         });
2731         anim.start();
2732 
2733         mDeferringForDelete = true;
2734     }
2735 
2736     /* Accessibility */
2737     @Override
2738     public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
2739         super.onInitializeAccessibilityNodeInfo(info);
2740         info.setScrollable(getPageCount() &gt; 1);
2741         if (getCurrentPage() &lt; getPageCount() - 1) {
2742             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
2743         }
2744         if (getCurrentPage() &gt; 0) {
2745             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
2746         }
2747     }
2748 
2749     @Override
2750     public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
2751         super.onInitializeAccessibilityEvent(event);
2752         event.setScrollable(true);
2753         if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
2754             event.setFromIndex(mCurrentPage);
2755             event.setToIndex(mCurrentPage);
2756             event.setItemCount(getChildCount());
2757         }
2758     }
2759 
2760     @Override
2761     public boolean performAccessibilityAction(int action, Bundle arguments) {
2762         if (super.performAccessibilityAction(action, arguments)) {
2763             return true;
2764         }
2765         switch (action) {
2766             case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
2767                 if (getCurrentPage() &lt; getPageCount() - 1) {
2768                     scrollRight();
2769                     return true;
2770                 }
2771             } break;
2772             case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
2773                 if (getCurrentPage() &gt; 0) {
2774                     scrollLeft();
2775                     return true;
2776                 }
2777             } break;
2778         }
2779         return false;
2780     }
2781 
2782     protected String getCurrentPageDescription() {
2783         return String.format(getContext().getString(R.string.default_scroll_format),
2784                 getNextPage() + 1, getChildCount());
2785     }
2786 
2787     @Override
2788     public boolean onHoverEvent(android.view.MotionEvent event) {
2789         return true;
2790     }
2791 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2012 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.ObjectAnimator;
  23 import android.animation.TimeInterpolator;
  24 import android.animation.ValueAnimator;
  25 import android.animation.ValueAnimator.AnimatorUpdateListener;
  26 import android.content.Context;
  27 import android.content.res.Resources;
  28 import android.content.res.TypedArray;
  29 import android.graphics.Canvas;
  30 import android.graphics.Matrix;
  31 import android.graphics.PointF;
  32 import android.graphics.Rect;
  33 import android.os.Bundle;
  34 import android.os.Parcel;
  35 import android.os.Parcelable;
  36 import android.util.AttributeSet;
  37 import android.util.DisplayMetrics;
  38 import android.util.Log;
  39 import android.view.InputDevice;
  40 import android.view.KeyEvent;
  41 import android.view.MotionEvent;
  42 import android.view.VelocityTracker;
  43 import android.view.View;
  44 import android.view.ViewConfiguration;
  45 import android.view.ViewGroup;
  46 import android.view.ViewParent;
  47 import android.view.ViewGroup.LayoutParams;
  48 import android.view.accessibility.AccessibilityEvent;
  49 import android.view.accessibility.AccessibilityManager;
  50 import android.view.accessibility.AccessibilityNodeInfo;
  51 import android.view.animation.AnimationUtils;
  52 import android.view.animation.DecelerateInterpolator;
  53 import android.view.animation.Interpolator;
  54 import android.view.animation.LinearInterpolator;
  55 import android.widget.FrameLayout;
  56 import android.widget.Scroller;
  57 
  58 import java.util.ArrayList;
  59 
  60 /**
  61  * An abstraction of the original Workspace which supports browsing through a
  62  * sequential list of &quot;pages&quot;
  63  */
  64 public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
  65     private static final String TAG = &quot;PagedView&quot;;
  66     private static final boolean DEBUG = false;
  67     protected static final int INVALID_PAGE = -1;
  68 
  69     // the min drag distance for a fling to register, to prevent random page shifts
  70     private static final int MIN_LENGTH_FOR_FLING = 25;
  71 
  72     protected static final int PAGE_SNAP_ANIMATION_DURATION = 750;
  73     protected static final int SLOW_PAGE_SNAP_ANIMATION_DURATION = 950;
  74     protected static final float NANOTIME_DIV = 1000000000.0f;
  75 
  76     private static final float OVERSCROLL_ACCELERATE_FACTOR = 2;
  77     private static final float OVERSCROLL_DAMP_FACTOR = 0.14f;
  78 
  79     private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD = 0.33f;
  80     // The page is moved more than halfway, automatically move to the next page on touch up.
  81     private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
  82 
  83     // The following constants need to be scaled based on density. The scaled versions will be
  84     // assigned to the corresponding member variables below.
  85     private static final int FLING_THRESHOLD_VELOCITY = 500;
  86     private static final int MIN_SNAP_VELOCITY = 1500;
  87     private static final int MIN_FLING_VELOCITY = 250;
  88 
  89     // We are disabling touch interaction of the widget region for factory ROM.
  90     private static final boolean DISABLE_TOUCH_INTERACTION = false;
  91     private static final boolean DISABLE_TOUCH_SIDE_PAGES = false;
  92     private static final boolean DISABLE_FLING_TO_DELETE = true;
  93 
  94     static final int AUTOMATIC_PAGE_SPACING = -1;
  95 
  96     protected int mFlingThresholdVelocity;
  97     protected int mMinFlingVelocity;
  98     protected int mMinSnapVelocity;
  99 
 100     protected float mDensity;
 101     protected float mSmoothingTime;
 102     protected float mTouchX;
 103 
 104     protected boolean mFirstLayout = true;
 105 
 106     protected int mCurrentPage;
 107     protected int mChildCountOnLastMeasure;
 108 
 109     protected int mNextPage = INVALID_PAGE;
 110     protected int mMaxScrollX;
 111     protected Scroller mScroller;
 112     private VelocityTracker mVelocityTracker;
 113 
 114     private float mParentDownMotionX;
 115     private float mParentDownMotionY;
 116     private float mDownMotionX;
 117     private float mDownMotionY;
 118     private float mDownScrollX;
 119     protected float mLastMotionX;
 120     protected float mLastMotionXRemainder;
 121     protected float mLastMotionY;
 122     protected float mTotalMotionX;
 123     private int mLastScreenCenter = -1;
 124     private int[] mChildOffsets;
 125     private int[] mChildRelativeOffsets;
 126 
 127     protected final static int TOUCH_STATE_REST = 0;
 128     protected final static int TOUCH_STATE_SCROLLING = 1;
 129     protected final static int TOUCH_STATE_PREV_PAGE = 2;
 130     protected final static int TOUCH_STATE_NEXT_PAGE = 3;
 131     protected final static int TOUCH_STATE_REORDERING = 4;
 132 
 133     protected final static float ALPHA_QUANTIZE_LEVEL = 0.0001f;
 134 
 135     protected int mTouchState = TOUCH_STATE_REST;
 136     protected boolean mForceScreenScrolled = false;
 137 
 138     protected OnLongClickListener mLongClickListener;
 139 
 140     protected int mTouchSlop;
 141     private int mPagingTouchSlop;
 142     private int mMaximumVelocity;
 143     protected int mPageSpacing;
 144     protected int mPageLayoutPaddingTop;
 145     protected int mPageLayoutPaddingBottom;
 146     protected int mPageLayoutPaddingLeft;
 147     protected int mPageLayoutPaddingRight;
 148     protected int mPageLayoutWidthGap;
 149     protected int mPageLayoutHeightGap;
 150     protected int mCellCountX = 0;
 151     protected int mCellCountY = 0;
 152     protected boolean mCenterPagesVertically;
 153     protected boolean mAllowOverScroll = true;
 154     protected int mUnboundedScrollX;
 155     protected int[] mTempVisiblePagesRange = new int[2];
 156     protected boolean mForceDrawAllChildrenNextFrame;
 157 
 158     // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 159     // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 160     // the screens from continuing to translate beyond the normal bounds.
 161     protected int mOverScrollX;
 162 
 163     protected static final int INVALID_POINTER = -1;
 164 
 165     protected int mActivePointerId = INVALID_POINTER;
 166 
 167     private PageSwitchListener mPageSwitchListener;
 168 
 169     protected ArrayList&lt;Boolean&gt; mDirtyPageContent;
 170 
 171     // If true, syncPages and syncPageItems will be called to refresh pages
 172     protected boolean mContentIsRefreshable = true;
 173 
 174     // If true, modify alpha of neighboring pages as user scrolls left/right
 175     protected boolean mFadeInAdjacentScreens = false;
 176 
 177     // It true, use a different slop parameter (pagingTouchSlop = 2 * touchSlop) for deciding
 178     // to switch to a new page
 179     protected boolean mUsePagingTouchSlop = true;
 180 
 181     // If true, the subclass should directly update scrollX itself in its computeScroll method
 182     // (SmoothPagedView does this)
 183     protected boolean mDeferScrollUpdate = false;
 184 
 185     protected boolean mIsPageMoving = false;
 186 
 187     // All syncs and layout passes are deferred until data is ready.
 188     protected boolean mIsDataReady = false;
 189 
 190     protected boolean mAllowLongPress = true;
 191 
 192     // Page Indicator
 193     private int mPageIndicatorViewId;
 194     private PageIndicator mPageIndicator;
 195 
 196     // The viewport whether the pages are to be contained (the actual view may be larger than the
 197     // viewport)
 198     private Rect mViewport = new Rect();
 199 
 200     // Reordering
 201     // We use the min scale to determine how much to expand the actually PagedView measured
 202     // dimensions such that when we are zoomed out, the view is not clipped
 203     private int REORDERING_DROP_REPOSITION_DURATION = 200;
 204     protected int REORDERING_REORDER_REPOSITION_DURATION = 300;
 205     protected int REORDERING_ZOOM_IN_OUT_DURATION = 250;
 206     private int REORDERING_SIDE_PAGE_HOVER_TIMEOUT = 300;
 207     private float REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE = 0.1f;
 208     private long REORDERING_DELETE_DROP_TARGET_FADE_DURATION = 150;
 209     private float mMinScale = 1f;
 210     protected View mDragView;
 211     protected AnimatorSet mZoomInOutAnim;
 212     private Runnable mSidePageHoverRunnable;
 213     private int mSidePageHoverIndex = -1;
 214     // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 215     private boolean mReorderingStarted = false;
 216     // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 217     // animation after endReordering()
 218     private boolean mIsReordering;
 219     // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 220     private int NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT = 2;
 221     private int mPostReorderingPreZoomInRemainingAnimationCount;
 222     private Runnable mPostReorderingPreZoomInRunnable;
 223 
 224     // Edge swiping
 225     private boolean mOnlyAllowEdgeSwipes = false;
 226     private boolean mDownEventOnEdge = false;
 227     private int mEdgeSwipeRegionSize = 0;
 228 
 229     // Convenience/caching
 230     private Matrix mTmpInvMatrix = new Matrix();
 231     private float[] mTmpPoint = new float[2];
 232     private Rect mTmpRect = new Rect();
 233     private Rect mAltTmpRect = new Rect();
 234 
 235     // Fling to delete
 236     private int FLING_TO_DELETE_FADE_OUT_DURATION = 350;
 237     private float FLING_TO_DELETE_FRICTION = 0.035f;
 238     // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 239     private float FLING_TO_DELETE_MAX_FLING_DEGREES = 65f;
 240     protected int mFlingToDeleteThresholdVelocity = -1400;
 241     // Drag to delete
 242     private boolean mDeferringForDelete = false;
 243     private int DELETE_SLIDE_IN_SIDE_PAGE_DURATION = 250;
 244     private int DRAG_TO_DELETE_FADE_OUT_DURATION = 350;
 245 
 246     // Drop to delete
 247     private View mDeleteDropTarget;
 248 
 249     private boolean mAutoComputePageSpacing = false;
 250     private boolean mRecomputePageSpacing = false;
 251 
 252     // Bouncer
 253     private boolean mTopAlignPageWhenShrinkingForBouncer = false;
 254 
 255     public interface PageSwitchListener {
 256         void onPageSwitch(View newPage, int newPageIndex);
 257     }
 258 
 259     public PagedView(Context context) {
 260         this(context, null);
 261     }
 262 
 263     public PagedView(Context context, AttributeSet attrs) {
 264         this(context, attrs, 0);
 265     }
 266 
 267     public PagedView(Context context, AttributeSet attrs, int defStyle) {
 268         super(context, attrs, defStyle);
 269         TypedArray a = context.obtainStyledAttributes(attrs,
 270                 R.styleable.PagedView, defStyle, 0);
 271         setPageSpacing(a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing, 0));
 272         if (mPageSpacing &lt; 0) {
 273             mAutoComputePageSpacing = mRecomputePageSpacing = true;
 274         }
 275         mPageLayoutPaddingTop = a.getDimensionPixelSize(
 276                 R.styleable.PagedView_pageLayoutPaddingTop, 0);
 277         mPageLayoutPaddingBottom = a.getDimensionPixelSize(
 278                 R.styleable.PagedView_pageLayoutPaddingBottom, 0);
 279         mPageLayoutPaddingLeft = a.getDimensionPixelSize(
 280                 R.styleable.PagedView_pageLayoutPaddingLeft, 0);
 281         mPageLayoutPaddingRight = a.getDimensionPixelSize(
 282                 R.styleable.PagedView_pageLayoutPaddingRight, 0);
 283         mPageLayoutWidthGap = a.getDimensionPixelSize(
 284                 R.styleable.PagedView_pageLayoutWidthGap, 0);
 285         mPageLayoutHeightGap = a.getDimensionPixelSize(
 286                 R.styleable.PagedView_pageLayoutHeightGap, 0);
 287         mPageIndicatorViewId = a.getResourceId(R.styleable.PagedView_pageIndicator, -1);
 288         a.recycle();
 289 
 290         setHapticFeedbackEnabled(false);
 291         init();
 292     }
 293 
 294     /**
 295      * Initializes various states for this workspace.
 296      */
 297     protected void init() {
 298         mDirtyPageContent = new ArrayList&lt;Boolean&gt;();
 299         mDirtyPageContent.ensureCapacity(32);
 300         mScroller = new Scroller(getContext(), new ScrollInterpolator());
 301         mCurrentPage = 0;
 302         mCenterPagesVertically = true;
 303 
 304         final ViewConfiguration configuration = ViewConfiguration.get(getContext());
 305         mTouchSlop = configuration.getScaledPagingTouchSlop();
 306         mPagingTouchSlop = configuration.getScaledPagingTouchSlop();
 307         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
 308         mDensity = getResources().getDisplayMetrics().density;
 309 
 310         // Scale the fling-to-delete threshold by the density
 311         mFlingToDeleteThresholdVelocity =
 312                 (int) (mFlingToDeleteThresholdVelocity * mDensity);
 313 
 314         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 315         mMinFlingVelocity = (int) (MIN_FLING_VELOCITY * mDensity);
 316         mMinSnapVelocity = (int) (MIN_SNAP_VELOCITY * mDensity);
 317         setOnHierarchyChangeListener(this);
 318     }
 319 
 320     protected void onAttachedToWindow() {
 321         // Hook up the page indicator
 322         ViewGroup parent = (ViewGroup) getParent();
 323         if (mPageIndicator == null &amp;&amp; mPageIndicatorViewId &gt; -1) {
 324             mPageIndicator = (PageIndicator) parent.findViewById(mPageIndicatorViewId);
 325             mPageIndicator.removeAllMarkers();
 326             mPageIndicator.addMarkers(getChildCount());
 327         }
 328     }
 329 
 330     protected void onDetachedFromWindow() {
 331         // Unhook the page indicator
 332         mPageIndicator = null;
 333     }
 334 
 335     void setDeleteDropTarget(View v) {
 336         mDeleteDropTarget = v;
 337     }
 338 
 339     // Convenience methods to map points from self to parent and vice versa
 340     float[] mapPointFromViewToParent(View v, float x, float y) {
 341         mTmpPoint[0] = x;
 342         mTmpPoint[1] = y;
 343         v.getMatrix().mapPoints(mTmpPoint);
 344         mTmpPoint[0] += v.getLeft();
 345         mTmpPoint[1] += v.getTop();
 346         return mTmpPoint;
 347     }
 348     float[] mapPointFromParentToView(View v, float x, float y) {
 349         mTmpPoint[0] = x - v.getLeft();
 350         mTmpPoint[1] = y - v.getTop();
 351         v.getMatrix().invert(mTmpInvMatrix);
 352         mTmpInvMatrix.mapPoints(mTmpPoint);
 353         return mTmpPoint;
 354     }
 355 
 356     void updateDragViewTranslationDuringDrag() {
 357         float x = mLastMotionX - mDownMotionX + getScrollX() - mDownScrollX;
 358         float y = mLastMotionY - mDownMotionY;
 359         mDragView.setTranslationX(x);
 360         mDragView.setTranslationY(y);
 361 
 362         if (DEBUG) Log.d(TAG, &quot;PagedView.updateDragViewTranslationDuringDrag(): &quot; + x + &quot;, &quot; + y);
 363     }
 364 
 365     public void setMinScale(float f) {
 366         mMinScale = f;
 367         requestLayout();
 368     }
 369 
 370     @Override
 371     public void setScaleX(float scaleX) {
 372         super.setScaleX(scaleX);
 373         if (isReordering(true)) {
 374             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 375             mLastMotionX = p[0];
 376             mLastMotionY = p[1];
 377             updateDragViewTranslationDuringDrag();
 378         }
 379     }
 380 
 381     // Convenience methods to get the actual width/height of the PagedView (since it is measured
 382     // to be larger to account for the minimum possible scale)
 383     int getViewportWidth() {
 384         return mViewport.width();
 385     }
 386     int getViewportHeight() {
 387         return mViewport.height();
 388     }
 389 
 390     // Convenience methods to get the offset ASSUMING that we are centering the pages in the
 391     // PagedView both horizontally and vertically
 392     int getViewportOffsetX() {
 393         return (getMeasuredWidth() - getViewportWidth()) / 2;
 394     }
 395 
 396     int getViewportOffsetY() {
 397         return (getMeasuredHeight() - getViewportHeight()) / 2;
 398     }
 399 
 400     public void setPageSwitchListener(PageSwitchListener pageSwitchListener) {
 401         mPageSwitchListener = pageSwitchListener;
 402         if (mPageSwitchListener != null) {
 403             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 404         }
 405     }
 406 
 407     /**
 408      * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.
 409      */
 410     public boolean isLayoutRtl() {
 411         return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
 412     }
 413 
 414     /**
 415      * Called by subclasses to mark that data is ready, and that we can begin loading and laying
 416      * out pages.
 417      */
 418     protected void setDataIsReady() {
 419         mIsDataReady = true;
 420     }
 421 
 422     protected boolean isDataReady() {
 423         return mIsDataReady;
 424     }
 425 
 426     /**
 427      * Returns the index of the currently displayed page.
 428      *
 429      * @return The index of the currently displayed page.
 430      */
 431     int getCurrentPage() {
 432         return mCurrentPage;
 433     }
 434 
 435     int getNextPage() {
 436         return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
 437     }
 438 
 439     int getPageCount() {
 440         return getChildCount();
 441     }
 442 
 443     View getPageAt(int index) {
 444         return getChildAt(index);
 445     }
 446 
 447     protected int indexToPage(int index) {
 448         return index;
 449     }
 450 
 451     /**
 452      * Updates the scroll of the current page immediately to its final scroll position.  We use this
 453      * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of
 454      * the previous tab page.
 455      */
 456     protected void updateCurrentPageScroll() {
 457         // If the current page is invalid, just reset the scroll position to zero
 458         int newX = 0;
 459         if (0 &lt;= mCurrentPage &amp;&amp; mCurrentPage &lt; getPageCount()) {
 460             int offset = getChildOffset(mCurrentPage);
 461             int relOffset = getRelativeChildOffset(mCurrentPage);
 462             newX = offset - relOffset;
 463         }
 464         scrollTo(newX, 0);
 465         mScroller.setFinalX(newX);
 466         mScroller.forceFinished(true);
 467     }
 468 
 469     /**
 470      * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation
 471      * ends, {@link #resumeScrolling()} should be called, along with
 472      * {@link #updateCurrentPageScroll()} to correctly set the final state and re-enable scrolling.
 473      */
 474     void pauseScrolling() {
 475         mScroller.forceFinished(true);
 476     }
 477 
 478     /**
 479      * Enables scrolling again.
 480      * @see #pauseScrolling()
 481      */
 482     void resumeScrolling() {
 483     }
 484     /**
 485      * Sets the current page.
 486      */
 487     void setCurrentPage(int currentPage) {
 488         if (!mScroller.isFinished()) {
 489             mScroller.abortAnimation();
 490         }
 491         // don&#x27;t introduce any checks like mCurrentPage == currentPage here-- if we change the
 492         // the default
 493         if (getChildCount() == 0) {
 494             return;
 495         }
 496 
 497         mForceScreenScrolled = true;
 498         mCurrentPage = Math.max(0, Math.min(currentPage, getPageCount() - 1));
 499         notifyPageSwitchListener();
 500         invalidate();
 501     }
 502 
 503     protected void notifyPageSwitchListener() {
 504         if (mPageSwitchListener != null) {
 505             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 506         }
 507 
 508         // Update the page indicator (when we aren&#x27;t reordering)
 509         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 510             mPageIndicator.setActiveMarker(getNextPage());
 511         }
 512     }
 513     protected void pageBeginMoving() {
 514         if (!mIsPageMoving) {
 515             mIsPageMoving = true;
 516             onPageBeginMoving();
 517         }
 518     }
 519 
 520     protected void pageEndMoving() {
 521         if (mIsPageMoving) {
 522             mIsPageMoving = false;
 523             onPageEndMoving();
 524         }
 525     }
 526 
 527     protected boolean isPageMoving() {
 528         return mIsPageMoving;
 529     }
 530 
 531     // a method that subclasses can override to add behavior
 532     protected void onPageBeginMoving() {
 533     }
 534 
 535     // a method that subclasses can override to add behavior
 536     protected void onPageEndMoving() {
 537     }
 538 
 539     /**
 540      * Registers the specified listener on each page contained in this workspace.
 541      *
 542      * @param l The listener used to respond to long clicks.
 543      */
 544     @Override
 545     public void setOnLongClickListener(OnLongClickListener l) {
 546         mLongClickListener = l;
 547         final int count = getPageCount();
 548         for (int i = 0; i &lt; count; i++) {
 549             getPageAt(i).setOnLongClickListener(l);
 550         }
 551     }
 552 
 553     @Override
 554     public void scrollBy(int x, int y) {
 555         scrollTo(mUnboundedScrollX + x, getScrollY() + y);
 556     }
 557 
 558     @Override
 559     public void scrollTo(int x, int y) {
 560         final boolean isRtl = isLayoutRtl();
 561         mUnboundedScrollX = x;
 562 
 563         boolean isXBeforeFirstPage = isRtl ? (x &gt; mMaxScrollX) : (x &lt; 0);
 564         boolean isXAfterLastPage = isRtl ? (x &lt; 0) : (x &gt; mMaxScrollX);
 565         if (isXBeforeFirstPage) {
 566             super.scrollTo(0, y);
 567             if (mAllowOverScroll) {
 568                 if (isRtl) {
 569                     overScroll(x - mMaxScrollX);
 570                 } else {
 571                     overScroll(x);
 572                 }
 573             }
 574         } else if (isXAfterLastPage) {
 575             super.scrollTo(mMaxScrollX, y);
 576             if (mAllowOverScroll) {
 577                 if (isRtl) {
 578                     overScroll(x);
 579                 } else {
 580                     overScroll(x - mMaxScrollX);
 581                 }
 582             }
 583         } else {
 584             mOverScrollX = x;
 585             super.scrollTo(x, y);
 586         }
 587 
 588         mTouchX = x;
 589         mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
 590 
 591         // Update the last motion events when scrolling
 592         if (isReordering(true)) {
 593             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 594             mLastMotionX = p[0];
 595             mLastMotionY = p[1];
 596             updateDragViewTranslationDuringDrag();
 597         }
 598     }
 599 
 600     // we moved this functionality to a helper function so SmoothPagedView can reuse it
 601     protected boolean computeScrollHelper() {
 602         if (mScroller.computeScrollOffset()) {
 603             // Don&#x27;t bother scrolling if the page does not need to be moved
 604             if (getScrollX() != mScroller.getCurrX()
 605                 || getScrollY() != mScroller.getCurrY()
 606                 || mOverScrollX != mScroller.getCurrX()) {
 607                 scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
 608             }
 609             invalidate();
 610             return true;
 611         } else if (mNextPage != INVALID_PAGE) {
 612             mCurrentPage = Math.max(0, Math.min(mNextPage, getPageCount() - 1));
 613             mNextPage = INVALID_PAGE;
 614             notifyPageSwitchListener();
 615 
 616             // We don&#x27;t want to trigger a page end moving unless the page has settled
 617             // and the user has stopped scrolling
 618             if (mTouchState == TOUCH_STATE_REST) {
 619                 pageEndMoving();
 620             }
 621 
 622             onPostReorderingAnimationCompleted();
 623             // Notify the user when the page changes
 624             AccessibilityManager accessibilityManager = (AccessibilityManager)
 625                     getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
 626             if (accessibilityManager.isEnabled()) {
 627                 AccessibilityEvent ev =
 628                     AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
 629                 ev.getText().add(getCurrentPageDescription());
 630                 sendAccessibilityEventUnchecked(ev);
 631             }
 632             return true;
 633         }
 634         return false;
 635     }
 636 
 637     @Override
 638     public void computeScroll() {
 639         computeScrollHelper();
 640     }
 641 
 642     protected boolean shouldSetTopAlignedPivotForWidget(int childIndex) {
 643         return mTopAlignPageWhenShrinkingForBouncer;
 644     }
 645 
 646     public static class LayoutParams extends ViewGroup.LayoutParams {
 647         public boolean isFullScreenPage = false;
 648 
 649         /**
 650          * {@inheritDoc}
 651          */
 652         public LayoutParams(int width, int height) {
 653             super(width, height);
 654         }
 655 
 656         public LayoutParams(ViewGroup.LayoutParams source) {
 657             super(source);
 658         }
 659     }
 660 
 661     protected LayoutParams generateDefaultLayoutParams() {
 662         return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
 663     }
 664 
 665     public void addFullScreenPage(View page, int width, int height) {
 666         LayoutParams lp = generateDefaultLayoutParams();
 667         lp.isFullScreenPage = true;
 668         super.addView(page, 0, lp);
 669     }
 670 
 671     @Override
 672     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 673         if (!mIsDataReady || getChildCount() == 0) {
 674             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 675             return;
 676         }
 677 
 678         // We measure the dimensions of the PagedView to be larger than the pages so that when we
 679         // zoom out (and scale down), the view is still contained in the parent
 680         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
 681         int widthSize = MeasureSpec.getSize(widthMeasureSpec);
 682         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
 683         int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 684         // NOTE: We multiply by 1.5f to account for the fact that depending on the offset of the
 685         // viewport, we can be at most one and a half screens offset once we scale down
 686         DisplayMetrics dm = getResources().getDisplayMetrics();
 687         int maxSize = Math.max(dm.widthPixels, dm.heightPixels);
 688         int parentWidthSize = (int) (1.5f * maxSize);
 689         int parentHeightSize = maxSize;
 690         int scaledWidthSize = (int) (parentWidthSize / mMinScale);
 691         int scaledHeightSize = (int) (parentHeightSize / mMinScale);
 692         mViewport.set(0, 0, widthSize, heightSize);
 693 
 694         if (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {
 695             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 696             return;
 697         }
 698 
 699         // Return early if we aren&#x27;t given a proper dimension
 700         if (widthSize &lt;= 0 || heightSize &lt;= 0) {
 701             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 702             return;
 703         }
 704 
 705         /* Allow the height to be set as WRAP_CONTENT. This allows the particular case
 706          * of the All apps view on XLarge displays to not take up more space then it needs. Width
 707          * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect
 708          * each page to have the same width.
 709          */
 710         final int verticalPadding = getPaddingTop() + getPaddingBottom();
 711         final int horizontalPadding = getPaddingLeft() + getPaddingRight();
 712 
 713         // The children are given the same width and height as the workspace
 714         // unless they were set to WRAP_CONTENT
 715         if (DEBUG) Log.d(TAG, &quot;PagedView.onMeasure(): &quot; + widthSize + &quot;, &quot; + heightSize);
 716         if (DEBUG) Log.d(TAG, &quot;PagedView.scaledSize: &quot; + scaledWidthSize + &quot;, &quot; + scaledHeightSize);
 717         if (DEBUG) Log.d(TAG, &quot;PagedView.parentSize: &quot; + parentWidthSize + &quot;, &quot; + parentHeightSize);
 718         if (DEBUG) Log.d(TAG, &quot;PagedView.horizontalPadding: &quot; + horizontalPadding);
 719         if (DEBUG) Log.d(TAG, &quot;PagedView.verticalPadding: &quot; + verticalPadding);
 720         final int childCount = getChildCount();
 721         for (int i = 0; i &lt; childCount; i++) {
 722             // disallowing padding in paged view (just pass 0)
 723             final View child = getPageAt(i);
 724             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 725 
 726             int childWidthMode;
 727             int childHeightMode;
 728             int childWidth;
 729             int childHeight;
 730 
 731             if (!lp.isFullScreenPage) {
 732             if (lp.width == LayoutParams.WRAP_CONTENT) {
 733                 childWidthMode = MeasureSpec.AT_MOST;
 734             } else {
 735                 childWidthMode = MeasureSpec.EXACTLY;
 736             }
 737 
 738             if (lp.height == LayoutParams.WRAP_CONTENT) {
 739                 childHeightMode = MeasureSpec.AT_MOST;
 740             } else {
 741                 childHeightMode = MeasureSpec.EXACTLY;
 742             }
 743 
 744                 childWidth = widthSize - horizontalPadding;
 745                 childHeight = heightSize - verticalPadding;
 746 
 747             } else {
 748                 childWidthMode = MeasureSpec.EXACTLY;
 749                 childHeightMode = MeasureSpec.EXACTLY;
 750 
 751                 childWidth = getViewportWidth();
 752                 childHeight = getViewportHeight();
 753             }
 754 
 755             final int childWidthMeasureSpec =
 756                     MeasureSpec.makeMeasureSpec(childWidth, childWidthMode);
 757                 final int childHeightMeasureSpec =
 758                     MeasureSpec.makeMeasureSpec(childHeight, childHeightMode);
 759             child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 760         }
 761         setMeasuredDimension(scaledWidthSize, scaledHeightSize);
 762 
 763         // We can&#x27;t call getChildOffset/getRelativeChildOffset until we set the measured dimensions.
 764         // We also wait until we set the measured dimensions before flushing the cache as well, to
 765         // ensure that the cache is filled with good values.
 766         invalidateCachedOffsets();
 767 
 768         if (childCount &gt; 0) {
 769             if (DEBUG) Log.d(TAG, &quot;getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
 770                     + getChildWidth(0));
 771 
 772             // Calculate the variable page spacing if necessary
 773             if (mAutoComputePageSpacing &amp;&amp; mRecomputePageSpacing) {
 774                 // The gap between pages in the PagedView should be equal to the gap from the page
 775                 // to the edge of the screen (so it is not visible in the current screen).  To
 776                 // account for unequal padding on each side of the paged view, we take the maximum
 777                 // of the left/right gap and use that as the gap between each page.
 778                 int offset = getRelativeChildOffset(0);
 779                 int spacing = Math.max(offset, widthSize - offset -
 780                         getChildAt(0).getMeasuredWidth());
 781                 setPageSpacing(spacing);
 782                 mRecomputePageSpacing = false;
 783             }
 784         }
 785 
 786 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 787 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 788         updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 789 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 790         if (childCount &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 791             final int index = isLayoutRtl() ? 0 : childCount - 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 792             mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 793         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 794             mMaxScrollX = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 795         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 796     }</span>
 797 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 798         if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 799                 !mDeferringForDelete) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 800             setCurrentPage(getNextPage());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 801         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 802         mChildCountOnLastMeasure = getChildCount();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 803 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 804         updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 805 </span>
 806 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 807         if (childCount &gt; 0) {
 808             final int index = isLayoutRtl() ? 0 : childCount - 1;
 809             mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);
 810         } else {
 811             mMaxScrollX = 0;
 812         }
 813     }
 814 
 815     public void setPageSpacing(int pageSpacing) {
 816         mPageSpacing = pageSpacing;
 817         invalidateCachedOffsets();
 818     }
 819 
 820     @Override
 821     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 822         if (!mIsDataReady || getChildCount() == 0) {
 823             return;
 824         }
 825 
 826         if (DEBUG) Log.d(TAG, &quot;PagedView.onLayout()&quot;);
 827         final int childCount = getChildCount();
 828 
 829         int offsetX = getViewportOffsetX();
 830         int offsetY = getViewportOffsetY();
 831 
 832         // Update the viewport offsets
 833         mViewport.offset(offsetX,  offsetY);
 834 
 835         final boolean isRtl = isLayoutRtl();
 836 
 837         final int startIndex = isRtl ? childCount - 1 : 0;
 838         final int endIndex = isRtl ? -1 : childCount;
 839         final int delta = isRtl ? -1 : 1;
 840 
 841         int verticalPadding = getPaddingTop() + getPaddingBottom();
 842         int childLeft = offsetX + getRelativeChildOffset(startIndex);
 843         for (int i = startIndex; i != endIndex; i += delta) {
 844             final View child = getPageAt(i);
 845             LayoutParams lp = (LayoutParams) child.getLayoutParams();
 846             int childTop;
 847 
 848             if (lp.isFullScreenPage) {
 849                 childTop = offsetY;
 850             } else {
 851                 childTop = offsetY + getPaddingTop();
 852             if (mCenterPagesVertically) {
 853                 childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;
 854             }
 855             }
 856 
 857             if (child.getVisibility() != View.GONE) {
 858                 final int childWidth = child.getMeasuredWidth();
 859                 final int childHeight = child.getMeasuredHeight();
 860 
 861                 if (DEBUG) Log.d(TAG, &quot;\tlayout-child&quot; + i + &quot;: &quot; + childLeft + &quot;, &quot; + childTop);
 862                 child.layout(childLeft, childTop,
 863                         childLeft + child.getMeasuredWidth(), childTop + childHeight);
 864                 childLeft += childWidth + mPageSpacing;
 865             }
 866         }
 867 
 868         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
 869             setHorizontalScrollBarEnabled(false);
 870             updateCurrentPageScroll();
 871             setHorizontalScrollBarEnabled(true);
 872             mFirstLayout = false;
 873         }
 874     }
 875 
 876     protected void screenScrolled(int screenCenter) {
 877         boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
 878 
 879         if (mFadeInAdjacentScreens &amp;&amp; !isInOverscroll) {
 880             for (int i = 0; i &lt; getChildCount(); i++) {
 881                 View child = getChildAt(i);
 882                 if (child != null) {
 883                     float scrollProgress = getScrollProgress(screenCenter, child, i);
 884                     float alpha = 1 - Math.abs(scrollProgress);
 885                     child.setAlpha(alpha);
 886                 }
 887             }
 888             invalidate();
 889         }
 890     }
 891 
 892     @Override
 893     public void onChildViewAdded(View parent, View child) {
 894         // Update the page indicator, we don&#x27;t update the page indicator as we
 895         // add/remove pages
 896         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 897             mPageIndicator.addMarker(indexOfChild(child));
 898         }
 899 
 900         // This ensures that when children are added, they get the correct transforms / alphas
 901         // in accordance with any scroll effects.
 902         mForceScreenScrolled = true;
 903         mRecomputePageSpacing = true;
 904 
 905         invalidate();
 906         invalidateCachedOffsets();
 907     }
 908 
 909     @Override
 910     public void onChildViewRemoved(View parent, View child) {
 911         mForceScreenScrolled = true;
 912         invalidate();
 913         invalidateCachedOffsets();
 914     }
 915 
 916     private void removeMarkerForView(int index) {
 917         // Update the page indicator, we don&#x27;t update the page indicator as we
 918         // add/remove pages
 919         if (mPageIndicator != null &amp;&amp; !isReordering(false)) {
 920             mPageIndicator.removeMarker(index);
 921         }
 922     }
 923 
 924     @Override
 925     public void removeView(View v) {
 926         // XXX: We should find a better way to hook into this before the view
 927         // gets removed form its parent...
 928         removeMarkerForView(indexOfChild(v));
 929         super.removeView(v);
 930     }
 931     @Override
 932     public void removeViewInLayout(View v) {
 933         // XXX: We should find a better way to hook into this before the view
 934         // gets removed form its parent...
 935         removeMarkerForView(indexOfChild(v));
 936         super.removeViewInLayout(v);
 937     }
 938     @Override
 939     public void removeViewAt(int index) {
 940         // XXX: We should find a better way to hook into this before the view
 941         // gets removed form its parent...
 942         removeViewAt(index);
 943         super.removeViewAt(index);
 944     }
 945     @Override
 946     public void removeAllViewsInLayout() {
 947         // Update the page indicator, we don&#x27;t update the page indicator as we
 948         // add/remove pages
 949         if (mPageIndicator != null) {
 950             mPageIndicator.removeAllMarkers();
 951         }
 952 
 953         super.removeAllViewsInLayout();
 954     }
 955 
 956     protected void invalidateCachedOffsets() {
 957         int count = getChildCount();
 958         if (count == 0) {
 959             mChildOffsets = null;
 960             mChildRelativeOffsets = null;
 961             return;
 962         }
 963 
 964         mChildOffsets = new int[count];
 965         mChildRelativeOffsets = new int[count];
 966         for (int i = 0; i &lt; count; i++) {
 967             mChildOffsets[i] = -1;
 968             mChildRelativeOffsets[i] = -1;
 969         }
 970     }
 971 
 972     protected int getChildOffset(int index) {
 973         if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
 974 
 975         final boolean isRtl = isLayoutRtl();
 976         int[] childOffsets = mChildOffsets;
 977 
 978         if (childOffsets != null &amp;&amp; childOffsets[index] != -1) {
 979             return childOffsets[index];
 980         } else {
 981             if (getChildCount() == 0)
 982                 return 0;
 983 
 984             final int startIndex = isRtl ? getChildCount() - 1 : 0;
 985             final int endIndex = isRtl ? index : index;
 986             final int delta = isRtl ? -1 : 1;
 987 
 988             int offset = getRelativeChildOffset(startIndex);
 989             for (int i = startIndex; i != endIndex; i += delta) {
 990                 offset += getPageAt(i).getMeasuredWidth() + mPageSpacing;
 991             }
 992             if (childOffsets != null) {
 993                 childOffsets[index] = offset;
 994             }
 995             return offset;
 996         }
 997 
 998     }
 999 
1000     protected int getRelativeChildOffset(int index) {
1001         if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
1002 
1003         if (mChildRelativeOffsets != null &amp;&amp; mChildRelativeOffsets[index] != -1) {
1004             return mChildRelativeOffsets[index];
1005         } else {
1006             final int padding = getPaddingLeft() + getPaddingRight();
1007             final int offset = getPaddingLeft() +
1008                     (getViewportWidth() - padding - getChildWidth(index)) / 2;
1009             if (mChildRelativeOffsets != null) {
1010                 mChildRelativeOffsets[index] = offset;
1011             }
1012             return offset;
1013         }
1014     }
1015 
1016     void boundByReorderablePages(boolean isReordering, int[] range) {
1017         // Do nothing
1018     }
1019 
1020     // TODO: Fix this
1021     protected void getVisiblePages(int[] range) {
1022         range[0] = 0;
1023         range[1] = getPageCount() - 1;
1024 
1025         /*
1026         final int pageCount = getChildCount();
1027 
1028         if (pageCount &gt; 0) {
1029             final int screenWidth = getViewportWidth();
1030             int leftScreen = 0;
1031             int rightScreen = 0;
1032             int offsetX = getViewportOffsetX() + getScrollX();
1033             View currPage = getPageAt(leftScreen);
1034             while (leftScreen &lt; pageCount - 1 &amp;&amp;
1035                     currPage.getX() + currPage.getWidth() -
1036                     currPage.getPaddingRight() &lt; offsetX) {
1037                 leftScreen++;
1038                 currPage = getPageAt(leftScreen);
1039             }
1040             rightScreen = leftScreen;
1041             currPage = getPageAt(rightScreen + 1);
1042             while (rightScreen &lt; pageCount - 1 &amp;&amp;
1043                     currPage.getX() - currPage.getPaddingLeft() &lt; offsetX + screenWidth) {
1044                 rightScreen++;
1045                 currPage = getPageAt(rightScreen + 1);
1046             }
1047 
1048             // TEMP: this is a hacky way to ensure that animations to new pages are not clipped
1049             // because we don&#x27;t draw them while scrolling?
1050             range[0] = Math.max(0, leftScreen - 1);
1051             range[1] = Math.min(rightScreen + 1, getChildCount() - 1);
1052         } else {
1053             range[0] = -1;
1054             range[1] = -1;
1055         }
1056         */
1057     }
1058 
1059     protected boolean shouldDrawChild(View child) {
1060         return child.getAlpha() &gt; 0;
1061     }
1062 
1063     @Override
1064     protected void dispatchDraw(Canvas canvas) {
1065         int halfScreenSize = getViewportWidth() / 2;
1066         // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range.
1067         // Otherwise it is equal to the scaled overscroll position.
1068         int screenCenter = mOverScrollX + halfScreenSize;
1069 
1070         if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
1071             // set mForceScreenScrolled before calling screenScrolled so that screenScrolled can
1072             // set it for the next frame
1073             mForceScreenScrolled = false;
1074             screenScrolled(screenCenter);
1075             mLastScreenCenter = screenCenter;
1076         }
1077 
1078         // Find out which screens are visible; as an optimization we only call draw on them
1079         final int pageCount = getChildCount();
1080         if (pageCount &gt; 0) {
1081             getVisiblePages(mTempVisiblePagesRange);
1082             final int leftScreen = mTempVisiblePagesRange[0];
1083             final int rightScreen = mTempVisiblePagesRange[1];
1084             if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1085                 final long drawingTime = getDrawingTime();
1086                 // Clip to the bounds
1087                 canvas.save();
1088                 canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
1089                         getScrollY() + getBottom() - getTop());
1090 
1091                 // Draw all the children, leaving the drag view for last
1092                 for (int i = pageCount - 1; i &gt;= 0; i--) {
1093                     final View v = getPageAt(i);
1094                     if (v == mDragView) continue;
1095                     if (mForceDrawAllChildrenNextFrame ||
1096                                (leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(v))) {
1097                         drawChild(canvas, v, drawingTime);
1098                     }
1099                 }
1100                 // Draw the drag view on top (if there is one)
1101                 if (mDragView != null) {
1102                     drawChild(canvas, mDragView, drawingTime);
1103                 }
1104 
1105                 mForceDrawAllChildrenNextFrame = false;
1106                 canvas.restore();
1107             }
1108         }
1109     }
1110 
1111     @Override
1112     public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
1113         int page = indexToPage(indexOfChild(child));
1114         if (page != mCurrentPage || !mScroller.isFinished()) {
1115             snapToPage(page);
1116             return true;
1117         }
1118         return false;
1119     }
1120 
1121     @Override
1122     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1123         int focusablePage;
1124         if (mNextPage != INVALID_PAGE) {
1125             focusablePage = mNextPage;
1126         } else {
1127             focusablePage = mCurrentPage;
1128         }
1129         View v = getPageAt(focusablePage);
1130         if (v != null) {
1131             return v.requestFocus(direction, previouslyFocusedRect);
1132         }
1133         return false;
1134     }
1135 
1136     @Override
1137     public boolean dispatchUnhandledMove(View focused, int direction) {
1138         // XXX-RTL: This will be fixed in a future CL
1139         if (direction == View.FOCUS_LEFT) {
1140             if (getCurrentPage() &gt; 0) {
1141                 snapToPage(getCurrentPage() - 1);
1142                 return true;
1143             }
1144         } else if (direction == View.FOCUS_RIGHT) {
1145             if (getCurrentPage() &lt; getPageCount() - 1) {
1146                 snapToPage(getCurrentPage() + 1);
1147                 return true;
1148             }
1149         }
1150         return super.dispatchUnhandledMove(focused, direction);
1151     }
1152 
1153     @Override
1154     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1155         // XXX-RTL: This will be fixed in a future CL
1156         if (mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getPageCount()) {
1157             getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
1158         }
1159         if (direction == View.FOCUS_LEFT) {
1160             if (mCurrentPage &gt; 0) {
1161                 getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
1162             }
1163         } else if (direction == View.FOCUS_RIGHT){
1164             if (mCurrentPage &lt; getPageCount() - 1) {
1165                 getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
1166             }
1167         }
1168     }
1169 
1170     /**
1171      * If one of our descendant views decides that it could be focused now, only
1172      * pass that along if it&#x27;s on the current page.
1173      *
1174      * This happens when live folders requery, and if they&#x27;re off page, they
1175      * end up calling requestFocus, which pulls it on page.
1176      */
1177     @Override
1178     public void focusableViewAvailable(View focused) {
1179         View current = getPageAt(mCurrentPage);
1180         View v = focused;
1181         while (true) {
1182             if (v == current) {
1183                 super.focusableViewAvailable(focused);
1184                 return;
1185             }
1186             if (v == this) {
1187                 return;
1188             }
1189             ViewParent parent = v.getParent();
1190             if (parent instanceof View) {
1191                 v = (View)v.getParent();
1192             } else {
1193                 return;
1194             }
1195         }
1196     }
1197 
1198     /**
1199      * {@inheritDoc}
1200      */
1201     @Override
1202     public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
1203         if (disallowIntercept) {
1204             // We need to make sure to cancel our long press if
1205             // a scrollable widget takes over touch events
1206             final View currentPage = getPageAt(mCurrentPage);
1207             currentPage.cancelLongPress();
1208         }
1209         super.requestDisallowInterceptTouchEvent(disallowIntercept);
1210     }
1211 
1212     /**
1213      * Return true if a tap at (x, y) should trigger a flip to the previous page.
1214      */
1215     protected boolean hitsPreviousPage(float x, float y) {
1216         if (isLayoutRtl()) {
1217             return (x &gt; (getViewportOffsetX() + getViewportWidth() -
1218                     getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1219         }
1220         return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1221     }
1222 
1223     /**
1224      * Return true if a tap at (x, y) should trigger a flip to the next page.
1225      */
1226     protected boolean hitsNextPage(float x, float y) {
1227         if (isLayoutRtl()) {
1228             return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1229         }
1230         return  (x &gt; (getViewportOffsetX() + getViewportWidth() -
1231                 getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1232     }
1233 
1234     /** Returns whether x and y originated within the buffered viewport */
1235     private boolean isTouchPointInViewportWithBuffer(int x, int y) {
1236         mTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top,
1237                 mViewport.right + mViewport.width() / 2, mViewport.bottom);
1238         return mTmpRect.contains(x, y);
1239     }
1240 
1241     /** Returns whether x and y originated within the current page view bounds */
1242     private boolean isTouchPointInCurrentPage(int x, int y) {
1243         View v = getPageAt(getCurrentPage());
1244         if (v != null) {
1245             mTmpRect.set((v.getLeft() - getScrollX()), 0, (v.getRight() - getScrollX()),
1246                     v.getBottom());
1247             return mTmpRect.contains(x, y);
1248         }
1249         return false;
1250     }
1251 
1252     @Override
1253     public boolean onInterceptTouchEvent(MotionEvent ev) {
1254         if (DISABLE_TOUCH_INTERACTION) {
1255             return false;
1256         }
1257 
1258         /*
1259          * This method JUST determines whether we want to intercept the motion.
1260          * If we return true, onTouchEvent will be called and we do the actual
1261          * scrolling there.
1262          */
1263         acquireVelocityTrackerAndAddMovement(ev);
1264 
1265         // Skip touch handling if there are no pages to swipe
1266         if (getChildCount() &lt;= 0) return super.onInterceptTouchEvent(ev);
1267 
1268         /*
1269          * Shortcut the most recurring case: the user is in the dragging
1270          * state and he is moving his finger.  We want to intercept this
1271          * motion.
1272          */
1273         final int action = ev.getAction();
1274         if ((action == MotionEvent.ACTION_MOVE) &amp;&amp;
1275                 (mTouchState == TOUCH_STATE_SCROLLING)) {
1276             return true;
1277         }
1278 
1279         switch (action &amp; MotionEvent.ACTION_MASK) {
1280             case MotionEvent.ACTION_MOVE: {
1281                 /*
1282                  * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
1283                  * whether the user has moved far enough from his original down touch.
1284                  */
1285                 if (mActivePointerId != INVALID_POINTER) {
1286                     determineScrollingStart(ev);
1287                     break;
1288                 }
1289                 // if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN
1290                 // event. in that case, treat the first occurence of a move event as a ACTION_DOWN
1291                 // i.e. fall through to the next case (don&#x27;t break)
1292                 // (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events
1293                 // while it&#x27;s small- this was causing a crash before we checked for INVALID_POINTER)
1294             }
1295 
1296             case MotionEvent.ACTION_DOWN: {
1297                 final float x = ev.getX();
1298                 final float y = ev.getY();
1299                 // Remember location of down touch
1300                 mDownMotionX = x;
1301                 mDownMotionY = y;
1302                 mDownScrollX = getScrollX();
1303                 mLastMotionX = x;
1304                 mLastMotionY = y;
1305                 float[] p = mapPointFromViewToParent(this, x, y);
1306                 mParentDownMotionX = p[0];
1307                 mParentDownMotionY = p[1];
1308                 mLastMotionXRemainder = 0;
1309                 mTotalMotionX = 0;
1310                 mActivePointerId = ev.getPointerId(0);
1311 
1312                 // Determine if the down event is within the threshold to be an edge swipe
1313                 int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1314                 int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1315                 if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1316                     mDownEventOnEdge = true;
1317                 }
1318 
1319                 /*
1320                  * If being flinged and user touches the screen, initiate drag;
1321                  * otherwise don&#x27;t.  mScroller.isFinished should be false when
1322                  * being flinged.
1323                  */
1324                 final int xDist = Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
1325                 final boolean finishedScrolling = (mScroller.isFinished() || xDist &lt; mTouchSlop);
1326                 if (finishedScrolling) {
1327                     mTouchState = TOUCH_STATE_REST;
1328                     mScroller.abortAnimation();
1329                 } else {
1330                     if (isTouchPointInViewportWithBuffer((int) mDownMotionX, (int) mDownMotionY)) {
1331                         mTouchState = TOUCH_STATE_SCROLLING;
1332                     } else {
1333                         mTouchState = TOUCH_STATE_REST;
1334                     }
1335                 }
1336 
1337                 // check if this can be the beginning of a tap on the side of the pages
1338                 // to scroll the current page
1339                 if (!DISABLE_TOUCH_SIDE_PAGES) {
1340                     if (mTouchState != TOUCH_STATE_PREV_PAGE &amp;&amp; mTouchState != TOUCH_STATE_NEXT_PAGE) {
1341                         if (getChildCount() &gt; 0) {
1342                             if (hitsPreviousPage(x, y)) {
1343                                 mTouchState = TOUCH_STATE_PREV_PAGE;
1344                             } else if (hitsNextPage(x, y)) {
1345                                 mTouchState = TOUCH_STATE_NEXT_PAGE;
1346                             }
1347                         }
1348                     }
1349                 }
1350                 break;
1351             }
1352 
1353             case MotionEvent.ACTION_UP:
1354             case MotionEvent.ACTION_CANCEL:
1355                 resetTouchState();
1356                 // Just intercept the touch event on up if we tap outside the strict viewport
1357                 if (!isTouchPointInCurrentPage((int) mLastMotionX, (int) mLastMotionY)) {
1358                     return true;
1359                 }
1360                 break;
1361 
1362             case MotionEvent.ACTION_POINTER_UP:
1363                 onSecondaryPointerUp(ev);
1364                 releaseVelocityTracker();
1365                 break;
1366         }
1367 
1368         /*
1369          * The only time we want to intercept motion events is if we are in the
1370          * drag mode.
1371          */
1372         return mTouchState != TOUCH_STATE_REST;
1373     }
1374 
1375     protected void determineScrollingStart(MotionEvent ev) {
1376         determineScrollingStart(ev, 1.0f);
1377     }
1378 
1379     /*
1380      * Determines if we should change the touch state to start scrolling after the
1381      * user moves their touch point too far.
1382      */
1383     protected void determineScrollingStart(MotionEvent ev, float touchSlopScale) {
1384         // Disallow scrolling if we don&#x27;t have a valid pointer index
1385         final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1386         if (pointerIndex == -1) return;
1387 
1388         // Disallow scrolling if we started the gesture from outside the viewport
1389         final float x = ev.getX(pointerIndex);
1390         final float y = ev.getY(pointerIndex);
1391         if (!isTouchPointInViewportWithBuffer((int) x, (int) y)) return;
1392 
1393         // If we&#x27;re only allowing edge swipes, we break out early if the down event wasn&#x27;t
1394         // at the edge.
1395         if (mOnlyAllowEdgeSwipes &amp;&amp; !mDownEventOnEdge) return;
1396 
1397         final int xDiff = (int) Math.abs(x - mLastMotionX);
1398         final int yDiff = (int) Math.abs(y - mLastMotionY);
1399 
1400         final int touchSlop = Math.round(touchSlopScale * mTouchSlop);
1401         boolean xPaged = xDiff &gt; mPagingTouchSlop;
1402         boolean xMoved = xDiff &gt; touchSlop;
1403         boolean yMoved = yDiff &gt; touchSlop;
1404 
1405         if (xMoved || xPaged || yMoved) {
1406             if (mUsePagingTouchSlop ? xPaged : xMoved) {
1407                 // Scroll if the user moved far enough along the X axis
1408                 mTouchState = TOUCH_STATE_SCROLLING;
1409                 mTotalMotionX += Math.abs(mLastMotionX - x);
1410                 mLastMotionX = x;
1411                 mLastMotionXRemainder = 0;
1412                 mTouchX = getViewportOffsetX() + getScrollX();
1413                 mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1414                 pageBeginMoving();
1415             }
1416         }
1417     }
1418 
1419     protected float getMaxScrollProgress() {
1420         return 1.0f;
1421     }
1422 
1423     protected void cancelCurrentPageLongPress() {
1424         if (mAllowLongPress) {
1425             //mAllowLongPress = false;
1426             // Try canceling the long press. It could also have been scheduled
1427             // by a distant descendant, so use the mAllowLongPress flag to block
1428             // everything
1429             final View currentPage = getPageAt(mCurrentPage);
1430             if (currentPage != null) {
1431                 currentPage.cancelLongPress();
1432             }
1433         }
1434     }
1435 
1436     protected float getBoundedScrollProgress(int screenCenter, View v, int page) {
1437         final int halfScreenSize = getViewportWidth() / 2;
1438 
1439         screenCenter = Math.min(getScrollX() + halfScreenSize, screenCenter);
1440         screenCenter = Math.max(halfScreenSize,  screenCenter);
1441 
1442         return getScrollProgress(screenCenter, v, page);
1443     }
1444 
1445     protected float getScrollProgress(int screenCenter, View v, int page) {
1446         final int halfScreenSize = getViewportWidth() / 2;
1447 
1448         int totalDistance = v.getMeasuredWidth() + mPageSpacing;
1449         int delta = screenCenter - (getChildOffset(page) -
1450                 getRelativeChildOffset(page) + halfScreenSize);
1451 
1452         float scrollProgress = delta / (totalDistance * 1.0f);
1453         scrollProgress = Math.min(scrollProgress, getMaxScrollProgress());
1454         scrollProgress = Math.max(scrollProgress, - getMaxScrollProgress());
1455         return scrollProgress;
1456     }
1457 
1458     // This curve determines how the effect of scrolling over the limits of the page dimishes
1459     // as the user pulls further and further from the bounds
1460     private float overScrollInfluenceCurve(float f) {
1461         f -= 1.0f;
1462         return f * f * f + 1.0f;
1463     }
1464 
1465     protected void acceleratedOverScroll(float amount) {
1466         int screenSize = getViewportWidth();
1467 
1468         // We want to reach the max over scroll effect when the user has
1469         // over scrolled half the size of the screen
1470         float f = OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
1471 
1472         if (f == 0) return;
1473 
1474         // Clamp this factor, f, to -1 &lt; f &lt; 1
1475         if (Math.abs(f) &gt;= 1) {
1476             f /= Math.abs(f);
1477         }
1478 
1479         int overScrollAmount = (int) Math.round(f * screenSize);
1480         if (amount &lt; 0) {
1481             mOverScrollX = overScrollAmount;
1482             super.scrollTo(0, getScrollY());
1483         } else {
1484             mOverScrollX = mMaxScrollX + overScrollAmount;
1485             super.scrollTo(mMaxScrollX, getScrollY());
1486         }
1487         invalidate();
1488     }
1489 
1490     protected void dampedOverScroll(float amount) {
1491         int screenSize = getViewportWidth();
1492 
1493         float f = (amount / screenSize);
1494 
1495         if (f == 0) return;
1496         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1497 
1498         // Clamp this factor, f, to -1 &lt; f &lt; 1
1499         if (Math.abs(f) &gt;= 1) {
1500             f /= Math.abs(f);
1501         }
1502 
1503         int overScrollAmount = (int) Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
1504         if (amount &lt; 0) {
1505             mOverScrollX = overScrollAmount;
1506             super.scrollTo(0, getScrollY());
1507         } else {
1508             mOverScrollX = mMaxScrollX + overScrollAmount;
1509             super.scrollTo(mMaxScrollX, getScrollY());
1510         }
1511         invalidate();
1512     }
1513 
1514     protected void overScroll(float amount) {
1515         dampedOverScroll(amount);
1516     }
1517 
1518     protected float maxOverScroll() {
1519         // Using the formula in overScroll, assuming that f = 1.0 (which it should generally not
1520         // exceed). Used to find out how much extra wallpaper we need for the over scroll effect
1521         float f = 1.0f;
1522         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1523         return OVERSCROLL_DAMP_FACTOR * f;
1524     }
1525 
1526     @Override
1527     public boolean onTouchEvent(MotionEvent ev) {
1528         if (DISABLE_TOUCH_INTERACTION) {
1529             return false;
1530         }
1531 
1532         // Skip touch handling if there are no pages to swipe
1533         if (getChildCount() &lt;= 0) return super.onTouchEvent(ev);
1534 
1535         acquireVelocityTrackerAndAddMovement(ev);
1536 
1537         final int action = ev.getAction();
1538 
1539         switch (action &amp; MotionEvent.ACTION_MASK) {
1540         case MotionEvent.ACTION_DOWN:
1541             /*
1542              * If being flinged and user touches, stop the fling. isFinished
1543              * will be false if being flinged.
1544              */
1545             if (!mScroller.isFinished()) {
1546                 mScroller.abortAnimation();
1547             }
1548 
1549             // Remember where the motion event started
1550             mDownMotionX = mLastMotionX = ev.getX();
1551             mDownMotionY = mLastMotionY = ev.getY();
1552             mDownScrollX = getScrollX();
1553             float[] p = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1554             mParentDownMotionX = p[0];
1555             mParentDownMotionY = p[1];
1556             mLastMotionXRemainder = 0;
1557             mTotalMotionX = 0;
1558             mActivePointerId = ev.getPointerId(0);
1559 
1560             // Determine if the down event is within the threshold to be an edge swipe
1561             int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1562             int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1563             if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1564                 mDownEventOnEdge = true;
1565             }
1566 
1567             if (mTouchState == TOUCH_STATE_SCROLLING) {
1568                 pageBeginMoving();
1569             }
1570             break;
1571 
1572         case MotionEvent.ACTION_MOVE:
1573             if (mTouchState == TOUCH_STATE_SCROLLING) {
1574                 // Scroll to follow the motion event
1575                 final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1576 
1577                 if (pointerIndex == -1) return true;
1578 
1579                 final float x = ev.getX(pointerIndex);
1580                 final float deltaX = mLastMotionX + mLastMotionXRemainder - x;
1581 
1582                 mTotalMotionX += Math.abs(deltaX);
1583 
1584                 // Only scroll and update mLastMotionX if we have moved some discrete amount.  We
1585                 // keep the remainder because we are actually testing if we&#x27;ve moved from the last
1586                 // scrolled position (which is discrete).
1587                 if (Math.abs(deltaX) &gt;= 1.0f) {
1588                     mTouchX += deltaX;
1589                     mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1590                     if (!mDeferScrollUpdate) {
1591                         scrollBy((int) deltaX, 0);
1592                         if (DEBUG) Log.d(TAG, &quot;onTouchEvent().Scrolling: &quot; + deltaX);
1593                     } else {
1594                         invalidate();
1595                     }
1596                     mLastMotionX = x;
1597                     mLastMotionXRemainder = deltaX - (int) deltaX;
1598                 } else {
1599                     awakenScrollBars();
1600                 }
1601             } else if (mTouchState == TOUCH_STATE_REORDERING) {
1602                 // Update the last motion position
1603                 mLastMotionX = ev.getX();
1604                 mLastMotionY = ev.getY();
1605 
1606                 // Update the parent down so that our zoom animations take this new movement into
1607                 // account
1608                 float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1609                 mParentDownMotionX = pt[0];
1610                 mParentDownMotionY = pt[1];
1611                 updateDragViewTranslationDuringDrag();
1612 
1613                 // Find the closest page to the touch point
1614                 final int dragViewIndex = indexOfChild(mDragView);
1615                 int bufferSize = (int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE *
1616                     getViewportWidth());
1617                 int leftBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.left, 0)[0]
1618                         + bufferSize);
1619                 int rightBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.right, 0)[0]
1620                         - bufferSize);
1621 
1622                 // Change the drag view if we are hovering over the drop target
1623                 boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(
1624                         (int) mParentDownMotionX, (int) mParentDownMotionY);
1625                 setPageHoveringOverDeleteDropTarget(dragViewIndex, isHoveringOverDelete);
1626 
1627                 if (DEBUG) Log.d(TAG, &quot;leftBufferEdge: &quot; + leftBufferEdge);
1628                 if (DEBUG) Log.d(TAG, &quot;rightBufferEdge: &quot; + rightBufferEdge);
1629                 if (DEBUG) Log.d(TAG, &quot;mLastMotionX: &quot; + mLastMotionX);
1630                 if (DEBUG) Log.d(TAG, &quot;mLastMotionY: &quot; + mLastMotionY);
1631                 if (DEBUG) Log.d(TAG, &quot;mParentDownMotionX: &quot; + mParentDownMotionX);
1632                 if (DEBUG) Log.d(TAG, &quot;mParentDownMotionY: &quot; + mParentDownMotionY);
1633 
1634                 float parentX = mParentDownMotionX;
1635                 int pageIndexToSnapTo = -1;
1636                 if (parentX &lt; leftBufferEdge &amp;&amp; dragViewIndex &gt; 0) {
1637                     pageIndexToSnapTo = dragViewIndex - 1;
1638                 } else if (parentX &gt; rightBufferEdge &amp;&amp; dragViewIndex &lt; getChildCount() - 1) {
1639                     pageIndexToSnapTo = dragViewIndex + 1;
1640                 }
1641 
1642                 final int pageUnderPointIndex = pageIndexToSnapTo;
1643                 if (pageUnderPointIndex &gt; -1 &amp;&amp; !isHoveringOverDelete) {
1644                     mTempVisiblePagesRange[0] = 0;
1645                     mTempVisiblePagesRange[1] = getPageCount() - 1;
1646                     boundByReorderablePages(true, mTempVisiblePagesRange);
1647                     if (mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex &amp;&amp;
1648                             pageUnderPointIndex &lt;= mTempVisiblePagesRange[1] &amp;&amp;
1649                             pageUnderPointIndex != mSidePageHoverIndex &amp;&amp; mScroller.isFinished()) {
1650                         mSidePageHoverIndex = pageUnderPointIndex;
1651                         mSidePageHoverRunnable = new Runnable() {
1652                             @Override
1653                             public void run() {
1654                                 // Update the down scroll position to account for the fact that the
1655                                 // current page is moved
1656                                 mDownScrollX = getChildOffset(pageUnderPointIndex)
1657                                         - getRelativeChildOffset(pageUnderPointIndex);
1658 
1659                                 // Setup the scroll to the correct page before we swap the views
1660                                 snapToPage(pageUnderPointIndex);
1661 
1662                                 // For each of the pages between the paged view and the drag view,
1663                                 // animate them from the previous position to the new position in
1664                                 // the layout (as a result of the drag view moving in the layout)
1665                                 int shiftDelta = (dragViewIndex &lt; pageUnderPointIndex) ? -1 : 1;
1666                                 int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ?
1667                                         dragViewIndex + 1 : pageUnderPointIndex;
1668                                 int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ?
1669                                         dragViewIndex - 1 : pageUnderPointIndex;
1670                                 for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
1671                                     View v = getChildAt(i);
1672                                     // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
1673                                     // drag view all subsequent views to pageUnderPointIndex will
1674                                     // shift down.
1675                                     int oldX = getViewportOffsetX() + getChildOffset(i);
1676                                     int newX = getViewportOffsetX() + getChildOffset(i + shiftDelta);
1677 
1678                                     // Animate the view translation from its old position to its new
1679                                     // position
1680                                     AnimatorSet anim = (AnimatorSet) v.getTag(ANIM_TAG_KEY);
1681                                     if (anim != null) {
1682                                         anim.cancel();
1683                                     }
1684 
1685                                     v.setTranslationX(oldX - newX);
1686                                     anim = new AnimatorSet();
1687                                     anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
1688                                     anim.playTogether(
1689                                             ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f));
1690                                     anim.start();
1691                                     v.setTag(anim);
1692                                 }
1693 
1694                                 removeView(mDragView);
1695                                 onRemoveView(mDragView, false);
1696                                 addView(mDragView, pageUnderPointIndex);
1697                                 onAddView(mDragView, pageUnderPointIndex);
1698                                 mSidePageHoverIndex = -1;
1699                                 mPageIndicator.setActiveMarker(getNextPage());
1700                             }
1701                         };
1702                         postDelayed(mSidePageHoverRunnable, REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
1703                     }
1704                 } else {
1705                     removeCallbacks(mSidePageHoverRunnable);
1706                     mSidePageHoverIndex = -1;
1707                 }
1708             } else {
1709                 determineScrollingStart(ev);
1710             }
1711             break;
1712 
1713         case MotionEvent.ACTION_UP:
1714             if (mTouchState == TOUCH_STATE_SCROLLING) {
1715                 final int activePointerId = mActivePointerId;
1716                 final int pointerIndex = ev.findPointerIndex(activePointerId);
1717                 final float x = ev.getX(pointerIndex);
1718                 final VelocityTracker velocityTracker = mVelocityTracker;
1719                 velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
1720                 int velocityX = (int) velocityTracker.getXVelocity(activePointerId);
1721                 final int deltaX = (int) (x - mDownMotionX);
1722                 final int pageWidth = getPageAt(mCurrentPage).getMeasuredWidth();
1723                 boolean isSignificantMove = Math.abs(deltaX) &gt; pageWidth *
1724                         SIGNIFICANT_MOVE_THRESHOLD;
1725 
1726                 mTotalMotionX += Math.abs(mLastMotionX + mLastMotionXRemainder - x);
1727 
1728                 boolean isFling = mTotalMotionX &gt; MIN_LENGTH_FOR_FLING &amp;&amp;
1729                         Math.abs(velocityX) &gt; mFlingThresholdVelocity;
1730 
1731                 // In the case that the page is moved far to one direction and then is flung
1732                 // in the opposite direction, we use a threshold to determine whether we should
1733                 // just return to the starting page, or if we should skip one further.
1734                 boolean returnToOriginalPage = false;
1735                 if (Math.abs(deltaX) &gt; pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD &amp;&amp;
1736                         Math.signum(velocityX) != Math.signum(deltaX) &amp;&amp; isFling) {
1737                     returnToOriginalPage = true;
1738                 }
1739 
1740                 int finalPage;
1741                 // We give flings precedence over large moves, which is why we short-circuit our
1742                 // test for a large move if a fling has been registered. That is, a large
1743                 // move to the left and fling to the right will register as a fling to the right.
1744                 final boolean isRtl = isLayoutRtl();
1745                 boolean isDeltaXLeft = isRtl ? deltaX &gt; 0 : deltaX &lt; 0;
1746                 boolean isVelocityXLeft = isRtl ? velocityX &gt; 0 : velocityX &lt; 0;
1747                 if (((isSignificantMove &amp;&amp; !isDeltaXLeft &amp;&amp; !isFling) ||
1748                         (isFling &amp;&amp; !isVelocityXLeft)) &amp;&amp; mCurrentPage &gt; 0) {
1749                     finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
1750                     snapToPageWithVelocity(finalPage, velocityX);
1751                 } else if (((isSignificantMove &amp;&amp; isDeltaXLeft &amp;&amp; !isFling) ||
1752                         (isFling &amp;&amp; isVelocityXLeft)) &amp;&amp;
1753                         mCurrentPage &lt; getChildCount() - 1) {
1754                     finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
1755                     snapToPageWithVelocity(finalPage, velocityX);
1756                 } else {
1757                     snapToDestination();
1758                 }            } else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
1759                 // at this point we have not moved beyond the touch slop
1760                 // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1761                 // we can just page
1762                 int nextPage = Math.max(0, mCurrentPage - 1);
1763                 if (nextPage != mCurrentPage) {
1764                     snapToPage(nextPage);
1765                 } else {
1766                     snapToDestination();
1767                 }
1768             } else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
1769                 // at this point we have not moved beyond the touch slop
1770                 // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1771                 // we can just page
1772                 int nextPage = Math.min(getChildCount() - 1, mCurrentPage + 1);
1773                 if (nextPage != mCurrentPage) {
1774                     snapToPage(nextPage);
1775                 } else {
1776                     snapToDestination();
1777                 }
1778             } else if (mTouchState == TOUCH_STATE_REORDERING) {
1779                 // Update the last motion position
1780                 mLastMotionX = ev.getX();
1781                 mLastMotionY = ev.getY();
1782 
1783                 // Update the parent down so that our zoom animations take this new movement into
1784                 // account
1785                 float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1786                 mParentDownMotionX = pt[0];
1787                 mParentDownMotionY = pt[1];
1788                 updateDragViewTranslationDuringDrag();
1789                 boolean handledFling = false;
1790                 if (!DISABLE_FLING_TO_DELETE) {
1791                     // Check the velocity and see if we are flinging-to-delete
1792                     PointF flingToDeleteVector = isFlingingToDelete();
1793                     if (flingToDeleteVector != null) {
1794                         onFlingToDelete(flingToDeleteVector);
1795                         handledFling = true;
1796                     }
1797                 }
1798                 if (!handledFling &amp;&amp; isHoveringOverDeleteDropTarget((int) mParentDownMotionX,
1799                         (int) mParentDownMotionY)) {
1800                     onDropToDelete();
1801                 }
1802             } else {
1803                 onUnhandledTap(ev);
1804             }
1805 
1806             // Remove the callback to wait for the side page hover timeout
1807             removeCallbacks(mSidePageHoverRunnable);
1808             // End any intermediate reordering states
1809             resetTouchState();
1810             break;
1811 
1812         case MotionEvent.ACTION_CANCEL:
1813             if (mTouchState == TOUCH_STATE_SCROLLING) {
1814                 snapToDestination();
1815             }
1816             resetTouchState();
1817             break;
1818 
1819         case MotionEvent.ACTION_POINTER_UP:
1820             onSecondaryPointerUp(ev);
1821             break;
1822         }
1823 
1824         return true;
1825     }
1826 
1827     public void onFlingToDelete(View v) {}
1828     public void onRemoveView(View v, boolean deletePermanently) {}
1829     public void onRemoveViewAnimationCompleted() {}
1830     public void onAddView(View v, int index) {}
1831 
1832     private void resetTouchState() {
1833         releaseVelocityTracker();
1834         endReordering();
1835         mTouchState = TOUCH_STATE_REST;
1836         mActivePointerId = INVALID_POINTER;
1837         mDownEventOnEdge = false;
1838     }
1839 
1840     protected void onUnhandledTap(MotionEvent ev) {}
1841 
1842     @Override
1843     public boolean onGenericMotionEvent(MotionEvent event) {
1844         if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
1845             switch (event.getAction()) {
1846                 case MotionEvent.ACTION_SCROLL: {
1847                     // Handle mouse (or ext. device) by shifting the page depending on the scroll
1848                     final float vscroll;
1849                     final float hscroll;
1850                     if ((event.getMetaState() &amp; KeyEvent.META_SHIFT_ON) != 0) {
1851                         vscroll = 0;
1852                         hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1853                     } else {
1854                         vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1855                         hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
1856                     }
1857                     if (hscroll != 0 || vscroll != 0) {
1858                         boolean isForwardScroll = isLayoutRtl() ? (hscroll &lt; 0 || vscroll &lt; 0)
1859                                                          : (hscroll &gt; 0 || vscroll &gt; 0);
1860                         if (isForwardScroll) {
1861                             scrollRight();
1862                         } else {
1863                             scrollLeft();
1864                         }
1865                         return true;
1866                     }
1867                 }
1868             }
1869         }
1870         return super.onGenericMotionEvent(event);
1871     }
1872 
1873     private void acquireVelocityTrackerAndAddMovement(MotionEvent ev) {
1874         if (mVelocityTracker == null) {
1875             mVelocityTracker = VelocityTracker.obtain();
1876         }
1877         mVelocityTracker.addMovement(ev);
1878     }
1879 
1880     private void releaseVelocityTracker() {
1881         if (mVelocityTracker != null) {
1882             mVelocityTracker.recycle();
1883             mVelocityTracker = null;
1884         }
1885     }
1886 
1887     private void onSecondaryPointerUp(MotionEvent ev) {
1888         final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;
1889                 MotionEvent.ACTION_POINTER_INDEX_SHIFT;
1890         final int pointerId = ev.getPointerId(pointerIndex);
1891         if (pointerId == mActivePointerId) {
1892             // This was our active pointer going up. Choose a new
1893             // active pointer and adjust accordingly.
1894             // TODO: Make this decision more intelligent.
1895             final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
1896             mLastMotionX = mDownMotionX = ev.getX(newPointerIndex);
1897             mLastMotionY = ev.getY(newPointerIndex);
1898             mLastMotionXRemainder = 0;
1899             mActivePointerId = ev.getPointerId(newPointerIndex);
1900             if (mVelocityTracker != null) {
1901                 mVelocityTracker.clear();
1902             }
1903         }
1904     }
1905 
1906     @Override
1907     public void requestChildFocus(View child, View focused) {
1908         super.requestChildFocus(child, focused);
1909         int page = indexToPage(indexOfChild(child));
1910         if (page &gt;= 0 &amp;&amp; page != getCurrentPage() &amp;&amp; !isInTouchMode()) {
1911             snapToPage(page);
1912         }
1913     }
1914 
1915     protected int getChildWidth(int index) {
1916         return getPageAt(index).getMeasuredWidth();
1917     }
1918 
1919     int getPageNearestToPoint(float x) {
1920         int index = 0;
1921         for (int i = 0; i &lt; getChildCount(); ++i) {
1922             if (x &lt; getChildAt(i).getRight() - getScrollX()) {
1923                 return index;
1924             } else {
1925                 index++;
1926             }
1927         }
1928         return Math.min(index, getChildCount() - 1);
1929     }
1930 
1931     int getPageNearestToCenterOfScreen() {
1932         int minDistanceFromScreenCenter = Integer.MAX_VALUE;
1933         int minDistanceFromScreenCenterIndex = -1;
1934         int screenCenter = getViewportOffsetX() + getScrollX() + (getViewportWidth() / 2);
1935         final int childCount = getChildCount();
1936         for (int i = 0; i &lt; childCount; ++i) {
1937             View layout = (View) getPageAt(i);
1938             int childWidth = layout.getMeasuredWidth();
1939             int halfChildWidth = (childWidth / 2);
1940             int childCenter = getViewportOffsetX() + getChildOffset(i) + halfChildWidth;
1941             int distanceFromScreenCenter = Math.abs(childCenter - screenCenter);
1942             if (distanceFromScreenCenter &lt; minDistanceFromScreenCenter) {
1943                 minDistanceFromScreenCenter = distanceFromScreenCenter;
1944                 minDistanceFromScreenCenterIndex = i;
1945             }
1946         }
1947         return minDistanceFromScreenCenterIndex;
1948     }
1949 
1950     protected void snapToDestination() {
1951         snapToPage(getPageNearestToCenterOfScreen(), PAGE_SNAP_ANIMATION_DURATION);
1952     }
1953 
1954     private static class ScrollInterpolator implements Interpolator {
1955         public ScrollInterpolator() {
1956         }
1957 
1958         public float getInterpolation(float t) {
1959             t -= 1.0f;
1960             return t*t*t*t*t + 1;
1961         }
1962     }
1963 
1964     // We want the duration of the page snap animation to be influenced by the distance that
1965     // the screen has to travel, however, we don&#x27;t want this duration to be effected in a
1966     // purely linear fashion. Instead, we use this method to moderate the effect that the distance
1967     // of travel has on the overall snap duration.
1968     float distanceInfluenceForSnapDuration(float f) {
1969         f -= 0.5f; // center the values about 0.
1970         f *= 0.3f * Math.PI / 2.0f;
1971         return (float) Math.sin(f);
1972     }
1973 
1974     protected void snapToPageWithVelocity(int whichPage, int velocity) {
1975         whichPage = Math.max(0, Math.min(whichPage, getChildCount() - 1));
1976         int halfScreenSize = getViewportWidth() / 2;
1977 
1978         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
1979         if (DEBUG) Log.d(TAG, &quot;snapToPageWithVelocity.getRelativeChildOffset(): &quot;
1980                 + getViewportWidth() + &quot;, &quot; + getChildWidth(whichPage));
1981         final int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
1982         int delta = newX - mUnboundedScrollX;
1983         int duration = 0;
1984 
1985         if (Math.abs(velocity) &lt; mMinFlingVelocity) {
1986             // If the velocity is low enough, then treat this more as an automatic page advance
1987             // as opposed to an apparent physical response to flinging
1988             snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
1989             return;
1990         }
1991 
1992         // Here we compute a &quot;distance&quot; that will be used in the computation of the overall
1993         // snap duration. This is a function of the actual distance that needs to be traveled;
1994         // we keep this value close to half screen size in order to reduce the variance in snap
1995         // duration as a function of the distance the page needs to travel.
1996         float distanceRatio = Math.min(1f, 1.0f * Math.abs(delta) / (2 * halfScreenSize));
1997         float distance = halfScreenSize + halfScreenSize *
1998                 distanceInfluenceForSnapDuration(distanceRatio);
1999 
2000         velocity = Math.abs(velocity);
2001         velocity = Math.max(mMinSnapVelocity, velocity);
2002 
2003         // we want the page&#x27;s snap velocity to approximately match the velocity at which the
2004         // user flings, so we scale the duration by a value near to the derivative of the scroll
2005         // interpolator at zero, ie. 5. We use 4 to make it a little slower.
2006         duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
2007 
2008         snapToPage(whichPage, delta, duration);
2009     }
2010 
2011     protected void snapToPage(int whichPage) {
2012         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2013     }
2014 
2015     protected void snapToPageImmediately(int whichPage) {
2016         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION, true);
2017     }
2018 
2019     protected void snapToPage(int whichPage, int duration) {
2020         snapToPage(whichPage, duration, false);
2021     }
2022 
2023     protected void snapToPage(int whichPage, int duration, boolean immediate) {
2024         whichPage = Math.max(0, Math.min(whichPage, getPageCount() - 1));
2025 
2026         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2027         if (DEBUG) Log.d(TAG, &quot;snapToPage.getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
2028                 + getChildWidth(whichPage));
2029         int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2030         final int sX = mUnboundedScrollX;
2031         final int delta = newX - sX;
2032         snapToPage(whichPage, delta, duration, immediate);
2033     }
2034 
2035     protected void snapToPage(int whichPage, int delta, int duration) {
2036         snapToPage(whichPage, delta, duration, false);
2037     }
2038 
2039     protected void snapToPage(int whichPage, int delta, int duration, boolean immediate) {
2040         mNextPage = whichPage;
2041         View focusedChild = getFocusedChild();
2042         if (focusedChild != null &amp;&amp; whichPage != mCurrentPage &amp;&amp;
2043                 focusedChild == getPageAt(mCurrentPage)) {
2044             focusedChild.clearFocus();
2045         }
2046 
2047         pageBeginMoving();
2048         awakenScrollBars(duration);
2049         if (immediate) {
2050             duration = 0;
2051         } else if (duration == 0) {
2052             duration = Math.abs(delta);
2053         }
2054 
2055         if (!mScroller.isFinished()) mScroller.abortAnimation();
2056         mScroller.startScroll(mUnboundedScrollX, 0, delta, 0, duration);
2057 
2058         notifyPageSwitchListener();
2059 
2060         // Trigger a compute() to finish switching pages if necessary
2061         if (immediate) {
2062             computeScroll();
2063         }
2064 
2065         mForceScreenScrolled = true;
2066         invalidate();
2067     }
2068 
2069     public void scrollLeft() {
2070         if (mScroller.isFinished()) {
2071             if (mCurrentPage &gt; 0) snapToPage(mCurrentPage - 1);
2072         } else {
2073             if (mNextPage &gt; 0) snapToPage(mNextPage - 1);
2074         }
2075     }
2076 
2077     public void scrollRight() {
2078         if (mScroller.isFinished()) {
2079             if (mCurrentPage &lt; getChildCount() -1) snapToPage(mCurrentPage + 1);
2080         } else {
2081             if (mNextPage &lt; getChildCount() -1) snapToPage(mNextPage + 1);
2082         }
2083     }
2084 
2085     public int getPageForView(View v) {
2086         int result = -1;
2087         if (v != null) {
2088             ViewParent vp = v.getParent();
2089             int count = getChildCount();
2090             for (int i = 0; i &lt; count; i++) {
2091                 if (vp == getPageAt(i)) {
2092                     return i;
2093                 }
2094             }
2095         }
2096         return result;
2097     }
2098 
2099     /**
2100      * @return True is long presses are still allowed for the current touch
2101      */
2102     public boolean allowLongPress() {
2103         return mAllowLongPress;
2104     }
2105 
2106     /**
2107      * Set true to allow long-press events to be triggered, usually checked by
2108      * {@link Launcher} to accept or block dpad-initiated long-presses.
2109      */
2110     public void setAllowLongPress(boolean allowLongPress) {
2111         mAllowLongPress = allowLongPress;
2112     }
2113 
2114     public static class SavedState extends BaseSavedState {
2115         int currentPage = -1;
2116 
2117         SavedState(Parcelable superState) {
2118             super(superState);
2119         }
2120 
2121         private SavedState(Parcel in) {
2122             super(in);
2123             currentPage = in.readInt();
2124         }
2125 
2126         @Override
2127         public void writeToParcel(Parcel out, int flags) {
2128             super.writeToParcel(out, flags);
2129             out.writeInt(currentPage);
2130         }
2131 
2132         public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
2133                 new Parcelable.Creator&lt;SavedState&gt;() {
2134             public SavedState createFromParcel(Parcel in) {
2135                 return new SavedState(in);
2136             }
2137 
2138             public SavedState[] newArray(int size) {
2139                 return new SavedState[size];
2140             }
2141         };
2142     }
2143 
2144     protected void loadAssociatedPages(int page) {
2145         loadAssociatedPages(page, false);
2146     }
2147     protected void loadAssociatedPages(int page, boolean immediateAndOnly) {
2148         if (mContentIsRefreshable) {
2149             final int count = getChildCount();
2150             if (page &lt; count) {
2151                 int lowerPageBound = getAssociatedLowerPageBound(page);
2152                 int upperPageBound = getAssociatedUpperPageBound(page);
2153                 if (DEBUG) Log.d(TAG, &quot;loadAssociatedPages: &quot; + lowerPageBound + &quot;/&quot;
2154                         + upperPageBound);
2155                 // First, clear any pages that should no longer be loaded
2156                 for (int i = 0; i &lt; count; ++i) {
2157                     Page layout = (Page) getPageAt(i);
2158                     if ((i &lt; lowerPageBound) || (i &gt; upperPageBound)) {
2159                         if (layout.getPageChildCount() &gt; 0) {
2160                             layout.removeAllViewsOnPage();
2161                         }
2162                         mDirtyPageContent.set(i, true);
2163                     }
2164                 }
2165                 // Next, load any new pages
2166                 for (int i = 0; i &lt; count; ++i) {
2167                     if ((i != page) &amp;&amp; immediateAndOnly) {
2168                         continue;
2169                     }
2170                     if (lowerPageBound &lt;= i &amp;&amp; i &lt;= upperPageBound) {
2171                         if (mDirtyPageContent.get(i)) {
2172                             syncPageItems(i, (i == page) &amp;&amp; immediateAndOnly);
2173                             mDirtyPageContent.set(i, false);
2174                         }
2175                     }
2176                 }
2177             }
2178         }
2179     }
2180 
2181     protected int getAssociatedLowerPageBound(int page) {
2182         return Math.max(0, page - 1);
2183     }
2184     protected int getAssociatedUpperPageBound(int page) {
2185         final int count = getChildCount();
2186         return Math.min(page + 1, count - 1);
2187     }
2188 
2189     /**
2190      * This method is called ONLY to synchronize the number of pages that the paged view has.
2191      * To actually fill the pages with information, implement syncPageItems() below.  It is
2192      * guaranteed that syncPageItems() will be called for a particular page before it is shown,
2193      * and therefore, individual page items do not need to be updated in this method.
2194      */
2195     public abstract void syncPages();
2196 
2197     /**
2198      * This method is called to synchronize the items that are on a particular page.  If views on
2199      * the page can be reused, then they should be updated within this method.
2200      */
2201     public abstract void syncPageItems(int page, boolean immediate);
2202 
2203     protected void invalidatePageData() {
2204         invalidatePageData(-1, false);
2205     }
2206     protected void invalidatePageData(int currentPage) {
2207         invalidatePageData(currentPage, false);
2208     }
2209     protected void invalidatePageData(int currentPage, boolean immediateAndOnly) {
2210         if (!mIsDataReady) {
2211             return;
2212         }
2213 
2214         if (mContentIsRefreshable) {
2215             // Force all scrolling-related behavior to end
2216             mScroller.forceFinished(true);
2217             mNextPage = INVALID_PAGE;
2218 
2219             // Update all the pages
2220             syncPages();
2221 
2222             // We must force a measure after we&#x27;ve loaded the pages to update the content width and
2223             // to determine the full scroll width
2224             measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
2225                     MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
2226 
2227             // Set a new page as the current page if necessary
2228             if (currentPage &gt; -1) {
2229                 setCurrentPage(Math.min(getPageCount() - 1, currentPage));
2230             }
2231 
2232             // Mark each of the pages as dirty
2233             final int count = getChildCount();
2234             mDirtyPageContent.clear();
2235             for (int i = 0; i &lt; count; ++i) {
2236                 mDirtyPageContent.add(true);
2237             }
2238 
2239             // Load any pages that are necessary for the current window of views
2240             loadAssociatedPages(mCurrentPage, immediateAndOnly);
2241             requestLayout();
2242         }
2243     }
2244 
2245     // Animate the drag view back to the original position
2246     void animateDragViewToOriginalPosition() {
2247         if (mDragView != null) {
2248             AnimatorSet anim = new AnimatorSet();
2249             anim.setDuration(REORDERING_DROP_REPOSITION_DURATION);
2250             anim.playTogether(
2251                     ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0f),
2252                     ObjectAnimator.ofFloat(mDragView, &quot;translationY&quot;, 0f));
2253             anim.addListener(new AnimatorListenerAdapter() {
2254                 @Override
2255                 public void onAnimationEnd(Animator animation) {
2256                     onPostReorderingAnimationCompleted();
2257                 }
2258             });
2259             anim.start();
2260         }
2261     }
2262 
2263     // &quot;Zooms out&quot; the PagedView to reveal more side pages
2264     protected boolean zoomOut() {
2265         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2266             mZoomInOutAnim.cancel();
2267         }
2268 
2269         if (!(getScaleX() &lt; 1f || getScaleY() &lt; 1f)) {
2270             mZoomInOutAnim = new AnimatorSet();
2271             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2272             mZoomInOutAnim.playTogether(
2273                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, mMinScale),
2274                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, mMinScale));
2275             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2276                 @Override
2277                 public void onAnimationStart(Animator animation) {
2278                     // Show the delete drop target
2279                     if (mDeleteDropTarget != null) {
2280                         mDeleteDropTarget.setVisibility(View.VISIBLE);
2281                         mDeleteDropTarget.animate().alpha(1f)
2282                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2283                             .setListener(new AnimatorListenerAdapter() {
2284                                 @Override
2285                                 public void onAnimationStart(Animator animation) {
2286                                     mDeleteDropTarget.setAlpha(0f);
2287                                 }
2288                             });
2289                     }
2290                 }
2291             });
2292             mZoomInOutAnim.start();
2293             return true;
2294         }
2295         return false;
2296     }
2297 
2298     protected void onStartReordering() {
2299         // Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)
2300         mTouchState = TOUCH_STATE_REORDERING;
2301         mIsReordering = true;
2302 
2303         // Mark all the non-widget pages as invisible
2304         getVisiblePages(mTempVisiblePagesRange);
2305         boundByReorderablePages(true, mTempVisiblePagesRange);
2306         for (int i = 0; i &lt; getPageCount(); ++i) {
2307             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2308                 getPageAt(i).setAlpha(0f);
2309             }
2310         }
2311 
2312         // We must invalidate to trigger a redraw to update the layers such that the drag view
2313         // is always drawn on top
2314         invalidate();
2315     }
2316 
2317     private void onPostReorderingAnimationCompleted() {
2318         // Trigger the callback when reordering has settled
2319         --mPostReorderingPreZoomInRemainingAnimationCount;
2320         if (mPostReorderingPreZoomInRunnable != null &amp;&amp;
2321                 mPostReorderingPreZoomInRemainingAnimationCount == 0) {
2322             mPostReorderingPreZoomInRunnable.run();
2323             mPostReorderingPreZoomInRunnable = null;
2324         }
2325     }
2326 
2327     protected void onEndReordering() {
2328         mIsReordering = false;
2329 
2330         // Mark all the non-widget pages as visible again
2331         getVisiblePages(mTempVisiblePagesRange);
2332         boundByReorderablePages(true, mTempVisiblePagesRange);
2333         for (int i = 0; i &lt; getPageCount(); ++i) {
2334             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2335                 getPageAt(i).setAlpha(1f);
2336             }
2337         }
2338     }
2339 
2340     public boolean startReordering() {
2341         int dragViewIndex = getPageNearestToCenterOfScreen();
2342         mTempVisiblePagesRange[0] = 0;
2343         mTempVisiblePagesRange[1] = getPageCount() - 1;
2344         boundByReorderablePages(true, mTempVisiblePagesRange);
2345         mReorderingStarted = true;
2346 
2347         // Check if we are within the reordering range
2348         if (mTempVisiblePagesRange[0] &lt;= dragViewIndex &amp;&amp;
2349                 dragViewIndex &lt;= mTempVisiblePagesRange[1]) {
2350             if (zoomOut()) {
2351                 // Find the drag view under the pointer
2352                 mDragView = getChildAt(dragViewIndex);
2353 
2354                 onStartReordering();
2355             }
2356             return true;
2357         }
2358         return false;
2359     }
2360 
2361     boolean isReordering(boolean testTouchState) {
2362         boolean state = mIsReordering;
2363         if (testTouchState) {
2364             state &amp;= (mTouchState == TOUCH_STATE_REORDERING);
2365         }
2366         return state;
2367     }
2368     void endReordering() {
2369         // For simplicity, we call endReordering sometimes even if reordering was never started.
2370         // In that case, we don&#x27;t want to do anything.
2371         if (!mReorderingStarted) return;
2372         mReorderingStarted = false;
2373 
2374         // If we haven&#x27;t flung-to-delete the current child, then we just animate the drag view
2375         // back into position
2376         final Runnable onCompleteRunnable = new Runnable() {
2377             @Override
2378             public void run() {
2379                 onEndReordering();
2380             }
2381         };
2382         if (!mDeferringForDelete) {
2383             mPostReorderingPreZoomInRunnable = new Runnable() {
2384                 public void run() {
2385                     zoomIn(onCompleteRunnable);
2386                 };
2387             };
2388 
2389             mPostReorderingPreZoomInRemainingAnimationCount =
2390                     NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT;
2391             // Snap to the current page
2392             snapToPage(indexOfChild(mDragView), 0);
2393             // Animate the drag view back to the front position
2394             animateDragViewToOriginalPosition();
2395         } else {
2396             // Handled in post-delete-animation-callbacks
2397         }
2398     }
2399 
2400     // &quot;Zooms in&quot; the PagedView to highlight the current page
2401     protected boolean zoomIn(final Runnable onCompleteRunnable) {
2402         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2403             mZoomInOutAnim.cancel();
2404         }
2405         if (getScaleX() &lt; 1f || getScaleY() &lt; 1f) {
2406             mZoomInOutAnim = new AnimatorSet();
2407             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2408             mZoomInOutAnim.playTogether(
2409                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 1f),
2410                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, 1f));
2411             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2412                 @Override
2413                 public void onAnimationStart(Animator animation) {
2414                     // Hide the delete drop target
2415                     if (mDeleteDropTarget != null) {
2416                         mDeleteDropTarget.animate().alpha(0f)
2417                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2418                             .setListener(new AnimatorListenerAdapter() {
2419                                 @Override
2420                                 public void onAnimationEnd(Animator animation) {
2421                                     mDeleteDropTarget.setVisibility(View.GONE);
2422                                 }
2423                             });
2424                     }
2425                 }
2426                 @Override
2427                 public void onAnimationCancel(Animator animation) {
2428                     mDragView = null;
2429                 }
2430                 @Override
2431                 public void onAnimationEnd(Animator animation) {
2432                     mDragView = null;
2433                     if (onCompleteRunnable != null) {
2434                         onCompleteRunnable.run();
2435                     }
2436                 }
2437             });
2438             mZoomInOutAnim.start();
2439             return true;
2440         } else {
2441             if (onCompleteRunnable != null) {
2442                 onCompleteRunnable.run();
2443             }
2444         }
2445         return false;
2446     }
2447 
2448     /*
2449      * Flinging to delete - IN PROGRESS
2450      */
2451     private PointF isFlingingToDelete() {
2452         ViewConfiguration config = ViewConfiguration.get(getContext());
2453         mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());
2454 
2455         if (mVelocityTracker.getYVelocity() &lt; mFlingToDeleteThresholdVelocity) {
2456             // Do a quick dot product test to ensure that we are flinging upwards
2457             PointF vel = new PointF(mVelocityTracker.getXVelocity(),
2458                     mVelocityTracker.getYVelocity());
2459             PointF upVec = new PointF(0f, -1f);
2460             float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) /
2461                     (vel.length() * upVec.length()));
2462             if (theta &lt;= Math.toRadians(FLING_TO_DELETE_MAX_FLING_DEGREES)) {
2463                 return vel;
2464             }
2465         }
2466         return null;
2467     }
2468 
2469     /**
2470      * Creates an animation from the current drag view along its current velocity vector.
2471      * For this animation, the alpha runs for a fixed duration and we update the position
2472      * progressively.
2473      */
2474     private static class FlingAlongVectorAnimatorUpdateListener implements AnimatorUpdateListener {
2475         private View mDragView;
2476         private PointF mVelocity;
2477         private Rect mFrom;
2478         private long mPrevTime;
2479         private float mFriction;
2480 
2481         private final TimeInterpolator mAlphaInterpolator = new DecelerateInterpolator(0.75f);
2482 
2483         public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from,
2484                 long startTime, float friction) {
2485             mDragView = dragView;
2486             mVelocity = vel;
2487             mFrom = from;
2488             mPrevTime = startTime;
2489             mFriction = 1f - (mDragView.getResources().getDisplayMetrics().density * friction);
2490         }
2491 
2492         @Override
2493         public void onAnimationUpdate(ValueAnimator animation) {
2494             float t = ((Float) animation.getAnimatedValue()).floatValue();
2495             long curTime = AnimationUtils.currentAnimationTimeMillis();
2496 
2497             mFrom.left += (mVelocity.x * (curTime - mPrevTime) / 1000f);
2498             mFrom.top += (mVelocity.y * (curTime - mPrevTime) / 1000f);
2499 
2500             mDragView.setTranslationX(mFrom.left);
2501             mDragView.setTranslationY(mFrom.top);
2502             mDragView.setAlpha(1f - mAlphaInterpolator.getInterpolation(t));
2503 
2504             mVelocity.x *= mFriction;
2505             mVelocity.y *= mFriction;
2506             mPrevTime = curTime;
2507         }
2508     }
2509 
2510     private static final int ANIM_TAG_KEY = 100;
2511 
2512     private Runnable createPostDeleteAnimationRunnable(final View dragView) {
2513         return new Runnable() {
2514             @Override
2515             public void run() {
2516                 int dragViewIndex = indexOfChild(dragView);
2517 
2518                 // For each of the pages around the drag view, animate them from the previous
2519                 // position to the new position in the layout (as a result of the drag view moving
2520                 // in the layout)
2521                 // NOTE: We can make an assumption here because we have side-bound pages that we
2522                 //       will always have pages to animate in from the left
2523                 getVisiblePages(mTempVisiblePagesRange);
2524                 boundByReorderablePages(true, mTempVisiblePagesRange);
2525                 boolean isLastWidgetPage = (mTempVisiblePagesRange[0] == mTempVisiblePagesRange[1]);
2526                 boolean slideFromLeft = (isLastWidgetPage ||
2527                         dragViewIndex &gt; mTempVisiblePagesRange[0]);
2528 
2529                 // Setup the scroll to the correct page before we swap the views
2530                 if (slideFromLeft) {
2531                     snapToPageImmediately(dragViewIndex - 1);
2532                 }
2533 
2534                 int firstIndex = (isLastWidgetPage ? 0 : mTempVisiblePagesRange[0]);
2535                 int lastIndex = Math.min(mTempVisiblePagesRange[1], getPageCount() - 1);
2536                 int lowerIndex = (slideFromLeft ? firstIndex : dragViewIndex + 1 );
2537                 int upperIndex = (slideFromLeft ? dragViewIndex - 1 : lastIndex);
2538                 ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2539                 for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
2540                     View v = getChildAt(i);
2541                     // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
2542                     // drag view all subsequent views to pageUnderPointIndex will
2543                     // shift down.
2544                     int oldX = 0;
2545                     int newX = 0;
2546                     if (slideFromLeft) {
2547                         if (i == 0) {
2548                             // Simulate the page being offscreen with the page spacing
2549                             oldX = getViewportOffsetX() + getChildOffset(i) - getChildWidth(i)
2550                                     - mPageSpacing;
2551                         } else {
2552                             oldX = getViewportOffsetX() + getChildOffset(i - 1);
2553                         }
2554                         newX = getViewportOffsetX() + getChildOffset(i);
2555                     } else {
2556                         oldX = getChildOffset(i) - getChildOffset(i - 1);
2557                         newX = 0;
2558                     }
2559 
2560                     // Animate the view translation from its old position to its new
2561                     // position
2562                     AnimatorSet anim = (AnimatorSet) v.getTag();
2563                     if (anim != null) {
2564                         anim.cancel();
2565                     }
2566 
2567                     // Note: Hacky, but we want to skip any optimizations to not draw completely
2568                     // hidden views
2569                     v.setAlpha(Math.max(v.getAlpha(), 0.01f));
2570                     v.setTranslationX(oldX - newX);
2571                     anim = new AnimatorSet();
2572                     anim.playTogether(
2573                             ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f),
2574                             ObjectAnimator.ofFloat(v, &quot;alpha&quot;, 1f));
2575                     animations.add(anim);
2576                     v.setTag(ANIM_TAG_KEY, anim);
2577                 }
2578 
2579                 AnimatorSet slideAnimations = new AnimatorSet();
2580                 slideAnimations.playTogether(animations);
2581                 slideAnimations.setDuration(DELETE_SLIDE_IN_SIDE_PAGE_DURATION);
2582                 slideAnimations.addListener(new AnimatorListenerAdapter() {
2583                     @Override
2584                     public void onAnimationEnd(Animator animation) {
2585                         final Runnable onCompleteRunnable = new Runnable() {
2586                             @Override
2587                             public void run() {
2588                                 mDeferringForDelete = false;
2589                                 onEndReordering();
2590                                 onRemoveViewAnimationCompleted();
2591                             }
2592                         };
2593                         zoomIn(onCompleteRunnable);
2594                     }
2595                 });
2596                 slideAnimations.start();
2597 
2598                 removeView(dragView);
2599                 onRemoveView(dragView, true);
2600             }
2601         };
2602     }
2603 
2604     public void onFlingToDelete(PointF vel) {
2605         final long startTime = AnimationUtils.currentAnimationTimeMillis();
2606 
2607         // NOTE: Because it takes time for the first frame of animation to actually be
2608         // called and we expect the animation to be a continuation of the fling, we have
2609         // to account for the time that has elapsed since the fling finished.  And since
2610         // we don&#x27;t have a startDelay, we will always get call to update when we call
2611         // start() (which we want to ignore).
2612         final TimeInterpolator tInterpolator = new TimeInterpolator() {
2613             private int mCount = -1;
2614             private long mStartTime;
2615             private float mOffset;
2616             /* Anonymous inner class ctor */ {
2617                 mStartTime = startTime;
2618             }
2619 
2620             @Override
2621             public float getInterpolation(float t) {
2622                 if (mCount &lt; 0) {
2623                     mCount++;
2624                 } else if (mCount == 0) {
2625                     mOffset = Math.min(0.5f, (float) (AnimationUtils.currentAnimationTimeMillis() -
2626                             mStartTime) / FLING_TO_DELETE_FADE_OUT_DURATION);
2627                     mCount++;
2628                 }
2629                 return Math.min(1f, mOffset + t);
2630             }
2631         };
2632 
2633         final Rect from = new Rect();
2634         final View dragView = mDragView;
2635         from.left = (int) dragView.getTranslationX();
2636         from.top = (int) dragView.getTranslationY();
2637         AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel,
2638                 from, startTime, FLING_TO_DELETE_FRICTION);
2639 
2640         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2641 
2642         // Create and start the animation
2643         ValueAnimator mDropAnim = new ValueAnimator();
2644         mDropAnim.setInterpolator(tInterpolator);
2645         mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
2646         mDropAnim.setFloatValues(0f, 1f);
2647         mDropAnim.addUpdateListener(updateCb);
2648         mDropAnim.addListener(new AnimatorListenerAdapter() {
2649             public void onAnimationEnd(Animator animation) {
2650                 onAnimationEndRunnable.run();
2651             }
2652         });
2653         mDropAnim.start();
2654         mDeferringForDelete = true;
2655     }
2656 
2657     /* Drag to delete */
2658     private boolean isHoveringOverDeleteDropTarget(int x, int y) {
2659         if (mDeleteDropTarget != null) {
2660             mAltTmpRect.set(0, 0, 0, 0);
2661             View parent = (View) mDeleteDropTarget.getParent();
2662             if (parent != null) {
2663                 parent.getGlobalVisibleRect(mAltTmpRect);
2664             }
2665             mDeleteDropTarget.getGlobalVisibleRect(mTmpRect);
2666             mTmpRect.offset(-mAltTmpRect.left, -mAltTmpRect.top);
2667             return mTmpRect.contains(x, y);
2668         }
2669         return false;
2670     }
2671 
2672     protected void setPageHoveringOverDeleteDropTarget(int viewIndex, boolean isHovering) {}
2673 
2674     private void onDropToDelete() {
2675         final View dragView = mDragView;
2676 
2677         final float toScale = 0f;
2678         final float toAlpha = 0f;
2679 
2680         // Create and start the complex animation
2681         ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2682         AnimatorSet motionAnim = new AnimatorSet();
2683         motionAnim.setInterpolator(new DecelerateInterpolator(2));
2684         motionAnim.playTogether(
2685                 ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale),
2686                 ObjectAnimator.ofFloat(dragView, &quot;scaleY&quot;, toScale));
2687         animations.add(motionAnim);
2688 
2689         AnimatorSet alphaAnim = new AnimatorSet();
2690         alphaAnim.setInterpolator(new LinearInterpolator());
2691         alphaAnim.playTogether(
2692                 ObjectAnimator.ofFloat(dragView, &quot;alpha&quot;, toAlpha));
2693         animations.add(alphaAnim);
2694 
2695         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2696 
2697         AnimatorSet anim = new AnimatorSet();
2698         anim.playTogether(animations);
2699         anim.setDuration(DRAG_TO_DELETE_FADE_OUT_DURATION);
2700         anim.addListener(new AnimatorListenerAdapter() {
2701             public void onAnimationEnd(Animator animation) {
2702                 onAnimationEndRunnable.run();
2703             }
2704         });
2705         anim.start();
2706 
2707         mDeferringForDelete = true;
2708     }
2709 
2710     /* Accessibility */
2711     @Override
2712     public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
2713         super.onInitializeAccessibilityNodeInfo(info);
2714         info.setScrollable(getPageCount() &gt; 1);
2715         if (getCurrentPage() &lt; getPageCount() - 1) {
2716             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
2717         }
2718         if (getCurrentPage() &gt; 0) {
2719             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
2720         }
2721     }
2722 
2723     @Override
2724     public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
2725         super.onInitializeAccessibilityEvent(event);
2726         event.setScrollable(true);
2727         if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
2728             event.setFromIndex(mCurrentPage);
2729             event.setToIndex(mCurrentPage);
2730             event.setItemCount(getChildCount());
2731         }
2732     }
2733 
2734     @Override
2735     public boolean performAccessibilityAction(int action, Bundle arguments) {
2736         if (super.performAccessibilityAction(action, arguments)) {
2737             return true;
2738         }
2739         switch (action) {
2740             case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
2741                 if (getCurrentPage() &lt; getPageCount() - 1) {
2742                     scrollRight();
2743                     return true;
2744                 }
2745             } break;
2746             case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
2747                 if (getCurrentPage() &gt; 0) {
2748                     scrollLeft();
2749                     return true;
2750                 }
2751             } break;
2752         }
2753         return false;
2754     }
2755 
2756     protected String getCurrentPageDescription() {
2757         return String.format(getContext().getString(R.string.default_scroll_format),
2758                 getNextPage() + 1, getChildCount());
2759     }
2760 
2761     @Override
2762     public boolean onHoverEvent(android.view.MotionEvent event) {
2763         return true;
2764     }
2765 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2012 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.animation.Animator;
  19 import android.animation.AnimatorListenerAdapter;
  20 import android.animation.AnimatorSet;
  21 import android.animation.ObjectAnimator;
  22 import android.animation.TimeInterpolator;
  23 import android.animation.ValueAnimator.AnimatorUpdateListener;
  24 import android.animation.ValueAnimator;
  25 import android.content.Context;
  26 import android.content.res.Resources;
  27 import android.content.res.TypedArray;
  28 import android.graphics.Canvas;
  29 import android.graphics.Matrix;
  30 import android.graphics.PointF;
  31 import android.graphics.Rect;
  32 import android.os.Bundle;
  33 import android.os.Parcel;
  34 import android.os.Parcelable;
  35 import android.util.AttributeSet;
  36 import android.util.DisplayMetrics;
  37 import android.util.Log;
  38 import android.view.InputDevice;
  39 import android.view.KeyEvent;
  40 import android.view.MotionEvent;
  41 import android.view.VelocityTracker;
  42 import android.view.View;
  43 import android.view.ViewConfiguration;
  44 import android.view.ViewGroup.LayoutParams;
  45 import android.view.ViewGroup;
  46 import android.view.ViewParent;
  47 import android.view.accessibility.AccessibilityEvent;
  48 import android.view.accessibility.AccessibilityManager;
  49 import android.view.accessibility.AccessibilityNodeInfo;
  50 import android.view.animation.AnimationUtils;
  51 import android.view.animation.DecelerateInterpolator;
  52 import android.view.animation.Interpolator;
  53 import android.view.animation.LinearInterpolator;
  54 import android.widget.FrameLayout;
  55 import android.widget.Scroller;
  56 import java.util.ArrayList;
  57 
  58 
  59 /**
  60  * An abstraction of the original Workspace which supports browsing through a
  61  * sequential list of &quot;pages&quot;
  62  */
  63 public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
  64     private static final String TAG = &quot;PagedView&quot;;
  65 
  66     private static final boolean DEBUG = false;
  67 
  68     protected static final int INVALID_PAGE = -1;
  69 
  70     // the min drag distance for a fling to register, to prevent random page shifts
  71     private static final int MIN_LENGTH_FOR_FLING = 25;
  72 
  73     protected static final int PAGE_SNAP_ANIMATION_DURATION = 750;
  74 
  75     protected static final int SLOW_PAGE_SNAP_ANIMATION_DURATION = 950;
  76 
  77     protected static final float NANOTIME_DIV = 1000000000.0f;
  78 
  79     private static final float OVERSCROLL_ACCELERATE_FACTOR = 2;
  80 
  81     private static final float OVERSCROLL_DAMP_FACTOR = 0.14f;
  82 
  83     private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD = 0.33f;
  84 
  85     // The page is moved more than halfway, automatically move to the next page on touch up.
  86     private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4F;
  87 
  88     // The following constants need to be scaled based on density. The scaled versions will be
  89     // assigned to the corresponding member variables below.
  90     // The following constants need to be scaled based on density. The scaled versions will be
  91     // assigned to the corresponding member variables below.
  92     private static final int FLING_THRESHOLD_VELOCITY = 500;
  93 
  94     private static final int MIN_SNAP_VELOCITY = 1500;
  95 
  96     private static final int MIN_FLING_VELOCITY = 250;
  97 
  98     // We are disabling touch interaction of the widget region for factory ROM.
  99     // We are disabling touch interaction of the widget region for factory ROM.
 100     private static final boolean DISABLE_TOUCH_INTERACTION = false;
 101 
 102     private static final boolean DISABLE_TOUCH_SIDE_PAGES = false;
 103 
 104     private static final boolean DISABLE_FLING_TO_DELETE = true;
 105 
 106     static final int AUTOMATIC_PAGE_SPACING = -1;
 107 
 108     protected int mFlingThresholdVelocity;
 109 
 110     protected int mMinFlingVelocity;
 111 
 112     protected int mMinSnapVelocity;
 113 
 114     protected float mDensity;
 115 
 116     protected float mSmoothingTime;
 117 
 118     protected float mTouchX;
 119 
 120     protected boolean mFirstLayout = true;
 121 
 122     protected int mCurrentPage;
 123 
 124     protected int mChildCountOnLastMeasure;
 125 
 126     protected int mNextPage = INVALID_PAGE;
 127 
 128     protected int mMaxScrollX;
 129 
 130     protected Scroller mScroller;
 131 
 132     private VelocityTracker mVelocityTracker;
 133 
 134     private float mParentDownMotionX;
 135 
 136     private float mParentDownMotionY;
 137 
 138     private float mDownMotionX;
 139 
 140     private float mDownMotionY;
 141 
 142     private float mDownScrollX;
 143 
 144     protected float mLastMotionX;
 145 
 146     protected float mLastMotionXRemainder;
 147 
 148     protected float mLastMotionY;
 149 
 150     protected float mTotalMotionX;
 151 
 152     private int mLastScreenCenter = -1;
 153 
 154     private int[] mChildOffsets;
 155 
 156     private int[] mChildRelativeOffsets;
 157 
 158     protected final static int TOUCH_STATE_REST = 0;
 159 
 160     protected final static int TOUCH_STATE_SCROLLING = 1;
 161 
 162     protected final static int TOUCH_STATE_PREV_PAGE = 2;
 163 
 164     protected final static int TOUCH_STATE_NEXT_PAGE = 3;
 165 
 166     protected final static int TOUCH_STATE_REORDERING = 4;
 167 
 168     protected final static float ALPHA_QUANTIZE_LEVEL = 0.0001f;
 169 
 170     protected int mTouchState = TOUCH_STATE_REST;
 171 
 172     protected boolean mForceScreenScrolled = false;
 173 
 174     protected OnLongClickListener mLongClickListener;
 175 
 176     protected int mTouchSlop;
 177 
 178     private int mPagingTouchSlop;
 179 
 180     private int mMaximumVelocity;
 181 
 182     protected int mPageSpacing;
 183 
 184     protected int mPageLayoutPaddingTop;
 185 
 186     protected int mPageLayoutPaddingBottom;
 187 
 188     protected int mPageLayoutPaddingLeft;
 189 
 190     protected int mPageLayoutPaddingRight;
 191 
 192     protected int mPageLayoutWidthGap;
 193 
 194     protected int mPageLayoutHeightGap;
 195 
 196     protected int mCellCountX = 0;
 197 
 198     protected int mCellCountY = 0;
 199 
 200     protected boolean mCenterPagesVertically;
 201 
 202     protected boolean mAllowOverScroll = true;
 203 
 204     protected int mUnboundedScrollX;
 205 
 206     protected int[] mTempVisiblePagesRange = new int[2];
 207 
 208     protected boolean mForceDrawAllChildrenNextFrame;
 209 
 210     // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 211     // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 212     // the screens from continuing to translate beyond the normal bounds.
 213     // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 214     // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 215     // the screens from continuing to translate beyond the normal bounds.
 216     protected int mOverScrollX;
 217 
 218     protected static final int INVALID_POINTER = -1;
 219 
 220     protected int mActivePointerId = INVALID_POINTER;
 221 
 222     private PageSwitchListener mPageSwitchListener;
 223 
 224     protected ArrayList&lt;Boolean&gt; mDirtyPageContent;
 225 
 226     // If true, syncPages and syncPageItems will be called to refresh pages
 227     protected boolean mContentIsRefreshable = true;
 228 
 229     // If true, modify alpha of neighboring pages as user scrolls left/right
 230     protected boolean mFadeInAdjacentScreens = false;
 231 
 232     // It true, use a different slop parameter (pagingTouchSlop = 2 * touchSlop) for deciding
 233     // to switch to a new page
 234     protected boolean mUsePagingTouchSlop = true;
 235 
 236     // If true, the subclass should directly update scrollX itself in its computeScroll method
 237     // (SmoothPagedView does this)
 238     protected boolean mDeferScrollUpdate = false;
 239 
 240     protected boolean mIsPageMoving = false;
 241 
 242     // All syncs and layout passes are deferred until data is ready.
 243     // All syncs and layout passes are deferred until data is ready.
 244     protected boolean mIsDataReady = false;
 245 
 246     protected boolean mAllowLongPress = true;
 247 
 248     // Page Indicator
 249     private int mPageIndicatorViewId;
 250 
 251     private PageIndicator mPageIndicator;
 252 
 253     // The viewport whether the pages are to be contained (the actual view may be larger than the
 254     // viewport)
 255     // The viewport whether the pages are to be contained (the actual view may be larger than the
 256     // viewport)
 257     private Rect mViewport = new Rect();
 258 
 259     // Reordering
 260     // We use the min scale to determine how much to expand the actually PagedView measured
 261     // dimensions such that when we are zoomed out, the view is not clipped
 262     private int REORDERING_DROP_REPOSITION_DURATION = 200;
 263 
 264     protected int REORDERING_REORDER_REPOSITION_DURATION = 300;
 265 
 266     protected int REORDERING_ZOOM_IN_OUT_DURATION = 250;
 267 
 268     private int REORDERING_SIDE_PAGE_HOVER_TIMEOUT = 300;
 269 
 270     private float REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE = 0.1f;
 271 
 272     private long REORDERING_DELETE_DROP_TARGET_FADE_DURATION = 150;
 273 
 274     private float mMinScale = 1f;
 275 
 276     protected View mDragView;
 277 
 278     protected AnimatorSet mZoomInOutAnim;
 279 
 280     private Runnable mSidePageHoverRunnable;
 281 
 282     private int mSidePageHoverIndex = -1;
 283 
 284     // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 285     // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 286     private boolean mReorderingStarted = false;
 287 
 288     // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 289     // animation after endReordering()
 290     // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 291     // animation after endReordering()
 292     private boolean mIsReordering;
 293 
 294     // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 295     // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 296     private int NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT = 2;
 297 
 298     private int mPostReorderingPreZoomInRemainingAnimationCount;
 299 
 300     private Runnable mPostReorderingPreZoomInRunnable;
 301 
 302     // Edge swiping
 303     // Edge swiping
 304     private boolean mOnlyAllowEdgeSwipes = false;
 305 
 306     private boolean mDownEventOnEdge = false;
 307 
 308     private int mEdgeSwipeRegionSize = 0;
 309 
 310     // Convenience/caching
 311     // Convenience/caching
 312     private Matrix mTmpInvMatrix = new Matrix();
 313 
 314     private float[] mTmpPoint = new float[2];
 315 
 316     private Rect mTmpRect = new Rect();
 317 
 318     private Rect mAltTmpRect = new Rect();
 319 
 320     // Fling to delete
 321     // Fling to delete
 322     private int FLING_TO_DELETE_FADE_OUT_DURATION = 350;
 323 
 324     private float FLING_TO_DELETE_FRICTION = 0.035f;
 325 
 326     // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 327     // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 328     private float FLING_TO_DELETE_MAX_FLING_DEGREES = 65f;
 329 
 330     protected int mFlingToDeleteThresholdVelocity = -1400;
 331 
 332     // Drag to delete
 333     // Drag to delete
 334     private boolean mDeferringForDelete = false;
 335 
 336     private int DELETE_SLIDE_IN_SIDE_PAGE_DURATION = 250;
 337 
 338     private int DRAG_TO_DELETE_FADE_OUT_DURATION = 350;
 339 
 340     // Drop to delete
 341     // Drop to delete
 342     private View mDeleteDropTarget;
 343 
 344     private boolean mAutoComputePageSpacing = false;
 345 
 346     private boolean mRecomputePageSpacing = false;
 347 
 348     // Bouncer
 349     // Bouncer
 350     private boolean mTopAlignPageWhenShrinkingForBouncer = false;
 351 
 352     public interface PageSwitchListener {
 353         public abstract void onPageSwitch(View newPage, int newPageIndex);
 354     }
 355 
 356     public PagedView(Context context) {
 357         this(context, null);
 358     }
 359 
 360     public PagedView(Context context, AttributeSet attrs) {
 361         this(context, attrs, 0);
 362     }
 363 
 364     public PagedView(Context context, AttributeSet attrs, int defStyle) {
 365         super(context, attrs, defStyle);
 366         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PagedView, defStyle, 0);
 367         setPageSpacing(a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing, 0));
 368         if (mPageSpacing &lt; 0) {
 369             mAutoComputePageSpacing = mRecomputePageSpacing = true;
 370         }
 371         mPageLayoutPaddingTop = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingTop, 0);
<abbr title=" 372         mPageLayoutPaddingBottom = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingBottom, 0);"> 372         mPageLayoutPaddingBottom = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingBottom,🔵</abbr>
 373         mPageLayoutPaddingLeft = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingLeft, 0);
<abbr title=" 374         mPageLayoutPaddingRight = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingRight, 0);"> 374         mPageLayoutPaddingRight = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutPaddingRight, 0🔵</abbr>
 375         mPageLayoutWidthGap = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutWidthGap, 0);
 376         mPageLayoutHeightGap = a.getDimensionPixelSize(R.styleable.PagedView_pageLayoutHeightGap, 0);
 377         mPageIndicatorViewId = a.getResourceId(R.styleable.PagedView_pageIndicator, -1);
 378         a.recycle();
 379         setHapticFeedbackEnabled(false);
 380         init();
 381     }
 382 
 383     /**
 384      * Initializes various states for this workspace.
 385      */
 386     protected void init() {
 387         mDirtyPageContent = new ArrayList&lt;Boolean&gt;();
 388         mDirtyPageContent.ensureCapacity(32);
 389         mScroller = new Scroller(getContext(), new ScrollInterpolator());
 390         mCurrentPage = 0;
 391         mCenterPagesVertically = true;
 392 
 393         final ViewConfiguration configuration = ViewConfiguration.get(getContext());
 394         mTouchSlop = configuration.getScaledPagingTouchSlop();
 395         mPagingTouchSlop = configuration.getScaledPagingTouchSlop();
 396         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
 397         mDensity = getResources().getDisplayMetrics().density;
 398 
 399         // Scale the fling-to-delete threshold by the density
 400         mFlingToDeleteThresholdVelocity =
 401                 (int) (mFlingToDeleteThresholdVelocity * mDensity);
 402 
 403         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 404         mMinFlingVelocity = (int) (MIN_FLING_VELOCITY * mDensity);
 405         mMinSnapVelocity = (int) (MIN_SNAP_VELOCITY * mDensity);
 406         setOnHierarchyChangeListener(this);
 407     }
 408 
 409     protected void onAttachedToWindow() {
 410         // Hook up the page indicator
 411         ViewGroup parent = ((ViewGroup) (getParent()));
 412         if ((mPageIndicator == null) &amp;&amp; (mPageIndicatorViewId &gt; (-1))) {
 413             mPageIndicator = ((PageIndicator) (parent.findViewById(mPageIndicatorViewId)));
 414             mPageIndicator.removeAllMarkers();
 415             mPageIndicator.addMarkers(getChildCount());
 416         }
 417     }
 418 
 419     protected void onDetachedFromWindow() {
 420         // Unhook the page indicator
 421         mPageIndicator = null;
 422     }
 423 
 424     void setDeleteDropTarget(View v) {
 425         mDeleteDropTarget = v;
 426     }
 427 
 428     // Convenience methods to map points from self to parent and vice versa
 429     float[] mapPointFromViewToParent(View v, float x, float y) {
 430         mTmpPoint[0] = x;
 431         mTmpPoint[1] = y;
 432         v.getMatrix().mapPoints(mTmpPoint);
 433         mTmpPoint[0] += v.getLeft();
 434         mTmpPoint[1] += v.getTop();
 435         return mTmpPoint;
 436     }
 437 
 438     float[] mapPointFromParentToView(View v, float x, float y) {
 439         mTmpPoint[0] = x - v.getLeft();
 440         mTmpPoint[1] = y - v.getTop();
 441         v.getMatrix().invert(mTmpInvMatrix);
 442         mTmpInvMatrix.mapPoints(mTmpPoint);
 443         return mTmpPoint;
 444     }
 445 
 446     void updateDragViewTranslationDuringDrag() {
 447         float x = mLastMotionX - mDownMotionX + getScrollX() - mDownScrollX;
 448         float y = mLastMotionY - mDownMotionY;
 449         mDragView.setTranslationX(x);
 450         mDragView.setTranslationY(y);
 451 
 452         if (DEBUG) Log.d(TAG, &quot;PagedView.updateDragViewTranslationDuringDrag(): &quot; + x + &quot;, &quot; + y);
 453     }
 454 
 455     public void setMinScale(float f) {
 456         mMinScale = f;
 457         requestLayout();
 458     }
 459 
 460     @Override
 461     public void setScaleX(float scaleX) {
 462         super.setScaleX(scaleX);
 463         if (isReordering(true)) {
 464             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 465             mLastMotionX = p[0];
 466             mLastMotionY = p[1];
 467             updateDragViewTranslationDuringDrag();
 468         }
 469     }
 470 
 471     // Convenience methods to get the actual width/height of the PagedView (since it is measured
 472     // to be larger to account for the minimum possible scale)
 473     int getViewportWidth() {
 474         return mViewport.width();
 475     }
 476 
 477     int getViewportHeight() {
 478         return mViewport.height();
 479     }
 480 
 481     // Convenience methods to get the offset ASSUMING that we are centering the pages in the
 482     // PagedView both horizontally and vertically
 483     int getViewportOffsetX() {
 484         return (getMeasuredWidth() - getViewportWidth()) / 2;
 485     }
 486 
 487     int getViewportOffsetY() {
 488         return (getMeasuredHeight() - getViewportHeight()) / 2;
 489     }
 490 
 491     public void setPageSwitchListener(PageSwitchListener pageSwitchListener) {
 492         mPageSwitchListener = pageSwitchListener;
 493         if (mPageSwitchListener != null) {
 494             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 495         }
 496     }
 497 
 498     /**
 499      * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.
 500      */
 501     public boolean isLayoutRtl() {
 502         return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
 503     }
 504 
 505     /**
 506      * Called by subclasses to mark that data is ready, and that we can begin loading and laying
 507      * out pages.
 508      */
 509     protected void setDataIsReady() {
 510         mIsDataReady = true;
 511     }
 512 
 513     protected boolean isDataReady() {
 514         return mIsDataReady;
 515     }
 516 
 517     /**
 518      * Returns the index of the currently displayed page.
 519      *
 520      * @return The index of the currently displayed page.
 521      */
 522     int getCurrentPage() {
 523         return mCurrentPage;
 524     }
 525 
 526     int getNextPage() {
 527         return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
 528     }
 529 
 530     int getPageCount() {
 531         return getChildCount();
 532     }
 533 
 534     View getPageAt(int index) {
 535         return getChildAt(index);
 536     }
 537 
 538     protected int indexToPage(int index) {
 539         return index;
 540     }
 541 
 542     /**
 543      * Updates the scroll of the current page immediately to its final scroll position.  We use this
 544      * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of
 545      * the previous tab page.
 546      */
 547     protected void updateCurrentPageScroll() {
 548         // If the current page is invalid, just reset the scroll position to zero
 549         int newX = 0;
 550         if (0 &lt;= mCurrentPage &amp;&amp; mCurrentPage &lt; getPageCount()) {
 551             int offset = getChildOffset(mCurrentPage);
 552             int relOffset = getRelativeChildOffset(mCurrentPage);
 553             newX = offset - relOffset;
 554         }
 555         scrollTo(newX, 0);
 556         mScroller.setFinalX(newX);
 557         mScroller.forceFinished(true);
 558     }
 559 
 560     /**
 561      * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation
 562      * ends, {@link #resumeScrolling()} should be called, along with
 563      * {@link #updateCurrentPageScroll()} to correctly set the final state and re-enable scrolling.
 564      */
 565     void pauseScrolling() {
 566         mScroller.forceFinished(true);
 567     }
 568 
 569     /**
 570      * Enables scrolling again.
 571      * @see #pauseScrolling()
 572      */
 573     void resumeScrolling() {
 574     }
 575 
 576     /**
 577      * Sets the current page.
 578      */
 579     void setCurrentPage(int currentPage) {
 580         if (!mScroller.isFinished()) {
 581             mScroller.abortAnimation();
 582         }
 583         // don&#x27;t introduce any checks like mCurrentPage == currentPage here-- if we change the
 584         // the default
 585         if (getChildCount() == 0) {
 586             return;
 587         }
 588         mForceScreenScrolled = true;
 589         mCurrentPage = Math.max(0, Math.min(currentPage, getPageCount() - 1));
 590         notifyPageSwitchListener();
 591         invalidate();
 592     }
 593 
 594     protected void notifyPageSwitchListener() {
 595         if (mPageSwitchListener != null) {
 596             mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 597         }
 598         // Update the page indicator (when we aren&#x27;t reordering)
 599         if ((mPageIndicator != null) &amp;&amp; (!isReordering(false))) {
 600             mPageIndicator.setActiveMarker(getNextPage());
 601         }
 602     }
 603 
 604     protected void pageBeginMoving() {
 605         if (!mIsPageMoving) {
 606             mIsPageMoving = true;
 607             onPageBeginMoving();
 608         }
 609     }
 610 
 611     protected void pageEndMoving() {
 612         if (mIsPageMoving) {
 613             mIsPageMoving = false;
 614             onPageEndMoving();
 615         }
 616     }
 617 
 618     protected boolean isPageMoving() {
 619         return mIsPageMoving;
 620     }
 621 
 622     // a method that subclasses can override to add behavior
 623     protected void onPageBeginMoving() {
 624     }
 625 
 626     // a method that subclasses can override to add behavior
 627     protected void onPageEndMoving() {
 628     }
 629 
 630     /**
 631      * Registers the specified listener on each page contained in this workspace.
 632      *
 633      * @param l The listener used to respond to long clicks.
 634      */
 635     @Override
 636     public void setOnLongClickListener(OnLongClickListener l) {
 637         mLongClickListener = l;
 638         final int count = getPageCount();
 639         for (int i = 0; i &lt; count; i++) {
 640             getPageAt(i).setOnLongClickListener(l);
 641         }
 642     }
 643 
 644     @Override
 645     public void scrollBy(int x, int y) {
 646         scrollTo(mUnboundedScrollX + x, getScrollY() + y);
 647     }
 648 
 649     @Override
 650     public void scrollTo(int x, int y) {
 651         final boolean isRtl = isLayoutRtl();
 652         mUnboundedScrollX = x;
 653 
 654         boolean isXBeforeFirstPage = isRtl ? (x &gt; mMaxScrollX) : (x &lt; 0);
 655         boolean isXAfterLastPage = isRtl ? (x &lt; 0) : (x &gt; mMaxScrollX);
 656         if (isXBeforeFirstPage) {
 657             super.scrollTo(0, y);
 658             if (mAllowOverScroll) {
 659                 if (isRtl) {
 660                     overScroll(x - mMaxScrollX);
 661                 } else {
 662                     overScroll(x);
 663                 }
 664             }
 665         } else if (isXAfterLastPage) {
 666             super.scrollTo(mMaxScrollX, y);
 667             if (mAllowOverScroll) {
 668                 if (isRtl) {
 669                     overScroll(x);
 670                 } else {
 671                     overScroll(x - mMaxScrollX);
 672                 }
 673             }
 674         } else {
 675             mOverScrollX = x;
 676             super.scrollTo(x, y);
 677         }
 678 
 679         mTouchX = x;
 680         mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
 681 
 682         // Update the last motion events when scrolling
 683         if (isReordering(true)) {
 684             float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 685             mLastMotionX = p[0];
 686             mLastMotionY = p[1];
 687             updateDragViewTranslationDuringDrag();
 688         }
 689     }
 690 
 691     // we moved this functionality to a helper function so SmoothPagedView can reuse it
 692     protected boolean computeScrollHelper() {
 693         if (mScroller.computeScrollOffset()) {
 694             // Don&#x27;t bother scrolling if the page does not need to be moved
 695             if (getScrollX() != mScroller.getCurrX()
 696                 || getScrollY() != mScroller.getCurrY()
 697                 || mOverScrollX != mScroller.getCurrX()) {
 698                 scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
 699             }
 700             invalidate();
 701             return true;
 702         } else if (mNextPage != INVALID_PAGE) {
 703             mCurrentPage = Math.max(0, Math.min(mNextPage, getPageCount() - 1));
 704             mNextPage = INVALID_PAGE;
 705             notifyPageSwitchListener();
 706 
 707             // We don&#x27;t want to trigger a page end moving unless the page has settled
 708             // and the user has stopped scrolling
 709             if (mTouchState == TOUCH_STATE_REST) {
 710                 pageEndMoving();
 711             }
 712 
 713             onPostReorderingAnimationCompleted();
 714             // Notify the user when the page changes
 715             AccessibilityManager accessibilityManager = (AccessibilityManager)
 716                     getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
 717             if (accessibilityManager.isEnabled()) {
 718                 AccessibilityEvent ev =
 719                     AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
 720                 ev.getText().add(getCurrentPageDescription());
 721                 sendAccessibilityEventUnchecked(ev);
 722             }
 723             return true;
 724         }
 725         return false;
 726     }
 727 
 728     @Override
 729     public void computeScroll() {
 730         computeScrollHelper();
 731     }
 732 
 733     protected boolean shouldSetTopAlignedPivotForWidget(int childIndex) {
 734         return mTopAlignPageWhenShrinkingForBouncer;
 735     }
 736 
 737     public static class LayoutParams extends ViewGroup.LayoutParams {
 738         public boolean isFullScreenPage = false;
 739 
 740         /**
 741          * {@inheritDoc}
 742          */
 743         public LayoutParams(int width, int height) {
 744             super(width, height);
 745         }
 746 
 747         public LayoutParams(ViewGroup.LayoutParams source) {
 748             super(source);
 749         }
 750     }
 751 
 752     protected LayoutParams generateDefaultLayoutParams() {
<abbr title=" 753         return new LayoutParams(PagedView.LayoutParams.WRAP_CONTENT, PagedView.LayoutParams.WRAP_CONTENT);"> 753         return new LayoutParams(PagedView.LayoutParams.WRAP_CONTENT, PagedView.LayoutParams.WRAP_CONTENT)🔵</abbr>
 754     }
 755 
 756     public void addFullScreenPage(View page, int width, int height) {
 757         LayoutParams lp = generateDefaultLayoutParams();
 758         lp.isFullScreenPage = true;
 759         super.addView(page, 0, lp);
 760     }
 761 
 762     @Override
 763     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 764         if (!mIsDataReady || getChildCount() == 0) {
 765             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 766             return;
 767         }
 768 
 769         // We measure the dimensions of the PagedView to be larger than the pages so that when we
 770         // zoom out (and scale down), the view is still contained in the parent
 771         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
 772         int widthSize = MeasureSpec.getSize(widthMeasureSpec);
 773         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
 774         int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 775         // NOTE: We multiply by 1.5f to account for the fact that depending on the offset of the
 776         // viewport, we can be at most one and a half screens offset once we scale down
 777         DisplayMetrics dm = getResources().getDisplayMetrics();
 778         int maxSize = Math.max(dm.widthPixels, dm.heightPixels);
 779         int parentWidthSize = (int) (1.5f * maxSize);
 780         int parentHeightSize = maxSize;
 781         int scaledWidthSize = (int) (parentWidthSize / mMinScale);
 782         int scaledHeightSize = (int) (parentHeightSize / mMinScale);
 783         mViewport.set(0, 0, widthSize, heightSize);
 784 
 785         if (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {
 786             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 787             return;
 788         }
 789 
 790         // Return early if we aren&#x27;t given a proper dimension
 791         if (widthSize &lt;= 0 || heightSize &lt;= 0) {
 792             super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 793             return;
 794         }
 795 
 796         /* Allow the height to be set as WRAP_CONTENT. This allows the particular case
 797          * of the All apps view on XLarge displays to not take up more space then it needs. Width
 798          * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect
 799          * each page to have the same width.
 800          */
 801         final int verticalPadding = getPaddingTop() + getPaddingBottom();
 802         final int horizontalPadding = getPaddingLeft() + getPaddingRight();
 803 
 804         // The children are given the same width and height as the workspace
 805         // unless they were set to WRAP_CONTENT
 806         if (DEBUG) Log.d(TAG, &quot;PagedView.onMeasure(): &quot; + widthSize + &quot;, &quot; + heightSize);
 807         if (DEBUG) Log.d(TAG, &quot;PagedView.scaledSize: &quot; + scaledWidthSize + &quot;, &quot; + scaledHeightSize);
 808         if (DEBUG) Log.d(TAG, &quot;PagedView.parentSize: &quot; + parentWidthSize + &quot;, &quot; + parentHeightSize);
 809         if (DEBUG) Log.d(TAG, &quot;PagedView.horizontalPadding: &quot; + horizontalPadding);
 810         if (DEBUG) Log.d(TAG, &quot;PagedView.verticalPadding: &quot; + verticalPadding);
 811         final int childCount = getChildCount();
 812         for (int i = 0; i &lt; childCount; i++) {
 813             // disallowing padding in paged view (just pass 0)
 814             final View child = getPageAt(i);
 815             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 816 
 817             int childWidthMode;
 818             int childHeightMode;
 819             int childWidth;
 820             int childHeight;
 821 
 822             if (!lp.isFullScreenPage) {
 823                 if (lp.width == LayoutParams.WRAP_CONTENT) {
 824                     childWidthMode = MeasureSpec.AT_MOST;
 825                 } else {
 826                     childWidthMode = MeasureSpec.EXACTLY;
 827                 }
 828 
 829                 if (lp.height == LayoutParams.WRAP_CONTENT) {
 830                     childHeightMode = MeasureSpec.AT_MOST;
 831                 } else {
 832                     childHeightMode = MeasureSpec.EXACTLY;
 833                 }
 834 
 835                 childWidth = widthSize - horizontalPadding;
 836                 childHeight = heightSize - verticalPadding;
 837 
 838             } else {
 839                 childWidthMode = MeasureSpec.EXACTLY;
 840                 childHeightMode = MeasureSpec.EXACTLY;
 841 
 842                 childWidth = getViewportWidth();
 843                 childHeight = getViewportHeight();
 844             }
 845 
 846             final int childWidthMeasureSpec =
 847                     MeasureSpec.makeMeasureSpec(childWidth, childWidthMode);
 848                 final int childHeightMeasureSpec =
 849                     MeasureSpec.makeMeasureSpec(childHeight, childHeightMode);
 850             child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 851         }
 852         setMeasuredDimension(scaledWidthSize, scaledHeightSize);
 853 
 854         // We can&#x27;t call getChildOffset/getRelativeChildOffset until we set the measured dimensions.
 855         // We also wait until we set the measured dimensions before flushing the cache as well, to
 856         // ensure that the cache is filled with good values.
 857         invalidateCachedOffsets();
 858 
 859         if (childCount &gt; 0) {
 860             if (DEBUG) Log.d(TAG, &quot;getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
 861                     + getChildWidth(0));
 862 
 863             // Calculate the variable page spacing if necessary
 864             if (mAutoComputePageSpacing &amp;&amp; mRecomputePageSpacing) {
 865                 // The gap between pages in the PagedView should be equal to the gap from the page
 866                 // to the edge of the screen (so it is not visible in the current screen).  To
 867                 // account for unequal padding on each side of the paged view, we take the maximum
 868                 // of the left/right gap and use that as the gap between each page.
 869                 int offset = getRelativeChildOffset(0);
 870                 int spacing = Math.max(offset, widthSize - offset -
 871                         getChildAt(0).getMeasuredWidth());
 872                 setPageSpacing(spacing);
 873                 mRecomputePageSpacing = false;
 874             }
 875         }
 876 
 877 
 878 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 879 </span>
 880 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 881 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 881 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 882 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 883 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 884         if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 885                 !mDeferringForDelete) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 886             setCurrentPage(getNextPage());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 887         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 888         mChildCountOnLastMeasure = getChildCount();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 889 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 890         updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 891 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 892 </span>
 893 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 894         if (childCount &gt; 0) {
 895             final int index = isLayoutRtl() ? 0 : childCount - 1;
 896             mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);
 897         } else {
 898             mMaxScrollX = 0;
 899         }
 900     }
 901 
 902     public void setPageSpacing(int pageSpacing) {
 903         mPageSpacing = pageSpacing;
 904         invalidateCachedOffsets();
 905     }
 906 
 907     @Override
 908     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 909         if ((!mIsDataReady) || (getChildCount() == 0)) {
 910             return;
 911         }
 912         if (DEBUG) {
 913             Log.d(TAG, &quot;PagedView.onLayout()&quot;);
 914         }
 915         final int childCount = getChildCount();
 916         int offsetX = getViewportOffsetX();
 917         int offsetY = getViewportOffsetY();
 918         // Update the viewport offsets
 919         mViewport.offset(offsetX, offsetY);
 920         final boolean isRtl = isLayoutRtl();
 921         final int startIndex = (isRtl) ? childCount - 1 : 0;
 922         final int endIndex = (isRtl) ? -1 : childCount;
 923         final int delta = (isRtl) ? -1 : 1;
 924         int verticalPadding = getPaddingTop() + getPaddingBottom();
 925         int childLeft = offsetX + getRelativeChildOffset(startIndex);
 926         for (int i = startIndex; i != endIndex; i += delta) {
 927             final View child = getPageAt(i);
 928             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
 929             int childTop;
 930             if (lp.isFullScreenPage) {
 931                 childTop = offsetY;
 932             } else {
 933                 childTop = offsetY + getPaddingTop();
 934                 if (mCenterPagesVertically) {
<abbr title=" 935                     childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;"> 935                     childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2🔵</abbr>
 936                 }
 937             }
 938             if (child.getVisibility() != View.GONE) {
 939                 final int childWidth = child.getMeasuredWidth();
 940                 final int childHeight = child.getMeasuredHeight();
 941                 if (DEBUG) {
 942                     Log.d(TAG, ((((&quot;\tlayout-child&quot; + i) + &quot;: &quot;) + childLeft) + &quot;, &quot;) + childTop);
 943                 }
<abbr title=" 944                 child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + childHeight);"> 944                 child.layout(childLeft, childTop, childLeft + child.getMeasuredWidth(), childTop + childH🔵</abbr>
 945                 childLeft += childWidth + mPageSpacing;
 946             }
 947         }
 948         if ((mFirstLayout &amp;&amp; (mCurrentPage &gt;= 0)) &amp;&amp; (mCurrentPage &lt; getChildCount())) {
 949             setHorizontalScrollBarEnabled(false);
 950             updateCurrentPageScroll();
 951             setHorizontalScrollBarEnabled(true);
 952             mFirstLayout = false;
 953         }
 954     }
 955 
 956     protected void screenScrolled(int screenCenter) {
 957         boolean isInOverscroll = (mOverScrollX &lt; 0) || (mOverScrollX &gt; mMaxScrollX);
 958         if (mFadeInAdjacentScreens &amp;&amp; (!isInOverscroll)) {
 959             for (int i = 0; i &lt; getChildCount(); i++) {
 960                 View child = getChildAt(i);
 961                 if (child != null) {
 962                     float scrollProgress = getScrollProgress(screenCenter, child, i);
 963                     float alpha = 1 - Math.abs(scrollProgress);
 964                     child.setAlpha(alpha);
 965                 }
 966             }
 967             invalidate();
 968         }
 969     }
 970 
 971     @Override
 972     public void onChildViewAdded(View parent, View child) {
 973         // Update the page indicator, we don&#x27;t update the page indicator as we
 974         // add/remove pages
 975         if ((mPageIndicator != null) &amp;&amp; (!isReordering(false))) {
 976             mPageIndicator.addMarker(indexOfChild(child));
 977         }
 978         // This ensures that when children are added, they get the correct transforms / alphas
 979         // in accordance with any scroll effects.
 980         mForceScreenScrolled = true;
 981         mRecomputePageSpacing = true;
 982         invalidate();
 983         invalidateCachedOffsets();
 984     }
 985 
 986     @Override
 987     public void onChildViewRemoved(View parent, View child) {
 988         mForceScreenScrolled = true;
 989         invalidate();
 990         invalidateCachedOffsets();
 991     }
 992 
 993     private void removeMarkerForView(int index) {
 994         // Update the page indicator, we don&#x27;t update the page indicator as we
 995         // add/remove pages
 996         if ((mPageIndicator != null) &amp;&amp; (!isReordering(false))) {
 997             mPageIndicator.removeMarker(index);
 998         }
 999     }
1000 
1001     @Override
1002     public void removeView(View v) {
1003         // XXX: We should find a better way to hook into this before the view
1004         // gets removed form its parent...
1005         removeMarkerForView(indexOfChild(v));
1006         super.removeView(v);
1007     }
1008 
1009     @Override
1010     public void removeViewInLayout(View v) {
1011         // XXX: We should find a better way to hook into this before the view
1012         // gets removed form its parent...
1013         removeMarkerForView(indexOfChild(v));
1014         super.removeViewInLayout(v);
1015     }
1016 
1017     @Override
1018     public void removeViewAt(int index) {
1019         // XXX: We should find a better way to hook into this before the view
1020         // gets removed form its parent...
1021         removeViewAt(index);
1022         super.removeViewAt(index);
1023     }
1024 
1025     @Override
1026     public void removeAllViewsInLayout() {
1027         // Update the page indicator, we don&#x27;t update the page indicator as we
1028         // add/remove pages
1029         if (mPageIndicator != null) {
1030             mPageIndicator.removeAllMarkers();
1031         }
1032         super.removeAllViewsInLayout();
1033     }
1034 
1035     protected void invalidateCachedOffsets() {
1036         int count = getChildCount();
1037         if (count == 0) {
1038             mChildOffsets = null;
1039             mChildRelativeOffsets = null;
1040             return;
1041         }
1042         mChildOffsets = new int[count];
1043         mChildRelativeOffsets = new int[count];
1044         for (int i = 0; i &lt; count; i++) {
1045             mChildOffsets[i] = -1;
1046             mChildRelativeOffsets[i] = -1;
1047         }
1048     }
1049 
1050     protected int getChildOffset(int index) {
1051         if ((index &lt; 0) || (index &gt; (getChildCount() - 1))) {
1052             return 0;
1053         }
1054         final boolean isRtl = isLayoutRtl();
1055         int[] childOffsets = mChildOffsets;
1056         if ((childOffsets != null) &amp;&amp; (childOffsets[index] != (-1))) {
1057             return childOffsets[index];
1058         } else {
1059             if (getChildCount() == 0) {
1060                 return 0;
1061             }
1062             final int startIndex = (isRtl) ? getChildCount() - 1 : 0;
1063             final int endIndex = (isRtl) ? index : index;
1064             final int delta = (isRtl) ? -1 : 1;
1065             int offset = getRelativeChildOffset(startIndex);
1066             for (int i = startIndex; i != endIndex; i += delta) {
1067                 offset += getPageAt(i).getMeasuredWidth() + mPageSpacing;
1068             }
1069             if (childOffsets != null) {
1070                 childOffsets[index] = offset;
1071             }
1072             return offset;
1073         }
1074     }
1075 
1076     protected int getRelativeChildOffset(int index) {
1077         if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
1078 
1079         if (mChildRelativeOffsets != null &amp;&amp; mChildRelativeOffsets[index] != -1) {
1080             return mChildRelativeOffsets[index];
1081         } else {
1082             final int padding = getPaddingLeft() + getPaddingRight();
1083             final int offset = getPaddingLeft() +
1084                     (getViewportWidth() - padding - getChildWidth(index)) / 2;
1085             if (mChildRelativeOffsets != null) {
1086                 mChildRelativeOffsets[index] = offset;
1087             }
1088             return offset;
1089         }
1090     }
1091 
1092     void boundByReorderablePages(boolean isReordering, int[] range) {
1093         // Do nothing
1094     }
1095 
1096     // TODO: Fix this
1097     protected void getVisiblePages(int[] range) {
1098         range[0] = 0;
1099         range[1] = getPageCount() - 1;
1100 
1101         /*
1102         final int pageCount = getChildCount();
1103 
1104         if (pageCount &gt; 0) {
1105             final int screenWidth = getViewportWidth();
1106             int leftScreen = 0;
1107             int rightScreen = 0;
1108             int offsetX = getViewportOffsetX() + getScrollX();
1109             View currPage = getPageAt(leftScreen);
1110             while (leftScreen &lt; pageCount - 1 &amp;&amp;
1111                     currPage.getX() + currPage.getWidth() -
1112                     currPage.getPaddingRight() &lt; offsetX) {
1113                 leftScreen++;
1114                 currPage = getPageAt(leftScreen);
1115             }
1116             rightScreen = leftScreen;
1117             currPage = getPageAt(rightScreen + 1);
1118             while (rightScreen &lt; pageCount - 1 &amp;&amp;
1119                     currPage.getX() - currPage.getPaddingLeft() &lt; offsetX + screenWidth) {
1120                 rightScreen++;
1121                 currPage = getPageAt(rightScreen + 1);
1122             }
1123 
1124             // TEMP: this is a hacky way to ensure that animations to new pages are not clipped
1125             // because we don&#x27;t draw them while scrolling?
1126             range[0] = Math.max(0, leftScreen - 1);
1127             range[1] = Math.min(rightScreen + 1, getChildCount() - 1);
1128         } else {
1129             range[0] = -1;
1130             range[1] = -1;
1131         }
1132         */
1133     }
1134 
1135     protected boolean shouldDrawChild(View child) {
1136         return child.getAlpha() &gt; 0;
1137     }
1138 
1139     @Override
1140     protected void dispatchDraw(Canvas canvas) {
1141         int halfScreenSize = getViewportWidth() / 2;
1142         // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range.
1143         // Otherwise it is equal to the scaled overscroll position.
1144         int screenCenter = mOverScrollX + halfScreenSize;
1145 
1146         if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
1147             // set mForceScreenScrolled before calling screenScrolled so that screenScrolled can
1148             // set it for the next frame
1149             mForceScreenScrolled = false;
1150             screenScrolled(screenCenter);
1151             mLastScreenCenter = screenCenter;
1152         }
1153 
1154         // Find out which screens are visible; as an optimization we only call draw on them
1155         final int pageCount = getChildCount();
1156         if (pageCount &gt; 0) {
1157             getVisiblePages(mTempVisiblePagesRange);
1158             final int leftScreen = mTempVisiblePagesRange[0];
1159             final int rightScreen = mTempVisiblePagesRange[1];
1160             if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1161                 final long drawingTime = getDrawingTime();
1162                 // Clip to the bounds
1163                 canvas.save();
1164                 canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
1165                         getScrollY() + getBottom() - getTop());
1166 
1167                 // Draw all the children, leaving the drag view for last
1168                 for (int i = pageCount - 1; i &gt;= 0; i--) {
1169                     final View v = getPageAt(i);
1170                     if (v == mDragView) continue;
1171                     if (mForceDrawAllChildrenNextFrame ||
1172                                (leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(v))) {
1173                         drawChild(canvas, v, drawingTime);
1174                     }
1175                 }
1176                 // Draw the drag view on top (if there is one)
1177                 if (mDragView != null) {
1178                     drawChild(canvas, mDragView, drawingTime);
1179                 }
1180 
1181                 mForceDrawAllChildrenNextFrame = false;
1182                 canvas.restore();
1183             }
1184         }
1185     }
1186 
1187     @Override
1188     public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
1189         int page = indexToPage(indexOfChild(child));
1190         if (page != mCurrentPage || !mScroller.isFinished()) {
1191             snapToPage(page);
1192             return true;
1193         }
1194         return false;
1195     }
1196 
1197     @Override
1198     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1199         int focusablePage;
1200         if (mNextPage != INVALID_PAGE) {
1201             focusablePage = mNextPage;
1202         } else {
1203             focusablePage = mCurrentPage;
1204         }
1205         View v = getPageAt(focusablePage);
1206         if (v != null) {
1207             return v.requestFocus(direction, previouslyFocusedRect);
1208         }
1209         return false;
1210     }
1211 
1212     @Override
1213     public boolean dispatchUnhandledMove(View focused, int direction) {
1214         // XXX-RTL: This will be fixed in a future CL
1215         if (direction == View.FOCUS_LEFT) {
1216             if (getCurrentPage() &gt; 0) {
1217                 snapToPage(getCurrentPage() - 1);
1218                 return true;
1219             }
1220         } else if (direction == View.FOCUS_RIGHT) {
1221             if (getCurrentPage() &lt; getPageCount() - 1) {
1222                 snapToPage(getCurrentPage() + 1);
1223                 return true;
1224             }
1225         }
1226         return super.dispatchUnhandledMove(focused, direction);
1227     }
1228 
1229     @Override
1230     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1231         // XXX-RTL: This will be fixed in a future CL
1232         if (mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getPageCount()) {
1233             getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
1234         }
1235         if (direction == View.FOCUS_LEFT) {
1236             if (mCurrentPage &gt; 0) {
1237                 getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
1238             }
1239         } else if (direction == View.FOCUS_RIGHT){
1240             if (mCurrentPage &lt; getPageCount() - 1) {
1241                 getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
1242             }
1243         }
1244     }
1245 
1246     /**
1247      * If one of our descendant views decides that it could be focused now, only
1248      * pass that along if it&#x27;s on the current page.
1249      *
1250      * This happens when live folders requery, and if they&#x27;re off page, they
1251      * end up calling requestFocus, which pulls it on page.
1252      */
1253     @Override
1254     public void focusableViewAvailable(View focused) {
1255         View current = getPageAt(mCurrentPage);
1256         View v = focused;
1257         while (true) {
1258             if (v == current) {
1259                 super.focusableViewAvailable(focused);
1260                 return;
1261             }
1262             if (v == this) {
1263                 return;
1264             }
1265             ViewParent parent = v.getParent();
1266             if (parent instanceof View) {
1267                 v = (View)v.getParent();
1268             } else {
1269                 return;
1270             }
1271         }
1272     }
1273 
1274     /**
1275      * {@inheritDoc}
1276      */
1277     @Override
1278     public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
1279         if (disallowIntercept) {
1280             // We need to make sure to cancel our long press if
1281             // a scrollable widget takes over touch events
1282             final View currentPage = getPageAt(mCurrentPage);
1283             currentPage.cancelLongPress();
1284         }
1285         super.requestDisallowInterceptTouchEvent(disallowIntercept);
1286     }
1287 
1288     /**
1289      * Return true if a tap at (x, y) should trigger a flip to the previous page.
1290      */
1291     protected boolean hitsPreviousPage(float x, float y) {
1292         if (isLayoutRtl()) {
1293             return (x &gt; (getViewportOffsetX() + getViewportWidth() -
1294                     getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1295         }
1296         return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1297     }
1298 
1299     /**
1300      * Return true if a tap at (x, y) should trigger a flip to the next page.
1301      */
1302     protected boolean hitsNextPage(float x, float y) {
1303         if (isLayoutRtl()) {
1304             return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1305         }
1306         return  (x &gt; (getViewportOffsetX() + getViewportWidth() -
1307                 getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1308     }
1309 
1310     /** Returns whether x and y originated within the buffered viewport */
1311     private boolean isTouchPointInViewportWithBuffer(int x, int y) {
1312         mTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top,
1313                 mViewport.right + mViewport.width() / 2, mViewport.bottom);
1314         return mTmpRect.contains(x, y);
1315     }
1316 
1317     /** Returns whether x and y originated within the current page view bounds */
1318     private boolean isTouchPointInCurrentPage(int x, int y) {
1319         View v = getPageAt(getCurrentPage());
1320         if (v != null) {
1321             mTmpRect.set((v.getLeft() - getScrollX()), 0, (v.getRight() - getScrollX()),
1322                     v.getBottom());
1323             return mTmpRect.contains(x, y);
1324         }
1325         return false;
1326     }
1327 
1328     @Override
1329     public boolean onInterceptTouchEvent(MotionEvent ev) {
1330         if (DISABLE_TOUCH_INTERACTION) {
1331             return false;
1332         }
1333 
1334         /*
1335          * This method JUST determines whether we want to intercept the motion.
1336          * If we return true, onTouchEvent will be called and we do the actual
1337          * scrolling there.
1338          */
1339         acquireVelocityTrackerAndAddMovement(ev);
1340 
1341         // Skip touch handling if there are no pages to swipe
1342         if (getChildCount() &lt;= 0) return super.onInterceptTouchEvent(ev);
1343 
1344         /*
1345          * Shortcut the most recurring case: the user is in the dragging
1346          * state and he is moving his finger.  We want to intercept this
1347          * motion.
1348          */
1349         final int action = ev.getAction();
1350         if ((action == MotionEvent.ACTION_MOVE) &amp;&amp;
1351                 (mTouchState == TOUCH_STATE_SCROLLING)) {
1352             return true;
1353         }
1354 
1355         switch (action &amp; MotionEvent.ACTION_MASK) {
1356             case MotionEvent.ACTION_MOVE: {
1357                 /*
1358                  * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
1359                  * whether the user has moved far enough from his original down touch.
1360                  */
1361                 if (mActivePointerId != INVALID_POINTER) {
1362                     determineScrollingStart(ev);
1363                     break;
1364                 }
1365                 // if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN
1366                 // event. in that case, treat the first occurence of a move event as a ACTION_DOWN
1367                 // i.e. fall through to the next case (don&#x27;t break)
1368                 // (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events
1369                 // while it&#x27;s small- this was causing a crash before we checked for INVALID_POINTER)
1370             }
1371 
1372             case MotionEvent.ACTION_DOWN: {
1373                 final float x = ev.getX();
1374                 final float y = ev.getY();
1375                 // Remember location of down touch
1376                 mDownMotionX = x;
1377                 mDownMotionY = y;
1378                 mDownScrollX = getScrollX();
1379                 mLastMotionX = x;
1380                 mLastMotionY = y;
1381                 float[] p = mapPointFromViewToParent(this, x, y);
1382                 mParentDownMotionX = p[0];
1383                 mParentDownMotionY = p[1];
1384                 mLastMotionXRemainder = 0;
1385                 mTotalMotionX = 0;
1386                 mActivePointerId = ev.getPointerId(0);
1387 
1388                 // Determine if the down event is within the threshold to be an edge swipe
1389                 int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1390                 int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1391                 if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1392                     mDownEventOnEdge = true;
1393                 }
1394 
1395                 /*
1396                  * If being flinged and user touches the screen, initiate drag;
1397                  * otherwise don&#x27;t.  mScroller.isFinished should be false when
1398                  * being flinged.
1399                  */
1400                 final int xDist = Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
1401                 final boolean finishedScrolling = (mScroller.isFinished() || xDist &lt; mTouchSlop);
1402                 if (finishedScrolling) {
1403                     mTouchState = TOUCH_STATE_REST;
1404                     mScroller.abortAnimation();
1405                 } else {
1406                     if (isTouchPointInViewportWithBuffer((int) mDownMotionX, (int) mDownMotionY)) {
1407                         mTouchState = TOUCH_STATE_SCROLLING;
1408                     } else {
1409                         mTouchState = TOUCH_STATE_REST;
1410                     }
1411                 }
1412 
1413                 // check if this can be the beginning of a tap on the side of the pages
1414                 // to scroll the current page
1415                 if (!DISABLE_TOUCH_SIDE_PAGES) {
1416                     if (mTouchState != TOUCH_STATE_PREV_PAGE &amp;&amp; mTouchState != TOUCH_STATE_NEXT_PAGE) {
1417                         if (getChildCount() &gt; 0) {
1418                             if (hitsPreviousPage(x, y)) {
1419                                 mTouchState = TOUCH_STATE_PREV_PAGE;
1420                             } else if (hitsNextPage(x, y)) {
1421                                 mTouchState = TOUCH_STATE_NEXT_PAGE;
1422                             }
1423                         }
1424                     }
1425                 }
1426                 break;
1427             }
1428 
1429             case MotionEvent.ACTION_UP:
1430             case MotionEvent.ACTION_CANCEL:
1431                 resetTouchState();
1432                 // Just intercept the touch event on up if we tap outside the strict viewport
1433                 if (!isTouchPointInCurrentPage((int) mLastMotionX, (int) mLastMotionY)) {
1434                     return true;
1435                 }
1436                 break;
1437 
1438             case MotionEvent.ACTION_POINTER_UP:
1439                 onSecondaryPointerUp(ev);
1440                 releaseVelocityTracker();
1441                 break;
1442         }
1443 
1444         /*
1445          * The only time we want to intercept motion events is if we are in the
1446          * drag mode.
1447          */
1448         return mTouchState != TOUCH_STATE_REST;
1449     }
1450 
1451     protected void determineScrollingStart(MotionEvent ev) {
1452         determineScrollingStart(ev, 1.0f);
1453     }
1454 
1455     /*
1456      * Determines if we should change the touch state to start scrolling after the
1457      * user moves their touch point too far.
1458      */
1459     protected void determineScrollingStart(MotionEvent ev, float touchSlopScale) {
1460         // Disallow scrolling if we don&#x27;t have a valid pointer index
1461         final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1462         if (pointerIndex == -1) return;
1463 
1464         // Disallow scrolling if we started the gesture from outside the viewport
1465         final float x = ev.getX(pointerIndex);
1466         final float y = ev.getY(pointerIndex);
1467         if (!isTouchPointInViewportWithBuffer((int) x, (int) y)) return;
1468 
1469         // If we&#x27;re only allowing edge swipes, we break out early if the down event wasn&#x27;t
1470         // at the edge.
1471         if (mOnlyAllowEdgeSwipes &amp;&amp; !mDownEventOnEdge) return;
1472 
1473         final int xDiff = (int) Math.abs(x - mLastMotionX);
1474         final int yDiff = (int) Math.abs(y - mLastMotionY);
1475 
1476         final int touchSlop = Math.round(touchSlopScale * mTouchSlop);
1477         boolean xPaged = xDiff &gt; mPagingTouchSlop;
1478         boolean xMoved = xDiff &gt; touchSlop;
1479         boolean yMoved = yDiff &gt; touchSlop;
1480 
1481         if (xMoved || xPaged || yMoved) {
1482             if (mUsePagingTouchSlop ? xPaged : xMoved) {
1483                 // Scroll if the user moved far enough along the X axis
1484                 mTouchState = TOUCH_STATE_SCROLLING;
1485                 mTotalMotionX += Math.abs(mLastMotionX - x);
1486                 mLastMotionX = x;
1487                 mLastMotionXRemainder = 0;
1488                 mTouchX = getViewportOffsetX() + getScrollX();
1489                 mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1490                 pageBeginMoving();
1491             }
1492         }
1493     }
1494 
1495     protected float getMaxScrollProgress() {
1496         return 1.0f;
1497     }
1498 
1499     protected void cancelCurrentPageLongPress() {
1500         if (mAllowLongPress) {
1501             //mAllowLongPress = false;
1502             // Try canceling the long press. It could also have been scheduled
1503             // by a distant descendant, so use the mAllowLongPress flag to block
1504             // everything
1505             final View currentPage = getPageAt(mCurrentPage);
1506             if (currentPage != null) {
1507                 currentPage.cancelLongPress();
1508             }
1509         }
1510     }
1511 
1512     protected float getBoundedScrollProgress(int screenCenter, View v, int page) {
1513         final int halfScreenSize = getViewportWidth() / 2;
1514 
1515         screenCenter = Math.min(getScrollX() + halfScreenSize, screenCenter);
1516         screenCenter = Math.max(halfScreenSize,  screenCenter);
1517 
1518         return getScrollProgress(screenCenter, v, page);
1519     }
1520 
1521     protected float getScrollProgress(int screenCenter, View v, int page) {
1522         final int halfScreenSize = getViewportWidth() / 2;
1523         int totalDistance = v.getMeasuredWidth() + mPageSpacing;
<abbr title="1524         int delta = screenCenter - ((getChildOffset(page) - getRelativeChildOffset(page)) + halfScreenSize);">1524         int delta = screenCenter - ((getChildOffset(page) - getRelativeChildOffset(page)) + halfScreenSiz🔵</abbr>
1525         float scrollProgress = delta / (totalDistance * 1.0F);
1526         scrollProgress = Math.min(scrollProgress, getMaxScrollProgress());
1527         scrollProgress = Math.max(scrollProgress, -getMaxScrollProgress());
1528         return scrollProgress;
1529     }
1530 
1531     // This curve determines how the effect of scrolling over the limits of the page dimishes
1532     // as the user pulls further and further from the bounds
1533     private float overScrollInfluenceCurve(float f) {
1534         f -= 1.0f;
1535         return f * f * f + 1.0f;
1536     }
1537 
1538     protected void acceleratedOverScroll(float amount) {
1539         int screenSize = getViewportWidth();
1540 
1541         // We want to reach the max over scroll effect when the user has
1542         // over scrolled half the size of the screen
1543         float f = OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
1544 
1545         if (f == 0) return;
1546 
1547         // Clamp this factor, f, to -1 &lt; f &lt; 1
1548         if (Math.abs(f) &gt;= 1) {
1549             f /= Math.abs(f);
1550         }
1551 
1552         int overScrollAmount = (int) Math.round(f * screenSize);
1553         if (amount &lt; 0) {
1554             mOverScrollX = overScrollAmount;
1555             super.scrollTo(0, getScrollY());
1556         } else {
1557             mOverScrollX = mMaxScrollX + overScrollAmount;
1558             super.scrollTo(mMaxScrollX, getScrollY());
1559         }
1560         invalidate();
1561     }
1562 
1563     protected void dampedOverScroll(float amount) {
1564         int screenSize = getViewportWidth();
1565 
1566         float f = (amount / screenSize);
1567 
1568         if (f == 0) return;
1569         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1570 
1571         // Clamp this factor, f, to -1 &lt; f &lt; 1
1572         if (Math.abs(f) &gt;= 1) {
1573             f /= Math.abs(f);
1574         }
1575 
1576         int overScrollAmount = (int) Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
1577         if (amount &lt; 0) {
1578             mOverScrollX = overScrollAmount;
1579             super.scrollTo(0, getScrollY());
1580         } else {
1581             mOverScrollX = mMaxScrollX + overScrollAmount;
1582             super.scrollTo(mMaxScrollX, getScrollY());
1583         }
1584         invalidate();
1585     }
1586 
1587     protected void overScroll(float amount) {
1588         dampedOverScroll(amount);
1589     }
1590 
1591     protected float maxOverScroll() {
1592         // Using the formula in overScroll, assuming that f = 1.0 (which it should generally not
1593         // exceed). Used to find out how much extra wallpaper we need for the over scroll effect
1594         float f = 1.0f;
1595         f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1596         return OVERSCROLL_DAMP_FACTOR * f;
1597     }
1598 
1599     @Override
1600     public boolean onTouchEvent(MotionEvent ev) {
1601         if (DISABLE_TOUCH_INTERACTION) {
1602             return false;
1603         }
1604         // Skip touch handling if there are no pages to swipe
1605         if (getChildCount() &lt;= 0) {
1606             return super.onTouchEvent(ev);
1607         }
1608         acquireVelocityTrackerAndAddMovement(ev);
1609         final int action = ev.getAction();
1610         switch (action &amp; MotionEvent.ACTION_MASK) {
1611             case MotionEvent.ACTION_DOWN :
1612                 /* If being flinged and user touches, stop the fling. isFinished
1613                 will be false if being flinged.
1614                  */
1615                 if (!mScroller.isFinished()) {
1616                     mScroller.abortAnimation();
1617                 }
1618                 // Remember where the motion event started
1619                 mDownMotionX = mLastMotionX = ev.getX();
1620                 mDownMotionY = mLastMotionY = ev.getY();
1621                 mDownScrollX = getScrollX();
1622                 float[] p = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1623                 mParentDownMotionX = p[0];
1624                 mParentDownMotionY = p[1];
1625                 mLastMotionXRemainder = 0;
1626                 mTotalMotionX = 0;
1627                 mActivePointerId = ev.getPointerId(0);
1628                 // Determine if the down event is within the threshold to be an edge swipe
1629                 int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
<abbr title="1630                 int rightEdgeBoundary = (getMeasuredWidth() - getViewportOffsetX()) - mEdgeSwipeRegionSize;">1630                 int rightEdgeBoundary = (getMeasuredWidth() - getViewportOffsetX()) - mEdgeSwipeRegionSiz🔵</abbr>
1631                 if ((mDownMotionX &lt;= leftEdgeBoundary) || (mDownMotionX &gt;= rightEdgeBoundary)) {
1632                     mDownEventOnEdge = true;
1633                 }
1634                 if (mTouchState == TOUCH_STATE_SCROLLING) {
1635                     pageBeginMoving();
1636                 }
1637                 break;
1638             case MotionEvent.ACTION_MOVE :
1639                 if (mTouchState == TOUCH_STATE_SCROLLING) {
1640                     // Scroll to follow the motion event
1641                     final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1642                     if (pointerIndex == (-1)) {
1643                         return true;
1644                     }
1645                     final float x = ev.getX(pointerIndex);
1646                     final float deltaX = (mLastMotionX + mLastMotionXRemainder) - x;
1647                     mTotalMotionX += Math.abs(deltaX);
1648                     // Only scroll and update mLastMotionX if we have moved some discrete amount.  We
1649                     // keep the remainder because we are actually testing if we&#x27;ve moved from the last
1650                     // scrolled position (which is discrete).
1651                     if (Math.abs(deltaX) &gt;= 1.0F) {
1652                         mTouchX += deltaX;
1653                         mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1654                         if (!mDeferScrollUpdate) {
1655                             scrollBy(((int) (deltaX)), 0);
1656                             if (DEBUG) {
1657                                 Log.d(TAG, &quot;onTouchEvent().Scrolling: &quot; + deltaX);
1658                             }
1659                         } else {
1660                             invalidate();
1661                         }
1662                         mLastMotionX = x;
1663                         mLastMotionXRemainder = deltaX - ((int) (deltaX));
1664                     } else {
1665                         awakenScrollBars();
1666                     }
1667                 } else if (mTouchState == TOUCH_STATE_REORDERING) {
1668                     // Update the last motion position
1669                     mLastMotionX = ev.getX();
1670                     mLastMotionY = ev.getY();
1671                     // Update the parent down so that our zoom animations take this new movement into
1672                     // account
1673                     float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1674                     mParentDownMotionX = pt[0];
1675                     mParentDownMotionY = pt[1];
1676                     updateDragViewTranslationDuringDrag();
1677                     // Find the closest page to the touch point
1678                     final int dragViewIndex = indexOfChild(mDragView);
<abbr title="1679                     int bufferSize = ((int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth()));">1679                     int bufferSize = ((int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE * getViewportWidth())🔵</abbr>
<abbr title="1680                     int leftBufferEdge = ((int) (mapPointFromViewToParent(this, mViewport.left, 0)[0] + bufferSize));">1680                     int leftBufferEdge = ((int) (mapPointFromViewToParent(this, mViewport.left, 0)[0] + b🔵</abbr>
<abbr title="1681                     int rightBufferEdge = ((int) (mapPointFromViewToParent(this, mViewport.right, 0)[0] - bufferSize));">1681                     int rightBufferEdge = ((int) (mapPointFromViewToParent(this, mViewport.right, 0)[0] -🔵</abbr>
1682                     // Change the drag view if we are hovering over the drop target
<abbr title="1683                     boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(((int) (mParentDownMotionX)), ((int) (mParentDownMotionY)));">1683                     boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(((int) (mParentDownMoti🔵</abbr>
1684                     setPageHoveringOverDeleteDropTarget(dragViewIndex, isHoveringOverDelete);
1685                     if (DEBUG) {
1686                         Log.d(TAG, &quot;leftBufferEdge: &quot; + leftBufferEdge);
1687                     }
1688                     if (DEBUG) {
1689                         Log.d(TAG, &quot;rightBufferEdge: &quot; + rightBufferEdge);
1690                     }
1691                     if (DEBUG) {
1692                         Log.d(TAG, &quot;mLastMotionX: &quot; + mLastMotionX);
1693                     }
1694                     if (DEBUG) {
1695                         Log.d(TAG, &quot;mLastMotionY: &quot; + mLastMotionY);
1696                     }
1697                     if (DEBUG) {
1698                         Log.d(TAG, &quot;mParentDownMotionX: &quot; + mParentDownMotionX);
1699                     }
1700                     if (DEBUG) {
1701                         Log.d(TAG, &quot;mParentDownMotionY: &quot; + mParentDownMotionY);
1702                     }
1703                     float parentX = mParentDownMotionX;
1704                     int pageIndexToSnapTo = -1;
1705                     if ((parentX &lt; leftBufferEdge) &amp;&amp; (dragViewIndex &gt; 0)) {
1706                         pageIndexToSnapTo = dragViewIndex - 1;
1707                     } else if ((parentX &gt; rightBufferEdge) &amp;&amp; (dragViewIndex &lt; (getChildCount() - 1))) {
1708                         pageIndexToSnapTo = dragViewIndex + 1;
1709                     }
1710                     final int pageUnderPointIndex = pageIndexToSnapTo;
1711                     if ((pageUnderPointIndex &gt; (-1)) &amp;&amp; (!isHoveringOverDelete)) {
1712                         mTempVisiblePagesRange[0] = 0;
1713                         mTempVisiblePagesRange[1] = getPageCount() - 1;
1714                         boundByReorderablePages(true, mTempVisiblePagesRange);
<abbr title="1715                         if ((((mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex) &amp;&amp; (pageUnderPointIndex &lt;= mTempVisiblePagesRange[1])) &amp;&amp; (pageUnderPointIndex != mSidePageHoverIndex)) &amp;&amp; mScroller.isFinished()) {">1715                         if ((((mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex) &amp;&amp; (pageUnderPointIndex 🔵</abbr>
1716                             mSidePageHoverIndex = pageUnderPointIndex;
1717                             mSidePageHoverRunnable = new Runnable() {
1718                                 @Override
1719                                 public void run() {
1720                                     // Update the down scroll position to account for the fact that the
1721                                     // current page is moved
<abbr title="1722                                     mDownScrollX = getChildOffset(pageUnderPointIndex) - getRelativeChildOffset(pageUnderPointIndex);">1722                                     mDownScrollX = getChildOffset(pageUnderPointIndex) - getRelativeChild🔵</abbr>
1723                                     // Setup the scroll to the correct page before we swap the views
1724                                     snapToPage(pageUnderPointIndex);
1725                                     // For each of the pages between the paged view and the drag view,
1726                                     // animate them from the previous position to the new position in
1727                                     // the layout (as a result of the drag view moving in the layout)
1728                                     int shiftDelta = (dragViewIndex &lt; pageUnderPointIndex) ? -1 : 1;
<abbr title="1729                                     int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ? dragViewIndex + 1 : pageUnderPointIndex;">1729                                     int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ? dragViewInde🔵</abbr>
<abbr title="1730                                     int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ? dragViewIndex - 1 : pageUnderPointIndex;">1730                                     int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ? dragViewInde🔵</abbr>
1731                                     for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
1732                                         View v = getChildAt(i);
1733                                         // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
1734                                         // drag view all subsequent views to pageUnderPointIndex will
1735                                         // shift down.
1736                                         int oldX = getViewportOffsetX() + getChildOffset(i);
1737                                         int newX = getViewportOffsetX() + getChildOffset(i + shiftDelta);
1738                                         // Animate the view translation from its old position to its new
1739                                         // position
1740                                         AnimatorSet anim = ((AnimatorSet) (v.getTag(ANIM_TAG_KEY)));
1741                                         if (anim != null) {
1742                                             anim.cancel();
1743                                         }
1744                                         v.setTranslationX(oldX - newX);
1745                                         anim = new AnimatorSet();
1746                                         anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
<abbr title="1747                                         anim.playTogether(ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0.0F));">1747                                         anim.playTogether(ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0.0F)🔵</abbr>
1748                                         anim.start();
1749                                         v.setTag(anim);
1750                                     }
1751                                     removeView(mDragView);
1752                                     onRemoveView(mDragView, false);
1753                                     addView(mDragView, pageUnderPointIndex);
1754                                     onAddView(mDragView, pageUnderPointIndex);
1755                                     mSidePageHoverIndex = -1;
1756                                     mPageIndicator.setActiveMarker(getNextPage());
1757                                 }
1758                             };
1759                             postDelayed(mSidePageHoverRunnable, REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
1760                         }
1761                     } else {
1762                         removeCallbacks(mSidePageHoverRunnable);
1763                         mSidePageHoverIndex = -1;
1764                     }
1765                 } else {
1766                     determineScrollingStart(ev);
1767                 }
1768                 break;
1769             case MotionEvent.ACTION_UP :
1770                 if (mTouchState == TOUCH_STATE_SCROLLING) {
1771                     final int activePointerId = mActivePointerId;
1772                     final int pointerIndex = ev.findPointerIndex(activePointerId);
1773                     final float x = ev.getX(pointerIndex);
1774                     final VelocityTracker velocityTracker = mVelocityTracker;
1775                     velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
1776                     int velocityX = ((int) (velocityTracker.getXVelocity(activePointerId)));
1777                     final int deltaX = ((int) (x - mDownMotionX));
1778                     final int pageWidth = getPageAt(mCurrentPage).getMeasuredWidth();
<abbr title="1779                     boolean isSignificantMove = Math.abs(deltaX) &gt; (pageWidth * SIGNIFICANT_MOVE_THRESHOLD);">1779                     boolean isSignificantMove = Math.abs(deltaX) &gt; (pageWidth * SIGNIFICANT_MOVE_THRESHOL🔵</abbr>
1780                     mTotalMotionX += Math.abs((mLastMotionX + mLastMotionXRemainder) - x);
<abbr title="1781                     boolean isFling = (mTotalMotionX &gt; MIN_LENGTH_FOR_FLING) &amp;&amp; (Math.abs(velocityX) &gt; mFlingThresholdVelocity);">1781                     boolean isFling = (mTotalMotionX &gt; MIN_LENGTH_FOR_FLING) &amp;&amp; (Math.abs(velocityX) &gt; mF🔵</abbr>
1782                     // In the case that the page is moved far to one direction and then is flung
1783                     // in the opposite direction, we use a threshold to determine whether we should
1784                     // just return to the starting page, or if we should skip one further.
1785                     boolean returnToOriginalPage = false;
<abbr title="1786                     if (((Math.abs(deltaX) &gt; (pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD)) &amp;&amp; (Math.signum(velocityX) != Math.signum(deltaX))) &amp;&amp; isFling) {">1786                     if (((Math.abs(deltaX) &gt; (pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD)) &amp;&amp; (Math.si🔵</abbr>
1787                         returnToOriginalPage = true;
1788                     }
1789                     int finalPage;
1790                     // We give flings precedence over large moves, which is why we short-circuit our
1791                     // test for a large move if a fling has been registered. That is, a large
1792                     // move to the left and fling to the right will register as a fling to the right.
1793                     final boolean isRtl = isLayoutRtl();
1794                     boolean isDeltaXLeft = (isRtl) ? deltaX &gt; 0 : deltaX &lt; 0;
1795                     boolean isVelocityXLeft = (isRtl) ? velocityX &gt; 0 : velocityX &lt; 0;
<abbr title="1796                     if ((((isSignificantMove &amp;&amp; (!isDeltaXLeft)) &amp;&amp; (!isFling)) || (isFling &amp;&amp; (!isVelocityXLeft))) &amp;&amp; (mCurrentPage &gt; 0)) {">1796                     if ((((isSignificantMove &amp;&amp; (!isDeltaXLeft)) &amp;&amp; (!isFling)) || (isFling &amp;&amp; (!isVeloci🔵</abbr>
1797                         finalPage = (returnToOriginalPage) ? mCurrentPage : mCurrentPage - 1;
1798                         snapToPageWithVelocity(finalPage, velocityX);
<abbr title="1799                     } else if ((((isSignificantMove &amp;&amp; isDeltaXLeft) &amp;&amp; (!isFling)) || (isFling &amp;&amp; isVelocityXLeft)) &amp;&amp; (mCurrentPage &lt; (getChildCount() - 1))) {">1799                     } else if ((((isSignificantMove &amp;&amp; isDeltaXLeft) &amp;&amp; (!isFling)) || (isFling &amp;&amp; isVelo🔵</abbr>
1800                         finalPage = (returnToOriginalPage) ? mCurrentPage : mCurrentPage + 1;
1801                         snapToPageWithVelocity(finalPage, velocityX);
1802                     } else {
1803                         snapToDestination();
1804                     }
1805                 } else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
1806                     // at this point we have not moved beyond the touch slop
1807                     // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1808                     // we can just page
1809                     int nextPage = Math.max(0, mCurrentPage - 1);
1810                     if (nextPage != mCurrentPage) {
1811                         snapToPage(nextPage);
1812                     } else {
1813                         snapToDestination();
1814                     }
1815                 } else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
1816                     // at this point we have not moved beyond the touch slop
1817                     // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1818                     // we can just page
1819                     int nextPage = Math.min(getChildCount() - 1, mCurrentPage + 1);
1820                     if (nextPage != mCurrentPage) {
1821                         snapToPage(nextPage);
1822                     } else {
1823                         snapToDestination();
1824                     }
1825                 } else if (mTouchState == TOUCH_STATE_REORDERING) {
1826                     // Update the last motion position
1827                     mLastMotionX = ev.getX();
1828                     mLastMotionY = ev.getY();
1829                     // Update the parent down so that our zoom animations take this new movement into
1830                     // account
1831                     float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1832                     mParentDownMotionX = pt[0];
1833                     mParentDownMotionY = pt[1];
1834                     updateDragViewTranslationDuringDrag();
1835                     boolean handledFling = false;
1836                     if (!DISABLE_FLING_TO_DELETE) {
1837                         // Check the velocity and see if we are flinging-to-delete
1838                         PointF flingToDeleteVector = isFlingingToDelete();
1839                         if (flingToDeleteVector != null) {
1840                             onFlingToDelete(flingToDeleteVector);
1841                             handledFling = true;
1842                         }
1843                     }
<abbr title="1844                     if ((!handledFling) &amp;&amp; isHoveringOverDeleteDropTarget(((int) (mParentDownMotionX)), ((int) (mParentDownMotionY)))) {">1844                     if ((!handledFling) &amp;&amp; isHoveringOverDeleteDropTarget(((int) (mParentDownMotionX)), (🔵</abbr>
1845                         onDropToDelete();
1846                     }
1847                 } else {
1848                     onUnhandledTap(ev);
1849                 }
1850                 // Remove the callback to wait for the side page hover timeout
1851                 removeCallbacks(mSidePageHoverRunnable);
1852                 // End any intermediate reordering states
1853                 resetTouchState();
1854                 break;
1855             case MotionEvent.ACTION_CANCEL :
1856                 if (mTouchState == TOUCH_STATE_SCROLLING) {
1857                     snapToDestination();
1858                 }
1859                 resetTouchState();
1860                 break;
1861             case MotionEvent.ACTION_POINTER_UP :
1862                 onSecondaryPointerUp(ev);
1863                 break;
1864         }
1865         return true;
1866     }
1867 
1868     public void onFlingToDelete(View v) {}
1869 
1870     public void onRemoveView(View v, boolean deletePermanently) {}
1871 
1872     public void onRemoveViewAnimationCompleted() {}
1873 
1874     public void onAddView(View v, int index) {}
1875 
1876     private void resetTouchState() {
1877         releaseVelocityTracker();
1878         endReordering();
1879         mTouchState = TOUCH_STATE_REST;
1880         mActivePointerId = INVALID_POINTER;
1881         mDownEventOnEdge = false;
1882     }
1883 
1884     protected void onUnhandledTap(MotionEvent ev) {}
1885 
1886     @Override
1887     public boolean onGenericMotionEvent(MotionEvent event) {
1888         if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
1889             switch (event.getAction()) {
1890                 case MotionEvent.ACTION_SCROLL: {
1891                     // Handle mouse (or ext. device) by shifting the page depending on the scroll
1892                     final float vscroll;
1893                     final float hscroll;
1894                     if ((event.getMetaState() &amp; KeyEvent.META_SHIFT_ON) != 0) {
1895                         vscroll = 0;
1896                         hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1897                     } else {
1898                         vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1899                         hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
1900                     }
1901                     if (hscroll != 0 || vscroll != 0) {
1902                         boolean isForwardScroll = isLayoutRtl() ? (hscroll &lt; 0 || vscroll &lt; 0)
1903                                                          : (hscroll &gt; 0 || vscroll &gt; 0);
1904                         if (isForwardScroll) {
1905                             scrollRight();
1906                         } else {
1907                             scrollLeft();
1908                         }
1909                         return true;
1910                     }
1911                 }
1912             }
1913         }
1914         return super.onGenericMotionEvent(event);
1915     }
1916 
1917     private void acquireVelocityTrackerAndAddMovement(MotionEvent ev) {
1918         if (mVelocityTracker == null) {
1919             mVelocityTracker = VelocityTracker.obtain();
1920         }
1921         mVelocityTracker.addMovement(ev);
1922     }
1923 
1924     private void releaseVelocityTracker() {
1925         if (mVelocityTracker != null) {
1926             mVelocityTracker.recycle();
1927             mVelocityTracker = null;
1928         }
1929     }
1930 
1931     private void onSecondaryPointerUp(MotionEvent ev) {
1932         final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;
1933                 MotionEvent.ACTION_POINTER_INDEX_SHIFT;
1934         final int pointerId = ev.getPointerId(pointerIndex);
1935         if (pointerId == mActivePointerId) {
1936             // This was our active pointer going up. Choose a new
1937             // active pointer and adjust accordingly.
1938             // TODO: Make this decision more intelligent.
1939             final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
1940             mLastMotionX = mDownMotionX = ev.getX(newPointerIndex);
1941             mLastMotionY = ev.getY(newPointerIndex);
1942             mLastMotionXRemainder = 0;
1943             mActivePointerId = ev.getPointerId(newPointerIndex);
1944             if (mVelocityTracker != null) {
1945                 mVelocityTracker.clear();
1946             }
1947         }
1948     }
1949 
1950     @Override
1951     public void requestChildFocus(View child, View focused) {
1952         super.requestChildFocus(child, focused);
1953         int page = indexToPage(indexOfChild(child));
1954         if (page &gt;= 0 &amp;&amp; page != getCurrentPage() &amp;&amp; !isInTouchMode()) {
1955             snapToPage(page);
1956         }
1957     }
1958 
1959     protected int getChildWidth(int index) {
1960         return getPageAt(index).getMeasuredWidth();
1961     }
1962 
1963     int getPageNearestToPoint(float x) {
1964         int index = 0;
1965         for (int i = 0; i &lt; getChildCount(); ++i) {
1966             if (x &lt; getChildAt(i).getRight() - getScrollX()) {
1967                 return index;
1968             } else {
1969                 index++;
1970             }
1971         }
1972         return Math.min(index, getChildCount() - 1);
1973     }
1974 
1975     int getPageNearestToCenterOfScreen() {
1976         int minDistanceFromScreenCenter = Integer.MAX_VALUE;
1977         int minDistanceFromScreenCenterIndex = -1;
1978         int screenCenter = (getViewportOffsetX() + getScrollX()) + (getViewportWidth() / 2);
1979         final int childCount = getChildCount();
1980         for (int i = 0; i &lt; childCount; ++i) {
1981             View layout = ((View) (getPageAt(i)));
1982             int childWidth = layout.getMeasuredWidth();
1983             int halfChildWidth = childWidth / 2;
1984             int childCenter = (getViewportOffsetX() + getChildOffset(i)) + halfChildWidth;
1985             int distanceFromScreenCenter = Math.abs(childCenter - screenCenter);
1986             if (distanceFromScreenCenter &lt; minDistanceFromScreenCenter) {
1987                 minDistanceFromScreenCenter = distanceFromScreenCenter;
1988                 minDistanceFromScreenCenterIndex = i;
1989             }
1990         }
1991         return minDistanceFromScreenCenterIndex;
1992     }
1993 
1994     protected void snapToDestination() {
1995         snapToPage(getPageNearestToCenterOfScreen(), PAGE_SNAP_ANIMATION_DURATION);
1996     }
1997 
1998     private static class ScrollInterpolator implements Interpolator {
1999         public ScrollInterpolator() {
2000         }
2001 
2002         public float getInterpolation(float t) {
2003             t -= 1.0F;
2004             return ((((t * t) * t) * t) * t) + 1;
2005         }
2006     }
2007 
2008     // We want the duration of the page snap animation to be influenced by the distance that
2009     // the screen has to travel, however, we don&#x27;t want this duration to be effected in a
2010     // purely linear fashion. Instead, we use this method to moderate the effect that the distance
2011     // of travel has on the overall snap duration.
2012     float distanceInfluenceForSnapDuration(float f) {
2013         f -= 0.5f; // center the values about 0.
2014         f *= 0.3f * Math.PI / 2.0f;
2015         return (float) Math.sin(f);
2016     }
2017 
2018     protected void snapToPageWithVelocity(int whichPage, int velocity) {
2019         whichPage = Math.max(0, Math.min(whichPage, getChildCount() - 1));
2020         int halfScreenSize = getViewportWidth() / 2;
2021 
2022         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2023         if (DEBUG) Log.d(TAG, &quot;snapToPageWithVelocity.getRelativeChildOffset(): &quot;
2024                 + getViewportWidth() + &quot;, &quot; + getChildWidth(whichPage));
2025         final int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2026         int delta = newX - mUnboundedScrollX;
2027         int duration = 0;
2028 
2029         if (Math.abs(velocity) &lt; mMinFlingVelocity) {
2030             // If the velocity is low enough, then treat this more as an automatic page advance
2031             // as opposed to an apparent physical response to flinging
2032             snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2033             return;
2034         }
2035 
2036         // Here we compute a &quot;distance&quot; that will be used in the computation of the overall
2037         // snap duration. This is a function of the actual distance that needs to be traveled;
2038         // we keep this value close to half screen size in order to reduce the variance in snap
2039         // duration as a function of the distance the page needs to travel.
2040         float distanceRatio = Math.min(1f, 1.0f * Math.abs(delta) / (2 * halfScreenSize));
2041         float distance = halfScreenSize + halfScreenSize *
2042                 distanceInfluenceForSnapDuration(distanceRatio);
2043 
2044         velocity = Math.abs(velocity);
2045         velocity = Math.max(mMinSnapVelocity, velocity);
2046 
2047         // we want the page&#x27;s snap velocity to approximately match the velocity at which the
2048         // user flings, so we scale the duration by a value near to the derivative of the scroll
2049         // interpolator at zero, ie. 5. We use 4 to make it a little slower.
2050         duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
2051 
2052         snapToPage(whichPage, delta, duration);
2053     }
2054 
2055     protected void snapToPage(int whichPage) {
2056         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2057     }
2058 
2059     protected void snapToPageImmediately(int whichPage) {
2060         snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION, true);
2061     }
2062 
2063     protected void snapToPage(int whichPage, int duration) {
2064         snapToPage(whichPage, duration, false);
2065     }
2066 
2067     protected void snapToPage(int whichPage, int duration, boolean immediate) {
2068         whichPage = Math.max(0, Math.min(whichPage, getPageCount() - 1));
2069 
2070         if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2071         if (DEBUG) Log.d(TAG, &quot;snapToPage.getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
2072                 + getChildWidth(whichPage));
2073         int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2074         final int sX = mUnboundedScrollX;
2075         final int delta = newX - sX;
2076         snapToPage(whichPage, delta, duration, immediate);
2077     }
2078 
2079     protected void snapToPage(int whichPage, int delta, int duration) {
2080         snapToPage(whichPage, delta, duration, false);
2081     }
2082 
2083     protected void snapToPage(int whichPage, int delta, int duration, boolean immediate) {
2084         mNextPage = whichPage;
2085         View focusedChild = getFocusedChild();
2086         if (focusedChild != null &amp;&amp; whichPage != mCurrentPage &amp;&amp;
2087                 focusedChild == getPageAt(mCurrentPage)) {
2088             focusedChild.clearFocus();
2089         }
2090 
2091         pageBeginMoving();
2092         awakenScrollBars(duration);
2093         if (immediate) {
2094             duration = 0;
2095         } else if (duration == 0) {
2096             duration = Math.abs(delta);
2097         }
2098 
2099         if (!mScroller.isFinished()) mScroller.abortAnimation();
2100         mScroller.startScroll(mUnboundedScrollX, 0, delta, 0, duration);
2101 
2102         notifyPageSwitchListener();
2103 
2104         // Trigger a compute() to finish switching pages if necessary
2105         if (immediate) {
2106             computeScroll();
2107         }
2108 
2109         mForceScreenScrolled = true;
2110         invalidate();
2111     }
2112 
2113     public void scrollLeft() {
2114         if (mScroller.isFinished()) {
2115             if (mCurrentPage &gt; 0) snapToPage(mCurrentPage - 1);
2116         } else {
2117             if (mNextPage &gt; 0) snapToPage(mNextPage - 1);
2118         }
2119     }
2120 
2121     public void scrollRight() {
2122         if (mScroller.isFinished()) {
2123             if (mCurrentPage &lt; getChildCount() -1) snapToPage(mCurrentPage + 1);
2124         } else {
2125             if (mNextPage &lt; getChildCount() -1) snapToPage(mNextPage + 1);
2126         }
2127     }
2128 
2129     public int getPageForView(View v) {
2130         int result = -1;
2131         if (v != null) {
2132             ViewParent vp = v.getParent();
2133             int count = getChildCount();
2134             for (int i = 0; i &lt; count; i++) {
2135                 if (vp == getPageAt(i)) {
2136                     return i;
2137                 }
2138             }
2139         }
2140         return result;
2141     }
2142 
2143     /**
2144      * @return True is long presses are still allowed for the current touch
2145      */
2146     public boolean allowLongPress() {
2147         return mAllowLongPress;
2148     }
2149 
2150     /**
2151      * Set true to allow long-press events to be triggered, usually checked by
2152      * {@link Launcher} to accept or block dpad-initiated long-presses.
2153      */
2154     public void setAllowLongPress(boolean allowLongPress) {
2155         mAllowLongPress = allowLongPress;
2156     }
2157 
2158     public static class SavedState extends BaseSavedState {
2159         int currentPage = -1;
2160 
2161         SavedState(Parcelable superState) {
2162             super(superState);
2163         }
2164 
2165         private SavedState(Parcel in) {
2166             super(in);
2167             currentPage = in.readInt();
2168         }
2169 
2170         @Override
2171         public void writeToParcel(Parcel out, int flags) {
2172             super.writeToParcel(out, flags);
2173             out.writeInt(currentPage);
2174         }
2175 
<abbr title="2176         public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;() {">2176         public static final Parcelable.Creator&lt;SavedState&gt; CREATOR = new Parcelable.Creator&lt;SavedState&gt;()🔵</abbr>
2177             public SavedState createFromParcel(Parcel in) {
2178                 return new SavedState(in);
2179             }
2180 
2181             public SavedState[] newArray(int size) {
2182                 return new SavedState[size];
2183             }
2184         };
2185     }
2186 
2187     protected void loadAssociatedPages(int page) {
2188         loadAssociatedPages(page, false);
2189     }
2190 
2191     protected void loadAssociatedPages(int page, boolean immediateAndOnly) {
2192         if (mContentIsRefreshable) {
2193             final int count = getChildCount();
2194             if (page &lt; count) {
2195                 int lowerPageBound = getAssociatedLowerPageBound(page);
2196                 int upperPageBound = getAssociatedUpperPageBound(page);
2197                 if (DEBUG) Log.d(TAG, &quot;loadAssociatedPages: &quot; + lowerPageBound + &quot;/&quot;
2198                         + upperPageBound);
2199                 // First, clear any pages that should no longer be loaded
2200                 for (int i = 0; i &lt; count; ++i) {
2201                     Page layout = (Page) getPageAt(i);
2202                     if ((i &lt; lowerPageBound) || (i &gt; upperPageBound)) {
2203                         if (layout.getPageChildCount() &gt; 0) {
2204                             layout.removeAllViewsOnPage();
2205                         }
2206                         mDirtyPageContent.set(i, true);
2207                     }
2208                 }
2209                 // Next, load any new pages
2210                 for (int i = 0; i &lt; count; ++i) {
2211                     if ((i != page) &amp;&amp; immediateAndOnly) {
2212                         continue;
2213                     }
2214                     if (lowerPageBound &lt;= i &amp;&amp; i &lt;= upperPageBound) {
2215                         if (mDirtyPageContent.get(i)) {
2216                             syncPageItems(i, (i == page) &amp;&amp; immediateAndOnly);
2217                             mDirtyPageContent.set(i, false);
2218                         }
2219                     }
2220                 }
2221             }
2222         }
2223     }
2224 
2225     protected int getAssociatedLowerPageBound(int page) {
2226         return Math.max(0, page - 1);
2227     }
2228 
2229     protected int getAssociatedUpperPageBound(int page) {
2230         final int count = getChildCount();
2231         return Math.min(page + 1, count - 1);
2232     }
2233 
2234     /**
2235      * This method is called ONLY to synchronize the number of pages that the paged view has.
2236      * To actually fill the pages with information, implement syncPageItems() below.  It is
2237      * guaranteed that syncPageItems() will be called for a particular page before it is shown,
2238      * and therefore, individual page items do not need to be updated in this method.
2239      */
2240     public abstract void syncPages();
2241 
2242     /**
2243      * This method is called to synchronize the items that are on a particular page.  If views on
2244      * the page can be reused, then they should be updated within this method.
2245      */
2246     public abstract void syncPageItems(int page, boolean immediate);
2247 
2248     protected void invalidatePageData() {
2249         invalidatePageData(-1, false);
2250     }
2251 
2252     protected void invalidatePageData(int currentPage) {
2253         invalidatePageData(currentPage, false);
2254     }
2255 
2256     protected void invalidatePageData(int currentPage, boolean immediateAndOnly) {
2257         if (!mIsDataReady) {
2258             return;
2259         }
2260 
2261         if (mContentIsRefreshable) {
2262             // Force all scrolling-related behavior to end
2263             mScroller.forceFinished(true);
2264             mNextPage = INVALID_PAGE;
2265 
2266             // Update all the pages
2267             syncPages();
2268 
2269             // We must force a measure after we&#x27;ve loaded the pages to update the content width and
2270             // to determine the full scroll width
2271             measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
2272                     MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
2273 
2274             // Set a new page as the current page if necessary
2275             if (currentPage &gt; -1) {
2276                 setCurrentPage(Math.min(getPageCount() - 1, currentPage));
2277             }
2278 
2279             // Mark each of the pages as dirty
2280             final int count = getChildCount();
2281             mDirtyPageContent.clear();
2282             for (int i = 0; i &lt; count; ++i) {
2283                 mDirtyPageContent.add(true);
2284             }
2285 
2286             // Load any pages that are necessary for the current window of views
2287             loadAssociatedPages(mCurrentPage, immediateAndOnly);
2288             requestLayout();
2289         }
2290     }
2291 
2292     // Animate the drag view back to the original position
2293     void animateDragViewToOriginalPosition() {
2294         if (mDragView != null) {
2295             AnimatorSet anim = new AnimatorSet();
2296             anim.setDuration(REORDERING_DROP_REPOSITION_DURATION);
<abbr title="2297             anim.playTogether(ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0.0F), ObjectAnimator.ofFloat(mDragView, &quot;translationY&quot;, 0.0F));">2297             anim.playTogether(ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0.0F), ObjectAnimator.ofF🔵</abbr>
2298             anim.addListener(new AnimatorListenerAdapter() {
2299                 @Override
2300                 public void onAnimationEnd(Animator animation) {
2301                     onPostReorderingAnimationCompleted();
2302                 }
2303             });
2304             anim.start();
2305         }
2306     }
2307 
2308     // &quot;Zooms out&quot; the PagedView to reveal more side pages
2309     protected boolean zoomOut() {
2310         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2311             mZoomInOutAnim.cancel();
2312         }
2313 
2314         if (!(getScaleX() &lt; 1f || getScaleY() &lt; 1f)) {
2315             mZoomInOutAnim = new AnimatorSet();
2316             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2317             mZoomInOutAnim.playTogether(
2318                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, mMinScale),
2319                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, mMinScale));
2320             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2321                 @Override
2322                 public void onAnimationStart(Animator animation) {
2323                     // Show the delete drop target
2324                     if (mDeleteDropTarget != null) {
2325                         mDeleteDropTarget.setVisibility(View.VISIBLE);
2326                         mDeleteDropTarget.animate().alpha(1f)
2327                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2328                             .setListener(new AnimatorListenerAdapter() {
2329                                 @Override
2330                                 public void onAnimationStart(Animator animation) {
2331                                     mDeleteDropTarget.setAlpha(0f);
2332                                 }
2333                             });
2334                     }
2335                 }
2336             });
2337             mZoomInOutAnim.start();
2338             return true;
2339         }
2340         return false;
2341     }
2342 
2343     protected void onStartReordering() {
2344         // Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)
2345         mTouchState = TOUCH_STATE_REORDERING;
2346         mIsReordering = true;
2347 
2348         // Mark all the non-widget pages as invisible
2349         getVisiblePages(mTempVisiblePagesRange);
2350         boundByReorderablePages(true, mTempVisiblePagesRange);
2351         for (int i = 0; i &lt; getPageCount(); ++i) {
2352             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2353                 getPageAt(i).setAlpha(0f);
2354             }
2355         }
2356 
2357         // We must invalidate to trigger a redraw to update the layers such that the drag view
2358         // is always drawn on top
2359         invalidate();
2360     }
2361 
2362     private void onPostReorderingAnimationCompleted() {
2363         // Trigger the callback when reordering has settled
2364         --mPostReorderingPreZoomInRemainingAnimationCount;
2365         if (mPostReorderingPreZoomInRunnable != null &amp;&amp;
2366                 mPostReorderingPreZoomInRemainingAnimationCount == 0) {
2367             mPostReorderingPreZoomInRunnable.run();
2368             mPostReorderingPreZoomInRunnable = null;
2369         }
2370     }
2371 
2372     protected void onEndReordering() {
2373         mIsReordering = false;
2374 
2375         // Mark all the non-widget pages as visible again
2376         getVisiblePages(mTempVisiblePagesRange);
2377         boundByReorderablePages(true, mTempVisiblePagesRange);
2378         for (int i = 0; i &lt; getPageCount(); ++i) {
2379             if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2380                 getPageAt(i).setAlpha(1f);
2381             }
2382         }
2383     }
2384 
2385     public boolean startReordering() {
2386         int dragViewIndex = getPageNearestToCenterOfScreen();
2387         mTempVisiblePagesRange[0] = 0;
2388         mTempVisiblePagesRange[1] = getPageCount() - 1;
2389         boundByReorderablePages(true, mTempVisiblePagesRange);
2390         mReorderingStarted = true;
2391 
2392         // Check if we are within the reordering range
2393         if (mTempVisiblePagesRange[0] &lt;= dragViewIndex &amp;&amp;
2394                 dragViewIndex &lt;= mTempVisiblePagesRange[1]) {
2395             if (zoomOut()) {
2396                 // Find the drag view under the pointer
2397                 mDragView = getChildAt(dragViewIndex);
2398 
2399                 onStartReordering();
2400             }
2401             return true;
2402         }
2403         return false;
2404     }
2405 
2406     boolean isReordering(boolean testTouchState) {
2407         boolean state = mIsReordering;
2408         if (testTouchState) {
2409             state &amp;= (mTouchState == TOUCH_STATE_REORDERING);
2410         }
2411         return state;
2412     }
2413 
2414     void endReordering() {
2415         // For simplicity, we call endReordering sometimes even if reordering was never started.
2416         // In that case, we don&#x27;t want to do anything.
2417         if (!mReorderingStarted) return;
2418         mReorderingStarted = false;
2419 
2420         // If we haven&#x27;t flung-to-delete the current child, then we just animate the drag view
2421         // back into position
2422         final Runnable onCompleteRunnable = new Runnable() {
2423             @Override
2424             public void run() {
2425                 onEndReordering();
2426             }
2427         };
2428         if (!mDeferringForDelete) {
2429             mPostReorderingPreZoomInRunnable = new Runnable() {
2430                 public void run() {
2431                     zoomIn(onCompleteRunnable);
2432                 };
2433             };
2434 
2435             mPostReorderingPreZoomInRemainingAnimationCount =
2436                     NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT;
2437             // Snap to the current page
2438             snapToPage(indexOfChild(mDragView), 0);
2439             // Animate the drag view back to the front position
2440             animateDragViewToOriginalPosition();
2441         } else {
2442             // Handled in post-delete-animation-callbacks
2443         }
2444     }
2445 
2446     // &quot;Zooms in&quot; the PagedView to highlight the current page
2447     protected boolean zoomIn(final Runnable onCompleteRunnable) {
2448         if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2449             mZoomInOutAnim.cancel();
2450         }
2451         if (getScaleX() &lt; 1f || getScaleY() &lt; 1f) {
2452             mZoomInOutAnim = new AnimatorSet();
2453             mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2454             mZoomInOutAnim.playTogether(
2455                     ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 1f),
2456                     ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, 1f));
2457             mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2458                 @Override
2459                 public void onAnimationStart(Animator animation) {
2460                     // Hide the delete drop target
2461                     if (mDeleteDropTarget != null) {
2462                         mDeleteDropTarget.animate().alpha(0f)
2463                             .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2464                             .setListener(new AnimatorListenerAdapter() {
2465                                 @Override
2466                                 public void onAnimationEnd(Animator animation) {
2467                                     mDeleteDropTarget.setVisibility(View.GONE);
2468                                 }
2469                             });
2470                     }
2471                 }
2472                 @Override
2473                 public void onAnimationCancel(Animator animation) {
2474                     mDragView = null;
2475                 }
2476                 @Override
2477                 public void onAnimationEnd(Animator animation) {
2478                     mDragView = null;
2479                     if (onCompleteRunnable != null) {
2480                         onCompleteRunnable.run();
2481                     }
2482                 }
2483             });
2484             mZoomInOutAnim.start();
2485             return true;
2486         } else {
2487             if (onCompleteRunnable != null) {
2488                 onCompleteRunnable.run();
2489             }
2490         }
2491         return false;
2492     }
2493 
2494     /*
2495      * Flinging to delete - IN PROGRESS
2496      */
2497     private PointF isFlingingToDelete() {
2498         ViewConfiguration config = ViewConfiguration.get(getContext());
2499         mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());
2500 
2501         if (mVelocityTracker.getYVelocity() &lt; mFlingToDeleteThresholdVelocity) {
2502             // Do a quick dot product test to ensure that we are flinging upwards
2503             PointF vel = new PointF(mVelocityTracker.getXVelocity(),
2504                     mVelocityTracker.getYVelocity());
2505             PointF upVec = new PointF(0f, -1f);
2506             float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) /
2507                     (vel.length() * upVec.length()));
2508             if (theta &lt;= Math.toRadians(FLING_TO_DELETE_MAX_FLING_DEGREES)) {
2509                 return vel;
2510             }
2511         }
2512         return null;
2513     }
2514 
2515     /**
2516      * Creates an animation from the current drag view along its current velocity vector.
2517      * For this animation, the alpha runs for a fixed duration and we update the position
2518      * progressively.
2519      */
2520     private static class FlingAlongVectorAnimatorUpdateListener implements AnimatorUpdateListener {
2521         private View mDragView;
2522 
2523         private PointF mVelocity;
2524 
2525         private Rect mFrom;
2526 
2527         private long mPrevTime;
2528 
2529         private float mFriction;
2530 
2531         private final TimeInterpolator mAlphaInterpolator = new DecelerateInterpolator(0.75F);
2532 
<abbr title="2533         public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from, long startTime, float friction) {">2533         public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from, long startTim🔵</abbr>
2534             mDragView = dragView;
2535             mVelocity = vel;
2536             mFrom = from;
2537             mPrevTime = startTime;
2538             mFriction = 1.0F - (mDragView.getResources().getDisplayMetrics().density * friction);
2539         }
2540 
2541         @Override
2542         public void onAnimationUpdate(ValueAnimator animation) {
2543             float t = ((Float) (animation.getAnimatedValue())).floatValue();
2544             long curTime = AnimationUtils.currentAnimationTimeMillis();
2545             mFrom.left += (mVelocity.x * (curTime - mPrevTime)) / 1000.0F;
2546             mFrom.top += (mVelocity.y * (curTime - mPrevTime)) / 1000.0F;
2547             mDragView.setTranslationX(mFrom.left);
2548             mDragView.setTranslationY(mFrom.top);
2549             mDragView.setAlpha(1.0F - mAlphaInterpolator.getInterpolation(t));
2550             mVelocity.x *= mFriction;
2551             mVelocity.y *= mFriction;
2552             mPrevTime = curTime;
2553         }
2554     }
2555 
2556     private static final int ANIM_TAG_KEY = 100;
2557 
2558     private Runnable createPostDeleteAnimationRunnable(final View dragView) {
2559         return new Runnable() {
2560             @Override
2561             public void run() {
2562                 int dragViewIndex = indexOfChild(dragView);
2563                 // For each of the pages around the drag view, animate them from the previous
2564                 // position to the new position in the layout (as a result of the drag view moving
2565                 // in the layout)
2566                 // NOTE: We can make an assumption here because we have side-bound pages that we
2567                 // will always have pages to animate in from the left
2568                 getVisiblePages(mTempVisiblePagesRange);
2569                 boundByReorderablePages(true, mTempVisiblePagesRange);
2570                 boolean isLastWidgetPage = mTempVisiblePagesRange[0] == mTempVisiblePagesRange[1];
2571                 boolean slideFromLeft = isLastWidgetPage || (dragViewIndex &gt; mTempVisiblePagesRange[0]);
2572                 // Setup the scroll to the correct page before we swap the views
2573                 if (slideFromLeft) {
2574                     snapToPageImmediately(dragViewIndex - 1);
2575                 }
2576                 int firstIndex = (isLastWidgetPage) ? 0 : mTempVisiblePagesRange[0];
2577                 int lastIndex = Math.min(mTempVisiblePagesRange[1], getPageCount() - 1);
2578                 int lowerIndex = (slideFromLeft) ? firstIndex : dragViewIndex + 1;
2579                 int upperIndex = (slideFromLeft) ? dragViewIndex - 1 : lastIndex;
2580                 ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2581                 for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
2582                     View v = getChildAt(i);
2583                     // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
2584                     // drag view all subsequent views to pageUnderPointIndex will
2585                     // shift down.
2586                     int oldX = 0;
2587                     int newX = 0;
2588                     if (slideFromLeft) {
2589                         if (i == 0) {
2590                             // Simulate the page being offscreen with the page spacing
<abbr title="2591                             oldX = ((getViewportOffsetX() + getChildOffset(i)) - getChildWidth(i)) - mPageSpacing;">2591                             oldX = ((getViewportOffsetX() + getChildOffset(i)) - getChildWidth(i)) - mPag🔵</abbr>
2592                         } else {
2593                             oldX = getViewportOffsetX() + getChildOffset(i - 1);
2594                         }
2595                         newX = getViewportOffsetX() + getChildOffset(i);
2596                     } else {
2597                         oldX = getChildOffset(i) - getChildOffset(i - 1);
2598                         newX = 0;
2599                     }
2600                     // Animate the view translation from its old position to its new
2601                     // position
2602                     AnimatorSet anim = ((AnimatorSet) (v.getTag()));
2603                     if (anim != null) {
2604                         anim.cancel();
2605                     }
2606                     // Note: Hacky, but we want to skip any optimizations to not draw completely
2607                     // hidden views
2608                     v.setAlpha(Math.max(v.getAlpha(), 0.01F));
2609                     v.setTranslationX(oldX - newX);
2610                     anim = new AnimatorSet();
<abbr title="2611                     anim.playTogether(ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0.0F), ObjectAnimator.ofFloat(v, &quot;alpha&quot;, 1.0F));">2611                     anim.playTogether(ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0.0F), ObjectAnimator.ofF🔵</abbr>
2612                     animations.add(anim);
2613                     v.setTag(ANIM_TAG_KEY, anim);
2614                 }
2615                 AnimatorSet slideAnimations = new AnimatorSet();
2616                 slideAnimations.playTogether(animations);
2617                 slideAnimations.setDuration(DELETE_SLIDE_IN_SIDE_PAGE_DURATION);
2618                 slideAnimations.addListener(new AnimatorListenerAdapter() {
2619                     @Override
2620                     public void onAnimationEnd(Animator animation) {
2621                         final Runnable onCompleteRunnable = new Runnable() {
2622                             @Override
2623                             public void run() {
2624                                 mDeferringForDelete = false;
2625                                 onEndReordering();
2626                                 onRemoveViewAnimationCompleted();
2627                             }
2628                         };
2629                         zoomIn(onCompleteRunnable);
2630                     }
2631                 });
2632                 slideAnimations.start();
2633                 removeView(dragView);
2634                 onRemoveView(dragView, true);
2635             }
2636         };
2637     }
2638 
2639     public void onFlingToDelete(PointF vel) {
2640         final long startTime = AnimationUtils.currentAnimationTimeMillis();
2641         // NOTE: Because it takes time for the first frame of animation to actually be
2642         // called and we expect the animation to be a continuation of the fling, we have
2643         // to account for the time that has elapsed since the fling finished.  And since
2644         // we don&#x27;t have a startDelay, we will always get call to update when we call
2645         // start() (which we want to ignore).
2646         final TimeInterpolator tInterpolator = new TimeInterpolator() {
2647             private int mCount = -1;
2648 
2649             private long mStartTime;
2650 
2651             private float mOffset;
2652 
2653             /* Anonymous inner class ctor */
2654             {
2655                 mStartTime = startTime;
2656             }
2657 
2658             @Override
2659             public float getInterpolation(float t) {
2660                 if (mCount &lt; 0) {
2661                     mCount++;
2662                 } else if (mCount == 0) {
<abbr title="2663                     mOffset = Math.min(0.5F, ((float) (AnimationUtils.currentAnimationTimeMillis() - mStartTime)) / FLING_TO_DELETE_FADE_OUT_DURATION);">2663                     mOffset = Math.min(0.5F, ((float) (AnimationUtils.currentAnimationTimeMillis() - mSta🔵</abbr>
2664                     mCount++;
2665                 }
2666                 return Math.min(1.0F, mOffset + t);
2667             }
2668         };
2669         final Rect from = new Rect();
2670         final View dragView = mDragView;
2671         from.left = ((int) (dragView.getTranslationX()));
2672         from.top = ((int) (dragView.getTranslationY()));
<abbr title="2673         AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel, from, startTime, FLING_TO_DELETE_FRICTION);">2673         AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel, from,🔵</abbr>
2674         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2675         // Create and start the animation
2676         ValueAnimator mDropAnim = new ValueAnimator();
2677         mDropAnim.setInterpolator(tInterpolator);
2678         mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
2679         mDropAnim.setFloatValues(0.0F, 1.0F);
2680         mDropAnim.addUpdateListener(updateCb);
2681         mDropAnim.addListener(new AnimatorListenerAdapter() {
2682             public void onAnimationEnd(Animator animation) {
2683                 onAnimationEndRunnable.run();
2684             }
2685         });
2686         mDropAnim.start();
2687         mDeferringForDelete = true;
2688     }
2689 
2690     /* Drag to delete */
2691     private boolean isHoveringOverDeleteDropTarget(int x, int y) {
2692         if (mDeleteDropTarget != null) {
2693             mAltTmpRect.set(0, 0, 0, 0);
2694             View parent = (View) mDeleteDropTarget.getParent();
2695             if (parent != null) {
2696                 parent.getGlobalVisibleRect(mAltTmpRect);
2697             }
2698             mDeleteDropTarget.getGlobalVisibleRect(mTmpRect);
2699             mTmpRect.offset(-mAltTmpRect.left, -mAltTmpRect.top);
2700             return mTmpRect.contains(x, y);
2701         }
2702         return false;
2703     }
2704 
2705     protected void setPageHoveringOverDeleteDropTarget(int viewIndex, boolean isHovering) {}
2706 
2707     private void onDropToDelete() {
2708         final View dragView = mDragView;
2709         final float toScale = 0.0F;
2710         final float toAlpha = 0.0F;
2711         // Create and start the complex animation
2712         ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2713         AnimatorSet motionAnim = new AnimatorSet();
2714         motionAnim.setInterpolator(new DecelerateInterpolator(2));
<abbr title="2715         motionAnim.playTogether(ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale), ObjectAnimator.ofFloat(dragView, &quot;scaleY&quot;, toScale));">2715         motionAnim.playTogether(ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale), ObjectAnimator.ofFlo🔵</abbr>
2716         animations.add(motionAnim);
2717         AnimatorSet alphaAnim = new AnimatorSet();
2718         alphaAnim.setInterpolator(new LinearInterpolator());
2719         alphaAnim.playTogether(ObjectAnimator.ofFloat(dragView, &quot;alpha&quot;, toAlpha));
2720         animations.add(alphaAnim);
2721         final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2722         AnimatorSet anim = new AnimatorSet();
2723         anim.playTogether(animations);
2724         anim.setDuration(DRAG_TO_DELETE_FADE_OUT_DURATION);
2725         anim.addListener(new AnimatorListenerAdapter() {
2726             public void onAnimationEnd(Animator animation) {
2727                 onAnimationEndRunnable.run();
2728             }
2729         });
2730         anim.start();
2731         mDeferringForDelete = true;
2732     }
2733 
2734     /* Accessibility */
2735     @Override
2736     public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
2737         super.onInitializeAccessibilityNodeInfo(info);
2738         info.setScrollable(getPageCount() &gt; 1);
2739         if (getCurrentPage() &lt; getPageCount() - 1) {
2740             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
2741         }
2742         if (getCurrentPage() &gt; 0) {
2743             info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
2744         }
2745     }
2746 
2747     @Override
2748     public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
2749         super.onInitializeAccessibilityEvent(event);
2750         event.setScrollable(true);
2751         if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
2752             event.setFromIndex(mCurrentPage);
2753             event.setToIndex(mCurrentPage);
2754             event.setItemCount(getChildCount());
2755         }
2756     }
2757 
2758     @Override
2759     public boolean performAccessibilityAction(int action, Bundle arguments) {
2760         if (super.performAccessibilityAction(action, arguments)) {
2761             return true;
2762         }
2763         switch (action) {
2764             case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
2765                 if (getCurrentPage() &lt; getPageCount() - 1) {
2766                     scrollRight();
2767                     return true;
2768                 }
2769             } break;
2770             case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
2771                 if (getCurrentPage() &gt; 0) {
2772                     scrollLeft();
2773                     return true;
2774                 }
2775             } break;
2776         }
2777         return false;
2778     }
2779 
2780     protected String getCurrentPageDescription() {
2781         return String.format(getContext().getString(R.string.default_scroll_format),
2782                 getNextPage() + 1, getChildCount());
2783     }
2784 
2785     @Override
2786     public boolean onHoverEvent(android.view.MotionEvent event) {
2787         return true;
2788     }
2789 }
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2012 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.animation.Animator;
  20  import android.animation.AnimatorListenerAdapter;
  21  import android.animation.AnimatorSet;
  22  import android.animation.ObjectAnimator;
  23  import android.animation.TimeInterpolator;
  24  import android.animation.ValueAnimator;
  25  import android.animation.ValueAnimator.AnimatorUpdateListener;
  26  import android.content.Context;
  27  import android.content.res.Resources;
  28  import android.content.res.TypedArray;
  29  import android.graphics.Canvas;
  30  import android.graphics.Matrix;
  31  import android.graphics.PointF;
  32  import android.graphics.Rect;
  33  import android.os.Bundle;
  34  import android.os.Parcel;
  35  import android.os.Parcelable;
  36  import android.util.AttributeSet;
  37  import android.util.DisplayMetrics;
  38  import android.util.Log;
  39  import android.view.InputDevice;
  40  import android.view.KeyEvent;
  41  import android.view.MotionEvent;
  42  import android.view.VelocityTracker;
  43  import android.view.View;
  44  import android.view.ViewConfiguration;
  45  import android.view.ViewGroup;
  46  import android.view.ViewParent;

  47  import android.view.accessibility.AccessibilityEvent;
  48  import android.view.accessibility.AccessibilityManager;
  49  import android.view.accessibility.AccessibilityNodeInfo;
  50  import android.view.animation.AnimationUtils;
  51  import android.view.animation.DecelerateInterpolator;
  52  import android.view.animation.Interpolator;
  53  import android.view.animation.LinearInterpolator;

  54  import android.widget.Scroller;
  55  
  56  import java.util.ArrayList;
  57  
  58  /**
  59   * An abstraction of the original Workspace which supports browsing through a
  60   * sequential list of &quot;pages&quot;
  61   */
  62  public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
  63      private static final String TAG = &quot;PagedView&quot;;
  64      private static final boolean DEBUG = false;
  65      protected static final int INVALID_PAGE = -1;
  66  
  67      // the min drag distance for a fling to register, to prevent random page shifts
  68      private static final int MIN_LENGTH_FOR_FLING = 25;
  69  
  70      protected static final int PAGE_SNAP_ANIMATION_DURATION = 750;
  71      protected static final int SLOW_PAGE_SNAP_ANIMATION_DURATION = 950;
  72      protected static final float NANOTIME_DIV = 1000000000.0f;
  73  
  74      private static final float OVERSCROLL_ACCELERATE_FACTOR = 2;
  75      private static final float OVERSCROLL_DAMP_FACTOR = 0.14f;
  76  
  77      private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD = 0.33f;
  78      // The page is moved more than halfway, automatically move to the next page on touch up.
  79      private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
  80  
  81      // The following constants need to be scaled based on density. The scaled versions will be
  82      // assigned to the corresponding member variables below.
  83      private static final int FLING_THRESHOLD_VELOCITY = 500;
  84      private static final int MIN_SNAP_VELOCITY = 1500;
  85      private static final int MIN_FLING_VELOCITY = 250;
  86  
  87      // We are disabling touch interaction of the widget region for factory ROM.
  88      private static final boolean DISABLE_TOUCH_INTERACTION = false;
  89      private static final boolean DISABLE_TOUCH_SIDE_PAGES = false;
  90      private static final boolean DISABLE_FLING_TO_DELETE = true;
  91  
  92      static final int AUTOMATIC_PAGE_SPACING = -1;
  93  
  94      protected int mFlingThresholdVelocity;
  95      protected int mMinFlingVelocity;
  96      protected int mMinSnapVelocity;
  97  
  98      protected float mDensity;
  99      protected float mSmoothingTime;
 100      protected float mTouchX;
 101  
 102      protected boolean mFirstLayout = true;
 103  
 104      protected int mCurrentPage;
 105      protected int mChildCountOnLastMeasure;
 106  
 107      protected int mNextPage = INVALID_PAGE;
 108      protected int mMaxScrollX;
 109      protected Scroller mScroller;
 110      private VelocityTracker mVelocityTracker;
 111  
 112      private float mParentDownMotionX;
 113      private float mParentDownMotionY;
 114      private float mDownMotionX;
 115      private float mDownMotionY;
 116      private float mDownScrollX;
 117      protected float mLastMotionX;
 118      protected float mLastMotionXRemainder;
 119      protected float mLastMotionY;
 120      protected float mTotalMotionX;
 121      private int mLastScreenCenter = -1;
 122      private int[] mChildOffsets;
 123      private int[] mChildRelativeOffsets;
 124      private int[] mChildOffsetsWithLayoutScale;
 125  
 126      protected final static int TOUCH_STATE_REST = 0;
 127      protected final static int TOUCH_STATE_SCROLLING = 1;
 128      protected final static int TOUCH_STATE_PREV_PAGE = 2;
 129      protected final static int TOUCH_STATE_NEXT_PAGE = 3;
 130      protected final static int TOUCH_STATE_REORDERING = 4;
 131  
 132      protected final static float ALPHA_QUANTIZE_LEVEL = 0.0001f;
 133  
 134      protected int mTouchState = TOUCH_STATE_REST;
 135      protected boolean mForceScreenScrolled = false;
 136  
 137      protected OnLongClickListener mLongClickListener;
 138  
 139      protected int mTouchSlop;
 140      private int mPagingTouchSlop;
 141      private int mMaximumVelocity;
 142      private int mMinimumWidth;
 143      protected int mPageSpacing;
 144      protected int mPageLayoutPaddingTop;
 145      protected int mPageLayoutPaddingBottom;
 146      protected int mPageLayoutPaddingLeft;
 147      protected int mPageLayoutPaddingRight;
 148      protected int mPageLayoutWidthGap;
 149      protected int mPageLayoutHeightGap;
 150      protected int mCellCountX = 0;
 151      protected int mCellCountY = 0;
 152      protected boolean mCenterPagesVertically;
 153      protected boolean mAllowOverScroll = true;
 154      protected int mUnboundedScrollX;
 155      protected int[] mTempVisiblePagesRange = new int[2];
 156      protected boolean mForceDrawAllChildrenNextFrame;
 157  
 158      // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 159      // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 160      // the screens from continuing to translate beyond the normal bounds.
 161      protected int mOverScrollX;
 162  
 163      // parameter that adjusts the layout to be optimized for pages with that scale factor
 164      protected float mLayoutScale = 1.0f;
 165  
 166      protected static final int INVALID_POINTER = -1;
 167  
 168      protected int mActivePointerId = INVALID_POINTER;
 169  
 170      private PageSwitchListener mPageSwitchListener;
 171  
 172      protected ArrayList&lt;Boolean&gt; mDirtyPageContent;
 173  
 174      // If true, syncPages and syncPageItems will be called to refresh pages
 175      protected boolean mContentIsRefreshable = true;
 176  
 177      // If true, modify alpha of neighboring pages as user scrolls left/right
 178      protected boolean mFadeInAdjacentScreens = false;
 179  
 180      // It true, use a different slop parameter (pagingTouchSlop = 2 * touchSlop) for deciding
 181      // to switch to a new page
 182      protected boolean mUsePagingTouchSlop = true;
 183  
 184      // If true, the subclass should directly update scrollX itself in its computeScroll method
 185      // (SmoothPagedView does this)
 186      protected boolean mDeferScrollUpdate = false;
 187  
 188      protected boolean mIsPageMoving = false;
 189  
 190      // All syncs and layout passes are deferred until data is ready.
 191      protected boolean mIsDataReady = false;
 192  
 193      protected boolean mAllowLongPress = true;
 194  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -    // Scrolling indicator</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -    private ValueAnimator mScrollIndicatorAnimator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -    private View mScrollIndicator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -    private int mScrollIndicatorPaddingLeft;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -    private int mScrollIndicatorPaddingRight;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -    private boolean mHasScrollIndicator = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -    private boolean mShouldShowScrollIndicator = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -    private boolean mShouldShowScrollIndicatorImmediately = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -    protected static final int sScrollIndicatorFadeInDuration = 150;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -    protected static final int sScrollIndicatorFadeOutDuration = 650;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -    protected static final int sScrollIndicatorFlashDuration = 650;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -    private boolean mScrollingPaused = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +    // Page Indicator</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +    private int mPageIndicatorViewId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +    private PageIndicator mPageIndicator;</span>
 210  
 211      // The viewport whether the pages are to be contained (the actual view may be larger than the
 212      // viewport)
 213      private Rect mViewport = new Rect();
 214  
 215      // Reordering
 216      // We use the min scale to determine how much to expand the actually PagedView measured
 217      // dimensions such that when we are zoomed out, the view is not clipped
 218      private int REORDERING_DROP_REPOSITION_DURATION = 200;
 219      protected int REORDERING_REORDER_REPOSITION_DURATION = 300;
 220      protected int REORDERING_ZOOM_IN_OUT_DURATION = 250;
 221      private int REORDERING_SIDE_PAGE_HOVER_TIMEOUT = 300;
 222      private float REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE = 0.1f;
 223      private long REORDERING_DELETE_DROP_TARGET_FADE_DURATION = 150;
 224      private float mMinScale = 1f;
 225      protected View mDragView;
 226      protected AnimatorSet mZoomInOutAnim;
 227      private Runnable mSidePageHoverRunnable;
 228      private int mSidePageHoverIndex = -1;
 229      // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 230      private boolean mReorderingStarted = false;
 231      // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 232      // animation after endReordering()
 233      private boolean mIsReordering;
 234      // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 235      private int NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT = 2;
 236      private int mPostReorderingPreZoomInRemainingAnimationCount;
 237      private Runnable mPostReorderingPreZoomInRunnable;
 238  
 239      // Edge swiping
 240      private boolean mOnlyAllowEdgeSwipes = false;
 241      private boolean mDownEventOnEdge = false;
 242      private int mEdgeSwipeRegionSize = 0;
 243  
 244      // Convenience/caching
 245      private Matrix mTmpInvMatrix = new Matrix();
 246      private float[] mTmpPoint = new float[2];
 247      private Rect mTmpRect = new Rect();
 248      private Rect mAltTmpRect = new Rect();
 249  
 250      // Fling to delete
 251      private int FLING_TO_DELETE_FADE_OUT_DURATION = 350;
 252      private float FLING_TO_DELETE_FRICTION = 0.035f;
 253      // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 254      private float FLING_TO_DELETE_MAX_FLING_DEGREES = 65f;
 255      protected int mFlingToDeleteThresholdVelocity = -1400;
 256      // Drag to delete
 257      private boolean mDeferringForDelete = false;
 258      private int DELETE_SLIDE_IN_SIDE_PAGE_DURATION = 250;
 259      private int DRAG_TO_DELETE_FADE_OUT_DURATION = 350;
 260  
 261      // Drop to delete
 262      private View mDeleteDropTarget;
 263  
 264      private boolean mAutoComputePageSpacing = false;
 265      private boolean mRecomputePageSpacing = false;
 266  
 267      // Bouncer
 268      private boolean mTopAlignPageWhenShrinkingForBouncer = false;
 269  
 270      public interface PageSwitchListener {
 271          void onPageSwitch(View newPage, int newPageIndex);
 272      }
 273  
 274      public PagedView(Context context) {
 275          this(context, null);
 276      }
 277  
 278      public PagedView(Context context, AttributeSet attrs) {
 279          this(context, attrs, 0);
 280      }
 281  
 282      public PagedView(Context context, AttributeSet attrs, int defStyle) {
 283          super(context, attrs, defStyle);
 284          TypedArray a = context.obtainStyledAttributes(attrs,
 285                  R.styleable.PagedView, defStyle, 0);
 286          setPageSpacing(a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing, 0));
 287          if (mPageSpacing &lt; 0) {
 288              mAutoComputePageSpacing = mRecomputePageSpacing = true;
 289          }
 290          mPageLayoutPaddingTop = a.getDimensionPixelSize(
 291                  R.styleable.PagedView_pageLayoutPaddingTop, 0);
 292          mPageLayoutPaddingBottom = a.getDimensionPixelSize(
 293                  R.styleable.PagedView_pageLayoutPaddingBottom, 0);
 294          mPageLayoutPaddingLeft = a.getDimensionPixelSize(
 295                  R.styleable.PagedView_pageLayoutPaddingLeft, 0);
 296          mPageLayoutPaddingRight = a.getDimensionPixelSize(
 297                  R.styleable.PagedView_pageLayoutPaddingRight, 0);
 298          mPageLayoutWidthGap = a.getDimensionPixelSize(
 299                  R.styleable.PagedView_pageLayoutWidthGap, 0);
 300          mPageLayoutHeightGap = a.getDimensionPixelSize(
 301                  R.styleable.PagedView_pageLayoutHeightGap, 0);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -        mScrollIndicatorPaddingLeft =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -            a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingLeft, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 304 -        mScrollIndicatorPaddingRight =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 305 -            a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingRight, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        mPageIndicatorViewId = a.getResourceId(R.styleable.PagedView_pageIndicator, -1);</span>
 307          a.recycle();
 308  
 309          setHapticFeedbackEnabled(false);
 310          init();
 311      }
 312  
 313      /**
 314       * Initializes various states for this workspace.
 315       */
 316      protected void init() {
 317          mDirtyPageContent = new ArrayList&lt;Boolean&gt;();
 318          mDirtyPageContent.ensureCapacity(32);
 319          mScroller = new Scroller(getContext(), new ScrollInterpolator());
 320          mCurrentPage = 0;
 321          mCenterPagesVertically = true;
 322  
 323          final ViewConfiguration configuration = ViewConfiguration.get(getContext());
 324          mTouchSlop = configuration.getScaledPagingTouchSlop();
 325          mPagingTouchSlop = configuration.getScaledPagingTouchSlop();
 326          mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
 327          mDensity = getResources().getDisplayMetrics().density;
 328  
 329          // Scale the fling-to-delete threshold by the density
 330          mFlingToDeleteThresholdVelocity =
 331                  (int) (mFlingToDeleteThresholdVelocity * mDensity);
 332  
 333          mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 334          mMinFlingVelocity = (int) (MIN_FLING_VELOCITY * mDensity);
 335          mMinSnapVelocity = (int) (MIN_SNAP_VELOCITY * mDensity);
 336          setOnHierarchyChangeListener(this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +    protected void onAttachedToWindow() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +        // Hook up the page indicator</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +        ViewGroup parent = (ViewGroup) getParent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +        if (mPageIndicator == null &amp;&amp; mPageIndicatorViewId &gt; -1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +            mPageIndicator = (PageIndicator) parent.findViewById(mPageIndicatorViewId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +            mPageIndicator.removeAllMarkers();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +            mPageIndicator.addMarkers(getChildCount());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +    protected void onDetachedFromWindow() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +        // Unhook the page indicator</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +        mPageIndicator = null;</span>
 352      }
 353  
 354      void setDeleteDropTarget(View v) {
 355          mDeleteDropTarget = v;
 356      }
 357  
 358      // Convenience methods to map points from self to parent and vice versa
 359      float[] mapPointFromViewToParent(View v, float x, float y) {
 360          mTmpPoint[0] = x;
 361          mTmpPoint[1] = y;
 362          v.getMatrix().mapPoints(mTmpPoint);
 363          mTmpPoint[0] += v.getLeft();
 364          mTmpPoint[1] += v.getTop();
 365          return mTmpPoint;
 366      }
 367      float[] mapPointFromParentToView(View v, float x, float y) {
 368          mTmpPoint[0] = x - v.getLeft();
 369          mTmpPoint[1] = y - v.getTop();
 370          v.getMatrix().invert(mTmpInvMatrix);
 371          mTmpInvMatrix.mapPoints(mTmpPoint);
 372          return mTmpPoint;
 373      }
 374  
 375      void updateDragViewTranslationDuringDrag() {
 376          float x = mLastMotionX - mDownMotionX + getScrollX() - mDownScrollX;
 377          float y = mLastMotionY - mDownMotionY;
 378          mDragView.setTranslationX(x);
 379          mDragView.setTranslationY(y);
 380  
 381          if (DEBUG) Log.d(TAG, &quot;PagedView.updateDragViewTranslationDuringDrag(): &quot; + x + &quot;, &quot; + y);
 382      }
 383  
 384      public void setMinScale(float f) {
 385          mMinScale = f;
 386          requestLayout();
 387      }
 388  
 389      @Override
 390      public void setScaleX(float scaleX) {
 391          super.setScaleX(scaleX);
 392          if (isReordering(true)) {
 393              float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 394              mLastMotionX = p[0];
 395              mLastMotionY = p[1];
 396              updateDragViewTranslationDuringDrag();
 397          }
 398      }
 399  
 400      // Convenience methods to get the actual width/height of the PagedView (since it is measured
 401      // to be larger to account for the minimum possible scale)
 402      int getViewportWidth() {
 403          return mViewport.width();
 404      }
 405      int getViewportHeight() {
 406          return mViewport.height();
 407      }
 408  
 409      // Convenience methods to get the offset ASSUMING that we are centering the pages in the
 410      // PagedView both horizontally and vertically
 411      int getViewportOffsetX() {
 412          return (getMeasuredWidth() - getViewportWidth()) / 2;
 413      }
 414  
 415      int getViewportOffsetY() {
 416          return (getMeasuredHeight() - getViewportHeight()) / 2;
 417      }
 418  
 419      public void setPageSwitchListener(PageSwitchListener pageSwitchListener) {
 420          mPageSwitchListener = pageSwitchListener;
 421          if (mPageSwitchListener != null) {
 422              mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 423          }
 424      }
 425  
 426      /**
 427       * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.
 428       */
 429      public boolean isLayoutRtl() {
 430          return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
 431      }
 432  
 433      /**
 434       * Called by subclasses to mark that data is ready, and that we can begin loading and laying
 435       * out pages.
 436       */
 437      protected void setDataIsReady() {
 438          mIsDataReady = true;
 439      }
 440  
 441      protected boolean isDataReady() {
 442          return mIsDataReady;
 443      }
 444  
 445      /**
 446       * Returns the index of the currently displayed page.
 447       *
 448       * @return The index of the currently displayed page.
 449       */
 450      int getCurrentPage() {
 451          return mCurrentPage;
 452      }
 453  
 454      int getNextPage() {
 455          return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
 456      }
 457  
 458      int getPageCount() {
 459          return getChildCount();
 460      }
 461  
 462      View getPageAt(int index) {
 463          return getChildAt(index);
 464      }
 465  
 466      protected int indexToPage(int index) {
 467          return index;
 468      }
 469  
 470      /**
 471       * Updates the scroll of the current page immediately to its final scroll position.  We use this
 472       * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of
 473       * the previous tab page.
 474       */
 475      protected void updateCurrentPageScroll() {
 476          // If the current page is invalid, just reset the scroll position to zero
 477          int newX = 0;
 478          if (0 &lt;= mCurrentPage &amp;&amp; mCurrentPage &lt; getPageCount()) {
 479              int offset = getChildOffset(mCurrentPage);
 480              int relOffset = getRelativeChildOffset(mCurrentPage);
 481              newX = offset - relOffset;
 482          }
 483          scrollTo(newX, 0);
 484          mScroller.setFinalX(newX);
 485          mScroller.forceFinished(true);
 486      }
 487  
 488      /**
 489       * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation
 490       * ends, {@link #resumeScrolling()} should be called, along with
 491       * {@link #updateCurrentPageScroll()} to correctly set the final state and re-enable scrolling.
 492       */
 493      void pauseScrolling() {
 494          mScroller.forceFinished(true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -        cancelScrollingIndicatorAnimations();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 496 -        mScrollingPaused = true;</span>
 497      }
 498  
 499      /**
 500       * Enables scrolling again.
 501       * @see #pauseScrolling()
 502       */
 503      void resumeScrolling() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -        mScrollingPaused = false;</span>
 505      }
 506      /**
 507       * Sets the current page.
 508       */
 509      void setCurrentPage(int currentPage) {
 510          if (!mScroller.isFinished()) {
 511              mScroller.abortAnimation();
 512          }
 513          // don&#x27;t introduce any checks like mCurrentPage == currentPage here-- if we change the
 514          // the default
 515          if (getChildCount() == 0) {
 516              return;
 517          }
 518  
 519          mForceScreenScrolled = true;
 520          mCurrentPage = Math.max(0, Math.min(currentPage, getPageCount() - 1));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -        updateCurrentPageScroll();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -        updateScrollingIndicator();</span>
 523          notifyPageSwitchListener();
 524          invalidate();
 525      }
 526  
 527      protected void notifyPageSwitchListener() {
 528          if (mPageSwitchListener != null) {
 529              mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 530 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 531 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 532 +        // Update the page indicator (when we aren&#x27;t reordering)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +        if (mPageIndicator != null &amp;&amp; !isReordering(false)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 534 +            mPageIndicator.setActiveMarker(getNextPage());</span>
 535          }
 536      }
 537      protected void pageBeginMoving() {
 538          if (!mIsPageMoving) {
 539              mIsPageMoving = true;
 540              onPageBeginMoving();
 541          }
 542      }
 543  
 544      protected void pageEndMoving() {
 545          if (mIsPageMoving) {
 546              mIsPageMoving = false;
 547              onPageEndMoving();
 548          }
 549      }
 550  
 551      protected boolean isPageMoving() {
 552          return mIsPageMoving;
 553      }
 554  
 555      // a method that subclasses can override to add behavior
 556      protected void onPageBeginMoving() {
 557      }
 558  
 559      // a method that subclasses can override to add behavior
 560      protected void onPageEndMoving() {
 561      }
 562  
 563      /**
 564       * Registers the specified listener on each page contained in this workspace.
 565       *
 566       * @param l The listener used to respond to long clicks.
 567       */
 568      @Override
 569      public void setOnLongClickListener(OnLongClickListener l) {
 570          mLongClickListener = l;
 571          final int count = getPageCount();
 572          for (int i = 0; i &lt; count; i++) {
 573              getPageAt(i).setOnLongClickListener(l);
 574          }
 575      }
 576  
 577      @Override
 578      public void scrollBy(int x, int y) {
 579          scrollTo(mUnboundedScrollX + x, getScrollY() + y);
 580      }
 581  
 582      @Override
 583      public void scrollTo(int x, int y) {
 584          final boolean isRtl = isLayoutRtl();
 585          mUnboundedScrollX = x;
 586  
 587          boolean isXBeforeFirstPage = isRtl ? (x &gt; mMaxScrollX) : (x &lt; 0);
 588          boolean isXAfterLastPage = isRtl ? (x &lt; 0) : (x &gt; mMaxScrollX);
 589          if (isXBeforeFirstPage) {
 590              super.scrollTo(0, y);
 591              if (mAllowOverScroll) {
 592                  if (isRtl) {
 593                      overScroll(x - mMaxScrollX);
 594                  } else {
 595                      overScroll(x);
 596                  }
 597              }
 598          } else if (isXAfterLastPage) {
 599              super.scrollTo(mMaxScrollX, y);
 600              if (mAllowOverScroll) {
 601                  if (isRtl) {
 602                      overScroll(x);
 603                  } else {
 604                      overScroll(x - mMaxScrollX);
 605                  }
 606              }
 607          } else {
 608              mOverScrollX = x;
 609              super.scrollTo(x, y);
 610          }
 611  
 612          mTouchX = x;
 613          mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
 614  
 615          // Update the last motion events when scrolling
 616          if (isReordering(true)) {
 617              float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 618              mLastMotionX = p[0];
 619              mLastMotionY = p[1];
 620              updateDragViewTranslationDuringDrag();
 621          }
 622      }
 623  
 624      // we moved this functionality to a helper function so SmoothPagedView can reuse it
 625      protected boolean computeScrollHelper() {
 626          if (mScroller.computeScrollOffset()) {
 627              // Don&#x27;t bother scrolling if the page does not need to be moved
 628              if (getScrollX() != mScroller.getCurrX()
 629                  || getScrollY() != mScroller.getCurrY()
 630                  || mOverScrollX != mScroller.getCurrX()) {
 631                  scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
 632              }
 633              invalidate();
 634              return true;
 635          } else if (mNextPage != INVALID_PAGE) {
 636              mCurrentPage = Math.max(0, Math.min(mNextPage, getPageCount() - 1));
 637              mNextPage = INVALID_PAGE;
 638              notifyPageSwitchListener();
 639  
 640              // We don&#x27;t want to trigger a page end moving unless the page has settled
 641              // and the user has stopped scrolling
 642              if (mTouchState == TOUCH_STATE_REST) {
 643                  pageEndMoving();
 644              }
 645  
 646              onPostReorderingAnimationCompleted();
 647              // Notify the user when the page changes
 648              AccessibilityManager accessibilityManager = (AccessibilityManager)
 649                      getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
 650              if (accessibilityManager.isEnabled()) {
 651                  AccessibilityEvent ev =
 652                      AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
 653                  ev.getText().add(getCurrentPageDescription());
 654                  sendAccessibilityEventUnchecked(ev);
 655              }
 656              return true;
 657          }
 658          return false;
 659      }
 660  
 661      @Override
 662      public void computeScroll() {
 663          computeScrollHelper();
 664      }
 665  
 666      protected boolean shouldSetTopAlignedPivotForWidget(int childIndex) {
 667          return mTopAlignPageWhenShrinkingForBouncer;
 668      }
 669  

























 670      @Override
 671      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 672          if (!mIsDataReady || getChildCount() == 0) {
 673              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 674              return;
 675          }
 676  
 677          // We measure the dimensions of the PagedView to be larger than the pages so that when we
 678          // zoom out (and scale down), the view is still contained in the parent
 679          int widthMode = MeasureSpec.getMode(widthMeasureSpec);
 680          int widthSize = MeasureSpec.getSize(widthMeasureSpec);
 681          int heightMode = MeasureSpec.getMode(heightMeasureSpec);
 682          int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 683          // NOTE: We multiply by 1.5f to account for the fact that depending on the offset of the
 684          // viewport, we can be at most one and a half screens offset once we scale down
 685          DisplayMetrics dm = getResources().getDisplayMetrics();
 686          int maxSize = Math.max(dm.widthPixels, dm.heightPixels);
 687          int parentWidthSize = (int) (1.5f * maxSize);
 688          int parentHeightSize = maxSize;
 689          int scaledWidthSize = (int) (parentWidthSize / mMinScale);
 690          int scaledHeightSize = (int) (parentHeightSize / mMinScale);
 691          mViewport.set(0, 0, widthSize, heightSize);
 692  
 693          if (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {
 694              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 695              return;
 696          }
 697  
 698          // Return early if we aren&#x27;t given a proper dimension
 699          if (widthSize &lt;= 0 || heightSize &lt;= 0) {
 700              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 701              return;
 702          }
 703  
 704          /* Allow the height to be set as WRAP_CONTENT. This allows the particular case
 705           * of the All apps view on XLarge displays to not take up more space then it needs. Width
 706           * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect
 707           * each page to have the same width.
 708           */
 709          final int verticalPadding = getPaddingTop() + getPaddingBottom();
 710          final int horizontalPadding = getPaddingLeft() + getPaddingRight();
 711  
 712          // The children are given the same width and height as the workspace
 713          // unless they were set to WRAP_CONTENT
 714          if (DEBUG) Log.d(TAG, &quot;PagedView.onMeasure(): &quot; + widthSize + &quot;, &quot; + heightSize);
 715          if (DEBUG) Log.d(TAG, &quot;PagedView.scaledSize: &quot; + scaledWidthSize + &quot;, &quot; + scaledHeightSize);
 716          if (DEBUG) Log.d(TAG, &quot;PagedView.parentSize: &quot; + parentWidthSize + &quot;, &quot; + parentHeightSize);
 717          if (DEBUG) Log.d(TAG, &quot;PagedView.horizontalPadding: &quot; + horizontalPadding);
 718          if (DEBUG) Log.d(TAG, &quot;PagedView.verticalPadding: &quot; + verticalPadding);
 719          final int childCount = getChildCount();
 720          for (int i = 0; i &lt; childCount; i++) {
 721              // disallowing padding in paged view (just pass 0)
 722              final View child = getPageAt(i);
 723              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 724  
 725              int childWidthMode;
 726              if (lp.width == LayoutParams.WRAP_CONTENT) {
 727                  childWidthMode = MeasureSpec.AT_MOST;




















 728              } else {
 729                  childWidthMode = MeasureSpec.EXACTLY;
 730              }
 731  
 732              int childHeightMode;
 733              if (lp.height == LayoutParams.WRAP_CONTENT) {
 734                  childHeightMode = MeasureSpec.AT_MOST;
 735              } else {
 736                  childHeightMode = MeasureSpec.EXACTLY;



 737              }
 738  
 739              final int childWidthMeasureSpec =
 740                  MeasureSpec.makeMeasureSpec(widthSize - horizontalPadding, childWidthMode);
 741              final int childHeightMeasureSpec =
 742                  MeasureSpec.makeMeasureSpec(heightSize - verticalPadding, childHeightMode);
 743  



 744              child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 745          }
 746          setMeasuredDimension(scaledWidthSize, scaledHeightSize);
 747  
 748          // We can&#x27;t call getChildOffset/getRelativeChildOffset until we set the measured dimensions.
 749          // We also wait until we set the measured dimensions before flushing the cache as well, to
 750          // ensure that the cache is filled with good values.
 751          invalidateCachedOffsets();
 752  
 753          if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;
 754                  !mDeferringForDelete) {
 755              setCurrentPage(getNextPage());
 756          }
 757          mChildCountOnLastMeasure = getChildCount();
 758  
 759          if (childCount &gt; 0) {
 760              if (DEBUG) Log.d(TAG, &quot;getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
 761                      + getChildWidth(0));
 762  
 763              // Calculate the variable page spacing if necessary
 764              if (mAutoComputePageSpacing &amp;&amp; mRecomputePageSpacing) {
 765                  // The gap between pages in the PagedView should be equal to the gap from the page
 766                  // to the edge of the screen (so it is not visible in the current screen).  To
 767                  // account for unequal padding on each side of the paged view, we take the maximum
 768                  // of the left/right gap and use that as the gap between each page.
 769                  int offset = getRelativeChildOffset(0);
 770                  int spacing = Math.max(offset, widthSize - offset -
 771                          getChildAt(0).getMeasuredWidth());
 772                  setPageSpacing(spacing);
 773                  mRecomputePageSpacing = false;
 774              }
 775          }
 776  






<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 777 -        updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -</span>
 779          if (childCount &gt; 0) {
 780              final int index = isLayoutRtl() ? 0 : childCount - 1;
 781              mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);
 782          } else {
 783              mMaxScrollX = 0;
 784          }
 785      }
 786  
 787      public void setPageSpacing(int pageSpacing) {
 788          mPageSpacing = pageSpacing;
 789          invalidateCachedOffsets();
 790      }
 791  
 792      @Override
 793      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 794          if (!mIsDataReady || getChildCount() == 0) {
 795              return;
 796          }
 797  
 798          if (DEBUG) Log.d(TAG, &quot;PagedView.onLayout()&quot;);
 799          final int childCount = getChildCount();
 800  
 801          int offsetX = getViewportOffsetX();
 802          int offsetY = getViewportOffsetY();
 803  
 804          // Update the viewport offsets
 805          mViewport.offset(offsetX,  offsetY);
 806  
 807          final boolean isRtl = isLayoutRtl();
 808  
 809          final int startIndex = isRtl ? childCount - 1 : 0;
 810          final int endIndex = isRtl ? -1 : childCount;
 811          final int delta = isRtl ? -1 : 1;
 812  
 813          int verticalPadding = getPaddingTop() + getPaddingBottom();
 814          int childLeft = offsetX + getRelativeChildOffset(startIndex);
 815          for (int i = startIndex; i != endIndex; i += delta) {
 816              final View child = getPageAt(i);
 817              int childTop = offsetY + getPaddingTop();
 818              if (mCenterPagesVertically) {
 819                  childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;
 820              }












 821              if (child.getVisibility() != View.GONE) {
 822                  final int childWidth = getScaledMeasuredWidth(child);

 823                  final int childHeight = child.getMeasuredHeight();
 824  
 825                  if (DEBUG) Log.d(TAG, &quot;\tlayout-child&quot; + i + &quot;: &quot; + childLeft + &quot;, &quot; + childTop);
 826                  child.layout(childLeft, childTop,
 827                          childLeft + child.getMeasuredWidth(), childTop + childHeight);
 828                  childLeft += childWidth + mPageSpacing;
 829              }
 830          }
 831  
 832          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
 833              setHorizontalScrollBarEnabled(false);
 834              updateCurrentPageScroll();
 835              setHorizontalScrollBarEnabled(true);
 836              mFirstLayout = false;
 837          }
 838      }
 839  
 840      protected void screenScrolled(int screenCenter) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -        if (isScrollingIndicatorEnabled()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -            updateScrollingIndicator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -        }</span>
 844          boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
 845  
 846          if (mFadeInAdjacentScreens &amp;&amp; !isInOverscroll) {
 847              for (int i = 0; i &lt; getChildCount(); i++) {
 848                  View child = getChildAt(i);
 849                  if (child != null) {
 850                      float scrollProgress = getScrollProgress(screenCenter, child, i);
 851                      float alpha = 1 - Math.abs(scrollProgress);
 852                      child.setAlpha(alpha);
 853                  }
 854              }
 855              invalidate();
 856          }
 857      }
 858  
 859      @Override
 860      public void onChildViewAdded(View parent, View child) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 861 +        // Update the page indicator, we don&#x27;t update the page indicator as we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +        // add/remove pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +        if (mPageIndicator != null &amp;&amp; !isReordering(false)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 864 +            mPageIndicator.addMarker(indexOfChild(child));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 865 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 866 +</span>
 867          // This ensures that when children are added, they get the correct transforms / alphas
 868          // in accordance with any scroll effects.
 869          mForceScreenScrolled = true;
 870          mRecomputePageSpacing = true;

 871          invalidate();
 872          invalidateCachedOffsets();
 873      }
 874  
 875      @Override
 876      public void onChildViewRemoved(View parent, View child) {
 877          mForceScreenScrolled = true;
 878          invalidate();
 879          invalidateCachedOffsets();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +    private void removeMarkerForView(int index) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 883 +        // Update the page indicator, we don&#x27;t update the page indicator as we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +        // add/remove pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +        if (mPageIndicator != null &amp;&amp; !isReordering(false)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +            mPageIndicator.removeMarker(index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 889 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 890 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +    public void removeView(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +        // XXX: We should find a better way to hook into this before the view</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +        // gets removed form its parent...</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +        removeMarkerForView(indexOfChild(v));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +        super.removeView(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 896 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +    public void removeViewInLayout(View v) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +        // XXX: We should find a better way to hook into this before the view</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +        // gets removed form its parent...</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +        removeMarkerForView(indexOfChild(v));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 902 +        super.removeViewInLayout(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 903 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +    public void removeViewAt(int index) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +        // XXX: We should find a better way to hook into this before the view</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +        // gets removed form its parent...</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +        removeViewAt(index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +        super.removeViewAt(index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +    public void removeAllViewsInLayout() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +        // Update the page indicator, we don&#x27;t update the page indicator as we</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +        // add/remove pages</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +        if (mPageIndicator != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +            mPageIndicator.removeAllMarkers();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +        super.removeAllViewsInLayout();</span>
 920      }
 921  
 922      protected void invalidateCachedOffsets() {
 923          int count = getChildCount();
 924          if (count == 0) {
 925              mChildOffsets = null;
 926              mChildRelativeOffsets = null;
 927              mChildOffsetsWithLayoutScale = null;
 928              return;
 929          }
 930  
 931          mChildOffsets = new int[count];
 932          mChildRelativeOffsets = new int[count];
 933          mChildOffsetsWithLayoutScale = new int[count];
 934          for (int i = 0; i &lt; count; i++) {
 935              mChildOffsets[i] = -1;
 936              mChildRelativeOffsets[i] = -1;
 937              mChildOffsetsWithLayoutScale[i] = -1;
 938          }
 939      }
 940  
 941      protected int getChildOffset(int index) {
 942          if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
 943  
 944          final boolean isRtl = isLayoutRtl();
 945          int[] childOffsets = Float.compare(mLayoutScale, 1f) == 0 ?
 946                  mChildOffsets : mChildOffsetsWithLayoutScale;

 947  
 948          if (childOffsets != null &amp;&amp; childOffsets[index] != -1) {
 949              return childOffsets[index];
 950          } else {
 951              if (getChildCount() == 0)
 952                  return 0;
 953  
 954  
 955              final int startIndex = isRtl ? getChildCount() - 1 : 0;
 956              final int endIndex = isRtl ? index : index;
 957              final int delta = isRtl ? -1 : 1;
 958  
 959              int offset = getRelativeChildOffset(startIndex);
 960              for (int i = startIndex; i != endIndex; i += delta) {
 961                  offset += getScaledMeasuredWidth(getPageAt(i)) + mPageSpacing;

 962              }
 963              if (childOffsets != null) {
 964                  childOffsets[index] = offset;
 965              }
 966              return offset;
 967          }

 968      }
 969  
 970      protected int getRelativeChildOffset(int index) {
 971          if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
 972  
 973          if (mChildRelativeOffsets != null &amp;&amp; mChildRelativeOffsets[index] != -1) {
 974              return mChildRelativeOffsets[index];
 975          } else {
 976              final int padding = getPaddingLeft() + getPaddingRight();
 977              final int offset = getPaddingLeft() +
 978                      (getViewportWidth() - padding - getChildWidth(index)) / 2;
 979              if (mChildRelativeOffsets != null) {
 980                  mChildRelativeOffsets[index] = offset;
 981              }
 982              return offset;
 983          }
 984      }
 985  
 986      protected int getScaledMeasuredWidth(View child) {
 987          // This functions are called enough times that it actually makes a difference in the
 988          // profiler -- so just inline the max() here
 989          final int measuredWidth = child.getMeasuredWidth();
 990          final int minWidth = mMinimumWidth;
 991          final int maxWidth = (minWidth &gt; measuredWidth) ? minWidth : measuredWidth;
 992          return (int) (maxWidth * mLayoutScale + 0.5f);
 993      }
 994  
 995      void boundByReorderablePages(boolean isReordering, int[] range) {
 996          // Do nothing
 997      }
 998  
 999      // TODO: Fix this
1000      protected void getVisiblePages(int[] range) {
1001          range[0] = 0;
1002          range[1] = getPageCount() - 1;
1003  
1004          /*
1005          final int pageCount = getChildCount();
1006  
1007          if (pageCount &gt; 0) {
1008              final int screenWidth = getViewportWidth();
1009              int leftScreen = 0;
1010              int rightScreen = 0;
1011              int offsetX = getViewportOffsetX() + getScrollX();
1012              View currPage = getPageAt(leftScreen);
1013              while (leftScreen &lt; pageCount - 1 &amp;&amp;
1014                      currPage.getX() + currPage.getWidth() -
1015                      currPage.getPaddingRight() &lt; offsetX) {
1016                  leftScreen++;
1017                  currPage = getPageAt(leftScreen);
1018              }
1019              rightScreen = leftScreen;
1020              currPage = getPageAt(rightScreen + 1);
1021              while (rightScreen &lt; pageCount - 1 &amp;&amp;
1022                      currPage.getX() - currPage.getPaddingLeft() &lt; offsetX + screenWidth) {
1023                  rightScreen++;
1024                  currPage = getPageAt(rightScreen + 1);
1025              }
1026  
1027              // TEMP: this is a hacky way to ensure that animations to new pages are not clipped
1028              // because we don&#x27;t draw them while scrolling?
1029              range[0] = Math.max(0, leftScreen - 1);
1030              range[1] = Math.min(rightScreen + 1, getChildCount() - 1);
1031          } else {
1032              range[0] = -1;
1033              range[1] = -1;
1034          }
1035          */
1036      }
1037  
1038      protected boolean shouldDrawChild(View child) {
1039          return child.getAlpha() &gt; 0;
1040      }
1041  
1042      @Override
1043      protected void dispatchDraw(Canvas canvas) {
1044          int halfScreenSize = getViewportWidth() / 2;
1045          // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range.
1046          // Otherwise it is equal to the scaled overscroll position.
1047          int screenCenter = mOverScrollX + halfScreenSize;
1048  
1049          if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
1050              // set mForceScreenScrolled before calling screenScrolled so that screenScrolled can
1051              // set it for the next frame
1052              mForceScreenScrolled = false;
1053              screenScrolled(screenCenter);
1054              mLastScreenCenter = screenCenter;
1055          }
1056  
1057          // Find out which screens are visible; as an optimization we only call draw on them
1058          final int pageCount = getChildCount();
1059          if (pageCount &gt; 0) {
1060              getVisiblePages(mTempVisiblePagesRange);
1061              final int leftScreen = mTempVisiblePagesRange[0];
1062              final int rightScreen = mTempVisiblePagesRange[1];
1063              if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1064                  final long drawingTime = getDrawingTime();
1065                  // Clip to the bounds
1066                  canvas.save();
1067                  canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
1068                          getScrollY() + getBottom() - getTop());
1069  
1070                  // Draw all the children, leaving the drag view for last
1071                  for (int i = pageCount - 1; i &gt;= 0; i--) {
1072                      final View v = getPageAt(i);
1073                      if (v == mDragView) continue;
1074                      if (mForceDrawAllChildrenNextFrame ||
1075                                 (leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(v))) {
1076                          drawChild(canvas, v, drawingTime);
1077                      }
1078                  }
1079                  // Draw the drag view on top (if there is one)
1080                  if (mDragView != null) {
1081                      drawChild(canvas, mDragView, drawingTime);
1082                  }
1083  
1084                  mForceDrawAllChildrenNextFrame = false;
1085                  canvas.restore();
1086              }
1087          }
1088      }
1089  
1090      @Override
1091      public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
1092          int page = indexToPage(indexOfChild(child));
1093          if (page != mCurrentPage || !mScroller.isFinished()) {
1094              snapToPage(page);
1095              return true;
1096          }
1097          return false;
1098      }
1099  
1100      @Override
1101      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1102          int focusablePage;
1103          if (mNextPage != INVALID_PAGE) {
1104              focusablePage = mNextPage;
1105          } else {
1106              focusablePage = mCurrentPage;
1107          }
1108          View v = getPageAt(focusablePage);
1109          if (v != null) {
1110              return v.requestFocus(direction, previouslyFocusedRect);
1111          }
1112          return false;
1113      }
1114  
1115      @Override
1116      public boolean dispatchUnhandledMove(View focused, int direction) {
1117          // XXX-RTL: This will be fixed in a future CL
1118          if (direction == View.FOCUS_LEFT) {
1119              if (getCurrentPage() &gt; 0) {
1120                  snapToPage(getCurrentPage() - 1);
1121                  return true;
1122              }
1123          } else if (direction == View.FOCUS_RIGHT) {
1124              if (getCurrentPage() &lt; getPageCount() - 1) {
1125                  snapToPage(getCurrentPage() + 1);
1126                  return true;
1127              }
1128          }
1129          return super.dispatchUnhandledMove(focused, direction);
1130      }
1131  
1132      @Override
1133      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1134          // XXX-RTL: This will be fixed in a future CL
1135          if (mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getPageCount()) {
1136              getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
1137          }
1138          if (direction == View.FOCUS_LEFT) {
1139              if (mCurrentPage &gt; 0) {
1140                  getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
1141              }
1142          } else if (direction == View.FOCUS_RIGHT){
1143              if (mCurrentPage &lt; getPageCount() - 1) {
1144                  getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
1145              }
1146          }
1147      }
1148  
1149      /**
1150       * If one of our descendant views decides that it could be focused now, only
1151       * pass that along if it&#x27;s on the current page.
1152       *
1153       * This happens when live folders requery, and if they&#x27;re off page, they
1154       * end up calling requestFocus, which pulls it on page.
1155       */
1156      @Override
1157      public void focusableViewAvailable(View focused) {
1158          View current = getPageAt(mCurrentPage);
1159          View v = focused;
1160          while (true) {
1161              if (v == current) {
1162                  super.focusableViewAvailable(focused);
1163                  return;
1164              }
1165              if (v == this) {
1166                  return;
1167              }
1168              ViewParent parent = v.getParent();
1169              if (parent instanceof View) {
1170                  v = (View)v.getParent();
1171              } else {
1172                  return;
1173              }
1174          }
1175      }
1176  
1177      /**
1178       * {@inheritDoc}
1179       */
1180      @Override
1181      public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
1182          if (disallowIntercept) {
1183              // We need to make sure to cancel our long press if
1184              // a scrollable widget takes over touch events
1185              final View currentPage = getPageAt(mCurrentPage);
1186              currentPage.cancelLongPress();
1187          }
1188          super.requestDisallowInterceptTouchEvent(disallowIntercept);
1189      }
1190  
1191      /**
1192       * Return true if a tap at (x, y) should trigger a flip to the previous page.
1193       */
1194      protected boolean hitsPreviousPage(float x, float y) {
1195          if (isLayoutRtl()) {
1196              return (x &gt; (getViewportOffsetX() + getViewportWidth() -
1197                      getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1198          }
1199          return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1200      }
1201  
1202      /**
1203       * Return true if a tap at (x, y) should trigger a flip to the next page.
1204       */
1205      protected boolean hitsNextPage(float x, float y) {
1206          if (isLayoutRtl()) {
1207              return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1208          }
1209          return  (x &gt; (getViewportOffsetX() + getViewportWidth() -
1210                  getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1211      }
1212  
1213      /** Returns whether x and y originated within the buffered viewport */
1214      private boolean isTouchPointInViewportWithBuffer(int x, int y) {
1215          mTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top,
1216                  mViewport.right + mViewport.width() / 2, mViewport.bottom);
1217          return mTmpRect.contains(x, y);
1218      }
1219  
1220      /** Returns whether x and y originated within the current page view bounds */
1221      private boolean isTouchPointInCurrentPage(int x, int y) {
1222          View v = getPageAt(getCurrentPage());
1223          if (v != null) {
1224              mTmpRect.set((v.getLeft() - getScrollX()), 0, (v.getRight() - getScrollX()),
1225                      v.getBottom());
1226              return mTmpRect.contains(x, y);
1227          }
1228          return false;
1229      }
1230  
1231      @Override
1232      public boolean onInterceptTouchEvent(MotionEvent ev) {
1233          if (DISABLE_TOUCH_INTERACTION) {
1234              return false;
1235          }
1236  
1237          /*
1238           * This method JUST determines whether we want to intercept the motion.
1239           * If we return true, onTouchEvent will be called and we do the actual
1240           * scrolling there.
1241           */
1242          acquireVelocityTrackerAndAddMovement(ev);
1243  
1244          // Skip touch handling if there are no pages to swipe
1245          if (getChildCount() &lt;= 0) return super.onInterceptTouchEvent(ev);
1246  
1247          /*
1248           * Shortcut the most recurring case: the user is in the dragging
1249           * state and he is moving his finger.  We want to intercept this
1250           * motion.
1251           */
1252          final int action = ev.getAction();
1253          if ((action == MotionEvent.ACTION_MOVE) &amp;&amp;
1254                  (mTouchState == TOUCH_STATE_SCROLLING)) {
1255              return true;
1256          }
1257  
1258          switch (action &amp; MotionEvent.ACTION_MASK) {
1259              case MotionEvent.ACTION_MOVE: {
1260                  /*
1261                   * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
1262                   * whether the user has moved far enough from his original down touch.
1263                   */
1264                  if (mActivePointerId != INVALID_POINTER) {
1265                      determineScrollingStart(ev);
1266                      break;
1267                  }
1268                  // if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN
1269                  // event. in that case, treat the first occurence of a move event as a ACTION_DOWN
1270                  // i.e. fall through to the next case (don&#x27;t break)
1271                  // (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events
1272                  // while it&#x27;s small- this was causing a crash before we checked for INVALID_POINTER)
1273              }
1274  
1275              case MotionEvent.ACTION_DOWN: {
1276                  final float x = ev.getX();
1277                  final float y = ev.getY();
1278                  // Remember location of down touch
1279                  mDownMotionX = x;
1280                  mDownMotionY = y;
1281                  mDownScrollX = getScrollX();
1282                  mLastMotionX = x;
1283                  mLastMotionY = y;
1284                  float[] p = mapPointFromViewToParent(this, x, y);
1285                  mParentDownMotionX = p[0];
1286                  mParentDownMotionY = p[1];
1287                  mLastMotionXRemainder = 0;
1288                  mTotalMotionX = 0;
1289                  mActivePointerId = ev.getPointerId(0);
1290  
1291                  // Determine if the down event is within the threshold to be an edge swipe
1292                  int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1293                  int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1294                  if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1295                      mDownEventOnEdge = true;
1296                  }
1297  
1298                  /*
1299                   * If being flinged and user touches the screen, initiate drag;
1300                   * otherwise don&#x27;t.  mScroller.isFinished should be false when
1301                   * being flinged.
1302                   */
1303                  final int xDist = Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
1304                  final boolean finishedScrolling = (mScroller.isFinished() || xDist &lt; mTouchSlop);
1305                  if (finishedScrolling) {
1306                      mTouchState = TOUCH_STATE_REST;
1307                      mScroller.abortAnimation();
1308                  } else {
1309                      if (isTouchPointInViewportWithBuffer((int) mDownMotionX, (int) mDownMotionY)) {
1310                          mTouchState = TOUCH_STATE_SCROLLING;
1311                      } else {
1312                          mTouchState = TOUCH_STATE_REST;
1313                      }
1314                  }
1315  
1316                  // check if this can be the beginning of a tap on the side of the pages
1317                  // to scroll the current page
1318                  if (!DISABLE_TOUCH_SIDE_PAGES) {
1319                      if (mTouchState != TOUCH_STATE_PREV_PAGE &amp;&amp; mTouchState != TOUCH_STATE_NEXT_PAGE) {
1320                          if (getChildCount() &gt; 0) {
1321                              if (hitsPreviousPage(x, y)) {
1322                                  mTouchState = TOUCH_STATE_PREV_PAGE;
1323                              } else if (hitsNextPage(x, y)) {
1324                                  mTouchState = TOUCH_STATE_NEXT_PAGE;
1325                              }
1326                          }
1327                      }
1328                  }
1329                  break;
1330              }
1331  
1332              case MotionEvent.ACTION_UP:
1333              case MotionEvent.ACTION_CANCEL:
1334                  resetTouchState();
1335                  // Just intercept the touch event on up if we tap outside the strict viewport
1336                  if (!isTouchPointInCurrentPage((int) mLastMotionX, (int) mLastMotionY)) {
1337                      return true;
1338                  }
1339                  break;
1340  
1341              case MotionEvent.ACTION_POINTER_UP:
1342                  onSecondaryPointerUp(ev);
1343                  releaseVelocityTracker();
1344                  break;
1345          }
1346  
1347          /*
1348           * The only time we want to intercept motion events is if we are in the
1349           * drag mode.
1350           */
1351          return mTouchState != TOUCH_STATE_REST;
1352      }
1353  
1354      protected void determineScrollingStart(MotionEvent ev) {
1355          determineScrollingStart(ev, 1.0f);
1356      }
1357  
1358      /*
1359       * Determines if we should change the touch state to start scrolling after the
1360       * user moves their touch point too far.
1361       */
1362      protected void determineScrollingStart(MotionEvent ev, float touchSlopScale) {
1363          // Disallow scrolling if we don&#x27;t have a valid pointer index
1364          final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1365          if (pointerIndex == -1) return;
1366  
1367          // Disallow scrolling if we started the gesture from outside the viewport
1368          final float x = ev.getX(pointerIndex);
1369          final float y = ev.getY(pointerIndex);
1370          if (!isTouchPointInViewportWithBuffer((int) x, (int) y)) return;
1371  
1372          // If we&#x27;re only allowing edge swipes, we break out early if the down event wasn&#x27;t
1373          // at the edge.
1374          if (mOnlyAllowEdgeSwipes &amp;&amp; !mDownEventOnEdge) return;
1375  
1376          final int xDiff = (int) Math.abs(x - mLastMotionX);
1377          final int yDiff = (int) Math.abs(y - mLastMotionY);
1378  
1379          final int touchSlop = Math.round(touchSlopScale * mTouchSlop);
1380          boolean xPaged = xDiff &gt; mPagingTouchSlop;
1381          boolean xMoved = xDiff &gt; touchSlop;
1382          boolean yMoved = yDiff &gt; touchSlop;
1383  
1384          if (xMoved || xPaged || yMoved) {
1385              if (mUsePagingTouchSlop ? xPaged : xMoved) {
1386                  // Scroll if the user moved far enough along the X axis
1387                  mTouchState = TOUCH_STATE_SCROLLING;
1388                  mTotalMotionX += Math.abs(mLastMotionX - x);
1389                  mLastMotionX = x;
1390                  mLastMotionXRemainder = 0;
1391                  mTouchX = getViewportOffsetX() + getScrollX();
1392                  mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1393                  pageBeginMoving();
1394              }
1395          }
1396      }
1397  
1398      protected float getMaxScrollProgress() {
1399          return 1.0f;
1400      }
1401  
1402      protected void cancelCurrentPageLongPress() {
1403          if (mAllowLongPress) {
1404              //mAllowLongPress = false;
1405              // Try canceling the long press. It could also have been scheduled
1406              // by a distant descendant, so use the mAllowLongPress flag to block
1407              // everything
1408              final View currentPage = getPageAt(mCurrentPage);
1409              if (currentPage != null) {
1410                  currentPage.cancelLongPress();
1411              }
1412          }
1413      }
1414  
1415      protected float getBoundedScrollProgress(int screenCenter, View v, int page) {
1416          final int halfScreenSize = getViewportWidth() / 2;
1417  
1418          screenCenter = Math.min(getScrollX() + halfScreenSize, screenCenter);
1419          screenCenter = Math.max(halfScreenSize,  screenCenter);
1420  
1421          return getScrollProgress(screenCenter, v, page);
1422      }
1423  
1424      protected float getScrollProgress(int screenCenter, View v, int page) {
1425          final int halfScreenSize = getViewportWidth() / 2;
1426  
1427          int totalDistance = getScaledMeasuredWidth(v) + mPageSpacing;

1428          int delta = screenCenter - (getChildOffset(page) -
1429                  getRelativeChildOffset(page) + halfScreenSize);
1430  
1431          float scrollProgress = delta / (totalDistance * 1.0f);
1432          scrollProgress = Math.min(scrollProgress, getMaxScrollProgress());
1433          scrollProgress = Math.max(scrollProgress, - getMaxScrollProgress());
1434          return scrollProgress;
1435      }
1436  
1437      // This curve determines how the effect of scrolling over the limits of the page dimishes
1438      // as the user pulls further and further from the bounds
1439      private float overScrollInfluenceCurve(float f) {
1440          f -= 1.0f;
1441          return f * f * f + 1.0f;
1442      }
1443  
1444      protected void acceleratedOverScroll(float amount) {
1445          int screenSize = getViewportWidth();
1446  
1447          // We want to reach the max over scroll effect when the user has
1448          // over scrolled half the size of the screen
1449          float f = OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
1450  
1451          if (f == 0) return;
1452  
1453          // Clamp this factor, f, to -1 &lt; f &lt; 1
1454          if (Math.abs(f) &gt;= 1) {
1455              f /= Math.abs(f);
1456          }
1457  
1458          int overScrollAmount = (int) Math.round(f * screenSize);
1459          if (amount &lt; 0) {
1460              mOverScrollX = overScrollAmount;
1461              super.scrollTo(0, getScrollY());
1462          } else {
1463              mOverScrollX = mMaxScrollX + overScrollAmount;
1464              super.scrollTo(mMaxScrollX, getScrollY());
1465          }
1466          invalidate();
1467      }
1468  
1469      protected void dampedOverScroll(float amount) {
1470          int screenSize = getViewportWidth();
1471  
1472          float f = (amount / screenSize);
1473  
1474          if (f == 0) return;
1475          f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1476  
1477          // Clamp this factor, f, to -1 &lt; f &lt; 1
1478          if (Math.abs(f) &gt;= 1) {
1479              f /= Math.abs(f);
1480          }
1481  
1482          int overScrollAmount = (int) Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
1483          if (amount &lt; 0) {
1484              mOverScrollX = overScrollAmount;
1485              super.scrollTo(0, getScrollY());
1486          } else {
1487              mOverScrollX = mMaxScrollX + overScrollAmount;
1488              super.scrollTo(mMaxScrollX, getScrollY());
1489          }
1490          invalidate();
1491      }
1492  
1493      protected void overScroll(float amount) {
1494          dampedOverScroll(amount);
1495      }
1496  
1497      protected float maxOverScroll() {
1498          // Using the formula in overScroll, assuming that f = 1.0 (which it should generally not
1499          // exceed). Used to find out how much extra wallpaper we need for the over scroll effect
1500          float f = 1.0f;
1501          f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1502          return OVERSCROLL_DAMP_FACTOR * f;
1503      }
1504  
1505      @Override
1506      public boolean onTouchEvent(MotionEvent ev) {
1507          if (DISABLE_TOUCH_INTERACTION) {
1508              return false;
1509          }
1510  
1511          // Skip touch handling if there are no pages to swipe
1512          if (getChildCount() &lt;= 0) return super.onTouchEvent(ev);
1513  
1514          acquireVelocityTrackerAndAddMovement(ev);
1515  
1516          final int action = ev.getAction();
1517  
1518          switch (action &amp; MotionEvent.ACTION_MASK) {
1519          case MotionEvent.ACTION_DOWN:
1520              /*
1521               * If being flinged and user touches, stop the fling. isFinished
1522               * will be false if being flinged.
1523               */
1524              if (!mScroller.isFinished()) {
1525                  mScroller.abortAnimation();
1526              }
1527  
1528              // Remember where the motion event started
1529              mDownMotionX = mLastMotionX = ev.getX();
1530              mDownMotionY = mLastMotionY = ev.getY();
1531              mDownScrollX = getScrollX();
1532              float[] p = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1533              mParentDownMotionX = p[0];
1534              mParentDownMotionY = p[1];
1535              mLastMotionXRemainder = 0;
1536              mTotalMotionX = 0;
1537              mActivePointerId = ev.getPointerId(0);
1538  
1539              // Determine if the down event is within the threshold to be an edge swipe
1540              int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1541              int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1542              if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1543                  mDownEventOnEdge = true;
1544              }
1545  
1546              if (mTouchState == TOUCH_STATE_SCROLLING) {
1547                  pageBeginMoving();
1548              }
1549              break;
1550  
1551          case MotionEvent.ACTION_MOVE:
1552              if (mTouchState == TOUCH_STATE_SCROLLING) {
1553                  // Scroll to follow the motion event
1554                  final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1555  
1556                  if (pointerIndex == -1) return true;
1557  
1558                  final float x = ev.getX(pointerIndex);
1559                  final float deltaX = mLastMotionX + mLastMotionXRemainder - x;
1560  
1561                  mTotalMotionX += Math.abs(deltaX);
1562  
1563                  // Only scroll and update mLastMotionX if we have moved some discrete amount.  We
1564                  // keep the remainder because we are actually testing if we&#x27;ve moved from the last
1565                  // scrolled position (which is discrete).
1566                  if (Math.abs(deltaX) &gt;= 1.0f) {
1567                      mTouchX += deltaX;
1568                      mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1569                      if (!mDeferScrollUpdate) {
1570                          scrollBy((int) deltaX, 0);
1571                          if (DEBUG) Log.d(TAG, &quot;onTouchEvent().Scrolling: &quot; + deltaX);
1572                      } else {
1573                          invalidate();
1574                      }
1575                      mLastMotionX = x;
1576                      mLastMotionXRemainder = deltaX - (int) deltaX;
1577                  } else {
1578                      awakenScrollBars();
1579                  }
1580              } else if (mTouchState == TOUCH_STATE_REORDERING) {
1581                  // Update the last motion position
1582                  mLastMotionX = ev.getX();
1583                  mLastMotionY = ev.getY();
1584  
1585                  // Update the parent down so that our zoom animations take this new movement into
1586                  // account
1587                  float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1588                  mParentDownMotionX = pt[0];
1589                  mParentDownMotionY = pt[1];
1590                  updateDragViewTranslationDuringDrag();
1591  
1592                  // Find the closest page to the touch point
1593                  final int dragViewIndex = indexOfChild(mDragView);
1594                  int bufferSize = (int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE *
1595                      getViewportWidth());
1596                  int leftBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.left, 0)[0]
1597                          + bufferSize);
1598                  int rightBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.right, 0)[0]
1599                          - bufferSize);
1600  
1601                  // Change the drag view if we are hovering over the drop target
1602                  boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(
1603                          (int) mParentDownMotionX, (int) mParentDownMotionY);
1604                  setPageHoveringOverDeleteDropTarget(dragViewIndex, isHoveringOverDelete);
1605  
1606                  if (DEBUG) Log.d(TAG, &quot;leftBufferEdge: &quot; + leftBufferEdge);
1607                  if (DEBUG) Log.d(TAG, &quot;rightBufferEdge: &quot; + rightBufferEdge);
1608                  if (DEBUG) Log.d(TAG, &quot;mLastMotionX: &quot; + mLastMotionX);
1609                  if (DEBUG) Log.d(TAG, &quot;mLastMotionY: &quot; + mLastMotionY);
1610                  if (DEBUG) Log.d(TAG, &quot;mParentDownMotionX: &quot; + mParentDownMotionX);
1611                  if (DEBUG) Log.d(TAG, &quot;mParentDownMotionY: &quot; + mParentDownMotionY);
1612  
1613                  float parentX = mParentDownMotionX;
1614                  int pageIndexToSnapTo = -1;
1615                  if (parentX &lt; leftBufferEdge &amp;&amp; dragViewIndex &gt; 0) {
1616                      pageIndexToSnapTo = dragViewIndex - 1;
1617                  } else if (parentX &gt; rightBufferEdge &amp;&amp; dragViewIndex &lt; getChildCount() - 1) {
1618                      pageIndexToSnapTo = dragViewIndex + 1;
1619                  }
1620  
1621                  final int pageUnderPointIndex = pageIndexToSnapTo;
1622                  if (pageUnderPointIndex &gt; -1 &amp;&amp; !isHoveringOverDelete) {
1623                      mTempVisiblePagesRange[0] = 0;
1624                      mTempVisiblePagesRange[1] = getPageCount() - 1;
1625                      boundByReorderablePages(true, mTempVisiblePagesRange);
1626                      if (mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex &amp;&amp;
1627                              pageUnderPointIndex &lt;= mTempVisiblePagesRange[1] &amp;&amp;
1628                              pageUnderPointIndex != mSidePageHoverIndex &amp;&amp; mScroller.isFinished()) {
1629                          mSidePageHoverIndex = pageUnderPointIndex;
1630                          mSidePageHoverRunnable = new Runnable() {
1631                              @Override
1632                              public void run() {
1633                                  // Update the down scroll position to account for the fact that the
1634                                  // current page is moved
1635                                  mDownScrollX = getChildOffset(pageUnderPointIndex)
1636                                          - getRelativeChildOffset(pageUnderPointIndex);
1637  
1638                                  // Setup the scroll to the correct page before we swap the views
1639                                  snapToPage(pageUnderPointIndex);
1640  
1641                                  // For each of the pages between the paged view and the drag view,
1642                                  // animate them from the previous position to the new position in
1643                                  // the layout (as a result of the drag view moving in the layout)
1644                                  int shiftDelta = (dragViewIndex &lt; pageUnderPointIndex) ? -1 : 1;
1645                                  int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ?
1646                                          dragViewIndex + 1 : pageUnderPointIndex;
1647                                  int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ?
1648                                          dragViewIndex - 1 : pageUnderPointIndex;
1649                                  for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
1650                                      View v = getChildAt(i);
1651                                      // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
1652                                      // drag view all subsequent views to pageUnderPointIndex will
1653                                      // shift down.
1654                                      int oldX = getViewportOffsetX() + getChildOffset(i);
1655                                      int newX = getViewportOffsetX() + getChildOffset(i + shiftDelta);
1656  
1657                                      // Animate the view translation from its old position to its new
1658                                      // position
1659                                      AnimatorSet anim = (AnimatorSet) v.getTag(ANIM_TAG_KEY);
1660                                      if (anim != null) {
1661                                          anim.cancel();
1662                                      }
1663  
1664                                      v.setTranslationX(oldX - newX);
1665                                      anim = new AnimatorSet();
1666                                      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
1667                                      anim.playTogether(
1668                                              ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f));
1669                                      anim.start();
1670                                      v.setTag(anim);
1671                                  }
1672  
1673                                  removeView(mDragView);
1674                                  onRemoveView(mDragView, false);
1675                                  addView(mDragView, pageUnderPointIndex);
1676                                  onAddView(mDragView, pageUnderPointIndex);
1677                                  mSidePageHoverIndex = -1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1678 +                                mPageIndicator.setActiveMarker(getNextPage());</span>
1679                              }
1680                          };
1681                          postDelayed(mSidePageHoverRunnable, REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
1682                      }
1683                  } else {
1684                      removeCallbacks(mSidePageHoverRunnable);
1685                      mSidePageHoverIndex = -1;
1686                  }
1687              } else {
1688                  determineScrollingStart(ev);
1689              }
1690              break;
1691  
1692          case MotionEvent.ACTION_UP:
1693              if (mTouchState == TOUCH_STATE_SCROLLING) {
1694                  final int activePointerId = mActivePointerId;
1695                  final int pointerIndex = ev.findPointerIndex(activePointerId);
1696                  final float x = ev.getX(pointerIndex);
1697                  final VelocityTracker velocityTracker = mVelocityTracker;
1698                  velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
1699                  int velocityX = (int) velocityTracker.getXVelocity(activePointerId);
1700                  final int deltaX = (int) (x - mDownMotionX);
1701                  final int pageWidth = getScaledMeasuredWidth(getPageAt(mCurrentPage));

1702                  boolean isSignificantMove = Math.abs(deltaX) &gt; pageWidth *
1703                          SIGNIFICANT_MOVE_THRESHOLD;
1704  
1705                  mTotalMotionX += Math.abs(mLastMotionX + mLastMotionXRemainder - x);
1706  
1707                  boolean isFling = mTotalMotionX &gt; MIN_LENGTH_FOR_FLING &amp;&amp;
1708                          Math.abs(velocityX) &gt; mFlingThresholdVelocity;
1709  
1710                  // In the case that the page is moved far to one direction and then is flung
1711                  // in the opposite direction, we use a threshold to determine whether we should
1712                  // just return to the starting page, or if we should skip one further.
1713                  boolean returnToOriginalPage = false;
1714                  if (Math.abs(deltaX) &gt; pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD &amp;&amp;
1715                          Math.signum(velocityX) != Math.signum(deltaX) &amp;&amp; isFling) {
1716                      returnToOriginalPage = true;
1717                  }
1718  
1719                  int finalPage;
1720                  // We give flings precedence over large moves, which is why we short-circuit our
1721                  // test for a large move if a fling has been registered. That is, a large
1722                  // move to the left and fling to the right will register as a fling to the right.
1723                  final boolean isRtl = isLayoutRtl();
1724                  boolean isDeltaXLeft = isRtl ? deltaX &gt; 0 : deltaX &lt; 0;
1725                  boolean isVelocityXLeft = isRtl ? velocityX &gt; 0 : velocityX &lt; 0;
1726                  if (((isSignificantMove &amp;&amp; !isDeltaXLeft &amp;&amp; !isFling) ||
1727                          (isFling &amp;&amp; !isVelocityXLeft)) &amp;&amp; mCurrentPage &gt; 0) {
1728                      finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
1729                      snapToPageWithVelocity(finalPage, velocityX);
1730                  } else if (((isSignificantMove &amp;&amp; isDeltaXLeft &amp;&amp; !isFling) ||
1731                          (isFling &amp;&amp; isVelocityXLeft)) &amp;&amp;
1732                          mCurrentPage &lt; getChildCount() - 1) {
1733                      finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
1734                      snapToPageWithVelocity(finalPage, velocityX);
1735                  } else {
1736                      snapToDestination();
1737                  }            } else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
1738                  // at this point we have not moved beyond the touch slop
1739                  // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1740                  // we can just page
1741                  int nextPage = Math.max(0, mCurrentPage - 1);
1742                  if (nextPage != mCurrentPage) {
1743                      snapToPage(nextPage);
1744                  } else {
1745                      snapToDestination();
1746                  }
1747              } else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
1748                  // at this point we have not moved beyond the touch slop
1749                  // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1750                  // we can just page
1751                  int nextPage = Math.min(getChildCount() - 1, mCurrentPage + 1);
1752                  if (nextPage != mCurrentPage) {
1753                      snapToPage(nextPage);
1754                  } else {
1755                      snapToDestination();
1756                  }
1757              } else if (mTouchState == TOUCH_STATE_REORDERING) {
1758                  // Update the last motion position
1759                  mLastMotionX = ev.getX();
1760                  mLastMotionY = ev.getY();
1761  
1762                  // Update the parent down so that our zoom animations take this new movement into
1763                  // account
1764                  float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1765                  mParentDownMotionX = pt[0];
1766                  mParentDownMotionY = pt[1];
1767                  updateDragViewTranslationDuringDrag();
1768                  boolean handledFling = false;
1769                  if (!DISABLE_FLING_TO_DELETE) {
1770                      // Check the velocity and see if we are flinging-to-delete
1771                      PointF flingToDeleteVector = isFlingingToDelete();
1772                      if (flingToDeleteVector != null) {
1773                          onFlingToDelete(flingToDeleteVector);
1774                          handledFling = true;
1775                      }
1776                  }
1777                  if (!handledFling &amp;&amp; isHoveringOverDeleteDropTarget((int) mParentDownMotionX,
1778                          (int) mParentDownMotionY)) {
1779                      onDropToDelete();
1780                  }
1781              } else {
1782                  onUnhandledTap(ev);
1783              }
1784  
1785              // Remove the callback to wait for the side page hover timeout
1786              removeCallbacks(mSidePageHoverRunnable);
1787              // End any intermediate reordering states
1788              resetTouchState();
1789              break;
1790  
1791          case MotionEvent.ACTION_CANCEL:
1792              if (mTouchState == TOUCH_STATE_SCROLLING) {
1793                  snapToDestination();
1794              }
1795              resetTouchState();
1796              break;
1797  
1798          case MotionEvent.ACTION_POINTER_UP:
1799              onSecondaryPointerUp(ev);
1800              break;
1801          }
1802  
1803          return true;
1804      }
1805  
1806      public void onFlingToDelete(View v) {}
1807      public void onRemoveView(View v, boolean deletePermanently) {}
1808      public void onRemoveViewAnimationCompleted() {}
1809      public void onAddView(View v, int index) {}
1810  
1811      private void resetTouchState() {
1812          releaseVelocityTracker();
1813          endReordering();
1814          mTouchState = TOUCH_STATE_REST;
1815          mActivePointerId = INVALID_POINTER;
1816          mDownEventOnEdge = false;
1817      }
1818  
1819      protected void onUnhandledTap(MotionEvent ev) {}
1820  
1821      @Override
1822      public boolean onGenericMotionEvent(MotionEvent event) {
1823          if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
1824              switch (event.getAction()) {
1825                  case MotionEvent.ACTION_SCROLL: {
1826                      // Handle mouse (or ext. device) by shifting the page depending on the scroll
1827                      final float vscroll;
1828                      final float hscroll;
1829                      if ((event.getMetaState() &amp; KeyEvent.META_SHIFT_ON) != 0) {
1830                          vscroll = 0;
1831                          hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1832                      } else {
1833                          vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1834                          hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
1835                      }
1836                      if (hscroll != 0 || vscroll != 0) {
1837                          boolean isForwardScroll = isLayoutRtl() ? (hscroll &lt; 0 || vscroll &lt; 0)
1838                                                           : (hscroll &gt; 0 || vscroll &gt; 0);
1839                          if (isForwardScroll) {
1840                              scrollRight();
1841                          } else {
1842                              scrollLeft();
1843                          }
1844                          return true;
1845                      }
1846                  }
1847              }
1848          }
1849          return super.onGenericMotionEvent(event);
1850      }
1851  
1852      private void acquireVelocityTrackerAndAddMovement(MotionEvent ev) {
1853          if (mVelocityTracker == null) {
1854              mVelocityTracker = VelocityTracker.obtain();
1855          }
1856          mVelocityTracker.addMovement(ev);
1857      }
1858  
1859      private void releaseVelocityTracker() {
1860          if (mVelocityTracker != null) {
1861              mVelocityTracker.recycle();
1862              mVelocityTracker = null;
1863          }
1864      }
1865  
1866      private void onSecondaryPointerUp(MotionEvent ev) {
1867          final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;
1868                  MotionEvent.ACTION_POINTER_INDEX_SHIFT;
1869          final int pointerId = ev.getPointerId(pointerIndex);
1870          if (pointerId == mActivePointerId) {
1871              // This was our active pointer going up. Choose a new
1872              // active pointer and adjust accordingly.
1873              // TODO: Make this decision more intelligent.
1874              final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
1875              mLastMotionX = mDownMotionX = ev.getX(newPointerIndex);
1876              mLastMotionY = ev.getY(newPointerIndex);
1877              mLastMotionXRemainder = 0;
1878              mActivePointerId = ev.getPointerId(newPointerIndex);
1879              if (mVelocityTracker != null) {
1880                  mVelocityTracker.clear();
1881              }
1882          }
1883      }
1884  
1885      @Override
1886      public void requestChildFocus(View child, View focused) {
1887          super.requestChildFocus(child, focused);
1888          int page = indexToPage(indexOfChild(child));
1889          if (page &gt;= 0 &amp;&amp; page != getCurrentPage() &amp;&amp; !isInTouchMode()) {
1890              snapToPage(page);
1891          }
1892      }
1893  
1894      protected int getChildIndexForRelativeOffset(int relativeOffset) {
1895          final boolean isRtl = isLayoutRtl();
1896          final int childCount = getChildCount();
1897          int left;
1898          int right;
1899          final int startIndex = isRtl ? childCount - 1 : 0;
1900          final int endIndex = isRtl ? -1 : childCount;
1901          final int delta = isRtl ? -1 : 1;
1902          for (int i = startIndex; i != endIndex; i += delta) {
1903              left = getRelativeChildOffset(i);
1904              right = (left + getScaledMeasuredWidth(getPageAt(i)));
1905              if (left &lt;= relativeOffset &amp;&amp; relativeOffset &lt;= right) {
1906                  return i;
1907              }
1908          }
1909          return -1;
1910      }
1911  
1912      protected int getChildWidth(int index) {
1913          // This functions are called enough times that it actually makes a difference in the
1914          // profiler -- so just inline the max() here
1915          final int measuredWidth = getPageAt(index).getMeasuredWidth();
1916          final int minWidth = mMinimumWidth;
1917          return (minWidth &gt; measuredWidth) ? minWidth : measuredWidth;

1918      }
1919  
1920      int getPageNearestToPoint(float x) {
1921          int index = 0;
1922          for (int i = 0; i &lt; getChildCount(); ++i) {
1923              if (x &lt; getChildAt(i).getRight() - getScrollX()) {
1924                  return index;
1925              } else {
1926                  index++;
1927              }
1928          }
1929          return Math.min(index, getChildCount() - 1);
1930      }
1931  
1932      int getPageNearestToCenterOfScreen() {
1933          int minDistanceFromScreenCenter = Integer.MAX_VALUE;
1934          int minDistanceFromScreenCenterIndex = -1;
1935          int screenCenter = getViewportOffsetX() + getScrollX() + (getViewportWidth() / 2);
1936          final int childCount = getChildCount();
1937          for (int i = 0; i &lt; childCount; ++i) {
1938              View layout = (View) getPageAt(i);
1939              int childWidth = getScaledMeasuredWidth(layout);

1940              int halfChildWidth = (childWidth / 2);
1941              int childCenter = getViewportOffsetX() + getChildOffset(i) + halfChildWidth;
1942              int distanceFromScreenCenter = Math.abs(childCenter - screenCenter);
1943              if (distanceFromScreenCenter &lt; minDistanceFromScreenCenter) {
1944                  minDistanceFromScreenCenter = distanceFromScreenCenter;
1945                  minDistanceFromScreenCenterIndex = i;
1946              }
1947          }
1948          return minDistanceFromScreenCenterIndex;
1949      }
1950  
1951      protected void snapToDestination() {
1952          snapToPage(getPageNearestToCenterOfScreen(), PAGE_SNAP_ANIMATION_DURATION);
1953      }
1954  
1955      private static class ScrollInterpolator implements Interpolator {
1956          public ScrollInterpolator() {
1957          }
1958  
1959          public float getInterpolation(float t) {
1960              t -= 1.0f;
1961              return t*t*t*t*t + 1;
1962          }
1963      }
1964  
1965      // We want the duration of the page snap animation to be influenced by the distance that
1966      // the screen has to travel, however, we don&#x27;t want this duration to be effected in a
1967      // purely linear fashion. Instead, we use this method to moderate the effect that the distance
1968      // of travel has on the overall snap duration.
1969      float distanceInfluenceForSnapDuration(float f) {
1970          f -= 0.5f; // center the values about 0.
1971          f *= 0.3f * Math.PI / 2.0f;
1972          return (float) Math.sin(f);
1973      }
1974  
1975      protected void snapToPageWithVelocity(int whichPage, int velocity) {
1976          whichPage = Math.max(0, Math.min(whichPage, getChildCount() - 1));
1977          int halfScreenSize = getViewportWidth() / 2;
1978  
1979          if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
1980          if (DEBUG) Log.d(TAG, &quot;snapToPageWithVelocity.getRelativeChildOffset(): &quot;
1981                  + getViewportWidth() + &quot;, &quot; + getChildWidth(whichPage));
1982          final int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
1983          int delta = newX - mUnboundedScrollX;
1984          int duration = 0;
1985  
1986          if (Math.abs(velocity) &lt; mMinFlingVelocity) {
1987              // If the velocity is low enough, then treat this more as an automatic page advance
1988              // as opposed to an apparent physical response to flinging
1989              snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
1990              return;
1991          }
1992  
1993          // Here we compute a &quot;distance&quot; that will be used in the computation of the overall
1994          // snap duration. This is a function of the actual distance that needs to be traveled;
1995          // we keep this value close to half screen size in order to reduce the variance in snap
1996          // duration as a function of the distance the page needs to travel.
1997          float distanceRatio = Math.min(1f, 1.0f * Math.abs(delta) / (2 * halfScreenSize));
1998          float distance = halfScreenSize + halfScreenSize *
1999                  distanceInfluenceForSnapDuration(distanceRatio);
2000  
2001          velocity = Math.abs(velocity);
2002          velocity = Math.max(mMinSnapVelocity, velocity);
2003  
2004          // we want the page&#x27;s snap velocity to approximately match the velocity at which the
2005          // user flings, so we scale the duration by a value near to the derivative of the scroll
2006          // interpolator at zero, ie. 5. We use 4 to make it a little slower.
2007          duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
2008  
2009          snapToPage(whichPage, delta, duration);
2010      }
2011  
2012      protected void snapToPage(int whichPage) {
2013          snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2014      }
2015  
2016      protected void snapToPageImmediately(int whichPage) {
2017          snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION, true);
2018      }
2019  
2020      protected void snapToPage(int whichPage, int duration) {
2021          snapToPage(whichPage, duration, false);
2022      }
2023  
2024      protected void snapToPage(int whichPage, int duration, boolean immediate) {
2025          whichPage = Math.max(0, Math.min(whichPage, getPageCount() - 1));
2026  
2027          if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2028          if (DEBUG) Log.d(TAG, &quot;snapToPage.getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
2029                  + getChildWidth(whichPage));
2030          int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2031          final int sX = mUnboundedScrollX;
2032          final int delta = newX - sX;
2033          snapToPage(whichPage, delta, duration, immediate);
2034      }
2035  
2036      protected void snapToPage(int whichPage, int delta, int duration) {
2037          snapToPage(whichPage, delta, duration, false);
2038      }
2039  
2040      protected void snapToPage(int whichPage, int delta, int duration, boolean immediate) {
2041          mNextPage = whichPage;
2042          View focusedChild = getFocusedChild();
2043          if (focusedChild != null &amp;&amp; whichPage != mCurrentPage &amp;&amp;
2044                  focusedChild == getPageAt(mCurrentPage)) {
2045              focusedChild.clearFocus();
2046          }
2047  
2048          pageBeginMoving();
2049          awakenScrollBars(duration);
2050          if (immediate) {
2051              duration = 0;
2052          } else if (duration == 0) {
2053              duration = Math.abs(delta);
2054          }
2055  
2056          if (!mScroller.isFinished()) mScroller.abortAnimation();
2057          mScroller.startScroll(mUnboundedScrollX, 0, delta, 0, duration);
2058  
2059          notifyPageSwitchListener();
2060  
2061          // Trigger a compute() to finish switching pages if necessary
2062          if (immediate) {
2063              computeScroll();
2064          }
2065  
2066          mForceScreenScrolled = true;
2067          invalidate();
2068      }
2069  
2070      public void scrollLeft() {
2071          if (mScroller.isFinished()) {
2072              if (mCurrentPage &gt; 0) snapToPage(mCurrentPage - 1);
2073          } else {
2074              if (mNextPage &gt; 0) snapToPage(mNextPage - 1);
2075          }
2076      }
2077  
2078      public void scrollRight() {
2079          if (mScroller.isFinished()) {
2080              if (mCurrentPage &lt; getChildCount() -1) snapToPage(mCurrentPage + 1);
2081          } else {
2082              if (mNextPage &lt; getChildCount() -1) snapToPage(mNextPage + 1);
2083          }
2084      }
2085  
2086      public int getPageForView(View v) {
2087          int result = -1;
2088          if (v != null) {
2089              ViewParent vp = v.getParent();
2090              int count = getChildCount();
2091              for (int i = 0; i &lt; count; i++) {
2092                  if (vp == getPageAt(i)) {
2093                      return i;
2094                  }
2095              }
2096          }
2097          return result;
2098      }
2099  
2100      /**
2101       * @return True is long presses are still allowed for the current touch
2102       */
2103      public boolean allowLongPress() {
2104          return mAllowLongPress;
2105      }
2106  
2107      /**
2108       * Set true to allow long-press events to be triggered, usually checked by
2109       * {@link Launcher} to accept or block dpad-initiated long-presses.
2110       */
2111      public void setAllowLongPress(boolean allowLongPress) {
2112          mAllowLongPress = allowLongPress;
2113      }
2114  
2115      public static class SavedState extends BaseSavedState {
2116          int currentPage = -1;
2117  
2118          SavedState(Parcelable superState) {
2119              super(superState);
2120          }
2121  
2122          private SavedState(Parcel in) {
2123              super(in);
2124              currentPage = in.readInt();
2125          }
2126  
2127          @Override
2128          public void writeToParcel(Parcel out, int flags) {
2129              super.writeToParcel(out, flags);
2130              out.writeInt(currentPage);
2131          }
2132  
2133          public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
2134                  new Parcelable.Creator&lt;SavedState&gt;() {
2135              public SavedState createFromParcel(Parcel in) {
2136                  return new SavedState(in);
2137              }
2138  
2139              public SavedState[] newArray(int size) {
2140                  return new SavedState[size];
2141              }
2142          };
2143      }
2144  
2145      protected void loadAssociatedPages(int page) {
2146          loadAssociatedPages(page, false);
2147      }
2148      protected void loadAssociatedPages(int page, boolean immediateAndOnly) {
2149          if (mContentIsRefreshable) {
2150              final int count = getChildCount();
2151              if (page &lt; count) {
2152                  int lowerPageBound = getAssociatedLowerPageBound(page);
2153                  int upperPageBound = getAssociatedUpperPageBound(page);
2154                  if (DEBUG) Log.d(TAG, &quot;loadAssociatedPages: &quot; + lowerPageBound + &quot;/&quot;
2155                          + upperPageBound);
2156                  // First, clear any pages that should no longer be loaded
2157                  for (int i = 0; i &lt; count; ++i) {
2158                      Page layout = (Page) getPageAt(i);
2159                      if ((i &lt; lowerPageBound) || (i &gt; upperPageBound)) {
2160                          if (layout.getPageChildCount() &gt; 0) {
2161                              layout.removeAllViewsOnPage();
2162                          }
2163                          mDirtyPageContent.set(i, true);
2164                      }
2165                  }
2166                  // Next, load any new pages
2167                  for (int i = 0; i &lt; count; ++i) {
2168                      if ((i != page) &amp;&amp; immediateAndOnly) {
2169                          continue;
2170                      }
2171                      if (lowerPageBound &lt;= i &amp;&amp; i &lt;= upperPageBound) {
2172                          if (mDirtyPageContent.get(i)) {
2173                              syncPageItems(i, (i == page) &amp;&amp; immediateAndOnly);
2174                              mDirtyPageContent.set(i, false);
2175                          }
2176                      }
2177                  }
2178              }
2179          }
2180      }
2181  
2182      protected int getAssociatedLowerPageBound(int page) {
2183          return Math.max(0, page - 1);
2184      }
2185      protected int getAssociatedUpperPageBound(int page) {
2186          final int count = getChildCount();
2187          return Math.min(page + 1, count - 1);
2188      }
2189  
2190      /**
2191       * This method is called ONLY to synchronize the number of pages that the paged view has.
2192       * To actually fill the pages with information, implement syncPageItems() below.  It is
2193       * guaranteed that syncPageItems() will be called for a particular page before it is shown,
2194       * and therefore, individual page items do not need to be updated in this method.
2195       */
2196      public abstract void syncPages();
2197  
2198      /**
2199       * This method is called to synchronize the items that are on a particular page.  If views on
2200       * the page can be reused, then they should be updated within this method.
2201       */
2202      public abstract void syncPageItems(int page, boolean immediate);
2203  
2204      protected void invalidatePageData() {
2205          invalidatePageData(-1, false);
2206      }
2207      protected void invalidatePageData(int currentPage) {
2208          invalidatePageData(currentPage, false);
2209      }
2210      protected void invalidatePageData(int currentPage, boolean immediateAndOnly) {
2211          if (!mIsDataReady) {
2212              return;
2213          }
2214  
2215          if (mContentIsRefreshable) {
2216              // Force all scrolling-related behavior to end
2217              mScroller.forceFinished(true);
2218              mNextPage = INVALID_PAGE;
2219  
2220              // Update all the pages
2221              syncPages();
2222  
2223              // We must force a measure after we&#x27;ve loaded the pages to update the content width and
2224              // to determine the full scroll width
2225              measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
2226                      MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
2227  
2228              // Set a new page as the current page if necessary
2229              if (currentPage &gt; -1) {
2230                  setCurrentPage(Math.min(getPageCount() - 1, currentPage));
2231              }
2232  
2233              // Mark each of the pages as dirty
2234              final int count = getChildCount();
2235              mDirtyPageContent.clear();
2236              for (int i = 0; i &lt; count; ++i) {
2237                  mDirtyPageContent.add(true);
2238              }
2239  
2240              // Load any pages that are necessary for the current window of views
2241              loadAssociatedPages(mCurrentPage, immediateAndOnly);
2242              requestLayout();
2243          }
2244      }
2245  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2246 -    protected View getScrollingIndicator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2247 -        // We use mHasScrollIndicator to prevent future lookups if there is no sibling indicator</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2248 -        // found</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2249 -        if (mHasScrollIndicator &amp;&amp; mScrollIndicator == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2250 -            ViewGroup parent = (ViewGroup) getParent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2251 -            if (parent != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2252 -                mScrollIndicator = (View) (parent.findViewById(R.id.paged_view_indicator));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2253 -                mHasScrollIndicator = mScrollIndicator != null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2254 -                if (mHasScrollIndicator) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2255 -                    mScrollIndicator.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2256 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2257 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2258 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2259 -        return mScrollIndicator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2260 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2261 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2262 -    protected boolean isScrollingIndicatorEnabled() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2263 -        return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2264 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2265 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2266 -    Runnable hideScrollingIndicatorRunnable = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2267 -        @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2268 -        public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2269 -            hideScrollingIndicator(false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2270 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2271 -    };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2272 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2273 -    protected void flashScrollingIndicator(boolean animated) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2274 -        removeCallbacks(hideScrollingIndicatorRunnable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2275 -        showScrollingIndicator(!animated);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2276 -        postDelayed(hideScrollingIndicatorRunnable, sScrollIndicatorFlashDuration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2277 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2278 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2279 -    protected void showScrollingIndicator(boolean immediately) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2280 -        mShouldShowScrollIndicator = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2281 -        mShouldShowScrollIndicatorImmediately = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2282 -        if (getChildCount() &lt;= 1) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2283 -        if (!isScrollingIndicatorEnabled()) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2284 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2285 -        mShouldShowScrollIndicator = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2286 -        getScrollingIndicator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2287 -        if (mScrollIndicator != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2288 -            // Fade the indicator in</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2289 -            updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2290 -            mScrollIndicator.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2291 -            cancelScrollingIndicatorAnimations();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2292 -            if (immediately) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2293 -                mScrollIndicator.setAlpha(1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2294 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2295 -                mScrollIndicatorAnimator = ObjectAnimator.ofFloat(mScrollIndicator, &quot;alpha&quot;, 1f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2296 -                mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeInDuration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2297 -                mScrollIndicatorAnimator.start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2298 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2299 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2300 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2301 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2302 -    protected void cancelScrollingIndicatorAnimations() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2303 -        if (mScrollIndicatorAnimator != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2304 -            mScrollIndicatorAnimator.cancel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2305 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2306 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2307 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2308 -    protected void hideScrollingIndicator(boolean immediately) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2309 -        if (getChildCount() &lt;= 1) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2310 -        if (!isScrollingIndicatorEnabled()) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2311 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2312 -        getScrollingIndicator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2313 -        if (mScrollIndicator != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2314 -            // Fade the indicator out</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2315 -            updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2316 -            cancelScrollingIndicatorAnimations();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2317 -            if (immediately) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2318 -                mScrollIndicator.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2319 -                mScrollIndicator.setAlpha(0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2320 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2321 -                mScrollIndicatorAnimator = ObjectAnimator.ofFloat(mScrollIndicator, &quot;alpha&quot;, 0f);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2322 -                mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeOutDuration);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2323 -                mScrollIndicatorAnimator.addListener(new AnimatorListenerAdapter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2324 -                    private boolean cancelled = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2325 -                    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2326 -                    public void onAnimationCancel(android.animation.Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2327 -                        cancelled = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2328 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2329 -                    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2330 -                    public void onAnimationEnd(Animator animation) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2331 -                        if (!cancelled) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2332 -                            mScrollIndicator.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2333 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2334 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2335 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2336 -                mScrollIndicatorAnimator.start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2337 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2338 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2339 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2340 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2341 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2342 -     * To be overridden by subclasses to determine whether the scroll indicator should stretch to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2343 -     * fill its space on the track or not.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2344 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2345 -    protected boolean hasElasticScrollIndicator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2346 -        return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2347 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2348 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2349 -    private void updateScrollingIndicator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2350 -        if (getChildCount() &lt;= 1) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2351 -        if (!isScrollingIndicatorEnabled()) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2352 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2353 -        getScrollingIndicator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2354 -        if (mScrollIndicator != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2355 -            updateScrollingIndicatorPosition();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2356 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2357 -        if (mShouldShowScrollIndicator) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2358 -            showScrollingIndicator(mShouldShowScrollIndicatorImmediately);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2359 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2360 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2361 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2362 -    private void updateScrollingIndicatorPosition() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2363 -        final boolean isRtl = isLayoutRtl();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2364 -        if (!isScrollingIndicatorEnabled()) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2365 -        if (mScrollIndicator == null) return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2366 -        int numPages = getChildCount();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2367 -        int pageWidth = getViewportWidth();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2368 -        int lastChildIndex = Math.max(0, getChildCount() - 1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2369 -        int maxScrollX = getChildOffset(lastChildIndex) - getRelativeChildOffset(lastChildIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2370 -        int trackWidth = pageWidth - mScrollIndicatorPaddingLeft - mScrollIndicatorPaddingRight;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2371 -        int indicatorWidth = mScrollIndicator.getMeasuredWidth() -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2372 -                mScrollIndicator.getPaddingLeft() - mScrollIndicator.getPaddingRight();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2373 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2374 -        float scrollPos = isRtl ? mMaxScrollX - getScrollX() : getScrollX();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2375 -        float offset = Math.max(0f, Math.min(1f, (float) scrollPos / mMaxScrollX));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2376 -        if (isRtl) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2377 -            offset = 1f - offset;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2378 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2379 -        int indicatorSpace = trackWidth / numPages;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2380 -        int indicatorPos = (int) (offset * (trackWidth - indicatorSpace)) + mScrollIndicatorPaddingLeft;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2381 -        if (hasElasticScrollIndicator()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2382 -            if (mScrollIndicator.getMeasuredWidth() != indicatorSpace) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2383 -                mScrollIndicator.getLayoutParams().width = indicatorSpace;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2384 -                mScrollIndicator.requestLayout();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2385 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2386 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2387 -            int indicatorCenterOffset = indicatorSpace / 2 - indicatorWidth / 2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2388 -            indicatorPos += indicatorCenterOffset;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2389 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2390 -        mScrollIndicator.setTranslationX(indicatorPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2391 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2392 -</span>
2393      // Animate the drag view back to the original position
2394      void animateDragViewToOriginalPosition() {
2395          if (mDragView != null) {
2396              AnimatorSet anim = new AnimatorSet();
2397              anim.setDuration(REORDERING_DROP_REPOSITION_DURATION);
2398              anim.playTogether(
2399                      ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0f),
2400                      ObjectAnimator.ofFloat(mDragView, &quot;translationY&quot;, 0f));
2401              anim.addListener(new AnimatorListenerAdapter() {
2402                  @Override
2403                  public void onAnimationEnd(Animator animation) {
2404                      onPostReorderingAnimationCompleted();
2405                  }
2406              });
2407              anim.start();
2408          }
2409      }
2410  
2411      // &quot;Zooms out&quot; the PagedView to reveal more side pages
2412      protected boolean zoomOut() {
2413          if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2414              mZoomInOutAnim.cancel();
2415          }
2416  
2417          if (!(getScaleX() &lt; 1f || getScaleY() &lt; 1f)) {
2418              mZoomInOutAnim = new AnimatorSet();
2419              mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2420              mZoomInOutAnim.playTogether(
2421                      ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, mMinScale),
2422                      ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, mMinScale));
2423              mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2424                  @Override
2425                  public void onAnimationStart(Animator animation) {
2426                      // Show the delete drop target
2427                      if (mDeleteDropTarget != null) {
2428                          mDeleteDropTarget.setVisibility(View.VISIBLE);
2429                          mDeleteDropTarget.animate().alpha(1f)
2430                              .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2431                              .setListener(new AnimatorListenerAdapter() {
2432                                  @Override
2433                                  public void onAnimationStart(Animator animation) {
2434                                      mDeleteDropTarget.setAlpha(0f);
2435                                  }
2436                              });
2437                      }
2438                  }
2439              });
2440              mZoomInOutAnim.start();
2441              return true;
2442          }
2443          return false;
2444      }
2445  
2446      protected void onStartReordering() {
2447          // Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)
2448          mTouchState = TOUCH_STATE_REORDERING;
2449          mIsReordering = true;
2450  
2451          // Mark all the non-widget pages as invisible
2452          getVisiblePages(mTempVisiblePagesRange);
2453          boundByReorderablePages(true, mTempVisiblePagesRange);
2454          for (int i = 0; i &lt; getPageCount(); ++i) {
2455              if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2456                  getPageAt(i).setAlpha(0f);
2457              }
2458          }
2459  
2460          // We must invalidate to trigger a redraw to update the layers such that the drag view
2461          // is always drawn on top
2462          invalidate();
2463      }
2464  
2465      private void onPostReorderingAnimationCompleted() {
2466          // Trigger the callback when reordering has settled
2467          --mPostReorderingPreZoomInRemainingAnimationCount;
2468          if (mPostReorderingPreZoomInRunnable != null &amp;&amp;
2469                  mPostReorderingPreZoomInRemainingAnimationCount == 0) {
2470              mPostReorderingPreZoomInRunnable.run();
2471              mPostReorderingPreZoomInRunnable = null;
2472          }
2473      }
2474  
2475      protected void onEndReordering() {
2476          mIsReordering = false;
2477  
2478          // Mark all the non-widget pages as visible again
2479          getVisiblePages(mTempVisiblePagesRange);
2480          boundByReorderablePages(true, mTempVisiblePagesRange);
2481          for (int i = 0; i &lt; getPageCount(); ++i) {
2482              if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2483                  getPageAt(i).setAlpha(1f);
2484              }
2485          }
2486      }
2487  
2488      public boolean startReordering() {
2489          int dragViewIndex = getPageNearestToCenterOfScreen();
2490          mTempVisiblePagesRange[0] = 0;
2491          mTempVisiblePagesRange[1] = getPageCount() - 1;
2492          boundByReorderablePages(true, mTempVisiblePagesRange);
2493          mReorderingStarted = true;
2494  
2495          // Check if we are within the reordering range
2496          if (mTempVisiblePagesRange[0] &lt;= dragViewIndex &amp;&amp;
2497                  dragViewIndex &lt;= mTempVisiblePagesRange[1]) {
2498              if (zoomOut()) {
2499                  // Find the drag view under the pointer
2500                  mDragView = getChildAt(dragViewIndex);
2501  
2502                  onStartReordering();
2503              }
2504              return true;
2505          }
2506          return false;
2507      }
2508  
2509      boolean isReordering(boolean testTouchState) {
2510          boolean state = mIsReordering;
2511          if (testTouchState) {
2512              state &amp;= (mTouchState == TOUCH_STATE_REORDERING);
2513          }
2514          return state;
2515      }
2516      void endReordering() {
2517          // For simplicity, we call endReordering sometimes even if reordering was never started.
2518          // In that case, we don&#x27;t want to do anything.
2519          if (!mReorderingStarted) return;
2520          mReorderingStarted = false;
2521  
2522          // If we haven&#x27;t flung-to-delete the current child, then we just animate the drag view
2523          // back into position
2524          final Runnable onCompleteRunnable = new Runnable() {
2525              @Override
2526              public void run() {
2527                  onEndReordering();
2528              }
2529          };
2530          if (!mDeferringForDelete) {
2531              mPostReorderingPreZoomInRunnable = new Runnable() {
2532                  public void run() {
2533                      zoomIn(onCompleteRunnable);
2534                  };
2535              };
2536  
2537              mPostReorderingPreZoomInRemainingAnimationCount =
2538                      NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT;
2539              // Snap to the current page
2540              snapToPage(indexOfChild(mDragView), 0);
2541              // Animate the drag view back to the front position
2542              animateDragViewToOriginalPosition();
2543          } else {
2544              // Handled in post-delete-animation-callbacks
2545          }
2546      }
2547  
2548      // &quot;Zooms in&quot; the PagedView to highlight the current page
2549      protected boolean zoomIn(final Runnable onCompleteRunnable) {
2550          if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2551              mZoomInOutAnim.cancel();
2552          }
2553          if (getScaleX() &lt; 1f || getScaleY() &lt; 1f) {
2554              mZoomInOutAnim = new AnimatorSet();
2555              mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2556              mZoomInOutAnim.playTogether(
2557                      ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 1f),
2558                      ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, 1f));
2559              mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2560                  @Override
2561                  public void onAnimationStart(Animator animation) {
2562                      // Hide the delete drop target
2563                      if (mDeleteDropTarget != null) {
2564                          mDeleteDropTarget.animate().alpha(0f)
2565                              .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2566                              .setListener(new AnimatorListenerAdapter() {
2567                                  @Override
2568                                  public void onAnimationEnd(Animator animation) {
2569                                      mDeleteDropTarget.setVisibility(View.GONE);
2570                                  }
2571                              });
2572                      }
2573                  }
2574                  @Override
2575                  public void onAnimationCancel(Animator animation) {
2576                      mDragView = null;
2577                  }
2578                  @Override
2579                  public void onAnimationEnd(Animator animation) {
2580                      mDragView = null;
2581                      if (onCompleteRunnable != null) {
2582                          onCompleteRunnable.run();
2583                      }
2584                  }
2585              });
2586              mZoomInOutAnim.start();
2587              return true;
2588          } else {
2589              if (onCompleteRunnable != null) {
2590                  onCompleteRunnable.run();
2591              }
2592          }
2593          return false;
2594      }
2595  
2596      /*
2597       * Flinging to delete - IN PROGRESS
2598       */
2599      private PointF isFlingingToDelete() {
2600          ViewConfiguration config = ViewConfiguration.get(getContext());
2601          mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());
2602  
2603          if (mVelocityTracker.getYVelocity() &lt; mFlingToDeleteThresholdVelocity) {
2604              // Do a quick dot product test to ensure that we are flinging upwards
2605              PointF vel = new PointF(mVelocityTracker.getXVelocity(),
2606                      mVelocityTracker.getYVelocity());
2607              PointF upVec = new PointF(0f, -1f);
2608              float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) /
2609                      (vel.length() * upVec.length()));
2610              if (theta &lt;= Math.toRadians(FLING_TO_DELETE_MAX_FLING_DEGREES)) {
2611                  return vel;
2612              }
2613          }
2614          return null;
2615      }
2616  
2617      /**
2618       * Creates an animation from the current drag view along its current velocity vector.
2619       * For this animation, the alpha runs for a fixed duration and we update the position
2620       * progressively.
2621       */
2622      private static class FlingAlongVectorAnimatorUpdateListener implements AnimatorUpdateListener {
2623          private View mDragView;
2624          private PointF mVelocity;
2625          private Rect mFrom;
2626          private long mPrevTime;
2627          private float mFriction;
2628  
2629          private final TimeInterpolator mAlphaInterpolator = new DecelerateInterpolator(0.75f);
2630  
2631          public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from,
2632                  long startTime, float friction) {
2633              mDragView = dragView;
2634              mVelocity = vel;
2635              mFrom = from;
2636              mPrevTime = startTime;
2637              mFriction = 1f - (mDragView.getResources().getDisplayMetrics().density * friction);
2638          }
2639  
2640          @Override
2641          public void onAnimationUpdate(ValueAnimator animation) {
2642              float t = ((Float) animation.getAnimatedValue()).floatValue();
2643              long curTime = AnimationUtils.currentAnimationTimeMillis();
2644  
2645              mFrom.left += (mVelocity.x * (curTime - mPrevTime) / 1000f);
2646              mFrom.top += (mVelocity.y * (curTime - mPrevTime) / 1000f);
2647  
2648              mDragView.setTranslationX(mFrom.left);
2649              mDragView.setTranslationY(mFrom.top);
2650              mDragView.setAlpha(1f - mAlphaInterpolator.getInterpolation(t));
2651  
2652              mVelocity.x *= mFriction;
2653              mVelocity.y *= mFriction;
2654              mPrevTime = curTime;
2655          }
2656      };
2657  
2658      private static final int ANIM_TAG_KEY = 100;
2659  
2660      private Runnable createPostDeleteAnimationRunnable(final View dragView) {
2661          return new Runnable() {
2662              @Override
2663              public void run() {
2664                  int dragViewIndex = indexOfChild(dragView);
2665  
2666                  // For each of the pages around the drag view, animate them from the previous
2667                  // position to the new position in the layout (as a result of the drag view moving
2668                  // in the layout)
2669                  // NOTE: We can make an assumption here because we have side-bound pages that we
2670                  //       will always have pages to animate in from the left
2671                  getVisiblePages(mTempVisiblePagesRange);
2672                  boundByReorderablePages(true, mTempVisiblePagesRange);
2673                  boolean isLastWidgetPage = (mTempVisiblePagesRange[0] == mTempVisiblePagesRange[1]);
2674                  boolean slideFromLeft = (isLastWidgetPage ||
2675                          dragViewIndex &gt; mTempVisiblePagesRange[0]);
2676  
2677                  // Setup the scroll to the correct page before we swap the views
2678                  if (slideFromLeft) {
2679                      snapToPageImmediately(dragViewIndex - 1);
2680                  }
2681  
2682                  int firstIndex = (isLastWidgetPage ? 0 : mTempVisiblePagesRange[0]);
2683                  int lastIndex = Math.min(mTempVisiblePagesRange[1], getPageCount() - 1);
2684                  int lowerIndex = (slideFromLeft ? firstIndex : dragViewIndex + 1 );
2685                  int upperIndex = (slideFromLeft ? dragViewIndex - 1 : lastIndex);
2686                  ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2687                  for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
2688                      View v = getChildAt(i);
2689                      // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
2690                      // drag view all subsequent views to pageUnderPointIndex will
2691                      // shift down.
2692                      int oldX = 0;
2693                      int newX = 0;
2694                      if (slideFromLeft) {
2695                          if (i == 0) {
2696                              // Simulate the page being offscreen with the page spacing
2697                              oldX = getViewportOffsetX() + getChildOffset(i) - getChildWidth(i)
2698                                      - mPageSpacing;
2699                          } else {
2700                              oldX = getViewportOffsetX() + getChildOffset(i - 1);
2701                          }
2702                          newX = getViewportOffsetX() + getChildOffset(i);
2703                      } else {
2704                          oldX = getChildOffset(i) - getChildOffset(i - 1);
2705                          newX = 0;
2706                      }
2707  
2708                      // Animate the view translation from its old position to its new
2709                      // position
2710                      AnimatorSet anim = (AnimatorSet) v.getTag();
2711                      if (anim != null) {
2712                          anim.cancel();
2713                      }
2714  
2715                      // Note: Hacky, but we want to skip any optimizations to not draw completely
2716                      // hidden views
2717                      v.setAlpha(Math.max(v.getAlpha(), 0.01f));
2718                      v.setTranslationX(oldX - newX);
2719                      anim = new AnimatorSet();
2720                      anim.playTogether(
2721                              ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f),
2722                              ObjectAnimator.ofFloat(v, &quot;alpha&quot;, 1f));
2723                      animations.add(anim);
2724                      v.setTag(ANIM_TAG_KEY, anim);
2725                  }
2726  
2727                  AnimatorSet slideAnimations = new AnimatorSet();
2728                  slideAnimations.playTogether(animations);
2729                  slideAnimations.setDuration(DELETE_SLIDE_IN_SIDE_PAGE_DURATION);
2730                  slideAnimations.addListener(new AnimatorListenerAdapter() {
2731                      @Override
2732                      public void onAnimationEnd(Animator animation) {
2733                          final Runnable onCompleteRunnable = new Runnable() {
2734                              @Override
2735                              public void run() {
2736                                  mDeferringForDelete = false;
2737                                  onEndReordering();
2738                                  onRemoveViewAnimationCompleted();
2739                              }
2740                          };
2741                          zoomIn(onCompleteRunnable);
2742                      }
2743                  });
2744                  slideAnimations.start();
2745  
2746                  removeView(dragView);
2747                  onRemoveView(dragView, true);
2748              }
2749          };
2750      }
2751  
2752      public void onFlingToDelete(PointF vel) {
2753          final long startTime = AnimationUtils.currentAnimationTimeMillis();
2754  
2755          // NOTE: Because it takes time for the first frame of animation to actually be
2756          // called and we expect the animation to be a continuation of the fling, we have
2757          // to account for the time that has elapsed since the fling finished.  And since
2758          // we don&#x27;t have a startDelay, we will always get call to update when we call
2759          // start() (which we want to ignore).
2760          final TimeInterpolator tInterpolator = new TimeInterpolator() {
2761              private int mCount = -1;
2762              private long mStartTime;
2763              private float mOffset;
2764              /* Anonymous inner class ctor */ {
2765                  mStartTime = startTime;
2766              }
2767  
2768              @Override
2769              public float getInterpolation(float t) {
2770                  if (mCount &lt; 0) {
2771                      mCount++;
2772                  } else if (mCount == 0) {
2773                      mOffset = Math.min(0.5f, (float) (AnimationUtils.currentAnimationTimeMillis() -
2774                              mStartTime) / FLING_TO_DELETE_FADE_OUT_DURATION);
2775                      mCount++;
2776                  }
2777                  return Math.min(1f, mOffset + t);
2778              }
2779          };
2780  
2781          final Rect from = new Rect();
2782          final View dragView = mDragView;
2783          from.left = (int) dragView.getTranslationX();
2784          from.top = (int) dragView.getTranslationY();
2785          AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel,
2786                  from, startTime, FLING_TO_DELETE_FRICTION);
2787  
2788          final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2789  
2790          // Create and start the animation
2791          ValueAnimator mDropAnim = new ValueAnimator();
2792          mDropAnim.setInterpolator(tInterpolator);
2793          mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
2794          mDropAnim.setFloatValues(0f, 1f);
2795          mDropAnim.addUpdateListener(updateCb);
2796          mDropAnim.addListener(new AnimatorListenerAdapter() {
2797              public void onAnimationEnd(Animator animation) {
2798                  onAnimationEndRunnable.run();
2799              }
2800          });
2801          mDropAnim.start();
2802          mDeferringForDelete = true;
2803      }
2804  
2805      /* Drag to delete */
2806      private boolean isHoveringOverDeleteDropTarget(int x, int y) {
2807          if (mDeleteDropTarget != null) {
2808              mAltTmpRect.set(0, 0, 0, 0);
2809              View parent = (View) mDeleteDropTarget.getParent();
2810              if (parent != null) {
2811                  parent.getGlobalVisibleRect(mAltTmpRect);
2812              }
2813              mDeleteDropTarget.getGlobalVisibleRect(mTmpRect);
2814              mTmpRect.offset(-mAltTmpRect.left, -mAltTmpRect.top);
2815              return mTmpRect.contains(x, y);
2816          }
2817          return false;
2818      }
2819  
2820      protected void setPageHoveringOverDeleteDropTarget(int viewIndex, boolean isHovering) {}
2821  
2822      private void onDropToDelete() {
2823          final View dragView = mDragView;
2824  
2825          final float toScale = 0f;
2826          final float toAlpha = 0f;
2827  
2828          // Create and start the complex animation
2829          ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2830          AnimatorSet motionAnim = new AnimatorSet();
2831          motionAnim.setInterpolator(new DecelerateInterpolator(2));
2832          motionAnim.playTogether(
2833                  ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale),
2834                  ObjectAnimator.ofFloat(dragView, &quot;scaleY&quot;, toScale));
2835          animations.add(motionAnim);
2836  
2837          AnimatorSet alphaAnim = new AnimatorSet();
2838          alphaAnim.setInterpolator(new LinearInterpolator());
2839          alphaAnim.playTogether(
2840                  ObjectAnimator.ofFloat(dragView, &quot;alpha&quot;, toAlpha));
2841          animations.add(alphaAnim);
2842  
2843          final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2844  
2845          AnimatorSet anim = new AnimatorSet();
2846          anim.playTogether(animations);
2847          anim.setDuration(DRAG_TO_DELETE_FADE_OUT_DURATION);
2848          anim.addListener(new AnimatorListenerAdapter() {
2849              public void onAnimationEnd(Animator animation) {
2850                  onAnimationEndRunnable.run();
2851              }
2852          });
2853          anim.start();
2854  
2855          mDeferringForDelete = true;
2856      }
2857  
2858      /* Accessibility */
2859      @Override
2860      public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
2861          super.onInitializeAccessibilityNodeInfo(info);
2862          info.setScrollable(getPageCount() &gt; 1);
2863          if (getCurrentPage() &lt; getPageCount() - 1) {
2864              info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
2865          }
2866          if (getCurrentPage() &gt; 0) {
2867              info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
2868          }
2869      }
2870  
2871      @Override
2872      public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
2873          super.onInitializeAccessibilityEvent(event);
2874          event.setScrollable(true);
2875          if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
2876              event.setFromIndex(mCurrentPage);
2877              event.setToIndex(mCurrentPage);
2878              event.setItemCount(getChildCount());
2879          }
2880      }
2881  
2882      @Override
2883      public boolean performAccessibilityAction(int action, Bundle arguments) {
2884          if (super.performAccessibilityAction(action, arguments)) {
2885              return true;
2886          }
2887          switch (action) {
2888              case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
2889                  if (getCurrentPage() &lt; getPageCount() - 1) {
2890                      scrollRight();
2891                      return true;
2892                  }
2893              } break;
2894              case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
2895                  if (getCurrentPage() &gt; 0) {
2896                      scrollLeft();
2897                      return true;
2898                  }
2899              } break;
2900          }
2901          return false;
2902      }
2903  
2904      protected String getCurrentPageDescription() {
2905          return String.format(getContext().getString(R.string.default_scroll_format),
2906                  getNextPage() + 1, getChildCount());
2907      }
2908  
2909      @Override
2910      public boolean onHoverEvent(android.view.MotionEvent event) {
2911          return true;
2912      }
2913  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2012 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.animation.Animator;
  20  import android.animation.AnimatorListenerAdapter;
  21  import android.animation.AnimatorSet;
  22  import android.animation.ObjectAnimator;
  23  import android.animation.TimeInterpolator;
  24  import android.animation.ValueAnimator;
  25  import android.animation.ValueAnimator.AnimatorUpdateListener;
  26  import android.content.Context;
  27  import android.content.res.Resources;
  28  import android.content.res.TypedArray;
  29  import android.graphics.Canvas;
  30  import android.graphics.Matrix;
  31  import android.graphics.PointF;
  32  import android.graphics.Rect;
  33  import android.os.Bundle;
  34  import android.os.Parcel;
  35  import android.os.Parcelable;
  36  import android.util.AttributeSet;
  37  import android.util.DisplayMetrics;
  38  import android.util.Log;
  39  import android.view.InputDevice;
  40  import android.view.KeyEvent;
  41  import android.view.MotionEvent;
  42  import android.view.VelocityTracker;
  43  import android.view.View;
  44  import android.view.ViewConfiguration;
  45  import android.view.ViewGroup;
  46  import android.view.ViewParent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import android.view.ViewGroup.LayoutParams;</span>
  48  import android.view.accessibility.AccessibilityEvent;
  49  import android.view.accessibility.AccessibilityManager;
  50  import android.view.accessibility.AccessibilityNodeInfo;
  51  import android.view.animation.AnimationUtils;
  52  import android.view.animation.DecelerateInterpolator;
  53  import android.view.animation.Interpolator;
  54  import android.view.animation.LinearInterpolator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +import android.widget.FrameLayout;</span>
  56  import android.widget.Scroller;
  57  
  58  import java.util.ArrayList;
  59  
  60  /**
  61   * An abstraction of the original Workspace which supports browsing through a
  62   * sequential list of &quot;pages&quot;
  63   */
  64  public abstract class PagedView extends ViewGroup implements ViewGroup.OnHierarchyChangeListener {
  65      private static final String TAG = &quot;PagedView&quot;;
  66      private static final boolean DEBUG = false;
  67      protected static final int INVALID_PAGE = -1;
  68  
  69      // the min drag distance for a fling to register, to prevent random page shifts
  70      private static final int MIN_LENGTH_FOR_FLING = 25;
  71  
  72      protected static final int PAGE_SNAP_ANIMATION_DURATION = 750;
  73      protected static final int SLOW_PAGE_SNAP_ANIMATION_DURATION = 950;
  74      protected static final float NANOTIME_DIV = 1000000000.0f;
  75  
  76      private static final float OVERSCROLL_ACCELERATE_FACTOR = 2;
  77      private static final float OVERSCROLL_DAMP_FACTOR = 0.14f;
  78  
  79      private static final float RETURN_TO_ORIGINAL_PAGE_THRESHOLD = 0.33f;
  80      // The page is moved more than halfway, automatically move to the next page on touch up.
  81      private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
  82  
  83      // The following constants need to be scaled based on density. The scaled versions will be
  84      // assigned to the corresponding member variables below.
  85      private static final int FLING_THRESHOLD_VELOCITY = 500;
  86      private static final int MIN_SNAP_VELOCITY = 1500;
  87      private static final int MIN_FLING_VELOCITY = 250;
  88  
  89      // We are disabling touch interaction of the widget region for factory ROM.
  90      private static final boolean DISABLE_TOUCH_INTERACTION = false;
  91      private static final boolean DISABLE_TOUCH_SIDE_PAGES = false;
  92      private static final boolean DISABLE_FLING_TO_DELETE = true;
  93  
  94      static final int AUTOMATIC_PAGE_SPACING = -1;
  95  
  96      protected int mFlingThresholdVelocity;
  97      protected int mMinFlingVelocity;
  98      protected int mMinSnapVelocity;
  99  
 100      protected float mDensity;
 101      protected float mSmoothingTime;
 102      protected float mTouchX;
 103  
 104      protected boolean mFirstLayout = true;
 105  
 106      protected int mCurrentPage;
 107      protected int mChildCountOnLastMeasure;
 108  
 109      protected int mNextPage = INVALID_PAGE;
 110      protected int mMaxScrollX;
 111      protected Scroller mScroller;
 112      private VelocityTracker mVelocityTracker;
 113  
 114      private float mParentDownMotionX;
 115      private float mParentDownMotionY;
 116      private float mDownMotionX;
 117      private float mDownMotionY;
 118      private float mDownScrollX;
 119      protected float mLastMotionX;
 120      protected float mLastMotionXRemainder;
 121      protected float mLastMotionY;
 122      protected float mTotalMotionX;
 123      private int mLastScreenCenter = -1;
 124      private int[] mChildOffsets;
 125      private int[] mChildRelativeOffsets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -    private int[] mChildOffsetsWithLayoutScale;</span>
 127  
 128      protected final static int TOUCH_STATE_REST = 0;
 129      protected final static int TOUCH_STATE_SCROLLING = 1;
 130      protected final static int TOUCH_STATE_PREV_PAGE = 2;
 131      protected final static int TOUCH_STATE_NEXT_PAGE = 3;
 132      protected final static int TOUCH_STATE_REORDERING = 4;
 133  
 134      protected final static float ALPHA_QUANTIZE_LEVEL = 0.0001f;
 135  
 136      protected int mTouchState = TOUCH_STATE_REST;
 137      protected boolean mForceScreenScrolled = false;
 138  
 139      protected OnLongClickListener mLongClickListener;
 140  
 141      protected int mTouchSlop;
 142      private int mPagingTouchSlop;
 143      private int mMaximumVelocity;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -    private int mMinimumWidth;</span>
 145      protected int mPageSpacing;
 146      protected int mPageLayoutPaddingTop;
 147      protected int mPageLayoutPaddingBottom;
 148      protected int mPageLayoutPaddingLeft;
 149      protected int mPageLayoutPaddingRight;
 150      protected int mPageLayoutWidthGap;
 151      protected int mPageLayoutHeightGap;
 152      protected int mCellCountX = 0;
 153      protected int mCellCountY = 0;
 154      protected boolean mCenterPagesVertically;
 155      protected boolean mAllowOverScroll = true;
 156      protected int mUnboundedScrollX;
 157      protected int[] mTempVisiblePagesRange = new int[2];
 158      protected boolean mForceDrawAllChildrenNextFrame;
 159  
 160      // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range. Otherwise
 161      // it is equal to the scaled overscroll position. We use a separate value so as to prevent
 162      // the screens from continuing to translate beyond the normal bounds.
 163      protected int mOverScrollX;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -    // parameter that adjusts the layout to be optimized for pages with that scale factor</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -    protected float mLayoutScale = 1.0f;</span>
 167  
 168      protected static final int INVALID_POINTER = -1;
 169  
 170      protected int mActivePointerId = INVALID_POINTER;
 171  
 172      private PageSwitchListener mPageSwitchListener;
 173  
 174      protected ArrayList&lt;Boolean&gt; mDirtyPageContent;
 175  
 176      // If true, syncPages and syncPageItems will be called to refresh pages
 177      protected boolean mContentIsRefreshable = true;
 178  
 179      // If true, modify alpha of neighboring pages as user scrolls left/right
 180      protected boolean mFadeInAdjacentScreens = false;
 181  
 182      // It true, use a different slop parameter (pagingTouchSlop = 2 * touchSlop) for deciding
 183      // to switch to a new page
 184      protected boolean mUsePagingTouchSlop = true;
 185  
 186      // If true, the subclass should directly update scrollX itself in its computeScroll method
 187      // (SmoothPagedView does this)
 188      protected boolean mDeferScrollUpdate = false;
 189  
 190      protected boolean mIsPageMoving = false;
 191  
 192      // All syncs and layout passes are deferred until data is ready.
 193      protected boolean mIsDataReady = false;
 194  
 195      protected boolean mAllowLongPress = true;
 196  
 197      // Scrolling indicator
 198      private ValueAnimator mScrollIndicatorAnimator;
 199      private View mScrollIndicator;
 200      private int mScrollIndicatorPaddingLeft;
 201      private int mScrollIndicatorPaddingRight;
 202      private boolean mHasScrollIndicator = true;
 203      private boolean mShouldShowScrollIndicator = false;
 204      private boolean mShouldShowScrollIndicatorImmediately = false;
 205      protected static final int sScrollIndicatorFadeInDuration = 150;
 206      protected static final int sScrollIndicatorFadeOutDuration = 650;
 207      protected static final int sScrollIndicatorFlashDuration = 650;
 208      private boolean mScrollingPaused = false;



 209  
 210      // The viewport whether the pages are to be contained (the actual view may be larger than the
 211      // viewport)
 212      private Rect mViewport = new Rect();
 213  
 214      // Reordering
 215      // We use the min scale to determine how much to expand the actually PagedView measured
 216      // dimensions such that when we are zoomed out, the view is not clipped
 217      private int REORDERING_DROP_REPOSITION_DURATION = 200;
 218      protected int REORDERING_REORDER_REPOSITION_DURATION = 300;
 219      protected int REORDERING_ZOOM_IN_OUT_DURATION = 250;
 220      private int REORDERING_SIDE_PAGE_HOVER_TIMEOUT = 300;
 221      private float REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE = 0.1f;
 222      private long REORDERING_DELETE_DROP_TARGET_FADE_DURATION = 150;
 223      private float mMinScale = 1f;
 224      protected View mDragView;
 225      protected AnimatorSet mZoomInOutAnim;
 226      private Runnable mSidePageHoverRunnable;
 227      private int mSidePageHoverIndex = -1;
 228      // This variable&#x27;s scope is only for the duration of startReordering() and endReordering()
 229      private boolean mReorderingStarted = false;
 230      // This variable&#x27;s scope is for the duration of startReordering() and after the zoomIn()
 231      // animation after endReordering()
 232      private boolean mIsReordering;
 233      // The runnable that settles the page after snapToPage and animateDragViewToOriginalPosition
 234      private int NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT = 2;
 235      private int mPostReorderingPreZoomInRemainingAnimationCount;
 236      private Runnable mPostReorderingPreZoomInRunnable;
 237  
 238      // Edge swiping
 239      private boolean mOnlyAllowEdgeSwipes = false;
 240      private boolean mDownEventOnEdge = false;
 241      private int mEdgeSwipeRegionSize = 0;
 242  
 243      // Convenience/caching
 244      private Matrix mTmpInvMatrix = new Matrix();
 245      private float[] mTmpPoint = new float[2];
 246      private Rect mTmpRect = new Rect();
 247      private Rect mAltTmpRect = new Rect();
 248  
 249      // Fling to delete
 250      private int FLING_TO_DELETE_FADE_OUT_DURATION = 350;
 251      private float FLING_TO_DELETE_FRICTION = 0.035f;
 252      // The degrees specifies how much deviation from the up vector to still consider a fling &quot;up&quot;
 253      private float FLING_TO_DELETE_MAX_FLING_DEGREES = 65f;
 254      protected int mFlingToDeleteThresholdVelocity = -1400;
 255      // Drag to delete
 256      private boolean mDeferringForDelete = false;
 257      private int DELETE_SLIDE_IN_SIDE_PAGE_DURATION = 250;
 258      private int DRAG_TO_DELETE_FADE_OUT_DURATION = 350;
 259  
 260      // Drop to delete
 261      private View mDeleteDropTarget;
 262  
 263      private boolean mAutoComputePageSpacing = false;
 264      private boolean mRecomputePageSpacing = false;
 265  
 266      // Bouncer
 267      private boolean mTopAlignPageWhenShrinkingForBouncer = false;
 268  
 269      public interface PageSwitchListener {
 270          void onPageSwitch(View newPage, int newPageIndex);
 271      }
 272  
 273      public PagedView(Context context) {
 274          this(context, null);
 275      }
 276  
 277      public PagedView(Context context, AttributeSet attrs) {
 278          this(context, attrs, 0);
 279      }
 280  
 281      public PagedView(Context context, AttributeSet attrs, int defStyle) {
 282          super(context, attrs, defStyle);
 283          TypedArray a = context.obtainStyledAttributes(attrs,
 284                  R.styleable.PagedView, defStyle, 0);
 285          setPageSpacing(a.getDimensionPixelSize(R.styleable.PagedView_pageSpacing, 0));
 286          if (mPageSpacing &lt; 0) {
 287              mAutoComputePageSpacing = mRecomputePageSpacing = true;
 288          }
 289          mPageLayoutPaddingTop = a.getDimensionPixelSize(
 290                  R.styleable.PagedView_pageLayoutPaddingTop, 0);
 291          mPageLayoutPaddingBottom = a.getDimensionPixelSize(
 292                  R.styleable.PagedView_pageLayoutPaddingBottom, 0);
 293          mPageLayoutPaddingLeft = a.getDimensionPixelSize(
 294                  R.styleable.PagedView_pageLayoutPaddingLeft, 0);
 295          mPageLayoutPaddingRight = a.getDimensionPixelSize(
 296                  R.styleable.PagedView_pageLayoutPaddingRight, 0);
 297          mPageLayoutWidthGap = a.getDimensionPixelSize(
 298                  R.styleable.PagedView_pageLayoutWidthGap, 0);
 299          mPageLayoutHeightGap = a.getDimensionPixelSize(
 300                  R.styleable.PagedView_pageLayoutHeightGap, 0);
 301          mScrollIndicatorPaddingLeft =
 302              a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingLeft, 0);
 303          mScrollIndicatorPaddingRight =
 304              a.getDimensionPixelSize(R.styleable.PagedView_scrollIndicatorPaddingRight, 0);

 305          a.recycle();
 306  
 307          setHapticFeedbackEnabled(false);
 308          init();
 309      }
 310  
 311      /**
 312       * Initializes various states for this workspace.
 313       */
 314      protected void init() {
 315          mDirtyPageContent = new ArrayList&lt;Boolean&gt;();
 316          mDirtyPageContent.ensureCapacity(32);
 317          mScroller = new Scroller(getContext(), new ScrollInterpolator());
 318          mCurrentPage = 0;
 319          mCenterPagesVertically = true;
 320  
 321          final ViewConfiguration configuration = ViewConfiguration.get(getContext());
 322          mTouchSlop = configuration.getScaledPagingTouchSlop();
 323          mPagingTouchSlop = configuration.getScaledPagingTouchSlop();
 324          mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
 325          mDensity = getResources().getDisplayMetrics().density;
 326  
 327          // Scale the fling-to-delete threshold by the density
 328          mFlingToDeleteThresholdVelocity =
 329                  (int) (mFlingToDeleteThresholdVelocity * mDensity);
 330  
 331          mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 332          mMinFlingVelocity = (int) (MIN_FLING_VELOCITY * mDensity);
 333          mMinSnapVelocity = (int) (MIN_SNAP_VELOCITY * mDensity);
 334          setOnHierarchyChangeListener(this);















 335      }
 336  
 337      void setDeleteDropTarget(View v) {
 338          mDeleteDropTarget = v;
 339      }
 340  
 341      // Convenience methods to map points from self to parent and vice versa
 342      float[] mapPointFromViewToParent(View v, float x, float y) {
 343          mTmpPoint[0] = x;
 344          mTmpPoint[1] = y;
 345          v.getMatrix().mapPoints(mTmpPoint);
 346          mTmpPoint[0] += v.getLeft();
 347          mTmpPoint[1] += v.getTop();
 348          return mTmpPoint;
 349      }
 350      float[] mapPointFromParentToView(View v, float x, float y) {
 351          mTmpPoint[0] = x - v.getLeft();
 352          mTmpPoint[1] = y - v.getTop();
 353          v.getMatrix().invert(mTmpInvMatrix);
 354          mTmpInvMatrix.mapPoints(mTmpPoint);
 355          return mTmpPoint;
 356      }
 357  
 358      void updateDragViewTranslationDuringDrag() {
 359          float x = mLastMotionX - mDownMotionX + getScrollX() - mDownScrollX;
 360          float y = mLastMotionY - mDownMotionY;
 361          mDragView.setTranslationX(x);
 362          mDragView.setTranslationY(y);
 363  
 364          if (DEBUG) Log.d(TAG, &quot;PagedView.updateDragViewTranslationDuringDrag(): &quot; + x + &quot;, &quot; + y);
 365      }
 366  
 367      public void setMinScale(float f) {
 368          mMinScale = f;
 369          requestLayout();
 370      }
 371  
 372      @Override
 373      public void setScaleX(float scaleX) {
 374          super.setScaleX(scaleX);
 375          if (isReordering(true)) {
 376              float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 377              mLastMotionX = p[0];
 378              mLastMotionY = p[1];
 379              updateDragViewTranslationDuringDrag();
 380          }
 381      }
 382  
 383      // Convenience methods to get the actual width/height of the PagedView (since it is measured
 384      // to be larger to account for the minimum possible scale)
 385      int getViewportWidth() {
 386          return mViewport.width();
 387      }
 388      int getViewportHeight() {
 389          return mViewport.height();
 390      }
 391  
 392      // Convenience methods to get the offset ASSUMING that we are centering the pages in the
 393      // PagedView both horizontally and vertically
 394      int getViewportOffsetX() {
 395          return (getMeasuredWidth() - getViewportWidth()) / 2;
 396      }
 397  
 398      int getViewportOffsetY() {
 399          return (getMeasuredHeight() - getViewportHeight()) / 2;
 400      }
 401  
 402      public void setPageSwitchListener(PageSwitchListener pageSwitchListener) {
 403          mPageSwitchListener = pageSwitchListener;
 404          if (mPageSwitchListener != null) {
 405              mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);
 406          }
 407      }
 408  
 409      /**
 410       * Note: this is a reimplementation of View.isLayoutRtl() since that is currently hidden api.
 411       */
 412      public boolean isLayoutRtl() {
 413          return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
 414      }
 415  
 416      /**
 417       * Called by subclasses to mark that data is ready, and that we can begin loading and laying
 418       * out pages.
 419       */
 420      protected void setDataIsReady() {
 421          mIsDataReady = true;
 422      }
 423  
 424      protected boolean isDataReady() {
 425          return mIsDataReady;
 426      }
 427  
 428      /**
 429       * Returns the index of the currently displayed page.
 430       *
 431       * @return The index of the currently displayed page.
 432       */
 433      int getCurrentPage() {
 434          return mCurrentPage;
 435      }
 436  
 437      int getNextPage() {
 438          return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
 439      }
 440  
 441      int getPageCount() {
 442          return getChildCount();
 443      }
 444  
 445      View getPageAt(int index) {
 446          return getChildAt(index);
 447      }
 448  
 449      protected int indexToPage(int index) {
 450          return index;
 451      }
 452  
 453      /**
 454       * Updates the scroll of the current page immediately to its final scroll position.  We use this
 455       * in CustomizePagedView to allow tabs to share the same PagedView while resetting the scroll of
 456       * the previous tab page.
 457       */
 458      protected void updateCurrentPageScroll() {
 459          // If the current page is invalid, just reset the scroll position to zero
 460          int newX = 0;
 461          if (0 &lt;= mCurrentPage &amp;&amp; mCurrentPage &lt; getPageCount()) {
 462              int offset = getChildOffset(mCurrentPage);
 463              int relOffset = getRelativeChildOffset(mCurrentPage);
 464              newX = offset - relOffset;
 465          }
 466          scrollTo(newX, 0);
 467          mScroller.setFinalX(newX);
 468          mScroller.forceFinished(true);
 469      }
 470  
 471      /**
 472       * Called during AllApps/Home transitions to avoid unnecessary work. When that other animation
 473       * ends, {@link #resumeScrolling()} should be called, along with
 474       * {@link #updateCurrentPageScroll()} to correctly set the final state and re-enable scrolling.
 475       */
 476      void pauseScrolling() {
 477          mScroller.forceFinished(true);
 478          cancelScrollingIndicatorAnimations();
 479          mScrollingPaused = true;
 480      }
 481  
 482      /**
 483       * Enables scrolling again.
 484       * @see #pauseScrolling()
 485       */
 486      void resumeScrolling() {
 487          mScrollingPaused = false;
 488      }
 489      /**
 490       * Sets the current page.
 491       */
 492      void setCurrentPage(int currentPage) {
 493          if (!mScroller.isFinished()) {
 494              mScroller.abortAnimation();
 495          }
 496          // don&#x27;t introduce any checks like mCurrentPage == currentPage here-- if we change the
 497          // the default
 498          if (getChildCount() == 0) {
 499              return;
 500          }
 501  
 502          mForceScreenScrolled = true;
 503          mCurrentPage = Math.max(0, Math.min(currentPage, getPageCount() - 1));
 504          updateCurrentPageScroll();
 505          updateScrollingIndicator();
 506          notifyPageSwitchListener();
 507          invalidate();
 508      }
 509  
 510      protected void notifyPageSwitchListener() {
 511          if (mPageSwitchListener != null) {
 512              mPageSwitchListener.onPageSwitch(getPageAt(mCurrentPage), mCurrentPage);





 513          }
 514      }
 515      protected void pageBeginMoving() {
 516          if (!mIsPageMoving) {
 517              mIsPageMoving = true;
 518              onPageBeginMoving();
 519          }
 520      }
 521  
 522      protected void pageEndMoving() {
 523          if (mIsPageMoving) {
 524              mIsPageMoving = false;
 525              onPageEndMoving();
 526          }
 527      }
 528  
 529      protected boolean isPageMoving() {
 530          return mIsPageMoving;
 531      }
 532  
 533      // a method that subclasses can override to add behavior
 534      protected void onPageBeginMoving() {
 535      }
 536  
 537      // a method that subclasses can override to add behavior
 538      protected void onPageEndMoving() {
 539      }
 540  
 541      /**
 542       * Registers the specified listener on each page contained in this workspace.
 543       *
 544       * @param l The listener used to respond to long clicks.
 545       */
 546      @Override
 547      public void setOnLongClickListener(OnLongClickListener l) {
 548          mLongClickListener = l;
 549          final int count = getPageCount();
 550          for (int i = 0; i &lt; count; i++) {
 551              getPageAt(i).setOnLongClickListener(l);
 552          }
 553      }
 554  
 555      @Override
 556      public void scrollBy(int x, int y) {
 557          scrollTo(mUnboundedScrollX + x, getScrollY() + y);
 558      }
 559  
 560      @Override
 561      public void scrollTo(int x, int y) {
 562          final boolean isRtl = isLayoutRtl();
 563          mUnboundedScrollX = x;
 564  
 565          boolean isXBeforeFirstPage = isRtl ? (x &gt; mMaxScrollX) : (x &lt; 0);
 566          boolean isXAfterLastPage = isRtl ? (x &lt; 0) : (x &gt; mMaxScrollX);
 567          if (isXBeforeFirstPage) {
 568              super.scrollTo(0, y);
 569              if (mAllowOverScroll) {
 570                  if (isRtl) {
 571                      overScroll(x - mMaxScrollX);
 572                  } else {
 573                      overScroll(x);
 574                  }
 575              }
 576          } else if (isXAfterLastPage) {
 577              super.scrollTo(mMaxScrollX, y);
 578              if (mAllowOverScroll) {
 579                  if (isRtl) {
 580                      overScroll(x);
 581                  } else {
 582                      overScroll(x - mMaxScrollX);
 583                  }
 584              }
 585          } else {
 586              mOverScrollX = x;
 587              super.scrollTo(x, y);
 588          }
 589  
 590          mTouchX = x;
 591          mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
 592  
 593          // Update the last motion events when scrolling
 594          if (isReordering(true)) {
 595              float[] p = mapPointFromParentToView(this, mParentDownMotionX, mParentDownMotionY);
 596              mLastMotionX = p[0];
 597              mLastMotionY = p[1];
 598              updateDragViewTranslationDuringDrag();
 599          }
 600      }
 601  
 602      // we moved this functionality to a helper function so SmoothPagedView can reuse it
 603      protected boolean computeScrollHelper() {
 604          if (mScroller.computeScrollOffset()) {
 605              // Don&#x27;t bother scrolling if the page does not need to be moved
 606              if (getScrollX() != mScroller.getCurrX()
 607                  || getScrollY() != mScroller.getCurrY()
 608                  || mOverScrollX != mScroller.getCurrX()) {
 609                  scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
 610              }
 611              invalidate();
 612              return true;
 613          } else if (mNextPage != INVALID_PAGE) {
 614              mCurrentPage = Math.max(0, Math.min(mNextPage, getPageCount() - 1));
 615              mNextPage = INVALID_PAGE;
 616              notifyPageSwitchListener();
 617  
 618              // We don&#x27;t want to trigger a page end moving unless the page has settled
 619              // and the user has stopped scrolling
 620              if (mTouchState == TOUCH_STATE_REST) {
 621                  pageEndMoving();
 622              }
 623  
 624              onPostReorderingAnimationCompleted();
 625              // Notify the user when the page changes
 626              AccessibilityManager accessibilityManager = (AccessibilityManager)
 627                      getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
 628              if (accessibilityManager.isEnabled()) {
 629                  AccessibilityEvent ev =
 630                      AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_SCROLLED);
 631                  ev.getText().add(getCurrentPageDescription());
 632                  sendAccessibilityEventUnchecked(ev);
 633              }
 634              return true;
 635          }
 636          return false;
 637      }
 638  
 639      @Override
 640      public void computeScroll() {
 641          computeScrollHelper();
 642      }
 643  
 644      protected boolean shouldSetTopAlignedPivotForWidget(int childIndex) {
 645          return mTopAlignPageWhenShrinkingForBouncer;
 646      }
 647  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +    public static class LayoutParams extends ViewGroup.LayoutParams {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +        public boolean isFullScreenPage = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +         * {@inheritDoc}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +        public LayoutParams(int width, int height) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +            super(width, height);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +        public LayoutParams(ViewGroup.LayoutParams source) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +            super(source);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +    protected LayoutParams generateDefaultLayoutParams() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +        return new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +    public void addFullScreenPage(View page, int width, int height) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +        LayoutParams lp = generateDefaultLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +        lp.isFullScreenPage = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +        super.addView(page, 0, lp);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +</span>
 673      @Override
 674      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 675          if (!mIsDataReady || getChildCount() == 0) {
 676              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 677              return;
 678          }
 679  
 680          // We measure the dimensions of the PagedView to be larger than the pages so that when we
 681          // zoom out (and scale down), the view is still contained in the parent
 682          int widthMode = MeasureSpec.getMode(widthMeasureSpec);
 683          int widthSize = MeasureSpec.getSize(widthMeasureSpec);
 684          int heightMode = MeasureSpec.getMode(heightMeasureSpec);
 685          int heightSize = MeasureSpec.getSize(heightMeasureSpec);
 686          // NOTE: We multiply by 1.5f to account for the fact that depending on the offset of the
 687          // viewport, we can be at most one and a half screens offset once we scale down
 688          DisplayMetrics dm = getResources().getDisplayMetrics();
 689          int maxSize = Math.max(dm.widthPixels, dm.heightPixels);
 690          int parentWidthSize = (int) (1.5f * maxSize);
 691          int parentHeightSize = maxSize;
 692          int scaledWidthSize = (int) (parentWidthSize / mMinScale);
 693          int scaledHeightSize = (int) (parentHeightSize / mMinScale);
 694          mViewport.set(0, 0, widthSize, heightSize);
 695  
 696          if (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED) {
 697              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 698              return;
 699          }
 700  
 701          // Return early if we aren&#x27;t given a proper dimension
 702          if (widthSize &lt;= 0 || heightSize &lt;= 0) {
 703              super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 704              return;
 705          }
 706  
 707          /* Allow the height to be set as WRAP_CONTENT. This allows the particular case
 708           * of the All apps view on XLarge displays to not take up more space then it needs. Width
 709           * is still not allowed to be set as WRAP_CONTENT since many parts of the code expect
 710           * each page to have the same width.
 711           */
 712          final int verticalPadding = getPaddingTop() + getPaddingBottom();
 713          final int horizontalPadding = getPaddingLeft() + getPaddingRight();
 714  
 715          // The children are given the same width and height as the workspace
 716          // unless they were set to WRAP_CONTENT
 717          if (DEBUG) Log.d(TAG, &quot;PagedView.onMeasure(): &quot; + widthSize + &quot;, &quot; + heightSize);
 718          if (DEBUG) Log.d(TAG, &quot;PagedView.scaledSize: &quot; + scaledWidthSize + &quot;, &quot; + scaledHeightSize);
 719          if (DEBUG) Log.d(TAG, &quot;PagedView.parentSize: &quot; + parentWidthSize + &quot;, &quot; + parentHeightSize);
 720          if (DEBUG) Log.d(TAG, &quot;PagedView.horizontalPadding: &quot; + horizontalPadding);
 721          if (DEBUG) Log.d(TAG, &quot;PagedView.verticalPadding: &quot; + verticalPadding);
 722          final int childCount = getChildCount();
 723          for (int i = 0; i &lt; childCount; i++) {
 724              // disallowing padding in paged view (just pass 0)
 725              final View child = getPageAt(i);
 726              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 727  
 728              int childWidthMode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 729 -            if (lp.width == LayoutParams.WRAP_CONTENT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 730 -                childWidthMode = MeasureSpec.AT_MOST;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 731 +            int childHeightMode;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 732 +            int childWidth;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 733 +            int childHeight;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 734 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 735 +            if (!lp.isFullScreenPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 736 +                if (lp.width == LayoutParams.WRAP_CONTENT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 737 +                    childWidthMode = MeasureSpec.AT_MOST;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 738 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 739 +                    childWidthMode = MeasureSpec.EXACTLY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 740 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 741 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 742 +                if (lp.height == LayoutParams.WRAP_CONTENT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 743 +                    childHeightMode = MeasureSpec.AT_MOST;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 744 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 745 +                    childHeightMode = MeasureSpec.EXACTLY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 746 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 747 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 748 +                childWidth = widthSize - horizontalPadding;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +                childHeight = heightSize - verticalPadding;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +</span>
 751              } else {
 752                  childWidthMode = MeasureSpec.EXACTLY;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 753 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 754 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 755 -            int childHeightMode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 756 -            if (lp.height == LayoutParams.WRAP_CONTENT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 757 -                childHeightMode = MeasureSpec.AT_MOST;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 758 -            } else {</span>
 759                  childHeightMode = MeasureSpec.EXACTLY;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 760 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 761 +                childWidth = getViewportWidth();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 762 +                childHeight = getViewportHeight();</span>
 763              }
 764  
 765              final int childWidthMeasureSpec =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 766 -                MeasureSpec.makeMeasureSpec(widthSize - horizontalPadding, childWidthMode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 767 -            final int childHeightMeasureSpec =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 768 -                MeasureSpec.makeMeasureSpec(heightSize - verticalPadding, childHeightMode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 769 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 770 +                    MeasureSpec.makeMeasureSpec(childWidth, childWidthMode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 771 +                final int childHeightMeasureSpec =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 772 +                    MeasureSpec.makeMeasureSpec(childHeight, childHeightMode);</span>
 773              child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 774          }
 775          setMeasuredDimension(scaledWidthSize, scaledHeightSize);
 776  
 777          // We can&#x27;t call getChildOffset/getRelativeChildOffset until we set the measured dimensions.
 778          // We also wait until we set the measured dimensions before flushing the cache as well, to
 779          // ensure that the cache is filled with good values.
 780          invalidateCachedOffsets();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 782 -        if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 783 -                !mDeferringForDelete) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 784 -            setCurrentPage(getNextPage());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 785 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 786 -        mChildCountOnLastMeasure = getChildCount();</span>
 787  
 788          if (childCount &gt; 0) {
 789              if (DEBUG) Log.d(TAG, &quot;getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
 790                      + getChildWidth(0));
 791  
 792              // Calculate the variable page spacing if necessary
 793              if (mAutoComputePageSpacing &amp;&amp; mRecomputePageSpacing) {
 794                  // The gap between pages in the PagedView should be equal to the gap from the page
 795                  // to the edge of the screen (so it is not visible in the current screen).  To
 796                  // account for unequal padding on each side of the paged view, we take the maximum
 797                  // of the left/right gap and use that as the gap between each page.
 798                  int offset = getRelativeChildOffset(0);
 799                  int spacing = Math.max(offset, widthSize - offset -
 800                          getChildAt(0).getMeasuredWidth());
 801                  setPageSpacing(spacing);
 802                  mRecomputePageSpacing = false;
 803              }
 804          }
 805  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +        if (mScroller.isFinished() &amp;&amp; mChildCountOnLastMeasure != getChildCount() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +                !mDeferringForDelete) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +            setCurrentPage(getNextPage());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 809 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 810 +        mChildCountOnLastMeasure = getChildCount();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 811 +</span>
 812          updateScrollingIndicatorPosition();
 813  
 814          if (childCount &gt; 0) {
 815              final int index = isLayoutRtl() ? 0 : childCount - 1;
 816              mMaxScrollX = getChildOffset(index) - getRelativeChildOffset(index);
 817          } else {
 818              mMaxScrollX = 0;
 819          }
 820      }
 821  
 822      public void setPageSpacing(int pageSpacing) {
 823          mPageSpacing = pageSpacing;
 824          invalidateCachedOffsets();
 825      }
 826  
 827      @Override
 828      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 829          if (!mIsDataReady || getChildCount() == 0) {
 830              return;
 831          }
 832  
 833          if (DEBUG) Log.d(TAG, &quot;PagedView.onLayout()&quot;);
 834          final int childCount = getChildCount();
 835  
 836          int offsetX = getViewportOffsetX();
 837          int offsetY = getViewportOffsetY();
 838  
 839          // Update the viewport offsets
 840          mViewport.offset(offsetX,  offsetY);
 841  
 842          final boolean isRtl = isLayoutRtl();
 843  
 844          final int startIndex = isRtl ? childCount - 1 : 0;
 845          final int endIndex = isRtl ? -1 : childCount;
 846          final int delta = isRtl ? -1 : 1;
 847  
 848          int verticalPadding = getPaddingTop() + getPaddingBottom();
 849          int childLeft = offsetX + getRelativeChildOffset(startIndex);
 850          for (int i = startIndex; i != endIndex; i += delta) {
 851              final View child = getPageAt(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 852 -            int childTop = offsetY + getPaddingTop();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 853 -            if (mCenterPagesVertically) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 854 -                childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 855 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 856 +            LayoutParams lp = (LayoutParams) child.getLayoutParams();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 857 +            int childTop;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +            if (lp.isFullScreenPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 860 +                childTop = offsetY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 861 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +                childTop = offsetY + getPaddingTop();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +                if (mCenterPagesVertically) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 864 +                    childTop += ((getViewportHeight() - verticalPadding) - child.getMeasuredHeight()) / 2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 865 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 866 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 867 +</span>
 868              if (child.getVisibility() != View.GONE) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 869 -                final int childWidth = getScaledMeasuredWidth(child);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 870 +                final int childWidth = child.getMeasuredWidth();</span>
 871                  final int childHeight = child.getMeasuredHeight();
 872  
 873                  if (DEBUG) Log.d(TAG, &quot;\tlayout-child&quot; + i + &quot;: &quot; + childLeft + &quot;, &quot; + childTop);
 874                  child.layout(childLeft, childTop,
 875                          childLeft + child.getMeasuredWidth(), childTop + childHeight);
 876                  childLeft += childWidth + mPageSpacing;
 877              }
 878          }
 879  
 880          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
 881              setHorizontalScrollBarEnabled(false);
 882              updateCurrentPageScroll();
 883              setHorizontalScrollBarEnabled(true);
 884              mFirstLayout = false;
 885          }
 886      }
 887  
 888      protected void screenScrolled(int screenCenter) {
 889          if (isScrollingIndicatorEnabled()) {
 890              updateScrollingIndicator();
 891          }
 892          boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
 893  
 894          if (mFadeInAdjacentScreens &amp;&amp; !isInOverscroll) {
 895              for (int i = 0; i &lt; getChildCount(); i++) {
 896                  View child = getChildAt(i);
 897                  if (child != null) {
 898                      float scrollProgress = getScrollProgress(screenCenter, child, i);
 899                      float alpha = 1 - Math.abs(scrollProgress);
 900                      child.setAlpha(alpha);
 901                  }
 902              }
 903              invalidate();
 904          }
 905      }
 906  
 907      @Override
 908      public void onChildViewAdded(View parent, View child) {






 909          // This ensures that when children are added, they get the correct transforms / alphas
 910          // in accordance with any scroll effects.
 911          mForceScreenScrolled = true;
 912          mRecomputePageSpacing = true;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +</span>
 914          invalidate();
 915          invalidateCachedOffsets();
 916      }
 917  
 918      @Override
 919      public void onChildViewRemoved(View parent, View child) {
 920          mForceScreenScrolled = true;
 921          invalidate();
 922          invalidateCachedOffsets();








































 923      }
 924  
 925      protected void invalidateCachedOffsets() {
 926          int count = getChildCount();
 927          if (count == 0) {
 928              mChildOffsets = null;
 929              mChildRelativeOffsets = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 930 -            mChildOffsetsWithLayoutScale = null;</span>
 931              return;
 932          }
 933  
 934          mChildOffsets = new int[count];
 935          mChildRelativeOffsets = new int[count];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 936 -        mChildOffsetsWithLayoutScale = new int[count];</span>
 937          for (int i = 0; i &lt; count; i++) {
 938              mChildOffsets[i] = -1;
 939              mChildRelativeOffsets[i] = -1;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 940 -            mChildOffsetsWithLayoutScale[i] = -1;</span>
 941          }
 942      }
 943  
 944      protected int getChildOffset(int index) {
 945          if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
 946  
 947          final boolean isRtl = isLayoutRtl();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 948 -        int[] childOffsets = Float.compare(mLayoutScale, 1f) == 0 ?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 949 -                mChildOffsets : mChildOffsetsWithLayoutScale;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +        int[] childOffsets = mChildOffsets;</span>
 951  
 952          if (childOffsets != null &amp;&amp; childOffsets[index] != -1) {
 953              return childOffsets[index];
 954          } else {
 955              if (getChildCount() == 0)
 956                  return 0;
 957  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 958 -</span>
 959              final int startIndex = isRtl ? getChildCount() - 1 : 0;
 960              final int endIndex = isRtl ? index : index;
 961              final int delta = isRtl ? -1 : 1;
 962  
 963              int offset = getRelativeChildOffset(startIndex);
 964              for (int i = startIndex; i != endIndex; i += delta) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 965 -                offset += getScaledMeasuredWidth(getPageAt(i)) + mPageSpacing;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +                offset += getPageAt(i).getMeasuredWidth() + mPageSpacing;</span>
 967              }
 968              if (childOffsets != null) {
 969                  childOffsets[index] = offset;
 970              }
 971              return offset;
 972          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +</span>
 974      }
 975  
 976      protected int getRelativeChildOffset(int index) {
 977          if (index &lt; 0 || index &gt; getChildCount() - 1) return 0;
 978  
 979          if (mChildRelativeOffsets != null &amp;&amp; mChildRelativeOffsets[index] != -1) {
 980              return mChildRelativeOffsets[index];
 981          } else {
 982              final int padding = getPaddingLeft() + getPaddingRight();
 983              final int offset = getPaddingLeft() +
 984                      (getViewportWidth() - padding - getChildWidth(index)) / 2;
 985              if (mChildRelativeOffsets != null) {
 986                  mChildRelativeOffsets[index] = offset;
 987              }
 988              return offset;
 989          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 990 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 991 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 992 -    protected int getScaledMeasuredWidth(View child) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 993 -        // This functions are called enough times that it actually makes a difference in the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 994 -        // profiler -- so just inline the max() here</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 995 -        final int measuredWidth = child.getMeasuredWidth();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 996 -        final int minWidth = mMinimumWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 997 -        final int maxWidth = (minWidth &gt; measuredWidth) ? minWidth : measuredWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 998 -        return (int) (maxWidth * mLayoutScale + 0.5f);</span>
 999      }
1000  
1001      void boundByReorderablePages(boolean isReordering, int[] range) {
1002          // Do nothing
1003      }
1004  
1005      // TODO: Fix this
1006      protected void getVisiblePages(int[] range) {
1007          range[0] = 0;
1008          range[1] = getPageCount() - 1;
1009  
1010          /*
1011          final int pageCount = getChildCount();
1012  
1013          if (pageCount &gt; 0) {
1014              final int screenWidth = getViewportWidth();
1015              int leftScreen = 0;
1016              int rightScreen = 0;
1017              int offsetX = getViewportOffsetX() + getScrollX();
1018              View currPage = getPageAt(leftScreen);
1019              while (leftScreen &lt; pageCount - 1 &amp;&amp;
1020                      currPage.getX() + currPage.getWidth() -
1021                      currPage.getPaddingRight() &lt; offsetX) {
1022                  leftScreen++;
1023                  currPage = getPageAt(leftScreen);
1024              }
1025              rightScreen = leftScreen;
1026              currPage = getPageAt(rightScreen + 1);
1027              while (rightScreen &lt; pageCount - 1 &amp;&amp;
1028                      currPage.getX() - currPage.getPaddingLeft() &lt; offsetX + screenWidth) {
1029                  rightScreen++;
1030                  currPage = getPageAt(rightScreen + 1);
1031              }
1032  
1033              // TEMP: this is a hacky way to ensure that animations to new pages are not clipped
1034              // because we don&#x27;t draw them while scrolling?
1035              range[0] = Math.max(0, leftScreen - 1);
1036              range[1] = Math.min(rightScreen + 1, getChildCount() - 1);
1037          } else {
1038              range[0] = -1;
1039              range[1] = -1;
1040          }
1041          */
1042      }
1043  
1044      protected boolean shouldDrawChild(View child) {
1045          return child.getAlpha() &gt; 0;
1046      }
1047  
1048      @Override
1049      protected void dispatchDraw(Canvas canvas) {
1050          int halfScreenSize = getViewportWidth() / 2;
1051          // mOverScrollX is equal to getScrollX() when we&#x27;re within the normal scroll range.
1052          // Otherwise it is equal to the scaled overscroll position.
1053          int screenCenter = mOverScrollX + halfScreenSize;
1054  
1055          if (screenCenter != mLastScreenCenter || mForceScreenScrolled) {
1056              // set mForceScreenScrolled before calling screenScrolled so that screenScrolled can
1057              // set it for the next frame
1058              mForceScreenScrolled = false;
1059              screenScrolled(screenCenter);
1060              mLastScreenCenter = screenCenter;
1061          }
1062  
1063          // Find out which screens are visible; as an optimization we only call draw on them
1064          final int pageCount = getChildCount();
1065          if (pageCount &gt; 0) {
1066              getVisiblePages(mTempVisiblePagesRange);
1067              final int leftScreen = mTempVisiblePagesRange[0];
1068              final int rightScreen = mTempVisiblePagesRange[1];
1069              if (leftScreen != -1 &amp;&amp; rightScreen != -1) {
1070                  final long drawingTime = getDrawingTime();
1071                  // Clip to the bounds
1072                  canvas.save();
1073                  canvas.clipRect(getScrollX(), getScrollY(), getScrollX() + getRight() - getLeft(),
1074                          getScrollY() + getBottom() - getTop());
1075  
1076                  // Draw all the children, leaving the drag view for last
1077                  for (int i = pageCount - 1; i &gt;= 0; i--) {
1078                      final View v = getPageAt(i);
1079                      if (v == mDragView) continue;
1080                      if (mForceDrawAllChildrenNextFrame ||
1081                                 (leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(v))) {
1082                          drawChild(canvas, v, drawingTime);
1083                      }
1084                  }
1085                  // Draw the drag view on top (if there is one)
1086                  if (mDragView != null) {
1087                      drawChild(canvas, mDragView, drawingTime);
1088                  }
1089  
1090                  mForceDrawAllChildrenNextFrame = false;
1091                  canvas.restore();
1092              }
1093          }
1094      }
1095  
1096      @Override
1097      public boolean requestChildRectangleOnScreen(View child, Rect rectangle, boolean immediate) {
1098          int page = indexToPage(indexOfChild(child));
1099          if (page != mCurrentPage || !mScroller.isFinished()) {
1100              snapToPage(page);
1101              return true;
1102          }
1103          return false;
1104      }
1105  
1106      @Override
1107      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1108          int focusablePage;
1109          if (mNextPage != INVALID_PAGE) {
1110              focusablePage = mNextPage;
1111          } else {
1112              focusablePage = mCurrentPage;
1113          }
1114          View v = getPageAt(focusablePage);
1115          if (v != null) {
1116              return v.requestFocus(direction, previouslyFocusedRect);
1117          }
1118          return false;
1119      }
1120  
1121      @Override
1122      public boolean dispatchUnhandledMove(View focused, int direction) {
1123          // XXX-RTL: This will be fixed in a future CL
1124          if (direction == View.FOCUS_LEFT) {
1125              if (getCurrentPage() &gt; 0) {
1126                  snapToPage(getCurrentPage() - 1);
1127                  return true;
1128              }
1129          } else if (direction == View.FOCUS_RIGHT) {
1130              if (getCurrentPage() &lt; getPageCount() - 1) {
1131                  snapToPage(getCurrentPage() + 1);
1132                  return true;
1133              }
1134          }
1135          return super.dispatchUnhandledMove(focused, direction);
1136      }
1137  
1138      @Override
1139      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1140          // XXX-RTL: This will be fixed in a future CL
1141          if (mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getPageCount()) {
1142              getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
1143          }
1144          if (direction == View.FOCUS_LEFT) {
1145              if (mCurrentPage &gt; 0) {
1146                  getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
1147              }
1148          } else if (direction == View.FOCUS_RIGHT){
1149              if (mCurrentPage &lt; getPageCount() - 1) {
1150                  getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
1151              }
1152          }
1153      }
1154  
1155      /**
1156       * If one of our descendant views decides that it could be focused now, only
1157       * pass that along if it&#x27;s on the current page.
1158       *
1159       * This happens when live folders requery, and if they&#x27;re off page, they
1160       * end up calling requestFocus, which pulls it on page.
1161       */
1162      @Override
1163      public void focusableViewAvailable(View focused) {
1164          View current = getPageAt(mCurrentPage);
1165          View v = focused;
1166          while (true) {
1167              if (v == current) {
1168                  super.focusableViewAvailable(focused);
1169                  return;
1170              }
1171              if (v == this) {
1172                  return;
1173              }
1174              ViewParent parent = v.getParent();
1175              if (parent instanceof View) {
1176                  v = (View)v.getParent();
1177              } else {
1178                  return;
1179              }
1180          }
1181      }
1182  
1183      /**
1184       * {@inheritDoc}
1185       */
1186      @Override
1187      public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
1188          if (disallowIntercept) {
1189              // We need to make sure to cancel our long press if
1190              // a scrollable widget takes over touch events
1191              final View currentPage = getPageAt(mCurrentPage);
1192              currentPage.cancelLongPress();
1193          }
1194          super.requestDisallowInterceptTouchEvent(disallowIntercept);
1195      }
1196  
1197      /**
1198       * Return true if a tap at (x, y) should trigger a flip to the previous page.
1199       */
1200      protected boolean hitsPreviousPage(float x, float y) {
1201          if (isLayoutRtl()) {
1202              return (x &gt; (getViewportOffsetX() + getViewportWidth() -
1203                      getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1204          }
1205          return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1206      }
1207  
1208      /**
1209       * Return true if a tap at (x, y) should trigger a flip to the next page.
1210       */
1211      protected boolean hitsNextPage(float x, float y) {
1212          if (isLayoutRtl()) {
1213              return (x &lt; getViewportOffsetX() + getRelativeChildOffset(mCurrentPage) - mPageSpacing);
1214          }
1215          return  (x &gt; (getViewportOffsetX() + getViewportWidth() -
1216                  getRelativeChildOffset(mCurrentPage) + mPageSpacing));
1217      }
1218  
1219      /** Returns whether x and y originated within the buffered viewport */
1220      private boolean isTouchPointInViewportWithBuffer(int x, int y) {
1221          mTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top,
1222                  mViewport.right + mViewport.width() / 2, mViewport.bottom);
1223          return mTmpRect.contains(x, y);
1224      }
1225  
1226      /** Returns whether x and y originated within the current page view bounds */
1227      private boolean isTouchPointInCurrentPage(int x, int y) {
1228          View v = getPageAt(getCurrentPage());
1229          if (v != null) {
1230              mTmpRect.set((v.getLeft() - getScrollX()), 0, (v.getRight() - getScrollX()),
1231                      v.getBottom());
1232              return mTmpRect.contains(x, y);
1233          }
1234          return false;
1235      }
1236  
1237      @Override
1238      public boolean onInterceptTouchEvent(MotionEvent ev) {
1239          if (DISABLE_TOUCH_INTERACTION) {
1240              return false;
1241          }
1242  
1243          /*
1244           * This method JUST determines whether we want to intercept the motion.
1245           * If we return true, onTouchEvent will be called and we do the actual
1246           * scrolling there.
1247           */
1248          acquireVelocityTrackerAndAddMovement(ev);
1249  
1250          // Skip touch handling if there are no pages to swipe
1251          if (getChildCount() &lt;= 0) return super.onInterceptTouchEvent(ev);
1252  
1253          /*
1254           * Shortcut the most recurring case: the user is in the dragging
1255           * state and he is moving his finger.  We want to intercept this
1256           * motion.
1257           */
1258          final int action = ev.getAction();
1259          if ((action == MotionEvent.ACTION_MOVE) &amp;&amp;
1260                  (mTouchState == TOUCH_STATE_SCROLLING)) {
1261              return true;
1262          }
1263  
1264          switch (action &amp; MotionEvent.ACTION_MASK) {
1265              case MotionEvent.ACTION_MOVE: {
1266                  /*
1267                   * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check
1268                   * whether the user has moved far enough from his original down touch.
1269                   */
1270                  if (mActivePointerId != INVALID_POINTER) {
1271                      determineScrollingStart(ev);
1272                      break;
1273                  }
1274                  // if mActivePointerId is INVALID_POINTER, then we must have missed an ACTION_DOWN
1275                  // event. in that case, treat the first occurence of a move event as a ACTION_DOWN
1276                  // i.e. fall through to the next case (don&#x27;t break)
1277                  // (We sometimes miss ACTION_DOWN events in Workspace because it ignores all events
1278                  // while it&#x27;s small- this was causing a crash before we checked for INVALID_POINTER)
1279              }
1280  
1281              case MotionEvent.ACTION_DOWN: {
1282                  final float x = ev.getX();
1283                  final float y = ev.getY();
1284                  // Remember location of down touch
1285                  mDownMotionX = x;
1286                  mDownMotionY = y;
1287                  mDownScrollX = getScrollX();
1288                  mLastMotionX = x;
1289                  mLastMotionY = y;
1290                  float[] p = mapPointFromViewToParent(this, x, y);
1291                  mParentDownMotionX = p[0];
1292                  mParentDownMotionY = p[1];
1293                  mLastMotionXRemainder = 0;
1294                  mTotalMotionX = 0;
1295                  mActivePointerId = ev.getPointerId(0);
1296  
1297                  // Determine if the down event is within the threshold to be an edge swipe
1298                  int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1299                  int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1300                  if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1301                      mDownEventOnEdge = true;
1302                  }
1303  
1304                  /*
1305                   * If being flinged and user touches the screen, initiate drag;
1306                   * otherwise don&#x27;t.  mScroller.isFinished should be false when
1307                   * being flinged.
1308                   */
1309                  final int xDist = Math.abs(mScroller.getFinalX() - mScroller.getCurrX());
1310                  final boolean finishedScrolling = (mScroller.isFinished() || xDist &lt; mTouchSlop);
1311                  if (finishedScrolling) {
1312                      mTouchState = TOUCH_STATE_REST;
1313                      mScroller.abortAnimation();
1314                  } else {
1315                      if (isTouchPointInViewportWithBuffer((int) mDownMotionX, (int) mDownMotionY)) {
1316                          mTouchState = TOUCH_STATE_SCROLLING;
1317                      } else {
1318                          mTouchState = TOUCH_STATE_REST;
1319                      }
1320                  }
1321  
1322                  // check if this can be the beginning of a tap on the side of the pages
1323                  // to scroll the current page
1324                  if (!DISABLE_TOUCH_SIDE_PAGES) {
1325                      if (mTouchState != TOUCH_STATE_PREV_PAGE &amp;&amp; mTouchState != TOUCH_STATE_NEXT_PAGE) {
1326                          if (getChildCount() &gt; 0) {
1327                              if (hitsPreviousPage(x, y)) {
1328                                  mTouchState = TOUCH_STATE_PREV_PAGE;
1329                              } else if (hitsNextPage(x, y)) {
1330                                  mTouchState = TOUCH_STATE_NEXT_PAGE;
1331                              }
1332                          }
1333                      }
1334                  }
1335                  break;
1336              }
1337  
1338              case MotionEvent.ACTION_UP:
1339              case MotionEvent.ACTION_CANCEL:
1340                  resetTouchState();
1341                  // Just intercept the touch event on up if we tap outside the strict viewport
1342                  if (!isTouchPointInCurrentPage((int) mLastMotionX, (int) mLastMotionY)) {
1343                      return true;
1344                  }
1345                  break;
1346  
1347              case MotionEvent.ACTION_POINTER_UP:
1348                  onSecondaryPointerUp(ev);
1349                  releaseVelocityTracker();
1350                  break;
1351          }
1352  
1353          /*
1354           * The only time we want to intercept motion events is if we are in the
1355           * drag mode.
1356           */
1357          return mTouchState != TOUCH_STATE_REST;
1358      }
1359  
1360      protected void determineScrollingStart(MotionEvent ev) {
1361          determineScrollingStart(ev, 1.0f);
1362      }
1363  
1364      /*
1365       * Determines if we should change the touch state to start scrolling after the
1366       * user moves their touch point too far.
1367       */
1368      protected void determineScrollingStart(MotionEvent ev, float touchSlopScale) {
1369          // Disallow scrolling if we don&#x27;t have a valid pointer index
1370          final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1371          if (pointerIndex == -1) return;
1372  
1373          // Disallow scrolling if we started the gesture from outside the viewport
1374          final float x = ev.getX(pointerIndex);
1375          final float y = ev.getY(pointerIndex);
1376          if (!isTouchPointInViewportWithBuffer((int) x, (int) y)) return;
1377  
1378          // If we&#x27;re only allowing edge swipes, we break out early if the down event wasn&#x27;t
1379          // at the edge.
1380          if (mOnlyAllowEdgeSwipes &amp;&amp; !mDownEventOnEdge) return;
1381  
1382          final int xDiff = (int) Math.abs(x - mLastMotionX);
1383          final int yDiff = (int) Math.abs(y - mLastMotionY);
1384  
1385          final int touchSlop = Math.round(touchSlopScale * mTouchSlop);
1386          boolean xPaged = xDiff &gt; mPagingTouchSlop;
1387          boolean xMoved = xDiff &gt; touchSlop;
1388          boolean yMoved = yDiff &gt; touchSlop;
1389  
1390          if (xMoved || xPaged || yMoved) {
1391              if (mUsePagingTouchSlop ? xPaged : xMoved) {
1392                  // Scroll if the user moved far enough along the X axis
1393                  mTouchState = TOUCH_STATE_SCROLLING;
1394                  mTotalMotionX += Math.abs(mLastMotionX - x);
1395                  mLastMotionX = x;
1396                  mLastMotionXRemainder = 0;
1397                  mTouchX = getViewportOffsetX() + getScrollX();
1398                  mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1399                  pageBeginMoving();
1400              }
1401          }
1402      }
1403  
1404      protected float getMaxScrollProgress() {
1405          return 1.0f;
1406      }
1407  
1408      protected void cancelCurrentPageLongPress() {
1409          if (mAllowLongPress) {
1410              //mAllowLongPress = false;
1411              // Try canceling the long press. It could also have been scheduled
1412              // by a distant descendant, so use the mAllowLongPress flag to block
1413              // everything
1414              final View currentPage = getPageAt(mCurrentPage);
1415              if (currentPage != null) {
1416                  currentPage.cancelLongPress();
1417              }
1418          }
1419      }
1420  
1421      protected float getBoundedScrollProgress(int screenCenter, View v, int page) {
1422          final int halfScreenSize = getViewportWidth() / 2;
1423  
1424          screenCenter = Math.min(getScrollX() + halfScreenSize, screenCenter);
1425          screenCenter = Math.max(halfScreenSize,  screenCenter);
1426  
1427          return getScrollProgress(screenCenter, v, page);
1428      }
1429  
1430      protected float getScrollProgress(int screenCenter, View v, int page) {
1431          final int halfScreenSize = getViewportWidth() / 2;
1432  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1433 -        int totalDistance = getScaledMeasuredWidth(v) + mPageSpacing;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +        int totalDistance = v.getMeasuredWidth() + mPageSpacing;</span>
1435          int delta = screenCenter - (getChildOffset(page) -
1436                  getRelativeChildOffset(page) + halfScreenSize);
1437  
1438          float scrollProgress = delta / (totalDistance * 1.0f);
1439          scrollProgress = Math.min(scrollProgress, getMaxScrollProgress());
1440          scrollProgress = Math.max(scrollProgress, - getMaxScrollProgress());
1441          return scrollProgress;
1442      }
1443  
1444      // This curve determines how the effect of scrolling over the limits of the page dimishes
1445      // as the user pulls further and further from the bounds
1446      private float overScrollInfluenceCurve(float f) {
1447          f -= 1.0f;
1448          return f * f * f + 1.0f;
1449      }
1450  
1451      protected void acceleratedOverScroll(float amount) {
1452          int screenSize = getViewportWidth();
1453  
1454          // We want to reach the max over scroll effect when the user has
1455          // over scrolled half the size of the screen
1456          float f = OVERSCROLL_ACCELERATE_FACTOR * (amount / screenSize);
1457  
1458          if (f == 0) return;
1459  
1460          // Clamp this factor, f, to -1 &lt; f &lt; 1
1461          if (Math.abs(f) &gt;= 1) {
1462              f /= Math.abs(f);
1463          }
1464  
1465          int overScrollAmount = (int) Math.round(f * screenSize);
1466          if (amount &lt; 0) {
1467              mOverScrollX = overScrollAmount;
1468              super.scrollTo(0, getScrollY());
1469          } else {
1470              mOverScrollX = mMaxScrollX + overScrollAmount;
1471              super.scrollTo(mMaxScrollX, getScrollY());
1472          }
1473          invalidate();
1474      }
1475  
1476      protected void dampedOverScroll(float amount) {
1477          int screenSize = getViewportWidth();
1478  
1479          float f = (amount / screenSize);
1480  
1481          if (f == 0) return;
1482          f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1483  
1484          // Clamp this factor, f, to -1 &lt; f &lt; 1
1485          if (Math.abs(f) &gt;= 1) {
1486              f /= Math.abs(f);
1487          }
1488  
1489          int overScrollAmount = (int) Math.round(OVERSCROLL_DAMP_FACTOR * f * screenSize);
1490          if (amount &lt; 0) {
1491              mOverScrollX = overScrollAmount;
1492              super.scrollTo(0, getScrollY());
1493          } else {
1494              mOverScrollX = mMaxScrollX + overScrollAmount;
1495              super.scrollTo(mMaxScrollX, getScrollY());
1496          }
1497          invalidate();
1498      }
1499  
1500      protected void overScroll(float amount) {
1501          dampedOverScroll(amount);
1502      }
1503  
1504      protected float maxOverScroll() {
1505          // Using the formula in overScroll, assuming that f = 1.0 (which it should generally not
1506          // exceed). Used to find out how much extra wallpaper we need for the over scroll effect
1507          float f = 1.0f;
1508          f = f / (Math.abs(f)) * (overScrollInfluenceCurve(Math.abs(f)));
1509          return OVERSCROLL_DAMP_FACTOR * f;
1510      }
1511  
1512      @Override
1513      public boolean onTouchEvent(MotionEvent ev) {
1514          if (DISABLE_TOUCH_INTERACTION) {
1515              return false;
1516          }
1517  
1518          // Skip touch handling if there are no pages to swipe
1519          if (getChildCount() &lt;= 0) return super.onTouchEvent(ev);
1520  
1521          acquireVelocityTrackerAndAddMovement(ev);
1522  
1523          final int action = ev.getAction();
1524  
1525          switch (action &amp; MotionEvent.ACTION_MASK) {
1526          case MotionEvent.ACTION_DOWN:
1527              /*
1528               * If being flinged and user touches, stop the fling. isFinished
1529               * will be false if being flinged.
1530               */
1531              if (!mScroller.isFinished()) {
1532                  mScroller.abortAnimation();
1533              }
1534  
1535              // Remember where the motion event started
1536              mDownMotionX = mLastMotionX = ev.getX();
1537              mDownMotionY = mLastMotionY = ev.getY();
1538              mDownScrollX = getScrollX();
1539              float[] p = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1540              mParentDownMotionX = p[0];
1541              mParentDownMotionY = p[1];
1542              mLastMotionXRemainder = 0;
1543              mTotalMotionX = 0;
1544              mActivePointerId = ev.getPointerId(0);
1545  
1546              // Determine if the down event is within the threshold to be an edge swipe
1547              int leftEdgeBoundary = getViewportOffsetX() + mEdgeSwipeRegionSize;
1548              int rightEdgeBoundary = getMeasuredWidth() - getViewportOffsetX() - mEdgeSwipeRegionSize;
1549              if ((mDownMotionX &lt;= leftEdgeBoundary || mDownMotionX &gt;= rightEdgeBoundary)) {
1550                  mDownEventOnEdge = true;
1551              }
1552  
1553              if (mTouchState == TOUCH_STATE_SCROLLING) {
1554                  pageBeginMoving();
1555              }
1556              break;
1557  
1558          case MotionEvent.ACTION_MOVE:
1559              if (mTouchState == TOUCH_STATE_SCROLLING) {
1560                  // Scroll to follow the motion event
1561                  final int pointerIndex = ev.findPointerIndex(mActivePointerId);
1562  
1563                  if (pointerIndex == -1) return true;
1564  
1565                  final float x = ev.getX(pointerIndex);
1566                  final float deltaX = mLastMotionX + mLastMotionXRemainder - x;
1567  
1568                  mTotalMotionX += Math.abs(deltaX);
1569  
1570                  // Only scroll and update mLastMotionX if we have moved some discrete amount.  We
1571                  // keep the remainder because we are actually testing if we&#x27;ve moved from the last
1572                  // scrolled position (which is discrete).
1573                  if (Math.abs(deltaX) &gt;= 1.0f) {
1574                      mTouchX += deltaX;
1575                      mSmoothingTime = System.nanoTime() / NANOTIME_DIV;
1576                      if (!mDeferScrollUpdate) {
1577                          scrollBy((int) deltaX, 0);
1578                          if (DEBUG) Log.d(TAG, &quot;onTouchEvent().Scrolling: &quot; + deltaX);
1579                      } else {
1580                          invalidate();
1581                      }
1582                      mLastMotionX = x;
1583                      mLastMotionXRemainder = deltaX - (int) deltaX;
1584                  } else {
1585                      awakenScrollBars();
1586                  }
1587              } else if (mTouchState == TOUCH_STATE_REORDERING) {
1588                  // Update the last motion position
1589                  mLastMotionX = ev.getX();
1590                  mLastMotionY = ev.getY();
1591  
1592                  // Update the parent down so that our zoom animations take this new movement into
1593                  // account
1594                  float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1595                  mParentDownMotionX = pt[0];
1596                  mParentDownMotionY = pt[1];
1597                  updateDragViewTranslationDuringDrag();
1598  
1599                  // Find the closest page to the touch point
1600                  final int dragViewIndex = indexOfChild(mDragView);
1601                  int bufferSize = (int) (REORDERING_SIDE_PAGE_BUFFER_PERCENTAGE *
1602                      getViewportWidth());
1603                  int leftBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.left, 0)[0]
1604                          + bufferSize);
1605                  int rightBufferEdge = (int) (mapPointFromViewToParent(this, mViewport.right, 0)[0]
1606                          - bufferSize);
1607  
1608                  // Change the drag view if we are hovering over the drop target
1609                  boolean isHoveringOverDelete = isHoveringOverDeleteDropTarget(
1610                          (int) mParentDownMotionX, (int) mParentDownMotionY);
1611                  setPageHoveringOverDeleteDropTarget(dragViewIndex, isHoveringOverDelete);
1612  
1613                  if (DEBUG) Log.d(TAG, &quot;leftBufferEdge: &quot; + leftBufferEdge);
1614                  if (DEBUG) Log.d(TAG, &quot;rightBufferEdge: &quot; + rightBufferEdge);
1615                  if (DEBUG) Log.d(TAG, &quot;mLastMotionX: &quot; + mLastMotionX);
1616                  if (DEBUG) Log.d(TAG, &quot;mLastMotionY: &quot; + mLastMotionY);
1617                  if (DEBUG) Log.d(TAG, &quot;mParentDownMotionX: &quot; + mParentDownMotionX);
1618                  if (DEBUG) Log.d(TAG, &quot;mParentDownMotionY: &quot; + mParentDownMotionY);
1619  
1620                  float parentX = mParentDownMotionX;
1621                  int pageIndexToSnapTo = -1;
1622                  if (parentX &lt; leftBufferEdge &amp;&amp; dragViewIndex &gt; 0) {
1623                      pageIndexToSnapTo = dragViewIndex - 1;
1624                  } else if (parentX &gt; rightBufferEdge &amp;&amp; dragViewIndex &lt; getChildCount() - 1) {
1625                      pageIndexToSnapTo = dragViewIndex + 1;
1626                  }
1627  
1628                  final int pageUnderPointIndex = pageIndexToSnapTo;
1629                  if (pageUnderPointIndex &gt; -1 &amp;&amp; !isHoveringOverDelete) {
1630                      mTempVisiblePagesRange[0] = 0;
1631                      mTempVisiblePagesRange[1] = getPageCount() - 1;
1632                      boundByReorderablePages(true, mTempVisiblePagesRange);
1633                      if (mTempVisiblePagesRange[0] &lt;= pageUnderPointIndex &amp;&amp;
1634                              pageUnderPointIndex &lt;= mTempVisiblePagesRange[1] &amp;&amp;
1635                              pageUnderPointIndex != mSidePageHoverIndex &amp;&amp; mScroller.isFinished()) {
1636                          mSidePageHoverIndex = pageUnderPointIndex;
1637                          mSidePageHoverRunnable = new Runnable() {
1638                              @Override
1639                              public void run() {
1640                                  // Update the down scroll position to account for the fact that the
1641                                  // current page is moved
1642                                  mDownScrollX = getChildOffset(pageUnderPointIndex)
1643                                          - getRelativeChildOffset(pageUnderPointIndex);
1644  
1645                                  // Setup the scroll to the correct page before we swap the views
1646                                  snapToPage(pageUnderPointIndex);
1647  
1648                                  // For each of the pages between the paged view and the drag view,
1649                                  // animate them from the previous position to the new position in
1650                                  // the layout (as a result of the drag view moving in the layout)
1651                                  int shiftDelta = (dragViewIndex &lt; pageUnderPointIndex) ? -1 : 1;
1652                                  int lowerIndex = (dragViewIndex &lt; pageUnderPointIndex) ?
1653                                          dragViewIndex + 1 : pageUnderPointIndex;
1654                                  int upperIndex = (dragViewIndex &gt; pageUnderPointIndex) ?
1655                                          dragViewIndex - 1 : pageUnderPointIndex;
1656                                  for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
1657                                      View v = getChildAt(i);
1658                                      // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
1659                                      // drag view all subsequent views to pageUnderPointIndex will
1660                                      // shift down.
1661                                      int oldX = getViewportOffsetX() + getChildOffset(i);
1662                                      int newX = getViewportOffsetX() + getChildOffset(i + shiftDelta);
1663  
1664                                      // Animate the view translation from its old position to its new
1665                                      // position
1666                                      AnimatorSet anim = (AnimatorSet) v.getTag(ANIM_TAG_KEY);
1667                                      if (anim != null) {
1668                                          anim.cancel();
1669                                      }
1670  
1671                                      v.setTranslationX(oldX - newX);
1672                                      anim = new AnimatorSet();
1673                                      anim.setDuration(REORDERING_REORDER_REPOSITION_DURATION);
1674                                      anim.playTogether(
1675                                              ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f));
1676                                      anim.start();
1677                                      v.setTag(anim);
1678                                  }
1679  
1680                                  removeView(mDragView);
1681                                  onRemoveView(mDragView, false);
1682                                  addView(mDragView, pageUnderPointIndex);
1683                                  onAddView(mDragView, pageUnderPointIndex);
1684                                  mSidePageHoverIndex = -1;

1685                              }
1686                          };
1687                          postDelayed(mSidePageHoverRunnable, REORDERING_SIDE_PAGE_HOVER_TIMEOUT);
1688                      }
1689                  } else {
1690                      removeCallbacks(mSidePageHoverRunnable);
1691                      mSidePageHoverIndex = -1;
1692                  }
1693              } else {
1694                  determineScrollingStart(ev);
1695              }
1696              break;
1697  
1698          case MotionEvent.ACTION_UP:
1699              if (mTouchState == TOUCH_STATE_SCROLLING) {
1700                  final int activePointerId = mActivePointerId;
1701                  final int pointerIndex = ev.findPointerIndex(activePointerId);
1702                  final float x = ev.getX(pointerIndex);
1703                  final VelocityTracker velocityTracker = mVelocityTracker;
1704                  velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
1705                  int velocityX = (int) velocityTracker.getXVelocity(activePointerId);
1706                  final int deltaX = (int) (x - mDownMotionX);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1707 -                final int pageWidth = getScaledMeasuredWidth(getPageAt(mCurrentPage));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1708 +                final int pageWidth = getPageAt(mCurrentPage).getMeasuredWidth();</span>
1709                  boolean isSignificantMove = Math.abs(deltaX) &gt; pageWidth *
1710                          SIGNIFICANT_MOVE_THRESHOLD;
1711  
1712                  mTotalMotionX += Math.abs(mLastMotionX + mLastMotionXRemainder - x);
1713  
1714                  boolean isFling = mTotalMotionX &gt; MIN_LENGTH_FOR_FLING &amp;&amp;
1715                          Math.abs(velocityX) &gt; mFlingThresholdVelocity;
1716  
1717                  // In the case that the page is moved far to one direction and then is flung
1718                  // in the opposite direction, we use a threshold to determine whether we should
1719                  // just return to the starting page, or if we should skip one further.
1720                  boolean returnToOriginalPage = false;
1721                  if (Math.abs(deltaX) &gt; pageWidth * RETURN_TO_ORIGINAL_PAGE_THRESHOLD &amp;&amp;
1722                          Math.signum(velocityX) != Math.signum(deltaX) &amp;&amp; isFling) {
1723                      returnToOriginalPage = true;
1724                  }
1725  
1726                  int finalPage;
1727                  // We give flings precedence over large moves, which is why we short-circuit our
1728                  // test for a large move if a fling has been registered. That is, a large
1729                  // move to the left and fling to the right will register as a fling to the right.
1730                  final boolean isRtl = isLayoutRtl();
1731                  boolean isDeltaXLeft = isRtl ? deltaX &gt; 0 : deltaX &lt; 0;
1732                  boolean isVelocityXLeft = isRtl ? velocityX &gt; 0 : velocityX &lt; 0;
1733                  if (((isSignificantMove &amp;&amp; !isDeltaXLeft &amp;&amp; !isFling) ||
1734                          (isFling &amp;&amp; !isVelocityXLeft)) &amp;&amp; mCurrentPage &gt; 0) {
1735                      finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage - 1;
1736                      snapToPageWithVelocity(finalPage, velocityX);
1737                  } else if (((isSignificantMove &amp;&amp; isDeltaXLeft &amp;&amp; !isFling) ||
1738                          (isFling &amp;&amp; isVelocityXLeft)) &amp;&amp;
1739                          mCurrentPage &lt; getChildCount() - 1) {
1740                      finalPage = returnToOriginalPage ? mCurrentPage : mCurrentPage + 1;
1741                      snapToPageWithVelocity(finalPage, velocityX);
1742                  } else {
1743                      snapToDestination();
1744                  }            } else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
1745                  // at this point we have not moved beyond the touch slop
1746                  // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1747                  // we can just page
1748                  int nextPage = Math.max(0, mCurrentPage - 1);
1749                  if (nextPage != mCurrentPage) {
1750                      snapToPage(nextPage);
1751                  } else {
1752                      snapToDestination();
1753                  }
1754              } else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
1755                  // at this point we have not moved beyond the touch slop
1756                  // (otherwise mTouchState would be TOUCH_STATE_SCROLLING), so
1757                  // we can just page
1758                  int nextPage = Math.min(getChildCount() - 1, mCurrentPage + 1);
1759                  if (nextPage != mCurrentPage) {
1760                      snapToPage(nextPage);
1761                  } else {
1762                      snapToDestination();
1763                  }
1764              } else if (mTouchState == TOUCH_STATE_REORDERING) {
1765                  // Update the last motion position
1766                  mLastMotionX = ev.getX();
1767                  mLastMotionY = ev.getY();
1768  
1769                  // Update the parent down so that our zoom animations take this new movement into
1770                  // account
1771                  float[] pt = mapPointFromViewToParent(this, mLastMotionX, mLastMotionY);
1772                  mParentDownMotionX = pt[0];
1773                  mParentDownMotionY = pt[1];
1774                  updateDragViewTranslationDuringDrag();
1775                  boolean handledFling = false;
1776                  if (!DISABLE_FLING_TO_DELETE) {
1777                      // Check the velocity and see if we are flinging-to-delete
1778                      PointF flingToDeleteVector = isFlingingToDelete();
1779                      if (flingToDeleteVector != null) {
1780                          onFlingToDelete(flingToDeleteVector);
1781                          handledFling = true;
1782                      }
1783                  }
1784                  if (!handledFling &amp;&amp; isHoveringOverDeleteDropTarget((int) mParentDownMotionX,
1785                          (int) mParentDownMotionY)) {
1786                      onDropToDelete();
1787                  }
1788              } else {
1789                  onUnhandledTap(ev);
1790              }
1791  
1792              // Remove the callback to wait for the side page hover timeout
1793              removeCallbacks(mSidePageHoverRunnable);
1794              // End any intermediate reordering states
1795              resetTouchState();
1796              break;
1797  
1798          case MotionEvent.ACTION_CANCEL:
1799              if (mTouchState == TOUCH_STATE_SCROLLING) {
1800                  snapToDestination();
1801              }
1802              resetTouchState();
1803              break;
1804  
1805          case MotionEvent.ACTION_POINTER_UP:
1806              onSecondaryPointerUp(ev);
1807              break;
1808          }
1809  
1810          return true;
1811      }
1812  
1813      public void onFlingToDelete(View v) {}
1814      public void onRemoveView(View v, boolean deletePermanently) {}
1815      public void onRemoveViewAnimationCompleted() {}
1816      public void onAddView(View v, int index) {}
1817  
1818      private void resetTouchState() {
1819          releaseVelocityTracker();
1820          endReordering();
1821          mTouchState = TOUCH_STATE_REST;
1822          mActivePointerId = INVALID_POINTER;
1823          mDownEventOnEdge = false;
1824      }
1825  
1826      protected void onUnhandledTap(MotionEvent ev) {}
1827  
1828      @Override
1829      public boolean onGenericMotionEvent(MotionEvent event) {
1830          if ((event.getSource() &amp; InputDevice.SOURCE_CLASS_POINTER) != 0) {
1831              switch (event.getAction()) {
1832                  case MotionEvent.ACTION_SCROLL: {
1833                      // Handle mouse (or ext. device) by shifting the page depending on the scroll
1834                      final float vscroll;
1835                      final float hscroll;
1836                      if ((event.getMetaState() &amp; KeyEvent.META_SHIFT_ON) != 0) {
1837                          vscroll = 0;
1838                          hscroll = event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1839                      } else {
1840                          vscroll = -event.getAxisValue(MotionEvent.AXIS_VSCROLL);
1841                          hscroll = event.getAxisValue(MotionEvent.AXIS_HSCROLL);
1842                      }
1843                      if (hscroll != 0 || vscroll != 0) {
1844                          boolean isForwardScroll = isLayoutRtl() ? (hscroll &lt; 0 || vscroll &lt; 0)
1845                                                           : (hscroll &gt; 0 || vscroll &gt; 0);
1846                          if (isForwardScroll) {
1847                              scrollRight();
1848                          } else {
1849                              scrollLeft();
1850                          }
1851                          return true;
1852                      }
1853                  }
1854              }
1855          }
1856          return super.onGenericMotionEvent(event);
1857      }
1858  
1859      private void acquireVelocityTrackerAndAddMovement(MotionEvent ev) {
1860          if (mVelocityTracker == null) {
1861              mVelocityTracker = VelocityTracker.obtain();
1862          }
1863          mVelocityTracker.addMovement(ev);
1864      }
1865  
1866      private void releaseVelocityTracker() {
1867          if (mVelocityTracker != null) {
1868              mVelocityTracker.recycle();
1869              mVelocityTracker = null;
1870          }
1871      }
1872  
1873      private void onSecondaryPointerUp(MotionEvent ev) {
1874          final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;
1875                  MotionEvent.ACTION_POINTER_INDEX_SHIFT;
1876          final int pointerId = ev.getPointerId(pointerIndex);
1877          if (pointerId == mActivePointerId) {
1878              // This was our active pointer going up. Choose a new
1879              // active pointer and adjust accordingly.
1880              // TODO: Make this decision more intelligent.
1881              final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
1882              mLastMotionX = mDownMotionX = ev.getX(newPointerIndex);
1883              mLastMotionY = ev.getY(newPointerIndex);
1884              mLastMotionXRemainder = 0;
1885              mActivePointerId = ev.getPointerId(newPointerIndex);
1886              if (mVelocityTracker != null) {
1887                  mVelocityTracker.clear();
1888              }
1889          }
1890      }
1891  
1892      @Override
1893      public void requestChildFocus(View child, View focused) {
1894          super.requestChildFocus(child, focused);
1895          int page = indexToPage(indexOfChild(child));
1896          if (page &gt;= 0 &amp;&amp; page != getCurrentPage() &amp;&amp; !isInTouchMode()) {
1897              snapToPage(page);
1898          }
1899      }
1900  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1901 -    protected int getChildIndexForRelativeOffset(int relativeOffset) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1902 -        final boolean isRtl = isLayoutRtl();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1903 -        final int childCount = getChildCount();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1904 -        int left;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1905 -        int right;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1906 -        final int startIndex = isRtl ? childCount - 1 : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1907 -        final int endIndex = isRtl ? -1 : childCount;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1908 -        final int delta = isRtl ? -1 : 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1909 -        for (int i = startIndex; i != endIndex; i += delta) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1910 -            left = getRelativeChildOffset(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1911 -            right = (left + getScaledMeasuredWidth(getPageAt(i)));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1912 -            if (left &lt;= relativeOffset &amp;&amp; relativeOffset &lt;= right) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1913 -                return i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1914 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1915 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1916 -        return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1917 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1918 -</span>
1919      protected int getChildWidth(int index) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1920 -        // This functions are called enough times that it actually makes a difference in the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1921 -        // profiler -- so just inline the max() here</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1922 -        final int measuredWidth = getPageAt(index).getMeasuredWidth();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1923 -        final int minWidth = mMinimumWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1924 -        return (minWidth &gt; measuredWidth) ? minWidth : measuredWidth;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1925 +        return getPageAt(index).getMeasuredWidth();</span>
1926      }
1927  
1928      int getPageNearestToPoint(float x) {
1929          int index = 0;
1930          for (int i = 0; i &lt; getChildCount(); ++i) {
1931              if (x &lt; getChildAt(i).getRight() - getScrollX()) {
1932                  return index;
1933              } else {
1934                  index++;
1935              }
1936          }
1937          return Math.min(index, getChildCount() - 1);
1938      }
1939  
1940      int getPageNearestToCenterOfScreen() {
1941          int minDistanceFromScreenCenter = Integer.MAX_VALUE;
1942          int minDistanceFromScreenCenterIndex = -1;
1943          int screenCenter = getViewportOffsetX() + getScrollX() + (getViewportWidth() / 2);
1944          final int childCount = getChildCount();
1945          for (int i = 0; i &lt; childCount; ++i) {
1946              View layout = (View) getPageAt(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1947 -            int childWidth = getScaledMeasuredWidth(layout);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1948 +            int childWidth = layout.getMeasuredWidth();</span>
1949              int halfChildWidth = (childWidth / 2);
1950              int childCenter = getViewportOffsetX() + getChildOffset(i) + halfChildWidth;
1951              int distanceFromScreenCenter = Math.abs(childCenter - screenCenter);
1952              if (distanceFromScreenCenter &lt; minDistanceFromScreenCenter) {
1953                  minDistanceFromScreenCenter = distanceFromScreenCenter;
1954                  minDistanceFromScreenCenterIndex = i;
1955              }
1956          }
1957          return minDistanceFromScreenCenterIndex;
1958      }
1959  
1960      protected void snapToDestination() {
1961          snapToPage(getPageNearestToCenterOfScreen(), PAGE_SNAP_ANIMATION_DURATION);
1962      }
1963  
1964      private static class ScrollInterpolator implements Interpolator {
1965          public ScrollInterpolator() {
1966          }
1967  
1968          public float getInterpolation(float t) {
1969              t -= 1.0f;
1970              return t*t*t*t*t + 1;
1971          }
1972      }
1973  
1974      // We want the duration of the page snap animation to be influenced by the distance that
1975      // the screen has to travel, however, we don&#x27;t want this duration to be effected in a
1976      // purely linear fashion. Instead, we use this method to moderate the effect that the distance
1977      // of travel has on the overall snap duration.
1978      float distanceInfluenceForSnapDuration(float f) {
1979          f -= 0.5f; // center the values about 0.
1980          f *= 0.3f * Math.PI / 2.0f;
1981          return (float) Math.sin(f);
1982      }
1983  
1984      protected void snapToPageWithVelocity(int whichPage, int velocity) {
1985          whichPage = Math.max(0, Math.min(whichPage, getChildCount() - 1));
1986          int halfScreenSize = getViewportWidth() / 2;
1987  
1988          if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
1989          if (DEBUG) Log.d(TAG, &quot;snapToPageWithVelocity.getRelativeChildOffset(): &quot;
1990                  + getViewportWidth() + &quot;, &quot; + getChildWidth(whichPage));
1991          final int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
1992          int delta = newX - mUnboundedScrollX;
1993          int duration = 0;
1994  
1995          if (Math.abs(velocity) &lt; mMinFlingVelocity) {
1996              // If the velocity is low enough, then treat this more as an automatic page advance
1997              // as opposed to an apparent physical response to flinging
1998              snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
1999              return;
2000          }
2001  
2002          // Here we compute a &quot;distance&quot; that will be used in the computation of the overall
2003          // snap duration. This is a function of the actual distance that needs to be traveled;
2004          // we keep this value close to half screen size in order to reduce the variance in snap
2005          // duration as a function of the distance the page needs to travel.
2006          float distanceRatio = Math.min(1f, 1.0f * Math.abs(delta) / (2 * halfScreenSize));
2007          float distance = halfScreenSize + halfScreenSize *
2008                  distanceInfluenceForSnapDuration(distanceRatio);
2009  
2010          velocity = Math.abs(velocity);
2011          velocity = Math.max(mMinSnapVelocity, velocity);
2012  
2013          // we want the page&#x27;s snap velocity to approximately match the velocity at which the
2014          // user flings, so we scale the duration by a value near to the derivative of the scroll
2015          // interpolator at zero, ie. 5. We use 4 to make it a little slower.
2016          duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
2017  
2018          snapToPage(whichPage, delta, duration);
2019      }
2020  
2021      protected void snapToPage(int whichPage) {
2022          snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION);
2023      }
2024  
2025      protected void snapToPageImmediately(int whichPage) {
2026          snapToPage(whichPage, PAGE_SNAP_ANIMATION_DURATION, true);
2027      }
2028  
2029      protected void snapToPage(int whichPage, int duration) {
2030          snapToPage(whichPage, duration, false);
2031      }
2032  
2033      protected void snapToPage(int whichPage, int duration, boolean immediate) {
2034          whichPage = Math.max(0, Math.min(whichPage, getPageCount() - 1));
2035  
2036          if (DEBUG) Log.d(TAG, &quot;snapToPage.getChildOffset(): &quot; + getChildOffset(whichPage));
2037          if (DEBUG) Log.d(TAG, &quot;snapToPage.getRelativeChildOffset(): &quot; + getViewportWidth() + &quot;, &quot;
2038                  + getChildWidth(whichPage));
2039          int newX = getChildOffset(whichPage) - getRelativeChildOffset(whichPage);
2040          final int sX = mUnboundedScrollX;
2041          final int delta = newX - sX;
2042          snapToPage(whichPage, delta, duration, immediate);
2043      }
2044  
2045      protected void snapToPage(int whichPage, int delta, int duration) {
2046          snapToPage(whichPage, delta, duration, false);
2047      }
2048  
2049      protected void snapToPage(int whichPage, int delta, int duration, boolean immediate) {
2050          mNextPage = whichPage;
2051          View focusedChild = getFocusedChild();
2052          if (focusedChild != null &amp;&amp; whichPage != mCurrentPage &amp;&amp;
2053                  focusedChild == getPageAt(mCurrentPage)) {
2054              focusedChild.clearFocus();
2055          }
2056  
2057          pageBeginMoving();
2058          awakenScrollBars(duration);
2059          if (immediate) {
2060              duration = 0;
2061          } else if (duration == 0) {
2062              duration = Math.abs(delta);
2063          }
2064  
2065          if (!mScroller.isFinished()) mScroller.abortAnimation();
2066          mScroller.startScroll(mUnboundedScrollX, 0, delta, 0, duration);
2067  
2068          notifyPageSwitchListener();
2069  
2070          // Trigger a compute() to finish switching pages if necessary
2071          if (immediate) {
2072              computeScroll();
2073          }
2074  
2075          mForceScreenScrolled = true;
2076          invalidate();
2077      }
2078  
2079      public void scrollLeft() {
2080          if (mScroller.isFinished()) {
2081              if (mCurrentPage &gt; 0) snapToPage(mCurrentPage - 1);
2082          } else {
2083              if (mNextPage &gt; 0) snapToPage(mNextPage - 1);
2084          }
2085      }
2086  
2087      public void scrollRight() {
2088          if (mScroller.isFinished()) {
2089              if (mCurrentPage &lt; getChildCount() -1) snapToPage(mCurrentPage + 1);
2090          } else {
2091              if (mNextPage &lt; getChildCount() -1) snapToPage(mNextPage + 1);
2092          }
2093      }
2094  
2095      public int getPageForView(View v) {
2096          int result = -1;
2097          if (v != null) {
2098              ViewParent vp = v.getParent();
2099              int count = getChildCount();
2100              for (int i = 0; i &lt; count; i++) {
2101                  if (vp == getPageAt(i)) {
2102                      return i;
2103                  }
2104              }
2105          }
2106          return result;
2107      }
2108  
2109      /**
2110       * @return True is long presses are still allowed for the current touch
2111       */
2112      public boolean allowLongPress() {
2113          return mAllowLongPress;
2114      }
2115  
2116      /**
2117       * Set true to allow long-press events to be triggered, usually checked by
2118       * {@link Launcher} to accept or block dpad-initiated long-presses.
2119       */
2120      public void setAllowLongPress(boolean allowLongPress) {
2121          mAllowLongPress = allowLongPress;
2122      }
2123  
2124      public static class SavedState extends BaseSavedState {
2125          int currentPage = -1;
2126  
2127          SavedState(Parcelable superState) {
2128              super(superState);
2129          }
2130  
2131          private SavedState(Parcel in) {
2132              super(in);
2133              currentPage = in.readInt();
2134          }
2135  
2136          @Override
2137          public void writeToParcel(Parcel out, int flags) {
2138              super.writeToParcel(out, flags);
2139              out.writeInt(currentPage);
2140          }
2141  
2142          public static final Parcelable.Creator&lt;SavedState&gt; CREATOR =
2143                  new Parcelable.Creator&lt;SavedState&gt;() {
2144              public SavedState createFromParcel(Parcel in) {
2145                  return new SavedState(in);
2146              }
2147  
2148              public SavedState[] newArray(int size) {
2149                  return new SavedState[size];
2150              }
2151          };
2152      }
2153  
2154      protected void loadAssociatedPages(int page) {
2155          loadAssociatedPages(page, false);
2156      }
2157      protected void loadAssociatedPages(int page, boolean immediateAndOnly) {
2158          if (mContentIsRefreshable) {
2159              final int count = getChildCount();
2160              if (page &lt; count) {
2161                  int lowerPageBound = getAssociatedLowerPageBound(page);
2162                  int upperPageBound = getAssociatedUpperPageBound(page);
2163                  if (DEBUG) Log.d(TAG, &quot;loadAssociatedPages: &quot; + lowerPageBound + &quot;/&quot;
2164                          + upperPageBound);
2165                  // First, clear any pages that should no longer be loaded
2166                  for (int i = 0; i &lt; count; ++i) {
2167                      Page layout = (Page) getPageAt(i);
2168                      if ((i &lt; lowerPageBound) || (i &gt; upperPageBound)) {
2169                          if (layout.getPageChildCount() &gt; 0) {
2170                              layout.removeAllViewsOnPage();
2171                          }
2172                          mDirtyPageContent.set(i, true);
2173                      }
2174                  }
2175                  // Next, load any new pages
2176                  for (int i = 0; i &lt; count; ++i) {
2177                      if ((i != page) &amp;&amp; immediateAndOnly) {
2178                          continue;
2179                      }
2180                      if (lowerPageBound &lt;= i &amp;&amp; i &lt;= upperPageBound) {
2181                          if (mDirtyPageContent.get(i)) {
2182                              syncPageItems(i, (i == page) &amp;&amp; immediateAndOnly);
2183                              mDirtyPageContent.set(i, false);
2184                          }
2185                      }
2186                  }
2187              }
2188          }
2189      }
2190  
2191      protected int getAssociatedLowerPageBound(int page) {
2192          return Math.max(0, page - 1);
2193      }
2194      protected int getAssociatedUpperPageBound(int page) {
2195          final int count = getChildCount();
2196          return Math.min(page + 1, count - 1);
2197      }
2198  
2199      /**
2200       * This method is called ONLY to synchronize the number of pages that the paged view has.
2201       * To actually fill the pages with information, implement syncPageItems() below.  It is
2202       * guaranteed that syncPageItems() will be called for a particular page before it is shown,
2203       * and therefore, individual page items do not need to be updated in this method.
2204       */
2205      public abstract void syncPages();
2206  
2207      /**
2208       * This method is called to synchronize the items that are on a particular page.  If views on
2209       * the page can be reused, then they should be updated within this method.
2210       */
2211      public abstract void syncPageItems(int page, boolean immediate);
2212  
2213      protected void invalidatePageData() {
2214          invalidatePageData(-1, false);
2215      }
2216      protected void invalidatePageData(int currentPage) {
2217          invalidatePageData(currentPage, false);
2218      }
2219      protected void invalidatePageData(int currentPage, boolean immediateAndOnly) {
2220          if (!mIsDataReady) {
2221              return;
2222          }
2223  
2224          if (mContentIsRefreshable) {
2225              // Force all scrolling-related behavior to end
2226              mScroller.forceFinished(true);
2227              mNextPage = INVALID_PAGE;
2228  
2229              // Update all the pages
2230              syncPages();
2231  
2232              // We must force a measure after we&#x27;ve loaded the pages to update the content width and
2233              // to determine the full scroll width
2234              measure(MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
2235                      MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
2236  
2237              // Set a new page as the current page if necessary
2238              if (currentPage &gt; -1) {
2239                  setCurrentPage(Math.min(getPageCount() - 1, currentPage));
2240              }
2241  
2242              // Mark each of the pages as dirty
2243              final int count = getChildCount();
2244              mDirtyPageContent.clear();
2245              for (int i = 0; i &lt; count; ++i) {
2246                  mDirtyPageContent.add(true);
2247              }
2248  
2249              // Load any pages that are necessary for the current window of views
2250              loadAssociatedPages(mCurrentPage, immediateAndOnly);
2251              requestLayout();
2252          }
2253      }
2254  
2255      protected View getScrollingIndicator() {
2256          // We use mHasScrollIndicator to prevent future lookups if there is no sibling indicator
2257          // found
2258          if (mHasScrollIndicator &amp;&amp; mScrollIndicator == null) {
2259              ViewGroup parent = (ViewGroup) getParent();
2260              if (parent != null) {
2261                  mScrollIndicator = (View) (parent.findViewById(R.id.paged_view_indicator));
2262                  mHasScrollIndicator = mScrollIndicator != null;
2263                  if (mHasScrollIndicator) {
2264                      mScrollIndicator.setVisibility(View.VISIBLE);
2265                  }
2266              }
2267          }
2268          return mScrollIndicator;
2269      }
2270  
2271      protected boolean isScrollingIndicatorEnabled() {
2272          return true;
2273      }
2274  
2275      Runnable hideScrollingIndicatorRunnable = new Runnable() {
2276          @Override
2277          public void run() {
2278              hideScrollingIndicator(false);
2279          }
2280      };
2281  
2282      protected void flashScrollingIndicator(boolean animated) {
2283          removeCallbacks(hideScrollingIndicatorRunnable);
2284          showScrollingIndicator(!animated);
2285          postDelayed(hideScrollingIndicatorRunnable, sScrollIndicatorFlashDuration);
2286      }
2287  
2288      protected void showScrollingIndicator(boolean immediately) {
2289          mShouldShowScrollIndicator = true;
2290          mShouldShowScrollIndicatorImmediately = true;
2291          if (getChildCount() &lt;= 1) return;
2292          if (!isScrollingIndicatorEnabled()) return;
2293  
2294          mShouldShowScrollIndicator = false;
2295          getScrollingIndicator();
2296          if (mScrollIndicator != null) {
2297              // Fade the indicator in
2298              updateScrollingIndicatorPosition();
2299              mScrollIndicator.setVisibility(View.VISIBLE);
2300              cancelScrollingIndicatorAnimations();
2301              if (immediately) {
2302                  mScrollIndicator.setAlpha(1f);
2303              } else {
2304                  mScrollIndicatorAnimator = ObjectAnimator.ofFloat(mScrollIndicator, &quot;alpha&quot;, 1f);
2305                  mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeInDuration);
2306                  mScrollIndicatorAnimator.start();
2307              }
2308          }
2309      }
2310  
2311      protected void cancelScrollingIndicatorAnimations() {
2312          if (mScrollIndicatorAnimator != null) {
2313              mScrollIndicatorAnimator.cancel();
2314          }
2315      }
2316  
2317      protected void hideScrollingIndicator(boolean immediately) {
2318          if (getChildCount() &lt;= 1) return;
2319          if (!isScrollingIndicatorEnabled()) return;
2320  
2321          getScrollingIndicator();
2322          if (mScrollIndicator != null) {
2323              // Fade the indicator out
2324              updateScrollingIndicatorPosition();
2325              cancelScrollingIndicatorAnimations();
2326              if (immediately) {
2327                  mScrollIndicator.setVisibility(View.INVISIBLE);
2328                  mScrollIndicator.setAlpha(0f);
2329              } else {
2330                  mScrollIndicatorAnimator = ObjectAnimator.ofFloat(mScrollIndicator, &quot;alpha&quot;, 0f);
2331                  mScrollIndicatorAnimator.setDuration(sScrollIndicatorFadeOutDuration);
2332                  mScrollIndicatorAnimator.addListener(new AnimatorListenerAdapter() {
2333                      private boolean cancelled = false;
2334                      @Override
2335                      public void onAnimationCancel(android.animation.Animator animation) {
2336                          cancelled = true;
2337                      }
2338                      @Override
2339                      public void onAnimationEnd(Animator animation) {
2340                          if (!cancelled) {
2341                              mScrollIndicator.setVisibility(View.INVISIBLE);
2342                          }
2343                      }
2344                  });
2345                  mScrollIndicatorAnimator.start();
2346              }
2347          }
2348      }
2349  
2350      /**
2351       * To be overridden by subclasses to determine whether the scroll indicator should stretch to
2352       * fill its space on the track or not.
2353       */
2354      protected boolean hasElasticScrollIndicator() {
2355          return true;
2356      }
2357  
2358      private void updateScrollingIndicator() {
2359          if (getChildCount() &lt;= 1) return;
2360          if (!isScrollingIndicatorEnabled()) return;
2361  
2362          getScrollingIndicator();
2363          if (mScrollIndicator != null) {
2364              updateScrollingIndicatorPosition();
2365          }
2366          if (mShouldShowScrollIndicator) {
2367              showScrollingIndicator(mShouldShowScrollIndicatorImmediately);
2368          }
2369      }
2370  
2371      private void updateScrollingIndicatorPosition() {
2372          final boolean isRtl = isLayoutRtl();
2373          if (!isScrollingIndicatorEnabled()) return;
2374          if (mScrollIndicator == null) return;
2375          int numPages = getChildCount();
2376          int pageWidth = getViewportWidth();
2377          int lastChildIndex = Math.max(0, getChildCount() - 1);
2378          int maxScrollX = getChildOffset(lastChildIndex) - getRelativeChildOffset(lastChildIndex);
2379          int trackWidth = pageWidth - mScrollIndicatorPaddingLeft - mScrollIndicatorPaddingRight;
2380          int indicatorWidth = mScrollIndicator.getMeasuredWidth() -
2381                  mScrollIndicator.getPaddingLeft() - mScrollIndicator.getPaddingRight();
2382  
2383          float scrollPos = isRtl ? mMaxScrollX - getScrollX() : getScrollX();
2384          float offset = Math.max(0f, Math.min(1f, (float) scrollPos / mMaxScrollX));
2385          if (isRtl) {
2386              offset = 1f - offset;
2387          }
2388          int indicatorSpace = trackWidth / numPages;
2389          int indicatorPos = (int) (offset * (trackWidth - indicatorSpace)) + mScrollIndicatorPaddingLeft;
2390          if (hasElasticScrollIndicator()) {
2391              if (mScrollIndicator.getMeasuredWidth() != indicatorSpace) {
2392                  mScrollIndicator.getLayoutParams().width = indicatorSpace;
2393                  mScrollIndicator.requestLayout();
2394              }
2395          } else {
2396              int indicatorCenterOffset = indicatorSpace / 2 - indicatorWidth / 2;
2397              indicatorPos += indicatorCenterOffset;
2398          }
2399          mScrollIndicator.setTranslationX(indicatorPos);
2400      }
2401  
2402      // Animate the drag view back to the original position
2403      void animateDragViewToOriginalPosition() {
2404          if (mDragView != null) {
2405              AnimatorSet anim = new AnimatorSet();
2406              anim.setDuration(REORDERING_DROP_REPOSITION_DURATION);
2407              anim.playTogether(
2408                      ObjectAnimator.ofFloat(mDragView, &quot;translationX&quot;, 0f),
2409                      ObjectAnimator.ofFloat(mDragView, &quot;translationY&quot;, 0f));
2410              anim.addListener(new AnimatorListenerAdapter() {
2411                  @Override
2412                  public void onAnimationEnd(Animator animation) {
2413                      onPostReorderingAnimationCompleted();
2414                  }
2415              });
2416              anim.start();
2417          }
2418      }
2419  
2420      // &quot;Zooms out&quot; the PagedView to reveal more side pages
2421      protected boolean zoomOut() {
2422          if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2423              mZoomInOutAnim.cancel();
2424          }
2425  
2426          if (!(getScaleX() &lt; 1f || getScaleY() &lt; 1f)) {
2427              mZoomInOutAnim = new AnimatorSet();
2428              mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2429              mZoomInOutAnim.playTogether(
2430                      ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, mMinScale),
2431                      ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, mMinScale));
2432              mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2433                  @Override
2434                  public void onAnimationStart(Animator animation) {
2435                      // Show the delete drop target
2436                      if (mDeleteDropTarget != null) {
2437                          mDeleteDropTarget.setVisibility(View.VISIBLE);
2438                          mDeleteDropTarget.animate().alpha(1f)
2439                              .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2440                              .setListener(new AnimatorListenerAdapter() {
2441                                  @Override
2442                                  public void onAnimationStart(Animator animation) {
2443                                      mDeleteDropTarget.setAlpha(0f);
2444                                  }
2445                              });
2446                      }
2447                  }
2448              });
2449              mZoomInOutAnim.start();
2450              return true;
2451          }
2452          return false;
2453      }
2454  
2455      protected void onStartReordering() {
2456          // Set the touch state to reordering (allows snapping to pages, dragging a child, etc.)
2457          mTouchState = TOUCH_STATE_REORDERING;
2458          mIsReordering = true;
2459  
2460          // Mark all the non-widget pages as invisible
2461          getVisiblePages(mTempVisiblePagesRange);
2462          boundByReorderablePages(true, mTempVisiblePagesRange);
2463          for (int i = 0; i &lt; getPageCount(); ++i) {
2464              if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2465                  getPageAt(i).setAlpha(0f);
2466              }
2467          }
2468  
2469          // We must invalidate to trigger a redraw to update the layers such that the drag view
2470          // is always drawn on top
2471          invalidate();
2472      }
2473  
2474      private void onPostReorderingAnimationCompleted() {
2475          // Trigger the callback when reordering has settled
2476          --mPostReorderingPreZoomInRemainingAnimationCount;
2477          if (mPostReorderingPreZoomInRunnable != null &amp;&amp;
2478                  mPostReorderingPreZoomInRemainingAnimationCount == 0) {
2479              mPostReorderingPreZoomInRunnable.run();
2480              mPostReorderingPreZoomInRunnable = null;
2481          }
2482      }
2483  
2484      protected void onEndReordering() {
2485          mIsReordering = false;
2486  
2487          // Mark all the non-widget pages as visible again
2488          getVisiblePages(mTempVisiblePagesRange);
2489          boundByReorderablePages(true, mTempVisiblePagesRange);
2490          for (int i = 0; i &lt; getPageCount(); ++i) {
2491              if (i &lt; mTempVisiblePagesRange[0] || i &gt; mTempVisiblePagesRange[1]) {
2492                  getPageAt(i).setAlpha(1f);
2493              }
2494          }
2495      }
2496  
2497      public boolean startReordering() {
2498          int dragViewIndex = getPageNearestToCenterOfScreen();
2499          mTempVisiblePagesRange[0] = 0;
2500          mTempVisiblePagesRange[1] = getPageCount() - 1;
2501          boundByReorderablePages(true, mTempVisiblePagesRange);
2502          mReorderingStarted = true;
2503  
2504          // Check if we are within the reordering range
2505          if (mTempVisiblePagesRange[0] &lt;= dragViewIndex &amp;&amp;
2506                  dragViewIndex &lt;= mTempVisiblePagesRange[1]) {
2507              if (zoomOut()) {
2508                  // Find the drag view under the pointer
2509                  mDragView = getChildAt(dragViewIndex);
2510  
2511                  onStartReordering();
2512              }
2513              return true;
2514          }
2515          return false;
2516      }
2517  
2518      boolean isReordering(boolean testTouchState) {
2519          boolean state = mIsReordering;
2520          if (testTouchState) {
2521              state &amp;= (mTouchState == TOUCH_STATE_REORDERING);
2522          }
2523          return state;
2524      }
2525      void endReordering() {
2526          // For simplicity, we call endReordering sometimes even if reordering was never started.
2527          // In that case, we don&#x27;t want to do anything.
2528          if (!mReorderingStarted) return;
2529          mReorderingStarted = false;
2530  
2531          // If we haven&#x27;t flung-to-delete the current child, then we just animate the drag view
2532          // back into position
2533          final Runnable onCompleteRunnable = new Runnable() {
2534              @Override
2535              public void run() {
2536                  onEndReordering();
2537              }
2538          };
2539          if (!mDeferringForDelete) {
2540              mPostReorderingPreZoomInRunnable = new Runnable() {
2541                  public void run() {
2542                      zoomIn(onCompleteRunnable);
2543                  };
2544              };
2545  
2546              mPostReorderingPreZoomInRemainingAnimationCount =
2547                      NUM_ANIMATIONS_RUNNING_BEFORE_ZOOM_OUT;
2548              // Snap to the current page
2549              snapToPage(indexOfChild(mDragView), 0);
2550              // Animate the drag view back to the front position
2551              animateDragViewToOriginalPosition();
2552          } else {
2553              // Handled in post-delete-animation-callbacks
2554          }
2555      }
2556  
2557      // &quot;Zooms in&quot; the PagedView to highlight the current page
2558      protected boolean zoomIn(final Runnable onCompleteRunnable) {
2559          if (mZoomInOutAnim != null &amp;&amp; mZoomInOutAnim.isRunning()) {
2560              mZoomInOutAnim.cancel();
2561          }
2562          if (getScaleX() &lt; 1f || getScaleY() &lt; 1f) {
2563              mZoomInOutAnim = new AnimatorSet();
2564              mZoomInOutAnim.setDuration(REORDERING_ZOOM_IN_OUT_DURATION);
2565              mZoomInOutAnim.playTogether(
2566                      ObjectAnimator.ofFloat(this, &quot;scaleX&quot;, 1f),
2567                      ObjectAnimator.ofFloat(this, &quot;scaleY&quot;, 1f));
2568              mZoomInOutAnim.addListener(new AnimatorListenerAdapter() {
2569                  @Override
2570                  public void onAnimationStart(Animator animation) {
2571                      // Hide the delete drop target
2572                      if (mDeleteDropTarget != null) {
2573                          mDeleteDropTarget.animate().alpha(0f)
2574                              .setDuration(REORDERING_DELETE_DROP_TARGET_FADE_DURATION)
2575                              .setListener(new AnimatorListenerAdapter() {
2576                                  @Override
2577                                  public void onAnimationEnd(Animator animation) {
2578                                      mDeleteDropTarget.setVisibility(View.GONE);
2579                                  }
2580                              });
2581                      }
2582                  }
2583                  @Override
2584                  public void onAnimationCancel(Animator animation) {
2585                      mDragView = null;
2586                  }
2587                  @Override
2588                  public void onAnimationEnd(Animator animation) {
2589                      mDragView = null;
2590                      if (onCompleteRunnable != null) {
2591                          onCompleteRunnable.run();
2592                      }
2593                  }
2594              });
2595              mZoomInOutAnim.start();
2596              return true;
2597          } else {
2598              if (onCompleteRunnable != null) {
2599                  onCompleteRunnable.run();
2600              }
2601          }
2602          return false;
2603      }
2604  
2605      /*
2606       * Flinging to delete - IN PROGRESS
2607       */
2608      private PointF isFlingingToDelete() {
2609          ViewConfiguration config = ViewConfiguration.get(getContext());
2610          mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());
2611  
2612          if (mVelocityTracker.getYVelocity() &lt; mFlingToDeleteThresholdVelocity) {
2613              // Do a quick dot product test to ensure that we are flinging upwards
2614              PointF vel = new PointF(mVelocityTracker.getXVelocity(),
2615                      mVelocityTracker.getYVelocity());
2616              PointF upVec = new PointF(0f, -1f);
2617              float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) /
2618                      (vel.length() * upVec.length()));
2619              if (theta &lt;= Math.toRadians(FLING_TO_DELETE_MAX_FLING_DEGREES)) {
2620                  return vel;
2621              }
2622          }
2623          return null;
2624      }
2625  
2626      /**
2627       * Creates an animation from the current drag view along its current velocity vector.
2628       * For this animation, the alpha runs for a fixed duration and we update the position
2629       * progressively.
2630       */
2631      private static class FlingAlongVectorAnimatorUpdateListener implements AnimatorUpdateListener {
2632          private View mDragView;
2633          private PointF mVelocity;
2634          private Rect mFrom;
2635          private long mPrevTime;
2636          private float mFriction;
2637  
2638          private final TimeInterpolator mAlphaInterpolator = new DecelerateInterpolator(0.75f);
2639  
2640          public FlingAlongVectorAnimatorUpdateListener(View dragView, PointF vel, Rect from,
2641                  long startTime, float friction) {
2642              mDragView = dragView;
2643              mVelocity = vel;
2644              mFrom = from;
2645              mPrevTime = startTime;
2646              mFriction = 1f - (mDragView.getResources().getDisplayMetrics().density * friction);
2647          }
2648  
2649          @Override
2650          public void onAnimationUpdate(ValueAnimator animation) {
2651              float t = ((Float) animation.getAnimatedValue()).floatValue();
2652              long curTime = AnimationUtils.currentAnimationTimeMillis();
2653  
2654              mFrom.left += (mVelocity.x * (curTime - mPrevTime) / 1000f);
2655              mFrom.top += (mVelocity.y * (curTime - mPrevTime) / 1000f);
2656  
2657              mDragView.setTranslationX(mFrom.left);
2658              mDragView.setTranslationY(mFrom.top);
2659              mDragView.setAlpha(1f - mAlphaInterpolator.getInterpolation(t));
2660  
2661              mVelocity.x *= mFriction;
2662              mVelocity.y *= mFriction;
2663              mPrevTime = curTime;
2664          }
2665      };
2666  
2667      private static final int ANIM_TAG_KEY = 100;
2668  
2669      private Runnable createPostDeleteAnimationRunnable(final View dragView) {
2670          return new Runnable() {
2671              @Override
2672              public void run() {
2673                  int dragViewIndex = indexOfChild(dragView);
2674  
2675                  // For each of the pages around the drag view, animate them from the previous
2676                  // position to the new position in the layout (as a result of the drag view moving
2677                  // in the layout)
2678                  // NOTE: We can make an assumption here because we have side-bound pages that we
2679                  //       will always have pages to animate in from the left
2680                  getVisiblePages(mTempVisiblePagesRange);
2681                  boundByReorderablePages(true, mTempVisiblePagesRange);
2682                  boolean isLastWidgetPage = (mTempVisiblePagesRange[0] == mTempVisiblePagesRange[1]);
2683                  boolean slideFromLeft = (isLastWidgetPage ||
2684                          dragViewIndex &gt; mTempVisiblePagesRange[0]);
2685  
2686                  // Setup the scroll to the correct page before we swap the views
2687                  if (slideFromLeft) {
2688                      snapToPageImmediately(dragViewIndex - 1);
2689                  }
2690  
2691                  int firstIndex = (isLastWidgetPage ? 0 : mTempVisiblePagesRange[0]);
2692                  int lastIndex = Math.min(mTempVisiblePagesRange[1], getPageCount() - 1);
2693                  int lowerIndex = (slideFromLeft ? firstIndex : dragViewIndex + 1 );
2694                  int upperIndex = (slideFromLeft ? dragViewIndex - 1 : lastIndex);
2695                  ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2696                  for (int i = lowerIndex; i &lt;= upperIndex; ++i) {
2697                      View v = getChildAt(i);
2698                      // dragViewIndex &lt; pageUnderPointIndex, so after we remove the
2699                      // drag view all subsequent views to pageUnderPointIndex will
2700                      // shift down.
2701                      int oldX = 0;
2702                      int newX = 0;
2703                      if (slideFromLeft) {
2704                          if (i == 0) {
2705                              // Simulate the page being offscreen with the page spacing
2706                              oldX = getViewportOffsetX() + getChildOffset(i) - getChildWidth(i)
2707                                      - mPageSpacing;
2708                          } else {
2709                              oldX = getViewportOffsetX() + getChildOffset(i - 1);
2710                          }
2711                          newX = getViewportOffsetX() + getChildOffset(i);
2712                      } else {
2713                          oldX = getChildOffset(i) - getChildOffset(i - 1);
2714                          newX = 0;
2715                      }
2716  
2717                      // Animate the view translation from its old position to its new
2718                      // position
2719                      AnimatorSet anim = (AnimatorSet) v.getTag();
2720                      if (anim != null) {
2721                          anim.cancel();
2722                      }
2723  
2724                      // Note: Hacky, but we want to skip any optimizations to not draw completely
2725                      // hidden views
2726                      v.setAlpha(Math.max(v.getAlpha(), 0.01f));
2727                      v.setTranslationX(oldX - newX);
2728                      anim = new AnimatorSet();
2729                      anim.playTogether(
2730                              ObjectAnimator.ofFloat(v, &quot;translationX&quot;, 0f),
2731                              ObjectAnimator.ofFloat(v, &quot;alpha&quot;, 1f));
2732                      animations.add(anim);
2733                      v.setTag(ANIM_TAG_KEY, anim);
2734                  }
2735  
2736                  AnimatorSet slideAnimations = new AnimatorSet();
2737                  slideAnimations.playTogether(animations);
2738                  slideAnimations.setDuration(DELETE_SLIDE_IN_SIDE_PAGE_DURATION);
2739                  slideAnimations.addListener(new AnimatorListenerAdapter() {
2740                      @Override
2741                      public void onAnimationEnd(Animator animation) {
2742                          final Runnable onCompleteRunnable = new Runnable() {
2743                              @Override
2744                              public void run() {
2745                                  mDeferringForDelete = false;
2746                                  onEndReordering();
2747                                  onRemoveViewAnimationCompleted();
2748                              }
2749                          };
2750                          zoomIn(onCompleteRunnable);
2751                      }
2752                  });
2753                  slideAnimations.start();
2754  
2755                  removeView(dragView);
2756                  onRemoveView(dragView, true);
2757              }
2758          };
2759      }
2760  
2761      public void onFlingToDelete(PointF vel) {
2762          final long startTime = AnimationUtils.currentAnimationTimeMillis();
2763  
2764          // NOTE: Because it takes time for the first frame of animation to actually be
2765          // called and we expect the animation to be a continuation of the fling, we have
2766          // to account for the time that has elapsed since the fling finished.  And since
2767          // we don&#x27;t have a startDelay, we will always get call to update when we call
2768          // start() (which we want to ignore).
2769          final TimeInterpolator tInterpolator = new TimeInterpolator() {
2770              private int mCount = -1;
2771              private long mStartTime;
2772              private float mOffset;
2773              /* Anonymous inner class ctor */ {
2774                  mStartTime = startTime;
2775              }
2776  
2777              @Override
2778              public float getInterpolation(float t) {
2779                  if (mCount &lt; 0) {
2780                      mCount++;
2781                  } else if (mCount == 0) {
2782                      mOffset = Math.min(0.5f, (float) (AnimationUtils.currentAnimationTimeMillis() -
2783                              mStartTime) / FLING_TO_DELETE_FADE_OUT_DURATION);
2784                      mCount++;
2785                  }
2786                  return Math.min(1f, mOffset + t);
2787              }
2788          };
2789  
2790          final Rect from = new Rect();
2791          final View dragView = mDragView;
2792          from.left = (int) dragView.getTranslationX();
2793          from.top = (int) dragView.getTranslationY();
2794          AnimatorUpdateListener updateCb = new FlingAlongVectorAnimatorUpdateListener(dragView, vel,
2795                  from, startTime, FLING_TO_DELETE_FRICTION);
2796  
2797          final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2798  
2799          // Create and start the animation
2800          ValueAnimator mDropAnim = new ValueAnimator();
2801          mDropAnim.setInterpolator(tInterpolator);
2802          mDropAnim.setDuration(FLING_TO_DELETE_FADE_OUT_DURATION);
2803          mDropAnim.setFloatValues(0f, 1f);
2804          mDropAnim.addUpdateListener(updateCb);
2805          mDropAnim.addListener(new AnimatorListenerAdapter() {
2806              public void onAnimationEnd(Animator animation) {
2807                  onAnimationEndRunnable.run();
2808              }
2809          });
2810          mDropAnim.start();
2811          mDeferringForDelete = true;
2812      }
2813  
2814      /* Drag to delete */
2815      private boolean isHoveringOverDeleteDropTarget(int x, int y) {
2816          if (mDeleteDropTarget != null) {
2817              mAltTmpRect.set(0, 0, 0, 0);
2818              View parent = (View) mDeleteDropTarget.getParent();
2819              if (parent != null) {
2820                  parent.getGlobalVisibleRect(mAltTmpRect);
2821              }
2822              mDeleteDropTarget.getGlobalVisibleRect(mTmpRect);
2823              mTmpRect.offset(-mAltTmpRect.left, -mAltTmpRect.top);
2824              return mTmpRect.contains(x, y);
2825          }
2826          return false;
2827      }
2828  
2829      protected void setPageHoveringOverDeleteDropTarget(int viewIndex, boolean isHovering) {}
2830  
2831      private void onDropToDelete() {
2832          final View dragView = mDragView;
2833  
2834          final float toScale = 0f;
2835          final float toAlpha = 0f;
2836  
2837          // Create and start the complex animation
2838          ArrayList&lt;Animator&gt; animations = new ArrayList&lt;Animator&gt;();
2839          AnimatorSet motionAnim = new AnimatorSet();
2840          motionAnim.setInterpolator(new DecelerateInterpolator(2));
2841          motionAnim.playTogether(
2842                  ObjectAnimator.ofFloat(dragView, &quot;scaleX&quot;, toScale),
2843                  ObjectAnimator.ofFloat(dragView, &quot;scaleY&quot;, toScale));
2844          animations.add(motionAnim);
2845  
2846          AnimatorSet alphaAnim = new AnimatorSet();
2847          alphaAnim.setInterpolator(new LinearInterpolator());
2848          alphaAnim.playTogether(
2849                  ObjectAnimator.ofFloat(dragView, &quot;alpha&quot;, toAlpha));
2850          animations.add(alphaAnim);
2851  
2852          final Runnable onAnimationEndRunnable = createPostDeleteAnimationRunnable(dragView);
2853  
2854          AnimatorSet anim = new AnimatorSet();
2855          anim.playTogether(animations);
2856          anim.setDuration(DRAG_TO_DELETE_FADE_OUT_DURATION);
2857          anim.addListener(new AnimatorListenerAdapter() {
2858              public void onAnimationEnd(Animator animation) {
2859                  onAnimationEndRunnable.run();
2860              }
2861          });
2862          anim.start();
2863  
2864          mDeferringForDelete = true;
2865      }
2866  
2867      /* Accessibility */
2868      @Override
2869      public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
2870          super.onInitializeAccessibilityNodeInfo(info);
2871          info.setScrollable(getPageCount() &gt; 1);
2872          if (getCurrentPage() &lt; getPageCount() - 1) {
2873              info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
2874          }
2875          if (getCurrentPage() &gt; 0) {
2876              info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
2877          }
2878      }
2879  
2880      @Override
2881      public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
2882          super.onInitializeAccessibilityEvent(event);
2883          event.setScrollable(true);
2884          if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED) {
2885              event.setFromIndex(mCurrentPage);
2886              event.setToIndex(mCurrentPage);
2887              event.setItemCount(getChildCount());
2888          }
2889      }
2890  
2891      @Override
2892      public boolean performAccessibilityAction(int action, Bundle arguments) {
2893          if (super.performAccessibilityAction(action, arguments)) {
2894              return true;
2895          }
2896          switch (action) {
2897              case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD: {
2898                  if (getCurrentPage() &lt; getPageCount() - 1) {
2899                      scrollRight();
2900                      return true;
2901                  }
2902              } break;
2903              case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD: {
2904                  if (getCurrentPage() &gt; 0) {
2905                      scrollLeft();
2906                      return true;
2907                  }
2908              } break;
2909          }
2910          return false;
2911      }
2912  
2913      protected String getCurrentPageDescription() {
2914          return String.format(getContext().getString(R.string.default_scroll_format),
2915                  getNextPage() + 1, getChildCount());
2916      }
2917  
2918      @Override
2919      public boolean onHoverEvent(android.view.MotionEvent event) {
2920          return true;
2921      }
2922  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            