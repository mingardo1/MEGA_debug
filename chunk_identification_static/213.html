<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>213</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    213
                    <a href="212.html">prev</a>
                    <a href="214.html">next</a>
                    <a href="213_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_47fec386683d4f12911413ae693bacd60e1538d7_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;47fec386683d4f12911413ae693bacd60e1538d7:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;47fec386683d4f12911413ae693bacd60e1538d7^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;47fec386683d4f12911413ae693bacd60e1538d7^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;a996923be2b09711d11d2a5df4df667dc9a00b19:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [j]], subset: [[b], [b], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 
  21 import org.apache.commons.collections4.map.LRUMap;
  22 import org.apache.commons.lang.StringUtils;
  23 import org.apache.commons.lang3.ArrayUtils;
  24 import org.apache.commons.logging.Log;
  25 import org.apache.commons.logging.LogFactory;
  26 import org.broadleafcommerce.common.money.Money;
  27 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28 import org.broadleafcommerce.common.persistence.Status;
  29 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  36 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  37 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  38 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  39 import org.broadleafcommerce.openadmin.dto.ClassTree;
  40 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  41 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  42 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  43 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  44 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  45 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  47 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  48 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  49 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  50 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  51 import org.hibernate.Criteria;
  52 import org.hibernate.MappingException;
  53 import org.hibernate.Session;
  54 import org.hibernate.mapping.PersistentClass;
  55 import org.hibernate.mapping.Property;
  56 import org.hibernate.type.ComponentType;
  57 import org.hibernate.type.Type;
  58 import org.springframework.beans.BeansException;
  59 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  60 import org.springframework.beans.factory.annotation.Value;
  61 import org.springframework.context.ApplicationContext;
  62 import org.springframework.context.ApplicationContextAware;
  63 import org.springframework.context.annotation.Scope;
  64 import org.springframework.core.annotation.AnnotationUtils;
  65 import org.springframework.stereotype.Component;
  66 
  67 import java.io.Serializable;
  68 import java.lang.reflect.Field;
  69 import java.lang.reflect.Method;
  70 import java.lang.reflect.Modifier;
  71 import java.math.BigDecimal;
  72 import java.math.BigInteger;
  73 import java.security.MessageDigest;
  74 import java.security.NoSuchAlgorithmException;
  75 import java.util.ArrayList;
  76 import java.util.Arrays;
  77 import java.util.Collections;
  78 import java.util.Comparator;
  79 import java.util.Date;
  80 import java.util.HashMap;
  81 import java.util.HashSet;
  82 import java.util.Iterator;
  83 import java.util.List;
  84 import java.util.Map;
  85 import java.util.Set;
  86 
  87 import javax.annotation.Nonnull;
  88 import javax.annotation.Resource;
  89 import javax.persistence.EntityManager;
  90 import javax.persistence.criteria.CriteriaBuilder;
  91 import javax.persistence.criteria.CriteriaQuery;
  92 import javax.persistence.criteria.Path;
  93 import javax.persistence.criteria.Predicate;
  94 import javax.persistence.criteria.Root;
  95 
  96 /**
  97  * @author jfischer
  98  */
  99 @Component(&quot;blDynamicEntityDao&quot;)
 100 @Scope(&quot;prototype&quot;)
 101 public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 102 
 103     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 104 
 105     protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 106 
 107     /**
<abbr title=" 108      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 108      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 109      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 109      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 110      * counts in METADATA_CACHE as a result of cache eviction
 111      */
 112     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 113 
 114     /*
<abbr title=" 115      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 115      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 116      * from polymorphism
 117      */
 118 
 119     protected EntityManager standardEntityManager;
 120 
 121 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 122     @Resource(name=&quot;blMetadata&quot;)</span>
 123 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124     protected EntityManager standardEntityManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126     protected EJB3ConfigurationDao ejb3ConfigurationDao;</span>
 127 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 128     protected EJB3ConfigurationDao ejb3ConfigurationDao;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 129 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130     @Resource(name = &quot;blMetadata&quot;)</span>
 131 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 132     protected Metadata metadata;
 133 
 134     @Resource(name = &quot;blEntityConfiguration&quot;)
 135     protected EntityConfiguration entityConfiguration;
 136 
 137     @Resource(name = &quot;blFieldMetadataProviders&quot;)
 138     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 139 
 140     @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 141     protected FieldMetadataProvider defaultFieldMetadataProvider;
 142 
 143     @Resource(name = &quot;blAppConfigurationMap&quot;)
 144     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 145 
 146     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 147 
 148     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 149     protected int cacheEntityMetaDataTtl;
 150 
 151     /**
<abbr title=" 152      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 152      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 153      */
 154     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 155     protected boolean validateMetadataCacheSizes;
 156 
 157     protected long lastCacheFlushTime = System.currentTimeMillis();
 158 
 159     protected ApplicationContext applicationContext;
 160 
 161     @Override
 162     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 163         this.applicationContext = applicationContext;
 164     }
 165 
 166     @Override
 167     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 168         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 169     }
 170 
 171     @Override
 172     public &lt;T&gt; T persist(T entity) {
 173         standardEntityManager.persist(entity);
 174         standardEntityManager.flush();
 175         return entity;
 176     }
 177 
 178     @Override
 179     public Object find(Class&lt;?&gt; entityClass, Object key) {
 180         return standardEntityManager.find(entityClass, key);
 181     }
 182 
 183     @Override
 184     public &lt;T&gt; T merge(T entity) {
 185         T response = standardEntityManager.merge(entity);
 186         standardEntityManager.flush();
 187         return response;
 188     }
 189 
 190     @Override
 191     public void flush() {
 192         standardEntityManager.flush();
 193     }
 194 
 195     @Override
 196     public void detach(Serializable entity) {
 197         standardEntityManager.detach(entity);
 198     }
 199 
 200     @Override
 201     public void refresh(Serializable entity) {
 202         standardEntityManager.refresh(entity);
 203     }
 204 
 205     @Override
 206     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 207         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 208     }
 209 
 210     @Override
 211     public void remove(Serializable entity) {
 212         standardEntityManager.remove(entity);
 213         standardEntityManager.flush();
 214     }
 215 
 216     @Override
 217     public void clear() {
 218         standardEntityManager.clear();
 219     }
 220 
 221     @Override
 222     public PersistentClass getPersistentClass(String targetClassName) {
 223         return HibernateMappingProvider.getMapping(targetClassName);
 224     }
 225 
 226     @Override
 227     public boolean useCache() {
 228         if (cacheEntityMetaDataTtl &lt; 0) {
 229             return true;
 230         }
 231         if (cacheEntityMetaDataTtl == 0) {
 232             return false;
 233         } else {
 234             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 235                 lastCacheFlushTime = System.currentTimeMillis();
 236                 METADATA_CACHE.clear();
 237                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 238                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 239                 LOG.trace(&quot;Metadata cache evicted&quot;);
 240                 return true; // cache is empty
 241             } else {
 242                 return true;
 243             }
 244         }
 245     }
 246 
 247     @Override
 248     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 249         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 250     }
 251 
 252     @Override
<abbr title=" 253     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 253     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
 254 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 255         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 255         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr></span>
 256 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 259     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 261     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 262     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 262     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr></span>
 263 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 264         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, getSessionFactory(),</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 265                 includeUnqualifiedPolymorphicEntities, useCache());</span>
 266 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 267     }
 268 
 269     @Override
 270     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 271         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 272     }
 273 
 274     @Override
 275     public Class&lt;?&gt; getImplClass(String className) {
 276         Class&lt;?&gt; clazz = null;
 277         try {
 278             clazz = entityConfiguration.lookupEntityClass(className);
 279         } catch (NoSuchBeanDefinitionException e) {
 280             //do nothing
 281         }
 282         if (clazz == null) {
 283             try {
 284                 clazz = Class.forName(className);
 285             } catch (ClassNotFoundException e) {
 286                 throw new RuntimeException(e);
 287             }
 288             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 289         }
 290         return clazz;
 291     }
 292 
 293     @Override
 294     public Class&lt;?&gt; getCeilingImplClass(String className) {
 295         Class&lt;?&gt; clazz;
 296         try {
 297             clazz = Class.forName(className);
 298         } catch (ClassNotFoundException e) {
 299             throw new RuntimeException(e);
 300         }
 301         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 302         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 303             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 304             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 305         }
 306         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 307             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 307             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 308         }
 309         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 310         return clazz;
 311     }
 312 
 313     @Override
<abbr title=" 314     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 314     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 315         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 315         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 316         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 317         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 318         Root root = criteria.from(clazz);
 319         Path idField = root.get(this.getIdField(clazz).getName());
 320         criteria.select(idField.as(Long.class));
 321         List&lt;Predicate&gt; restrictions = new ArrayList();
 322 
 323         Path path = null;
 324 
 325         // Support property name such as &quot;defaultSku.name&quot;
 326         if (propertyName.contains(&quot;.&quot;)) {
 327             String[] split = propertyName.split(&quot;\\.&quot;);
 328             for (String splitResult : split) {
 329                 if (path == null) {
 330                     path = root.get(splitResult);
 331                 } else {
 332                     path = path.get(splitResult);
 333                 }
 334             }
 335         } else {
 336             path = root.get(propertyName);
 337         }
 338 
 339         restrictions.add(builder.equal(path, value));
 340         Serializable identifier = this.getIdentifier(instance);
 341         //when we creating the new item identifier is not exists
 342         if (identifier != null) {
 343             restrictions.add(builder.notEqual(idField, identifier));
 344         }
 345 
 346         if (instance instanceof Status) {
<abbr title=" 347             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 347             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 348         }
 349 
 350         criteria.where((Predicate[]) restrictions.toArray(new Predicate[restrictions.size()]));
 351         return this.standardEntityManager.createQuery(criteria).getResultList();
 352     }
 353 
 354     @Override
 355     public Serializable getIdentifier(Object entity) {
 356         return dynamicDaoHelper.getIdentifier(entity);
 357     }
 358 
 359     protected Field getIdField(Class&lt;?&gt; clazz) {
 360         return dynamicDaoHelper.getIdField(clazz);
 361     }
 362 
 363     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 364         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 365     }
 366 
 367     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 368         Class&lt;?&gt; testClass;
 369         try {
 370             testClass = Class.forName(tree.getFullyQualifiedClassname());
 371         } catch (ClassNotFoundException e) {
 372             throw new RuntimeException(e);
 373         }
 374         if (clazz.equals(testClass)) {
 375             return;
 376         }
 377         if (clazz.getSuperclass().equals(testClass)) {
 378             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 379             createClassTreeFromAnnotation(clazz, myTree);
 380             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 381         } else {
 382             for (ClassTree child : tree.getChildren()) {
 383                 addClassToTree(clazz, child);
 384             }
 385         }
 386     }
 387 
 388     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 389         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 389         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 390         if (classPresentation != null) {
 391             String friendlyName = classPresentation.friendlyName();
 392             if (!StringUtils.isEmpty(friendlyName)) {
 393                 myTree.setFriendlyName(friendlyName);
 394             }
 395         }
 396     }
 397 
 398     @Override
 399     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 400         String ceilingClass = null;
 401         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 402             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 402             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 403             if (classPresentation != null) {
 404                 String ceilingEntity = classPresentation.ceilingDisplayEntity();
 405                 if (!StringUtils.isEmpty(ceilingEntity)) {
 406                     ceilingClass = ceilingEntity;
 407                     break;
 408                 }
 409             }
 410         }
 411         if (ceilingClass != null) {
 412             int pos = -1;
 413             int j = 0;
 414             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 415                 if (clazz.getName().equals(ceilingClass)) {
 416                     pos = j;
 417                     break;
 418                 }
 419                 j++;
 420             }
 421             if (pos &gt;= 0) {
 422                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 423                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 424                 polymorphicClasses = temp;
 425             }
 426         }
 427 
 428         ClassTree classTree = null;
 429         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 430             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 431             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 432             createClassTreeFromAnnotation(topClass, classTree);
 433             for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 434                 addClassToTree(polymorphicClasses[j], classTree);
 435             }
 436             classTree.finalizeStructure(1);
 437         }
 438         return classTree;
 439     }
 440 
 441     @Override
 442     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 443         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 444         return getClassTree(sortedEntities);
 445     }
 446 
 447     @Override
<abbr title=" 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 449         Class&lt;?&gt;[] entityClasses;
 450         try {
 451             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 452         } catch (ClassNotFoundException e) {
 453             throw new RuntimeException(e);
 454         }
 455         if (!ArrayUtils.isEmpty(entityClasses)) {
 456             return getMergedProperties(
 457                     entityName,
 458                     entityClasses,
<abbr title=" 459                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 459                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 460                     persistencePerspective.getAdditionalNonPersistentProperties(),
 461                     persistencePerspective.getAdditionalForeignKeys(),
 462                     MergedPropertyType.PRIMARY,
 463                     persistencePerspective.getPopulateToOneFields(),
 464                     persistencePerspective.getIncludeFields(),
 465                     persistencePerspective.getExcludeFields(),
 466                     persistencePerspective.getConfigurationKey(),
 467                     &quot;&quot;
 468             );
 469         } else {
 470             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 471             Class&lt;?&gt; targetClass;
 472             try {
 473                 targetClass = Class.forName(entityName);
 474             } catch (ClassNotFoundException e) {
 475                 throw new RuntimeException(e);
 476             }
<abbr title=" 477             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 477             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 478             for (String property : attributesMap.keySet()) {
 479                 FieldMetadata presentationAttribute = attributesMap.get(property);
 480                 if (!presentationAttribute.getExcluded()) {
 481                     Field field = FieldManager.getSingleField(targetClass, property);
 482                     if (!Modifier.isStatic(field.getModifiers())) {
 483                         boolean handled = false;
 484                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 485                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 486                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 486                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 487                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 488                                             property, null, false, 0, attributesMap, presentationAttribute,"> 488                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 489                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 489                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 490                                     mergedProperties);
 491                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 492                                 handled = true;
 493                             }
 494                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 495                                 break;
 496                             }
 497                         }
 498                         if (!handled) {
<abbr title=" 499                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 499                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 500                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 500                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 501                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 502                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 502                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 503                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 504                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 504                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 505                                             field.getType(), this), mergedProperties);
 506                         }
 507                     }
 508                 }
 509             }
 510 
 511             return mergedProperties;
 512         }
 513     }
 514 
 515     @Override
 516     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 517         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 518         return getMergedProperties(
 519                 cls.getName(),
 520                 polymorphicTypes,
 521                 null,
 522                 new String[]{},
 523                 new ForeignKey[]{},
 524                 MergedPropertyType.PRIMARY,
 525                 true,
 526                 new String[]{},
 527                 new String[]{},
 528                 null,
 529                 &quot;&quot;
 530         );
 531     }
 532 
 533     @Override
 534     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 535             String ceilingEntityFullyQualifiedClassname,
 536             Class&lt;?&gt;[] entities,
 537             ForeignKey foreignField,
 538             String[] additionalNonPersistentProperties,
 539             ForeignKey[] additionalForeignFields,
 540             MergedPropertyType mergedPropertyType,
 541             Boolean populateManyToOneFields,
 542             String[] includeFields,
 543             String[] excludeFields,
 544             String configurationKey,
 545             String prefix) {
 546         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 547                 ceilingEntityFullyQualifiedClassname,
 548                 entities,
 549                 foreignField,
 550                 additionalNonPersistentProperties,
 551                 additionalForeignFields,
 552                 mergedPropertyType,
 553                 populateManyToOneFields,
 554                 includeFields,
 555                 excludeFields,
 556                 configurationKey,
 557                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 558                 prefix,
 559                 false,
 560                 &quot;&quot;);
 561 
 562         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 563 
 564         for (final String key : mergedProperties.keySet()) {
<abbr title=" 565             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 565             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 566                 removeKeys.add(key);
 567             }
 568         }
 569 
 570         for (String removeKey : removeKeys) {
 571             mergedProperties.remove(removeKey);
 572         }
 573 
<abbr title=" 574         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 574         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 575         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 575         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 576         // like properties gleaned from reflection typically are.
 577         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 578         for (Class&lt;?&gt; targetClass : entities) {
 579             for (String key : keys) {
<abbr title=" 580                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 580                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 581 
 582                 boolean foundOneOrMoreHandlers = false;
 583                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 584                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 584                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 585                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 586                         foundOneOrMoreHandlers = true;
 587                     }
 588                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 589                         break;
 590                     }
 591                 }
 592                 if (!foundOneOrMoreHandlers) {
 593                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 594                 }
 595             }
 596         }
 597 
 598         return mergedProperties;
 599     }
 600 
 601     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 602             final String ceilingEntityFullyQualifiedClassname,
 603             final Class&lt;?&gt;[] entities,
 604             final ForeignKey foreignField,
 605             final String[] additionalNonPersistentProperties,
 606             final ForeignKey[] additionalForeignFields,
 607             final MergedPropertyType mergedPropertyType,
 608             final Boolean populateManyToOneFields,
 609             final String[] includeFields,
 610             final String[] excludeFields,
 611             final String configurationKey,
 612             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 613             final String prefix,
 614             final Boolean isParentExcluded,
 615             final String parentPrefix) {
 616         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 617             @Override
 618             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 619                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 620                 Boolean classAnnotatedPopulateManyToOneFields;
 621                 if (overridePopulateManyToOne != null) {
 622                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 623                 } else {
 624                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 625                 }
 626 
 627                 buildPropertiesFromPolymorphicEntities(
 628                         entities,
 629                         foreignField,
 630                         additionalNonPersistentProperties,
 631                         additionalForeignFields,
 632                         mergedPropertyType,
 633                         classAnnotatedPopulateManyToOneFields,
 634                         includeFields,
 635                         excludeFields,
 636                         configurationKey,
 637                         ceilingEntityFullyQualifiedClassname,
 638                         mergedProperties,
 639                         parentClasses,
 640                         prefix,
 641                         isParentExcluded,
 642                         parentPrefix);
 643 
 644                 return mergedProperties;
 645             }
 646         };
 647 
<abbr title=" 648         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 648         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 649         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 649         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 650         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 651 
 652         return mergedProperties;
 653     }
 654 
<abbr title=" 655     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 655     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 656         for (String key : mergedProperties.keySet()) {
 657             boolean isForeign = false;
 658             if (foreignField != null) {
 659                 isForeign = foreignField.getManyToField().equals(key);
 660             }
 661             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 662                 for (ForeignKey foreignKey : additionalForeignFields) {
 663                     isForeign = foreignKey.getManyToField().equals(key);
 664                     if (isForeign) {
 665                         break;
 666                     }
 667                 }
 668             }
 669             if (isForeign) {
 670                 FieldMetadata metadata = mergedProperties.get(key);
 671                 metadata.setExcluded(false);
 672             }
 673         }
 674     }
 675 
<abbr title=" 676     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 676     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 677         //check includes
 678         if (!ArrayUtils.isEmpty(includeFields)) {
 679             for (String include : includeFields) {
 680                 for (String key : mergedProperties.keySet()) {
 681                     String testKey = prefix + key;
 682                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 683                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 684                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 684                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 685                         metadata.setExcluded(true);
 686                     } else {
 687                         FieldMetadata metadata = mergedProperties.get(key);
 688                         if (!isParentExcluded) {
<abbr title=" 689                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 689                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 690                             metadata.setExcluded(false);
 691                         }
 692                     }
 693                 }
 694             }
 695         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 696             //check excludes
 697             for (String exclude : excludeFields) {
 698                 for (String key : mergedProperties.keySet()) {
 699                     String testKey = prefix + key;
 700                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 701                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 702                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 702                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 703                         metadata.setExcluded(true);
 704                     } else {
 705                         FieldMetadata metadata = mergedProperties.get(key);
 706                         if (!isParentExcluded) {
<abbr title=" 707                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 707                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 708                             metadata.setExcluded(false);
 709                         }
 710                     }
 711                 }
 712             }
 713         }
 714     }
 715 
 716     protected String pad(String s, int length, char pad) {
 717         StringBuilder buffer = new StringBuilder(s);
 718         while (buffer.length() &lt; length) {
 719             buffer.insert(0, pad);
 720         }
 721         return buffer.toString();
 722     }
 723 
<abbr title=" 724     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 724     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 725         StringBuilder sb = new StringBuilder(150);
 726         sb.append(ceilingEntityFullyQualifiedClassname);
 727         sb.append(clazz.hashCode());
 728         sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 729         sb.append(configurationKey);
 730         sb.append(isParentExcluded);
 731         if (additionalNonPersistentProperties != null) {
 732             for (String prop : additionalNonPersistentProperties) {
 733                 sb.append(prop);
 734             }
 735         }
 736         if (additionalForeignFields != null) {
 737             for (ForeignKey key : additionalForeignFields) {
 738                 sb.append(key.toString());
 739             }
 740         }
 741         sb.append(mergedPropertyType);
 742         sb.append(populateManyToOneFields);
 743 
 744         String digest;
 745         try {
 746             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 747             byte[] messageDigest = md.digest(sb.toString().getBytes());
 748             BigInteger number = new BigInteger(1, messageDigest);
 749             digest = number.toString(16);
 750         } catch (NoSuchAlgorithmException e) {
 751             throw new RuntimeException(e);
 752         }
 753 
 754         String key = pad(digest, 32, &#x27;0&#x27;);
 755 
 756         if (LOG.isDebugEnabled()) {
 757             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 758         }
 759         return key;
 760     }
 761 
 762     protected void buildPropertiesFromPolymorphicEntities(
 763             Class&lt;?&gt;[] entities,
 764             ForeignKey foreignField,
 765             String[] additionalNonPersistentProperties,
 766             ForeignKey[] additionalForeignFields,
 767             MergedPropertyType mergedPropertyType,
 768             Boolean populateManyToOneFields,
 769             String[] includeFields,
 770             String[] excludeFields,
 771             String configurationKey,
 772             String ceilingEntityFullyQualifiedClassname,
 773             Map&lt;String, FieldMetadata&gt; mergedProperties,
 774             List&lt;Class&lt;?&gt;&gt; parentClasses,
 775             String prefix,
 776             Boolean isParentExcluded,
 777             String parentPrefix) {
 778         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 779             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 779             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 780 
 781             Map&lt;String, FieldMetadata&gt; cacheData = null;
 782             synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {
 783                 if (useCache()) {
 784                     cacheData = METADATA_CACHE.get(cacheKey);
 785                 }
 786 
 787                 if (cacheData == null) {
 788                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 789                             clazz,
 790                             foreignField,
 791                             additionalNonPersistentProperties,
 792                             additionalForeignFields,
 793                             mergedPropertyType,
 794                             populateManyToOneFields,
 795                             includeFields,
 796                             excludeFields,
 797                             configurationKey,
 798                             ceilingEntityFullyQualifiedClassname,
 799                             parentClasses,
 800                             prefix,
 801                             isParentExcluded,
 802                             parentPrefix);
<abbr title=" 803                     //first check all the properties currently in there to see if my entity inherits from them"> 803                     //first check all the properties currently in there to see if my entity inherits fromðŸ”µ</abbr>
 804                     for (Class&lt;?&gt; clazz2 : entities) {
 805                         if (!clazz2.getName().equals(clazz.getName())) {
 806                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 807                                 FieldMetadata metadata = entry.getValue();
 808                                 try {
<abbr title=" 809                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 809                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 810                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 810                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 811                                         metadata.setAvailableToTypes(both);
 812                                     }
 813                                 } catch (ClassNotFoundException e) {
 814                                     throw new RuntimeException(e);
 815                                 }
 816                             }
 817                         }
 818                     }
 819                     METADATA_CACHE.put(cacheKey, props);
 820 
 821                     if (LOG.isTraceEnabled()) {
<abbr title=" 822                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 822                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKeyðŸ”µ</abbr>
 823                     }
 824 
 825                     if (validateMetadataCacheSizes) {
 826                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 827                         Integer currentSize = props.size();
 828                         if (previousSize == null) {
 829                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 830                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 831                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 831                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache ðŸ”µ</abbr>
 832                             LOG.error(msg);
 833                             throw new RuntimeException(msg);
 834                         }
 835                     }
 836 
 837                     cacheData = props;
 838                 } else {
 839                     if (LOG.isTraceEnabled()) {
<abbr title=" 840                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 840                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheðŸ”µ</abbr>
 841                     }
 842                 }
 843             }
 844             //clone the metadata before passing to the system
 845             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 846             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 847                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 848             }
 849             mergedProperties.putAll(clonedCache);
 850         }
 851     }
 852 
 853     @Override
 854     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 855         Field[] allFields = new Field[]{};
 856         boolean eof = false;
 857         Class&lt;?&gt; currentClass = targetClass;
 858         while (!eof) {
 859             Field[] fields = currentClass.getDeclaredFields();
 860             allFields = ArrayUtils.addAll(allFields, fields);
 861             if (currentClass.getSuperclass() != null) {
 862                 currentClass = currentClass.getSuperclass();
 863             } else {
 864                 eof = true;
 865             }
 866         }
 867 
 868         return allFields;
 869     }
 870 
 871     @Override
 872     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 873             String propertyName,
 874             String friendlyPropertyName,
 875             Class&lt;?&gt; targetClass,
 876             Class&lt;?&gt; parentClass,
 877             MergedPropertyType mergedPropertyType
 878     ) {
 879         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 880         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 881         presentationAttribute.setFriendlyName(friendlyPropertyName);
 882         if (String.class.isAssignableFrom(targetClass)) {
 883             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 884             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 885             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 885             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 886         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 887             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 888             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 889             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 889             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 890         } else if (Date.class.isAssignableFrom(targetClass)) {
 891             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 892             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 893             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 893             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 894         } else if (Money.class.isAssignableFrom(targetClass)) {
 895             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 896             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 897             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 897             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 898         } else if (
 899                 Byte.class.isAssignableFrom(targetClass) ||
 900                         Integer.class.isAssignableFrom(targetClass) ||
 901                         Long.class.isAssignableFrom(targetClass) ||
 902                         Short.class.isAssignableFrom(targetClass)
 903                 ) {
 904             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 905             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 906             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 906             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 907         } else if (
 908                 Double.class.isAssignableFrom(targetClass) ||
 909                         BigDecimal.class.isAssignableFrom(targetClass)
 910                 ) {
 911             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 912             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 913             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 913             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 914         }
 915         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 916         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 917         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 918         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 919         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 920         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 921 
 922         return fields;
 923     }
 924 
 925     @Override
 926     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 927         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 928     }
 929 
 930     @Override
 931     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 932         return dynamicDaoHelper.getPropertyNames(entityClass);
 933     }
 934 
 935     @Override
 936     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 937         return dynamicDaoHelper.getPropertyTypes(entityClass);
 938     }
 939 
 940     @Override
 941     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 942         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 943 
<abbr title=" 944         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 944         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 945         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 946         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 947 
 948         return mergedTabAndGroupMetadata;
 949     }
 950 
 951     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 952         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 953 
 954         if (ceilingEntity != null) {
 955             entities = ArrayUtils.add(entities, ceilingEntity);
 956             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 957                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 958                 ceilingEntity = ceilingEntity.getSuperclass();
 959             }
 960         }
 961         return entities;
 962     }
 963 
 964     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 965             Class&lt;?&gt; targetClass,
 966             ForeignKey foreignField,
 967             String[] additionalNonPersistentProperties,
 968             ForeignKey[] additionalForeignFields,
 969             MergedPropertyType mergedPropertyType,
 970             Boolean populateManyToOneFields,
 971             String[] includeFields,
 972             String[] excludeFields,
 973             String configurationKey,
 974             String ceilingEntityFullyQualifiedClassname,
 975             List&lt;Class&lt;?&gt;&gt; parentClasses,
 976             String prefix,
 977             Boolean isParentExcluded,
 978             String parentPrefix) {
<abbr title=" 979         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 979         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
 980         if (isParentExcluded) {
 981             for (String key : presentationAttributes.keySet()) {
<abbr title=" 982                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);"> 982                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
 983                 presentationAttributes.get(key).setExcluded(true);
 984             }
 985         }
 986 
 987         Map idMetadata = getIdMetadata(targetClass);
 988         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 989         String idProperty = (String) idMetadata.get(&quot;name&quot;);
 990         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 991         propertyNames.add(idProperty);
 992         Type idType = (Type) idMetadata.get(&quot;type&quot;);
 993         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 994         propertyTypes.add(idType);
 995 
 996         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
 997         Iterator testIter = persistentClass.getPropertyIterator();
 998         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
 999 
1000         //check the properties for problems
1001         while (testIter.hasNext()) {
1002             Property property = (Property) testIter.next();
1003             if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1004                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1004                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
1005             }
1006             propertyList.add(property);
1007         }
1008 
1009         buildProperties(
1010                 targetClass,
1011                 foreignField,
1012                 additionalForeignFields,
1013                 additionalNonPersistentProperties,
1014                 mergedPropertyType,
1015                 presentationAttributes,
1016                 propertyList,
1017                 fields,
1018                 propertyNames,
1019                 propertyTypes,
1020                 idProperty,
1021                 populateManyToOneFields,
1022                 includeFields,
1023                 excludeFields,
1024                 configurationKey,
1025                 ceilingEntityFullyQualifiedClassname,
1026                 parentClasses,
1027                 prefix,
1028                 isParentExcluded,
1029                 false,
1030                 parentPrefix
1031         );
1032         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1033         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1034         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1035         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1036             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1037             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1038                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1038                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1039                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1040                     //get final property if this is a dot delimited property
1041                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1042                     if (finalDotPos &gt;= 0) {
<abbr title="1043                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1043                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1044                     }
<abbr title="1045                     //check all the polymorphic types on this target class to see if the end property exists">1045                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1046                     Field testField = null;
1047                     Method testMethod = null;
1048                     for (Class&lt;?&gt; clazz : entities) {
1049                         try {
1050                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1051                             if (testMethod != null) {
1052                                 break;
1053                             }
1054                         } catch (NoSuchMethodException e) {
1055                             //do nothing - method does not exist
1056                         }
1057                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1058                         if (testField != null) {
1059                             break;
1060                         }
1061                     }
1062                     //if the property exists, add it to the metadata for this class
1063                     if (testField != null || testMethod != null) {
<abbr title="1064                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1064                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1065                     }
1066                 }
1067             }
1068         }
1069 
1070         return fields;
1071     }
1072 
1073     protected void buildProperties(
1074             Class&lt;?&gt; targetClass,
1075             ForeignKey foreignField,
1076             ForeignKey[] additionalForeignFields,
1077             String[] additionalNonPersistentProperties,
1078             MergedPropertyType mergedPropertyType,
1079             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1080             List&lt;Property&gt; componentProperties,
1081             Map&lt;String, FieldMetadata&gt; fields,
1082             List&lt;String&gt; propertyNames,
1083             List&lt;Type&gt; propertyTypes,
1084             String idProperty,
1085             Boolean populateManyToOneFields,
1086             String[] includeFields,
1087             String[] excludeFields,
1088             String configurationKey,
1089             String ceilingEntityFullyQualifiedClassname,
1090             List&lt;Class&lt;?&gt;&gt; parentClasses,
1091             String prefix,
1092             Boolean isParentExcluded,
1093             Boolean isComponentPrefix,
1094             String parentPrefix) {
1095         int j = 0;
1096         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1097             @Override
1098             public int compare(String o1, String o2) {
1099                 //check for property name equality and for map field properties
<abbr title="1100                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1100                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1101                     return 0;
1102                 }
1103                 return o1.compareTo(o2);
1104             }
1105         };
1106         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1107         Collections.sort(presentationKeyList);
1108 
1109         for (String propertyName : propertyNames) {
1110             final Type type = propertyTypes.get(j);
1111             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1112             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1112             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1113             j++;
1114             Field myField = getFieldManager().getField(targetClass, propertyName);
1115             if (myField == null) {
<abbr title="1116                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1116                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1117                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1118             }
1119             if (
1120                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1121                             isPropertyForeignKey ||
1122                             additionalForeignKeyIndexPosition &gt;= 0 ||
<abbr title="1123                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0">1123                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparatoðŸ”µ</abbr>
1124                     ) {
1125                 if (myField != null) {
1126                     boolean handled = false;
1127                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1128                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1129                         if (presentationAttribute != null) {
1130                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1131                         }
1132                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1133                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1133                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1134                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1135                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1135                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1136                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1136                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1137                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1138                             handled = true;
1139                         }
1140                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1141                             break;
1142                         }
1143                     }
1144                     if (!handled) {
1145                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1146                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1146                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttribðŸ”µ</abbr>
<abbr title="1147                                 componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1147                                 componentProperties, fields, idProperty, populateManyToOneFields, includeðŸ”µ</abbr>
<abbr title="1148                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1148                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, paðŸ”µ</abbr>
<abbr title="1149                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1149                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additðŸ”µ</abbr>
1150                     }
1151                 }
1152             }
1153         }
1154     }
1155 
1156     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1157         setExcludedBasedOnShowIfProperty(presentationAttribute);
1158 
<abbr title="1159         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1159         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1160 
1161     }
1162 
1163     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1164         if (fieldMetadata != null
1165                 &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1166                 &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1167                 &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1168 
1169             //do not include this in the display if it returns false.
1170             fieldMetadata.setExcluded(true);
1171         }
1172     }
1173 
<abbr title="1174     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1174     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1175                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1175                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1176 
<abbr title="1177         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1177         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1178                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1179 
<abbr title="1180         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1180         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1181                 parentPrefix, propertyName);
1182 
1183         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1184     }
1185 
<abbr title="1186     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1186     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1187         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1188     }
1189 
1190     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1191             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1192                                                             isComponentPrefix) {
1193         Boolean response = false;
1194         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1195         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1195         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1196         if (shouldTest) {
1197             Field testField = getFieldManager().getField(targetClass, propertyName);
1198             if (testField == null) {
1199                 Class&lt;?&gt;[] entities;
1200                 try {
<abbr title="1201                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1201                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1202                 } catch (ClassNotFoundException e) {
1203                     throw new RuntimeException(e);
1204                 }
1205                 for (Class&lt;?&gt; clazz : entities) {
1206                     testField = getFieldManager().getField(clazz, propertyName);
1207                     if (testField != null) {
1208                         break;
1209                     }
1210                 }
1211                 String testProperty = prefix + propertyName;
1212                 if (testField == null) {
1213                     testField = getFieldManager().getField(targetClass, testProperty);
1214                 }
1215                 if (testField == null) {
1216                     for (Class&lt;?&gt; clazz : entities) {
1217                         testField = getFieldManager().getField(clazz, testProperty);
1218                         if (testField != null) {
1219                             break;
1220                         }
1221                     }
1222                 }
1223             }
1224             response = determineExclusionForField(parentClasses, targetClass, testField);
1225         }
1226         return response;
1227     }
1228 
<abbr title="1229     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1229     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1230         Boolean response = false;
1231         if (testField != null) {
1232             Class&lt;?&gt; testType = testField.getType();
1233             for (Class&lt;?&gt; parentClass : parentClasses) {
1234                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1235                     response = true;
1236                     break;
1237                 }
1238             }
<abbr title="1239             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1239             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1240                 response = true;
1241             }
1242         }
1243         return response;
1244     }
1245 
1246     protected void buildBasicProperty(
1247             Field field,
1248             Class&lt;?&gt; targetClass,
1249             ForeignKey foreignField,
1250             ForeignKey[] additionalForeignFields,
1251             String[] additionalNonPersistentProperties,
1252             MergedPropertyType mergedPropertyType,
1253             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1254             List&lt;Property&gt; componentProperties,
1255             Map&lt;String, FieldMetadata&gt; fields,
1256             String idProperty,
1257             Boolean populateManyToOneFields,
1258             String[] includeFields,
1259             String[] excludeFields,
1260             String configurationKey,
1261             String ceilingEntityFullyQualifiedClassname,
1262             List&lt;Class&lt;?&gt;&gt; parentClasses,
1263             String prefix,
1264             Boolean isParentExcluded,
1265             String propertyName,
1266             Type type,
1267             boolean propertyForeignKey,
1268             int additionalForeignKeyIndexPosition,
1269             Boolean isComponentPrefix,
1270             String parentPrefix) {
1271         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1272         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1273         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1274                 ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1275 
1276         SupportedFieldType explicitType = null;
1277         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1278             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1279         }
1280         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1281         checkProp:
1282         {
1283             if (type.isComponentType() &amp;&amp; includeField) {
1284                 buildComponentProperties(
1285                         targetClass,
1286                         foreignField,
1287                         additionalForeignFields,
1288                         additionalNonPersistentProperties,
1289                         mergedPropertyType,
1290                         fields,
1291                         idProperty,
1292                         populateManyToOneFields,
1293                         includeFields,
1294                         excludeFields,
1295                         configurationKey,
1296                         ceilingEntityFullyQualifiedClassname,
1297                         propertyName,
1298                         type,
1299                         returnedClass,
1300                         parentClasses,
1301                         amIExcluded,
1302                         prefix,
1303                         parentPrefix);
1304                 break checkProp;
1305             }
1306             /*
1307              * Currently we do not support ManyToOne fields whose class type is the same
1308              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1309              */
1310             if (
1311                     type.isEntityType() &amp;&amp;
1312                             !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1313                             populateManyToOneFields &amp;&amp;
1314                             includeField
1315                     ) {
1316                 buildEntityProperties(
1317                         fields,
1318                         foreignField,
1319                         additionalForeignFields,
1320                         additionalNonPersistentProperties,
1321                         populateManyToOneFields,
1322                         includeFields,
1323                         excludeFields,
1324                         configurationKey,
1325                         ceilingEntityFullyQualifiedClassname,
1326                         propertyName,
1327                         returnedClass,
1328                         targetClass,
1329                         parentClasses,
1330                         prefix,
1331                         amIExcluded,
1332                         parentPrefix
1333                 );
1334                 break checkProp;
1335             }
1336         }
1337         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1338         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1339             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1340                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1340                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1341                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1341                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1342                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1342                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1343                             presentationAttribute, explicitType, returnedClass, this), fields);
1344         }
1345     }
1346 
1347     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1348         boolean isPropertyForeignKey = false;
1349         if (foreignField != null) {
1350             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1351         }
1352         return isPropertyForeignKey;
1353     }
1354 
<abbr title="1355     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1355     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1356         int additionalForeignKeyIndexPosition = -1;
1357         if (additionalForeignFields != null) {
<abbr title="1358             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1358             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1359                 @Override
1360                 public int compare(ForeignKey o1, ForeignKey o2) {
1361                     return o1.getManyToField().compareTo(o2.getManyToField());
1362                 }
1363             });
1364         }
1365         return additionalForeignKeyIndexPosition;
1366     }
1367 
1368     protected void buildEntityProperties(
1369             Map&lt;String, FieldMetadata&gt; fields,
1370             ForeignKey foreignField,
1371             ForeignKey[] additionalForeignFields,
1372             String[] additionalNonPersistentProperties,
1373             Boolean populateManyToOneFields,
1374             String[] includeFields,
1375             String[] excludeFields,
1376             String configurationKey,
1377             String ceilingEntityFullyQualifiedClassname,
1378             String propertyName,
1379             Class&lt;?&gt; returnedClass,
1380             Class&lt;?&gt; targetClass,
1381             List&lt;Class&lt;?&gt;&gt; parentClasses,
1382             String prefix,
1383             Boolean isParentExcluded,
1384             String parentPrefix) {
1385         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1386         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1387 
1388         for (Class&lt;?&gt; parentClass : parentClasses) {
1389             clonedParentClasses.add(parentClass);
1390         }
1391 
1392         clonedParentClasses.add(targetClass);
1393 
1394         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1395                 ceilingEntityFullyQualifiedClassname,
1396                 polymorphicEntities,
1397                 foreignField,
1398                 additionalNonPersistentProperties,
1399                 additionalForeignFields,
1400                 MergedPropertyType.PRIMARY,
1401                 populateManyToOneFields,
1402                 includeFields,
1403                 excludeFields,
1404                 configurationKey,
1405                 clonedParentClasses,
1406                 prefix + propertyName + &#x27;.&#x27;,
1407                 isParentExcluded,
1408                 parentPrefix);
1409 
1410         final String targetClassName = targetClass.getName();
1411 
1412         for (FieldMetadata newMetadata : newFields.values()) {
1413             newMetadata.setInheritedFromType(targetClassName);
1414             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1415         }
1416 
1417         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1418 
1419         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1420             final FieldMetadata fieldMetadata = newField.getValue();
1421             final String key = newField.getKey();
1422 
1423             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1424 
1425             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1426                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1426                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1427                     Class&lt;?&gt; validatorImpl = null;
1428 
1429                     try {
1430                         validatorImpl = Class.forName(validationConfigurations.getKey());
1431                     } catch (ClassNotFoundException e) {
1432                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1433 
1434                         if (bean != null) {
1435                             validatorImpl = bean.getClass();
1436                         }
1437                     }
1438 
<abbr title="1439                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1439                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1440                         for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1441                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1442                                 final String value = config.getValue();
1443 
1444                                 if (newFields.containsKey(value)) {
1445                                     config.setValue(propertyName + &quot;.&quot; + value);
1446                                 }
1447                             }
1448                         }
1449                     }
1450                 }
1451             }
1452 
1453             if (isForeignKey(fieldMetadata)) {
1454                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1455             }
1456         }
1457 
1458         fields.putAll(convertedFields);
1459     }
1460 
1461     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1462         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1463                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1463                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePðŸ”µ</abbr>
<abbr title="1464                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1464                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
1465     }
1466 
1467     /*
1468      * There may be multiple pathways to this foreign key which may have come from a cached source.
1469      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1470      * to make sure it is set appropriately here.
1471      *
1472      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1473      * owningSite.embeddableMultitenantSite.adminUsers.
1474      */
<abbr title="1475     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1475     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1476         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1476         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1477         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1478     }
1479 
1480     protected void buildComponentProperties(
1481             Class&lt;?&gt; targetClass,
1482             ForeignKey foreignField,
1483             ForeignKey[] additionalForeignFields,
1484             String[] additionalNonPersistentProperties,
1485             MergedPropertyType mergedPropertyType,
1486             Map&lt;String, FieldMetadata&gt; fields,
1487             String idProperty,
1488             Boolean populateManyToOneFields,
1489             String[] includeFields,
1490             String[] excludeFields,
1491             String configurationKey,
1492             String ceilingEntityFullyQualifiedClassname,
1493             String propertyName,
1494             Type type,
1495             Class&lt;?&gt; returnedClass,
1496             List&lt;Class&lt;?&gt;&gt; parentClasses,
1497             Boolean isParentExcluded,
1498             String prefix,
1499             String parentPrefix) {
1500         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1501         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1502         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1503         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1504         String tempPrefix = &quot;&quot;;
1505 
1506         int pos = prefix.indexOf(&quot;.&quot;);
1507         final int prefixLength = prefix.length();
1508 
1509         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1510             //only use part of the prefix if it&#x27;s more than one layer deep
1511             tempPrefix = prefix.substring(pos + 1, prefixLength);
1512         }
1513 
<abbr title="1514         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1514         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1515 
1516         if (isParentExcluded) {
1517             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1518                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1518                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1519                 componentPresentationAttributes.get(key).setExcluded(true);
1520             }
1521         }
1522 
1523         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1524         Property property;
1525 
1526         try {
1527             property = persistentClass.getProperty(propertyName);
1528         } catch (MappingException e) {
1529             property = persistentClass.getProperty(prefix + propertyName);
1530         }
1531 
<abbr title="1532         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1532         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1533         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1534 
1535         while (componentPropertyIterator.hasNext()) {
1536             componentPropertyList.add((Property) componentPropertyIterator.next());
1537         }
1538 
1539         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1540         buildProperties(
1541                 targetClass,
1542                 foreignField,
1543                 additionalForeignFields,
1544                 additionalNonPersistentProperties,
1545                 mergedPropertyType,
1546                 componentPresentationAttributes,
1547                 componentPropertyList,
1548                 newFields,
1549                 componentPropertyNames,
1550                 componentPropertyTypes,
1551                 idProperty,
1552                 populateManyToOneFields,
1553                 includeFields,
1554                 excludeFields,
1555                 configurationKey,
1556                 ceilingEntityFullyQualifiedClassname,
1557                 parentClasses,
1558                 propertyName + &quot;.&quot;,
1559                 isParentExcluded,
1560                 true,
1561                 parentPrefix + prefix
1562         );
1563 
1564         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1565 
1566         for (String key : newFields.keySet()) {
1567             final FieldMetadata fieldMetadata = newFields.get(key);
1568             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1569 
1570             if (isForeignKey(fieldMetadata)) {
1571                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1572             }
1573         }
1574         fields.putAll(convertedFields);
1575     }
1576 
1577     @Override
1578     public EntityManager getStandardEntityManager() {
1579         return standardEntityManager;
1580     }
1581 
1582     @Override
1583     public void setStandardEntityManager(EntityManager entityManager) {
1584         this.standardEntityManager = entityManager;
1585     }
1586 
1587     @Override
1588     public FieldManager getFieldManager() {
1589 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1590         return new FieldManager(entityConfiguration, getStandardEntityManager());</span>
1591 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1592     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1593     public EntityManager getStandardEntityManager() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1594         return standardEntityManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1595     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1596 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1597     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1598     public void setStandardEntityManager(EntityManager entityManager) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1599         this.standardEntityManager = entityManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1600         fieldManager = new FieldManager(entityConfiguration, entityManager);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1601     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1602 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1603     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1604     public EJB3ConfigurationDao getEjb3ConfigurationDao() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1605         return ejb3ConfigurationDao;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1606     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1607 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1608     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1609     public void setEjb3ConfigurationDao(EJB3ConfigurationDao ejb3ConfigurationDao) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1610         this.ejb3ConfigurationDao = ejb3ConfigurationDao;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1611     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1612 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1613     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1614     public FieldManager getFieldManager() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1615         if (fieldManager == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1616             //keep in mind that getStandardEntityManager() can return null, this is in general OK,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1617             // we re-init fieldManager in setStandardEntityManager method</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1618             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1619         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1620             fieldManager.clearMiddleFields();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1621         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1622         return fieldManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1623     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1624 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1625     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1626     public EntityConfiguration getEntityConfiguration() {</span>
1627 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1628         return this.getFieldManager(true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1629     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1630 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1631     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1632     public FieldManager getFieldManager(boolean cleanFieldManager) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1633         if (fieldManager == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1634             //keep in mind that getStandardEntityManager() can return null, this is in general OK,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1635             // we re-init fieldManager in setStandardEntityManager method</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1636             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1637         } else if (cleanFieldManager){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1638             fieldManager.clearMiddleFields();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1639         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1640         return fieldManager;</span>
1641 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1642     }
1643 
1644     @Override
1645     public EntityConfiguration getEntityConfiguration() {
1646         return entityConfiguration;
1647     }
1648 
1649     @Override
1650     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1651         this.entityConfiguration = entityConfiguration;
1652     }
1653 
1654     @Override
1655     public Metadata getMetadata() {
1656         return metadata;
1657     }
1658 
1659     @Override
1660     public void setMetadata(Metadata metadata) {
1661         this.metadata = metadata;
1662     }
1663 
1664     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1665         return fieldMetadataProviders;
1666     }
1667 
1668     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1669         this.fieldMetadataProviders = fieldMetadataProviders;
1670     }
1671 
1672     @Override
1673     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1674         return defaultFieldMetadataProvider;
1675     }
1676 
1677     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1678         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1679     }
1680 
1681     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1682         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1683     }
1684 
1685     @Override
1686     public DynamicDaoHelper getDynamicDaoHelper() {
1687         return dynamicDaoHelper;
1688     }
1689 
1690     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1691         this.dynamicDaoHelper = dynamicDaoHelper;
1692     }
1693 
1694 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 
  21 import org.apache.commons.collections4.map.LRUMap;
  22 import org.apache.commons.lang.StringUtils;
  23 import org.apache.commons.lang3.ArrayUtils;
  24 import org.apache.commons.logging.Log;
  25 import org.apache.commons.logging.LogFactory;
  26 import org.broadleafcommerce.common.money.Money;
  27 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28 import org.broadleafcommerce.common.persistence.Status;
  29 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  36 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  37 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  38 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  39 import org.broadleafcommerce.openadmin.dto.ClassTree;
  40 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  41 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  42 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  43 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  44 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  45 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  47 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  48 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  49 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  50 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  51 import org.hibernate.Criteria;
  52 import org.hibernate.MappingException;
  53 import org.hibernate.Session;
  54 import org.hibernate.mapping.PersistentClass;
  55 import org.hibernate.mapping.Property;
  56 import org.hibernate.type.ComponentType;
  57 import org.hibernate.type.Type;
  58 import org.springframework.beans.BeansException;
  59 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  60 import org.springframework.beans.factory.annotation.Value;
  61 import org.springframework.context.ApplicationContext;
  62 import org.springframework.context.ApplicationContextAware;
  63 import org.springframework.context.annotation.Scope;
  64 import org.springframework.core.annotation.AnnotationUtils;
  65 import org.springframework.stereotype.Component;
  66 
  67 import java.io.Serializable;
  68 import java.lang.reflect.Field;
  69 import java.lang.reflect.Method;
  70 import java.lang.reflect.Modifier;
  71 import java.math.BigDecimal;
  72 import java.math.BigInteger;
  73 import java.security.MessageDigest;
  74 import java.security.NoSuchAlgorithmException;
  75 import java.util.ArrayList;
  76 import java.util.Arrays;
  77 import java.util.Collections;
  78 import java.util.Comparator;
  79 import java.util.Date;
  80 import java.util.HashMap;
  81 import java.util.HashSet;
  82 import java.util.Iterator;
  83 import java.util.List;
  84 import java.util.Map;
  85 import java.util.Set;
  86 
  87 import javax.annotation.Nonnull;
  88 import javax.annotation.Resource;
  89 import javax.persistence.EntityManager;
  90 import javax.persistence.criteria.CriteriaBuilder;
  91 import javax.persistence.criteria.CriteriaQuery;
  92 import javax.persistence.criteria.Path;
  93 import javax.persistence.criteria.Predicate;
  94 import javax.persistence.criteria.Root;
  95 
  96 /**
  97  * @author jfischer
  98  */
  99 @Component(&quot;blDynamicEntityDao&quot;)
 100 @Scope(&quot;prototype&quot;)
 101 public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 102 
 103     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 104 
 105     protected static final Map&lt;String,Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 106 
 107     /**
<abbr title=" 108      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 108      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 109      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 109      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 110      * counts in METADATA_CACHE as a result of cache eviction
 111      */
 112     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 113 
 114     /*
<abbr title=" 115      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 115      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 116      * from polymorphism
 117      */
 118 
 119     protected EntityManager standardEntityManager;
 120 
 121     @Resource(name=&quot;blMetadata&quot;)
 122     protected Metadata metadata;
 123 
 124     @Resource(name=&quot;blEntityConfiguration&quot;)
 125     protected EntityConfiguration entityConfiguration;
 126 
 127     @Resource(name=&quot;blFieldMetadataProviders&quot;)
 128     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 129 
 130     @Resource(name= &quot;blDefaultFieldMetadataProvider&quot;)
 131     protected FieldMetadataProvider defaultFieldMetadataProvider;
 132 
 133     @Resource(name = &quot;blAppConfigurationMap&quot;)
 134     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 135 
 136     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 137 
 138     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 139     protected int cacheEntityMetaDataTtl;
 140 
 141     /**
<abbr title=" 142      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 142      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 143      */
 144     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 145     protected boolean validateMetadataCacheSizes;
 146 
 147     protected long lastCacheFlushTime = System.currentTimeMillis();
 148 
 149     protected ApplicationContext applicationContext;
 150 
 151     @Override
 152     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 153         this.applicationContext = applicationContext;
 154     }
 155 
 156     @Override
 157     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 158         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 159     }
 160 
 161     @Override
 162     public &lt;T&gt; T persist(T entity) {
 163         standardEntityManager.persist(entity);
 164         standardEntityManager.flush();
 165         return entity;
 166     }
 167 
 168     @Override
 169     public Object find(Class&lt;?&gt; entityClass, Object key) {
 170         return standardEntityManager.find(entityClass, key);
 171     }
 172 
 173     @Override
 174     public &lt;T&gt; T merge(T entity) {
 175         T response = standardEntityManager.merge(entity);
 176         standardEntityManager.flush();
 177         return response;
 178     }
 179 
 180     @Override
 181     public void flush() {
 182         standardEntityManager.flush();
 183     }
 184 
 185     @Override
 186     public void detach(Serializable entity) {
 187         standardEntityManager.detach(entity);
 188     }
 189 
 190     @Override
 191     public void refresh(Serializable entity) {
 192         standardEntityManager.refresh(entity);
 193     }
 194 
 195     @Override
 196     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 197         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 198     }
 199 
 200     @Override
 201     public void remove(Serializable entity) {
 202         standardEntityManager.remove(entity);
 203         standardEntityManager.flush();
 204     }
 205 
 206     @Override
 207     public void clear() {
 208         standardEntityManager.clear();
 209     }
 210 
 211     @Override
 212     public PersistentClass getPersistentClass(String targetClassName) {
 213         return HibernateMappingProvider.getMapping(targetClassName);
 214     }
 215 
 216     @Override
 217     public boolean useCache() {
 218         if (cacheEntityMetaDataTtl &lt; 0) {
 219             return true;
 220         }
 221         if (cacheEntityMetaDataTtl == 0) {
 222             return false;
 223         } else {
 224             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 225                 lastCacheFlushTime = System.currentTimeMillis();
 226                 METADATA_CACHE.clear();
 227                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 228                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 229                 LOG.trace(&quot;Metadata cache evicted&quot;);
 230                 return true; // cache is empty
 231             } else {
 232                 return true;
 233             }
 234         }
 235     }
 236 
 237     @Override
 238     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 239         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 240     }
 241 
 242     @Override
<abbr title=" 243     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 243     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
<abbr title=" 244         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 244         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr>
 245     }
 246 
 247     @Override
 248     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 249         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 250     }
 251 
 252     @Override
 253     public Class&lt;?&gt; getImplClass(String className) {
 254         Class&lt;?&gt; clazz = null;
 255         try {
 256             clazz = entityConfiguration.lookupEntityClass(className);
 257         } catch (NoSuchBeanDefinitionException e) {
 258             //do nothing
 259         }
 260         if (clazz == null) {
 261             try {
 262                 clazz = Class.forName(className);
 263             } catch (ClassNotFoundException e) {
 264                 throw new RuntimeException(e);
 265             }
 266             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 267         }
 268         return clazz;
 269     }
 270 
 271     @Override
 272     public Class&lt;?&gt; getCeilingImplClass(String className) {
 273         Class&lt;?&gt; clazz;
 274         try {
 275             clazz = Class.forName(className);
 276         } catch (ClassNotFoundException e) {
 277             throw new RuntimeException(e);
 278         }
 279         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 280         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 281             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 282             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 283         }
 284         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 285             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 285             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 286         }
 287         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 288         return clazz;
 289     }
 290 
 291     @Override
<abbr title=" 292     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 292     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 293         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 293         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 294         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 295         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 296         Root root = criteria.from(clazz);
 297         Path idField = root.get(this.getIdField(clazz).getName());
 298         criteria.select(idField.as(Long.class));
 299         List&lt;Predicate&gt; restrictions = new ArrayList();
 300 
 301         Path path = null;
 302 
 303         // Support property name such as &quot;defaultSku.name&quot;
 304         if (propertyName.contains(&quot;.&quot;)) {
 305             String[] split = propertyName.split(&quot;\\.&quot;);
 306             for (String splitResult : split) {
 307                 if (path == null) {
 308                     path = root.get(splitResult);
 309                 } else {
 310                     path = path.get(splitResult);
 311                 }
 312             }
 313         } else {
 314             path = root.get(propertyName);
 315         }
 316 
 317         restrictions.add(builder.equal(path, value));
 318         Serializable identifier = this.getIdentifier(instance);
 319         //when we creating the new item identifier is not exists
 320         if(identifier != null) {
 321             restrictions.add(builder.notEqual(idField, identifier));
 322         }
 323 
 324         if (instance instanceof Status) {
<abbr title=" 325             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 325             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 326         }
 327 
 328         criteria.where((Predicate[]) restrictions.toArray(new Predicate[restrictions.size()]));
 329         return this.standardEntityManager.createQuery(criteria).getResultList();
 330     }
 331 
 332     @Override
 333     public Serializable getIdentifier(Object entity) {
 334         return dynamicDaoHelper.getIdentifier(entity);
 335     }
 336 
 337     protected Field getIdField(Class&lt;?&gt; clazz) {
 338         return dynamicDaoHelper.getIdField(clazz);
 339     }
 340 
 341     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 342         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 343     }
 344 
 345     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 346         Class&lt;?&gt; testClass;
 347         try {
 348             testClass = Class.forName(tree.getFullyQualifiedClassname());
 349         } catch (ClassNotFoundException e) {
 350             throw new RuntimeException(e);
 351         }
 352         if (clazz.equals(testClass)) {
 353             return;
 354         }
 355         if (clazz.getSuperclass().equals(testClass)) {
 356             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 357             createClassTreeFromAnnotation(clazz, myTree);
 358             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 359         } else {
 360             for (ClassTree child : tree.getChildren()) {
 361                 addClassToTree(clazz, child);
 362             }
 363         }
 364     }
 365 
 366     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 367         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 367         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 368         if (classPresentation != null) {
 369             String friendlyName = classPresentation.friendlyName();
 370             if (!StringUtils.isEmpty(friendlyName)) {
 371                 myTree.setFriendlyName(friendlyName);
 372             }
 373         }
 374     }
 375 
 376     @Override
 377     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 378         String ceilingClass = null;
 379         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 380             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 380             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 381             if (classPresentation != null) {
 382                String ceilingEntity = classPresentation.ceilingDisplayEntity();
 383                 if (!StringUtils.isEmpty(ceilingEntity)) {
 384                     ceilingClass = ceilingEntity;
 385                     break;
 386                 }
 387             }
 388         }
 389         if (ceilingClass != null) {
 390             int pos = -1;
 391             int j = 0;
 392             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 393                 if (clazz.getName().equals(ceilingClass)) {
 394                     pos = j;
 395                     break;
 396                 }
 397                 j++;
 398             }
 399             if (pos &gt;= 0) {
 400                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 401                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 402                 polymorphicClasses = temp;
 403             }
 404         }
 405 
 406         ClassTree classTree = null;
 407         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 408             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length-1];
 409             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 410             createClassTreeFromAnnotation(topClass, classTree);
 411             for (int j=polymorphicClasses.length-1; j &gt;= 0; j--) {
 412                 addClassToTree(polymorphicClasses[j], classTree);
 413             }
 414             classTree.finalizeStructure(1);
 415         }
 416         return classTree;
 417     }
 418 
 419     @Override
 420     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 421         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 422         return getClassTree(sortedEntities);
 423     }
 424 
 425     @Override
<abbr title=" 426     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 426     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 427         Class&lt;?&gt;[] entityClasses;
 428         try {
 429             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 430         } catch (ClassNotFoundException e) {
 431             throw new RuntimeException(e);
 432         }
 433         if (!ArrayUtils.isEmpty(entityClasses)) {
 434             return getMergedProperties(
 435                 entityName,
 436                 entityClasses,
<abbr title=" 437                 (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 437                 (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspðŸ”µ</abbr>
 438                 persistencePerspective.getAdditionalNonPersistentProperties(),
 439                 persistencePerspective.getAdditionalForeignKeys(),
 440                 MergedPropertyType.PRIMARY,
 441                 persistencePerspective.getPopulateToOneFields(),
 442                 persistencePerspective.getIncludeFields(),
 443                 persistencePerspective.getExcludeFields(),
 444                 persistencePerspective.getConfigurationKey(),
 445                 &quot;&quot;
 446             );
 447         } else {
 448             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 449             Class&lt;?&gt; targetClass;
 450             try {
 451                 targetClass = Class.forName(entityName);
 452             } catch (ClassNotFoundException e) {
 453                 throw new RuntimeException(e);
 454             }
<abbr title=" 455             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 455             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 456             for (String property : attributesMap.keySet()) {
 457                 FieldMetadata presentationAttribute = attributesMap.get(property);
 458                 if (!presentationAttribute.getExcluded()) {
 459                     Field field = FieldManager.getSingleField(targetClass, property);
 460                     if (!Modifier.isStatic(field.getModifiers())) {
 461                         boolean handled = false;
 462                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 463                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 464                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 464                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 465                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 466                                             property, null, false, 0, attributesMap, presentationAttribute,"> 466                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 467                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 467                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 468                                             mergedProperties);
 469                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 470                                 handled = true;
 471                             }
 472                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 473                                 break;
 474                             }
 475                         }
 476                         if (!handled) {
<abbr title=" 477                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 477                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 478                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 478                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 479                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 480                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 480                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 481                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 482                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 482                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 483                                             field.getType(), this), mergedProperties);
 484                         }
 485                     }
 486                 }
 487             }
 488 
 489             return mergedProperties;
 490         }
 491     }
 492 
 493     @Override
 494     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 495         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 496         return getMergedProperties(
 497                 cls.getName(),
 498                 polymorphicTypes,
 499                 null,
 500                 new String[] {},
 501                 new ForeignKey[] {},
 502                 MergedPropertyType.PRIMARY,
 503                 true,
 504                 new String[] {},
 505                 new String[] {},
 506                 null,
 507                 &quot;&quot;
 508                 );
 509     }
 510 
 511     @Override
 512     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 513             String ceilingEntityFullyQualifiedClassname,
 514             Class&lt;?&gt;[] entities,
 515             ForeignKey foreignField,
 516             String[] additionalNonPersistentProperties,
 517             ForeignKey[] additionalForeignFields,
 518             MergedPropertyType mergedPropertyType,
 519             Boolean populateManyToOneFields,
 520             String[] includeFields,
 521             String[] excludeFields,
 522             String configurationKey,
 523             String prefix) {
 524         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 525                 ceilingEntityFullyQualifiedClassname,
 526                 entities,
 527                 foreignField,
 528                 additionalNonPersistentProperties,
 529                 additionalForeignFields,
 530                 mergedPropertyType,
 531                 populateManyToOneFields,
 532                 includeFields,
 533                 excludeFields,
 534                 configurationKey,
 535                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 536                 prefix,
 537                 false,
 538                 &quot;&quot;);
 539 
 540         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 541 
 542         for (final String key : mergedProperties.keySet()) {
<abbr title=" 543             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 543             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 544                 removeKeys.add(key);
 545             }
 546         }
 547 
 548         for (String removeKey : removeKeys) {
 549             mergedProperties.remove(removeKey);
 550         }
 551 
<abbr title=" 552         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 552         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 553         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 553         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 554         // like properties gleaned from reflection typically are.
 555         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 556         for (Class&lt;?&gt; targetClass : entities) {
 557             for (String key : keys) {
<abbr title=" 558                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 558                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 559 
 560                 boolean foundOneOrMoreHandlers = false;
 561                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 562                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 562                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 563                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 564                         foundOneOrMoreHandlers = true;
 565                     }
 566                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 567                         break;
 568                     }
 569                 }
 570                 if (!foundOneOrMoreHandlers) {
 571                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 572                 }
 573             }
 574         }
 575 
 576         return mergedProperties;
 577     }
 578 
 579     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 580             final String ceilingEntityFullyQualifiedClassname,
 581             final Class&lt;?&gt;[] entities,
 582             final ForeignKey foreignField,
 583             final String[] additionalNonPersistentProperties,
 584             final ForeignKey[] additionalForeignFields,
 585             final MergedPropertyType mergedPropertyType,
 586             final Boolean populateManyToOneFields,
 587             final String[] includeFields,
 588             final String[] excludeFields,
 589             final String configurationKey,
 590             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 591             final String prefix,
 592             final Boolean isParentExcluded,
 593             final String parentPrefix) {
 594         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 595             @Override
 596             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 597                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 598                 Boolean classAnnotatedPopulateManyToOneFields;
 599                 if (overridePopulateManyToOne != null) {
 600                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 601                 } else {
 602                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 603                 }
 604 
 605                 buildPropertiesFromPolymorphicEntities(
 606                     entities,
 607                     foreignField,
 608                     additionalNonPersistentProperties,
 609                     additionalForeignFields,
 610                     mergedPropertyType,
 611                     classAnnotatedPopulateManyToOneFields,
 612                     includeFields,
 613                     excludeFields,
 614                     configurationKey,
 615                     ceilingEntityFullyQualifiedClassname,
 616                     mergedProperties,
 617                     parentClasses,
 618                     prefix,
 619                     isParentExcluded,
 620                     parentPrefix);
 621 
 622                 return mergedProperties;
 623             }
 624         };
 625 
<abbr title=" 626         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 626         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 627         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 627         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 628         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 629 
 630         return mergedProperties;
 631     }
 632 
<abbr title=" 633     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 633     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 634         for (String key : mergedProperties.keySet()) {
 635             boolean isForeign = false;
 636             if (foreignField != null) {
 637                 isForeign = foreignField.getManyToField().equals(key);
 638             }
 639             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 640                 for (ForeignKey foreignKey : additionalForeignFields) {
 641                     isForeign = foreignKey.getManyToField().equals(key);
 642                     if (isForeign) {
 643                         break;
 644                     }
 645                 }
 646             }
 647             if (isForeign) {
 648                 FieldMetadata metadata = mergedProperties.get(key);
 649                 metadata.setExcluded(false);
 650             }
 651         }
 652     }
 653 
<abbr title=" 654     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 654     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 655         //check includes
 656         if (!ArrayUtils.isEmpty(includeFields)) {
 657             for (String include : includeFields) {
 658                 for (String key : mergedProperties.keySet()) {
 659                     String testKey = prefix + key;
 660                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 661                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 662                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 662                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 663                         metadata.setExcluded(true);
 664                     } else {
 665                         FieldMetadata metadata = mergedProperties.get(key);
 666                         if (!isParentExcluded) {
<abbr title=" 667                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 667                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 668                             metadata.setExcluded(false);
 669                         }
 670                     }
 671                 }
 672             }
 673         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 674             //check excludes
 675             for (String exclude : excludeFields) {
 676                 for (String key : mergedProperties.keySet()) {
 677                     String testKey = prefix + key;
 678                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 679                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 680                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 680                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 681                         metadata.setExcluded(true);
 682                     } else {
 683                         FieldMetadata metadata = mergedProperties.get(key);
 684                         if (!isParentExcluded) {
<abbr title=" 685                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 685                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 686                             metadata.setExcluded(false);
 687                         }
 688                     }
 689                 }
 690             }
 691         }
 692     }
 693 
 694     protected String pad(String s, int length, char pad) {
 695         StringBuilder buffer = new StringBuilder(s);
 696         while (buffer.length() &lt; length) {
 697             buffer.insert(0, pad);
 698         }
 699         return buffer.toString();
 700     }
 701 
<abbr title=" 702     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 702     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 703         StringBuilder sb = new StringBuilder(150);
 704         sb.append(ceilingEntityFullyQualifiedClassname);
 705         sb.append(clazz.hashCode());
 706         sb.append(foreignField==null?&quot;&quot;:foreignField.toString());
 707         sb.append(configurationKey);
 708         sb.append(isParentExcluded);
 709         if (additionalNonPersistentProperties != null) {
 710             for (String prop : additionalNonPersistentProperties) {
 711                 sb.append(prop);
 712             }
 713         }
 714         if (additionalForeignFields != null) {
 715             for (ForeignKey key : additionalForeignFields) {
 716                 sb.append(key.toString());
 717             }
 718         }
 719         sb.append(mergedPropertyType);
 720         sb.append(populateManyToOneFields);
 721 
 722         String digest;
 723         try {
 724             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 725             byte[] messageDigest = md.digest(sb.toString().getBytes());
 726             BigInteger number = new BigInteger(1,messageDigest);
 727             digest = number.toString(16);
 728         } catch(NoSuchAlgorithmException e) {
 729             throw new RuntimeException(e);
 730         }
 731 
 732         String key = pad(digest, 32, &#x27;0&#x27;);
 733 
 734         if (LOG.isDebugEnabled()) {
 735             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 736         }
 737         return key;
 738     }
 739 
 740     protected void buildPropertiesFromPolymorphicEntities(
 741             Class&lt;?&gt;[] entities,
 742             ForeignKey foreignField,
 743             String[] additionalNonPersistentProperties,
 744             ForeignKey[] additionalForeignFields,
 745             MergedPropertyType mergedPropertyType,
 746             Boolean populateManyToOneFields,
 747             String[] includeFields,
 748             String[] excludeFields,
 749             String configurationKey,
 750             String ceilingEntityFullyQualifiedClassname,
 751             Map&lt;String, FieldMetadata&gt; mergedProperties,
 752             List&lt;Class&lt;?&gt;&gt; parentClasses,
 753             String prefix,
 754             Boolean isParentExcluded,
 755             String parentPrefix) {
 756         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 757             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 757             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 758 
 759             Map&lt;String, FieldMetadata&gt; cacheData = null;
 760             synchronized(DynamicDaoHelperImpl.LOCK_OBJECT) {
 761                 if (useCache()) {
 762                     cacheData = METADATA_CACHE.get(cacheKey);
 763                 }
 764 
 765                 if (cacheData == null) {
 766                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 767                         clazz,
 768                         foreignField,
 769                         additionalNonPersistentProperties,
 770                         additionalForeignFields,
 771                         mergedPropertyType,
 772                         populateManyToOneFields,
 773                         includeFields,
 774                         excludeFields,
 775                         configurationKey,
 776                         ceilingEntityFullyQualifiedClassname,
 777                         parentClasses,
 778                         prefix,
 779                         isParentExcluded,
 780                         parentPrefix);
<abbr title=" 781                     //first check all the properties currently in there to see if my entity inherits from them"> 781                     //first check all the properties currently in there to see if my entity inherits fromðŸ”µ</abbr>
 782                     for (Class&lt;?&gt; clazz2 : entities) {
 783                         if (!clazz2.getName().equals(clazz.getName())) {
 784                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 785                                 FieldMetadata metadata = entry.getValue();
 786                                 try {
<abbr title=" 787                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 787                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 788                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 788                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 789                                         metadata.setAvailableToTypes(both);
 790                                     }
 791                                 } catch (ClassNotFoundException e) {
 792                                     throw new RuntimeException(e);
 793                                 }
 794                             }
 795                         }
 796                     }
 797                     METADATA_CACHE.put(cacheKey, props);
 798 
 799                     if (LOG.isTraceEnabled()) {
<abbr title=" 800                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 800                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKeyðŸ”µ</abbr>
 801                     }
 802 
 803                     if (validateMetadataCacheSizes) {
 804                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 805                         Integer currentSize = props.size();
 806                         if (previousSize == null) {
 807                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 808                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 809                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 809                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache ðŸ”µ</abbr>
 810                             LOG.error(msg);
 811                             throw new RuntimeException(msg);
 812                         }
 813                     }
 814 
 815                     cacheData = props;
 816                 } else {
 817                     if (LOG.isTraceEnabled()) {
<abbr title=" 818                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 818                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheðŸ”µ</abbr>
 819                     }
 820                 }
 821             }
 822             //clone the metadata before passing to the system
 823             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 824             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 825                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 826             }
 827             mergedProperties.putAll(clonedCache);
 828         }
 829     }
 830 
 831     @Override
 832     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 833         Field[] allFields = new Field[]{};
 834         boolean eof = false;
 835         Class&lt;?&gt; currentClass = targetClass;
 836         while (!eof) {
 837             Field[] fields = currentClass.getDeclaredFields();
 838             allFields = ArrayUtils.addAll(allFields, fields);
 839             if (currentClass.getSuperclass() != null) {
 840                 currentClass = currentClass.getSuperclass();
 841             } else {
 842                 eof = true;
 843             }
 844         }
 845 
 846         return allFields;
 847     }
 848 
 849     @Override
 850     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 851         String propertyName,
 852         String friendlyPropertyName,
 853         Class&lt;?&gt; targetClass,
 854         Class&lt;?&gt; parentClass,
 855         MergedPropertyType mergedPropertyType
 856     ) {
 857         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 858         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 859         presentationAttribute.setFriendlyName(friendlyPropertyName);
 860         if (String.class.isAssignableFrom(targetClass)) {
 861             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 862             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 863             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 863             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 864         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 865             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 866             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 867             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 867             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 868         } else if (Date.class.isAssignableFrom(targetClass)) {
 869             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 870             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 871             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 871             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 872         } else if (Money.class.isAssignableFrom(targetClass)) {
 873             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 874             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 875             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 875             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 876         } else if (
 877                 Byte.class.isAssignableFrom(targetClass) ||
 878                 Integer.class.isAssignableFrom(targetClass) ||
 879                 Long.class.isAssignableFrom(targetClass) ||
 880                 Short.class.isAssignableFrom(targetClass)
 881             ) {
 882             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 883             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 884             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 884             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 885         } else if (
 886                 Double.class.isAssignableFrom(targetClass) ||
 887                 BigDecimal.class.isAssignableFrom(targetClass)
 888             ) {
 889             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 890             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 891             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 891             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 892         }
 893         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 894         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 895         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 896         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 897         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 898         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 899 
 900         return fields;
 901     }
 902 
 903     @Override
 904     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 905         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 906     }
 907 
 908     @Override
 909     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 910         return dynamicDaoHelper.getPropertyNames(entityClass);
 911     }
 912 
 913     @Override
 914     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 915         return dynamicDaoHelper.getPropertyTypes(entityClass);
 916     }
 917 
 918     @Override
 919     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 920         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length-1]);
 921 
<abbr title=" 922         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 922         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 923         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 924         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 925 
 926         return mergedTabAndGroupMetadata;
 927     }
 928 
 929     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 930         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 931 
 932         if (ceilingEntity != null) {
 933             entities = ArrayUtils.add(entities, ceilingEntity);
 934             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 935                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 936                 ceilingEntity = ceilingEntity.getSuperclass();
 937             }
 938         }
 939         return entities;
 940     }
 941 
 942     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 943             Class&lt;?&gt; targetClass,
 944             ForeignKey foreignField,
 945             String[] additionalNonPersistentProperties,
 946             ForeignKey[] additionalForeignFields,
 947             MergedPropertyType mergedPropertyType,
 948             Boolean populateManyToOneFields,
 949             String[] includeFields,
 950             String[] excludeFields,
 951             String configurationKey,
 952             String ceilingEntityFullyQualifiedClassname,
 953             List&lt;Class&lt;?&gt;&gt; parentClasses,
 954             String prefix,
 955             Boolean isParentExcluded,
 956             String parentPrefix) {
<abbr title=" 957         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 957         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
 958         if (isParentExcluded) {
 959             for (String key : presentationAttributes.keySet()) {
<abbr title=" 960                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);"> 960                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
 961                 presentationAttributes.get(key).setExcluded(true);
 962             }
 963         }
 964 
 965         Map idMetadata = getIdMetadata(targetClass);
 966         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 967         String idProperty = (String) idMetadata.get(&quot;name&quot;);
 968         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 969         propertyNames.add(idProperty);
 970         Type idType = (Type) idMetadata.get(&quot;type&quot;);
 971         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 972         propertyTypes.add(idType);
 973 
 974         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
 975         Iterator testIter = persistentClass.getPropertyIterator();
 976         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
 977 
 978         //check the properties for problems
 979         while(testIter.hasNext()) {
 980             Property property = (Property) testIter.next();
 981             if (property.getName().contains(&quot;.&quot;)) {
<abbr title=" 982                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);"> 982                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
 983             }
 984             propertyList.add(property);
 985         }
 986 
 987         buildProperties(
 988             targetClass,
 989             foreignField,
 990             additionalForeignFields,
 991             additionalNonPersistentProperties,
 992             mergedPropertyType,
 993             presentationAttributes,
 994             propertyList,
 995             fields,
 996             propertyNames,
 997             propertyTypes,
 998             idProperty,
 999             populateManyToOneFields,
1000             includeFields,
1001             excludeFields,
1002             configurationKey,
1003             ceilingEntityFullyQualifiedClassname,
1004             parentClasses,
1005             prefix,
1006             isParentExcluded,
1007             false,
1008             parentPrefix
1009         );
1010         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1011         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1012         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1013         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1014             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1015             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1016                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1016                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1017                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1018                     //get final property if this is a dot delimited property
1019                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1020                     if (finalDotPos &gt;= 0) {
<abbr title="1021                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1021                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1022                     }
<abbr title="1023                     //check all the polymorphic types on this target class to see if the end property exists">1023                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1024                     Field testField = null;
1025                     Method testMethod = null;
1026                     for (Class&lt;?&gt; clazz : entities) {
1027                         try {
1028                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1029                             if (testMethod != null) {
1030                                 break;
1031                             }
1032                         } catch (NoSuchMethodException e) {
1033                             //do nothing - method does not exist
1034                         }
1035                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1036                         if (testField != null) {
1037                             break;
1038                         }
1039                     }
1040                     //if the property exists, add it to the metadata for this class
1041                     if (testField != null || testMethod != null) {
<abbr title="1042                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1042                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1043                     }
1044                 }
1045             }
1046         }
1047 
1048         return fields;
1049     }
1050 
1051     protected void buildProperties(
1052             Class&lt;?&gt; targetClass,
1053             ForeignKey foreignField,
1054             ForeignKey[] additionalForeignFields,
1055             String[] additionalNonPersistentProperties,
1056             MergedPropertyType mergedPropertyType,
1057             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1058             List&lt;Property&gt; componentProperties,
1059             Map&lt;String, FieldMetadata&gt; fields,
1060             List&lt;String&gt; propertyNames,
1061             List&lt;Type&gt; propertyTypes,
1062             String idProperty,
1063             Boolean populateManyToOneFields,
1064             String[] includeFields,
1065             String[] excludeFields,
1066             String configurationKey,
1067             String ceilingEntityFullyQualifiedClassname,
1068             List&lt;Class&lt;?&gt;&gt; parentClasses,
1069             String prefix,
1070             Boolean isParentExcluded,
1071             Boolean isComponentPrefix,
1072             String parentPrefix) {
1073         int j = 0;
1074         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1075             @Override
1076             public int compare(String o1, String o2) {
1077                 //check for property name equality and for map field properties
<abbr title="1078                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1078                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1079                     return 0;
1080                 }
1081                 return o1.compareTo(o2);
1082             }
1083         };
1084         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1085         Collections.sort(presentationKeyList);
1086 
1087         for (String propertyName : propertyNames) {
1088             final Type type = propertyTypes.get(j);
1089             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1090             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1090             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1091             j++;
1092             Field myField = getFieldManager().getField(targetClass, propertyName);
1093             if (myField == null) {
<abbr title="1094                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1094                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1095                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1096             }
1097             if (
1098                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1099                     isPropertyForeignKey ||
1100                     additionalForeignKeyIndexPosition &gt;= 0 ||
1101                     Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0
1102             ) {
1103                 if (myField != null) {
1104                     boolean handled = false;
1105                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1106                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1107                         if (presentationAttribute != null) {
1108                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1109                         }
1110                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1111                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1111                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1112                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1113                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1113                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1114                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1114                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1115                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1116                             handled = true;
1117                         }
1118                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1119                             break;
1120                         }
1121                     }
1122                     if (!handled) {
1123                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1124                             additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1124                             additionalNonPersistentProperties, mergedPropertyType, presentationAttributesðŸ”µ</abbr>
<abbr title="1125                             componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1125                             componentProperties, fields, idProperty, populateManyToOneFields, includeFielðŸ”µ</abbr>
<abbr title="1126                             excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1126                             excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentðŸ”µ</abbr>
<abbr title="1127                             prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1127                             prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionaðŸ”µ</abbr>
1128                     }
1129                 }
1130             }
1131         }
1132     }
1133 
1134     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1135         setExcludedBasedOnShowIfProperty(presentationAttribute);
1136 
<abbr title="1137         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1137         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1138 
1139     }
1140 
1141     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1142         if (fieldMetadata != null
1143             &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1144             &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1145             &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1146 
1147             //do not include this in the display if it returns false.
1148             fieldMetadata.setExcluded(true);
1149         }
1150     }
1151 
<abbr title="1152     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1152     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1153                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1153                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1154 
<abbr title="1155         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1155         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1156                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1157 
<abbr title="1158         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1158         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1159                 parentPrefix, propertyName);
1160 
1161         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1162     }
1163 
<abbr title="1164     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1164     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1165         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1166     }
1167 
1168     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1169             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1170             isComponentPrefix) {
1171         Boolean response = false;
1172         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1173         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1173         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1174         if (shouldTest) {
1175             Field testField = getFieldManager().getField(targetClass, propertyName);
1176             if (testField == null) {
1177                 Class&lt;?&gt;[] entities;
1178                 try {
<abbr title="1179                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1179                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1180                 } catch (ClassNotFoundException e) {
1181                     throw new RuntimeException(e);
1182                 }
1183                 for (Class&lt;?&gt; clazz : entities) {
1184                     testField = getFieldManager().getField(clazz, propertyName);
1185                     if (testField != null) {
1186                         break;
1187                     }
1188                 }
1189                 String testProperty = prefix + propertyName;
1190                 if (testField == null) {
1191                     testField = getFieldManager().getField(targetClass, testProperty);
1192                 }
1193                 if (testField == null) {
1194                     for (Class&lt;?&gt; clazz : entities) {
1195                         testField = getFieldManager().getField(clazz, testProperty);
1196                         if (testField != null) {
1197                             break;
1198                         }
1199                     }
1200                 }
1201             }
1202             response = determineExclusionForField(parentClasses, targetClass, testField);
1203         }
1204         return response;
1205     }
1206 
<abbr title="1207     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1207     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1208         Boolean response = false;
1209         if (testField != null) {
1210             Class&lt;?&gt; testType = testField.getType();
1211             for (Class&lt;?&gt; parentClass : parentClasses) {
1212                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1213                     response = true;
1214                     break;
1215                 }
1216             }
<abbr title="1217             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1217             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1218                 response = true;
1219             }
1220         }
1221         return response;
1222     }
1223 
1224     protected void buildBasicProperty(
1225             Field field,
1226             Class&lt;?&gt; targetClass,
1227             ForeignKey foreignField,
1228             ForeignKey[] additionalForeignFields,
1229             String[] additionalNonPersistentProperties,
1230             MergedPropertyType mergedPropertyType,
1231             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1232             List&lt;Property&gt; componentProperties,
1233             Map&lt;String, FieldMetadata&gt; fields,
1234             String idProperty,
1235             Boolean populateManyToOneFields,
1236             String[] includeFields,
1237             String[] excludeFields,
1238             String configurationKey,
1239             String ceilingEntityFullyQualifiedClassname,
1240             List&lt;Class&lt;?&gt;&gt; parentClasses,
1241             String prefix,
1242             Boolean isParentExcluded,
1243             String propertyName,
1244             Type type,
1245             boolean propertyForeignKey,
1246             int additionalForeignKeyIndexPosition,
1247             Boolean isComponentPrefix,
1248             String parentPrefix) {
1249         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1250         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1251         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1252             ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1253 
1254         SupportedFieldType explicitType = null;
1255         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1256             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1257         }
1258         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1259         checkProp:
1260         {
1261             if (type.isComponentType() &amp;&amp; includeField) {
1262                 buildComponentProperties(
1263                     targetClass,
1264                     foreignField,
1265                     additionalForeignFields,
1266                     additionalNonPersistentProperties,
1267                     mergedPropertyType,
1268                     fields,
1269                     idProperty,
1270                     populateManyToOneFields,
1271                     includeFields,
1272                     excludeFields,
1273                     configurationKey,
1274                     ceilingEntityFullyQualifiedClassname,
1275                     propertyName,
1276                     type,
1277                     returnedClass,
1278                     parentClasses,
1279                     amIExcluded,
1280                     prefix,
1281                         parentPrefix);
1282                 break checkProp;
1283             }
1284             /*
1285              * Currently we do not support ManyToOne fields whose class type is the same
1286              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1287              */
1288             if (
1289                 type.isEntityType() &amp;&amp;
1290                 !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1291                 populateManyToOneFields &amp;&amp;
1292                 includeField
1293             ) {
1294                 buildEntityProperties(
1295                     fields,
1296                     foreignField,
1297                     additionalForeignFields,
1298                     additionalNonPersistentProperties,
1299                     populateManyToOneFields,
1300                     includeFields,
1301                     excludeFields,
1302                     configurationKey,
1303                     ceilingEntityFullyQualifiedClassname,
1304                     propertyName,
1305                     returnedClass,
1306                     targetClass,
1307                     parentClasses,
1308                     prefix,
1309                     amIExcluded,
1310                     parentPrefix
1311                 );
1312                 break checkProp;
1313             }
1314         }
1315         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1316         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1317             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1318                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1318                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1319                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1319                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1320                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1320                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1321                             presentationAttribute, explicitType, returnedClass, this), fields);
1322         }
1323     }
1324 
1325     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1326         boolean isPropertyForeignKey = false;
1327         if (foreignField != null) {
1328             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1329         }
1330         return isPropertyForeignKey;
1331     }
1332 
<abbr title="1333     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1333     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1334         int additionalForeignKeyIndexPosition = -1;
1335         if (additionalForeignFields != null) {
<abbr title="1336             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1336             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1337                 @Override
1338                 public int compare(ForeignKey o1, ForeignKey o2) {
1339                     return o1.getManyToField().compareTo(o2.getManyToField());
1340                 }
1341             });
1342         }
1343         return additionalForeignKeyIndexPosition;
1344     }
1345 
1346     protected void buildEntityProperties(
1347             Map&lt;String, FieldMetadata&gt; fields,
1348             ForeignKey foreignField,
1349             ForeignKey[] additionalForeignFields,
1350             String[] additionalNonPersistentProperties,
1351             Boolean populateManyToOneFields,
1352             String[] includeFields,
1353             String[] excludeFields,
1354             String configurationKey,
1355             String ceilingEntityFullyQualifiedClassname,
1356             String propertyName,
1357             Class&lt;?&gt; returnedClass,
1358             Class&lt;?&gt; targetClass,
1359             List&lt;Class&lt;?&gt;&gt; parentClasses,
1360             String prefix,
1361             Boolean isParentExcluded,
1362             String parentPrefix) {
1363         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1364         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1365 
1366         for (Class&lt;?&gt; parentClass : parentClasses) {
1367             clonedParentClasses.add(parentClass);
1368         }
1369 
1370         clonedParentClasses.add(targetClass);
1371 
1372         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1373             ceilingEntityFullyQualifiedClassname,
1374             polymorphicEntities,
1375             foreignField,
1376             additionalNonPersistentProperties,
1377             additionalForeignFields,
1378             MergedPropertyType.PRIMARY,
1379             populateManyToOneFields,
1380             includeFields,
1381             excludeFields,
1382             configurationKey,
1383             clonedParentClasses,
1384             prefix + propertyName + &#x27;.&#x27;,
1385             isParentExcluded,
1386             parentPrefix);
1387 
1388         final String targetClassName = targetClass.getName();
1389 
1390         for (FieldMetadata newMetadata : newFields.values()) {
1391             newMetadata.setInheritedFromType(targetClassName);
1392             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1393         }
1394 
1395         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1396 
1397         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1398             final FieldMetadata fieldMetadata = newField.getValue();
1399             final String key = newField.getKey();
1400 
1401             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1402 
1403             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1404                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1404                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1405                     Class&lt;?&gt; validatorImpl = null;
1406 
1407                     try {
1408                         validatorImpl = Class.forName(validationConfigurations.getKey());
1409                     } catch (ClassNotFoundException e) {
1410                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1411 
1412                         if (bean != null) {
1413                             validatorImpl = bean.getClass();
1414                         }
1415                     }
1416 
<abbr title="1417                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1417                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1418                         for (Map&lt;String, String&gt; configs  : validationConfigurations.getValue()) {
1419                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1420                                 final String value = config.getValue();
1421 
1422                                 if (newFields.containsKey(value)) {
1423                                     config.setValue(propertyName + &quot;.&quot; + value);
1424                                 }
1425                             }
1426                         }
1427                     }
1428                 }
1429             }
1430 
1431             if (isForeignKey(fieldMetadata)) {
1432                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1433             }
1434         }
1435 
1436         fields.putAll(convertedFields);
1437     }
1438 
1439     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1440         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1441                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1441                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
<abbr title="1442                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1442                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerðŸ”µ</abbr>
1443     }
1444 
1445     /*
1446      * There may be multiple pathways to this foreign key which may have come from a cached source.
1447      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1448      * to make sure it is set appropriately here.
1449      *
1450      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1451      * owningSite.embeddableMultitenantSite.adminUsers.
1452      */
<abbr title="1453     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1453     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1454         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1454         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1455         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1456     }
1457 
1458     protected void buildComponentProperties(
1459             Class&lt;?&gt; targetClass,
1460             ForeignKey foreignField,
1461             ForeignKey[] additionalForeignFields,
1462             String[] additionalNonPersistentProperties,
1463             MergedPropertyType mergedPropertyType,
1464             Map&lt;String, FieldMetadata&gt; fields,
1465             String idProperty,
1466             Boolean populateManyToOneFields,
1467             String[] includeFields,
1468             String[] excludeFields,
1469             String configurationKey,
1470             String ceilingEntityFullyQualifiedClassname,
1471             String propertyName,
1472             Type type,
1473             Class&lt;?&gt; returnedClass,
1474             List&lt;Class&lt;?&gt;&gt; parentClasses,
1475             Boolean isParentExcluded,
1476             String prefix,
1477             String parentPrefix) {
1478         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1479         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1480         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1481         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1482         String tempPrefix = &quot;&quot;;
1483 
1484         int pos = prefix.indexOf(&quot;.&quot;);
1485         final int prefixLength = prefix.length();
1486 
1487         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1488             //only use part of the prefix if it&#x27;s more than one layer deep
1489             tempPrefix = prefix.substring(pos + 1, prefixLength);
1490         }
1491 
<abbr title="1492         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1492         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1493 
1494         if (isParentExcluded) {
1495             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1496                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1496                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1497                 componentPresentationAttributes.get(key).setExcluded(true);
1498             }
1499         }
1500 
1501         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1502         Property property;
1503 
1504         try {
1505             property = persistentClass.getProperty(propertyName);
1506         } catch (MappingException e) {
1507             property = persistentClass.getProperty(prefix + propertyName);
1508         }
1509 
<abbr title="1510         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1510         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1511         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1512 
1513         while(componentPropertyIterator.hasNext()) {
1514             componentPropertyList.add((Property) componentPropertyIterator.next());
1515         }
1516 
1517         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1518         buildProperties(
1519             targetClass,
1520             foreignField,
1521             additionalForeignFields,
1522             additionalNonPersistentProperties,
1523             mergedPropertyType,
1524             componentPresentationAttributes,
1525             componentPropertyList,
1526             newFields,
1527             componentPropertyNames,
1528             componentPropertyTypes,
1529             idProperty,
1530             populateManyToOneFields,
1531             includeFields,
1532             excludeFields,
1533             configurationKey,
1534             ceilingEntityFullyQualifiedClassname,
1535             parentClasses,
1536             propertyName + &quot;.&quot;,
1537             isParentExcluded,
1538             true,
1539             parentPrefix + prefix
1540         );
1541 
1542         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1543 
1544         for (String key : newFields.keySet()) {
1545             final FieldMetadata fieldMetadata = newFields.get(key);
1546             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1547 
1548             if (isForeignKey(fieldMetadata)) {
1549                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1550             }
1551         }
1552         fields.putAll(convertedFields);
1553     }
1554 
1555     @Override
1556     public EntityManager getStandardEntityManager() {
1557         return standardEntityManager;
1558     }
1559 
1560     @Override
1561     public void setStandardEntityManager(EntityManager entityManager) {
1562         this.standardEntityManager = entityManager;
1563     }
1564 
1565     @Override
1566     public FieldManager getFieldManager() {
1567 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1568         return new FieldManager(entityConfiguration, getStandardEntityManager());</span>
1569 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1570         if (fieldManager == null) {</span>
1571 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1572         return this.getFieldManager(true);</span>
1573 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1574     }
1575 
1576     @Override
1577     public FieldManager getFieldManager(boolean cleanFieldManager) {
1578         if (fieldManager == null) {
1579             //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1580             // we re-init fieldManager in setStandardEntityManager method
1581             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1582         } else if (cleanFieldManager){
1583             fieldManager.clearMiddleFields();
1584         }
1585         return fieldManager;
1586     }
1587 
1588     @Override
1589     public EntityConfiguration getEntityConfiguration() {
1590         return entityConfiguration;
1591     }
1592 
1593     @Override
1594     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1595         this.entityConfiguration = entityConfiguration;
1596     }
1597 
1598     @Override
1599     public Metadata getMetadata() {
1600         return metadata;
1601     }
1602 
1603     @Override
1604     public void setMetadata(Metadata metadata) {
1605         this.metadata = metadata;
1606     }
1607 
1608     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1609         return fieldMetadataProviders;
1610     }
1611 
1612     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1613         this.fieldMetadataProviders = fieldMetadataProviders;
1614     }
1615 
1616     @Override
1617     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1618         return defaultFieldMetadataProvider;
1619     }
1620 
1621     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1622         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1623     }
1624 
1625     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1626         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1627     }
1628 
1629     @Override
1630     public DynamicDaoHelper getDynamicDaoHelper() {
1631         return dynamicDaoHelper;
1632     }
1633 
1634     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1635         this.dynamicDaoHelper = dynamicDaoHelper;
1636     }
1637 
1638 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 import java.io.Serializable;
  21 import java.lang.reflect.Field;
  22 import java.lang.reflect.Method;
  23 import java.lang.reflect.Modifier;
  24 import java.math.BigDecimal;
  25 import java.math.BigInteger;
  26 import java.security.MessageDigest;
  27 import java.security.NoSuchAlgorithmException;
  28 import java.util.ArrayList;
  29 import java.util.Arrays;
  30 import java.util.Collections;
  31 import java.util.Comparator;
  32 import java.util.Date;
  33 import java.util.HashMap;
  34 import java.util.HashSet;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Set;
  39 import javax.annotation.Nonnull;
  40 import javax.annotation.Resource;
  41 import javax.persistence.EntityManager;
  42 import javax.persistence.criteria.CriteriaBuilder;
  43 import javax.persistence.criteria.CriteriaQuery;
  44 import javax.persistence.criteria.Path;
  45 import javax.persistence.criteria.Predicate;
  46 import javax.persistence.criteria.Root;
  47 import org.apache.commons.collections4.map.LRUMap;
  48 import org.apache.commons.lang.StringUtils;
  49 import org.apache.commons.lang3.ArrayUtils;
  50 import org.apache.commons.logging.Log;
  51 import org.apache.commons.logging.LogFactory;
  52 import org.broadleafcommerce.common.money.Money;
  53 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  54 import org.broadleafcommerce.common.persistence.Status;
  55 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  56 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  57 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  58 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  59 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  60 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  61 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  62 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  63 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  64 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  65 import org.broadleafcommerce.openadmin.dto.ClassTree;
  66 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  67 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  68 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  69 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  70 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  71 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  72 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  72 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  73 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  75 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  76 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  77 import org.hibernate.Criteria;
  78 import org.hibernate.MappingException;
  79 import org.hibernate.Session;
  80 import org.hibernate.mapping.PersistentClass;
  81 import org.hibernate.mapping.Property;
  82 import org.hibernate.type.ComponentType;
  83 import org.hibernate.type.Type;
  84 import org.springframework.beans.BeansException;
  85 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  86 import org.springframework.beans.factory.annotation.Value;
  87 import org.springframework.context.ApplicationContext;
  88 import org.springframework.context.ApplicationContextAware;
  89 import org.springframework.context.annotation.Scope;
  90 import org.springframework.core.annotation.AnnotationUtils;
  91 import org.springframework.stereotype.Component;
  92 
  93 
  94 /**
  95  *
  96  * @author jfischer
  97  *
  98  */
  99 @Component(&quot;blDynamicEntityDao&quot;)
 100 @Scope(&quot;prototype&quot;)
 101 public class DynamicEntityDaoImpl implements DynamicEntityDao , ApplicationContextAware {
 102     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 103 
 104     protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 105 
 106     /**
<abbr title=" 107      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 107      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 108      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 108      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 109      * counts in METADATA_CACHE as a result of cache eviction
 110      */
 111     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 112 
<abbr title=" 113     /* This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 113     /* This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 114     from polymorphism
 115      */
 116     protected EntityManager standardEntityManager;
 117 
 118     @Resource(name=&quot;blMetadata&quot;)
 119     protected Metadata metadata;
 120 
 121     @Resource(name=&quot;blEntityConfiguration&quot;)
 122     protected EntityConfiguration entityConfiguration;
 123 
 124     @Resource(name=&quot;blFieldMetadataProviders&quot;)
 125     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 126 
 127     @Resource(name= &quot;blDefaultFieldMetadataProvider&quot;)
 128     protected FieldMetadataProvider defaultFieldMetadataProvider;
 129 
 130     @Resource(name = &quot;blAppConfigurationMap&quot;)
 131     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 132 
 133     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 134 
 135     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 136     protected int cacheEntityMetaDataTtl;
 137 
 138     /**
<abbr title=" 139      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 139      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 140      */
 141     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 142     protected boolean validateMetadataCacheSizes;
 143 
 144     protected long lastCacheFlushTime = System.currentTimeMillis();
 145 
 146     protected ApplicationContext applicationContext;
 147 
 148     @Override
 149     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 150         this.applicationContext = applicationContext;
 151     }
 152 
 153     @Override
 154     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 155         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 156     }
 157 
 158     @Override
 159     public &lt;T&gt; T persist(T entity) {
 160         standardEntityManager.persist(entity);
 161         standardEntityManager.flush();
 162         return entity;
 163     }
 164 
 165     @Override
 166     public Object find(Class&lt;?&gt; entityClass, Object key) {
 167         return standardEntityManager.find(entityClass, key);
 168     }
 169 
 170     @Override
 171     public &lt;T&gt; T merge(T entity) {
 172         T response = standardEntityManager.merge(entity);
 173         standardEntityManager.flush();
 174         return response;
 175     }
 176 
 177     @Override
 178     public void flush() {
 179         standardEntityManager.flush();
 180     }
 181 
 182     @Override
 183     public void detach(Serializable entity) {
 184         standardEntityManager.detach(entity);
 185     }
 186 
 187     @Override
 188     public void refresh(Serializable entity) {
 189         standardEntityManager.refresh(entity);
 190     }
 191 
 192     @Override
 193     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 194         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 195     }
 196 
 197     @Override
 198     public void remove(Serializable entity) {
 199         standardEntityManager.remove(entity);
 200         standardEntityManager.flush();
 201     }
 202 
 203     @Override
 204     public void clear() {
 205         standardEntityManager.clear();
 206     }
 207 
 208     @Override
 209     public PersistentClass getPersistentClass(String targetClassName) {
 210         return HibernateMappingProvider.getMapping(targetClassName);
 211     }
 212 
 213     @Override
 214     public boolean useCache() {
 215         if (cacheEntityMetaDataTtl &lt; 0) {
 216             return true;
 217         }
 218         if (cacheEntityMetaDataTtl == 0) {
 219             return false;
 220         } else {
 221             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 222                 lastCacheFlushTime = System.currentTimeMillis();
 223                 METADATA_CACHE.clear();
 224                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 225                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 226                 LOG.trace(&quot;Metadata cache evicted&quot;);
 227                 return true; // cache is empty
 228             } else {
 229                 return true;
 230             }
 231         }
 232     }
 233 
 234     @Override
 235     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 236         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 237     }
 238 
 239     @Override
<abbr title=" 240     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 240     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
<abbr title=" 241         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 241         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr>
 242     }
 243 
 244     @Override
 245     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 246         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 247     }
 248 
 249     @Override
 250     public Class&lt;?&gt; getImplClass(String className) {
 251         Class&lt;?&gt; clazz = null;
 252         try {
 253             clazz = entityConfiguration.lookupEntityClass(className);
 254         } catch (NoSuchBeanDefinitionException e) {
 255             //do nothing
 256         }
 257         if (clazz == null) {
 258             try {
 259                 clazz = Class.forName(className);
 260             } catch (ClassNotFoundException e) {
 261                 throw new RuntimeException(e);
 262             }
 263             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 264         }
 265         return clazz;
 266     }
 267 
 268     @Override
 269     public Class&lt;?&gt; getCeilingImplClass(String className) {
 270         Class&lt;?&gt; clazz;
 271         try {
 272             clazz = Class.forName(className);
 273         } catch (ClassNotFoundException e) {
 274             throw new RuntimeException(e);
 275         }
 276         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 277         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 278             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 279             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 280         }
 281         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 282             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 282             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 283         }
 284         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 285         return clazz;
 286     }
 287 
 288     @Override
<abbr title=" 289     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 289     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 290         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 290         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 291         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 292         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 293         Root root = criteria.from(clazz);
 294         Path idField = root.get(this.getIdField(clazz).getName());
 295         criteria.select(idField.as(Long.class));
 296         List&lt;Predicate&gt; restrictions = new ArrayList();
 297 
 298         Path path = null;
 299 
 300         // Support property name such as &quot;defaultSku.name&quot;
 301         if (propertyName.contains(&quot;.&quot;)) {
 302             String[] split = propertyName.split(&quot;\\.&quot;);
 303             for (String splitResult : split) {
 304                 if (path == null) {
 305                     path = root.get(splitResult);
 306                 } else {
 307                     path = path.get(splitResult);
 308                 }
 309             }
 310         } else {
 311             path = root.get(propertyName);
 312         }
 313 
 314         restrictions.add(builder.equal(path, value));
 315         Serializable identifier = this.getIdentifier(instance);
 316         //when we creating the new item identifier is not exists
 317         if(identifier != null) {
 318             restrictions.add(builder.notEqual(idField, identifier));
 319         }
 320 
 321         if (instance instanceof Status) {
<abbr title=" 322             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 322             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 323         }
 324 
 325         criteria.where((Predicate[]) restrictions.toArray(new Predicate[restrictions.size()]));
 326         return this.standardEntityManager.createQuery(criteria).getResultList();
 327     }
 328 
 329     @Override
 330     public Serializable getIdentifier(Object entity) {
 331         return dynamicDaoHelper.getIdentifier(entity);
 332     }
 333 
 334     protected Field getIdField(Class&lt;?&gt; clazz) {
 335         return dynamicDaoHelper.getIdField(clazz);
 336     }
 337 
 338     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 339         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 340     }
 341 
 342     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 343         Class&lt;?&gt; testClass;
 344         try {
 345             testClass = Class.forName(tree.getFullyQualifiedClassname());
 346         } catch (ClassNotFoundException e) {
 347             throw new RuntimeException(e);
 348         }
 349         if (clazz.equals(testClass)) {
 350             return;
 351         }
 352         if (clazz.getSuperclass().equals(testClass)) {
 353             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 354             createClassTreeFromAnnotation(clazz, myTree);
 355             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 356         } else {
 357             for (ClassTree child : tree.getChildren()) {
 358                 addClassToTree(clazz, child);
 359             }
 360         }
 361     }
 362 
 363     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 364         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 364         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 365         if (classPresentation != null) {
 366             String friendlyName = classPresentation.friendlyName();
 367             if (!StringUtils.isEmpty(friendlyName)) {
 368                 myTree.setFriendlyName(friendlyName);
 369             }
 370         }
 371     }
 372 
 373     @Override
 374     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 375         String ceilingClass = null;
 376         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 377             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 377             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 378             if (classPresentation != null) {
 379                String ceilingEntity = classPresentation.ceilingDisplayEntity();
 380                 if (!StringUtils.isEmpty(ceilingEntity)) {
 381                     ceilingClass = ceilingEntity;
 382                     break;
 383                 }
 384             }
 385         }
 386         if (ceilingClass != null) {
 387             int pos = -1;
 388             int j = 0;
 389             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 390                 if (clazz.getName().equals(ceilingClass)) {
 391                     pos = j;
 392                     break;
 393                 }
 394                 j++;
 395             }
 396             if (pos &gt;= 0) {
 397                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 398                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 399                 polymorphicClasses = temp;
 400             }
 401         }
 402 
 403         ClassTree classTree = null;
 404         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 405             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length-1];
 406             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 407             createClassTreeFromAnnotation(topClass, classTree);
 408             for (int j=polymorphicClasses.length-1; j &gt;= 0; j--) {
 409                 addClassToTree(polymorphicClasses[j], classTree);
 410             }
 411             classTree.finalizeStructure(1);
 412         }
 413         return classTree;
 414     }
 415 
 416     @Override
 417     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 418         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 419         return getClassTree(sortedEntities);
 420     }
 421 
 422     @Override
<abbr title=" 423     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 423     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 424         Class&lt;?&gt;[] entityClasses;
 425         try {
 426             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 427         } catch (ClassNotFoundException e) {
 428             throw new RuntimeException(e);
 429         }
 430         if (!ArrayUtils.isEmpty(entityClasses)) {
 431             return getMergedProperties(
 432                 entityName,
 433                 entityClasses,
<abbr title=" 434                 (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 434                 (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspðŸ”µ</abbr>
 435                 persistencePerspective.getAdditionalNonPersistentProperties(),
 436                 persistencePerspective.getAdditionalForeignKeys(),
 437                 MergedPropertyType.PRIMARY,
 438                 persistencePerspective.getPopulateToOneFields(),
 439                 persistencePerspective.getIncludeFields(),
 440                 persistencePerspective.getExcludeFields(),
 441                 persistencePerspective.getConfigurationKey(),
 442                 &quot;&quot;
 443             );
 444         } else {
 445             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 446             Class&lt;?&gt; targetClass;
 447             try {
 448                 targetClass = Class.forName(entityName);
 449             } catch (ClassNotFoundException e) {
 450                 throw new RuntimeException(e);
 451             }
<abbr title=" 452             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 452             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 453             for (String property : attributesMap.keySet()) {
 454                 FieldMetadata presentationAttribute = attributesMap.get(property);
 455                 if (!presentationAttribute.getExcluded()) {
 456                     Field field = FieldManager.getSingleField(targetClass, property);
 457                     if (!Modifier.isStatic(field.getModifiers())) {
 458                         boolean handled = false;
 459                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 460                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 461                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 461                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 462                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 463                                             property, null, false, 0, attributesMap, presentationAttribute,"> 463                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 464                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 464                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 465                                             mergedProperties);
 466                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 467                                 handled = true;
 468                             }
 469                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 470                                 break;
 471                             }
 472                         }
 473                         if (!handled) {
<abbr title=" 474                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 474                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 475                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 475                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 476                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 477                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 477                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 478                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 479                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 479                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 480                                             field.getType(), this), mergedProperties);
 481                         }
 482                     }
 483                 }
 484             }
 485 
 486             return mergedProperties;
 487         }
 488     }
 489 
 490     @Override
 491     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 492         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 493         return getMergedProperties(
 494                 cls.getName(),
 495                 polymorphicTypes,
 496                 null,
 497                 new String[] {},
 498                 new ForeignKey[] {},
 499                 MergedPropertyType.PRIMARY,
 500                 true,
 501                 new String[] {},
 502                 new String[] {},
 503                 null,
 504                 &quot;&quot;
 505                 );
 506     }
 507 
 508     @Override
 509     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 510             String ceilingEntityFullyQualifiedClassname,
 511             Class&lt;?&gt;[] entities,
 512             ForeignKey foreignField,
 513             String[] additionalNonPersistentProperties,
 514             ForeignKey[] additionalForeignFields,
 515             MergedPropertyType mergedPropertyType,
 516             Boolean populateManyToOneFields,
 517             String[] includeFields,
 518             String[] excludeFields,
 519             String configurationKey,
 520             String prefix) {
 521         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 522                 ceilingEntityFullyQualifiedClassname,
 523                 entities,
 524                 foreignField,
 525                 additionalNonPersistentProperties,
 526                 additionalForeignFields,
 527                 mergedPropertyType,
 528                 populateManyToOneFields,
 529                 includeFields,
 530                 excludeFields,
 531                 configurationKey,
 532                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 533                 prefix,
 534                 false,
 535                 &quot;&quot;);
 536 
 537         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 538 
 539         for (final String key : mergedProperties.keySet()) {
<abbr title=" 540             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 540             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 541                 removeKeys.add(key);
 542             }
 543         }
 544 
 545         for (String removeKey : removeKeys) {
 546             mergedProperties.remove(removeKey);
 547         }
 548 
<abbr title=" 549         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 549         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 550         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 550         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 551         // like properties gleaned from reflection typically are.
 552         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 553         for (Class&lt;?&gt; targetClass : entities) {
 554             for (String key : keys) {
<abbr title=" 555                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 555                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 556 
 557                 boolean foundOneOrMoreHandlers = false;
 558                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 559                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 559                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 560                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 561                         foundOneOrMoreHandlers = true;
 562                     }
 563                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 564                         break;
 565                     }
 566                 }
 567                 if (!foundOneOrMoreHandlers) {
 568                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 569                 }
 570             }
 571         }
 572 
 573         return mergedProperties;
 574     }
 575 
 576     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 577             final String ceilingEntityFullyQualifiedClassname,
 578             final Class&lt;?&gt;[] entities,
 579             final ForeignKey foreignField,
 580             final String[] additionalNonPersistentProperties,
 581             final ForeignKey[] additionalForeignFields,
 582             final MergedPropertyType mergedPropertyType,
 583             final Boolean populateManyToOneFields,
 584             final String[] includeFields,
 585             final String[] excludeFields,
 586             final String configurationKey,
 587             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 588             final String prefix,
 589             final Boolean isParentExcluded,
 590             final String parentPrefix) {
 591         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 592             @Override
 593             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 594                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 595                 Boolean classAnnotatedPopulateManyToOneFields;
 596                 if (overridePopulateManyToOne != null) {
 597                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 598                 } else {
 599                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 600                 }
 601 
 602                 buildPropertiesFromPolymorphicEntities(
 603                     entities,
 604                     foreignField,
 605                     additionalNonPersistentProperties,
 606                     additionalForeignFields,
 607                     mergedPropertyType,
 608                     classAnnotatedPopulateManyToOneFields,
 609                     includeFields,
 610                     excludeFields,
 611                     configurationKey,
 612                     ceilingEntityFullyQualifiedClassname,
 613                     mergedProperties,
 614                     parentClasses,
 615                     prefix,
 616                     isParentExcluded,
 617                     parentPrefix);
 618 
 619                 return mergedProperties;
 620             }
 621         };
 622 
<abbr title=" 623         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 623         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 624         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 624         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 625         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 626 
 627         return mergedProperties;
 628     }
 629 
<abbr title=" 630     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 630     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 631         for (String key : mergedProperties.keySet()) {
 632             boolean isForeign = false;
 633             if (foreignField != null) {
 634                 isForeign = foreignField.getManyToField().equals(key);
 635             }
 636             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 637                 for (ForeignKey foreignKey : additionalForeignFields) {
 638                     isForeign = foreignKey.getManyToField().equals(key);
 639                     if (isForeign) {
 640                         break;
 641                     }
 642                 }
 643             }
 644             if (isForeign) {
 645                 FieldMetadata metadata = mergedProperties.get(key);
 646                 metadata.setExcluded(false);
 647             }
 648         }
 649     }
 650 
<abbr title=" 651     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 651     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 652         //check includes
 653         if (!ArrayUtils.isEmpty(includeFields)) {
 654             for (String include : includeFields) {
 655                 for (String key : mergedProperties.keySet()) {
 656                     String testKey = prefix + key;
 657                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 658                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 659                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 659                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 660                         metadata.setExcluded(true);
 661                     } else {
 662                         FieldMetadata metadata = mergedProperties.get(key);
 663                         if (!isParentExcluded) {
<abbr title=" 664                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 664                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 665                             metadata.setExcluded(false);
 666                         }
 667                     }
 668                 }
 669             }
 670         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 671             //check excludes
 672             for (String exclude : excludeFields) {
 673                 for (String key : mergedProperties.keySet()) {
 674                     String testKey = prefix + key;
 675                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 676                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 677                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 677                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 678                         metadata.setExcluded(true);
 679                     } else {
 680                         FieldMetadata metadata = mergedProperties.get(key);
 681                         if (!isParentExcluded) {
<abbr title=" 682                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 682                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 683                             metadata.setExcluded(false);
 684                         }
 685                     }
 686                 }
 687             }
 688         }
 689     }
 690 
 691     protected String pad(String s, int length, char pad) {
 692         StringBuilder buffer = new StringBuilder(s);
 693         while (buffer.length() &lt; length) {
 694             buffer.insert(0, pad);
 695         }
 696         return buffer.toString();
 697     }
 698 
<abbr title=" 699     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 699     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 700         StringBuilder sb = new StringBuilder(150);
 701         sb.append(ceilingEntityFullyQualifiedClassname);
 702         sb.append(clazz.hashCode());
 703         sb.append(foreignField==null?&quot;&quot;:foreignField.toString());
 704         sb.append(configurationKey);
 705         sb.append(isParentExcluded);
 706         if (additionalNonPersistentProperties != null) {
 707             for (String prop : additionalNonPersistentProperties) {
 708                 sb.append(prop);
 709             }
 710         }
 711         if (additionalForeignFields != null) {
 712             for (ForeignKey key : additionalForeignFields) {
 713                 sb.append(key.toString());
 714             }
 715         }
 716         sb.append(mergedPropertyType);
 717         sb.append(populateManyToOneFields);
 718 
 719         String digest;
 720         try {
 721             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 722             byte[] messageDigest = md.digest(sb.toString().getBytes());
 723             BigInteger number = new BigInteger(1,messageDigest);
 724             digest = number.toString(16);
 725         } catch(NoSuchAlgorithmException e) {
 726             throw new RuntimeException(e);
 727         }
 728 
 729         String key = pad(digest, 32, &#x27;0&#x27;);
 730 
 731         if (LOG.isDebugEnabled()) {
 732             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 733         }
 734         return key;
 735     }
 736 
 737     protected void buildPropertiesFromPolymorphicEntities(
 738             Class&lt;?&gt;[] entities,
 739             ForeignKey foreignField,
 740             String[] additionalNonPersistentProperties,
 741             ForeignKey[] additionalForeignFields,
 742             MergedPropertyType mergedPropertyType,
 743             Boolean populateManyToOneFields,
 744             String[] includeFields,
 745             String[] excludeFields,
 746             String configurationKey,
 747             String ceilingEntityFullyQualifiedClassname,
 748             Map&lt;String, FieldMetadata&gt; mergedProperties,
 749             List&lt;Class&lt;?&gt;&gt; parentClasses,
 750             String prefix,
 751             Boolean isParentExcluded,
 752             String parentPrefix) {
 753         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 754             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 754             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 755 
 756             Map&lt;String, FieldMetadata&gt; cacheData = null;
 757             synchronized(DynamicDaoHelperImpl.LOCK_OBJECT) {
 758                 if (useCache()) {
 759                     cacheData = METADATA_CACHE.get(cacheKey);
 760                 }
 761 
 762                 if (cacheData == null) {
 763                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 764                         clazz,
 765                         foreignField,
 766                         additionalNonPersistentProperties,
 767                         additionalForeignFields,
 768                         mergedPropertyType,
 769                         populateManyToOneFields,
 770                         includeFields,
 771                         excludeFields,
 772                         configurationKey,
 773                         ceilingEntityFullyQualifiedClassname,
 774                         parentClasses,
 775                         prefix,
 776                         isParentExcluded,
 777                         parentPrefix);
<abbr title=" 778                     //first check all the properties currently in there to see if my entity inherits from them"> 778                     //first check all the properties currently in there to see if my entity inherits fromðŸ”µ</abbr>
 779                     for (Class&lt;?&gt; clazz2 : entities) {
 780                         if (!clazz2.getName().equals(clazz.getName())) {
 781                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 782                                 FieldMetadata metadata = entry.getValue();
 783                                 try {
<abbr title=" 784                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 784                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 785                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 785                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 786                                         metadata.setAvailableToTypes(both);
 787                                     }
 788                                 } catch (ClassNotFoundException e) {
 789                                     throw new RuntimeException(e);
 790                                 }
 791                             }
 792                         }
 793                     }
 794                     METADATA_CACHE.put(cacheKey, props);
 795 
 796                     if (LOG.isTraceEnabled()) {
<abbr title=" 797                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 797                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKeyðŸ”µ</abbr>
 798                     }
 799 
 800                     if (validateMetadataCacheSizes) {
 801                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 802                         Integer currentSize = props.size();
 803                         if (previousSize == null) {
 804                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 805                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 806                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 806                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache ðŸ”µ</abbr>
 807                             LOG.error(msg);
 808                             throw new RuntimeException(msg);
 809                         }
 810                     }
 811 
 812                     cacheData = props;
 813                 } else {
 814                     if (LOG.isTraceEnabled()) {
<abbr title=" 815                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 815                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheðŸ”µ</abbr>
 816                     }
 817                 }
 818             }
 819             //clone the metadata before passing to the system
 820             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 821             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 822                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 823             }
 824             mergedProperties.putAll(clonedCache);
 825         }
 826     }
 827 
 828     @Override
 829     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 830         Field[] allFields = new Field[]{};
 831         boolean eof = false;
 832         Class&lt;?&gt; currentClass = targetClass;
 833         while (!eof) {
 834             Field[] fields = currentClass.getDeclaredFields();
 835             allFields = ArrayUtils.addAll(allFields, fields);
 836             if (currentClass.getSuperclass() != null) {
 837                 currentClass = currentClass.getSuperclass();
 838             } else {
 839                 eof = true;
 840             }
 841         }
 842 
 843         return allFields;
 844     }
 845 
 846     @Override
 847     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 848         String propertyName,
 849         String friendlyPropertyName,
 850         Class&lt;?&gt; targetClass,
 851         Class&lt;?&gt; parentClass,
 852         MergedPropertyType mergedPropertyType
 853     ) {
 854         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 855         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 856         presentationAttribute.setFriendlyName(friendlyPropertyName);
 857         if (String.class.isAssignableFrom(targetClass)) {
 858             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 859             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 860             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 860             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 861         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 862             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 863             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 864             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 864             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 865         } else if (Date.class.isAssignableFrom(targetClass)) {
 866             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 867             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 868             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 868             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 869         } else if (Money.class.isAssignableFrom(targetClass)) {
 870             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 871             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 872             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 872             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 873         } else if (
 874                 Byte.class.isAssignableFrom(targetClass) ||
 875                 Integer.class.isAssignableFrom(targetClass) ||
 876                 Long.class.isAssignableFrom(targetClass) ||
 877                 Short.class.isAssignableFrom(targetClass)
 878             ) {
 879             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 880             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 881             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 881             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 882         } else if (
 883                 Double.class.isAssignableFrom(targetClass) ||
 884                 BigDecimal.class.isAssignableFrom(targetClass)
 885             ) {
 886             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 887             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 888             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 888             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 889         }
 890         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 891         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 892         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 893         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 894         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 895         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 896 
 897         return fields;
 898     }
 899 
 900     @Override
 901     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 902         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 903     }
 904 
 905     @Override
 906     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 907         return dynamicDaoHelper.getPropertyNames(entityClass);
 908     }
 909 
 910     @Override
 911     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 912         return dynamicDaoHelper.getPropertyTypes(entityClass);
 913     }
 914 
 915     @Override
 916     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 917         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length-1]);
 918 
<abbr title=" 919         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 919         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 920         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 921         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 922 
 923         return mergedTabAndGroupMetadata;
 924     }
 925 
 926     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 927         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 928 
 929         if (ceilingEntity != null) {
 930             entities = ArrayUtils.add(entities, ceilingEntity);
 931             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 932                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 933                 ceilingEntity = ceilingEntity.getSuperclass();
 934             }
 935         }
 936         return entities;
 937     }
 938 
 939     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 940             Class&lt;?&gt; targetClass,
 941             ForeignKey foreignField,
 942             String[] additionalNonPersistentProperties,
 943             ForeignKey[] additionalForeignFields,
 944             MergedPropertyType mergedPropertyType,
 945             Boolean populateManyToOneFields,
 946             String[] includeFields,
 947             String[] excludeFields,
 948             String configurationKey,
 949             String ceilingEntityFullyQualifiedClassname,
 950             List&lt;Class&lt;?&gt;&gt; parentClasses,
 951             String prefix,
 952             Boolean isParentExcluded,
 953             String parentPrefix) {
<abbr title=" 954         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 954         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
 955         if (isParentExcluded) {
 956             for (String key : presentationAttributes.keySet()) {
<abbr title=" 957                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);"> 957                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
 958                 presentationAttributes.get(key).setExcluded(true);
 959             }
 960         }
 961 
 962         Map idMetadata = getIdMetadata(targetClass);
 963         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 964         String idProperty = (String) idMetadata.get(&quot;name&quot;);
 965         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 966         propertyNames.add(idProperty);
 967         Type idType = (Type) idMetadata.get(&quot;type&quot;);
 968         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 969         propertyTypes.add(idType);
 970 
 971         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
 972         Iterator testIter = persistentClass.getPropertyIterator();
 973         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
 974 
 975         //check the properties for problems
 976         while(testIter.hasNext()) {
 977             Property property = (Property) testIter.next();
 978             if (property.getName().contains(&quot;.&quot;)) {
<abbr title=" 979                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);"> 979                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
 980             }
 981             propertyList.add(property);
 982         }
 983 
 984         buildProperties(
 985             targetClass,
 986             foreignField,
 987             additionalForeignFields,
 988             additionalNonPersistentProperties,
 989             mergedPropertyType,
 990             presentationAttributes,
 991             propertyList,
 992             fields,
 993             propertyNames,
 994             propertyTypes,
 995             idProperty,
 996             populateManyToOneFields,
 997             includeFields,
 998             excludeFields,
 999             configurationKey,
1000             ceilingEntityFullyQualifiedClassname,
1001             parentClasses,
1002             prefix,
1003             isParentExcluded,
1004             false,
1005             parentPrefix
1006         );
1007         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1008         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1009         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1010         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1011             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1012             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1013                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1013                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1014                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1015                     //get final property if this is a dot delimited property
1016                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1017                     if (finalDotPos &gt;= 0) {
<abbr title="1018                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1018                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1019                     }
<abbr title="1020                     //check all the polymorphic types on this target class to see if the end property exists">1020                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1021                     Field testField = null;
1022                     Method testMethod = null;
1023                     for (Class&lt;?&gt; clazz : entities) {
1024                         try {
1025                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1026                             if (testMethod != null) {
1027                                 break;
1028                             }
1029                         } catch (NoSuchMethodException e) {
1030                             //do nothing - method does not exist
1031                         }
1032                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1033                         if (testField != null) {
1034                             break;
1035                         }
1036                     }
1037                     //if the property exists, add it to the metadata for this class
1038                     if (testField != null || testMethod != null) {
<abbr title="1039                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1039                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1040                     }
1041                 }
1042             }
1043         }
1044 
1045         return fields;
1046     }
1047 
1048     protected void buildProperties(
1049             Class&lt;?&gt; targetClass,
1050             ForeignKey foreignField,
1051             ForeignKey[] additionalForeignFields,
1052             String[] additionalNonPersistentProperties,
1053             MergedPropertyType mergedPropertyType,
1054             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1055             List&lt;Property&gt; componentProperties,
1056             Map&lt;String, FieldMetadata&gt; fields,
1057             List&lt;String&gt; propertyNames,
1058             List&lt;Type&gt; propertyTypes,
1059             String idProperty,
1060             Boolean populateManyToOneFields,
1061             String[] includeFields,
1062             String[] excludeFields,
1063             String configurationKey,
1064             String ceilingEntityFullyQualifiedClassname,
1065             List&lt;Class&lt;?&gt;&gt; parentClasses,
1066             String prefix,
1067             Boolean isParentExcluded,
1068             Boolean isComponentPrefix,
1069             String parentPrefix) {
1070         int j = 0;
1071         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1072             @Override
1073             public int compare(String o1, String o2) {
1074                 //check for property name equality and for map field properties
<abbr title="1075                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1075                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1076                     return 0;
1077                 }
1078                 return o1.compareTo(o2);
1079             }
1080         };
1081         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1082         Collections.sort(presentationKeyList);
1083 
1084         for (String propertyName : propertyNames) {
1085             final Type type = propertyTypes.get(j);
1086             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1087             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1087             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1088             j++;
1089             Field myField = getFieldManager().getField(targetClass, propertyName);
1090             if (myField == null) {
<abbr title="1091                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1091                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1092                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1093             }
1094             if (
1095                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1096                     isPropertyForeignKey ||
1097                     additionalForeignKeyIndexPosition &gt;= 0 ||
1098                     Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0
1099             ) {
1100                 if (myField != null) {
1101                     boolean handled = false;
1102                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1103                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1104                         if (presentationAttribute != null) {
1105                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1106                         }
1107                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1108                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1108                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1109                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1110                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1110                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1111                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1111                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1112                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1113                             handled = true;
1114                         }
1115                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1116                             break;
1117                         }
1118                     }
1119                     if (!handled) {
1120                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1121                             additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1121                             additionalNonPersistentProperties, mergedPropertyType, presentationAttributesðŸ”µ</abbr>
<abbr title="1122                             componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1122                             componentProperties, fields, idProperty, populateManyToOneFields, includeFielðŸ”µ</abbr>
<abbr title="1123                             excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1123                             excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentðŸ”µ</abbr>
<abbr title="1124                             prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1124                             prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionaðŸ”µ</abbr>
1125                     }
1126                 }
1127             }
1128         }
1129     }
1130 
1131     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1132         setExcludedBasedOnShowIfProperty(presentationAttribute);
1133 
<abbr title="1134         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1134         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1135 
1136     }
1137 
1138     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1139         if (fieldMetadata != null
1140             &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1141             &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1142             &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1143 
1144             //do not include this in the display if it returns false.
1145             fieldMetadata.setExcluded(true);
1146         }
1147     }
1148 
<abbr title="1149     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1149     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1150                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1150                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1151 
<abbr title="1152         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1152         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1153                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1154 
<abbr title="1155         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1155         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1156                 parentPrefix, propertyName);
1157 
1158         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1159     }
1160 
<abbr title="1161     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1161     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1162         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1163     }
1164 
1165     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1166             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1167             isComponentPrefix) {
1168         Boolean response = false;
1169         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1170         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1170         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1171         if (shouldTest) {
1172             Field testField = getFieldManager().getField(targetClass, propertyName);
1173             if (testField == null) {
1174                 Class&lt;?&gt;[] entities;
1175                 try {
<abbr title="1176                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1176                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1177                 } catch (ClassNotFoundException e) {
1178                     throw new RuntimeException(e);
1179                 }
1180                 for (Class&lt;?&gt; clazz : entities) {
1181                     testField = getFieldManager().getField(clazz, propertyName);
1182                     if (testField != null) {
1183                         break;
1184                     }
1185                 }
1186                 String testProperty = prefix + propertyName;
1187                 if (testField == null) {
1188                     testField = getFieldManager().getField(targetClass, testProperty);
1189                 }
1190                 if (testField == null) {
1191                     for (Class&lt;?&gt; clazz : entities) {
1192                         testField = getFieldManager().getField(clazz, testProperty);
1193                         if (testField != null) {
1194                             break;
1195                         }
1196                     }
1197                 }
1198             }
1199             response = determineExclusionForField(parentClasses, targetClass, testField);
1200         }
1201         return response;
1202     }
1203 
<abbr title="1204     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1204     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1205         Boolean response = false;
1206         if (testField != null) {
1207             Class&lt;?&gt; testType = testField.getType();
1208             for (Class&lt;?&gt; parentClass : parentClasses) {
1209                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1210                     response = true;
1211                     break;
1212                 }
1213             }
<abbr title="1214             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1214             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1215                 response = true;
1216             }
1217         }
1218         return response;
1219     }
1220 
1221     protected void buildBasicProperty(
1222             Field field,
1223             Class&lt;?&gt; targetClass,
1224             ForeignKey foreignField,
1225             ForeignKey[] additionalForeignFields,
1226             String[] additionalNonPersistentProperties,
1227             MergedPropertyType mergedPropertyType,
1228             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1229             List&lt;Property&gt; componentProperties,
1230             Map&lt;String, FieldMetadata&gt; fields,
1231             String idProperty,
1232             Boolean populateManyToOneFields,
1233             String[] includeFields,
1234             String[] excludeFields,
1235             String configurationKey,
1236             String ceilingEntityFullyQualifiedClassname,
1237             List&lt;Class&lt;?&gt;&gt; parentClasses,
1238             String prefix,
1239             Boolean isParentExcluded,
1240             String propertyName,
1241             Type type,
1242             boolean propertyForeignKey,
1243             int additionalForeignKeyIndexPosition,
1244             Boolean isComponentPrefix,
1245             String parentPrefix) {
1246         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1247         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1248         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1249             ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1250 
1251         SupportedFieldType explicitType = null;
1252         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1253             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1254         }
1255         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1256         checkProp: {
1257             if (type.isComponentType() &amp;&amp; includeField) {
1258                 buildComponentProperties(
1259                     targetClass,
1260                     foreignField,
1261                     additionalForeignFields,
1262                     additionalNonPersistentProperties,
1263                     mergedPropertyType,
1264                     fields,
1265                     idProperty,
1266                     populateManyToOneFields,
1267                     includeFields,
1268                     excludeFields,
1269                     configurationKey,
1270                     ceilingEntityFullyQualifiedClassname,
1271                     propertyName,
1272                     type,
1273                     returnedClass,
1274                     parentClasses,
1275                     amIExcluded,
1276                     prefix,
1277                         parentPrefix);
1278                 break checkProp;
1279             }
1280             /*
1281              * Currently we do not support ManyToOne fields whose class type is the same
1282              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1283              */
1284             if (
1285                 type.isEntityType() &amp;&amp;
1286                 !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1287                 populateManyToOneFields &amp;&amp;
1288                 includeField
1289             ) {
1290                 buildEntityProperties(
1291                     fields,
1292                     foreignField,
1293                     additionalForeignFields,
1294                     additionalNonPersistentProperties,
1295                     populateManyToOneFields,
1296                     includeFields,
1297                     excludeFields,
1298                     configurationKey,
1299                     ceilingEntityFullyQualifiedClassname,
1300                     propertyName,
1301                     returnedClass,
1302                     targetClass,
1303                     parentClasses,
1304                     prefix,
1305                     amIExcluded,
1306                     parentPrefix
1307                 );
1308                 break checkProp;
1309             }
1310         }
1311         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1312         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1313             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1314                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1314                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1315                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1315                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1316                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1316                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1317                             presentationAttribute, explicitType, returnedClass, this), fields);
1318         }
1319     }
1320 
1321     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1322         boolean isPropertyForeignKey = false;
1323         if (foreignField != null) {
1324             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1325         }
1326         return isPropertyForeignKey;
1327     }
1328 
<abbr title="1329     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1329     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1330         int additionalForeignKeyIndexPosition = -1;
1331         if (additionalForeignFields != null) {
<abbr title="1332             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1332             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1333                 @Override
1334                 public int compare(ForeignKey o1, ForeignKey o2) {
1335                     return o1.getManyToField().compareTo(o2.getManyToField());
1336                 }
1337             });
1338         }
1339         return additionalForeignKeyIndexPosition;
1340     }
1341 
1342     protected void buildEntityProperties(
1343             Map&lt;String, FieldMetadata&gt; fields,
1344             ForeignKey foreignField,
1345             ForeignKey[] additionalForeignFields,
1346             String[] additionalNonPersistentProperties,
1347             Boolean populateManyToOneFields,
1348             String[] includeFields,
1349             String[] excludeFields,
1350             String configurationKey,
1351             String ceilingEntityFullyQualifiedClassname,
1352             String propertyName,
1353             Class&lt;?&gt; returnedClass,
1354             Class&lt;?&gt; targetClass,
1355             List&lt;Class&lt;?&gt;&gt; parentClasses,
1356             String prefix,
1357             Boolean isParentExcluded,
1358             String parentPrefix) {
1359         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1360         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1361 
1362         for (Class&lt;?&gt; parentClass : parentClasses) {
1363             clonedParentClasses.add(parentClass);
1364         }
1365 
1366         clonedParentClasses.add(targetClass);
1367 
1368         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1369             ceilingEntityFullyQualifiedClassname,
1370             polymorphicEntities,
1371             foreignField,
1372             additionalNonPersistentProperties,
1373             additionalForeignFields,
1374             MergedPropertyType.PRIMARY,
1375             populateManyToOneFields,
1376             includeFields,
1377             excludeFields,
1378             configurationKey,
1379             clonedParentClasses,
1380             prefix + propertyName + &#x27;.&#x27;,
1381             isParentExcluded,
1382             parentPrefix);
1383 
1384         final String targetClassName = targetClass.getName();
1385 
1386         for (FieldMetadata newMetadata : newFields.values()) {
1387             newMetadata.setInheritedFromType(targetClassName);
1388             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1389         }
1390 
1391         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1392 
1393         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1394             final FieldMetadata fieldMetadata = newField.getValue();
1395             final String key = newField.getKey();
1396 
1397             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1398 
1399             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1400                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1400                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1401                     Class&lt;?&gt; validatorImpl = null;
1402 
1403                     try {
1404                         validatorImpl = Class.forName(validationConfigurations.getKey());
1405                     } catch (ClassNotFoundException e) {
1406                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1407 
1408                         if (bean != null) {
1409                             validatorImpl = bean.getClass();
1410                         }
1411                     }
1412 
<abbr title="1413                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1413                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1414                         for (Map&lt;String, String&gt; configs  : validationConfigurations.getValue()) {
1415                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1416                                 final String value = config.getValue();
1417 
1418                                 if (newFields.containsKey(value)) {
1419                                     config.setValue(propertyName + &quot;.&quot; + value);
1420                                 }
1421                             }
1422                         }
1423                     }
1424                 }
1425             }
1426 
1427             if (isForeignKey(fieldMetadata)) {
1428                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1429             }
1430         }
1431 
1432         fields.putAll(convertedFields);
1433     }
1434 
1435     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1436         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1437                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1437                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
<abbr title="1438                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1438                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerðŸ”µ</abbr>
1439     }
1440 
1441     /*
1442      * There may be multiple pathways to this foreign key which may have come from a cached source.
1443      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1444      * to make sure it is set appropriately here.
1445      *
1446      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1447      * owningSite.embeddableMultitenantSite.adminUsers.
1448      */
<abbr title="1449     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1449     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1450         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1450         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1451         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1452     }
1453 
1454     protected void buildComponentProperties(
1455             Class&lt;?&gt; targetClass,
1456             ForeignKey foreignField,
1457             ForeignKey[] additionalForeignFields,
1458             String[] additionalNonPersistentProperties,
1459             MergedPropertyType mergedPropertyType,
1460             Map&lt;String, FieldMetadata&gt; fields,
1461             String idProperty,
1462             Boolean populateManyToOneFields,
1463             String[] includeFields,
1464             String[] excludeFields,
1465             String configurationKey,
1466             String ceilingEntityFullyQualifiedClassname,
1467             String propertyName,
1468             Type type,
1469             Class&lt;?&gt; returnedClass,
1470             List&lt;Class&lt;?&gt;&gt; parentClasses,
1471             Boolean isParentExcluded,
1472             String prefix,
1473             String parentPrefix) {
1474         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1475         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1476         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1477         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1478         String tempPrefix = &quot;&quot;;
1479 
1480         int pos = prefix.indexOf(&quot;.&quot;);
1481         final int prefixLength = prefix.length();
1482 
1483         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1484             //only use part of the prefix if it&#x27;s more than one layer deep
1485             tempPrefix = prefix.substring(pos + 1, prefixLength);
1486         }
1487 
<abbr title="1488         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1488         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1489 
1490         if (isParentExcluded) {
1491             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1492                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1492                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1493                 componentPresentationAttributes.get(key).setExcluded(true);
1494             }
1495         }
1496 
1497         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1498         Property property;
1499 
1500         try {
1501             property = persistentClass.getProperty(propertyName);
1502         } catch (MappingException e) {
1503             property = persistentClass.getProperty(prefix + propertyName);
1504         }
1505 
<abbr title="1506         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1506         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1507         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1508 
1509         while(componentPropertyIterator.hasNext()) {
1510             componentPropertyList.add((Property) componentPropertyIterator.next());
1511         }
1512 
1513         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1514         buildProperties(
1515             targetClass,
1516             foreignField,
1517             additionalForeignFields,
1518             additionalNonPersistentProperties,
1519             mergedPropertyType,
1520             componentPresentationAttributes,
1521             componentPropertyList,
1522             newFields,
1523             componentPropertyNames,
1524             componentPropertyTypes,
1525             idProperty,
1526             populateManyToOneFields,
1527             includeFields,
1528             excludeFields,
1529             configurationKey,
1530             ceilingEntityFullyQualifiedClassname,
1531             parentClasses,
1532             propertyName + &quot;.&quot;,
1533             isParentExcluded,
1534             true,
1535             parentPrefix + prefix
1536         );
1537 
1538         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1539 
1540         for (String key : newFields.keySet()) {
1541             final FieldMetadata fieldMetadata = newFields.get(key);
1542             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1543 
1544             if (isForeignKey(fieldMetadata)) {
1545                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1546             }
1547         }
1548         fields.putAll(convertedFields);
1549     }
1550 
1551     @Override
1552     public EntityManager getStandardEntityManager() {
1553         return standardEntityManager;
1554     }
1555 
1556     @Override
1557     public void setStandardEntityManager(EntityManager entityManager) {
1558         this.standardEntityManager = entityManager;
1559     }
1560 
1561     @Override
1562     public FieldManager getFieldManager(boolean cleanFieldManager) {
1563         return new FieldManager(entityConfiguration, getStandardEntityManager());
1564     }
1565 
1566     @Override
1567     public EntityConfiguration getEntityConfiguration() {
1568         return entityConfiguration;
1569     }
1570 
1571     @Override
1572     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1573         this.entityConfiguration = entityConfiguration;
1574     }
1575 
1576     @Override
1577     public Metadata getMetadata() {
1578         return metadata;
1579     }
1580 
1581     @Override
1582     public void setMetadata(Metadata metadata) {
1583         this.metadata = metadata;
1584     }
1585 
1586     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1587         return fieldMetadataProviders;
1588     }
1589 
1590     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1591         this.fieldMetadataProviders = fieldMetadataProviders;
1592     }
1593 
1594     @Override
1595     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1596         return defaultFieldMetadataProvider;
1597     }
1598 
1599     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1600         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1601     }
1602 
1603     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1604         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1605     }
1606 
1607     @Override
1608     public DynamicDaoHelper getDynamicDaoHelper() {
1609         return dynamicDaoHelper;
1610     }
1611 
1612     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1613         this.dynamicDaoHelper = dynamicDaoHelper;
1614     }
1615 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.dao;
  19  
  20  
  21  import org.apache.commons.collections4.map.LRUMap;
  22  import org.apache.commons.lang.StringUtils;
  23  import org.apache.commons.lang3.ArrayUtils;
  24  import org.apache.commons.logging.Log;
  25  import org.apache.commons.logging.LogFactory;
  26  import org.broadleafcommerce.common.money.Money;
  27  import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28  import org.broadleafcommerce.common.persistence.Status;
  29  import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33  import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.broadleafcommerce.common.util.dao.EJB3ConfigurationDao;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;</span>
  37  import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  38  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  39  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  40  import org.broadleafcommerce.openadmin.dto.ClassTree;
  41  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  42  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  43  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  44  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  45  import org.broadleafcommerce.openadmin.dto.TabMetadata;
  46  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
  47  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;
  48  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  49  import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  50  import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  51  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  52  import org.hibernate.Criteria;
  53  import org.hibernate.MappingException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.hibernate.SessionFactory;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.hibernate.ejb.HibernateEntityManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +import org.hibernate.Session;</span>
  57  import org.hibernate.mapping.PersistentClass;
  58  import org.hibernate.mapping.Property;
  59  import org.hibernate.type.ComponentType;
  60  import org.hibernate.type.Type;
  61  import org.springframework.beans.BeansException;
  62  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  63  import org.springframework.beans.factory.annotation.Value;
  64  import org.springframework.context.ApplicationContext;
  65  import org.springframework.context.ApplicationContextAware;
  66  import org.springframework.context.annotation.Scope;
  67  import org.springframework.core.annotation.AnnotationUtils;
  68  import org.springframework.stereotype.Component;
  69  
  70  import java.io.Serializable;
  71  import java.lang.reflect.Field;
  72  import java.lang.reflect.Method;
  73  import java.lang.reflect.Modifier;
  74  import java.math.BigDecimal;
  75  import java.math.BigInteger;
  76  import java.security.MessageDigest;
  77  import java.security.NoSuchAlgorithmException;
  78  import java.util.ArrayList;
  79  import java.util.Arrays;
  80  import java.util.Collections;
  81  import java.util.Comparator;
  82  import java.util.Date;
  83  import java.util.HashMap;
  84  import java.util.HashSet;
  85  import java.util.Iterator;
  86  import java.util.List;
  87  import java.util.Map;
  88  import java.util.Set;
  89  
  90  import javax.annotation.Nonnull;
  91  import javax.annotation.Resource;
  92  import javax.persistence.EntityManager;
  93  import javax.persistence.criteria.CriteriaBuilder;
  94  import javax.persistence.criteria.CriteriaQuery;
  95  import javax.persistence.criteria.Path;
  96  import javax.persistence.criteria.Predicate;
  97  import javax.persistence.criteria.Root;
  98  
  99  /**
 100   *
 101   * @author jfischer
 102   *
 103   */
 104  @Component(&quot;blDynamicEntityDao&quot;)
 105  @Scope(&quot;prototype&quot;)
 106  public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 107  
 108      private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 109  
 110      protected static final Map&lt;String,Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);

 111  
 112      /**
<abbr title=" 113       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 113       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cacheðŸ”µ</abbr>
<abbr title=" 114       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 114       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagðŸ”µ</abbr>
 115       * counts in METADATA_CACHE as a result of cache eviction
 116       */
 117      protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 118  
 119      /*
<abbr title=" 120       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 120       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or ðŸ”µ</abbr>
 121       * from polymorphism
 122       */
 123  
 124      protected EntityManager standardEntityManager;
 125  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -    protected EJB3ConfigurationDao ejb3ConfigurationDao;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -</span>
 128      @Resource(name=&quot;blMetadata&quot;)

 129      protected Metadata metadata;
 130  
 131      @Resource(name=&quot;blEntityConfiguration&quot;)

 132      protected EntityConfiguration entityConfiguration;
 133  
 134      @Resource(name=&quot;blFieldMetadataProviders&quot;)

 135      protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 136  
 137      @Resource(name= &quot;blDefaultFieldMetadataProvider&quot;)

 138      protected FieldMetadataProvider defaultFieldMetadataProvider;
 139  
 140      @Resource(name = &quot;blAppConfigurationMap&quot;)
 141      protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 142  
 143      protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 144  
 145      @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 146      protected int cacheEntityMetaDataTtl;
 147  
 148      /**
 149       * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application
 150       */
 151      @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 152      protected boolean validateMetadataCacheSizes;
 153  
 154      protected long lastCacheFlushTime = System.currentTimeMillis();
 155  
 156      protected ApplicationContext applicationContext;
 157  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -    protected FieldManager fieldManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -</span>
 161      @Override
 162      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 163          this.applicationContext = applicationContext;
 164      }
 165  
 166      @Override
 167      public Criteria createCriteria(Class&lt;?&gt; entityClass) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -        return ((HibernateEntityManager) getStandardEntityManager()).getSession().createCriteria(entityClass);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +        return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);</span>
 170      }
 171  
 172      @Override
 173      public &lt;T&gt; T persist(T entity) {
 174          standardEntityManager.persist(entity);
 175          standardEntityManager.flush();
 176          return entity;
 177      }
 178  
 179      @Override
 180      public Object find(Class&lt;?&gt; entityClass, Object key) {
 181          return standardEntityManager.find(entityClass, key);
 182      }
 183  
 184      @Override
 185      public &lt;T&gt; T merge(T entity) {
 186          T response = standardEntityManager.merge(entity);
 187          standardEntityManager.flush();
 188          return response;
 189      }
 190  
 191      @Override
 192      public void flush() {
 193          standardEntityManager.flush();
 194      }
 195  
 196      @Override
 197      public void detach(Serializable entity) {
 198          standardEntityManager.detach(entity);
 199      }
 200  
 201      @Override
 202      public void refresh(Serializable entity) {
 203          standardEntityManager.refresh(entity);
 204      }
 205  
 206      @Override
 207      public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 208          return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 209      }
 210  
 211      @Override
 212      public void remove(Serializable entity) {
 213          standardEntityManager.remove(entity);
 214          standardEntityManager.flush();
 215      }
 216  
 217      @Override
 218      public void clear() {
 219          standardEntityManager.clear();
 220      }
 221  
 222      @Override
 223      public PersistentClass getPersistentClass(String targetClassName) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -        return ejb3ConfigurationDao.getConfiguration().getClassMapping(targetClassName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        return HibernateMappingProvider.getMapping(targetClassName);</span>
 226      }
 227  
 228      @Override
 229      public boolean useCache() {
 230          if (cacheEntityMetaDataTtl &lt; 0) {
 231              return true;
 232          }
 233          if (cacheEntityMetaDataTtl == 0) {
 234              return false;
 235          } else {
 236              if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 237                  lastCacheFlushTime = System.currentTimeMillis();
 238                  METADATA_CACHE.clear();
 239                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 240                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 241                  LOG.trace(&quot;Metadata cache evicted&quot;);
 242                  return true; // cache is empty
 243              } else {
 244                  return true;
 245              }
 246          }
 247      }
 248  
 249      @Override
 250      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 251          return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 252      }
 253  
 254      @Override
<abbr title=" 255      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 255      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymoðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -        return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, getSessionFactory(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -            includeUnqualifiedPolymorphicEntities, useCache());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 258 +        return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 258 +        return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEnðŸ”µ</abbr></span>
 259      }
 260  
 261      @Override
 262      public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 263 -        return dynamicDaoHelper.getUpDownInheritance(testClass, getSessionFactory(), true, useCache(), ejb3ConfigurationDao);"> 263 -        return dynamicDaoHelper.getUpDownInheritance(testClass, getSessionFactory(), true, useCache(), ejb3ConfiguðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +        return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());</span>
 265      }
 266  
 267      @Override
 268      public Class&lt;?&gt; getImplClass(String className) {
 269          Class&lt;?&gt; clazz = null;
 270          try {
 271              clazz = entityConfiguration.lookupEntityClass(className);
 272          } catch (NoSuchBeanDefinitionException e) {
 273              //do nothing
 274          }
 275          if (clazz == null) {
 276              try {
 277                  clazz = Class.forName(className);
 278              } catch (ClassNotFoundException e) {
 279                  throw new RuntimeException(e);
 280              }
 281              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 282          }
 283          return clazz;
 284      }
 285  
 286      @Override
 287      public Class&lt;?&gt; getCeilingImplClass(String className) {
 288          Class&lt;?&gt; clazz;
 289          try {
 290              clazz = Class.forName(className);
 291          } catch (ClassNotFoundException e) {
 292              throw new RuntimeException(e);
 293          }
 294          Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 295          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 296              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 297              entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 298          }
 299          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 300              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 300              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requesðŸ”µ</abbr>
 301          }
 302          clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 303          return clazz;
 304      }
 305  
 306      @Override
<abbr title=" 307      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 307      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value)ðŸ”µ</abbr>
 308          Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());
 309          CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 310          CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 311          Root root = criteria.from(clazz);
 312          Path idField = root.get(this.getIdField(clazz).getName());
 313          criteria.select(idField.as(Long.class));
 314          List&lt;Predicate&gt; restrictions = new ArrayList();
 315  
 316          Path path = null;
 317  
 318          // Support property name such as &quot;defaultSku.name&quot;
 319          if (propertyName.contains(&quot;.&quot;)) {
 320              String[] split = propertyName.split(&quot;\\.&quot;);
 321              for (String splitResult : split) {
 322                  if (path == null) {
 323                      path = root.get(splitResult);
 324                  } else {
 325                      path = path.get(splitResult);
 326                  }
 327              }
 328          } else {
 329              path = root.get(propertyName);
 330          }
 331  
 332          restrictions.add(builder.equal(path, value));
 333          Serializable identifier = this.getIdentifier(instance);
 334          //when we creating the new item identifier is not exists
 335          if(identifier != null) {

 336              restrictions.add(builder.notEqual(idField, identifier));
 337          }
 338  
 339          if (instance instanceof Status) {
<abbr title=" 340              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 340              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(rðŸ”µ</abbr>
 341          }
 342  
 343          criteria.where((Predicate[]) restrictions.toArray(new Predicate[restrictions.size()]));
 344          return this.standardEntityManager.createQuery(criteria).getResultList();
 345      }
 346  
 347      @Override
 348      public Serializable getIdentifier(Object entity) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 349 -        return dynamicDaoHelper.getIdentifier(entity, standardEntityManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +        return dynamicDaoHelper.getIdentifier(entity);</span>
 351      }
 352  
 353      protected Field getIdField(Class&lt;?&gt; clazz) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -        return dynamicDaoHelper.getIdField(clazz, standardEntityManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +        return dynamicDaoHelper.getIdField(clazz);</span>
 356      }
 357  
 358      public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 359          return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 360      }
 361  
 362      protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 363          Class&lt;?&gt; testClass;
 364          try {
 365              testClass = Class.forName(tree.getFullyQualifiedClassname());
 366          } catch (ClassNotFoundException e) {
 367              throw new RuntimeException(e);
 368          }
 369          if (clazz.equals(testClass)) {
 370              return;
 371          }
 372          if (clazz.getSuperclass().equals(testClass)) {
 373              ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 374              createClassTreeFromAnnotation(clazz, myTree);
 375              tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 376          } else {
 377              for (ClassTree child : tree.getChildren()) {
 378                  addClassToTree(clazz, child);
 379              }
 380          }
 381      }
 382  
 383      protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 384          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 384          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.clðŸ”µ</abbr>
 385          if (classPresentation != null) {
 386              String friendlyName = classPresentation.friendlyName();
 387              if (!StringUtils.isEmpty(friendlyName)) {
 388                  myTree.setFriendlyName(friendlyName);
 389              }
 390          }
 391      }
 392  
 393      @Override
 394      public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 395          String ceilingClass = null;
 396          for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 397              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 397              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClasðŸ”µ</abbr>
 398              if (classPresentation != null) {
 399                 String ceilingEntity = classPresentation.ceilingDisplayEntity();

 400                  if (!StringUtils.isEmpty(ceilingEntity)) {
 401                      ceilingClass = ceilingEntity;
 402                      break;
 403                  }
 404              }
 405          }
 406          if (ceilingClass != null) {
 407              int pos = -1;
 408              int j = 0;
 409              for (Class&lt;?&gt; clazz : polymorphicClasses) {
 410                  if (clazz.getName().equals(ceilingClass)) {
 411                      pos = j;
 412                      break;
 413                  }
 414                  j++;
 415              }
 416              if (pos &gt;= 0) {
 417                  Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 418                  System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 419                  polymorphicClasses = temp;
 420              }
 421          }
 422  
 423          ClassTree classTree = null;
 424          if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 425              Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length-1];

 426              classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 427              createClassTreeFromAnnotation(topClass, classTree);
 428              for (int j=polymorphicClasses.length-1; j &gt;= 0; j--) {

 429                  addClassToTree(polymorphicClasses[j], classTree);
 430              }
 431              classTree.finalizeStructure(1);
 432          }
 433          return classTree;
 434      }
 435  
 436      @Override
 437      public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 438          Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 439          return getClassTree(sortedEntities);
 440      }
 441  
 442      @Override
<abbr title=" 443      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 443      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
 444          Class&lt;?&gt;[] entityClasses;
 445          try {
 446              entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 447          } catch (ClassNotFoundException e) {
 448              throw new RuntimeException(e);
 449          }
 450          if (!ArrayUtils.isEmpty(entityClasses)) {
 451              return getMergedProperties(
 452                  entityName,
 453                  entityClasses,
<abbr title=" 454                  (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 454                  (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveIteðŸ”µ</abbr>
 455                  persistencePerspective.getAdditionalNonPersistentProperties(),
 456                  persistencePerspective.getAdditionalForeignKeys(),
 457                  MergedPropertyType.PRIMARY,
 458                  persistencePerspective.getPopulateToOneFields(),
 459                  persistencePerspective.getIncludeFields(),
 460                  persistencePerspective.getExcludeFields(),
 461                  persistencePerspective.getConfigurationKey(),
 462                  &quot;&quot;











 463              );
 464          } else {
 465              Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 466              Class&lt;?&gt; targetClass;
 467              try {
 468                  targetClass = Class.forName(entityName);
 469              } catch (ClassNotFoundException e) {
 470                  throw new RuntimeException(e);
 471              }
<abbr title=" 472              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 472              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, ðŸ”µ</abbr>
 473              for (String property : attributesMap.keySet()) {
 474                  FieldMetadata presentationAttribute = attributesMap.get(property);
 475                  if (!presentationAttribute.getExcluded()) {
 476                      Field field = FieldManager.getSingleField(targetClass, property);
 477                      if (!Modifier.isStatic(field.getModifiers())) {
 478                          boolean handled = false;
 479                          for (FieldMetadataProvider provider : fieldMetadataProviders) {
 480                              MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 481                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 481                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 482                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
 483                                              property, null, false, 0, attributesMap, presentationAttribute,
<abbr title=" 484                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 484                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), fðŸ”µ</abbr>
 485                                              mergedProperties);

 486                              if (MetadataProviderResponse.NOT_HANDLED != response) {
 487                                  handled = true;
 488                              }
 489                              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 490                                  break;
 491                              }
 492                          }
 493                          if (!handled) {
<abbr title=" 494                              //this provider is not included in the provider list on purpose - it is designed to handle basic"> 494                              //this provider is not included in the provider list on purpose - it is designed to haðŸ”µ</abbr>
 495                              //AdminPresentation fields, and those fields not admin presentation annotated at all
 496                              defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 497                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 497                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 498                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 499                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 499                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetaðŸ”µ</abbr>
 500                                              field.getType(), this), mergedProperties);
 501                          }
 502                      }
 503                  }
 504              }
 505  
 506              return mergedProperties;
 507          }
 508      }
 509  
 510      @Override
 511      public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 512          Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 513          return getMergedProperties(
 514                  cls.getName(),
 515                  polymorphicTypes,
 516                  null,
 517                  new String[] {},
 518                  new ForeignKey[] {},


 519                  MergedPropertyType.PRIMARY,
 520                  true,
 521                  new String[] {},
 522                  new String[] {},


 523                  null,
 524                  &quot;&quot;
 525                  );

 526      }
 527  
 528      @Override
 529      public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 530              String ceilingEntityFullyQualifiedClassname,
 531              Class&lt;?&gt;[] entities,
 532              ForeignKey foreignField,
 533              String[] additionalNonPersistentProperties,
 534              ForeignKey[] additionalForeignFields,
 535              MergedPropertyType mergedPropertyType,
 536              Boolean populateManyToOneFields,
 537              String[] includeFields,
 538              String[] excludeFields,
 539              String configurationKey,
 540              String prefix) {
 541          Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 542                  ceilingEntityFullyQualifiedClassname,
 543                  entities,
 544                  foreignField,
 545                  additionalNonPersistentProperties,
 546                  additionalForeignFields,
 547                  mergedPropertyType,
 548                  populateManyToOneFields,
 549                  includeFields,
 550                  excludeFields,
 551                  configurationKey,
 552                  new ArrayList&lt;Class&lt;?&gt;&gt;(),
 553                  prefix,
 554                  false,
 555                  &quot;&quot;);
 556  
 557          final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 558  
 559          for (final String key : mergedProperties.keySet()) {
 560              if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {
 561                  removeKeys.add(key);
 562              }
 563          }
 564  
 565          for (String removeKey : removeKeys) {
 566              mergedProperties.remove(removeKey);
 567          }
 568  
<abbr title=" 569          // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 569          // Allow field metadata providers to contribute additional fields here. These latestage handlers take placðŸ”µ</abbr>
<abbr title=" 570          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 570          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally caðŸ”µ</abbr>
 571          // like properties gleaned from reflection typically are.
 572          Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 573          for (Class&lt;?&gt; targetClass : entities) {
 574              for (String key : keys) {
<abbr title=" 575                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 575                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;ðŸ”µ</abbr>
 576  
 577                  boolean foundOneOrMoreHandlers = false;
 578                  for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 579                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 579                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedPropðŸ”µ</abbr>
 580                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 581                          foundOneOrMoreHandlers = true;
 582                      }
 583                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 584                          break;
 585                      }
 586                  }
 587                  if (!foundOneOrMoreHandlers) {
 588                      defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 589                  }
 590              }
 591          }
 592  
 593          return mergedProperties;
 594      }
 595  
 596      protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 597              final String ceilingEntityFullyQualifiedClassname,
 598              final Class&lt;?&gt;[] entities,
 599              final ForeignKey foreignField,
 600              final String[] additionalNonPersistentProperties,
 601              final ForeignKey[] additionalForeignFields,
 602              final MergedPropertyType mergedPropertyType,
 603              final Boolean populateManyToOneFields,
 604              final String[] includeFields,
 605              final String[] excludeFields,
 606              final String configurationKey,
 607              final List&lt;Class&lt;?&gt;&gt; parentClasses,
 608              final String prefix,
 609              final Boolean isParentExcluded,
 610              final String parentPrefix) {
 611          PropertyBuilder propertyBuilder = new PropertyBuilder() {
 612              @Override
 613              public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 614                  Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 615                  Boolean classAnnotatedPopulateManyToOneFields;
 616                  if (overridePopulateManyToOne != null) {
 617                      classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 618                  } else {
 619                      classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 620                  }
 621  
 622                  buildPropertiesFromPolymorphicEntities(
 623                      entities,
 624                      foreignField,
 625                      additionalNonPersistentProperties,
 626                      additionalForeignFields,
 627                      mergedPropertyType,
 628                      classAnnotatedPopulateManyToOneFields,
 629                      includeFields,
 630                      excludeFields,
 631                      configurationKey,
 632                      ceilingEntityFullyQualifiedClassname,
 633                      mergedProperties,
 634                      parentClasses,
 635                      prefix,
 636                      isParentExcluded,
 637                      parentPrefix);















 638  
 639                  return mergedProperties;
 640              }
 641          };
 642  
<abbr title=" 643          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 643          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix,ðŸ”µ</abbr>
 644          applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);
 645          applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 646  
 647          return mergedProperties;
 648      }
 649  
<abbr title=" 650      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 650      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;StðŸ”µ</abbr>
 651          for (String key : mergedProperties.keySet()) {
 652              boolean isForeign = false;
 653              if (foreignField != null) {
 654                  isForeign = foreignField.getManyToField().equals(key);
 655              }
 656              if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 657                  for (ForeignKey foreignKey : additionalForeignFields) {
 658                      isForeign = foreignKey.getManyToField().equals(key);
 659                      if (isForeign) {
 660                          break;
 661                      }
 662                  }
 663              }
 664              if (isForeign) {
 665                  FieldMetadata metadata = mergedProperties.get(key);
 666                  metadata.setExcluded(false);
 667              }
 668          }
 669      }
 670  
<abbr title=" 671      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 671      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, BooleanðŸ”µ</abbr>
 672          //check includes
 673          if (!ArrayUtils.isEmpty(includeFields)) {
 674              for (String include : includeFields) {
 675                  for (String key : mergedProperties.keySet()) {
 676                      String testKey = prefix + key;
 677                      if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 678                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 679                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 679                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appeaðŸ”µ</abbr>
 680                          metadata.setExcluded(true);
 681                      } else {
 682                          FieldMetadata metadata = mergedProperties.get(key);
 683                          if (!isParentExcluded) {
<abbr title=" 684                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 684                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in ðŸ”µ</abbr>
 685                              metadata.setExcluded(false);
 686                          }
 687                      }
 688                  }
 689              }
 690          } else if (!ArrayUtils.isEmpty(excludeFields)) {
 691              //check excludes
 692              for (String exclude : excludeFields) {
 693                  for (String key : mergedProperties.keySet()) {
 694                      String testKey = prefix + key;
 695                      if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 696                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 697                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 697                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in thðŸ”µ</abbr>
 698                          metadata.setExcluded(true);
 699                      } else {
 700                          FieldMetadata metadata = mergedProperties.get(key);
 701                          if (!isParentExcluded) {
<abbr title=" 702                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 702                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appðŸ”µ</abbr>
 703                              metadata.setExcluded(false);
 704                          }
 705                      }
 706                  }
 707              }
 708          }
 709      }
 710  
 711      protected String pad(String s, int length, char pad) {
 712          StringBuilder buffer = new StringBuilder(s);
 713          while (buffer.length() &lt; length) {
 714              buffer.insert(0, pad);
 715          }
 716          return buffer.toString();
 717      }
 718  
<abbr title=" 719      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 719      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] adðŸ”µ</abbr>
 720          StringBuilder sb = new StringBuilder(150);
 721          sb.append(ceilingEntityFullyQualifiedClassname);
 722          sb.append(clazz.hashCode());
 723          sb.append(foreignField==null?&quot;&quot;:foreignField.toString());

 724          sb.append(configurationKey);
 725          sb.append(isParentExcluded);
 726          if (additionalNonPersistentProperties != null) {
 727              for (String prop : additionalNonPersistentProperties) {
 728                  sb.append(prop);
 729              }
 730          }
 731          if (additionalForeignFields != null) {
 732              for (ForeignKey key : additionalForeignFields) {
 733                  sb.append(key.toString());
 734              }
 735          }
 736          sb.append(mergedPropertyType);
 737          sb.append(populateManyToOneFields);
 738  
 739          String digest;
 740          try {
 741              MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 742              byte[] messageDigest = md.digest(sb.toString().getBytes());
 743              BigInteger number = new BigInteger(1,messageDigest);

 744              digest = number.toString(16);
 745          } catch(NoSuchAlgorithmException e) {

 746              throw new RuntimeException(e);
 747          }
 748  
 749          String key = pad(digest, 32, &#x27;0&#x27;);
 750  
 751          if (LOG.isDebugEnabled()) {
 752              LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 753          }
 754          return key;
 755      }
 756  
 757      protected void buildPropertiesFromPolymorphicEntities(
 758              Class&lt;?&gt;[] entities,
 759              ForeignKey foreignField,
 760              String[] additionalNonPersistentProperties,
 761              ForeignKey[] additionalForeignFields,
 762              MergedPropertyType mergedPropertyType,
 763              Boolean populateManyToOneFields,
 764              String[] includeFields,
 765              String[] excludeFields,
 766              String configurationKey,
 767              String ceilingEntityFullyQualifiedClassname,
 768              Map&lt;String, FieldMetadata&gt; mergedProperties,
 769              List&lt;Class&lt;?&gt;&gt; parentClasses,
 770              String prefix,
 771              Boolean isParentExcluded,
 772              String parentPrefix) {
 773          for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 774              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 774              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistðŸ”µ</abbr>
 775  
 776              Map&lt;String, FieldMetadata&gt; cacheData = null;
 777              synchronized(DynamicDaoHelperImpl.LOCK_OBJECT) {

 778                  if (useCache()) {
 779                      cacheData = METADATA_CACHE.get(cacheKey);
 780                  }
 781  
 782                  if (cacheData == null) {
 783                      Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 784                          clazz,
 785                          foreignField,
 786                          additionalNonPersistentProperties,
 787                          additionalForeignFields,
 788                          mergedPropertyType,
 789                          populateManyToOneFields,
 790                          includeFields,
 791                          excludeFields,
 792                          configurationKey,
 793                          ceilingEntityFullyQualifiedClassname,
 794                          parentClasses,
 795                          prefix,
 796                          isParentExcluded,
 797                          parentPrefix);














 798                      //first check all the properties currently in there to see if my entity inherits from them
 799                      for (Class&lt;?&gt; clazz2 : entities) {
 800                          if (!clazz2.getName().equals(clazz.getName())) {
 801                              for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 802                                  FieldMetadata metadata = entry.getValue();
 803                                  try {
 804                                      if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {
<abbr title=" 805                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 805                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new StriðŸ”µ</abbr>
 806                                          metadata.setAvailableToTypes(both);
 807                                      }
 808                                  } catch (ClassNotFoundException e) {
 809                                      throw new RuntimeException(e);
 810                                  }
 811                              }
 812                          }
 813                      }
 814                      METADATA_CACHE.put(cacheKey, props);
 815  
 816                      if (LOG.isTraceEnabled()) {
<abbr title=" 817                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 817                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for ðŸ”µ</abbr>
 818                      }
 819  
 820                      if (validateMetadataCacheSizes) {
 821                          Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 822                          Integer currentSize = props.size();
 823                          if (previousSize == null) {
 824                              METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 825                          } else if (!currentSize.equals(previousSize)) {
<abbr title=" 826                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 826                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the kðŸ”µ</abbr>
 827                              LOG.error(msg);
 828                              throw new RuntimeException(msg);
 829                          }
 830                      }
 831  
 832                      cacheData = props;
 833                  } else {
 834                      if (LOG.isTraceEnabled()) {
<abbr title=" 835                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 835                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; fðŸ”µ</abbr>
 836                      }
 837                  }
 838              }
 839              //clone the metadata before passing to the system
 840              Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 841              for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 842                  clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 843              }
 844              mergedProperties.putAll(clonedCache);
 845          }
 846      }
 847  
 848      @Override
 849      public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 850          Field[] allFields = new Field[]{};
 851          boolean eof = false;
 852          Class&lt;?&gt; currentClass = targetClass;
 853          while (!eof) {
 854              Field[] fields = currentClass.getDeclaredFields();
 855              allFields = ArrayUtils.addAll(allFields, fields);
 856              if (currentClass.getSuperclass() != null) {
 857                  currentClass = currentClass.getSuperclass();
 858              } else {
 859                  eof = true;
 860              }
 861          }
 862  
 863          return allFields;
 864      }
 865  
 866      @Override
 867      public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 868          String propertyName,
 869          String friendlyPropertyName,
 870          Class&lt;?&gt; targetClass,
 871          Class&lt;?&gt; parentClass,
 872          MergedPropertyType mergedPropertyType





 873      ) {
 874          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 875          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 876          presentationAttribute.setFriendlyName(friendlyPropertyName);
 877          if (String.class.isAssignableFrom(targetClass)) {
 878              presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 879              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 880              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 880              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, ðŸ”µ</abbr>
 881          } else if (Boolean.class.isAssignableFrom(targetClass)) {
 882              presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 883              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 884              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 884              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN,ðŸ”µ</abbr>
 885          } else if (Date.class.isAssignableFrom(targetClass)) {
 886              presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 887              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 888              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 888              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, nuðŸ”µ</abbr>
 889          } else if (Money.class.isAssignableFrom(targetClass)) {
 890              presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 891              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 892              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 892              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, nðŸ”µ</abbr>
 893          } else if (
 894                  Byte.class.isAssignableFrom(targetClass) ||
 895                  Integer.class.isAssignableFrom(targetClass) ||
 896                  Long.class.isAssignableFrom(targetClass) ||
 897                  Short.class.isAssignableFrom(targetClass)
 898              ) {




 899              presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 900              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 901              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 901              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER,ðŸ”µ</abbr>
 902          } else if (
 903                  Double.class.isAssignableFrom(targetClass) ||
 904                  BigDecimal.class.isAssignableFrom(targetClass)
 905              ) {


 906              presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 907              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 908              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 908              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL,ðŸ”µ</abbr>
 909          }
 910          ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 911          ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 912          ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 913          ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 914          ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 915          ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 916  
 917          return fields;
 918      }
 919  
 920      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 921 -    public SessionFactory getSessionFactory() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 922 -        return dynamicDaoHelper.getSessionFactory((HibernateEntityManager) standardEntityManager);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 923 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 924 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 925 -    @Override</span>
 926      public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 927 -        return dynamicDaoHelper.getIdMetadata(entityClass, (HibernateEntityManager) standardEntityManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +        return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);</span>
 929      }
 930  
 931      @Override
 932      public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 933 -        return dynamicDaoHelper.getPropertyNames(entityClass, (HibernateEntityManager) standardEntityManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 934 +        return dynamicDaoHelper.getPropertyNames(entityClass);</span>
 935      }
 936  
 937      @Override
 938      public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 939 -        return dynamicDaoHelper.getPropertyTypes(entityClass, (HibernateEntityManager) standardEntityManager);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +        return dynamicDaoHelper.getPropertyTypes(entityClass);</span>
 941      }
 942  
 943      @Override
 944      public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 945          Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length-1]);

 946  
 947          Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);
 948          metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 949          metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 950  
 951          return mergedTabAndGroupMetadata;
 952      }
 953  
 954      public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 955          Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 956  
 957          if (ceilingEntity != null) {
 958              entities = ArrayUtils.add(entities, ceilingEntity);
 959              while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 960                  entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 961                  ceilingEntity = ceilingEntity.getSuperclass();
 962              }
 963          }
 964          return entities;
 965      }
 966  
 967      protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 968              Class&lt;?&gt; targetClass,
 969              ForeignKey foreignField,
 970              String[] additionalNonPersistentProperties,
 971              ForeignKey[] additionalForeignFields,
 972              MergedPropertyType mergedPropertyType,
 973              Boolean populateManyToOneFields,
 974              String[] includeFields,
 975              String[] excludeFields,
 976              String configurationKey,
 977              String ceilingEntityFullyQualifiedClassname,
 978              List&lt;Class&lt;?&gt;&gt; parentClasses,
 979              String prefix,
 980              Boolean isParentExcluded,
 981              String parentPrefix) {
<abbr title=" 982          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 982          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClðŸ”µ</abbr>
 983          if (isParentExcluded) {
 984              for (String key : presentationAttributes.keySet()) {
 985                  LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);
 986                  presentationAttributes.get(key).setExcluded(true);
 987              }
 988          }
 989  
 990          Map idMetadata = getIdMetadata(targetClass);
 991          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 992          String idProperty = (String) idMetadata.get(&quot;name&quot;);
 993          List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 994          propertyNames.add(idProperty);
 995          Type idType = (Type) idMetadata.get(&quot;type&quot;);
 996          List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 997          propertyTypes.add(idType);
 998  
 999          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1000          Iterator testIter = persistentClass.getPropertyIterator();
1001          List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
1002  
1003          //check the properties for problems
1004          while(testIter.hasNext()) {

1005              Property property = (Property) testIter.next();
1006              if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1007                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1007                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;)ðŸ”µ</abbr>
1008              }
1009              propertyList.add(property);
1010          }
1011  
1012          buildProperties(
1013              targetClass,
1014              foreignField,
1015              additionalForeignFields,
1016              additionalNonPersistentProperties,
1017              mergedPropertyType,
1018              presentationAttributes,
1019              propertyList,
1020              fields,
1021              propertyNames,
1022              propertyTypes,
1023              idProperty,
1024              populateManyToOneFields,
1025              includeFields,
1026              excludeFields,
1027              configurationKey,
1028              ceilingEntityFullyQualifiedClassname,
1029              parentClasses,
1030              prefix,
1031              isParentExcluded,
1032              false,
1033              parentPrefix





















1034          );
1035          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1036          presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1037          presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1038          if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1039              Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1040              for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1041                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1041                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentPropertðŸ”µ</abbr>
1042                      String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1043                      //get final property if this is a dot delimited property
1044                      int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1045                      if (finalDotPos &gt;= 0) {
<abbr title="1046                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1046                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPoðŸ”µ</abbr>
1047                      }
1048                      //check all the polymorphic types on this target class to see if the end property exists
1049                      Field testField = null;
1050                      Method testMethod = null;
1051                      for (Class&lt;?&gt; clazz : entities) {
1052                          try {
1053                              testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1054                              if (testMethod != null) {
1055                                  break;
1056                              }
1057                          } catch (NoSuchMethodException e) {
1058                              //do nothing - method does not exist
1059                          }
1060                          testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1061                          if (testField != null) {
1062                              break;
1063                          }
1064                      }
1065                      //if the property exists, add it to the metadata for this class
1066                      if (testField != null || testMethod != null) {
<abbr title="1067                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1067                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNoðŸ”µ</abbr>
1068                      }
1069                  }
1070              }
1071          }
1072  
1073          return fields;
1074      }
1075  
1076      protected void buildProperties(
1077              Class&lt;?&gt; targetClass,
1078              ForeignKey foreignField,
1079              ForeignKey[] additionalForeignFields,
1080              String[] additionalNonPersistentProperties,
1081              MergedPropertyType mergedPropertyType,
1082              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1083              List&lt;Property&gt; componentProperties,
1084              Map&lt;String, FieldMetadata&gt; fields,
1085              List&lt;String&gt; propertyNames,
1086              List&lt;Type&gt; propertyTypes,
1087              String idProperty,
1088              Boolean populateManyToOneFields,
1089              String[] includeFields,
1090              String[] excludeFields,
1091              String configurationKey,
1092              String ceilingEntityFullyQualifiedClassname,
1093              List&lt;Class&lt;?&gt;&gt; parentClasses,
1094              String prefix,
1095              Boolean isParentExcluded,
1096              Boolean isComponentPrefix,
1097              String parentPrefix) {
1098          int j = 0;
1099          Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1100              @Override
1101              public int compare(String o1, String o2) {
1102                  //check for property name equality and for map field properties
<abbr title="1103                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1103                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FielðŸ”µ</abbr>
1104                      return 0;
1105                  }
1106                  return o1.compareTo(o2);
1107              }
1108          };
1109          List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1110          Collections.sort(presentationKeyList);
1111  
1112          for (String propertyName : propertyNames) {
1113              final Type type = propertyTypes.get(j);
1114              boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1115              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1115              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix,ðŸ”µ</abbr>
1116              j++;
1117              Field myField = getFieldManager().getField(targetClass, propertyName);
1118              if (myField == null) {
<abbr title="1119                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1119                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded ðŸ”µ</abbr>
1120                  myField = getFieldManager().getField(targetClass, prefix + propertyName);
1121              }
1122              if (
1123                      !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1124                      isPropertyForeignKey ||
1125                      additionalForeignKeyIndexPosition &gt;= 0 ||
1126                      Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0
1127              ) {




1128                  if (myField != null) {
1129                      boolean handled = false;
1130                      for (FieldMetadataProvider provider : fieldMetadataProviders) {
1131                          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1132                          if (presentationAttribute != null) {
1133                              setExcludedBasedOnShowIfProperty(presentationAttribute);
1134                          }
1135                          MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1136                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1136                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalðŸ”µ</abbr>
1137                                          mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1138                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1138                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPositioðŸ”µ</abbr>
<abbr title="1139                                          presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1139                                          presentationAttributes, presentationAttribute, null, type.getReturnedClassðŸ”µ</abbr>
1140                          if (MetadataProviderResponse.NOT_HANDLED != response) {
1141                              handled = true;
1142                          }
1143                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
1144                              break;
1145                          }
1146                      }
1147                      if (!handled) {
1148                          buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
1149                              additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,
1150                              componentProperties, fields, idProperty, populateManyToOneFields, includeFields,
1151                              excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,
<abbr title="1152                              prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1152                              prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKðŸ”µ</abbr>




1153                      }
1154                  }
1155              }
1156          }
1157      }
1158  
1159      public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1160          setExcludedBasedOnShowIfProperty(presentationAttribute);
1161  
<abbr title="1162          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1162          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttðŸ”µ</abbr>
1163  
1164      }
1165  
1166      protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1167          if (fieldMetadata != null
1168              &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1169              &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1170              &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {



1171  
1172              //do not include this in the display if it returns false.
1173              fieldMetadata.setExcluded(true);
1174          }
1175      }
1176  
<abbr title="1177      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1177      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, ClasðŸ”µ</abbr>
<abbr title="1178                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1178                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefixðŸ”µ</abbr>
1179  
<abbr title="1180          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1180          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, tarðŸ”µ</abbr>
1181                  ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1182  
<abbr title="1183          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1183          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefiðŸ”µ</abbr>
1184                  parentPrefix, propertyName);
1185  
1186          return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1187      }
1188  
<abbr title="1189      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1189      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPreðŸ”µ</abbr>
1190          return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1191      }
1192  
1193      protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1194              propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1195              isComponentPrefix) {

1196          Boolean response = false;
1197          //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1198          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1198          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1ðŸ”µ</abbr>
1199          if (shouldTest) {
1200              Field testField = getFieldManager().getField(targetClass, propertyName);
1201              if (testField == null) {
1202                  Class&lt;?&gt;[] entities;
1203                  try {
<abbr title="1204                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1204                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassðŸ”µ</abbr>
1205                  } catch (ClassNotFoundException e) {
1206                      throw new RuntimeException(e);
1207                  }
1208                  for (Class&lt;?&gt; clazz : entities) {
1209                      testField = getFieldManager().getField(clazz, propertyName);
1210                      if (testField != null) {
1211                          break;
1212                      }
1213                  }
1214                  String testProperty = prefix + propertyName;
1215                  if (testField == null) {
1216                      testField = getFieldManager().getField(targetClass, testProperty);
1217                  }
1218                  if (testField == null) {
1219                      for (Class&lt;?&gt; clazz : entities) {
1220                          testField = getFieldManager().getField(clazz, testProperty);
1221                          if (testField != null) {
1222                              break;
1223                          }
1224                      }
1225                  }
1226              }
1227              response = determineExclusionForField(parentClasses, targetClass, testField);
1228          }
1229          return response;
1230      }
1231  
<abbr title="1232      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1232      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testFieðŸ”µ</abbr>
1233          Boolean response = false;
1234          if (testField != null) {
1235              Class&lt;?&gt; testType = testField.getType();
1236              for (Class&lt;?&gt; parentClass : parentClasses) {
1237                  if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1238                      response = true;
1239                      break;
1240                  }
1241              }
1242              if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {
1243                  response = true;
1244              }
1245          }
1246          return response;
1247      }
1248  
1249      protected void buildBasicProperty(
1250              Field field,
1251              Class&lt;?&gt; targetClass,
1252              ForeignKey foreignField,
1253              ForeignKey[] additionalForeignFields,
1254              String[] additionalNonPersistentProperties,
1255              MergedPropertyType mergedPropertyType,
1256              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1257              List&lt;Property&gt; componentProperties,
1258              Map&lt;String, FieldMetadata&gt; fields,
1259              String idProperty,
1260              Boolean populateManyToOneFields,
1261              String[] includeFields,
1262              String[] excludeFields,
1263              String configurationKey,
1264              String ceilingEntityFullyQualifiedClassname,
1265              List&lt;Class&lt;?&gt;&gt; parentClasses,
1266              String prefix,
1267              Boolean isParentExcluded,
1268              String propertyName,
1269              Type type,
1270              boolean propertyForeignKey,
1271              int additionalForeignKeyIndexPosition,
1272              Boolean isComponentPrefix,
1273              String parentPrefix) {
1274          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1275          Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1276          Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1277              ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);

1278  
1279          SupportedFieldType explicitType = null;
1280          if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1281              explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1282          }
1283          Class&lt;?&gt; returnedClass = type.getReturnedClass();
1284          checkProp: {


1285              if (type.isComponentType() &amp;&amp; includeField) {
1286                  buildComponentProperties(
1287                      targetClass,
1288                      foreignField,
1289                      additionalForeignFields,
1290                      additionalNonPersistentProperties,
1291                      mergedPropertyType,
1292                      fields,
1293                      idProperty,
1294                      populateManyToOneFields,
1295                      includeFields,
1296                      excludeFields,
1297                      configurationKey,
1298                      ceilingEntityFullyQualifiedClassname,
1299                      propertyName,
1300                      type,
1301                      returnedClass,
1302                      parentClasses,
1303                      amIExcluded,
1304                      prefix,


















1305                          parentPrefix);
1306                  break checkProp;
1307              }
1308              /*
1309               * Currently we do not support ManyToOne fields whose class type is the same
1310               * as the target type, since this forms an infinite loop and will cause a stack overflow.
1311               */
1312              if (
1313                  type.isEntityType() &amp;&amp;
1314                  !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1315                  populateManyToOneFields &amp;&amp;
1316                  includeField
1317              ) {





1318                  buildEntityProperties(
1319                      fields,
1320                      foreignField,
1321                      additionalForeignFields,
1322                      additionalNonPersistentProperties,
1323                      populateManyToOneFields,
1324                      includeFields,
1325                      excludeFields,
1326                      configurationKey,
1327                      ceilingEntityFullyQualifiedClassname,
1328                      propertyName,
1329                      returnedClass,
1330                      targetClass,
1331                      parentClasses,
1332                      prefix,
1333                      amIExcluded,
1334                      parentPrefix
















1335                  );
1336                  break checkProp;
1337              }
1338          }
1339          //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1340          if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1341              defaultFieldMetadataProvider.addMetadataFromFieldType(
1342                      new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,
1343                              mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,
1344                              propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,
1345                              presentationAttribute, explicitType, returnedClass, this), fields);
1346          }
1347      }
1348  
1349      protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1350          boolean isPropertyForeignKey = false;
1351          if (foreignField != null) {
1352              isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1353          }
1354          return isPropertyForeignKey;
1355      }
1356  
<abbr title="1357      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1357      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String properðŸ”µ</abbr>
1358          int additionalForeignKeyIndexPosition = -1;
1359          if (additionalForeignFields != null) {
<abbr title="1360              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1360              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefixðŸ”µ</abbr>
1361                  @Override
1362                  public int compare(ForeignKey o1, ForeignKey o2) {
1363                      return o1.getManyToField().compareTo(o2.getManyToField());
1364                  }
1365              });
1366          }
1367          return additionalForeignKeyIndexPosition;
1368      }
1369  
1370      protected void buildEntityProperties(
1371              Map&lt;String, FieldMetadata&gt; fields,
1372              ForeignKey foreignField,
1373              ForeignKey[] additionalForeignFields,
1374              String[] additionalNonPersistentProperties,
1375              Boolean populateManyToOneFields,
1376              String[] includeFields,
1377              String[] excludeFields,
1378              String configurationKey,
1379              String ceilingEntityFullyQualifiedClassname,
1380              String propertyName,
1381              Class&lt;?&gt; returnedClass,
1382              Class&lt;?&gt; targetClass,
1383              List&lt;Class&lt;?&gt;&gt; parentClasses,
1384              String prefix,
1385              Boolean isParentExcluded,
1386              String parentPrefix) {
1387          Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1388          List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1389  
1390          for (Class&lt;?&gt; parentClass : parentClasses) {
1391              clonedParentClasses.add(parentClass);
1392          }
1393  
1394          clonedParentClasses.add(targetClass);
1395  
1396          Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1397              ceilingEntityFullyQualifiedClassname,
1398              polymorphicEntities,
1399              foreignField,
1400              additionalNonPersistentProperties,
1401              additionalForeignFields,
1402              MergedPropertyType.PRIMARY,
1403              populateManyToOneFields,
1404              includeFields,
1405              excludeFields,
1406              configurationKey,
1407              clonedParentClasses,
1408              prefix + propertyName + &#x27;.&#x27;,
1409              isParentExcluded,
1410              parentPrefix);














1411  
1412          final String targetClassName = targetClass.getName();
1413  
1414          for (FieldMetadata newMetadata : newFields.values()) {
1415              newMetadata.setInheritedFromType(targetClassName);
1416              newMetadata.setAvailableToTypes(new String[]{targetClassName});
1417          }
1418  
1419          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1420  
1421          for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1422              final FieldMetadata fieldMetadata = newField.getValue();
1423              final String key = newField.getKey();
1424  
1425              convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1426  
1427              if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1428                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1428                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata)ðŸ”µ</abbr>
1429                      Class&lt;?&gt; validatorImpl = null;
1430  
1431                      try {
1432                          validatorImpl = Class.forName(validationConfigurations.getKey());
1433                      } catch (ClassNotFoundException e) {
1434                          Object bean = applicationContext.getBean(validationConfigurations.getKey());
1435  
1436                          if (bean != null) {
1437                              validatorImpl = bean.getClass();
1438                          }
1439                      }
1440  
<abbr title="1441                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1441                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl))ðŸ”µ</abbr>
1442                          for (Map&lt;String, String&gt; configs  : validationConfigurations.getValue()) {

1443                              for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1444                                  final String value = config.getValue();
1445  
1446                                  if (newFields.containsKey(value)) {
1447                                      config.setValue(propertyName + &quot;.&quot; + value);
1448                                  }
1449                              }
1450                          }
1451                      }
1452                  }
1453              }
1454  
1455              if (isForeignKey(fieldMetadata)) {
1456                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1457              }
1458          }
1459  
1460          fields.putAll(convertedFields);
1461      }
1462  
1463      protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1464          return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1465                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1465                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveðŸ”µ</abbr>
<abbr title="1466                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1466                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveIðŸ”µ</abbr>


1467      }
1468  
1469      /*
1470       * There may be multiple pathways to this foreign key which may have come from a cached source.
1471       * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1472       * to make sure it is set appropriately here.
1473       *
1474       * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1475       * owningSite.embeddableMultitenantSite.adminUsers.
1476       */
<abbr title="1477      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1477      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) ðŸ”µ</abbr>
<abbr title="1478          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1478          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective()ðŸ”µ</abbr>
1479          foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1480      }
1481  
1482      protected void buildComponentProperties(
1483              Class&lt;?&gt; targetClass,
1484              ForeignKey foreignField,
1485              ForeignKey[] additionalForeignFields,
1486              String[] additionalNonPersistentProperties,
1487              MergedPropertyType mergedPropertyType,
1488              Map&lt;String, FieldMetadata&gt; fields,
1489              String idProperty,
1490              Boolean populateManyToOneFields,
1491              String[] includeFields,
1492              String[] excludeFields,
1493              String configurationKey,
1494              String ceilingEntityFullyQualifiedClassname,
1495              String propertyName,
1496              Type type,
1497              Class&lt;?&gt; returnedClass,
1498              List&lt;Class&lt;?&gt;&gt; parentClasses,
1499              Boolean isParentExcluded,
1500              String prefix,
1501              String parentPrefix) {
1502          String[] componentProperties = ((ComponentType) type).getPropertyNames();
1503          List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1504          Type[] componentTypes = ((ComponentType) type).getSubtypes();
1505          List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1506          String tempPrefix = &quot;&quot;;
1507  
1508          int pos = prefix.indexOf(&quot;.&quot;);
1509          final int prefixLength = prefix.length();
1510  
1511          if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1512              //only use part of the prefix if it&#x27;s more than one layer deep
1513              tempPrefix = prefix.substring(pos + 1, prefixLength);
1514          }
1515  
<abbr title="1516          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1516          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targeðŸ”µ</abbr>
1517  
1518          if (isParentExcluded) {
1519              for (String key : componentPresentationAttributes.keySet()) {
1520                  LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);
1521                  componentPresentationAttributes.get(key).setExcluded(true);
1522              }
1523          }
1524  
1525          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1526          Property property;
1527  
1528          try {
1529              property = persistentClass.getProperty(propertyName);
1530          } catch (MappingException e) {
1531              property = persistentClass.getProperty(prefix + propertyName);
1532          }
1533  
<abbr title="1534          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1534          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyItðŸ”µ</abbr>
1535          List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1536  
1537          while(componentPropertyIterator.hasNext()) {

1538              componentPropertyList.add((Property) componentPropertyIterator.next());
1539          }
1540  
1541          Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1542          buildProperties(
1543              targetClass,
1544              foreignField,
1545              additionalForeignFields,
1546              additionalNonPersistentProperties,
1547              mergedPropertyType,
1548              componentPresentationAttributes,
1549              componentPropertyList,
1550              newFields,
1551              componentPropertyNames,
1552              componentPropertyTypes,
1553              idProperty,
1554              populateManyToOneFields,
1555              includeFields,
1556              excludeFields,
1557              configurationKey,
1558              ceilingEntityFullyQualifiedClassname,
1559              parentClasses,
1560              propertyName + &quot;.&quot;,
1561              isParentExcluded,
1562              true,
1563              parentPrefix + prefix





















1564          );
1565  
1566          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1567  
1568          for (String key : newFields.keySet()) {
1569              final FieldMetadata fieldMetadata = newFields.get(key);
1570              convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1571  
1572              if (isForeignKey(fieldMetadata)) {
1573                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1574              }
1575          }
1576          fields.putAll(convertedFields);
1577      }
1578  
1579      @Override
1580      public EntityManager getStandardEntityManager() {
1581          return standardEntityManager;
1582      }
1583  
1584      @Override
1585      public void setStandardEntityManager(EntityManager entityManager) {
1586          this.standardEntityManager = entityManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1587 -        fieldManager = new FieldManager(entityConfiguration, entityManager);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1588 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1589 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1590 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1591 -    public EJB3ConfigurationDao getEjb3ConfigurationDao() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1592 -        return ejb3ConfigurationDao;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1594 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1595 -    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1596 -    public void setEjb3ConfigurationDao(EJB3ConfigurationDao ejb3ConfigurationDao) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1597 -        this.ejb3ConfigurationDao = ejb3ConfigurationDao;</span>
1598      }
1599  
1600      @Override
1601      public FieldManager getFieldManager() {





<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1602 -        if (fieldManager == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1603 -            //keep in mind that getStandardEntityManager() can return null, this is in general OK,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1604 -            // we re-init fieldManager in setStandardEntityManager method</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1605 -            fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1606 -        } else {</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1607 -            fieldManager.clearMiddleFields();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1608 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1609 -        return fieldManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1610 +        return new FieldManager(entityConfiguration, getStandardEntityManager());</span>
1611      }
1612  
1613      @Override
1614      public EntityConfiguration getEntityConfiguration() {
1615          return entityConfiguration;
1616      }
1617  
1618      @Override
1619      public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1620          this.entityConfiguration = entityConfiguration;
1621      }
1622  
1623      @Override
1624      public Metadata getMetadata() {
1625          return metadata;
1626      }
1627  
1628      @Override
1629      public void setMetadata(Metadata metadata) {
1630          this.metadata = metadata;
1631      }
1632  
1633      public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1634          return fieldMetadataProviders;
1635      }
1636  
1637      public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1638          this.fieldMetadataProviders = fieldMetadataProviders;
1639      }
1640  
1641      @Override
1642      public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1643          return defaultFieldMetadataProvider;
1644      }
1645  
1646      public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1647          this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1648      }
1649  
1650      protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1651          return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1652      }
1653  
1654      @Override
1655      public DynamicDaoHelper getDynamicDaoHelper() {
1656          return dynamicDaoHelper;
1657      }
1658  
1659      public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1660          this.dynamicDaoHelper = dynamicDaoHelper;
1661      }
1662  
1663  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.dao;
  19  
  20  
  21  import org.apache.commons.collections4.map.LRUMap;
  22  import org.apache.commons.lang.StringUtils;
  23  import org.apache.commons.lang3.ArrayUtils;
  24  import org.apache.commons.logging.Log;
  25  import org.apache.commons.logging.LogFactory;
  26  import org.broadleafcommerce.common.money.Money;
  27  import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28  import org.broadleafcommerce.common.persistence.Status;
  29  import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33  import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35  import org.broadleafcommerce.common.util.dao.EJB3ConfigurationDao;

  36  import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  37  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  38  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  39  import org.broadleafcommerce.openadmin.dto.ClassTree;
  40  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  41  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  42  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  43  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  44  import org.broadleafcommerce.openadmin.dto.TabMetadata;
  45  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
  46  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;
  47  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  48  import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  49  import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  50  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  51  import org.hibernate.Criteria;
  52  import org.hibernate.MappingException;
  53  import org.hibernate.SessionFactory;
  54  import org.hibernate.ejb.HibernateEntityManager;

  55  import org.hibernate.mapping.PersistentClass;
  56  import org.hibernate.mapping.Property;
  57  import org.hibernate.type.ComponentType;
  58  import org.hibernate.type.Type;
  59  import org.springframework.beans.BeansException;
  60  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  61  import org.springframework.beans.factory.annotation.Value;
  62  import org.springframework.context.ApplicationContext;
  63  import org.springframework.context.ApplicationContextAware;
  64  import org.springframework.context.annotation.Scope;
  65  import org.springframework.core.annotation.AnnotationUtils;
  66  import org.springframework.stereotype.Component;
  67  
  68  import java.io.Serializable;
  69  import java.lang.reflect.Field;
  70  import java.lang.reflect.Method;
  71  import java.lang.reflect.Modifier;
  72  import java.math.BigDecimal;
  73  import java.math.BigInteger;
  74  import java.security.MessageDigest;
  75  import java.security.NoSuchAlgorithmException;
  76  import java.util.ArrayList;
  77  import java.util.Arrays;
  78  import java.util.Collections;
  79  import java.util.Comparator;
  80  import java.util.Date;
  81  import java.util.HashMap;
  82  import java.util.HashSet;
  83  import java.util.Iterator;
  84  import java.util.List;
  85  import java.util.Map;
  86  import java.util.Set;
  87  
  88  import javax.annotation.Nonnull;
  89  import javax.annotation.Resource;
  90  import javax.persistence.EntityManager;
  91  import javax.persistence.criteria.CriteriaBuilder;
  92  import javax.persistence.criteria.CriteriaQuery;
  93  import javax.persistence.criteria.Path;
  94  import javax.persistence.criteria.Predicate;
  95  import javax.persistence.criteria.Root;
  96  
  97  /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 - *</span>
  99   * @author jfischer
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 - *</span>
 101   */
 102  @Component(&quot;blDynamicEntityDao&quot;)
 103  @Scope(&quot;prototype&quot;)
 104  public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 105  
 106      private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 107  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    protected static final Map&lt;String,Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +    protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);</span>
 110  
 111      /**
<abbr title=" 112       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 112       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cacheðŸ”µ</abbr>
<abbr title=" 113       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 113       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagðŸ”µ</abbr>
 114       * counts in METADATA_CACHE as a result of cache eviction
 115       */
 116      protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 117  
 118      /*
<abbr title=" 119       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 119       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or ðŸ”µ</abbr>
 120       * from polymorphism
 121       */
 122  
 123      protected EntityManager standardEntityManager;
 124  
 125      protected EJB3ConfigurationDao ejb3ConfigurationDao;
 126  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -    @Resource(name=&quot;blMetadata&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +    @Resource(name = &quot;blMetadata&quot;)</span>
 129      protected Metadata metadata;
 130  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -    @Resource(name=&quot;blEntityConfiguration&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +    @Resource(name = &quot;blEntityConfiguration&quot;)</span>
 133      protected EntityConfiguration entityConfiguration;
 134  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    @Resource(name=&quot;blFieldMetadataProviders&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +    @Resource(name = &quot;blFieldMetadataProviders&quot;)</span>
 137      protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 138  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    @Resource(name= &quot;blDefaultFieldMetadataProvider&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +    @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)</span>
 141      protected FieldMetadataProvider defaultFieldMetadataProvider;
 142  
 143      @Resource(name = &quot;blAppConfigurationMap&quot;)
 144      protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 145  
 146      protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 147  
 148      @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 149      protected int cacheEntityMetaDataTtl;
 150  
 151      /**
 152       * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application
 153       */
 154      @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 155      protected boolean validateMetadataCacheSizes;
 156  
 157      protected long lastCacheFlushTime = System.currentTimeMillis();
 158  
 159      protected ApplicationContext applicationContext;
 160  
 161  
 162      protected FieldManager fieldManager;
 163  
 164      @Override
 165      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 166          this.applicationContext = applicationContext;
 167      }
 168  
 169      @Override
 170      public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 171          return ((HibernateEntityManager) getStandardEntityManager()).getSession().createCriteria(entityClass);

 172      }
 173  
 174      @Override
 175      public &lt;T&gt; T persist(T entity) {
 176          standardEntityManager.persist(entity);
 177          standardEntityManager.flush();
 178          return entity;
 179      }
 180  
 181      @Override
 182      public Object find(Class&lt;?&gt; entityClass, Object key) {
 183          return standardEntityManager.find(entityClass, key);
 184      }
 185  
 186      @Override
 187      public &lt;T&gt; T merge(T entity) {
 188          T response = standardEntityManager.merge(entity);
 189          standardEntityManager.flush();
 190          return response;
 191      }
 192  
 193      @Override
 194      public void flush() {
 195          standardEntityManager.flush();
 196      }
 197  
 198      @Override
 199      public void detach(Serializable entity) {
 200          standardEntityManager.detach(entity);
 201      }
 202  
 203      @Override
 204      public void refresh(Serializable entity) {
 205          standardEntityManager.refresh(entity);
 206      }
 207  
 208      @Override
 209      public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 210          return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 211      }
 212  
 213      @Override
 214      public void remove(Serializable entity) {
 215          standardEntityManager.remove(entity);
 216          standardEntityManager.flush();
 217      }
 218  
 219      @Override
 220      public void clear() {
 221          standardEntityManager.clear();
 222      }
 223  
 224      @Override
 225      public PersistentClass getPersistentClass(String targetClassName) {
 226          return ejb3ConfigurationDao.getConfiguration().getClassMapping(targetClassName);

 227      }
 228  
 229      @Override
 230      public boolean useCache() {
 231          if (cacheEntityMetaDataTtl &lt; 0) {
 232              return true;
 233          }
 234          if (cacheEntityMetaDataTtl == 0) {
 235              return false;
 236          } else {
 237              if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 238                  lastCacheFlushTime = System.currentTimeMillis();
 239                  METADATA_CACHE.clear();
 240                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 241                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 242                  LOG.trace(&quot;Metadata cache evicted&quot;);
 243                  return true; // cache is empty
 244              } else {
 245                  return true;
 246              }
 247          }
 248      }
 249  
 250      @Override
 251      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 252          return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 253      }
 254  
 255      @Override
<abbr title=" 256      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 256      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymoðŸ”µ</abbr>
 257          return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, getSessionFactory(),
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -            includeUnqualifiedPolymorphicEntities, useCache());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +                includeUnqualifiedPolymorphicEntities, useCache());</span>
 260      }
 261  
 262      @Override
 263      public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
<abbr title=" 264          return dynamicDaoHelper.getUpDownInheritance(testClass, getSessionFactory(), true, useCache(), ejb3ConfigurationDao);"> 264          return dynamicDaoHelper.getUpDownInheritance(testClass, getSessionFactory(), true, useCache(), ejb3ConfiguðŸ”µ</abbr>

 265      }
 266  
 267      @Override
 268      public Class&lt;?&gt; getImplClass(String className) {
 269          Class&lt;?&gt; clazz = null;
 270          try {
 271              clazz = entityConfiguration.lookupEntityClass(className);
 272          } catch (NoSuchBeanDefinitionException e) {
 273              //do nothing
 274          }
 275          if (clazz == null) {
 276              try {
 277                  clazz = Class.forName(className);
 278              } catch (ClassNotFoundException e) {
 279                  throw new RuntimeException(e);
 280              }
 281              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 282          }
 283          return clazz;
 284      }
 285  
 286      @Override
 287      public Class&lt;?&gt; getCeilingImplClass(String className) {
 288          Class&lt;?&gt; clazz;
 289          try {
 290              clazz = Class.forName(className);
 291          } catch (ClassNotFoundException e) {
 292              throw new RuntimeException(e);
 293          }
 294          Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 295          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 296              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 297              entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 298          }
 299          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 300              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 300              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requesðŸ”µ</abbr>
 301          }
 302          clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 303          return clazz;
 304      }
 305  
 306      @Override
<abbr title=" 307      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 307      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value)ðŸ”µ</abbr>
 308          Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());
 309          CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 310          CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 311          Root root = criteria.from(clazz);
 312          Path idField = root.get(this.getIdField(clazz).getName());
 313          criteria.select(idField.as(Long.class));
 314          List&lt;Predicate&gt; restrictions = new ArrayList();
 315  
 316          Path path = null;
 317  
 318          // Support property name such as &quot;defaultSku.name&quot;
 319          if (propertyName.contains(&quot;.&quot;)) {
 320              String[] split = propertyName.split(&quot;\\.&quot;);
 321              for (String splitResult : split) {
 322                  if (path == null) {
 323                      path = root.get(splitResult);
 324                  } else {
 325                      path = path.get(splitResult);
 326                  }
 327              }
 328          } else {
 329              path = root.get(propertyName);
 330          }
 331  
 332          restrictions.add(builder.equal(path, value));
 333          Serializable identifier = this.getIdentifier(instance);
 334          //when we creating the new item identifier is not exists
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -        if(identifier != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +        if (identifier != null) {</span>
 337              restrictions.add(builder.notEqual(idField, identifier));
 338          }
 339  
 340          if (instance instanceof Status) {
<abbr title=" 341              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 341              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(rðŸ”µ</abbr>
 342          }
 343  
 344          criteria.where((Predicate[]) restrictions.toArray(new Predicate[restrictions.size()]));
 345          return this.standardEntityManager.createQuery(criteria).getResultList();
 346      }
 347  
 348      @Override
 349      public Serializable getIdentifier(Object entity) {
 350          return dynamicDaoHelper.getIdentifier(entity, standardEntityManager);

 351      }
 352  
 353      protected Field getIdField(Class&lt;?&gt; clazz) {
 354          return dynamicDaoHelper.getIdField(clazz, standardEntityManager);

 355      }
 356  
 357      public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 358          return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 359      }
 360  
 361      protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 362          Class&lt;?&gt; testClass;
 363          try {
 364              testClass = Class.forName(tree.getFullyQualifiedClassname());
 365          } catch (ClassNotFoundException e) {
 366              throw new RuntimeException(e);
 367          }
 368          if (clazz.equals(testClass)) {
 369              return;
 370          }
 371          if (clazz.getSuperclass().equals(testClass)) {
 372              ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 373              createClassTreeFromAnnotation(clazz, myTree);
 374              tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 375          } else {
 376              for (ClassTree child : tree.getChildren()) {
 377                  addClassToTree(clazz, child);
 378              }
 379          }
 380      }
 381  
 382      protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 383          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 383          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.clðŸ”µ</abbr>
 384          if (classPresentation != null) {
 385              String friendlyName = classPresentation.friendlyName();
 386              if (!StringUtils.isEmpty(friendlyName)) {
 387                  myTree.setFriendlyName(friendlyName);
 388              }
 389          }
 390      }
 391  
 392      @Override
 393      public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 394          String ceilingClass = null;
 395          for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 396              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 396              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClasðŸ”µ</abbr>
 397              if (classPresentation != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -               String ceilingEntity = classPresentation.ceilingDisplayEntity();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +                String ceilingEntity = classPresentation.ceilingDisplayEntity();</span>
 400                  if (!StringUtils.isEmpty(ceilingEntity)) {
 401                      ceilingClass = ceilingEntity;
 402                      break;
 403                  }
 404              }
 405          }
 406          if (ceilingClass != null) {
 407              int pos = -1;
 408              int j = 0;
 409              for (Class&lt;?&gt; clazz : polymorphicClasses) {
 410                  if (clazz.getName().equals(ceilingClass)) {
 411                      pos = j;
 412                      break;
 413                  }
 414                  j++;
 415              }
 416              if (pos &gt;= 0) {
 417                  Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 418                  System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 419                  polymorphicClasses = temp;
 420              }
 421          }
 422  
 423          ClassTree classTree = null;
 424          if (!ArrayUtils.isEmpty(polymorphicClasses)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -            Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length-1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 426 +            Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];</span>
 427              classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 428              createClassTreeFromAnnotation(topClass, classTree);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -            for (int j=polymorphicClasses.length-1; j &gt;= 0; j--) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +            for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {</span>
 431                  addClassToTree(polymorphicClasses[j], classTree);
 432              }
 433              classTree.finalizeStructure(1);
 434          }
 435          return classTree;
 436      }
 437  
 438      @Override
 439      public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 440          Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 441          return getClassTree(sortedEntities);
 442      }
 443  
 444      @Override
<abbr title=" 445      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 445      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
 446          Class&lt;?&gt;[] entityClasses;
 447          try {
 448              entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 449          } catch (ClassNotFoundException e) {
 450              throw new RuntimeException(e);
 451          }
 452          if (!ArrayUtils.isEmpty(entityClasses)) {
 453              return getMergedProperties(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -                entityName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -                entityClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 456 -                (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 456 -                (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveIteðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -                persistencePerspective.getAdditionalNonPersistentProperties(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -                persistencePerspective.getAdditionalForeignKeys(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -                MergedPropertyType.PRIMARY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -                persistencePerspective.getPopulateToOneFields(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -                persistencePerspective.getIncludeFields(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -                persistencePerspective.getExcludeFields(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -                persistencePerspective.getConfigurationKey(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -                &quot;&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +                    entityName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +                    entityClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 467 +                    (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 467 +                    (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +                    persistencePerspective.getAdditionalNonPersistentProperties(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +                    persistencePerspective.getAdditionalForeignKeys(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +                    MergedPropertyType.PRIMARY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +                    persistencePerspective.getPopulateToOneFields(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +                    persistencePerspective.getIncludeFields(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +                    persistencePerspective.getExcludeFields(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 474 +                    persistencePerspective.getConfigurationKey(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 475 +                    &quot;&quot;</span>
 476              );
 477          } else {
 478              Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 479              Class&lt;?&gt; targetClass;
 480              try {
 481                  targetClass = Class.forName(entityName);
 482              } catch (ClassNotFoundException e) {
 483                  throw new RuntimeException(e);
 484              }
<abbr title=" 485              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 485              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, ðŸ”µ</abbr>
 486              for (String property : attributesMap.keySet()) {
 487                  FieldMetadata presentationAttribute = attributesMap.get(property);
 488                  if (!presentationAttribute.getExcluded()) {
 489                      Field field = FieldManager.getSingleField(targetClass, property);
 490                      if (!Modifier.isStatic(field.getModifiers())) {
 491                          boolean handled = false;
 492                          for (FieldMetadataProvider provider : fieldMetadataProviders) {
 493                              MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 494                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 494                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 495                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
 496                                              property, null, false, 0, attributesMap, presentationAttribute,
<abbr title=" 497                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 497                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), fðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -                                            mergedProperties);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +                                    mergedProperties);</span>
 500                              if (MetadataProviderResponse.NOT_HANDLED != response) {
 501                                  handled = true;
 502                              }
 503                              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 504                                  break;
 505                              }
 506                          }
 507                          if (!handled) {
<abbr title=" 508                              //this provider is not included in the provider list on purpose - it is designed to handle basic"> 508                              //this provider is not included in the provider list on purpose - it is designed to haðŸ”µ</abbr>
 509                              //AdminPresentation fields, and those fields not admin presentation annotated at all
 510                              defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 511                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 511                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 512                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 513                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 513                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetaðŸ”µ</abbr>
 514                                              field.getType(), this), mergedProperties);
 515                          }
 516                      }
 517                  }
 518              }
 519  
 520              return mergedProperties;
 521          }
 522      }
 523  
 524      @Override
 525      public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 526          Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 527          return getMergedProperties(
 528                  cls.getName(),
 529                  polymorphicTypes,
 530                  null,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -                new String[] {},</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -                new ForeignKey[] {},</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +                new String[]{},</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 534 +                new ForeignKey[]{},</span>
 535                  MergedPropertyType.PRIMARY,
 536                  true,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -                new String[] {},</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -                new String[] {},</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 539 +                new String[]{},</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 540 +                new String[]{},</span>
 541                  null,
 542                  &quot;&quot;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 543 -                );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 544 +        );</span>
 545      }
 546  
 547      @Override
 548      public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 549              String ceilingEntityFullyQualifiedClassname,
 550              Class&lt;?&gt;[] entities,
 551              ForeignKey foreignField,
 552              String[] additionalNonPersistentProperties,
 553              ForeignKey[] additionalForeignFields,
 554              MergedPropertyType mergedPropertyType,
 555              Boolean populateManyToOneFields,
 556              String[] includeFields,
 557              String[] excludeFields,
 558              String configurationKey,
 559              String prefix) {
 560          Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 561                  ceilingEntityFullyQualifiedClassname,
 562                  entities,
 563                  foreignField,
 564                  additionalNonPersistentProperties,
 565                  additionalForeignFields,
 566                  mergedPropertyType,
 567                  populateManyToOneFields,
 568                  includeFields,
 569                  excludeFields,
 570                  configurationKey,
 571                  new ArrayList&lt;Class&lt;?&gt;&gt;(),
 572                  prefix,
 573                  false,
 574                  &quot;&quot;);
 575  
 576          final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 577  
 578          for (final String key : mergedProperties.keySet()) {
 579              if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {
 580                  removeKeys.add(key);
 581              }
 582          }
 583  
 584          for (String removeKey : removeKeys) {
 585              mergedProperties.remove(removeKey);
 586          }
 587  
<abbr title=" 588          // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 588          // Allow field metadata providers to contribute additional fields here. These latestage handlers take placðŸ”µ</abbr>
<abbr title=" 589          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 589          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally caðŸ”µ</abbr>
 590          // like properties gleaned from reflection typically are.
 591          Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 592          for (Class&lt;?&gt; targetClass : entities) {
 593              for (String key : keys) {
<abbr title=" 594                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 594                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;ðŸ”µ</abbr>
 595  
 596                  boolean foundOneOrMoreHandlers = false;
 597                  for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 598                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 598                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedPropðŸ”µ</abbr>
 599                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 600                          foundOneOrMoreHandlers = true;
 601                      }
 602                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 603                          break;
 604                      }
 605                  }
 606                  if (!foundOneOrMoreHandlers) {
 607                      defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 608                  }
 609              }
 610          }
 611  
 612          return mergedProperties;
 613      }
 614  
 615      protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 616              final String ceilingEntityFullyQualifiedClassname,
 617              final Class&lt;?&gt;[] entities,
 618              final ForeignKey foreignField,
 619              final String[] additionalNonPersistentProperties,
 620              final ForeignKey[] additionalForeignFields,
 621              final MergedPropertyType mergedPropertyType,
 622              final Boolean populateManyToOneFields,
 623              final String[] includeFields,
 624              final String[] excludeFields,
 625              final String configurationKey,
 626              final List&lt;Class&lt;?&gt;&gt; parentClasses,
 627              final String prefix,
 628              final Boolean isParentExcluded,
 629              final String parentPrefix) {
 630          PropertyBuilder propertyBuilder = new PropertyBuilder() {
 631              @Override
 632              public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 633                  Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 634                  Boolean classAnnotatedPopulateManyToOneFields;
 635                  if (overridePopulateManyToOne != null) {
 636                      classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 637                  } else {
 638                      classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 639                  }
 640  
 641                  buildPropertiesFromPolymorphicEntities(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -                    entities,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                    foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -                    additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -                    additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -                    mergedPropertyType,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -                    classAnnotatedPopulateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                    includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -                    excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -                    configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -                    ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -                    mergedProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -                    parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -                    prefix,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -                    isParentExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -                    parentPrefix);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +                        entities,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                        foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +                        additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                        additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                        mergedPropertyType,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                        classAnnotatedPopulateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                        includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                        excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                        configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                        ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                        mergedProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                        parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                        prefix,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                        isParentExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                        parentPrefix);</span>
 672  
 673                  return mergedProperties;
 674              }
 675          };
 676  
<abbr title=" 677          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 677          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix,ðŸ”µ</abbr>
 678          applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);
 679          applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 680  
 681          return mergedProperties;
 682      }
 683  
<abbr title=" 684      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 684      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;StðŸ”µ</abbr>
 685          for (String key : mergedProperties.keySet()) {
 686              boolean isForeign = false;
 687              if (foreignField != null) {
 688                  isForeign = foreignField.getManyToField().equals(key);
 689              }
 690              if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 691                  for (ForeignKey foreignKey : additionalForeignFields) {
 692                      isForeign = foreignKey.getManyToField().equals(key);
 693                      if (isForeign) {
 694                          break;
 695                      }
 696                  }
 697              }
 698              if (isForeign) {
 699                  FieldMetadata metadata = mergedProperties.get(key);
 700                  metadata.setExcluded(false);
 701              }
 702          }
 703      }
 704  
<abbr title=" 705      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 705      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, BooleanðŸ”µ</abbr>
 706          //check includes
 707          if (!ArrayUtils.isEmpty(includeFields)) {
 708              for (String include : includeFields) {
 709                  for (String key : mergedProperties.keySet()) {
 710                      String testKey = prefix + key;
 711                      if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 712                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 713                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 713                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appeaðŸ”µ</abbr>
 714                          metadata.setExcluded(true);
 715                      } else {
 716                          FieldMetadata metadata = mergedProperties.get(key);
 717                          if (!isParentExcluded) {
<abbr title=" 718                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 718                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in ðŸ”µ</abbr>
 719                              metadata.setExcluded(false);
 720                          }
 721                      }
 722                  }
 723              }
 724          } else if (!ArrayUtils.isEmpty(excludeFields)) {
 725              //check excludes
 726              for (String exclude : excludeFields) {
 727                  for (String key : mergedProperties.keySet()) {
 728                      String testKey = prefix + key;
 729                      if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 730                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 731                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 731                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in thðŸ”µ</abbr>
 732                          metadata.setExcluded(true);
 733                      } else {
 734                          FieldMetadata metadata = mergedProperties.get(key);
 735                          if (!isParentExcluded) {
<abbr title=" 736                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 736                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appðŸ”µ</abbr>
 737                              metadata.setExcluded(false);
 738                          }
 739                      }
 740                  }
 741              }
 742          }
 743      }
 744  
 745      protected String pad(String s, int length, char pad) {
 746          StringBuilder buffer = new StringBuilder(s);
 747          while (buffer.length() &lt; length) {
 748              buffer.insert(0, pad);
 749          }
 750          return buffer.toString();
 751      }
 752  
<abbr title=" 753      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 753      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] adðŸ”µ</abbr>
 754          StringBuilder sb = new StringBuilder(150);
 755          sb.append(ceilingEntityFullyQualifiedClassname);
 756          sb.append(clazz.hashCode());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 757 -        sb.append(foreignField==null?&quot;&quot;:foreignField.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 758 +        sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());</span>
 759          sb.append(configurationKey);
 760          sb.append(isParentExcluded);
 761          if (additionalNonPersistentProperties != null) {
 762              for (String prop : additionalNonPersistentProperties) {
 763                  sb.append(prop);
 764              }
 765          }
 766          if (additionalForeignFields != null) {
 767              for (ForeignKey key : additionalForeignFields) {
 768                  sb.append(key.toString());
 769              }
 770          }
 771          sb.append(mergedPropertyType);
 772          sb.append(populateManyToOneFields);
 773  
 774          String digest;
 775          try {
 776              MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 777              byte[] messageDigest = md.digest(sb.toString().getBytes());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -            BigInteger number = new BigInteger(1,messageDigest);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +            BigInteger number = new BigInteger(1, messageDigest);</span>
 780              digest = number.toString(16);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -        } catch(NoSuchAlgorithmException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +        } catch (NoSuchAlgorithmException e) {</span>
 783              throw new RuntimeException(e);
 784          }
 785  
 786          String key = pad(digest, 32, &#x27;0&#x27;);
 787  
 788          if (LOG.isDebugEnabled()) {
 789              LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 790          }
 791          return key;
 792      }
 793  
 794      protected void buildPropertiesFromPolymorphicEntities(
 795              Class&lt;?&gt;[] entities,
 796              ForeignKey foreignField,
 797              String[] additionalNonPersistentProperties,
 798              ForeignKey[] additionalForeignFields,
 799              MergedPropertyType mergedPropertyType,
 800              Boolean populateManyToOneFields,
 801              String[] includeFields,
 802              String[] excludeFields,
 803              String configurationKey,
 804              String ceilingEntityFullyQualifiedClassname,
 805              Map&lt;String, FieldMetadata&gt; mergedProperties,
 806              List&lt;Class&lt;?&gt;&gt; parentClasses,
 807              String prefix,
 808              Boolean isParentExcluded,
 809              String parentPrefix) {
 810          for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 811              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 811              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistðŸ”µ</abbr>
 812  
 813              Map&lt;String, FieldMetadata&gt; cacheData = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 814 -            synchronized(DynamicDaoHelperImpl.LOCK_OBJECT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +            synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {</span>
 816                  if (useCache()) {
 817                      cacheData = METADATA_CACHE.get(cacheKey);
 818                  }
 819  
 820                  if (cacheData == null) {
 821                      Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 822 -                        clazz,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 823 -                        foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -                        additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -                        additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -                        mergedPropertyType,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -                        populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -                        includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -                        excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 830 -                        configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 831 -                        ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 832 -                        parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 833 -                        prefix,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 834 -                        isParentExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 835 -                        parentPrefix);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 836 +                            clazz,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 837 +                            foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 838 +                            additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 839 +                            additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 840 +                            mergedPropertyType,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 841 +                            populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 842 +                            includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 843 +                            excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 844 +                            configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +                            ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 846 +                            parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 847 +                            prefix,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 848 +                            isParentExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +                            parentPrefix);</span>
 850                      //first check all the properties currently in there to see if my entity inherits from them
 851                      for (Class&lt;?&gt; clazz2 : entities) {
 852                          if (!clazz2.getName().equals(clazz.getName())) {
 853                              for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 854                                  FieldMetadata metadata = entry.getValue();
 855                                  try {
 856                                      if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {
<abbr title=" 857                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 857                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new StriðŸ”µ</abbr>
 858                                          metadata.setAvailableToTypes(both);
 859                                      }
 860                                  } catch (ClassNotFoundException e) {
 861                                      throw new RuntimeException(e);
 862                                  }
 863                              }
 864                          }
 865                      }
 866                      METADATA_CACHE.put(cacheKey, props);
 867  
 868                      if (LOG.isTraceEnabled()) {
<abbr title=" 869                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 869                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for ðŸ”µ</abbr>
 870                      }
 871  
 872                      if (validateMetadataCacheSizes) {
 873                          Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 874                          Integer currentSize = props.size();
 875                          if (previousSize == null) {
 876                              METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 877                          } else if (!currentSize.equals(previousSize)) {
<abbr title=" 878                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 878                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the kðŸ”µ</abbr>
 879                              LOG.error(msg);
 880                              throw new RuntimeException(msg);
 881                          }
 882                      }
 883  
 884                      cacheData = props;
 885                  } else {
 886                      if (LOG.isTraceEnabled()) {
<abbr title=" 887                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 887                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; fðŸ”µ</abbr>
 888                      }
 889                  }
 890              }
 891              //clone the metadata before passing to the system
 892              Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 893              for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 894                  clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 895              }
 896              mergedProperties.putAll(clonedCache);
 897          }
 898      }
 899  
 900      @Override
 901      public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 902          Field[] allFields = new Field[]{};
 903          boolean eof = false;
 904          Class&lt;?&gt; currentClass = targetClass;
 905          while (!eof) {
 906              Field[] fields = currentClass.getDeclaredFields();
 907              allFields = ArrayUtils.addAll(allFields, fields);
 908              if (currentClass.getSuperclass() != null) {
 909                  currentClass = currentClass.getSuperclass();
 910              } else {
 911                  eof = true;
 912              }
 913          }
 914  
 915          return allFields;
 916      }
 917  
 918      @Override
 919      public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 920 -        String propertyName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 921 -        String friendlyPropertyName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 922 -        Class&lt;?&gt; targetClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 923 -        Class&lt;?&gt; parentClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 924 -        MergedPropertyType mergedPropertyType</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +            String propertyName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +            String friendlyPropertyName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +            Class&lt;?&gt; targetClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +            Class&lt;?&gt; parentClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            MergedPropertyType mergedPropertyType</span>
 930      ) {
 931          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 932          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 933          presentationAttribute.setFriendlyName(friendlyPropertyName);
 934          if (String.class.isAssignableFrom(targetClass)) {
 935              presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 936              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 937              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 937              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, ðŸ”µ</abbr>
 938          } else if (Boolean.class.isAssignableFrom(targetClass)) {
 939              presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 940              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 941              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 941              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN,ðŸ”µ</abbr>
 942          } else if (Date.class.isAssignableFrom(targetClass)) {
 943              presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 944              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 945              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 945              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, nuðŸ”µ</abbr>
 946          } else if (Money.class.isAssignableFrom(targetClass)) {
 947              presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 948              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 949              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 949              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, nðŸ”µ</abbr>
 950          } else if (
 951                  Byte.class.isAssignableFrom(targetClass) ||
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 952 -                Integer.class.isAssignableFrom(targetClass) ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 953 -                Long.class.isAssignableFrom(targetClass) ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 954 -                Short.class.isAssignableFrom(targetClass)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 955 -            ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +                        Integer.class.isAssignableFrom(targetClass) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +                        Long.class.isAssignableFrom(targetClass) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +                        Short.class.isAssignableFrom(targetClass)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +                ) {</span>
 960              presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 961              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 962              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 962              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER,ðŸ”µ</abbr>
 963          } else if (
 964                  Double.class.isAssignableFrom(targetClass) ||
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 965 -                BigDecimal.class.isAssignableFrom(targetClass)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 966 -            ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 967 +                        BigDecimal.class.isAssignableFrom(targetClass)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +                ) {</span>
 969              presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 970              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 971              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 971              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL,ðŸ”µ</abbr>
 972          }
 973          ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 974          ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 975          ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 976          ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 977          ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 978          ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 979  
 980          return fields;
 981      }
 982  
 983      @Override
 984      public SessionFactory getSessionFactory() {
 985          return dynamicDaoHelper.getSessionFactory((HibernateEntityManager) standardEntityManager);
 986      }
 987  
 988      @Override
 989      public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 990          return dynamicDaoHelper.getIdMetadata(entityClass, (HibernateEntityManager) standardEntityManager);

 991      }
 992  
 993      @Override
 994      public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 995          return dynamicDaoHelper.getPropertyNames(entityClass, (HibernateEntityManager) standardEntityManager);

 996      }
 997  
 998      @Override
 999      public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
1000          return dynamicDaoHelper.getPropertyTypes(entityClass, (HibernateEntityManager) standardEntityManager);

1001      }
1002  
1003      @Override
1004      public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1005 -        Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length-1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1006 +        Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);</span>
1007  
1008          Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);
1009          metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
1010          metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
1011  
1012          return mergedTabAndGroupMetadata;
1013      }
1014  
1015      public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
1016          Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
1017  
1018          if (ceilingEntity != null) {
1019              entities = ArrayUtils.add(entities, ceilingEntity);
1020              while (!ceilingEntity.getSuperclass().equals(Object.class)) {
1021                  entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
1022                  ceilingEntity = ceilingEntity.getSuperclass();
1023              }
1024          }
1025          return entities;
1026      }
1027  
1028      protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
1029              Class&lt;?&gt; targetClass,
1030              ForeignKey foreignField,
1031              String[] additionalNonPersistentProperties,
1032              ForeignKey[] additionalForeignFields,
1033              MergedPropertyType mergedPropertyType,
1034              Boolean populateManyToOneFields,
1035              String[] includeFields,
1036              String[] excludeFields,
1037              String configurationKey,
1038              String ceilingEntityFullyQualifiedClassname,
1039              List&lt;Class&lt;?&gt;&gt; parentClasses,
1040              String prefix,
1041              Boolean isParentExcluded,
1042              String parentPrefix) {
<abbr title="1043          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);">1043          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClðŸ”µ</abbr>
1044          if (isParentExcluded) {
1045              for (String key : presentationAttributes.keySet()) {
1046                  LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);
1047                  presentationAttributes.get(key).setExcluded(true);
1048              }
1049          }
1050  
1051          Map idMetadata = getIdMetadata(targetClass);
1052          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
1053          String idProperty = (String) idMetadata.get(&quot;name&quot;);
1054          List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
1055          propertyNames.add(idProperty);
1056          Type idType = (Type) idMetadata.get(&quot;type&quot;);
1057          List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
1058          propertyTypes.add(idType);
1059  
1060          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1061          Iterator testIter = persistentClass.getPropertyIterator();
1062          List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
1063  
1064          //check the properties for problems
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1065 -        while(testIter.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1066 +        while (testIter.hasNext()) {</span>
1067              Property property = (Property) testIter.next();
1068              if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1069                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1069                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;)ðŸ”µ</abbr>
1070              }
1071              propertyList.add(property);
1072          }
1073  
1074          buildProperties(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1075 -            targetClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1076 -            foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1077 -            additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1078 -            additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1079 -            mergedPropertyType,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1080 -            presentationAttributes,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1081 -            propertyList,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1082 -            fields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1083 -            propertyNames,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1084 -            propertyTypes,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1085 -            idProperty,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1086 -            populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1087 -            includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1088 -            excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1089 -            configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1090 -            ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1091 -            parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1092 -            prefix,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1093 -            isParentExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1094 -            false,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1095 -            parentPrefix</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1096 +                targetClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1097 +                foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1098 +                additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1099 +                additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1100 +                mergedPropertyType,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1101 +                presentationAttributes,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1102 +                propertyList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1103 +                fields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1104 +                propertyNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1105 +                propertyTypes,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1106 +                idProperty,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1107 +                populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1108 +                includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1109 +                excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1110 +                configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1111 +                ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1112 +                parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1113 +                prefix,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1114 +                isParentExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1115 +                false,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1116 +                parentPrefix</span>
1117          );
1118          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1119          presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1120          presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1121          if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1122              Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1123              for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1124                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1124                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentPropertðŸ”µ</abbr>
1125                      String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1126                      //get final property if this is a dot delimited property
1127                      int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1128                      if (finalDotPos &gt;= 0) {
<abbr title="1129                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1129                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPoðŸ”µ</abbr>
1130                      }
1131                      //check all the polymorphic types on this target class to see if the end property exists
1132                      Field testField = null;
1133                      Method testMethod = null;
1134                      for (Class&lt;?&gt; clazz : entities) {
1135                          try {
1136                              testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1137                              if (testMethod != null) {
1138                                  break;
1139                              }
1140                          } catch (NoSuchMethodException e) {
1141                              //do nothing - method does not exist
1142                          }
1143                          testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1144                          if (testField != null) {
1145                              break;
1146                          }
1147                      }
1148                      //if the property exists, add it to the metadata for this class
1149                      if (testField != null || testMethod != null) {
<abbr title="1150                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1150                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNoðŸ”µ</abbr>
1151                      }
1152                  }
1153              }
1154          }
1155  
1156          return fields;
1157      }
1158  
1159      protected void buildProperties(
1160              Class&lt;?&gt; targetClass,
1161              ForeignKey foreignField,
1162              ForeignKey[] additionalForeignFields,
1163              String[] additionalNonPersistentProperties,
1164              MergedPropertyType mergedPropertyType,
1165              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1166              List&lt;Property&gt; componentProperties,
1167              Map&lt;String, FieldMetadata&gt; fields,
1168              List&lt;String&gt; propertyNames,
1169              List&lt;Type&gt; propertyTypes,
1170              String idProperty,
1171              Boolean populateManyToOneFields,
1172              String[] includeFields,
1173              String[] excludeFields,
1174              String configurationKey,
1175              String ceilingEntityFullyQualifiedClassname,
1176              List&lt;Class&lt;?&gt;&gt; parentClasses,
1177              String prefix,
1178              Boolean isParentExcluded,
1179              Boolean isComponentPrefix,
1180              String parentPrefix) {
1181          int j = 0;
1182          Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1183              @Override
1184              public int compare(String o1, String o2) {
1185                  //check for property name equality and for map field properties
<abbr title="1186                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1186                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FielðŸ”µ</abbr>
1187                      return 0;
1188                  }
1189                  return o1.compareTo(o2);
1190              }
1191          };
1192          List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1193          Collections.sort(presentationKeyList);
1194  
1195          for (String propertyName : propertyNames) {
1196              final Type type = propertyTypes.get(j);
1197              boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1198              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1198              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix,ðŸ”µ</abbr>
1199              j++;
1200              Field myField = getFieldManager().getField(targetClass, propertyName);
1201              if (myField == null) {
<abbr title="1202                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1202                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded ðŸ”µ</abbr>
1203                  myField = getFieldManager().getField(targetClass, prefix + propertyName);
1204              }
1205              if (
1206                      !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1207 -                    isPropertyForeignKey ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1208 -                    additionalForeignKeyIndexPosition &gt;= 0 ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1209 -                    Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1210 -            ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1211 +                            isPropertyForeignKey ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1212 +                            additionalForeignKeyIndexPosition &gt;= 0 ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1213 +                            Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1214 +                    ) {</span>
1215                  if (myField != null) {
1216                      boolean handled = false;
1217                      for (FieldMetadataProvider provider : fieldMetadataProviders) {
1218                          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1219                          if (presentationAttribute != null) {
1220                              setExcludedBasedOnShowIfProperty(presentationAttribute);
1221                          }
1222                          MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1223                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1223                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalðŸ”µ</abbr>
1224                                          mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1225                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1225                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPositioðŸ”µ</abbr>
<abbr title="1226                                          presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1226                                          presentationAttributes, presentationAttribute, null, type.getReturnedClassðŸ”µ</abbr>
1227                          if (MetadataProviderResponse.NOT_HANDLED != response) {
1228                              handled = true;
1229                          }
1230                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
1231                              break;
1232                          }
1233                      }
1234                      if (!handled) {
1235                          buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1236 -                            additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1237 -                            componentProperties, fields, idProperty, populateManyToOneFields, includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1238 -                            excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="1239 -                            prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1239 -                            prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1240 +                                additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1241 +                                componentProperties, fields, idProperty, populateManyToOneFields, includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1242 +                                excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1242 +                                excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClassðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1243 +                                prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1243 +                                prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeðŸ”µ</abbr></span>
1244                      }
1245                  }
1246              }
1247          }
1248      }
1249  
1250      public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1251          setExcludedBasedOnShowIfProperty(presentationAttribute);
1252  
<abbr title="1253          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1253          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttðŸ”µ</abbr>
1254  
1255      }
1256  
1257      protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1258          if (fieldMetadata != null
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1259 -            &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1260 -            &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1261 -            &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1262 +                &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1263 +                &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1264 +                &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {</span>
1265  
1266              //do not include this in the display if it returns false.
1267              fieldMetadata.setExcluded(true);
1268          }
1269      }
1270  
<abbr title="1271      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1271      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, ClasðŸ”µ</abbr>
<abbr title="1272                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1272                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefixðŸ”µ</abbr>
1273  
<abbr title="1274          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1274          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, tarðŸ”µ</abbr>
1275                  ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1276  
<abbr title="1277          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1277          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefiðŸ”µ</abbr>
1278                  parentPrefix, propertyName);
1279  
1280          return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1281      }
1282  
<abbr title="1283      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1283      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPreðŸ”µ</abbr>
1284          return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1285      }
1286  
1287      protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1288              propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1289 -            isComponentPrefix) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1290 +                                                            isComponentPrefix) {</span>
1291          Boolean response = false;
1292          //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1293          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1293          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1ðŸ”µ</abbr>
1294          if (shouldTest) {
1295              Field testField = getFieldManager().getField(targetClass, propertyName);
1296              if (testField == null) {
1297                  Class&lt;?&gt;[] entities;
1298                  try {
<abbr title="1299                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1299                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassðŸ”µ</abbr>
1300                  } catch (ClassNotFoundException e) {
1301                      throw new RuntimeException(e);
1302                  }
1303                  for (Class&lt;?&gt; clazz : entities) {
1304                      testField = getFieldManager().getField(clazz, propertyName);
1305                      if (testField != null) {
1306                          break;
1307                      }
1308                  }
1309                  String testProperty = prefix + propertyName;
1310                  if (testField == null) {
1311                      testField = getFieldManager().getField(targetClass, testProperty);
1312                  }
1313                  if (testField == null) {
1314                      for (Class&lt;?&gt; clazz : entities) {
1315                          testField = getFieldManager().getField(clazz, testProperty);
1316                          if (testField != null) {
1317                              break;
1318                          }
1319                      }
1320                  }
1321              }
1322              response = determineExclusionForField(parentClasses, targetClass, testField);
1323          }
1324          return response;
1325      }
1326  
<abbr title="1327      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1327      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testFieðŸ”µ</abbr>
1328          Boolean response = false;
1329          if (testField != null) {
1330              Class&lt;?&gt; testType = testField.getType();
1331              for (Class&lt;?&gt; parentClass : parentClasses) {
1332                  if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1333                      response = true;
1334                      break;
1335                  }
1336              }
1337              if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {
1338                  response = true;
1339              }
1340          }
1341          return response;
1342      }
1343  
1344      protected void buildBasicProperty(
1345              Field field,
1346              Class&lt;?&gt; targetClass,
1347              ForeignKey foreignField,
1348              ForeignKey[] additionalForeignFields,
1349              String[] additionalNonPersistentProperties,
1350              MergedPropertyType mergedPropertyType,
1351              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1352              List&lt;Property&gt; componentProperties,
1353              Map&lt;String, FieldMetadata&gt; fields,
1354              String idProperty,
1355              Boolean populateManyToOneFields,
1356              String[] includeFields,
1357              String[] excludeFields,
1358              String configurationKey,
1359              String ceilingEntityFullyQualifiedClassname,
1360              List&lt;Class&lt;?&gt;&gt; parentClasses,
1361              String prefix,
1362              Boolean isParentExcluded,
1363              String propertyName,
1364              Type type,
1365              boolean propertyForeignKey,
1366              int additionalForeignKeyIndexPosition,
1367              Boolean isComponentPrefix,
1368              String parentPrefix) {
1369          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1370          Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1371          Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1372 -            ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +                ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);</span>
1374  
1375          SupportedFieldType explicitType = null;
1376          if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1377              explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1378          }
1379          Class&lt;?&gt; returnedClass = type.getReturnedClass();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1380 -        checkProp: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1381 +        checkProp:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +        {</span>
1383              if (type.isComponentType() &amp;&amp; includeField) {
1384                  buildComponentProperties(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1385 -                    targetClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1386 -                    foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1387 -                    additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1388 -                    additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1389 -                    mergedPropertyType,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1390 -                    fields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1391 -                    idProperty,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1392 -                    populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1393 -                    includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1394 -                    excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1395 -                    configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1396 -                    ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1397 -                    propertyName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1398 -                    type,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1399 -                    returnedClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                    parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -                    amIExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                    prefix,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1403 +                        targetClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1404 +                        foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1405 +                        additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1406 +                        additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1407 +                        mergedPropertyType,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1408 +                        fields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1409 +                        idProperty,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1410 +                        populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1411 +                        includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1412 +                        excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1413 +                        configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1414 +                        ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1415 +                        propertyName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1416 +                        type,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1417 +                        returnedClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1418 +                        parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1419 +                        amIExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1420 +                        prefix,</span>
1421                          parentPrefix);
1422                  break checkProp;
1423              }
1424              /*
1425               * Currently we do not support ManyToOne fields whose class type is the same
1426               * as the target type, since this forms an infinite loop and will cause a stack overflow.
1427               */
1428              if (
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1429 -                type.isEntityType() &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1430 -                !returnedClass.isAssignableFrom(targetClass) &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1431 -                populateManyToOneFields &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1432 -                includeField</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1433 -            ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1434 +                    type.isEntityType() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1435 +                            !returnedClass.isAssignableFrom(targetClass) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1436 +                            populateManyToOneFields &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1437 +                            includeField</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1438 +                    ) {</span>
1439                  buildEntityProperties(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1440 -                    fields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1441 -                    foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1442 -                    additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1443 -                    additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1444 -                    populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1445 -                    includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1446 -                    excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1447 -                    configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1448 -                    ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1449 -                    propertyName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1450 -                    returnedClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1451 -                    targetClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1452 -                    parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1453 -                    prefix,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1454 -                    amIExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1455 -                    parentPrefix</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1456 +                        fields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1457 +                        foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1458 +                        additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1459 +                        additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1460 +                        populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1461 +                        includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1462 +                        excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1463 +                        configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1464 +                        ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1465 +                        propertyName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1466 +                        returnedClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1467 +                        targetClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1468 +                        parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1469 +                        prefix,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1470 +                        amIExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1471 +                        parentPrefix</span>
1472                  );
1473                  break checkProp;
1474              }
1475          }
1476          //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1477          if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1478              defaultFieldMetadataProvider.addMetadataFromFieldType(
1479                      new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,
1480                              mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,
1481                              propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,
1482                              presentationAttribute, explicitType, returnedClass, this), fields);
1483          }
1484      }
1485  
1486      protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1487          boolean isPropertyForeignKey = false;
1488          if (foreignField != null) {
1489              isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1490          }
1491          return isPropertyForeignKey;
1492      }
1493  
<abbr title="1494      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1494      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String properðŸ”µ</abbr>
1495          int additionalForeignKeyIndexPosition = -1;
1496          if (additionalForeignFields != null) {
<abbr title="1497              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1497              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefixðŸ”µ</abbr>
1498                  @Override
1499                  public int compare(ForeignKey o1, ForeignKey o2) {
1500                      return o1.getManyToField().compareTo(o2.getManyToField());
1501                  }
1502              });
1503          }
1504          return additionalForeignKeyIndexPosition;
1505      }
1506  
1507      protected void buildEntityProperties(
1508              Map&lt;String, FieldMetadata&gt; fields,
1509              ForeignKey foreignField,
1510              ForeignKey[] additionalForeignFields,
1511              String[] additionalNonPersistentProperties,
1512              Boolean populateManyToOneFields,
1513              String[] includeFields,
1514              String[] excludeFields,
1515              String configurationKey,
1516              String ceilingEntityFullyQualifiedClassname,
1517              String propertyName,
1518              Class&lt;?&gt; returnedClass,
1519              Class&lt;?&gt; targetClass,
1520              List&lt;Class&lt;?&gt;&gt; parentClasses,
1521              String prefix,
1522              Boolean isParentExcluded,
1523              String parentPrefix) {
1524          Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1525          List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1526  
1527          for (Class&lt;?&gt; parentClass : parentClasses) {
1528              clonedParentClasses.add(parentClass);
1529          }
1530  
1531          clonedParentClasses.add(targetClass);
1532  
1533          Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1534 -            ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1535 -            polymorphicEntities,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1536 -            foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1537 -            additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1538 -            additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1539 -            MergedPropertyType.PRIMARY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1540 -            populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1541 -            includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1542 -            excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1543 -            configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1544 -            clonedParentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1545 -            prefix + propertyName + &#x27;.&#x27;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1546 -            isParentExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1547 -            parentPrefix);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1548 +                ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1549 +                polymorphicEntities,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1550 +                foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1551 +                additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1552 +                additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1553 +                MergedPropertyType.PRIMARY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1554 +                populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1555 +                includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1556 +                excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1557 +                configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1558 +                clonedParentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1559 +                prefix + propertyName + &#x27;.&#x27;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1560 +                isParentExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1561 +                parentPrefix);</span>
1562  
1563          final String targetClassName = targetClass.getName();
1564  
1565          for (FieldMetadata newMetadata : newFields.values()) {
1566              newMetadata.setInheritedFromType(targetClassName);
1567              newMetadata.setAvailableToTypes(new String[]{targetClassName});
1568          }
1569  
1570          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1571  
1572          for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1573              final FieldMetadata fieldMetadata = newField.getValue();
1574              final String key = newField.getKey();
1575  
1576              convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1577  
1578              if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1579                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1579                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata)ðŸ”µ</abbr>
1580                      Class&lt;?&gt; validatorImpl = null;
1581  
1582                      try {
1583                          validatorImpl = Class.forName(validationConfigurations.getKey());
1584                      } catch (ClassNotFoundException e) {
1585                          Object bean = applicationContext.getBean(validationConfigurations.getKey());
1586  
1587                          if (bean != null) {
1588                              validatorImpl = bean.getClass();
1589                          }
1590                      }
1591  
<abbr title="1592                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1592                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl))ðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1593 -                        for (Map&lt;String, String&gt; configs  : validationConfigurations.getValue()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1594 +                        for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {</span>
1595                              for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1596                                  final String value = config.getValue();
1597  
1598                                  if (newFields.containsKey(value)) {
1599                                      config.setValue(propertyName + &quot;.&quot; + value);
1600                                  }
1601                              }
1602                          }
1603                      }
1604                  }
1605              }
1606  
1607              if (isForeignKey(fieldMetadata)) {
1608                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1609              }
1610          }
1611  
1612          fields.putAll(convertedFields);
1613      }
1614  
1615      protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1616          return fieldMetadata instanceof BasicCollectionMetadata
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="1617 -               &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1617 -               &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="1618 -               &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1618 -               &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveIðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1619 +                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1619 +                &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectivðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="1620 +                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1620 +                &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveðŸ”µ</abbr></span>
1621      }
1622  
1623      /*
1624       * There may be multiple pathways to this foreign key which may have come from a cached source.
1625       * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1626       * to make sure it is set appropriately here.
1627       *
1628       * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1629       * owningSite.embeddableMultitenantSite.adminUsers.
1630       */
<abbr title="1631      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1631      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) ðŸ”µ</abbr>
<abbr title="1632          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1632          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective()ðŸ”µ</abbr>
1633          foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1634      }
1635  
1636      protected void buildComponentProperties(
1637              Class&lt;?&gt; targetClass,
1638              ForeignKey foreignField,
1639              ForeignKey[] additionalForeignFields,
1640              String[] additionalNonPersistentProperties,
1641              MergedPropertyType mergedPropertyType,
1642              Map&lt;String, FieldMetadata&gt; fields,
1643              String idProperty,
1644              Boolean populateManyToOneFields,
1645              String[] includeFields,
1646              String[] excludeFields,
1647              String configurationKey,
1648              String ceilingEntityFullyQualifiedClassname,
1649              String propertyName,
1650              Type type,
1651              Class&lt;?&gt; returnedClass,
1652              List&lt;Class&lt;?&gt;&gt; parentClasses,
1653              Boolean isParentExcluded,
1654              String prefix,
1655              String parentPrefix) {
1656          String[] componentProperties = ((ComponentType) type).getPropertyNames();
1657          List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1658          Type[] componentTypes = ((ComponentType) type).getSubtypes();
1659          List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1660          String tempPrefix = &quot;&quot;;
1661  
1662          int pos = prefix.indexOf(&quot;.&quot;);
1663          final int prefixLength = prefix.length();
1664  
1665          if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1666              //only use part of the prefix if it&#x27;s more than one layer deep
1667              tempPrefix = prefix.substring(pos + 1, prefixLength);
1668          }
1669  
<abbr title="1670          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1670          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targeðŸ”µ</abbr>
1671  
1672          if (isParentExcluded) {
1673              for (String key : componentPresentationAttributes.keySet()) {
1674                  LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);
1675                  componentPresentationAttributes.get(key).setExcluded(true);
1676              }
1677          }
1678  
1679          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1680          Property property;
1681  
1682          try {
1683              property = persistentClass.getProperty(propertyName);
1684          } catch (MappingException e) {
1685              property = persistentClass.getProperty(prefix + propertyName);
1686          }
1687  
<abbr title="1688          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1688          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyItðŸ”µ</abbr>
1689          List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1690  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1691 -        while(componentPropertyIterator.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1692 +        while (componentPropertyIterator.hasNext()) {</span>
1693              componentPropertyList.add((Property) componentPropertyIterator.next());
1694          }
1695  
1696          Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1697          buildProperties(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1698 -            targetClass,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1699 -            foreignField,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1700 -            additionalForeignFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1701 -            additionalNonPersistentProperties,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1702 -            mergedPropertyType,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1703 -            componentPresentationAttributes,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1704 -            componentPropertyList,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1705 -            newFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1706 -            componentPropertyNames,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1707 -            componentPropertyTypes,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1708 -            idProperty,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1709 -            populateManyToOneFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1710 -            includeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1711 -            excludeFields,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -            configurationKey,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1713 -            ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1714 -            parentClasses,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1715 -            propertyName + &quot;.&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1716 -            isParentExcluded,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1717 -            true,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1718 -            parentPrefix + prefix</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1719 +                targetClass,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1720 +                foreignField,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1721 +                additionalForeignFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1722 +                additionalNonPersistentProperties,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1723 +                mergedPropertyType,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1724 +                componentPresentationAttributes,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1725 +                componentPropertyList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1726 +                newFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1727 +                componentPropertyNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1728 +                componentPropertyTypes,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1729 +                idProperty,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1730 +                populateManyToOneFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1731 +                includeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1732 +                excludeFields,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1733 +                configurationKey,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1734 +                ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1735 +                parentClasses,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1736 +                propertyName + &quot;.&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1737 +                isParentExcluded,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1738 +                true,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1739 +                parentPrefix + prefix</span>
1740          );
1741  
1742          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1743  
1744          for (String key : newFields.keySet()) {
1745              final FieldMetadata fieldMetadata = newFields.get(key);
1746              convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1747  
1748              if (isForeignKey(fieldMetadata)) {
1749                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1750              }
1751          }
1752          fields.putAll(convertedFields);
1753      }
1754  
1755      @Override
1756      public EntityManager getStandardEntityManager() {
1757          return standardEntityManager;
1758      }
1759  
1760      @Override
1761      public void setStandardEntityManager(EntityManager entityManager) {
1762          this.standardEntityManager = entityManager;
1763          fieldManager = new FieldManager(entityConfiguration, entityManager);
1764      }
1765  
1766      @Override
1767      public EJB3ConfigurationDao getEjb3ConfigurationDao() {
1768          return ejb3ConfigurationDao;
1769      }
1770  
1771      @Override
1772      public void setEjb3ConfigurationDao(EJB3ConfigurationDao ejb3ConfigurationDao) {
1773          this.ejb3ConfigurationDao = ejb3ConfigurationDao;
1774      }
1775  
1776      @Override
1777      public FieldManager getFieldManager() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1778 +        return this.getFieldManager(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1779 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1780 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1781 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1782 +    public FieldManager getFieldManager(boolean cleanFieldManager) {</span>
1783          if (fieldManager == null) {
1784              //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1785              // we re-init fieldManager in setStandardEntityManager method
1786              fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1787 -        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1788 +        } else if (cleanFieldManager){</span>
1789              fieldManager.clearMiddleFields();
1790          }
1791          return fieldManager;

1792      }
1793  
1794      @Override
1795      public EntityConfiguration getEntityConfiguration() {
1796          return entityConfiguration;
1797      }
1798  
1799      @Override
1800      public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1801          this.entityConfiguration = entityConfiguration;
1802      }
1803  
1804      @Override
1805      public Metadata getMetadata() {
1806          return metadata;
1807      }
1808  
1809      @Override
1810      public void setMetadata(Metadata metadata) {
1811          this.metadata = metadata;
1812      }
1813  
1814      public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1815          return fieldMetadataProviders;
1816      }
1817  
1818      public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1819          this.fieldMetadataProviders = fieldMetadataProviders;
1820      }
1821  
1822      @Override
1823      public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1824          return defaultFieldMetadataProvider;
1825      }
1826  
1827      public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1828          this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1829      }
1830  
1831      protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1832          return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1833      }
1834  
1835      @Override
1836      public DynamicDaoHelper getDynamicDaoHelper() {
1837          return dynamicDaoHelper;
1838      }
1839  
1840      public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1841          this.dynamicDaoHelper = dynamicDaoHelper;
1842      }
1843  
1844  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            