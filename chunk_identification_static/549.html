<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>549</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    549
                    <a href="548.html">prev</a>
                    <a href="550.html">next</a>
                    <a href="549_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_a207ac605e23d86ca01cffc317e7b6746f3539b1_src/com/android/launcher2/AppsCustomizePagedView.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;a207ac605e23d86ca01cffc317e7b6746f3539b1:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;a207ac605e23d86ca01cffc317e7b6746f3539b1^1:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;a207ac605e23d86ca01cffc317e7b6746f3539b1^2:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;64c9ab318817d5f098fa0fed7d893f630189b657:src/com/android/launcher2/AppsCustomizePagedView.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [s], [s], [s]], subset: [[bj], [s], [s], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.AnimatorSet;
  20 import android.animation.ObjectAnimator;
  21 import android.animation.ValueAnimator;
  22 import android.appwidget.AppWidgetHostView;
  23 import android.appwidget.AppWidgetManager;
  24 import android.appwidget.AppWidgetProviderInfo;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.ResolveInfo;
  30 import android.content.res.Configuration;
  31 import android.content.res.Resources;
  32 import android.content.res.TypedArray;
  33 import android.graphics.Bitmap;
  34 import android.graphics.Bitmap.Config;
  35 import android.graphics.Canvas;
  36 import android.graphics.MaskFilter;
  37 import android.graphics.Matrix;
  38 import android.graphics.Paint;
  39 import android.graphics.Rect;
  40 import android.graphics.RectF;
  41 import android.graphics.TableMaskFilter;
  42 import android.graphics.drawable.Drawable;
  43 import android.os.AsyncTask;
  44 import android.os.Process;
  45 import android.util.AttributeSet;
  46 import android.util.Log;
  47 import android.view.Gravity;
  48 import android.view.KeyEvent;
  49 import android.view.LayoutInflater;
  50 import android.view.MotionEvent;
  51 import android.view.View;
  52 import android.view.ViewConfiguration;
  53 import android.view.ViewGroup;
  54 import android.view.animation.AccelerateInterpolator;
  55 import android.view.animation.DecelerateInterpolator;
  56 import android.widget.GridLayout;
  57 import android.widget.ImageView;
  58 import android.widget.Toast;
  59 
  60 import com.android.launcher.R;
  61 import com.android.launcher2.DropTarget.DragObject;
  62 
  63 import java.util.ArrayList;
  64 import java.util.Collections;
  65 import java.util.Iterator;
  66 import java.util.List;
  67 
  68 /**
  69  * A simple callback interface which also provides the results of the task.
  70  */
  71 interface AsyncTaskCallback {
  72     void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  73 }
  74 
  75 /**
  76  * The data needed to perform either of the custom AsyncTasks.
  77  */
  78 class AsyncTaskPageData {
  79     enum Type {
  80         LoadWidgetPreviewData
  81     }
  82 
  83     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  84             AsyncTaskCallback postR) {
  85         page = p;
  86         items = l;
  87         sourceImages = si;
  88         generatedImages = new ArrayList&lt;Bitmap&gt;();
  89         maxImageWidth = maxImageHeight = -1;
  90         doInBackgroundCallback = bgR;
  91         postExecuteCallback = postR;
  92     }
  93     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
  94             AsyncTaskCallback postR) {
  95         page = p;
  96         items = l;
  97         generatedImages = new ArrayList&lt;Bitmap&gt;();
  98         maxImageWidth = cw;
  99         maxImageHeight = ch;
 100         doInBackgroundCallback = bgR;
 101         postExecuteCallback = postR;
 102     }
 103     void cleanup(boolean cancelled) {
 104         // Clean up any references to source/generated bitmaps
 105         if (sourceImages != null) {
 106             if (cancelled) {
 107                 for (Bitmap b : sourceImages) {
 108                     b.recycle();
 109                 }
 110             }
 111             sourceImages.clear();
 112         }
 113         if (generatedImages != null) {
 114             if (cancelled) {
 115                 for (Bitmap b : generatedImages) {
 116                     b.recycle();
 117                 }
 118             }
 119             generatedImages.clear();
 120         }
 121     }
 122     int page;
 123     ArrayList&lt;Object&gt; items;
 124     ArrayList&lt;Bitmap&gt; sourceImages;
 125     ArrayList&lt;Bitmap&gt; generatedImages;
 126     int maxImageWidth;
 127     int maxImageHeight;
 128     AsyncTaskCallback doInBackgroundCallback;
 129     AsyncTaskCallback postExecuteCallback;
 130 }
 131 
 132 /**
 133  * A generic template for an async task used in AppsCustomize.
 134  */
 135 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 136     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 137         page = p;
 138         threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 139         dataType = ty;
 140     }
 141     @Override
 142     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 143         if (params.length != 1) return null;
 144         // Load each of the widget previews in the background
 145         params[0].doInBackgroundCallback.run(this, params[0]);
 146         return params[0];
 147     }
 148     @Override
 149     protected void onPostExecute(AsyncTaskPageData result) {
 150         // All the widget previews are loaded, so we can just callback to inflate the page
 151         result.postExecuteCallback.run(this, result);
 152     }
 153 
 154     void setThreadPriority(int p) {
 155         threadPriority = p;
 156     }
 157     void syncThreadPriority() {
 158         Process.setThreadPriority(threadPriority);
 159     }
 160 
 161     // The page that this async task is associated with
 162     AsyncTaskPageData.Type dataType;
 163     int page;
 164     int threadPriority;
 165 }
 166 
 167 /**
 168  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 169  */
 170 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 171         AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,
 172         PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 173         LauncherTransitionable {
 174     static final String LOG_TAG = &quot;AppsCustomizePagedView&quot;;
 175 
 176     /**
 177      * The different content types that this paged view can show.
 178      */
 179     public enum ContentType {
 180         Applications,
 181         Widgets
 182     }
 183 
 184     // Refs
 185     private Launcher mLauncher;
 186     private DragController mDragController;
 187     private final LayoutInflater mLayoutInflater;
 188     private final PackageManager mPackageManager;
 189 
 190     // Save and Restore
 191     private int mSaveInstanceStateItemIndex = -1;
 192     private PagedViewIcon mPressedIcon;
 193 
 194     // Content
 195     private ArrayList&lt;ApplicationInfo&gt; mApps;
 196     private ArrayList&lt;Object&gt; mWidgets;
 197 
 198     // Cling
 199     private boolean mHasShownAllAppsCling;
 200     private int mClingFocusedX;
 201     private int mClingFocusedY;
 202 
 203     // Caching
 204     private Canvas mCanvas;
 205     private Drawable mDefaultWidgetBackground;
 206     private IconCache mIconCache;
 207 
 208     // Dimens
 209     private int mContentWidth;
 210     private int mAppIconSize;
 211     private int mMaxAppCellCountX, mMaxAppCellCountY;
 212     private int mWidgetCountX, mWidgetCountY;
 213     private int mWidgetWidthGap, mWidgetHeightGap;
 214     private final int mWidgetPreviewIconPaddedDimension;
 215     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 216     private PagedViewCellLayout mWidgetSpacingLayout;
 217     private int mNumAppsPages;
 218     private int mNumWidgetPages;
 219 
 220     // Relating to the scroll and overscroll effects
 221     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 222     private static float CAMERA_DISTANCE = 6500;
 223     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 224     private static float TRANSITION_PIVOT = 0.65f;
 225     private static float TRANSITION_MAX_ROTATION = 22;
 226     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 227     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 228     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 229 
 230     // Previews &amp; outlines
 231     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 232     private static final int sPageSleepDelay = 200;
 233 
 234     private Runnable mInflateWidgetRunnable = null;
 235     private Runnable mBindWidgetRunnable = null;
 236     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 237     static final int WIDGET_BOUND = 0;
 238     static final int WIDGET_INFLATED = 1;
 239     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 240     int mWidgetLoadingId = -1;
 241     PendingAddWidgetInfo mCreateWidgetInfo = null;
 242     private boolean mDraggingWidget = false;
 243 
 244     // Deferral of loading widget previews during launcher transitions
 245     private boolean mInTransition;
 246     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 247         new ArrayList&lt;AsyncTaskPageData&gt;();
 248 
 249     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 250         super(context, attrs);
 251         mLayoutInflater = LayoutInflater.from(context);
 252         mPackageManager = context.getPackageManager();
 253         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 254         mWidgets = new ArrayList&lt;Object&gt;();
 255         mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 256         mCanvas = new Canvas();
 257         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 258 
 259         // Save the default widget preview background
 260         Resources resources = context.getResources();
 261         mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 262         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 263 
 264         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 265         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 266         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 267         mWidgetWidthGap =
 268             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 269         mWidgetHeightGap =
 270             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 271         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 272         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 273         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 274         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 275         a.recycle();
 276         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 277 
 278         // The padding on the non-matched dimension for the default widget preview icons
 279         // (top + bottom)
 280         mWidgetPreviewIconPaddedDimension =
 281             (int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPercentage)));
 282         mFadeInAdjacentScreens = false;
 283     }
 284 
 285     @Override
 286     protected void init() {
 287         super.init();
 288         mCenterPagesVertically = false;
 289 
 290         Context context = getContext();
 291         Resources r = context.getResources();
 292         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 293     }
 294 
 295     @Override
 296     protected void onUnhandledTap(MotionEvent ev) {
 297         if (LauncherApplication.isScreenLarge()) {
 298             // Dismiss AppsCustomize if we tap
 299             mLauncher.showWorkspace(true);
 300         }
 301     }
 302 
 303     /** Returns the item index of the center item on this page so that we can restore to this
 304      *  item index when we rotate. */
 305     private int getMiddleComponentIndexOnCurrentPage() {
 306         int i = -1;
 307         if (getPageCount() &gt; 0) {
 308             int currentPage = getCurrentPage();
 309             if (currentPage &lt; mNumAppsPages) {
 310                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 311                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 312                 int numItemsPerPage = mCellCountX * mCellCountY;
 313                 int childCount = childrenLayout.getChildCount();
 314                 if (childCount &gt; 0) {
 315                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 316                 }
 317             } else {
 318                 int numApps = mApps.size();
 319                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 320                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 321                 int childCount = layout.getChildCount();
 322                 if (childCount &gt; 0) {
 323                     i = numApps +
 324                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 325                 }
 326             }
 327         }
 328         return i;
 329     }
 330 
 331     /** Get the index of the item to restore to if we need to restore the current page. */
 332     int getSaveInstanceStateIndex() {
 333         if (mSaveInstanceStateItemIndex == -1) {
 334             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 335         }
 336         return mSaveInstanceStateItemIndex;
 337     }
 338 
 339     /** Returns the page in the current orientation which is expected to contain the specified
 340      *  item index. */
 341     int getPageForComponent(int index) {
 342         if (index &lt; 0) return 0;
 343 
 344         if (index &lt; mApps.size()) {
 345             int numItemsPerPage = mCellCountX * mCellCountY;
 346             return (index / numItemsPerPage);
 347         } else {
 348             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 349             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 350         }
 351     }
 352 
 353     /**
 354      * This differs from isDataReady as this is the test done if isDataReady is not set.
 355      */
 356     private boolean testDataReady() {
 357         // We only do this test once, and we default to the Applications page, so we only really
 358         // have to wait for there to be apps.
 359         // TODO: What if one of them is validly empty
 360         return !mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty();
 361     }
 362 
 363     /** Restores the page for an item at the specified index */
 364     void restorePageForIndex(int index) {
 365         if (index &lt; 0) return;
 366         mSaveInstanceStateItemIndex = index;
 367     }
 368 
 369     private void updatePageCounts() {
 370         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 371                 (float) (mWidgetCountX * mWidgetCountY));
 372         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 373     }
 374 
 375     protected void onDataReady(int width, int height) {
 376         // Note that we transpose the counts in portrait so that we get a similar layout
 377         boolean isLandscape = getResources().getConfiguration().orientation ==
 378             Configuration.ORIENTATION_LANDSCAPE;
 379         int maxCellCountX = Integer.MAX_VALUE;
 380         int maxCellCountY = Integer.MAX_VALUE;
 381         if (LauncherApplication.isScreenLarge()) {
 382             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 383                 LauncherModel.getCellCountY());
 384             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 385                 LauncherModel.getCellCountX());
 386         }
 387         if (mMaxAppCellCountX &gt; -1) {
 388             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 389         }
 390         if (mMaxAppCellCountY &gt; -1) {
 391             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 392         }
 393 
 394         // Now that the data is ready, we can calculate the content width, the number of cells to
 395         // use for each page
 396         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 397         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 398                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 399         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 400         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 401         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 402         updatePageCounts();
 403 
 404         // Force a measure to update recalculate the gaps
 405         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 406         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 407         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 408         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 409 
 410         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 411         final boolean hostIsTransitioning = host.isTransitioning();
 412 
 413         // Restore the page
 414         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 415         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 416 
 417         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 418         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 419         // returned while animating)
 420         if (!hostIsTransitioning) {
 421             post(new Runnable() {
 422                 @Override
 423                 public void run() {
 424                     showAllAppsCling();
 425                 }
 426             });
 427         }
 428     }
 429 
 430     void showAllAppsCling() {
 431         if (!mHasShownAllAppsCling &amp;&amp; isDataReady() &amp;&amp; testDataReady()) {
 432             mHasShownAllAppsCling = true;
 433             // Calculate the position for the cling punch through
 434             int[] offset = new int[2];
 435             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 436             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 437             // PagedViews are centered horizontally but top aligned
 438             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 439                     offset[0];
 440             pos[1] += offset[1];
 441             mLauncher.showFirstRunAllAppsCling(pos);
 442         }
 443     }
 444 
 445     @Override
 446     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 447         int width = MeasureSpec.getSize(widthMeasureSpec);
 448         int height = MeasureSpec.getSize(heightMeasureSpec);
 449         if (!isDataReady()) {
 450             if (testDataReady()) {
 451                 setDataIsReady();
 452                 setMeasuredDimension(width, height);
 453                 onDataReady(width, height);
 454             }
 455         }
 456 
 457         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 458     }
 459 
 460     public void onPackagesUpdated() {
 461         // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered
 462         // by a broadcast receiver, and in order for it to work correctly, we need to know that
 463         // the AppWidgetService has already received and processed the same broadcast. Since there
 464         // is no guarantee about ordering of broadcast receipt, we just delay here. Ideally,
 465         // we should have a more precise way of ensuring the AppWidgetService is up to date.
 466         postDelayed(new Runnable() {
 467            public void run() {
 468                updatePackages();
 469            }
 470         }, 500);
 471     }
 472 
 473     public void updatePackages() {
 474         // Get the list of widgets and shortcuts
 475         boolean wasEmpty = mWidgets.isEmpty();
 476         mWidgets.clear();
 477         List&lt;AppWidgetProviderInfo&gt; widgets =
 478             AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 479         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 480         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 481         for (AppWidgetProviderInfo widget : widgets) {
 482             if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 483                 // Ensure that all widgets we show can be added on a workspace of this size
 484                 int[] spanXY = mLauncher.getSpanForWidget(widget);
 485                 int[] minSpanXY = mLauncher.getMinSpanForWidget(widget);
 486                 int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 487                 int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 488                 if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 489                         minSpanY &lt;= LauncherModel.getCellCountY()) {
 490                     mWidgets.add(widget);
 491                 }
 492             } else {
 493                 Log.e(LOG_TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 494                         widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 495             }
 496         }
 497         mWidgets.addAll(shortcuts);
 498         Collections.sort(mWidgets,
 499                 new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 500         updatePageCounts();
 501 
 502         if (wasEmpty) {
 503             // The next layout pass will trigger data-ready if both widgets and apps are set, so request
 504             // a layout to do this test and invalidate the page data when ready.
 505             if (testDataReady()) requestLayout();
 506         } else {
 507             cancelAllTasks();
 508             invalidatePageData();
 509         }
 510     }
 511 
 512     @Override
 513     public void onClick(View v) {
 514         // When we have exited all apps or are in transition, disregard clicks
 515         if (!mLauncher.isAllAppsCustomizeOpen() ||
 516                 mLauncher.getWorkspace().isSwitchingState()) return;
 517 
 518         if (v instanceof PagedViewIcon) {
 519             // Animate some feedback to the click
 520             final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 521             mLauncher.startActivitySafely(appInfo.intent, appInfo);
 522 
 523             // Lock the drawable state to pressed until we return to Launcher
 524             if (mPressedIcon != null) {
 525                 mPressedIcon.lockDrawableState();
 526             }
 527         } else if (v instanceof PagedViewWidget) {
 528             // Let the user know that they have to long press to add a widget
 529             Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 530                     Toast.LENGTH_SHORT).show();
 531 
 532             // Create a little animation to show that the widget can move
 533             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 534             final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 535             AnimatorSet bounce = new AnimatorSet();
 536             ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);
 537             tyuAnim.setDuration(125);
 538             ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);
 539             tydAnim.setDuration(100);
 540             bounce.play(tyuAnim).before(tydAnim);
 541             bounce.setInterpolator(new AccelerateInterpolator());
 542             bounce.start();
 543         }
 544     }
 545 
 546     public boolean onKey(View v, int keyCode, KeyEvent event) {
 547         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 548     }
 549 
 550     /*
 551      * PagedViewWithDraggableItems implementation
 552      */
 553     @Override
 554     protected void determineDraggingStart(android.view.MotionEvent ev) {
 555         // Disable dragging by pulling an app down for now.
 556     }
 557 
 558     private void beginDraggingApplication(View v) {
 559         mLauncher.getWorkspace().onDragStartedWithItem(v);
 560         mLauncher.getWorkspace().beginDragShared(v, this);
 561     }
 562 
 563     private void loadWidgetInBackground(final PendingAddWidgetInfo info) {
 564         final AppWidgetProviderInfo pInfo = info.info;
 565         if (pInfo.configure != null) {
 566             return;
 567         }
 568 
 569         mBindWidgetRunnable = new Runnable() {
 570             @Override
 571             public void run() {
 572                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 573                 AppWidgetManager.getInstance(mLauncher).bindAppWidgetId(mWidgetLoadingId,
 574                         info.componentName);
 575                 mWidgetCleanupState = WIDGET_BOUND;
 576             }
 577         };
 578         post(mBindWidgetRunnable);
 579 
 580         mInflateWidgetRunnable = new Runnable() {
 581             @Override
 582             public void run() {
 583                 AppWidgetHostView hostView =
 584                         mLauncher.getAppWidgetHost().createView(mContext, mWidgetLoadingId, pInfo);
 585                 info.boundWidget = hostView;
 586                 mWidgetCleanupState = WIDGET_INFLATED;
 587                 hostView.setVisibility(INVISIBLE);
 588                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 589                         info.spanY, info, false);
 590 
 591                 // We want the first widget layout to be the correct size. This will be important
 592                 // for width size reporting to the AppWidgetManager.
 593                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 594                         unScaledSize[1]);
 595                 lp.x = lp.y = 0;
 596                 lp.customPosition = true;
 597                 hostView.setLayoutParams(lp);
 598                 mLauncher.getDragLayer().addView(hostView);
 599             }
 600         };
 601         post(mInflateWidgetRunnable);
 602     }
 603 
 604     @Override
 605     public void onShortPress(View v) {
 606         // We are anticipating a long press, and we use this time to load bind and instantiate
 607         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 608         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 609         loadWidgetInBackground(mCreateWidgetInfo);
 610     }
 611 
 612     private void cleanupWidgetPreloading() {
 613         PendingAddWidgetInfo info = mCreateWidgetInfo;
 614         mCreateWidgetInfo = null;
 615         if (mWidgetCleanupState &gt;= 0 &amp;&amp; mWidgetLoadingId != -1) {
 616             mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 617         }
 618         if (mWidgetCleanupState == WIDGET_BOUND) {
 619             removeCallbacks(mInflateWidgetRunnable);
 620         } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 621             AppWidgetHostView widget = info.boundWidget;
 622             int widgetId = widget.getAppWidgetId();
 623             mLauncher.getAppWidgetHost().deleteAppWidgetId(widgetId);
 624             mLauncher.getDragLayer().removeView(widget);
 625         }
 626         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 627         mWidgetLoadingId = -1;
 628     }
 629 
 630     @Override
 631     public void cleanUpShortPress(View v) {
 632         if (!mDraggingWidget) {
 633             cleanupWidgetPreloading();
 634         }
 635     }
 636 
 637     private void beginDraggingWidget(View v) {
 638         mDraggingWidget = true;
 639         // Get the widget preview as the drag representation
 640         ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 641         PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 642 
 643         // Compose the drag image
 644         Bitmap preview;
 645         Bitmap outline;
 646         float scale = 1f;
 647         if (createItemInfo instanceof PendingAddWidgetInfo) {
 648             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 649             createItemInfo = createWidgetInfo;
 650             int spanX = createItemInfo.spanX;
 651             int spanY = createItemInfo.spanY;
 652             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 653                     createWidgetInfo, true);
 654 
 655             FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 656             float minScale = 1.25f;
 657             int minWidth, minHeight;
 658             minWidth = Math.max((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 659             minHeight = Math.max((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 660             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 661                     createWidgetInfo.icon, spanX, spanY, minWidth, minHeight);
 662 
 663             // Determine the image view drawable scale relative to the preview
 664             float[] mv = new float[9];
 665             Matrix m = new Matrix();
 666             m.setRectToRect(
 667                     new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 668                     new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 669                             (float) previewDrawable.getIntrinsicHeight()),
 670                     Matrix.ScaleToFit.START);
 671             m.getValues(mv);
 672             scale = (float) mv[0];
 673         } else {
 674             // Workaround for the fact that we don&#x27;t keep the original ResolveInfo associated with
 675             // the shortcut around.  To get the icon, we just render the preview image (which has
 676             // the shortcut icon) to a new drag bitmap that clips the non-icon space.
 677             preview = Bitmap.createBitmap(mWidgetPreviewIconPaddedDimension,
 678                     mWidgetPreviewIconPaddedDimension, Bitmap.Config.ARGB_8888);
 679             Drawable d = image.getDrawable();
 680             mCanvas.setBitmap(preview);
 681             d.draw(mCanvas);
 682             mCanvas.setBitmap(null);
 683             createItemInfo.spanX = createItemInfo.spanY = 1;
 684         }
 685 
 686         // We use a custom alpha clip table for the default widget previews
 687         Paint alphaClipPaint = null;
 688         if (createItemInfo instanceof PendingAddWidgetInfo) {
 689             if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 690                 MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 691                 alphaClipPaint = new Paint();
 692                 alphaClipPaint.setMaskFilter(alphaClipTable);
 693             }
 694         }
 695 
 696         // Save the preview for the outline generation, then dim the preview
 697         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 698                 false);
 699 
 700         // Start the drag
 701         alphaClipPaint = null;
 702         mLauncher.lockScreenOrientationOnLargeUI();
 703         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);
 704         mDragController.startDrag(image, preview, this, createItemInfo,
 705                 DragController.DRAG_ACTION_COPY, null, scale);
 706         outline.recycle();
 707         preview.recycle();
 708     }
 709 
 710     @Override
 711     protected boolean beginDragging(final View v) {
 712         if (!super.beginDragging(v)) return false;
 713 
 714         if (v instanceof PagedViewIcon) {
 715             beginDraggingApplication(v);
 716         } else if (v instanceof PagedViewWidget) {
 717             beginDraggingWidget(v);
 718         }
 719 
 720         // We delay entering spring-loaded mode slightly to make sure the UI
 721         // thready is free of any work.
 722         postDelayed(new Runnable() {
 723             @Override
 724             public void run() {
 725                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 726                 if (mLauncher.getDragController().isDragging()) {
 727                     // Dismiss the cling
 728                     mLauncher.dismissAllAppsCling(null);
 729 
 730                     // Reset the alpha on the dragged icon before we drag
 731                     resetDrawableState();
 732 
 733                     // Go into spring loaded mode (must happen before we startDrag())
 734                     mLauncher.enterSpringLoadedDragMode();
 735                 }
 736             }
 737         }, 150);
 738 
 739         return true;
 740     }
 741 
 742     /**
 743      * Clean up after dragging.
 744      *
 745      * @param target where the item was dragged to (can be null if the item was flung)
 746      */
 747     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 748         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 749                 !(target instanceof DeleteDropTarget))) {
 750             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 751             // drop in Workspace
 752             mLauncher.exitSpringLoadedDragMode();
 753         }
 754         mLauncher.unlockScreenOrientationOnLargeUI();
 755     }
 756 
 757     @Override
 758     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 759         mInTransition = true;
 760         if (toWorkspace) {
 761             cancelAllTasks();
 762         }
 763     }
 764 
 765     @Override
 766     public View getContent() {
 767         return null;
 768     }
 769 
 770     @Override
 771     public void onLauncherTransitionStep(Launcher l, float t) {
 772     }
 773 
 774     @Override
 775     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 776         mInTransition = false;
 777         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 778             onSyncWidgetPageItems(d);
 779         }
 780         mDeferredSyncWidgetPageItems.clear();
 781     }
 782 
 783     @Override
 784     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 785             boolean success) {
 786         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 787         if (isFlingToDelete) return;
 788 
 789         endDragging(target, false, success);
 790 
 791         // Display an error message if the drag failed due to there not being enough space on the
 792         // target layout we were dropping on.
 793         if (!success) {
 794             boolean showOutOfSpaceMessage = false;
 795             if (target instanceof Workspace) {
 796                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 797                 Workspace workspace = (Workspace) target;
 798                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 799                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 800                 if (layout != null) {
 801                     layout.calculateSpans(itemInfo);
 802                     showOutOfSpaceMessage =
 803                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 804                 }
 805             }
 806             if (showOutOfSpaceMessage) {
 807                 mLauncher.showOutOfSpaceMessage(false);
 808             }
 809 
 810             d.deferDragViewCleanupPostAnimation = false;
 811             cleanupWidgetPreloading();
 812         }
 813         mDraggingWidget = false;
 814     }
 815 
 816     @Override
 817     public void onFlingToDeleteCompleted() {
 818         // We just dismiss the drag when we fling, so cleanup here
 819         endDragging(null, true, true);
 820         cleanupWidgetPreloading();
 821         mDraggingWidget = false;
 822     }
 823 
 824     @Override
 825     public boolean supportsFlingToDelete() {
 826         return true;
 827     }
 828 
 829     @Override
 830     protected void onDetachedFromWindow() {
 831         super.onDetachedFromWindow();
 832         cancelAllTasks();
 833     }
 834 
 835     public void clearAllWidgetPages() {
 836         cancelAllTasks();
 837         int count = getChildCount();
 838         for (int i = 0; i &lt; count; i++) {
 839             View v = getPageAt(i);
 840             if (v instanceof PagedViewGridLayout) {
 841                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 842                 mDirtyPageContent.set(i, true);
 843             }
 844         }
 845     }
 846 
 847     private void cancelAllTasks() {
 848         // Clean up all the async tasks
 849         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 850         while (iter.hasNext()) {
 851             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 852             task.cancel(false);
 853             iter.remove();
 854             mDirtyPageContent.set(task.page, true);
 855         }
 856     }
 857 
 858     public void setContentType(ContentType type) {
 859         if (type == ContentType.Widgets) {
 860             invalidatePageData(mNumAppsPages, true);
 861         } else if (type == ContentType.Applications) {
 862             invalidatePageData(0, true);
 863         }
 864     }
 865 
 866     protected void snapToPage(int whichPage, int delta, int duration) {
 867         super.snapToPage(whichPage, delta, duration);
 868         updateCurrentTab(whichPage);
 869 
 870         // Update the thread priorities given the direction lookahead
 871         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 872         while (iter.hasNext()) {
 873             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 874             int pageIndex = task.page;
 875             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 876                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 877                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 878             } else {
 879                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 880             }
 881         }
 882     }
 883 
 884     private void updateCurrentTab(int currentPage) {
 885         AppsCustomizeTabHost tabHost = getTabHost();
 886         if (tabHost != null) {
 887             String tag = tabHost.getCurrentTabTag();
 888             if (tag != null) {
 889                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
 890                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 891                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
 892                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 893                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 894                     tabHost.setCurrentTabFromContent(ContentType.Applications);
 895                 }
 896             }
 897         }
 898     }
 899 
 900     /*
 901      * Apps PagedView implementation
 902      */
 903     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 904         int childCount = layout.getChildCount();
 905         for (int i = 0; i &lt; childCount; ++i) {
 906             layout.getChildAt(i).setVisibility(visibility);
 907         }
 908     }
 909     private void setupPage(PagedViewCellLayout layout) {
 910         layout.setCellCount(mCellCountX, mCellCountY);
 911         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 912         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 913                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 914 
 915         // Note: We force a measure here to get around the fact that when we do layout calculations
 916         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 917         // expected page width, so we can actually optimize by hiding all the TextView-based
 918         // children that are expensive to measure, and let that happen naturally later.
 919         setVisibilityOnChildren(layout, View.GONE);
 920         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 921         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 922         layout.setMinimumWidth(getPageContentWidth());
 923         layout.measure(widthSpec, heightSpec);
 924         setVisibilityOnChildren(layout, View.VISIBLE);
 925     }
 926 
 927     public void syncAppsPageItems(int page, boolean immediate) {
 928         // ensure that we have the right number of items on the pages
 929         int numCells = mCellCountX * mCellCountY;
 930         int startIndex = page * numCells;
 931         int endIndex = Math.min(startIndex + numCells, mApps.size());
 932         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 933 
 934         layout.removeAllViewsOnPage();
 935         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 936         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 937         for (int i = startIndex; i &lt; endIndex; ++i) {
 938             ApplicationInfo info = mApps.get(i);
 939             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 940                     R.layout.apps_customize_application, layout, false);
 941             icon.applyFromApplicationInfo(info, true, this);
 942             icon.setOnClickListener(this);
 943             icon.setOnLongClickListener(this);
 944             icon.setOnTouchListener(this);
 945             icon.setOnKeyListener(this);
 946 
 947             int index = i - startIndex;
 948             int x = index % mCellCountX;
 949             int y = index / mCellCountX;
 950             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 951 
 952             items.add(info);
 953             images.add(info.iconBitmap);
 954         }
 955 
 956         layout.createHardwareLayers();
 957     }
 958 
 959     /**
 960      * A helper to return the priority for loading of the specified widget page.
 961      */
 962     private int getWidgetPageLoadPriority(int page) {
 963         // If we are snapping to another page, use that index as the target page index
 964         int toPage = mCurrentPage;
 965         if (mNextPage &gt; -1) {
 966             toPage = mNextPage;
 967         }
 968 
 969         // We use the distance from the target page as an initial guess of priority, but if there
 970         // are no pages of higher priority than the page specified, then bump up the priority of
 971         // the specified page.
 972         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 973         int minPageDiff = Integer.MAX_VALUE;
 974         while (iter.hasNext()) {
 975             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 976             minPageDiff = Math.abs(task.page - toPage);
 977         }
 978 
 979         int rawPageDiff = Math.abs(page - toPage);
 980         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 981     }
 982     /**
 983      * Return the appropriate thread priority for loading for a given page (we give the current
 984      * page much higher priority)
 985      */
 986     private int getThreadPriorityForPage(int page) {
 987         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
 988         int pageDiff = getWidgetPageLoadPriority(page);
 989         if (pageDiff &lt;= 0) {
 990             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
 991         } else if (pageDiff &lt;= 1) {
 992             return Process.THREAD_PRIORITY_LOWEST;
 993         } else {
 994             return Process.THREAD_PRIORITY_LOWEST;
 995         }
 996     }
 997     private int getSleepForPage(int page) {
 998         int pageDiff = getWidgetPageLoadPriority(page);
 999         return Math.max(0, pageDiff * sPageSleepDelay);
1000     }
1001     /**
1002      * Creates and executes a new AsyncTask to load a page of widget previews.
1003      */
1004     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1005             int cellWidth, int cellHeight, int cellCountX) {
1006 
1007         // Prune all tasks that are no longer needed
1008         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1009         while (iter.hasNext()) {
1010             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1011             int taskPage = task.page;
1012             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1013                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1014                 task.cancel(false);
1015                 iter.remove();
1016             } else {
1017                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1018             }
1019         }
1020 
1021         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1022         final int sleepMs = getSleepForPage(page);
1023         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1024             new AsyncTaskCallback() {
1025                 @Override
1026                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1027                     try {
1028                         try {
1029                             Thread.sleep(sleepMs);
1030                         } catch (Exception e) {}
1031                         loadWidgetPreviewsInBackground(task, data);
1032                     } finally {
1033                         if (task.isCancelled()) {
1034                             data.cleanup(true);
1035                         }
1036                     }
1037                 }
1038             },
1039             new AsyncTaskCallback() {
1040                 @Override
1041                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1042                     mRunningTasks.remove(task);
1043                     if (task.isCancelled()) return;
1044                     // do cleanup inside onSyncWidgetPageItems
1045                     onSyncWidgetPageItems(data);
1046                 }
1047             });
1048 
1049         // Ensure that the task is appropriately prioritized and runs in parallel
1050         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1051                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1052         t.setThreadPriority(getThreadPriorityForPage(page));
1053         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1054         mRunningTasks.add(t);
1055     }
1056 
1057     /*
1058      * Widgets PagedView implementation
1059      */
1060     private void setupPage(PagedViewGridLayout layout) {
1061         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1062                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1063 
1064         // Note: We force a measure here to get around the fact that when we do layout calculations
1065         // immediately after syncing, we don&#x27;t have a proper width.
1066         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1067         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1068         layout.setMinimumWidth(getPageContentWidth());
1069         layout.measure(widthSpec, heightSpec);
1070     }
1071 
1072     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1073         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f, 0xFFFFFFFF);
1074     }
1075 
1076     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1077             float scale, int multiplyColor) {
1078         if (bitmap != null) {
1079             Canvas c = new Canvas(bitmap);
1080             c.scale(scale, scale);
1081             Rect oldBounds = d.copyBounds();
1082             d.setBounds(x, y, x + w, y + h);
1083             d.draw(c);
1084             d.setBounds(oldBounds); // Restore the bounds
1085             c.setBitmap(null);
1086         }
1087     }
1088     private Bitmap getShortcutPreview(ResolveInfo info) {
1089         // Render the background
1090         int offset = 0;
1091         int bitmapSize = mAppIconSize;
1092         Bitmap preview = Bitmap.createBitmap(bitmapSize, bitmapSize, Config.ARGB_8888);
1093 
1094         // Render the icon
1095         Drawable icon = mIconCache.getFullResIcon(info);
1096         renderDrawableToBitmap(icon, preview, offset, offset, mAppIconSize, mAppIconSize);
1097         return preview;
1098     }
1099 
1100     private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId,
1101             int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {
1102         // Load the preview image if possible
1103         String packageName = provider.getPackageName();
1104         if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1105         if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1106 
1107         Drawable drawable = null;
1108         if (previewImage != 0) {
1109             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1110             if (drawable == null) {
1111                 Log.w(LOG_TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1112                         Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1113             }
1114         }
1115 
1116         int bitmapWidth;
1117         int bitmapHeight;
1118         boolean widgetPreviewExists = (drawable != null);
1119         if (widgetPreviewExists) {
1120             bitmapWidth = drawable.getIntrinsicWidth();
1121             bitmapHeight = drawable.getIntrinsicHeight();
1122         } else {
1123             if (cellHSpan &lt; 1) cellHSpan = 1;
1124             if (cellVSpan &lt; 1) cellVSpan = 1;
1125             // Determine the size of the bitmap for the preview image we will generate
1126             // TODO: This actually uses the apps customize cell layout params, where as we make want
1127             // the Workspace params for more accuracy.
1128             bitmapWidth = mWidgetSpacingLayout.estimateCellWidth(cellHSpan);
1129             bitmapHeight = mWidgetSpacingLayout.estimateCellHeight(cellVSpan);
1130             if (cellHSpan == cellVSpan) {
1131                 // For square widgets, we just have a fixed size for 1x1 and larger-than-1x1
1132                 int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1133                 if (cellHSpan &lt;= 1) {
1134                     bitmapWidth = bitmapHeight = mAppIconSize + 2 * minOffset;
1135                 } else {
1136                     bitmapWidth = bitmapHeight = mAppIconSize + 4 * minOffset;
1137                 }
1138             }
1139         }
1140 
1141         float scale = 1f;
1142         if (bitmapWidth &gt; maxWidth) {
1143             scale = maxWidth / (float) bitmapWidth;
1144         }
1145         if (bitmapHeight * scale &gt; maxHeight) {
1146             scale = maxHeight / (float) bitmapHeight;
1147         }
1148         if (scale != 1f) {
1149             bitmapWidth = (int) (scale * bitmapWidth);
1150             bitmapHeight = (int) (scale * bitmapHeight);
1151         }
1152 
1153         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1154 
1155         if (widgetPreviewExists) {
1156             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1157         } else {
1158             // Generate a preview image if we couldn&#x27;t load one
1159             int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1160             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1161             float iconScale = Math.min((float) smallestSide / (mAppIconSize + 2 * minOffset), 1f);
1162             if (cellHSpan != 1 || cellVSpan != 1) {
1163                 renderDrawableToBitmap(mDefaultWidgetBackground, preview, 0, 0, bitmapWidth,
1164                         bitmapHeight);
1165             }
1166 
1167             // Draw the icon in the top left corner
1168             try {
1169                 Drawable icon = null;
1170                 int hoffset = (int) (bitmapWidth / 2 - mAppIconSize * iconScale / 2);
1171                 int yoffset = (int) (bitmapHeight / 2 - mAppIconSize * iconScale / 2);
1172                 if (iconId &gt; 0) icon = mIconCache.getFullResIcon(packageName, iconId);
1173                 Resources resources = mLauncher.getResources();
1174                 if (icon == null) icon = resources.getDrawable(R.drawable.ic_launcher_application);
1175 
1176                 renderDrawableToBitmap(icon, preview, hoffset, yoffset,
1177                         (int) (mAppIconSize * iconScale),
1178                         (int) (mAppIconSize * iconScale));
1179             } catch (Resources.NotFoundException e) {}
1180         }
1181         return preview;
1182     }
1183 
1184     public void syncWidgetPageItems(final int page, final boolean immediate) {
1185         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1186 
1187         // Calculate the dimensions of each cell we are giving to each widget
1188         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1189         int contentWidth = mWidgetSpacingLayout.getContentWidth();
1190         final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1191                 - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1192         int contentHeight = mWidgetSpacingLayout.getContentHeight();
1193         final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1194                 - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1195 
1196         // Prepare the set of widgets to load previews for in the background
1197         int offset = (page - mNumAppsPages) * numItemsPerPage;
1198         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1199             items.add(mWidgets.get(i));
1200         }
1201 
1202         // Prepopulate the pages with the other widget info, and fill in the previews later
1203         final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1204         layout.setColumnCount(layout.getCellCountX());
1205         for (int i = 0; i &lt; items.size(); ++i) {
1206             Object rawInfo = items.get(i);
1207             PendingAddItemInfo createItemInfo = null;
1208             PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1209                     R.layout.apps_customize_widget, layout, false);
1210             if (rawInfo instanceof AppWidgetProviderInfo) {
1211                 // Fill in the widget information
1212                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1213                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1214 
1215                 // Determine the widget spans and min resize spans.
1216                 int[] spanXY = mLauncher.getSpanForWidget(info);
1217 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
1218 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1219                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1220                 widget.setTag(createItemInfo);</span>
1221 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1222                 int[] size = mLauncher.getWorkspace().estimateItemSize(spanXY[0],</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1223                         spanXY[1], createItemInfo, true);</span>
1224 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1225                 createItemInfo.spanX = spanXY[0];
1226                 createItemInfo.spanY = spanXY[1];
1227                 int[] minSpanXY = mLauncher.getMinSpanForWidget(info);
1228                 createItemInfo.minSpanX = minSpanXY[0];
1229                 createItemInfo.minSpanY = minSpanXY[1];
1230 
1231                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1232                 widget.setTag(createItemInfo);
1233                 widget.setShortPressListener(this);
1234             } else if (rawInfo instanceof ResolveInfo) {
1235                 // Fill in the shortcuts information
1236                 ResolveInfo info = (ResolveInfo) rawInfo;
1237                 createItemInfo = new PendingAddItemInfo();
1238                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1239                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1240                         info.activityInfo.name);
1241                 widget.applyFromResolveInfo(mPackageManager, info);
1242                 widget.setTag(createItemInfo);
1243             }
1244             widget.setOnClickListener(this);
1245             widget.setOnLongClickListener(this);
1246             widget.setOnTouchListener(this);
1247             widget.setOnKeyListener(this);
1248 
1249             // Layout each widget
1250             int ix = i % mWidgetCountX;
1251             int iy = i / mWidgetCountX;
1252             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1253                     GridLayout.spec(iy, GridLayout.LEFT),
1254                     GridLayout.spec(ix, GridLayout.TOP));
1255             lp.width = cellWidth;
1256             lp.height = cellHeight;
1257             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1258             if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1259             if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1260             layout.addView(widget, lp);
1261         }
1262 
1263         // wait until a call on onLayout to start loading, because
1264         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1265         // TODO: can we do a measure/layout immediately?
1266         layout.setOnLayoutListener(new Runnable() {
1267             public void run() {
1268                 // Load the widget previews
1269                 int maxPreviewWidth = cellWidth;
1270                 int maxPreviewHeight = cellHeight;
1271                 if (layout.getChildCount() &gt; 0) {
1272                     PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1273                     int[] maxSize = w.getPreviewSize();
1274                     maxPreviewWidth = maxSize[0];
1275                     maxPreviewHeight = maxSize[1];
1276                 }
1277                 if (immediate) {
1278                     AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1279                             maxPreviewWidth, maxPreviewHeight, null, null);
1280                     loadWidgetPreviewsInBackground(null, data);
1281                     onSyncWidgetPageItems(data);
1282                 } else {
1283                     prepareLoadWidgetPreviewsTask(page, items,
1284                             maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1285                 }
1286             }
1287         });
1288     }
1289     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1290             AsyncTaskPageData data) {
1291         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1292         // previews synchronously
1293         if (task != null) {
1294             // Ensure that this task starts running at the correct priority
1295             task.syncThreadPriority();
1296         }
1297 
1298         // Load each of the widget/shortcut previews
1299         ArrayList&lt;Object&gt; items = data.items;
1300         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1301         int count = items.size();
1302         for (int i = 0; i &lt; count; ++i) {
1303             if (task != null) {
1304                 // Ensure we haven&#x27;t been cancelled yet
1305                 if (task.isCancelled()) break;
1306                 // Before work on each item, ensure that this task is running at the correct
1307                 // priority
1308                 task.syncThreadPriority();
1309             }
1310 
1311             Object rawInfo = items.get(i);
1312             if (rawInfo instanceof AppWidgetProviderInfo) {
1313                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1314                 int[] cellSpans = mLauncher.getSpanForWidget(info);
1315 
1316                 int maxWidth = Math.min(data.maxImageWidth,
1317                         mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1318                 int maxHeight = Math.min(data.maxImageHeight,
1319                         mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1320                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1321                         cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1322                 images.add(b);
1323             } else if (rawInfo instanceof ResolveInfo) {
1324                 // Fill in the shortcuts information
1325                 ResolveInfo info = (ResolveInfo) rawInfo;
1326                 images.add(getShortcutPreview(info));
1327             }
1328         }
1329     }
1330 
1331     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1332         if (mInTransition) {
1333             mDeferredSyncWidgetPageItems.add(data);
1334             return;
1335         }
1336         try {
1337             int page = data.page;
1338             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1339 
1340             ArrayList&lt;Object&gt; items = data.items;
1341             int count = items.size();
1342             for (int i = 0; i &lt; count; ++i) {
1343                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1344                 if (widget != null) {
1345                     Bitmap preview = data.generatedImages.get(i);
1346                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1347                 }
1348             }
1349 
1350             layout.createHardwareLayer();
1351             invalidate();
1352 
1353             // Update all thread priorities
1354             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1355             while (iter.hasNext()) {
1356                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1357                 int pageIndex = task.page;
1358                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1359             }
1360         } finally {
1361             data.cleanup(false);
1362         }
1363     }
1364 
1365     @Override
1366     public void syncPages() {
1367         removeAllViews();
1368         cancelAllTasks();
1369 
1370         Context context = getContext();
1371         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1372             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1373                     mWidgetCountY);
1374             setupPage(layout);
1375             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1376                     LayoutParams.MATCH_PARENT));
1377         }
1378 
1379         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1380             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1381             setupPage(layout);
1382             addView(layout);
1383         }
1384     }
1385 
1386     @Override
1387     public void syncPageItems(int page, boolean immediate) {
1388         if (page &lt; mNumAppsPages) {
1389             syncAppsPageItems(page, immediate);
1390         } else {
1391             syncWidgetPageItems(page, immediate);
1392         }
1393     }
1394 
1395     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1396     // it is in the z-order. This is important to insure touch events are handled correctly.
1397     View getPageAt(int index) {
1398         return getChildAt(indexToPage(index));
1399     }
1400 
1401     @Override
1402     protected int indexToPage(int index) {
1403         return getChildCount() - index - 1;
1404     }
1405 
1406     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1407     @Override
1408     protected void screenScrolled(int screenCenter) {
1409         super.screenScrolled(screenCenter);
1410 
1411         for (int i = 0; i &lt; getChildCount(); i++) {
1412             View v = getPageAt(i);
1413             if (v != null) {
1414                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1415 
1416                 float interpolatedProgress =
1417                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1418                 float scale = (1 - interpolatedProgress) +
1419                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1420                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1421 
1422                 float alpha;
1423 
1424                 if (!LauncherApplication.isScreenLarge() || scrollProgress &lt; 0) {
1425                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1426                         1 - Math.abs(scrollProgress)) : 1.0f;
1427                 } else {
1428                     // On large screens we need to fade the page as it nears its leftmost position
1429                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1430                 }
1431 
1432                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1433                 int pageWidth = v.getMeasuredWidth();
1434                 int pageHeight = v.getMeasuredHeight();
1435 
1436                 if (PERFORM_OVERSCROLL_ROTATION) {
1437                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1438                         // Overscroll to the left
1439                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1440                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1441                         scale = 1.0f;
1442                         alpha = 1.0f;
1443                         // On the first page, we don&#x27;t want the page to have any lateral motion
1444                         translationX = 0;
1445                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1446                         // Overscroll to the right
1447                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1448                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1449                         scale = 1.0f;
1450                         alpha = 1.0f;
1451                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1452                         translationX = 0;
1453                     } else {
1454                         v.setPivotY(pageHeight / 2.0f);
1455                         v.setPivotX(pageWidth / 2.0f);
1456                         v.setRotationY(0f);
1457                     }
1458                 }
1459 
1460                 v.setTranslationX(translationX);
1461                 v.setScaleX(scale);
1462                 v.setScaleY(scale);
1463                 v.setAlpha(alpha);
1464 
1465                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1466                 // it from accepting touches
1467                 if (alpha &lt; ViewConfiguration.ALPHA_THRESHOLD) {
1468                     v.setVisibility(INVISIBLE);
1469                 } else if (v.getVisibility() != VISIBLE) {
1470                     v.setVisibility(VISIBLE);
1471                 }
1472             }
1473         }
1474     }
1475 
1476     protected void overScroll(float amount) {
1477         acceleratedOverScroll(amount);
1478     }
1479 
1480     /**
1481      * Used by the parent to get the content width to set the tab bar to
1482      * @return
1483      */
1484     public int getPageContentWidth() {
1485         return mContentWidth;
1486     }
1487 
1488     @Override
1489     protected void onPageEndMoving() {
1490         super.onPageEndMoving();
1491 
1492         // We reset the save index when we change pages so that it will be recalculated on next
1493         // rotation
1494         mSaveInstanceStateItemIndex = -1;
1495     }
1496 
1497     /*
1498      * AllAppsView implementation
1499      */
1500     @Override
1501     public void setup(Launcher launcher, DragController dragController) {
1502         mLauncher = launcher;
1503         mDragController = dragController;
1504     }
1505     @Override
1506     public void zoom(float zoom, boolean animate) {
1507         // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1508     }
1509     @Override
1510     public boolean isVisible() {
1511         return (getVisibility() == VISIBLE);
1512     }
1513     @Override
1514     public boolean isAnimating() {
1515         return false;
1516     }
1517     @Override
1518     public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1519         mApps = list;
1520         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1521         updatePageCounts();
1522 
1523         // The next layout pass will trigger data-ready if both widgets and apps are set, so 
1524         // request a layout to do this test and invalidate the page data when ready.
1525         if (testDataReady()) requestLayout();
1526     }
1527     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1528         // We add it in place, in alphabetical order
1529         int count = list.size();
1530         for (int i = 0; i &lt; count; ++i) {
1531             ApplicationInfo info = list.get(i);
1532             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1533             if (index &lt; 0) {
1534                 mApps.add(-(index + 1), info);
1535             }
1536         }
1537     }
1538     @Override
1539     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1540         addAppsWithoutInvalidate(list);
1541         updatePageCounts();
1542         invalidatePageData();
1543     }
1544     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1545         ComponentName removeComponent = item.intent.getComponent();
1546         int length = list.size();
1547         for (int i = 0; i &lt; length; ++i) {
1548             ApplicationInfo info = list.get(i);
1549             if (info.intent.getComponent().equals(removeComponent)) {
1550                 return i;
1551             }
1552         }
1553         return -1;
1554     }
1555     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1556         // loop through all the apps and remove apps that have the same component
1557         int length = list.size();
1558         for (int i = 0; i &lt; length; ++i) {
1559             ApplicationInfo info = list.get(i);
1560             int removeIndex = findAppByComponent(mApps, info);
1561             if (removeIndex &gt; -1) {
1562                 mApps.remove(removeIndex);
1563             }
1564         }
1565     }
1566     @Override
1567     public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1568         removeAppsWithoutInvalidate(list);
1569         updatePageCounts();
1570         invalidatePageData();
1571     }
1572     @Override
1573     public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1574         // We remove and re-add the updated applications list because it&#x27;s properties may have
1575         // changed (ie. the title), and this will ensure that the items will be in their proper
1576         // place in the list.
1577         removeAppsWithoutInvalidate(list);
1578         addAppsWithoutInvalidate(list);
1579         updatePageCounts();
1580 
1581         invalidatePageData();
1582     }
1583 
1584     @Override
1585     public void reset() {
1586         // If we have reset, then we should not continue to restore the previous state
1587         mSaveInstanceStateItemIndex = -1;
1588 
1589         AppsCustomizeTabHost tabHost = getTabHost();
1590         String tag = tabHost.getCurrentTabTag();
1591         if (tag != null) {
1592             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1593                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1594             }
1595         }
1596 
1597         if (mCurrentPage != 0) {
1598             invalidatePageData(0);
1599         }
1600     }
1601 
1602     private AppsCustomizeTabHost getTabHost() {
1603         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1604     }
1605 
1606     @Override
1607     public void dumpState() {
1608         // TODO: Dump information related to current list of Applications, Widgets, etc.
1609         ApplicationInfo.dumpApplicationInfoList(LOG_TAG, &quot;mApps&quot;, mApps);
1610         dumpAppWidgetProviderInfoList(LOG_TAG, &quot;mWidgets&quot;, mWidgets);
1611     }
1612 
1613     private void dumpAppWidgetProviderInfoList(String tag, String label,
1614             ArrayList&lt;Object&gt; list) {
1615         Log.d(tag, label + &quot; size=&quot; + list.size());
1616         for (Object i: list) {
1617             if (i instanceof AppWidgetProviderInfo) {
1618                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1619                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1620                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1621                         + &quot; initialLayout=&quot; + info.initialLayout
1622                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1623             } else if (i instanceof ResolveInfo) {
1624                 ResolveInfo info = (ResolveInfo) i;
1625                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1626                         + info.icon);
1627             }
1628         }
1629     }
1630 
1631     @Override
1632     public void surrender() {
1633         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1634         // should stop this now.
1635 
1636         // Stop all background tasks
1637         cancelAllTasks();
1638     }
1639 
1640     @Override
1641     public void iconPressed(PagedViewIcon icon) {
1642         // Reset the previously pressed icon and store a reference to the pressed icon so that
1643         // we can reset it on return to Launcher (in Launcher.onResume())
1644         if (mPressedIcon != null) {
1645             mPressedIcon.resetDrawableState();
1646         }
1647         mPressedIcon = icon;
1648     }
1649 
1650     public void resetDrawableState() {
1651         if (mPressedIcon != null) {
1652             mPressedIcon.resetDrawableState();
1653             mPressedIcon = null;
1654         }
1655     }
1656 
1657     /*
1658      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1659      * widget previews in the background with the AsyncTasks.
1660      */
1661     final static int sLookBehindPageCount = 2;
1662     final static int sLookAheadPageCount = 2;
1663     protected int getAssociatedLowerPageBound(int page) {
1664         final int count = getChildCount();
1665         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1666         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1667         return windowMinIndex;
1668     }
1669     protected int getAssociatedUpperPageBound(int page) {
1670         final int count = getChildCount();
1671         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1672         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1673                 count - 1);
1674         return windowMaxIndex;
1675     }
1676 
1677     @Override
1678     protected String getCurrentPageDescription() {
1679         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1680         int stringId = R.string.default_scroll_format;
1681         int count = 0;
1682         
1683         if (page &lt; mNumAppsPages) {
1684             stringId = R.string.apps_customize_apps_scroll_format;
1685             count = mNumAppsPages;
1686         } else {
1687             page -= mNumAppsPages;
1688             stringId = R.string.apps_customize_widgets_scroll_format;
1689             count = mNumWidgetPages;
1690         }
1691 
1692         return String.format(mContext.getString(stringId), page + 1, count);
1693     }
1694 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.AnimatorSet;
  20 import android.animation.ObjectAnimator;
  21 import android.animation.ValueAnimator;
  22 import android.appwidget.AppWidgetHostView;
  23 import android.appwidget.AppWidgetManager;
  24 import android.appwidget.AppWidgetProviderInfo;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.pm.PackageManager;
  29 import android.content.pm.ResolveInfo;
  30 import android.content.res.Configuration;
  31 import android.content.res.Resources;
  32 import android.content.res.TypedArray;
  33 import android.graphics.Bitmap;
  34 import android.graphics.Bitmap.Config;
  35 import android.graphics.Canvas;
  36 import android.graphics.MaskFilter;
  37 import android.graphics.Matrix;
  38 import android.graphics.Paint;
  39 import android.graphics.Rect;
  40 import android.graphics.RectF;
  41 import android.graphics.TableMaskFilter;
  42 import android.graphics.drawable.Drawable;
  43 import android.os.AsyncTask;
  44 import android.os.Process;
  45 import android.util.AttributeSet;
  46 import android.util.Log;
  47 import android.view.Gravity;
  48 import android.view.KeyEvent;
  49 import android.view.LayoutInflater;
  50 import android.view.MotionEvent;
  51 import android.view.View;
  52 import android.view.ViewConfiguration;
  53 import android.view.ViewGroup;
  54 import android.view.animation.AccelerateInterpolator;
  55 import android.view.animation.DecelerateInterpolator;
  56 import android.widget.GridLayout;
  57 import android.widget.ImageView;
  58 import android.widget.Toast;
  59 
  60 import com.android.launcher.R;
  61 import com.android.launcher2.DropTarget.DragObject;
  62 
  63 import java.util.ArrayList;
  64 import java.util.Collections;
  65 import java.util.Iterator;
  66 import java.util.List;
  67 
  68 /**
  69  * A simple callback interface which also provides the results of the task.
  70  */
  71 
  72 
  73 /**
  74  * A simple callback interface which also provides the results of the task.
  75  */
  76 interface AsyncTaskCallback {
  77     void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  78 }
  79 
  80 /**
  81  * The data needed to perform either of the custom AsyncTasks.
  82  */
  83 
  84 
  85 /**
  86  * The data needed to perform either of the custom AsyncTasks.
  87  */
  88 class AsyncTaskPageData {
  89     enum Type {
  90         LoadWidgetPreviewData
  91     }
  92 
  93     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  94             AsyncTaskCallback postR) {
  95         page = p;
  96         items = l;
  97         sourceImages = si;
  98         generatedImages = new ArrayList&lt;Bitmap&gt;();
  99         maxImageWidth = maxImageHeight = -1;
 100         doInBackgroundCallback = bgR;
 101         postExecuteCallback = postR;
 102     }
 103     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
 104             AsyncTaskCallback postR) {
 105         page = p;
 106         items = l;
 107         generatedImages = new ArrayList&lt;Bitmap&gt;();
 108         maxImageWidth = cw;
 109         maxImageHeight = ch;
 110         doInBackgroundCallback = bgR;
 111         postExecuteCallback = postR;
 112     }
 113     void cleanup(boolean cancelled) {
 114         // Clean up any references to source/generated bitmaps
 115         if (sourceImages != null) {
 116             if (cancelled) {
 117                 for (Bitmap b : sourceImages) {
 118                     b.recycle();
 119                 }
 120             }
 121             sourceImages.clear();
 122         }
 123         if (generatedImages != null) {
 124             if (cancelled) {
 125                 for (Bitmap b : generatedImages) {
 126                     b.recycle();
 127                 }
 128             }
 129             generatedImages.clear();
 130         }
 131     }
 132     int page;
 133     ArrayList&lt;Object&gt; items;
 134     ArrayList&lt;Bitmap&gt; sourceImages;
 135     ArrayList&lt;Bitmap&gt; generatedImages;
 136     int maxImageWidth;
 137     int maxImageHeight;
 138     AsyncTaskCallback doInBackgroundCallback;
 139     AsyncTaskCallback postExecuteCallback;
 140 }
 141 
 142 /**
 143  * A generic template for an async task used in AppsCustomize.
 144  */
 145 
 146 
 147 /**
 148  * A generic template for an async task used in AppsCustomize.
 149  */
 150 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 151     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 152         page = p;
 153         threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 154         dataType = ty;
 155     }
 156     @Override
 157     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 158         if (params.length != 1) return null;
 159         // Load each of the widget previews in the background
 160         params[0].doInBackgroundCallback.run(this, params[0]);
 161         return params[0];
 162     }
 163     @Override
 164     protected void onPostExecute(AsyncTaskPageData result) {
 165         // All the widget previews are loaded, so we can just callback to inflate the page
 166         result.postExecuteCallback.run(this, result);
 167     }
 168 
 169     void setThreadPriority(int p) {
 170         threadPriority = p;
 171     }
 172     void syncThreadPriority() {
 173         Process.setThreadPriority(threadPriority);
 174     }
 175 
 176     // The page that this async task is associated with
 177     AsyncTaskPageData.Type dataType;
 178     int page;
 179     int threadPriority;
 180 }
 181 
 182 /**
 183  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 184  */
 185 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 186         AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,
 187         PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 188         LauncherTransitionable {
 189     static final String LOG_TAG = &quot;AppsCustomizePagedView&quot;;
 190 
 191     /**
 192      * The different content types that this paged view can show.
 193      */
 194     public enum ContentType {
 195         Applications,
 196         Widgets
 197     }
 198 
 199     // Refs
 200     private Launcher mLauncher;
 201     private DragController mDragController;
 202     private final LayoutInflater mLayoutInflater;
 203     private final PackageManager mPackageManager;
 204 
 205     // Save and Restore
 206     private int mSaveInstanceStateItemIndex = -1;
 207     private PagedViewIcon mPressedIcon;
 208 
 209     // Content
 210     private ArrayList&lt;ApplicationInfo&gt; mApps;
 211     private ArrayList&lt;Object&gt; mWidgets;
 212 
 213     // Cling
 214     private boolean mHasShownAllAppsCling;
 215     private int mClingFocusedX;
 216     private int mClingFocusedY;
 217 
 218     // Caching
 219     private Canvas mCanvas;
 220     private Drawable mDefaultWidgetBackground;
 221     private IconCache mIconCache;
 222 
 223     // Dimens
 224     private int mContentWidth;
 225     private int mAppIconSize;
 226     private int mMaxAppCellCountX, mMaxAppCellCountY;
 227     private int mWidgetCountX, mWidgetCountY;
 228     private int mWidgetWidthGap, mWidgetHeightGap;
 229     private final int mWidgetPreviewIconPaddedDimension;
 230     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 231     private PagedViewCellLayout mWidgetSpacingLayout;
 232     private int mNumAppsPages;
 233     private int mNumWidgetPages;
 234 
 235     // Relating to the scroll and overscroll effects
 236     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 237     private static float CAMERA_DISTANCE = 6500;
 238     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 239     private static float TRANSITION_PIVOT = 0.65f;
 240     private static float TRANSITION_MAX_ROTATION = 22;
 241     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 242     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 243     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 244 
 245     // Previews &amp; outlines
 246     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 247     private static final int sPageSleepDelay = 200;
 248 
 249     private Runnable mInflateWidgetRunnable = null;
 250     private Runnable mBindWidgetRunnable = null;
 251     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 252     static final int WIDGET_BOUND = 0;
 253     static final int WIDGET_INFLATED = 1;
 254     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 255     int mWidgetLoadingId = -1;
 256     PendingAddWidgetInfo mCreateWidgetInfo = null;
 257     private boolean mDraggingWidget = false;
 258 
 259     // Deferral of loading widget previews during launcher transitions
 260     private boolean mInTransition;
 261     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 262         new ArrayList&lt;AsyncTaskPageData&gt;();
 263 
 264     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 265         super(context, attrs);
 266         mLayoutInflater = LayoutInflater.from(context);
 267         mPackageManager = context.getPackageManager();
 268         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 269         mWidgets = new ArrayList&lt;Object&gt;();
 270         mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 271         mCanvas = new Canvas();
 272         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 273 
 274         // Save the default widget preview background
 275         Resources resources = context.getResources();
 276         mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 277         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 278 
 279         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 280         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 281         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 282         mWidgetWidthGap =
 283             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 284         mWidgetHeightGap =
 285             a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 286         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 287         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 288         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 289         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 290         a.recycle();
 291         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 292 
 293         // The padding on the non-matched dimension for the default widget preview icons
 294         // (top + bottom)
 295         mWidgetPreviewIconPaddedDimension =
 296             (int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPercentage)));
 297         mFadeInAdjacentScreens = false;
 298     }
 299 
 300     @Override
 301     protected void init() {
 302         super.init();
 303         mCenterPagesVertically = false;
 304 
 305         Context context = getContext();
 306         Resources r = context.getResources();
 307         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 308     }
 309 
 310     @Override
 311     protected void onUnhandledTap(MotionEvent ev) {
 312         if (LauncherApplication.isScreenLarge()) {
 313             // Dismiss AppsCustomize if we tap
 314             mLauncher.showWorkspace(true);
 315         }
 316     }
 317 
 318     /** Returns the item index of the center item on this page so that we can restore to this
 319      *  item index when we rotate. */
 320     private int getMiddleComponentIndexOnCurrentPage() {
 321         int i = -1;
 322         if (getPageCount() &gt; 0) {
 323             int currentPage = getCurrentPage();
 324             if (currentPage &lt; mNumAppsPages) {
 325                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 326                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 327                 int numItemsPerPage = mCellCountX * mCellCountY;
 328                 int childCount = childrenLayout.getChildCount();
 329                 if (childCount &gt; 0) {
 330                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 331                 }
 332             } else {
 333                 int numApps = mApps.size();
 334                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 335                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 336                 int childCount = layout.getChildCount();
 337                 if (childCount &gt; 0) {
 338                     i = numApps +
 339                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 340                 }
 341             }
 342         }
 343         return i;
 344     }
 345 
 346     /** Get the index of the item to restore to if we need to restore the current page. */
 347     int getSaveInstanceStateIndex() {
 348         if (mSaveInstanceStateItemIndex == -1) {
 349             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 350         }
 351         return mSaveInstanceStateItemIndex;
 352     }
 353 
 354     /** Returns the page in the current orientation which is expected to contain the specified
 355      *  item index. */
 356     int getPageForComponent(int index) {
 357         if (index &lt; 0) return 0;
 358 
 359         if (index &lt; mApps.size()) {
 360             int numItemsPerPage = mCellCountX * mCellCountY;
 361             return (index / numItemsPerPage);
 362         } else {
 363             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 364             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 365         }
 366     }
 367 
 368     /**
 369      * This differs from isDataReady as this is the test done if isDataReady is not set.
 370      */
 371     private boolean testDataReady() {
 372         // We only do this test once, and we default to the Applications page, so we only really
 373         // have to wait for there to be apps.
 374         // TODO: What if one of them is validly empty
 375         return !mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty();
 376     }
 377 
 378     /** Restores the page for an item at the specified index */
 379     void restorePageForIndex(int index) {
 380         if (index &lt; 0) return;
 381         mSaveInstanceStateItemIndex = index;
 382     }
 383 
 384     private void updatePageCounts() {
 385         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 386                 (float) (mWidgetCountX * mWidgetCountY));
 387         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 388     }
 389 
 390     protected void onDataReady(int width, int height) {
 391         // Note that we transpose the counts in portrait so that we get a similar layout
 392         boolean isLandscape = getResources().getConfiguration().orientation ==
 393             Configuration.ORIENTATION_LANDSCAPE;
 394         int maxCellCountX = Integer.MAX_VALUE;
 395         int maxCellCountY = Integer.MAX_VALUE;
 396         if (LauncherApplication.isScreenLarge()) {
 397             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 398                 LauncherModel.getCellCountY());
 399             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 400                 LauncherModel.getCellCountX());
 401         }
 402         if (mMaxAppCellCountX &gt; -1) {
 403             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 404         }
 405         if (mMaxAppCellCountY &gt; -1) {
 406             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 407         }
 408 
 409         // Now that the data is ready, we can calculate the content width, the number of cells to
 410         // use for each page
 411         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 412         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 413                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 414         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 415         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 416         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 417         updatePageCounts();
 418 
 419         // Force a measure to update recalculate the gaps
 420         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 421         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 422         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 423         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 424 
 425         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 426         final boolean hostIsTransitioning = host.isTransitioning();
 427 
 428         // Restore the page
 429         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 430         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 431 
 432         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 433         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 434         // returned while animating)
 435         if (!hostIsTransitioning) {
 436             post(new Runnable() {
 437                 @Override
 438                 public void run() {
 439                     showAllAppsCling();
 440                 }
 441             });
 442         }
 443     }
 444 
 445     void showAllAppsCling() {
 446         if (!mHasShownAllAppsCling &amp;&amp; isDataReady() &amp;&amp; testDataReady()) {
 447             mHasShownAllAppsCling = true;
 448             // Calculate the position for the cling punch through
 449             int[] offset = new int[2];
 450             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 451             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 452             // PagedViews are centered horizontally but top aligned
 453             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 454                     offset[0];
 455             pos[1] += offset[1];
 456             mLauncher.showFirstRunAllAppsCling(pos);
 457         }
 458     }
 459 
 460     @Override
 461     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 462         int width = MeasureSpec.getSize(widthMeasureSpec);
 463         int height = MeasureSpec.getSize(heightMeasureSpec);
 464         if (!isDataReady()) {
 465             if (testDataReady()) {
 466                 setDataIsReady();
 467                 setMeasuredDimension(width, height);
 468                 onDataReady(width, height);
 469             }
 470         }
 471 
 472         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 473     }
 474 
 475     public void onPackagesUpdated() {
 476         // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered
 477         // by a broadcast receiver, and in order for it to work correctly, we need to know that
 478         // the AppWidgetService has already received and processed the same broadcast. Since there
 479         // is no guarantee about ordering of broadcast receipt, we just delay here. Ideally,
 480         // we should have a more precise way of ensuring the AppWidgetService is up to date.
 481         postDelayed(new Runnable() {
 482            public void run() {
 483                updatePackages();
 484            }
 485         }, 500);
 486     }
 487 
 488     public void updatePackages() {
 489         // Get the list of widgets and shortcuts
 490         boolean wasEmpty = mWidgets.isEmpty();
 491         mWidgets.clear();
 492         List&lt;AppWidgetProviderInfo&gt; widgets =
 493             AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 494         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 495         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 496         for (AppWidgetProviderInfo widget : widgets) {
 497             if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
 498                 // Ensure that all widgets we show can be added on a workspace of this size
 499                 int[] spanXY = mLauncher.getSpanForWidget(widget);
 500                 int[] minSpanXY = mLauncher.getMinSpanForWidget(widget);
 501                 int minSpanX = Math.min(spanXY[0], minSpanXY[0]);
 502                 int minSpanY = Math.min(spanXY[1], minSpanXY[1]);
 503                 if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;
 504                         minSpanY &lt;= LauncherModel.getCellCountY()) {
 505                 mWidgets.add(widget);
 506                 }
 507             } else {
 508                 Log.e(LOG_TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 509                         widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 510             }
 511         }
 512         mWidgets.addAll(shortcuts);
 513         Collections.sort(mWidgets,
 514                 new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 515         updatePageCounts();
 516 
 517         if (wasEmpty) {
 518             // The next layout pass will trigger data-ready if both widgets and apps are set, so request
 519             // a layout to do this test and invalidate the page data when ready.
 520             if (testDataReady()) requestLayout();
 521         } else {
 522             cancelAllTasks();
 523             invalidatePageData();
 524         }
 525     }
 526 
 527     @Override
 528     public void onClick(View v) {
 529         // When we have exited all apps or are in transition, disregard clicks
 530         if (!mLauncher.isAllAppsCustomizeOpen() ||
 531                 mLauncher.getWorkspace().isSwitchingState()) return;
 532 
 533         if (v instanceof PagedViewIcon) {
 534             // Animate some feedback to the click
 535             final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 536             mLauncher.startActivitySafely(appInfo.intent, appInfo);
 537 
 538             // Lock the drawable state to pressed until we return to Launcher
 539             if (mPressedIcon != null) {
 540                 mPressedIcon.lockDrawableState();
 541             }
 542         } else if (v instanceof PagedViewWidget) {
 543             // Let the user know that they have to long press to add a widget
 544             Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 545                     Toast.LENGTH_SHORT).show();
 546 
 547             // Create a little animation to show that the widget can move
 548             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 549             final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 550             AnimatorSet bounce = new AnimatorSet();
 551             ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);
 552             tyuAnim.setDuration(125);
 553             ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);
 554             tydAnim.setDuration(100);
 555             bounce.play(tyuAnim).before(tydAnim);
 556             bounce.setInterpolator(new AccelerateInterpolator());
 557             bounce.start();
 558         }
 559     }
 560 
 561     public boolean onKey(View v, int keyCode, KeyEvent event) {
 562         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 563     }
 564 
 565     /*
 566      * PagedViewWithDraggableItems implementation
 567      */
 568     @Override
 569     protected void determineDraggingStart(android.view.MotionEvent ev) {
 570         // Disable dragging by pulling an app down for now.
 571     }
 572 
 573     private void beginDraggingApplication(View v) {
 574         mLauncher.getWorkspace().onDragStartedWithItem(v);
 575         mLauncher.getWorkspace().beginDragShared(v, this);
 576     }
 577 
 578     private void loadWidgetInBackground(final PendingAddWidgetInfo info) {
 579         final AppWidgetProviderInfo pInfo = info.info;
 580         if (pInfo.configure != null) {
 581             return;
 582         }
 583 
 584         mBindWidgetRunnable = new Runnable() {
 585             @Override
 586             public void run() {
 587                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 588                 AppWidgetManager.getInstance(mLauncher).bindAppWidgetId(mWidgetLoadingId,
 589                         info.componentName);
 590                 mWidgetCleanupState = WIDGET_BOUND;
 591             }
 592         };
 593         post(mBindWidgetRunnable);
 594 
 595         mInflateWidgetRunnable = new Runnable() {
 596             @Override
 597             public void run() {
 598                 AppWidgetHostView hostView =
 599                         mLauncher.getAppWidgetHost().createView(mContext, mWidgetLoadingId, pInfo);
 600                 info.boundWidget = hostView;
 601                 mWidgetCleanupState = WIDGET_INFLATED;
 602                 hostView.setVisibility(INVISIBLE);
 603                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 604                         info.spanY, info, false);
 605 
 606                 // We want the first widget layout to be the correct size. This will be important
 607                 // for width size reporting to the AppWidgetManager.
 608                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 609                         unScaledSize[1]);
 610                 lp.x = lp.y = 0;
 611                 lp.customPosition = true;
 612                 hostView.setLayoutParams(lp);
 613                 mLauncher.getDragLayer().addView(hostView);
 614             }
 615         };
 616         post(mInflateWidgetRunnable);
 617     }
 618 
 619     @Override
 620     public void onShortPress(View v) {
 621         // We are anticipating a long press, and we use this time to load bind and instantiate
 622         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 623         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 624         loadWidgetInBackground(mCreateWidgetInfo);
 625     }
 626 
 627     private void cleanupWidgetPreloading() {
 628         PendingAddWidgetInfo info = mCreateWidgetInfo;
 629         mCreateWidgetInfo = null;
 630         if (mWidgetCleanupState &gt;= 0 &amp;&amp; mWidgetLoadingId != -1) {
 631             mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 632         }
 633         if (mWidgetCleanupState == WIDGET_BOUND) {
 634             removeCallbacks(mInflateWidgetRunnable);
 635         } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 636             AppWidgetHostView widget = info.boundWidget;
 637             int widgetId = widget.getAppWidgetId();
 638             mLauncher.getAppWidgetHost().deleteAppWidgetId(widgetId);
 639             mLauncher.getDragLayer().removeView(widget);
 640         }
 641         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 642         mWidgetLoadingId = -1;
 643     }
 644 
 645     @Override
 646     public void cleanUpShortPress(View v) {
 647         if (!mDraggingWidget) {
 648             cleanupWidgetPreloading();
 649         }
 650     }
 651 
 652     private void beginDraggingWidget(View v) {
 653         mDraggingWidget = true;
 654         // Get the widget preview as the drag representation
 655         ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 656         PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 657 
 658         // Compose the drag image
 659         Bitmap preview;
 660         Bitmap outline;
 661         float scale = 1f;
 662         if (createItemInfo instanceof PendingAddWidgetInfo) {
 663             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 664             createItemInfo = createWidgetInfo;
 665             int spanX = createItemInfo.spanX;
 666             int spanY = createItemInfo.spanY;
 667             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 668                     createWidgetInfo, true);
 669 
 670             FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 671             float minScale = 1.25f;
 672             int minWidth, minHeight;
 673             minWidth = Math.max((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 674             minHeight = Math.max((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 675             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 676                     createWidgetInfo.icon, spanX, spanY, minWidth, minHeight);
 677 
 678             // Determine the image view drawable scale relative to the preview
 679             float[] mv = new float[9];
 680             Matrix m = new Matrix();
 681             m.setRectToRect(
 682                     new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 683                     new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 684                             (float) previewDrawable.getIntrinsicHeight()),
 685                     Matrix.ScaleToFit.START);
 686             m.getValues(mv);
 687             scale = (float) mv[0];
 688         } else {
 689             // Workaround for the fact that we don&#x27;t keep the original ResolveInfo associated with
 690             // the shortcut around.  To get the icon, we just render the preview image (which has
 691             // the shortcut icon) to a new drag bitmap that clips the non-icon space.
 692             preview = Bitmap.createBitmap(mWidgetPreviewIconPaddedDimension,
 693                     mWidgetPreviewIconPaddedDimension, Bitmap.Config.ARGB_8888);
 694             Drawable d = image.getDrawable();
 695             mCanvas.setBitmap(preview);
 696             d.draw(mCanvas);
 697             mCanvas.setBitmap(null);
 698             createItemInfo.spanX = createItemInfo.spanY = 1;
 699         }
 700 
 701         // We use a custom alpha clip table for the default widget previews
 702         Paint alphaClipPaint = null;
 703         if (createItemInfo instanceof PendingAddWidgetInfo) {
 704             if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 705                 MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 706                 alphaClipPaint = new Paint();
 707                 alphaClipPaint.setMaskFilter(alphaClipTable);
 708             }
 709         }
 710 
 711         // Save the preview for the outline generation, then dim the preview
 712         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 713                 false);
 714 
 715         // Start the drag
 716         alphaClipPaint = null;
 717         mLauncher.lockScreenOrientationOnLargeUI();
 718         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);
 719         mDragController.startDrag(image, preview, this, createItemInfo,
 720                 DragController.DRAG_ACTION_COPY, null, scale);
 721         outline.recycle();
 722         preview.recycle();
 723     }
 724 
 725     @Override
 726     protected boolean beginDragging(final View v) {
 727         if (!super.beginDragging(v)) return false;
 728 
 729         if (v instanceof PagedViewIcon) {
 730             beginDraggingApplication(v);
 731         } else if (v instanceof PagedViewWidget) {
 732             beginDraggingWidget(v);
 733         }
 734 
 735         // We delay entering spring-loaded mode slightly to make sure the UI
 736         // thready is free of any work.
 737         postDelayed(new Runnable() {
 738             @Override
 739             public void run() {
 740                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 741                 if (mLauncher.getDragController().isDragging()) {
 742                     // Dismiss the cling
 743                     mLauncher.dismissAllAppsCling(null);
 744 
 745                     // Reset the alpha on the dragged icon before we drag
 746                     resetDrawableState();
 747 
 748                     // Go into spring loaded mode (must happen before we startDrag())
 749                     mLauncher.enterSpringLoadedDragMode();
 750                 }
 751             }
 752         }, 150);
 753 
 754         return true;
 755     }
 756 
 757     /**
 758      * Clean up after dragging.
 759      *
 760      * @param target where the item was dragged to (can be null if the item was flung)
 761      */
 762     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 763         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 764                 !(target instanceof DeleteDropTarget))) {
 765             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 766             // drop in Workspace
 767             mLauncher.exitSpringLoadedDragMode();
 768         }
 769         mLauncher.unlockScreenOrientationOnLargeUI();
 770     }
 771 
 772     @Override
 773     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 774         mInTransition = true;
 775         if (toWorkspace) {
 776             cancelAllTasks();
 777         }
 778     }
 779 
 780     @Override
 781     public View getContent() {
 782         return null;
 783     }
 784 
 785     @Override
 786     public void onLauncherTransitionStep(Launcher l, float t) {
 787     }
 788 
 789     @Override
 790     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 791         mInTransition = false;
 792         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 793             onSyncWidgetPageItems(d);
 794         }
 795         mDeferredSyncWidgetPageItems.clear();
 796     }
 797 
 798     @Override
 799     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 800             boolean success) {
 801         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 802         if (isFlingToDelete) return;
 803 
 804         endDragging(target, false, success);
 805 
 806         // Display an error message if the drag failed due to there not being enough space on the
 807         // target layout we were dropping on.
 808         if (!success) {
 809             boolean showOutOfSpaceMessage = false;
 810             if (target instanceof Workspace) {
 811                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 812                 Workspace workspace = (Workspace) target;
 813                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 814                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 815                 if (layout != null) {
 816                     layout.calculateSpans(itemInfo);
 817                     showOutOfSpaceMessage =
 818                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 819                 }
 820             }
 821             if (showOutOfSpaceMessage) {
 822                 mLauncher.showOutOfSpaceMessage(false);
 823             }
 824 
 825             d.deferDragViewCleanupPostAnimation = false;
 826             cleanupWidgetPreloading();
 827         }
 828         mDraggingWidget = false;
 829     }
 830 
 831     @Override
 832     public void onFlingToDeleteCompleted() {
 833         // We just dismiss the drag when we fling, so cleanup here
 834         endDragging(null, true, true);
 835         cleanupWidgetPreloading();
 836         mDraggingWidget = false;
 837     }
 838 
 839     @Override
 840     public boolean supportsFlingToDelete() {
 841         return true;
 842     }
 843 
 844     @Override
 845     protected void onDetachedFromWindow() {
 846         super.onDetachedFromWindow();
 847         cancelAllTasks();
 848     }
 849 
 850     public void clearAllWidgetPages() {
 851         cancelAllTasks();
 852         int count = getChildCount();
 853         for (int i = 0; i &lt; count; i++) {
 854             View v = getPageAt(i);
 855             if (v instanceof PagedViewGridLayout) {
 856                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 857                 mDirtyPageContent.set(i, true);
 858             }
 859         }
 860     }
 861 
 862     private void cancelAllTasks() {
 863         // Clean up all the async tasks
 864         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 865         while (iter.hasNext()) {
 866             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 867             task.cancel(false);
 868             iter.remove();
 869             mDirtyPageContent.set(task.page, true);
 870         }
 871     }
 872 
 873     public void setContentType(ContentType type) {
 874         if (type == ContentType.Widgets) {
 875             invalidatePageData(mNumAppsPages, true);
 876         } else if (type == ContentType.Applications) {
 877             invalidatePageData(0, true);
 878         }
 879     }
 880 
 881     protected void snapToPage(int whichPage, int delta, int duration) {
 882         super.snapToPage(whichPage, delta, duration);
 883         updateCurrentTab(whichPage);
 884 
 885         // Update the thread priorities given the direction lookahead
 886         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 887         while (iter.hasNext()) {
 888             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 889             int pageIndex = task.page;
 890             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 891                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 892                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 893             } else {
 894                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 895             }
 896         }
 897     }
 898 
 899     private void updateCurrentTab(int currentPage) {
 900         AppsCustomizeTabHost tabHost = getTabHost();
 901         if (tabHost != null) {
 902             String tag = tabHost.getCurrentTabTag();
 903             if (tag != null) {
 904                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
 905                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 906                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
 907                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 908                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 909                     tabHost.setCurrentTabFromContent(ContentType.Applications);
 910                 }
 911             }
 912         }
 913     }
 914 
 915     /*
 916      * Apps PagedView implementation
 917      */
 918     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 919         int childCount = layout.getChildCount();
 920         for (int i = 0; i &lt; childCount; ++i) {
 921             layout.getChildAt(i).setVisibility(visibility);
 922         }
 923     }
 924     private void setupPage(PagedViewCellLayout layout) {
 925         layout.setCellCount(mCellCountX, mCellCountY);
 926         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 927         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 928                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 929 
 930         // Note: We force a measure here to get around the fact that when we do layout calculations
 931         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 932         // expected page width, so we can actually optimize by hiding all the TextView-based
 933         // children that are expensive to measure, and let that happen naturally later.
 934         setVisibilityOnChildren(layout, View.GONE);
 935         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 936         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 937         layout.setMinimumWidth(getPageContentWidth());
 938         layout.measure(widthSpec, heightSpec);
 939         setVisibilityOnChildren(layout, View.VISIBLE);
 940     }
 941 
 942     public void syncAppsPageItems(int page, boolean immediate) {
 943         // ensure that we have the right number of items on the pages
 944         int numCells = mCellCountX * mCellCountY;
 945         int startIndex = page * numCells;
 946         int endIndex = Math.min(startIndex + numCells, mApps.size());
 947         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 948 
 949         layout.removeAllViewsOnPage();
 950         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 951         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 952         for (int i = startIndex; i &lt; endIndex; ++i) {
 953             ApplicationInfo info = mApps.get(i);
 954             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 955                     R.layout.apps_customize_application, layout, false);
 956             icon.applyFromApplicationInfo(info, true, this);
 957             icon.setOnClickListener(this);
 958             icon.setOnLongClickListener(this);
 959             icon.setOnTouchListener(this);
 960             icon.setOnKeyListener(this);
 961 
 962             int index = i - startIndex;
 963             int x = index % mCellCountX;
 964             int y = index / mCellCountX;
 965             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 966 
 967             items.add(info);
 968             images.add(info.iconBitmap);
 969         }
 970 
 971         layout.createHardwareLayers();
 972     }
 973 
 974     /**
 975      * A helper to return the priority for loading of the specified widget page.
 976      */
 977     private int getWidgetPageLoadPriority(int page) {
 978         // If we are snapping to another page, use that index as the target page index
 979         int toPage = mCurrentPage;
 980         if (mNextPage &gt; -1) {
 981             toPage = mNextPage;
 982         }
 983 
 984         // We use the distance from the target page as an initial guess of priority, but if there
 985         // are no pages of higher priority than the page specified, then bump up the priority of
 986         // the specified page.
 987         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 988         int minPageDiff = Integer.MAX_VALUE;
 989         while (iter.hasNext()) {
 990             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 991             minPageDiff = Math.abs(task.page - toPage);
 992         }
 993 
 994         int rawPageDiff = Math.abs(page - toPage);
 995         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 996     }
 997     /**
 998      * Return the appropriate thread priority for loading for a given page (we give the current
 999      * page much higher priority)
1000      */
1001     private int getThreadPriorityForPage(int page) {
1002         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
1003         int pageDiff = getWidgetPageLoadPriority(page);
1004         if (pageDiff &lt;= 0) {
1005             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
1006         } else if (pageDiff &lt;= 1) {
1007             return Process.THREAD_PRIORITY_LOWEST;
1008         } else {
1009             return Process.THREAD_PRIORITY_LOWEST;
1010         }
1011     }
1012     private int getSleepForPage(int page) {
1013         int pageDiff = getWidgetPageLoadPriority(page);
1014         return Math.max(0, pageDiff * sPageSleepDelay);
1015     }
1016     /**
1017      * Creates and executes a new AsyncTask to load a page of widget previews.
1018      */
1019     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1020             int cellWidth, int cellHeight, int cellCountX) {
1021 
1022         // Prune all tasks that are no longer needed
1023         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1024         while (iter.hasNext()) {
1025             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1026             int taskPage = task.page;
1027             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1028                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1029                 task.cancel(false);
1030                 iter.remove();
1031             } else {
1032                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1033             }
1034         }
1035 
1036         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1037         final int sleepMs = getSleepForPage(page);
1038         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1039             new AsyncTaskCallback() {
1040                 @Override
1041                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1042                     try {
1043                         try {
1044                             Thread.sleep(sleepMs);
1045                         } catch (Exception e) {}
1046                         loadWidgetPreviewsInBackground(task, data);
1047                     } finally {
1048                         if (task.isCancelled()) {
1049                             data.cleanup(true);
1050                         }
1051                     }
1052                 }
1053             },
1054             new AsyncTaskCallback() {
1055                 @Override
1056                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1057                     mRunningTasks.remove(task);
1058                     if (task.isCancelled()) return;
1059                     // do cleanup inside onSyncWidgetPageItems
1060                     onSyncWidgetPageItems(data);
1061                 }
1062             });
1063 
1064         // Ensure that the task is appropriately prioritized and runs in parallel
1065         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1066                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1067         t.setThreadPriority(getThreadPriorityForPage(page));
1068         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1069         mRunningTasks.add(t);
1070     }
1071 
1072     /*
1073      * Widgets PagedView implementation
1074      */
1075     private void setupPage(PagedViewGridLayout layout) {
1076         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1077                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1078 
1079         // Note: We force a measure here to get around the fact that when we do layout calculations
1080         // immediately after syncing, we don&#x27;t have a proper width.
1081         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1082         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1083         layout.setMinimumWidth(getPageContentWidth());
1084         layout.measure(widthSpec, heightSpec);
1085     }
1086 
1087     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1088         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f, 0xFFFFFFFF);
1089     }
1090 
1091     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1092             float scale, int multiplyColor) {
1093         if (bitmap != null) {
1094             Canvas c = new Canvas(bitmap);
1095             c.scale(scale, scale);
1096             Rect oldBounds = d.copyBounds();
1097             d.setBounds(x, y, x + w, y + h);
1098             d.draw(c);
1099             d.setBounds(oldBounds); // Restore the bounds
1100             c.setBitmap(null);
1101         }
1102     }
1103     private Bitmap getShortcutPreview(ResolveInfo info) {
1104         // Render the background
1105         int offset = 0;
1106         int bitmapSize = mAppIconSize;
1107         Bitmap preview = Bitmap.createBitmap(bitmapSize, bitmapSize, Config.ARGB_8888);
1108 
1109         // Render the icon
1110         Drawable icon = mIconCache.getFullResIcon(info);
1111         renderDrawableToBitmap(icon, preview, offset, offset, mAppIconSize, mAppIconSize);
1112         return preview;
1113     }
1114 
1115     private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId,
1116             int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {
1117         // Load the preview image if possible
1118         String packageName = provider.getPackageName();
1119         if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1120         if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1121 
1122         Drawable drawable = null;
1123         if (previewImage != 0) {
1124             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1125             if (drawable == null) {
1126                 Log.w(LOG_TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1127                         Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1128             }
1129         }
1130 
1131         int bitmapWidth;
1132         int bitmapHeight;
1133         boolean widgetPreviewExists = (drawable != null);
1134         if (widgetPreviewExists) {
1135             bitmapWidth = drawable.getIntrinsicWidth();
1136             bitmapHeight = drawable.getIntrinsicHeight();
1137         } else {
1138             if (cellHSpan &lt; 1) cellHSpan = 1;
1139             if (cellVSpan &lt; 1) cellVSpan = 1;
1140             // Determine the size of the bitmap for the preview image we will generate
1141             // TODO: This actually uses the apps customize cell layout params, where as we make want
1142             // the Workspace params for more accuracy.
1143             bitmapWidth = mWidgetSpacingLayout.estimateCellWidth(cellHSpan);
1144             bitmapHeight = mWidgetSpacingLayout.estimateCellHeight(cellVSpan);
1145             if (cellHSpan == cellVSpan) {
1146                 // For square widgets, we just have a fixed size for 1x1 and larger-than-1x1
1147                 int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1148                 if (cellHSpan &lt;= 1) {
1149                     bitmapWidth = bitmapHeight = mAppIconSize + 2 * minOffset;
1150                 } else {
1151                     bitmapWidth = bitmapHeight = mAppIconSize + 4 * minOffset;
1152                 }
1153             }
1154         }
1155 
1156         float scale = 1f;
1157         if (bitmapWidth &gt; maxWidth) {
1158             scale = maxWidth / (float) bitmapWidth;
1159         }
1160         if (bitmapHeight * scale &gt; maxHeight) {
1161             scale = maxHeight / (float) bitmapHeight;
1162         }
1163         if (scale != 1f) {
1164             bitmapWidth = (int) (scale * bitmapWidth);
1165             bitmapHeight = (int) (scale * bitmapHeight);
1166         }
1167 
1168         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1169 
1170         if (widgetPreviewExists) {
1171             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1172         } else {
1173             // Generate a preview image if we couldn&#x27;t load one
1174             int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1175             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1176             float iconScale = Math.min((float) smallestSide / (mAppIconSize + 2 * minOffset), 1f);
1177             if (cellHSpan != 1 || cellVSpan != 1) {
1178                 renderDrawableToBitmap(mDefaultWidgetBackground, preview, 0, 0, bitmapWidth,
1179                         bitmapHeight);
1180             }
1181 
1182             // Draw the icon in the top left corner
1183             try {
1184                 Drawable icon = null;
1185                 int hoffset = (int) (bitmapWidth / 2 - mAppIconSize * iconScale / 2);
1186                 int yoffset = (int) (bitmapHeight / 2 - mAppIconSize * iconScale / 2);
1187                 if (iconId &gt; 0) icon = mIconCache.getFullResIcon(packageName, iconId);
1188                 Resources resources = mLauncher.getResources();
1189                 if (icon == null) icon = resources.getDrawable(R.drawable.ic_launcher_application);
1190 
1191                 renderDrawableToBitmap(icon, preview, hoffset, yoffset,
1192                         (int) (mAppIconSize * iconScale),
1193                         (int) (mAppIconSize * iconScale));
1194             } catch (Resources.NotFoundException e) {}
1195         }
1196         return preview;
1197     }
1198 
1199     public void syncWidgetPageItems(final int page, final boolean immediate) {
1200         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1201 
1202         // Calculate the dimensions of each cell we are giving to each widget
1203         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1204         int contentWidth = mWidgetSpacingLayout.getContentWidth();
1205         final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1206                 - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1207         int contentHeight = mWidgetSpacingLayout.getContentHeight();
1208         final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1209                 - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1210 
1211         // Prepare the set of widgets to load previews for in the background
1212         int offset = (page - mNumAppsPages) * numItemsPerPage;
1213         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1214             items.add(mWidgets.get(i));
1215         }
1216 
1217         // Prepopulate the pages with the other widget info, and fill in the previews later
1218         final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1219         layout.setColumnCount(layout.getCellCountX());
1220         for (int i = 0; i &lt; items.size(); ++i) {
1221             Object rawInfo = items.get(i);
1222             PendingAddItemInfo createItemInfo = null;
1223             PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1224                     R.layout.apps_customize_widget, layout, false);
1225             if (rawInfo instanceof AppWidgetProviderInfo) {
1226                 // Fill in the widget information
1227                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1228                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1229 
1230                 // Determine the widget spans and min resize spans.
1231                 int[] spanXY = mLauncher.getSpanForWidget(info);
1232 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
1233 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1234                 int[] size = mLauncher.getWorkspace().estimateItemSize(spanXY[0],</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1235                         spanXY[1], createItemInfo, true);</span>
1236 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1237                 int[] size = mLauncher.getWorkspace().estimateItemSize(spanXY[0],</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1238                         spanXY[1], createItemInfo, true);</span>
1239 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
1240                 createItemInfo.spanX = spanXY[0];
1241                 createItemInfo.spanY = spanXY[1];
1242                 int[] minSpanXY = mLauncher.getMinSpanForWidget(info);
1243                 createItemInfo.minSpanX = minSpanXY[0];
1244                 createItemInfo.minSpanY = minSpanXY[1];
1245 
1246                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1247                 widget.setTag(createItemInfo);
1248                 widget.setShortPressListener(this);
1249             } else if (rawInfo instanceof ResolveInfo) {
1250                 // Fill in the shortcuts information
1251                 ResolveInfo info = (ResolveInfo) rawInfo;
1252                 createItemInfo = new PendingAddItemInfo();
1253                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1254                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1255                         info.activityInfo.name);
1256                 widget.applyFromResolveInfo(mPackageManager, info);
1257                 widget.setTag(createItemInfo);
1258             }
1259             widget.setOnClickListener(this);
1260             widget.setOnLongClickListener(this);
1261             widget.setOnTouchListener(this);
1262             widget.setOnKeyListener(this);
1263 
1264             // Layout each widget
1265             int ix = i % mWidgetCountX;
1266             int iy = i / mWidgetCountX;
1267             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1268                     GridLayout.spec(iy, GridLayout.LEFT),
1269                     GridLayout.spec(ix, GridLayout.TOP));
1270             lp.width = cellWidth;
1271             lp.height = cellHeight;
1272             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1273             if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1274             if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1275             layout.addView(widget, lp);
1276         }
1277 
1278         // wait until a call on onLayout to start loading, because
1279         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1280         // TODO: can we do a measure/layout immediately?
1281         layout.setOnLayoutListener(new Runnable() {
1282             public void run() {
1283                 // Load the widget previews
1284                 int maxPreviewWidth = cellWidth;
1285                 int maxPreviewHeight = cellHeight;
1286                 if (layout.getChildCount() &gt; 0) {
1287                     PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1288                     int[] maxSize = w.getPreviewSize();
1289                     maxPreviewWidth = maxSize[0];
1290                     maxPreviewHeight = maxSize[1];
1291                 }
1292                 if (immediate) {
1293                     AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1294                             maxPreviewWidth, maxPreviewHeight, null, null);
1295                     loadWidgetPreviewsInBackground(null, data);
1296                     onSyncWidgetPageItems(data);
1297                 } else {
1298                     prepareLoadWidgetPreviewsTask(page, items,
1299                             maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1300                 }
1301             }
1302         });
1303     }
1304     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1305             AsyncTaskPageData data) {
1306         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1307         // previews synchronously
1308         if (task != null) {
1309             // Ensure that this task starts running at the correct priority
1310             task.syncThreadPriority();
1311         }
1312 
1313         // Load each of the widget/shortcut previews
1314         ArrayList&lt;Object&gt; items = data.items;
1315         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1316         int count = items.size();
1317         for (int i = 0; i &lt; count; ++i) {
1318             if (task != null) {
1319                 // Ensure we haven&#x27;t been cancelled yet
1320                 if (task.isCancelled()) break;
1321                 // Before work on each item, ensure that this task is running at the correct
1322                 // priority
1323                 task.syncThreadPriority();
1324             }
1325 
1326             Object rawInfo = items.get(i);
1327             if (rawInfo instanceof AppWidgetProviderInfo) {
1328                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1329                 int[] cellSpans = mLauncher.getSpanForWidget(info);
1330 
1331                 int maxWidth = Math.min(data.maxImageWidth,
1332                         mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1333                 int maxHeight = Math.min(data.maxImageHeight,
1334                         mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1335                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1336                         cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1337                 images.add(b);
1338             } else if (rawInfo instanceof ResolveInfo) {
1339                 // Fill in the shortcuts information
1340                 ResolveInfo info = (ResolveInfo) rawInfo;
1341                 images.add(getShortcutPreview(info));
1342             }
1343         }
1344     }
1345 
1346     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1347         if (mInTransition) {
1348             mDeferredSyncWidgetPageItems.add(data);
1349             return;
1350         }
1351         try {
1352             int page = data.page;
1353             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1354 
1355             ArrayList&lt;Object&gt; items = data.items;
1356             int count = items.size();
1357             for (int i = 0; i &lt; count; ++i) {
1358                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1359                 if (widget != null) {
1360                     Bitmap preview = data.generatedImages.get(i);
1361                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1362                 }
1363             }
1364 
1365             layout.createHardwareLayer();
1366             invalidate();
1367 
1368             // Update all thread priorities
1369             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1370             while (iter.hasNext()) {
1371                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1372                 int pageIndex = task.page;
1373                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1374             }
1375         } finally {
1376             data.cleanup(false);
1377         }
1378     }
1379 
1380     @Override
1381     public void syncPages() {
1382         removeAllViews();
1383         cancelAllTasks();
1384 
1385         Context context = getContext();
1386         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1387             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1388                     mWidgetCountY);
1389             setupPage(layout);
1390             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1391                     LayoutParams.MATCH_PARENT));
1392         }
1393 
1394         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1395             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1396             setupPage(layout);
1397             addView(layout);
1398         }
1399     }
1400 
1401     @Override
1402     public void syncPageItems(int page, boolean immediate) {
1403         if (page &lt; mNumAppsPages) {
1404             syncAppsPageItems(page, immediate);
1405         } else {
1406             syncWidgetPageItems(page, immediate);
1407         }
1408     }
1409 
1410     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1411     // it is in the z-order. This is important to insure touch events are handled correctly.
1412     View getPageAt(int index) {
1413         return getChildAt(indexToPage(index));
1414     }
1415 
1416     @Override
1417     protected int indexToPage(int index) {
1418         return getChildCount() - index - 1;
1419     }
1420 
1421     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1422     @Override
1423     protected void screenScrolled(int screenCenter) {
1424         super.screenScrolled(screenCenter);
1425 
1426         for (int i = 0; i &lt; getChildCount(); i++) {
1427             View v = getPageAt(i);
1428             if (v != null) {
1429                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1430 
1431                 float interpolatedProgress =
1432                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1433                 float scale = (1 - interpolatedProgress) +
1434                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1435                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1436 
1437                 float alpha;
1438 
1439                 if (!LauncherApplication.isScreenLarge() || scrollProgress &lt; 0) {
1440                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1441                         1 - Math.abs(scrollProgress)) : 1.0f;
1442                 } else {
1443                     // On large screens we need to fade the page as it nears its leftmost position
1444                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1445                 }
1446 
1447                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1448                 int pageWidth = v.getMeasuredWidth();
1449                 int pageHeight = v.getMeasuredHeight();
1450 
1451                 if (PERFORM_OVERSCROLL_ROTATION) {
1452                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1453                         // Overscroll to the left
1454                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1455                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1456                         scale = 1.0f;
1457                         alpha = 1.0f;
1458                         // On the first page, we don&#x27;t want the page to have any lateral motion
1459                         translationX = 0;
1460                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1461                         // Overscroll to the right
1462                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1463                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1464                         scale = 1.0f;
1465                         alpha = 1.0f;
1466                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1467                         translationX = 0;
1468                     } else {
1469                         v.setPivotY(pageHeight / 2.0f);
1470                         v.setPivotX(pageWidth / 2.0f);
1471                         v.setRotationY(0f);
1472                     }
1473                 }
1474 
1475                 v.setTranslationX(translationX);
1476                 v.setScaleX(scale);
1477                 v.setScaleY(scale);
1478                 v.setAlpha(alpha);
1479 
1480                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1481                 // it from accepting touches
1482                 if (alpha &lt; ViewConfiguration.ALPHA_THRESHOLD) {
1483                     v.setVisibility(INVISIBLE);
1484                 } else if (v.getVisibility() != VISIBLE) {
1485                     v.setVisibility(VISIBLE);
1486                 }
1487             }
1488         }
1489     }
1490 
1491     protected void overScroll(float amount) {
1492         acceleratedOverScroll(amount);
1493     }
1494 
1495     /**
1496      * Used by the parent to get the content width to set the tab bar to
1497      * @return
1498      */
1499     public int getPageContentWidth() {
1500         return mContentWidth;
1501     }
1502 
1503     @Override
1504     protected void onPageEndMoving() {
1505         super.onPageEndMoving();
1506 
1507         // We reset the save index when we change pages so that it will be recalculated on next
1508         // rotation
1509         mSaveInstanceStateItemIndex = -1;
1510     }
1511 
1512     /*
1513      * AllAppsView implementation
1514      */
1515     @Override
1516     public void setup(Launcher launcher, DragController dragController) {
1517         mLauncher = launcher;
1518         mDragController = dragController;
1519     }
1520     @Override
1521     public void zoom(float zoom, boolean animate) {
1522         // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1523     }
1524     @Override
1525     public boolean isVisible() {
1526         return (getVisibility() == VISIBLE);
1527     }
1528     @Override
1529     public boolean isAnimating() {
1530         return false;
1531     }
1532     @Override
1533     public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1534         mApps = list;
1535         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1536         updatePageCounts();
1537 
1538         // The next layout pass will trigger data-ready if both widgets and apps are set, so
1539         // request a layout to do this test and invalidate the page data when ready.
1540         if (testDataReady()) requestLayout();
1541     }
1542     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1543         // We add it in place, in alphabetical order
1544         int count = list.size();
1545         for (int i = 0; i &lt; count; ++i) {
1546             ApplicationInfo info = list.get(i);
1547             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1548             if (index &lt; 0) {
1549                 mApps.add(-(index + 1), info);
1550             }
1551         }
1552     }
1553     @Override
1554     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1555         addAppsWithoutInvalidate(list);
1556         updatePageCounts();
1557         invalidatePageData();
1558     }
1559     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1560         ComponentName removeComponent = item.intent.getComponent();
1561         int length = list.size();
1562         for (int i = 0; i &lt; length; ++i) {
1563             ApplicationInfo info = list.get(i);
1564             if (info.intent.getComponent().equals(removeComponent)) {
1565                 return i;
1566             }
1567         }
1568         return -1;
1569     }
1570     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1571         // loop through all the apps and remove apps that have the same component
1572         int length = list.size();
1573         for (int i = 0; i &lt; length; ++i) {
1574             ApplicationInfo info = list.get(i);
1575             int removeIndex = findAppByComponent(mApps, info);
1576             if (removeIndex &gt; -1) {
1577                 mApps.remove(removeIndex);
1578             }
1579         }
1580     }
1581     @Override
1582     public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1583         removeAppsWithoutInvalidate(list);
1584         updatePageCounts();
1585         invalidatePageData();
1586     }
1587     @Override
1588     public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1589         // We remove and re-add the updated applications list because it&#x27;s properties may have
1590         // changed (ie. the title), and this will ensure that the items will be in their proper
1591         // place in the list.
1592         removeAppsWithoutInvalidate(list);
1593         addAppsWithoutInvalidate(list);
1594         updatePageCounts();
1595 
1596         invalidatePageData();
1597     }
1598 
1599     @Override
1600     public void reset() {
1601         // If we have reset, then we should not continue to restore the previous state
1602         mSaveInstanceStateItemIndex = -1;
1603 
1604         AppsCustomizeTabHost tabHost = getTabHost();
1605         String tag = tabHost.getCurrentTabTag();
1606         if (tag != null) {
1607             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1608                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1609             }
1610         }
1611 
1612         if (mCurrentPage != 0) {
1613             invalidatePageData(0);
1614         }
1615     }
1616 
1617     private AppsCustomizeTabHost getTabHost() {
1618         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1619     }
1620 
1621     @Override
1622     public void dumpState() {
1623         // TODO: Dump information related to current list of Applications, Widgets, etc.
1624         ApplicationInfo.dumpApplicationInfoList(LOG_TAG, &quot;mApps&quot;, mApps);
1625         dumpAppWidgetProviderInfoList(LOG_TAG, &quot;mWidgets&quot;, mWidgets);
1626     }
1627 
1628     private void dumpAppWidgetProviderInfoList(String tag, String label,
1629             ArrayList&lt;Object&gt; list) {
1630         Log.d(tag, label + &quot; size=&quot; + list.size());
1631         for (Object i: list) {
1632             if (i instanceof AppWidgetProviderInfo) {
1633                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1634                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1635                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1636                         + &quot; initialLayout=&quot; + info.initialLayout
1637                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1638             } else if (i instanceof ResolveInfo) {
1639                 ResolveInfo info = (ResolveInfo) i;
1640                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1641                         + info.icon);
1642             }
1643         }
1644     }
1645 
1646     @Override
1647     public void surrender() {
1648         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1649         // should stop this now.
1650 
1651         // Stop all background tasks
1652         cancelAllTasks();
1653     }
1654 
1655     @Override
1656     public void iconPressed(PagedViewIcon icon) {
1657         // Reset the previously pressed icon and store a reference to the pressed icon so that
1658         // we can reset it on return to Launcher (in Launcher.onResume())
1659         if (mPressedIcon != null) {
1660             mPressedIcon.resetDrawableState();
1661         }
1662         mPressedIcon = icon;
1663     }
1664 
1665     public void resetDrawableState() {
1666         if (mPressedIcon != null) {
1667             mPressedIcon.resetDrawableState();
1668             mPressedIcon = null;
1669         }
1670     }
1671 
1672     /*
1673      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1674      * widget previews in the background with the AsyncTasks.
1675      */
1676     final static int sLookBehindPageCount = 2;
1677     final static int sLookAheadPageCount = 2;
1678     protected int getAssociatedLowerPageBound(int page) {
1679         final int count = getChildCount();
1680         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1681         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1682         return windowMinIndex;
1683     }
1684     protected int getAssociatedUpperPageBound(int page) {
1685         final int count = getChildCount();
1686         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1687         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1688                 count - 1);
1689         return windowMaxIndex;
1690     }
1691 
1692     @Override
1693     protected String getCurrentPageDescription() {
1694         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1695         int stringId = R.string.default_scroll_format;
1696         int count = 0;
1697 
1698         if (page &lt; mNumAppsPages) {
1699             stringId = R.string.apps_customize_apps_scroll_format;
1700             count = mNumAppsPages;
1701         } else {
1702             page -= mNumAppsPages;
1703             stringId = R.string.apps_customize_widgets_scroll_format;
1704             count = mNumWidgetPages;
1705         }
1706 
1707         return String.format(mContext.getString(stringId), page + 1, count);
1708     }
1709 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2011 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.animation.AnimatorSet;
  19 import android.animation.ObjectAnimator;
  20 import android.animation.ValueAnimator;
  21 import android.appwidget.AppWidgetHostView;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.PackageManager;
  28 import android.content.pm.ResolveInfo;
  29 import android.content.res.Configuration;
  30 import android.content.res.Resources;
  31 import android.content.res.TypedArray;
  32 import android.graphics.Bitmap.Config;
  33 import android.graphics.Bitmap;
  34 import android.graphics.Canvas;
  35 import android.graphics.MaskFilter;
  36 import android.graphics.Matrix;
  37 import android.graphics.Paint;
  38 import android.graphics.Rect;
  39 import android.graphics.RectF;
  40 import android.graphics.TableMaskFilter;
  41 import android.graphics.drawable.Drawable;
  42 import android.os.AsyncTask;
  43 import android.os.Process;
  44 import android.util.AttributeSet;
  45 import android.util.Log;
  46 import android.view.Gravity;
  47 import android.view.KeyEvent;
  48 import android.view.LayoutInflater;
  49 import android.view.MotionEvent;
  50 import android.view.View;
  51 import android.view.ViewConfiguration;
  52 import android.view.ViewGroup;
  53 import android.view.animation.AccelerateInterpolator;
  54 import android.view.animation.DecelerateInterpolator;
  55 import android.widget.GridLayout;
  56 import android.widget.ImageView;
  57 import android.widget.Toast;
  58 import com.android.launcher.R;
  59 import com.android.launcher2.DropTarget.DragObject;
  60 import java.util.ArrayList;
  61 import java.util.Collections;
  62 import java.util.Iterator;
  63 import java.util.List;
  64 
  65 
  66 /**
  67  * A generic template for an async task used in AppsCustomize.
  68  */
  69 class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
  70     AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
  71         page = p;
  72         threadPriority = java.lang.Process.THREAD_PRIORITY_DEFAULT;
  73         dataType = ty;
  74     }
  75 
  76     @Override
  77     protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
  78         if (params.length != 1) {
  79             return null;
  80         }
  81         // Load each of the widget previews in the background
  82         params[0].doInBackgroundCallback.run(this, params[0]);
  83         return params[0];
  84     }
  85 
  86     @Override
  87     protected void onPostExecute(AsyncTaskPageData result) {
  88         // All the widget previews are loaded, so we can just callback to inflate the page
  89         result.postExecuteCallback.run(this, result);
  90     }
  91 
  92     void setThreadPriority(int p) {
  93         threadPriority = p;
  94     }
  95 
  96     void syncThreadPriority() {
  97         Process.setThreadPriority(threadPriority);
  98     }
  99 
 100     // The page that this async task is associated with
 101     AsyncTaskPageData.Type dataType;
 102 
 103     int page;
 104 
 105     int threadPriority;
 106 }
 107 
 108 /**
 109  * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 110  */
<abbr title=" 111 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements AllAppsView , View.OnClickListener , View.OnKeyListener , DragSource , PagedViewIcon.PressedCallback , PagedViewWidget.ShortPressListener , LauncherTransitionable {"> 111 public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements AllAppsView , View.OnC</abbr>
 112     static final String LOG_TAG = &quot;AppsCustomizePagedView&quot;;
 113 
 114     /**
 115      * The different content types that this paged view can show.
 116      */
 117     public enum ContentType {
 118 
 119         Applications,
 120         Widgets;}
 121 
 122     // Refs
 123     // Refs
 124     private Launcher mLauncher;
 125 
 126     private DragController mDragController;
 127 
 128     private final LayoutInflater mLayoutInflater;
 129 
 130     private final PackageManager mPackageManager;
 131 
 132     // Save and Restore
 133     // Save and Restore
 134     private int mSaveInstanceStateItemIndex = -1;
 135 
 136     private PagedViewIcon mPressedIcon;
 137 
 138     // Content
 139     // Content
 140     private ArrayList&lt;ApplicationInfo&gt; mApps;
 141 
 142     private ArrayList&lt;Object&gt; mWidgets;
 143 
 144     // Cling
 145     // Cling
 146     private boolean mHasShownAllAppsCling;
 147 
 148     private int mClingFocusedX;
 149 
 150     private int mClingFocusedY;
 151 
 152     // Caching
 153     // Caching
 154     private Canvas mCanvas;
 155 
 156     private Drawable mDefaultWidgetBackground;
 157 
 158     private IconCache mIconCache;
 159 
 160     // Dimens
 161     // Dimens
 162     private int mContentWidth;
 163 
 164     private int mAppIconSize;
 165 
 166     private int mMaxAppCellCountX;
 167 
 168     private int mMaxAppCellCountY;
 169 
 170     private int mWidgetCountX;
 171 
 172     private int mWidgetCountY;
 173 
 174     private int mWidgetWidthGap;
 175 
 176     private int mWidgetHeightGap;
 177 
 178     private final int mWidgetPreviewIconPaddedDimension;
 179 
 180     private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 181 
 182     private PagedViewCellLayout mWidgetSpacingLayout;
 183 
 184     private int mNumAppsPages;
 185 
 186     private int mNumWidgetPages;
 187 
 188     // Relating to the scroll and overscroll effects
 189     // Relating to the scroll and overscroll effects
 190     Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 191 
 192     private static float CAMERA_DISTANCE = 6500;
 193 
 194     private static float TRANSITION_SCALE_FACTOR = 0.74f;
 195 
 196     private static float TRANSITION_PIVOT = 0.65f;
 197 
 198     private static float TRANSITION_MAX_ROTATION = 22;
 199 
 200     private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 201 
 202     private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 203 
 204     private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 205 
 206     // Previews &amp; outlines
 207     // Previews &amp; outlines
 208     ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 209 
 210     private static final int sPageSleepDelay = 200;
 211 
 212     private Runnable mInflateWidgetRunnable = null;
 213 
 214     private Runnable mBindWidgetRunnable = null;
 215 
 216     static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 217 
 218     static final int WIDGET_BOUND = 0;
 219 
 220     static final int WIDGET_INFLATED = 1;
 221 
 222     int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 223 
 224     int mWidgetLoadingId = -1;
 225 
 226     PendingAddWidgetInfo mCreateWidgetInfo = null;
 227 
 228     private boolean mDraggingWidget = false;
 229 
 230     // Deferral of loading widget previews during launcher transitions
 231     // Deferral of loading widget previews during launcher transitions
 232     private boolean mInTransition;
 233 
 234     private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 235         new ArrayList&lt;AsyncTaskPageData&gt;();
 236 
 237     public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 238         super(context, attrs);
 239         mLayoutInflater = LayoutInflater.from(context);
 240         mPackageManager = context.getPackageManager();
 241         mApps = new ArrayList&lt;ApplicationInfo&gt;();
 242         mWidgets = new ArrayList&lt;Object&gt;();
 243         mIconCache = ((LauncherApplication) (context.getApplicationContext())).getIconCache();
 244         mCanvas = new Canvas();
 245         mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 246         // Save the default widget preview background
 247         Resources resources = context.getResources();
 248         mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 249         mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 250         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 251         mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 252         mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
<abbr title=" 253         mWidgetWidthGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);"> 253         mWidgetWidthGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, </abbr>
<abbr title=" 254         mWidgetHeightGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);"> 254         mWidgetHeightGap = a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap</abbr>
 255         mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 256         mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 257         mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 258         mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 259         a.recycle();
 260         mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 261         // The padding on the non-matched dimension for the default widget preview icons
 262         // (top + bottom)
<abbr title=" 263         mWidgetPreviewIconPaddedDimension = ((int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPercentage))));"> 263         mWidgetPreviewIconPaddedDimension = ((int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPer</abbr>
 264         mFadeInAdjacentScreens = false;
 265     }
 266 
 267     @Override
 268     protected void init() {
 269         super.init();
 270         mCenterPagesVertically = false;
 271 
 272         Context context = getContext();
 273         Resources r = context.getResources();
 274         setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 275     }
 276 
 277     @Override
 278     protected void onUnhandledTap(MotionEvent ev) {
 279         if (LauncherApplication.isScreenLarge()) {
 280             // Dismiss AppsCustomize if we tap
 281             mLauncher.showWorkspace(true);
 282         }
 283     }
 284 
 285     /** Returns the item index of the center item on this page so that we can restore to this
 286      *  item index when we rotate. */
 287     private int getMiddleComponentIndexOnCurrentPage() {
 288         int i = -1;
 289         if (getPageCount() &gt; 0) {
 290             int currentPage = getCurrentPage();
 291             if (currentPage &lt; mNumAppsPages) {
 292                 PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 293                 PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 294                 int numItemsPerPage = mCellCountX * mCellCountY;
 295                 int childCount = childrenLayout.getChildCount();
 296                 if (childCount &gt; 0) {
 297                     i = (currentPage * numItemsPerPage) + (childCount / 2);
 298                 }
 299             } else {
 300                 int numApps = mApps.size();
 301                 PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 302                 int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 303                 int childCount = layout.getChildCount();
 304                 if (childCount &gt; 0) {
 305                     i = numApps +
 306                         ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 307                 }
 308             }
 309         }
 310         return i;
 311     }
 312 
 313     /** Get the index of the item to restore to if we need to restore the current page. */
 314     int getSaveInstanceStateIndex() {
 315         if (mSaveInstanceStateItemIndex == -1) {
 316             mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 317         }
 318         return mSaveInstanceStateItemIndex;
 319     }
 320 
 321     /** Returns the page in the current orientation which is expected to contain the specified
 322      *  item index. */
 323     int getPageForComponent(int index) {
 324         if (index &lt; 0) return 0;
 325 
 326         if (index &lt; mApps.size()) {
 327             int numItemsPerPage = mCellCountX * mCellCountY;
 328             return (index / numItemsPerPage);
 329         } else {
 330             int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 331             return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 332         }
 333     }
 334 
 335     /**
 336      * This differs from isDataReady as this is the test done if isDataReady is not set.
 337      */
 338     private boolean testDataReady() {
 339         // We only do this test once, and we default to the Applications page, so we only really
 340         // have to wait for there to be apps.
 341         // TODO: What if one of them is validly empty
 342         return !mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty();
 343     }
 344 
 345     /** Restores the page for an item at the specified index */
 346     void restorePageForIndex(int index) {
 347         if (index &lt; 0) return;
 348         mSaveInstanceStateItemIndex = index;
 349     }
 350 
 351     private void updatePageCounts() {
 352         mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 353                 (float) (mWidgetCountX * mWidgetCountY));
 354         mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 355     }
 356 
 357     protected void onDataReady(int width, int height) {
 358         // Note that we transpose the counts in portrait so that we get a similar layout
 359         boolean isLandscape = getResources().getConfiguration().orientation ==
 360             Configuration.ORIENTATION_LANDSCAPE;
 361         int maxCellCountX = Integer.MAX_VALUE;
 362         int maxCellCountY = Integer.MAX_VALUE;
 363         if (LauncherApplication.isScreenLarge()) {
 364             maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 365                 LauncherModel.getCellCountY());
 366             maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 367                 LauncherModel.getCellCountX());
 368         }
 369         if (mMaxAppCellCountX &gt; -1) {
 370             maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 371         }
 372         if (mMaxAppCellCountY &gt; -1) {
 373             maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 374         }
 375 
 376         // Now that the data is ready, we can calculate the content width, the number of cells to
 377         // use for each page
 378         mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 379         mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 380                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 381         mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 382         mCellCountX = mWidgetSpacingLayout.getCellCountX();
 383         mCellCountY = mWidgetSpacingLayout.getCellCountY();
 384         updatePageCounts();
 385 
 386         // Force a measure to update recalculate the gaps
 387         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 388         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 389         mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 390         mContentWidth = mWidgetSpacingLayout.getContentWidth();
 391 
 392         AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 393         final boolean hostIsTransitioning = host.isTransitioning();
 394 
 395         // Restore the page
 396         int page = getPageForComponent(mSaveInstanceStateItemIndex);
 397         invalidatePageData(Math.max(0, page), hostIsTransitioning);
 398 
 399         // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 400         // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 401         // returned while animating)
 402         if (!hostIsTransitioning) {
 403             post(new Runnable() {
 404                 @Override
 405                 public void run() {
 406                     showAllAppsCling();
 407                 }
 408             });
 409         }
 410     }
 411 
 412     void showAllAppsCling() {
 413         if (!mHasShownAllAppsCling &amp;&amp; isDataReady() &amp;&amp; testDataReady()) {
 414             mHasShownAllAppsCling = true;
 415             // Calculate the position for the cling punch through
 416             int[] offset = new int[2];
 417             int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 418             mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 419             // PagedViews are centered horizontally but top aligned
 420             pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 421                     offset[0];
 422             pos[1] += offset[1];
 423             mLauncher.showFirstRunAllAppsCling(pos);
 424         }
 425     }
 426 
 427     @Override
 428     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 429         int width = MeasureSpec.getSize(widthMeasureSpec);
 430         int height = MeasureSpec.getSize(heightMeasureSpec);
 431         if (!isDataReady()) {
 432             if (testDataReady()) {
 433                 setDataIsReady();
 434                 setMeasuredDimension(width, height);
 435                 onDataReady(width, height);
 436             }
 437         }
 438 
 439         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 440     }
 441 
 442     public void onPackagesUpdated() {
 443         // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered
 444         // by a broadcast receiver, and in order for it to work correctly, we need to know that
 445         // the AppWidgetService has already received and processed the same broadcast. Since there
 446         // is no guarantee about ordering of broadcast receipt, we just delay here. Ideally,
 447         // we should have a more precise way of ensuring the AppWidgetService is up to date.
 448         postDelayed(new Runnable() {
 449            public void run() {
 450                updatePackages();
 451            }
 452         }, 500);
 453     }
 454 
 455     public void updatePackages() {
 456         // Get the list of widgets and shortcuts
 457         boolean wasEmpty = mWidgets.isEmpty();
 458         mWidgets.clear();
<abbr title=" 459         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(mLauncher).getInstalledProviders();"> 459         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(mLauncher).getInstalledProvide</abbr>
 460         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 461         List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 462         for (AppWidgetProviderInfo widget : widgets) {
 463             if ((widget.minWidth &gt; 0) &amp;&amp; (widget.minHeight &gt; 0)) {
 464                 // Ensure that all widgets we show can be added on a workspace of this size
 465                 int[] spanXY = mLauncher.getSpanForWidget(widget);
 466                 int[] minSpanXY =
 467 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 468 mLauncher</span>
 469 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 470 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 470 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 471 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 472 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 473 mLauncher</span>
 474 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 475                 .getMinSpanForWidget(widget);
 476                 int minSpanX = Math.min(
 477 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 478 spanXY[0]</span>
 479 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 480 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 480 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 481 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 482 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 483 spanXY[0]</span>
 484 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 485                 , minSpanXY[0]);
 486                 int minSpanY = Math.min(
 487 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 488                         spanXY[1]</span>
 489 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 490 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 490 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 491 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 492 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 493 spanXY[1]</span>
 494 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 495                 , minSpanXY[1]);
<abbr title=" 496                 if ((minSpanX &lt;= LauncherModel.getCellCountX()) &amp;&amp; (minSpanY &lt;= LauncherModel.getCellCountY())) {"> 496                 if ((minSpanX &lt;= LauncherModel.getCellCountX()) &amp;&amp; (minSpanY &lt;= LauncherModel.getCellCoun</abbr>
 497                     mWidgets.add(widget);
 498                 }
 499             } else {
<abbr title=" 500                 Log.e(LOG_TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; has invalid dimensions (&quot;) + widget.minWidth) + &quot;, &quot;) + widget.minHeight) + &quot;)&quot;);"> 500                 Log.e(LOG_TAG, (((((&quot;Widget &quot; + widget.provider) + &quot; has invalid dimensions (&quot;) + widget.</abbr>
 501             }
 502         }
 503         mWidgets.addAll(shortcuts);
 504         Collections.sort(mWidgets, new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 505         updatePageCounts();
 506         if (wasEmpty) {
 507             // The next layout pass will trigger data-ready if both widgets and apps are set, so request
 508             // a layout to do this test and invalidate the page data when ready.
 509             if (testDataReady()) {
 510                 requestLayout();
 511             }
 512         } else {
 513             cancelAllTasks();
 514             invalidatePageData();
 515         }
 516     }
 517 
 518     @Override
 519     public void onClick(View v) {
 520         // When we have exited all apps or are in transition, disregard clicks
 521         if (!mLauncher.isAllAppsCustomizeOpen() ||
 522                 mLauncher.getWorkspace().isSwitchingState()) return;
 523 
 524         if (v instanceof PagedViewIcon) {
 525             // Animate some feedback to the click
 526             final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 527             mLauncher.startActivitySafely(appInfo.intent, appInfo);
 528 
 529             // Lock the drawable state to pressed until we return to Launcher
 530             if (mPressedIcon != null) {
 531                 mPressedIcon.lockDrawableState();
 532             }
 533         } else if (v instanceof PagedViewWidget) {
 534             // Let the user know that they have to long press to add a widget
 535             Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 536                     Toast.LENGTH_SHORT).show();
 537 
 538             // Create a little animation to show that the widget can move
 539             float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 540             final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 541             AnimatorSet bounce = new AnimatorSet();
 542             ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);
 543             tyuAnim.setDuration(125);
 544             ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);
 545             tydAnim.setDuration(100);
 546             bounce.play(tyuAnim).before(tydAnim);
 547             bounce.setInterpolator(new AccelerateInterpolator());
 548             bounce.start();
 549         }
 550     }
 551 
 552     public boolean onKey(View v, int keyCode, KeyEvent event) {
 553         return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 554     }
 555 
 556     /*
 557      * PagedViewWithDraggableItems implementation
 558      */
 559     @Override
 560     protected void determineDraggingStart(android.view.MotionEvent ev) {
 561         // Disable dragging by pulling an app down for now.
 562     }
 563 
 564     private void beginDraggingApplication(View v) {
 565         mLauncher.getWorkspace().onDragStartedWithItem(v);
 566         mLauncher.getWorkspace().beginDragShared(v, this);
 567     }
 568 
 569     private void loadWidgetInBackground(final PendingAddWidgetInfo info) {
 570         final AppWidgetProviderInfo pInfo = info.info;
 571         if (pInfo.configure != null) {
 572             return;
 573         }
 574 
 575         mBindWidgetRunnable = new Runnable() {
 576             @Override
 577             public void run() {
 578                 mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 579                 AppWidgetManager.getInstance(mLauncher).bindAppWidgetId(mWidgetLoadingId,
 580                         info.componentName);
 581                 mWidgetCleanupState = WIDGET_BOUND;
 582             }
 583         };
 584         post(mBindWidgetRunnable);
 585 
 586         mInflateWidgetRunnable = new Runnable() {
 587             @Override
 588             public void run() {
 589                 AppWidgetHostView hostView =
 590                         mLauncher.getAppWidgetHost().createView(mContext, mWidgetLoadingId, pInfo);
 591                 info.boundWidget = hostView;
 592                 mWidgetCleanupState = WIDGET_INFLATED;
 593                 hostView.setVisibility(INVISIBLE);
 594                 int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 595                         info.spanY, info, false);
 596 
 597                 // We want the first widget layout to be the correct size. This will be important
 598                 // for width size reporting to the AppWidgetManager.
 599                 DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 600                         unScaledSize[1]);
 601                 lp.x = lp.y = 0;
 602                 lp.customPosition = true;
 603                 hostView.setLayoutParams(lp);
 604                 mLauncher.getDragLayer().addView(hostView);
 605             }
 606         };
 607         post(mInflateWidgetRunnable);
 608     }
 609 
 610     @Override
 611     public void onShortPress(View v) {
 612         // We are anticipating a long press, and we use this time to load bind and instantiate
 613         // the widget. This will need to be cleaned up if it turns out no long press occurs.
 614         mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 615         loadWidgetInBackground(mCreateWidgetInfo);
 616     }
 617 
 618     private void cleanupWidgetPreloading() {
 619         PendingAddWidgetInfo info = mCreateWidgetInfo;
 620         mCreateWidgetInfo = null;
 621         if (mWidgetCleanupState &gt;= 0 &amp;&amp; mWidgetLoadingId != -1) {
 622             mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 623         }
 624         if (mWidgetCleanupState == WIDGET_BOUND) {
 625             removeCallbacks(mInflateWidgetRunnable);
 626         } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 627             AppWidgetHostView widget = info.boundWidget;
 628             int widgetId = widget.getAppWidgetId();
 629             mLauncher.getAppWidgetHost().deleteAppWidgetId(widgetId);
 630             mLauncher.getDragLayer().removeView(widget);
 631         }
 632         mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 633         mWidgetLoadingId = -1;
 634     }
 635 
 636     @Override
 637     public void cleanUpShortPress(View v) {
 638         if (!mDraggingWidget) {
 639             cleanupWidgetPreloading();
 640         }
 641     }
 642 
 643     private void beginDraggingWidget(View v) {
 644         mDraggingWidget = true;
 645         // Get the widget preview as the drag representation
 646         ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 647         PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 648 
 649         // Compose the drag image
 650         Bitmap preview;
 651         Bitmap outline;
 652         float scale = 1f;
 653         if (createItemInfo instanceof PendingAddWidgetInfo) {
 654             PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 655             createItemInfo = createWidgetInfo;
 656             int spanX = createItemInfo.spanX;
 657             int spanY = createItemInfo.spanY;
 658             int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 659                     createWidgetInfo, true);
 660 
 661             FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 662             float minScale = 1.25f;
 663             int minWidth, minHeight;
 664             minWidth = Math.max((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 665             minHeight = Math.max((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 666             preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 667                     createWidgetInfo.icon, spanX, spanY, minWidth, minHeight);
 668 
 669             // Determine the image view drawable scale relative to the preview
 670             float[] mv = new float[9];
 671             Matrix m = new Matrix();
 672             m.setRectToRect(
 673                     new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 674                     new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 675                             (float) previewDrawable.getIntrinsicHeight()),
 676                     Matrix.ScaleToFit.START);
 677             m.getValues(mv);
 678             scale = (float) mv[0];
 679         } else {
 680             // Workaround for the fact that we don&#x27;t keep the original ResolveInfo associated with
 681             // the shortcut around.  To get the icon, we just render the preview image (which has
 682             // the shortcut icon) to a new drag bitmap that clips the non-icon space.
 683             preview = Bitmap.createBitmap(mWidgetPreviewIconPaddedDimension,
 684                     mWidgetPreviewIconPaddedDimension, Bitmap.Config.ARGB_8888);
 685             Drawable d = image.getDrawable();
 686             mCanvas.setBitmap(preview);
 687             d.draw(mCanvas);
 688             mCanvas.setBitmap(null);
 689             createItemInfo.spanX = createItemInfo.spanY = 1;
 690         }
 691 
 692         // We use a custom alpha clip table for the default widget previews
 693         Paint alphaClipPaint = null;
 694         if (createItemInfo instanceof PendingAddWidgetInfo) {
 695             if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 696                 MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 697                 alphaClipPaint = new Paint();
 698                 alphaClipPaint.setMaskFilter(alphaClipTable);
 699             }
 700         }
 701 
 702         // Save the preview for the outline generation, then dim the preview
 703         outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 704                 false);
 705 
 706         // Start the drag
 707         alphaClipPaint = null;
 708         mLauncher.lockScreenOrientationOnLargeUI();
 709         mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);
 710         mDragController.startDrag(image, preview, this, createItemInfo,
 711                 DragController.DRAG_ACTION_COPY, null, scale);
 712         outline.recycle();
 713         preview.recycle();
 714     }
 715 
 716     @Override
 717     protected boolean beginDragging(final View v) {
 718         if (!super.beginDragging(v)) return false;
 719 
 720         if (v instanceof PagedViewIcon) {
 721             beginDraggingApplication(v);
 722         } else if (v instanceof PagedViewWidget) {
 723             beginDraggingWidget(v);
 724         }
 725 
 726         // We delay entering spring-loaded mode slightly to make sure the UI
 727         // thready is free of any work.
 728         postDelayed(new Runnable() {
 729             @Override
 730             public void run() {
 731                 // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 732                 if (mLauncher.getDragController().isDragging()) {
 733                     // Dismiss the cling
 734                     mLauncher.dismissAllAppsCling(null);
 735 
 736                     // Reset the alpha on the dragged icon before we drag
 737                     resetDrawableState();
 738 
 739                     // Go into spring loaded mode (must happen before we startDrag())
 740                     mLauncher.enterSpringLoadedDragMode();
 741                 }
 742             }
 743         }, 150);
 744 
 745         return true;
 746     }
 747 
 748     /**
 749      * Clean up after dragging.
 750      *
 751      * @param target where the item was dragged to (can be null if the item was flung)
 752      */
 753     private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 754         if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 755                 !(target instanceof DeleteDropTarget))) {
 756             // Exit spring loaded mode if we have not successfully dropped or have not handled the
 757             // drop in Workspace
 758             mLauncher.exitSpringLoadedDragMode();
 759         }
 760         mLauncher.unlockScreenOrientationOnLargeUI();
 761     }
 762 
 763     @Override
 764     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 765         mInTransition = true;
 766         if (toWorkspace) {
 767             cancelAllTasks();
 768         }
 769     }
 770 
 771     @Override
 772     public View getContent() {
 773         return null;
 774     }
 775 
 776     @Override
 777     public void onLauncherTransitionStep(Launcher l, float t) {
 778     }
 779 
 780     @Override
 781     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 782         mInTransition = false;
 783         for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 784             onSyncWidgetPageItems(d);
 785         }
 786         mDeferredSyncWidgetPageItems.clear();
 787     }
 788 
 789     @Override
 790     public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 791             boolean success) {
 792         // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 793         if (isFlingToDelete) return;
 794 
 795         endDragging(target, false, success);
 796 
 797         // Display an error message if the drag failed due to there not being enough space on the
 798         // target layout we were dropping on.
 799         if (!success) {
 800             boolean showOutOfSpaceMessage = false;
 801             if (target instanceof Workspace) {
 802                 int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 803                 Workspace workspace = (Workspace) target;
 804                 CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 805                 ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 806                 if (layout != null) {
 807                     layout.calculateSpans(itemInfo);
 808                     showOutOfSpaceMessage =
 809                             !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 810                 }
 811             }
 812             if (showOutOfSpaceMessage) {
 813                 mLauncher.showOutOfSpaceMessage(false);
 814             }
 815 
 816             d.deferDragViewCleanupPostAnimation = false;
 817             cleanupWidgetPreloading();
 818         }
 819         mDraggingWidget = false;
 820     }
 821 
 822     @Override
 823     public void onFlingToDeleteCompleted() {
 824         // We just dismiss the drag when we fling, so cleanup here
 825         endDragging(null, true, true);
 826         cleanupWidgetPreloading();
 827         mDraggingWidget = false;
 828     }
 829 
 830     @Override
 831     public boolean supportsFlingToDelete() {
 832         return true;
 833     }
 834 
 835     @Override
 836     protected void onDetachedFromWindow() {
 837         super.onDetachedFromWindow();
 838         cancelAllTasks();
 839     }
 840 
 841     public void clearAllWidgetPages() {
 842         cancelAllTasks();
 843         int count = getChildCount();
 844         for (int i = 0; i &lt; count; i++) {
 845             View v = getPageAt(i);
 846             if (v instanceof PagedViewGridLayout) {
 847                 ((PagedViewGridLayout) v).removeAllViewsOnPage();
 848                 mDirtyPageContent.set(i, true);
 849             }
 850         }
 851     }
 852 
 853     private void cancelAllTasks() {
 854         // Clean up all the async tasks
 855         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 856         while (iter.hasNext()) {
 857             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 858             task.cancel(false);
 859             iter.remove();
 860             mDirtyPageContent.set(task.page, true);
 861         }
 862     }
 863 
 864     public void setContentType(ContentType type) {
 865         if (type == ContentType.Widgets) {
 866             invalidatePageData(mNumAppsPages, true);
 867         } else if (type == ContentType.Applications) {
 868             invalidatePageData(0, true);
 869         }
 870     }
 871 
 872     protected void snapToPage(int whichPage, int delta, int duration) {
 873         super.snapToPage(whichPage, delta, duration);
 874         updateCurrentTab(whichPage);
 875 
 876         // Update the thread priorities given the direction lookahead
 877         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 878         while (iter.hasNext()) {
 879             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 880             int pageIndex = task.page;
 881             if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 882                 (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 883                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 884             } else {
 885                 task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 886             }
 887         }
 888     }
 889 
 890     private void updateCurrentTab(int currentPage) {
 891         AppsCustomizeTabHost tabHost = getTabHost();
 892         if (tabHost != null) {
 893             String tag = tabHost.getCurrentTabTag();
 894             if (tag != null) {
 895                 if (currentPage &gt;= mNumAppsPages &amp;&amp;
 896                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 897                     tabHost.setCurrentTabFromContent(ContentType.Widgets);
 898                 } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 899                         !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 900                     tabHost.setCurrentTabFromContent(ContentType.Applications);
 901                 }
 902             }
 903         }
 904     }
 905 
 906     /*
 907      * Apps PagedView implementation
 908      */
 909     private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 910         int childCount = layout.getChildCount();
 911         for (int i = 0; i &lt; childCount; ++i) {
 912             layout.getChildAt(i).setVisibility(visibility);
 913         }
 914     }
 915 
 916     private void setupPage(PagedViewCellLayout layout) {
 917         layout.setCellCount(mCellCountX, mCellCountY);
 918         layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 919         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 920                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 921 
 922         // Note: We force a measure here to get around the fact that when we do layout calculations
 923         // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 924         // expected page width, so we can actually optimize by hiding all the TextView-based
 925         // children that are expensive to measure, and let that happen naturally later.
 926         setVisibilityOnChildren(layout, View.GONE);
 927         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 928         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 929         layout.setMinimumWidth(getPageContentWidth());
 930         layout.measure(widthSpec, heightSpec);
 931         setVisibilityOnChildren(layout, View.VISIBLE);
 932     }
 933 
 934     public void syncAppsPageItems(int page, boolean immediate) {
 935         // ensure that we have the right number of items on the pages
 936         int numCells = mCellCountX * mCellCountY;
 937         int startIndex = page * numCells;
 938         int endIndex = Math.min(startIndex + numCells, mApps.size());
 939         PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 940 
 941         layout.removeAllViewsOnPage();
 942         ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 943         ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 944         for (int i = startIndex; i &lt; endIndex; ++i) {
 945             ApplicationInfo info = mApps.get(i);
 946             PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 947                     R.layout.apps_customize_application, layout, false);
 948             icon.applyFromApplicationInfo(info, true, this);
 949             icon.setOnClickListener(this);
 950             icon.setOnLongClickListener(this);
 951             icon.setOnTouchListener(this);
 952             icon.setOnKeyListener(this);
 953 
 954             int index = i - startIndex;
 955             int x = index % mCellCountX;
 956             int y = index / mCellCountX;
 957             layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 958 
 959             items.add(info);
 960             images.add(info.iconBitmap);
 961         }
 962 
 963         layout.createHardwareLayers();
 964     }
 965 
 966     /**
 967      * A helper to return the priority for loading of the specified widget page.
 968      */
 969     private int getWidgetPageLoadPriority(int page) {
 970         // If we are snapping to another page, use that index as the target page index
 971         int toPage = mCurrentPage;
 972         if (mNextPage &gt; -1) {
 973             toPage = mNextPage;
 974         }
 975 
 976         // We use the distance from the target page as an initial guess of priority, but if there
 977         // are no pages of higher priority than the page specified, then bump up the priority of
 978         // the specified page.
 979         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 980         int minPageDiff = Integer.MAX_VALUE;
 981         while (iter.hasNext()) {
 982             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 983             minPageDiff = Math.abs(task.page - toPage);
 984         }
 985 
 986         int rawPageDiff = Math.abs(page - toPage);
 987         return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 988     }
 989 
 990     /**
 991      * Return the appropriate thread priority for loading for a given page (we give the current
 992      * page much higher priority)
 993      */
 994     private int getThreadPriorityForPage(int page) {
 995         // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
 996         int pageDiff = getWidgetPageLoadPriority(page);
 997         if (pageDiff &lt;= 0) {
 998             return Process.THREAD_PRIORITY_LESS_FAVORABLE;
 999         } else if (pageDiff &lt;= 1) {
1000             return Process.THREAD_PRIORITY_LOWEST;
1001         } else {
1002             return Process.THREAD_PRIORITY_LOWEST;
1003         }
1004     }
1005 
1006     private int getSleepForPage(int page) {
1007         int pageDiff = getWidgetPageLoadPriority(page);
1008         return Math.max(0, pageDiff * sPageSleepDelay);
1009     }
1010 
1011     /**
1012      * Creates and executes a new AsyncTask to load a page of widget previews.
1013      */
1014     private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1015             int cellWidth, int cellHeight, int cellCountX) {
1016 
1017         // Prune all tasks that are no longer needed
1018         Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1019         while (iter.hasNext()) {
1020             AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1021             int taskPage = task.page;
1022             if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1023                     taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1024                 task.cancel(false);
1025                 iter.remove();
1026             } else {
1027                 task.setThreadPriority(getThreadPriorityForPage(taskPage));
1028             }
1029         }
1030 
1031         // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1032         final int sleepMs = getSleepForPage(page);
1033         AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1034             new AsyncTaskCallback() {
1035                 @Override
1036                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1037                     try {
1038                         try {
1039                             Thread.sleep(sleepMs);
1040                         } catch (Exception e) {}
1041                         loadWidgetPreviewsInBackground(task, data);
1042                     } finally {
1043                         if (task.isCancelled()) {
1044                             data.cleanup(true);
1045                         }
1046                     }
1047                 }
1048             },
1049             new AsyncTaskCallback() {
1050                 @Override
1051                 public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1052                     mRunningTasks.remove(task);
1053                     if (task.isCancelled()) return;
1054                     // do cleanup inside onSyncWidgetPageItems
1055                     onSyncWidgetPageItems(data);
1056                 }
1057             });
1058 
1059         // Ensure that the task is appropriately prioritized and runs in parallel
1060         AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1061                 AsyncTaskPageData.Type.LoadWidgetPreviewData);
1062         t.setThreadPriority(getThreadPriorityForPage(page));
1063         t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1064         mRunningTasks.add(t);
1065     }
1066 
1067     /*
1068      * Widgets PagedView implementation
1069      */
1070     private void setupPage(PagedViewGridLayout layout) {
1071         layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1072                 mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1073 
1074         // Note: We force a measure here to get around the fact that when we do layout calculations
1075         // immediately after syncing, we don&#x27;t have a proper width.
1076         int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1077         int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1078         layout.setMinimumWidth(getPageContentWidth());
1079         layout.measure(widthSpec, heightSpec);
1080     }
1081 
1082     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1083         renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f, 0xFFFFFFFF);
1084     }
1085 
1086     private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1087             float scale, int multiplyColor) {
1088         if (bitmap != null) {
1089             Canvas c = new Canvas(bitmap);
1090             c.scale(scale, scale);
1091             Rect oldBounds = d.copyBounds();
1092             d.setBounds(x, y, x + w, y + h);
1093             d.draw(c);
1094             d.setBounds(oldBounds); // Restore the bounds
1095             c.setBitmap(null);
1096         }
1097     }
1098 
1099     private Bitmap getShortcutPreview(ResolveInfo info) {
1100         // Render the background
1101         int offset = 0;
1102         int bitmapSize = mAppIconSize;
1103         Bitmap preview = Bitmap.createBitmap(bitmapSize, bitmapSize, Config.ARGB_8888);
1104 
1105         // Render the icon
1106         Drawable icon = mIconCache.getFullResIcon(info);
1107         renderDrawableToBitmap(icon, preview, offset, offset, mAppIconSize, mAppIconSize);
1108         return preview;
1109     }
1110 
1111     private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId,
1112             int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {
1113         // Load the preview image if possible
1114         String packageName = provider.getPackageName();
1115         if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1116         if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1117 
1118         Drawable drawable = null;
1119         if (previewImage != 0) {
1120             drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1121             if (drawable == null) {
1122                 Log.w(LOG_TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1123                         Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1124             }
1125         }
1126 
1127         int bitmapWidth;
1128         int bitmapHeight;
1129         boolean widgetPreviewExists = (drawable != null);
1130         if (widgetPreviewExists) {
1131             bitmapWidth = drawable.getIntrinsicWidth();
1132             bitmapHeight = drawable.getIntrinsicHeight();
1133         } else {
1134             if (cellHSpan &lt; 1) cellHSpan = 1;
1135             if (cellVSpan &lt; 1) cellVSpan = 1;
1136             // Determine the size of the bitmap for the preview image we will generate
1137             // TODO: This actually uses the apps customize cell layout params, where as we make want
1138             // the Workspace params for more accuracy.
1139             bitmapWidth = mWidgetSpacingLayout.estimateCellWidth(cellHSpan);
1140             bitmapHeight = mWidgetSpacingLayout.estimateCellHeight(cellVSpan);
1141             if (cellHSpan == cellVSpan) {
1142                 // For square widgets, we just have a fixed size for 1x1 and larger-than-1x1
1143                 int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1144                 if (cellHSpan &lt;= 1) {
1145                     bitmapWidth = bitmapHeight = mAppIconSize + 2 * minOffset;
1146                 } else {
1147                     bitmapWidth = bitmapHeight = mAppIconSize + 4 * minOffset;
1148                 }
1149             }
1150         }
1151 
1152         float scale = 1f;
1153         if (bitmapWidth &gt; maxWidth) {
1154             scale = maxWidth / (float) bitmapWidth;
1155         }
1156         if (bitmapHeight * scale &gt; maxHeight) {
1157             scale = maxHeight / (float) bitmapHeight;
1158         }
1159         if (scale != 1f) {
1160             bitmapWidth = (int) (scale * bitmapWidth);
1161             bitmapHeight = (int) (scale * bitmapHeight);
1162         }
1163 
1164         Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1165 
1166         if (widgetPreviewExists) {
1167             renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1168         } else {
1169             // Generate a preview image if we couldn&#x27;t load one
1170             int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1171             int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1172             float iconScale = Math.min((float) smallestSide / (mAppIconSize + 2 * minOffset), 1f);
1173             if (cellHSpan != 1 || cellVSpan != 1) {
1174                 renderDrawableToBitmap(mDefaultWidgetBackground, preview, 0, 0, bitmapWidth,
1175                         bitmapHeight);
1176             }
1177 
1178             // Draw the icon in the top left corner
1179             try {
1180                 Drawable icon = null;
1181                 int hoffset = (int) (bitmapWidth / 2 - mAppIconSize * iconScale / 2);
1182                 int yoffset = (int) (bitmapHeight / 2 - mAppIconSize * iconScale / 2);
1183                 if (iconId &gt; 0) icon = mIconCache.getFullResIcon(packageName, iconId);
1184                 Resources resources = mLauncher.getResources();
1185                 if (icon == null) icon = resources.getDrawable(R.drawable.ic_launcher_application);
1186 
1187                 renderDrawableToBitmap(icon, preview, hoffset, yoffset,
1188                         (int) (mAppIconSize * iconScale),
1189                         (int) (mAppIconSize * iconScale));
1190             } catch (Resources.NotFoundException e) {}
1191         }
1192         return preview;
1193     }
1194 
1195     public void syncWidgetPageItems(final int page, final boolean immediate) {
1196         int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1197         // Calculate the dimensions of each cell we are giving to each widget
1198         final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1199         int contentWidth = mWidgetSpacingLayout.getContentWidth();
<abbr title="1200         final int cellWidth = (((contentWidth - mPageLayoutPaddingLeft) - mPageLayoutPaddingRight) - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX;">1200         final int cellWidth = (((contentWidth - mPageLayoutPaddingLeft) - mPageLayoutPaddingRight) - ((mW</abbr>
1201         int contentHeight = mWidgetSpacingLayout.getContentHeight();
<abbr title="1202         final int cellHeight = (((contentHeight - mPageLayoutPaddingTop) - mPageLayoutPaddingBottom) - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY;">1202         final int cellHeight = (((contentHeight - mPageLayoutPaddingTop) - mPageLayoutPaddingBottom) - ((</abbr>
1203         // Prepare the set of widgets to load previews for in the background
1204         int offset = (page - mNumAppsPages) * numItemsPerPage;
1205         for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1206             items.add(mWidgets.get(i));
1207         }
1208         // Prepopulate the pages with the other widget info, and fill in the previews later
1209         final PagedViewGridLayout layout = ((PagedViewGridLayout) (getPageAt(page)));
1210         layout.setColumnCount(layout.getCellCountX());
1211         for (int i = 0; i &lt; items.size(); ++i) {
1212             Object rawInfo = items.get(i);
1213             PendingAddItemInfo createItemInfo = null;
<abbr title="1214             PagedViewWidget widget = ((PagedViewWidget) (mLayoutInflater.inflate(R.layout.apps_customize_widget, layout, false)));">1214             PagedViewWidget widget = ((PagedViewWidget) (mLayoutInflater.inflate(R.layout.apps_customize_</abbr>
1215             if (rawInfo instanceof AppWidgetProviderInfo) {
1216                 // Fill in the widget information
1217                 AppWidgetProviderInfo info = ((AppWidgetProviderInfo) (rawInfo));
1218                 createItemInfo = new PendingAddWidgetInfo(info, null, null);
1219                 // Determine the widget spans and min resize spans.
1220                 int[] spanXY = mLauncher.getSpanForWidget(info);
1221                 createItemInfo.spanX = spanXY[0];
1222                 createItemInfo.spanY = spanXY[1];
1223                 int[] minSpanXY = mLauncher.getMinSpanForWidget(info);
1224                 createItemInfo.minSpanX = minSpanXY[0];
1225                 createItemInfo.minSpanY = minSpanXY[1];
1226                 widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1227                 widget.setTag(createItemInfo);
1228                 widget.setShortPressListener(this);
1229             } else if (rawInfo instanceof ResolveInfo) {
1230                 // Fill in the shortcuts information
1231                 ResolveInfo info = ((ResolveInfo) (rawInfo));
1232                 createItemInfo = new PendingAddItemInfo();
1233                 createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
<abbr title="1234                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName, info.activityInfo.name);">1234                 createItemInfo.componentName = new ComponentName(info.activityInfo.packageName, info.acti</abbr>
1235                 widget.applyFromResolveInfo(mPackageManager, info);
1236                 widget.setTag(createItemInfo);
1237             }
1238             widget.setOnClickListener(this);
1239             widget.setOnLongClickListener(this);
1240             widget.setOnTouchListener(this);
1241             widget.setOnKeyListener(this);
1242             // Layout each widget
1243             int ix = i % mWidgetCountX;
1244             int iy = i / mWidgetCountX;
<abbr title="1245             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(GridLayout.spec(iy, GridLayout.LEFT), GridLayout.spec(ix, GridLayout.TOP));">1245             GridLayout.LayoutParams lp = new GridLayout.LayoutParams(GridLayout.spec(iy, GridLayout.LEFT)</abbr>
1246             lp.width = cellWidth;
1247             lp.height = cellHeight;
1248             lp.setGravity(Gravity.TOP | Gravity.LEFT);
1249             if (ix &gt; 0) {
1250                 lp.leftMargin = mWidgetWidthGap;
1251             }
1252             if (iy &gt; 0) {
1253                 lp.topMargin = mWidgetHeightGap;
1254             }
1255             layout.addView(widget, lp);
1256         }
1257         // wait until a call on onLayout to start loading, because
1258         // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1259         // TODO: can we do a measure/layout immediately?
1260         layout.setOnLayoutListener(new Runnable() {
1261             public void run() {
1262                 // Load the widget previews
1263                 int maxPreviewWidth = cellWidth;
1264                 int maxPreviewHeight = cellHeight;
1265                 if (layout.getChildCount() &gt; 0) {
1266                     PagedViewWidget w = ((PagedViewWidget) (layout.getChildAt(0)));
1267                     int[] maxSize = w.getPreviewSize();
1268                     maxPreviewWidth = maxSize[0];
1269                     maxPreviewHeight = maxSize[1];
1270                 }
1271                 if (immediate) {
<abbr title="1272                     AsyncTaskPageData data = new AsyncTaskPageData(page, items, maxPreviewWidth, maxPreviewHeight, null, null);">1272                     AsyncTaskPageData data = new AsyncTaskPageData(page, items, maxPreviewWidth, maxPrevi</abbr>
1273                     loadWidgetPreviewsInBackground(null, data);
1274                     onSyncWidgetPageItems(data);
1275                 } else {
<abbr title="1276                     prepareLoadWidgetPreviewsTask(page, items, maxPreviewWidth, maxPreviewHeight, mWidgetCountX);">1276                     prepareLoadWidgetPreviewsTask(page, items, maxPreviewWidth, maxPreviewHeight, mWidget</abbr>
1277                 }
1278             }
1279         });
1280     }
1281 
1282     private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1283         // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1284         // previews synchronously
1285         if (task != null) {
1286             // Ensure that this task starts running at the correct priority
1287             task.syncThreadPriority();
1288         }
1289         // Load each of the widget/shortcut previews
1290         ArrayList&lt;Object&gt; items = data.items;
1291         ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1292         int count = items.size();
1293         for (int i = 0; i &lt; count; ++i) {
1294             if (task != null) {
1295                 // Ensure we haven&#x27;t been cancelled yet
1296                 if (task.isCancelled()) {
1297                     break;
1298                 }
1299                 // Before work on each item, ensure that this task is running at the correct
1300                 // priority
1301                 task.syncThreadPriority();
1302             }
1303             Object rawInfo = items.get(i);
1304             if (rawInfo instanceof AppWidgetProviderInfo) {
1305                 AppWidgetProviderInfo info = ((AppWidgetProviderInfo) (rawInfo));
1306                 int[] cellSpans = mLauncher.getSpanForWidget(info);
<abbr title="1307                 int maxWidth = Math.min(data.maxImageWidth, mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));">1307                 int maxWidth = Math.min(data.maxImageWidth, mWidgetSpacingLayout.estimateCellWidth(cellSp</abbr>
<abbr title="1308                 int maxHeight = Math.min(data.maxImageHeight, mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));">1308                 int maxHeight = Math.min(data.maxImageHeight, mWidgetSpacingLayout.estimateCellHeight(cel</abbr>
<abbr title="1309                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon, cellSpans[0], cellSpans[1], maxWidth, maxHeight);">1309                 Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon, cellSpans[0], ce</abbr>
1310                 images.add(b);
1311             } else if (rawInfo instanceof ResolveInfo) {
1312                 // Fill in the shortcuts information
1313                 ResolveInfo info = ((ResolveInfo) (rawInfo));
1314                 images.add(getShortcutPreview(info));
1315             }
1316         }
1317     }
1318 
1319     private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1320         if (mInTransition) {
1321             mDeferredSyncWidgetPageItems.add(data);
1322             return;
1323         }
1324         try {
1325             int page = data.page;
1326             PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1327 
1328             ArrayList&lt;Object&gt; items = data.items;
1329             int count = items.size();
1330             for (int i = 0; i &lt; count; ++i) {
1331                 PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1332                 if (widget != null) {
1333                     Bitmap preview = data.generatedImages.get(i);
1334                     widget.applyPreview(new FastBitmapDrawable(preview), i);
1335                 }
1336             }
1337 
1338             layout.createHardwareLayer();
1339             invalidate();
1340 
1341             // Update all thread priorities
1342             Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1343             while (iter.hasNext()) {
1344                 AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1345                 int pageIndex = task.page;
1346                 task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1347             }
1348         } finally {
1349             data.cleanup(false);
1350         }
1351     }
1352 
1353     @Override
1354     public void syncPages() {
1355         removeAllViews();
1356         cancelAllTasks();
1357 
1358         Context context = getContext();
1359         for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1360             PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1361                     mWidgetCountY);
1362             setupPage(layout);
1363             addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1364                     LayoutParams.MATCH_PARENT));
1365         }
1366 
1367         for (int i = 0; i &lt; mNumAppsPages; ++i) {
1368             PagedViewCellLayout layout = new PagedViewCellLayout(context);
1369             setupPage(layout);
1370             addView(layout);
1371         }
1372     }
1373 
1374     @Override
1375     public void syncPageItems(int page, boolean immediate) {
1376         if (page &lt; mNumAppsPages) {
1377             syncAppsPageItems(page, immediate);
1378         } else {
1379             syncWidgetPageItems(page, immediate);
1380         }
1381     }
1382 
1383     // We want our pages to be z-ordered such that the further a page is to the left, the higher
1384     // it is in the z-order. This is important to insure touch events are handled correctly.
1385     View getPageAt(int index) {
1386         return getChildAt(indexToPage(index));
1387     }
1388 
1389     @Override
1390     protected int indexToPage(int index) {
1391         return getChildCount() - index - 1;
1392     }
1393 
1394     // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1395     @Override
1396     protected void screenScrolled(int screenCenter) {
1397         super.screenScrolled(screenCenter);
1398 
1399         for (int i = 0; i &lt; getChildCount(); i++) {
1400             View v = getPageAt(i);
1401             if (v != null) {
1402                 float scrollProgress = getScrollProgress(screenCenter, v, i);
1403 
1404                 float interpolatedProgress =
1405                         mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1406                 float scale = (1 - interpolatedProgress) +
1407                         interpolatedProgress * TRANSITION_SCALE_FACTOR;
1408                 float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1409 
1410                 float alpha;
1411 
1412                 if (!LauncherApplication.isScreenLarge() || scrollProgress &lt; 0) {
1413                     alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1414                         1 - Math.abs(scrollProgress)) : 1.0f;
1415                 } else {
1416                     // On large screens we need to fade the page as it nears its leftmost position
1417                     alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1418                 }
1419 
1420                 v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1421                 int pageWidth = v.getMeasuredWidth();
1422                 int pageHeight = v.getMeasuredHeight();
1423 
1424                 if (PERFORM_OVERSCROLL_ROTATION) {
1425                     if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1426                         // Overscroll to the left
1427                         v.setPivotX(TRANSITION_PIVOT * pageWidth);
1428                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1429                         scale = 1.0f;
1430                         alpha = 1.0f;
1431                         // On the first page, we don&#x27;t want the page to have any lateral motion
1432                         translationX = 0;
1433                     } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1434                         // Overscroll to the right
1435                         v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1436                         v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1437                         scale = 1.0f;
1438                         alpha = 1.0f;
1439                         // On the last page, we don&#x27;t want the page to have any lateral motion.
1440                         translationX = 0;
1441                     } else {
1442                         v.setPivotY(pageHeight / 2.0f);
1443                         v.setPivotX(pageWidth / 2.0f);
1444                         v.setRotationY(0f);
1445                     }
1446                 }
1447 
1448                 v.setTranslationX(translationX);
1449                 v.setScaleX(scale);
1450                 v.setScaleY(scale);
1451                 v.setAlpha(alpha);
1452 
1453                 // If the view has 0 alpha, we set it to be invisible so as to prevent
1454                 // it from accepting touches
1455                 if (alpha &lt; ViewConfiguration.ALPHA_THRESHOLD) {
1456                     v.setVisibility(INVISIBLE);
1457                 } else if (v.getVisibility() != VISIBLE) {
1458                     v.setVisibility(VISIBLE);
1459                 }
1460             }
1461         }
1462     }
1463 
1464     protected void overScroll(float amount) {
1465         acceleratedOverScroll(amount);
1466     }
1467 
1468     /**
1469      * Used by the parent to get the content width to set the tab bar to
1470      * @return
1471      */
1472     public int getPageContentWidth() {
1473         return mContentWidth;
1474     }
1475 
1476     @Override
1477     protected void onPageEndMoving() {
1478         super.onPageEndMoving();
1479 
1480         // We reset the save index when we change pages so that it will be recalculated on next
1481         // rotation
1482         mSaveInstanceStateItemIndex = -1;
1483     }
1484 
1485     /*
1486      * AllAppsView implementation
1487      */
1488     @Override
1489     public void setup(Launcher launcher, DragController dragController) {
1490         mLauncher = launcher;
1491         mDragController = dragController;
1492     }
1493 
1494     @Override
1495     public void zoom(float zoom, boolean animate) {
1496         // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1497     }
1498 
1499     @Override
1500     public boolean isVisible() {
1501         return (getVisibility() == VISIBLE);
1502     }
1503 
1504     @Override
1505     public boolean isAnimating() {
1506         return false;
1507     }
1508 
1509     @Override
1510     public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1511         mApps = list;
1512         Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1513         updatePageCounts();
1514 
1515         // The next layout pass will trigger data-ready if both widgets and apps are set, so
1516         // request a layout to do this test and invalidate the page data when ready.
1517         if (testDataReady()) requestLayout();
1518     }
1519 
1520     private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1521         // We add it in place, in alphabetical order
1522         int count = list.size();
1523         for (int i = 0; i &lt; count; ++i) {
1524             ApplicationInfo info = list.get(i);
1525             int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1526             if (index &lt; 0) {
1527                 mApps.add(-(index + 1), info);
1528             }
1529         }
1530     }
1531 
1532     @Override
1533     public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1534         addAppsWithoutInvalidate(list);
1535         updatePageCounts();
1536         invalidatePageData();
1537     }
1538 
1539     private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1540         ComponentName removeComponent = item.intent.getComponent();
1541         int length = list.size();
1542         for (int i = 0; i &lt; length; ++i) {
1543             ApplicationInfo info = list.get(i);
1544             if (info.intent.getComponent().equals(removeComponent)) {
1545                 return i;
1546             }
1547         }
1548         return -1;
1549     }
1550 
1551     private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1552         // loop through all the apps and remove apps that have the same component
1553         int length = list.size();
1554         for (int i = 0; i &lt; length; ++i) {
1555             ApplicationInfo info = list.get(i);
1556             int removeIndex = findAppByComponent(mApps, info);
1557             if (removeIndex &gt; -1) {
1558                 mApps.remove(removeIndex);
1559             }
1560         }
1561     }
1562 
1563     @Override
1564     public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1565         removeAppsWithoutInvalidate(list);
1566         updatePageCounts();
1567         invalidatePageData();
1568     }
1569 
1570     @Override
1571     public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1572         // We remove and re-add the updated applications list because it&#x27;s properties may have
1573         // changed (ie. the title), and this will ensure that the items will be in their proper
1574         // place in the list.
1575         removeAppsWithoutInvalidate(list);
1576         addAppsWithoutInvalidate(list);
1577         updatePageCounts();
1578 
1579         invalidatePageData();
1580     }
1581 
1582     @Override
1583     public void reset() {
1584         // If we have reset, then we should not continue to restore the previous state
1585         mSaveInstanceStateItemIndex = -1;
1586 
1587         AppsCustomizeTabHost tabHost = getTabHost();
1588         String tag = tabHost.getCurrentTabTag();
1589         if (tag != null) {
1590             if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1591                 tabHost.setCurrentTabFromContent(ContentType.Applications);
1592             }
1593         }
1594 
1595         if (mCurrentPage != 0) {
1596             invalidatePageData(0);
1597         }
1598     }
1599 
1600     private AppsCustomizeTabHost getTabHost() {
1601         return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1602     }
1603 
1604     @Override
1605     public void dumpState() {
1606         // TODO: Dump information related to current list of Applications, Widgets, etc.
1607         ApplicationInfo.dumpApplicationInfoList(LOG_TAG, &quot;mApps&quot;, mApps);
1608         dumpAppWidgetProviderInfoList(LOG_TAG, &quot;mWidgets&quot;, mWidgets);
1609     }
1610 
1611     private void dumpAppWidgetProviderInfoList(String tag, String label,
1612             ArrayList&lt;Object&gt; list) {
1613         Log.d(tag, label + &quot; size=&quot; + list.size());
1614         for (Object i: list) {
1615             if (i instanceof AppWidgetProviderInfo) {
1616                 AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1617                 Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1618                         + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1619                         + &quot; initialLayout=&quot; + info.initialLayout
1620                         + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1621             } else if (i instanceof ResolveInfo) {
1622                 ResolveInfo info = (ResolveInfo) i;
1623                 Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1624                         + info.icon);
1625             }
1626         }
1627     }
1628 
1629     @Override
1630     public void surrender() {
1631         // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1632         // should stop this now.
1633 
1634         // Stop all background tasks
1635         cancelAllTasks();
1636     }
1637 
1638     @Override
1639     public void iconPressed(PagedViewIcon icon) {
1640         // Reset the previously pressed icon and store a reference to the pressed icon so that
1641         // we can reset it on return to Launcher (in Launcher.onResume())
1642         if (mPressedIcon != null) {
1643             mPressedIcon.resetDrawableState();
1644         }
1645         mPressedIcon = icon;
1646     }
1647 
1648     public void resetDrawableState() {
1649         if (mPressedIcon != null) {
1650             mPressedIcon.resetDrawableState();
1651             mPressedIcon = null;
1652         }
1653     }
1654 
1655     /*
1656      * We load an extra page on each side to prevent flashes from scrolling and loading of the
1657      * widget previews in the background with the AsyncTasks.
1658      */
1659     final static int sLookBehindPageCount = 2;
1660 
1661     final static int sLookAheadPageCount = 2;
1662 
1663     protected int getAssociatedLowerPageBound(int page) {
1664         final int count = getChildCount();
1665         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1666         int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1667         return windowMinIndex;
1668     }
1669 
1670     protected int getAssociatedUpperPageBound(int page) {
1671         final int count = getChildCount();
1672         int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1673         int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1674                 count - 1);
1675         return windowMaxIndex;
1676     }
1677 
1678     @Override
1679     protected String getCurrentPageDescription() {
1680         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1681         int stringId = R.string.default_scroll_format;
1682         int count = 0;
1683 
1684         if (page &lt; mNumAppsPages) {
1685             stringId = R.string.apps_customize_apps_scroll_format;
1686             count = mNumAppsPages;
1687         } else {
1688             page -= mNumAppsPages;
1689             stringId = R.string.apps_customize_widgets_scroll_format;
1690             count = mNumWidgetPages;
1691         }
1692 
1693         return String.format(mContext.getString(stringId), page + 1, count);
1694     }
1695 }
1696 
1697 /**
1698  * A simple callback interface which also provides the results of the task.
1699  */
1700 interface AsyncTaskCallback {
1701     public abstract void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
1702 }
1703 
1704 /**
1705  * The data needed to perform either of the custom AsyncTasks.
1706  */
1707 class AsyncTaskPageData {
1708     enum Type {
1709 
1710         LoadWidgetPreviewData;}
1711 
<abbr title="1712     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR, AsyncTaskCallback postR) {">1712     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR, AsyncTaskC</abbr>
1713         page = p;
1714         items = l;
1715         sourceImages = si;
1716         generatedImages = new ArrayList&lt;Bitmap&gt;();
1717         maxImageWidth = maxImageHeight = -1;
1718         doInBackgroundCallback = bgR;
1719         postExecuteCallback = postR;
1720     }
1721 
<abbr title="1722     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR, AsyncTaskCallback postR) {">1722     AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR, AsyncTaskCallbac</abbr>
1723         page = p;
1724         items = l;
1725         generatedImages = new ArrayList&lt;Bitmap&gt;();
1726         maxImageWidth = cw;
1727         maxImageHeight = ch;
1728         doInBackgroundCallback = bgR;
1729         postExecuteCallback = postR;
1730     }
1731 
1732     void cleanup(boolean cancelled) {
1733         // Clean up any references to source/generated bitmaps
1734         if (sourceImages != null) {
1735             if (cancelled) {
1736                 for (Bitmap b : sourceImages) {
1737                     b.recycle();
1738                 }
1739             }
1740             sourceImages.clear();
1741         }
1742         if (generatedImages != null) {
1743             if (cancelled) {
1744                 for (Bitmap b : generatedImages) {
1745                     b.recycle();
1746                 }
1747             }
1748             generatedImages.clear();
1749         }
1750     }
1751 
1752     int page;
1753 
1754     ArrayList&lt;Object&gt; items;
1755 
1756     ArrayList&lt;Bitmap&gt; sourceImages;
1757 
1758     ArrayList&lt;Bitmap&gt; generatedImages;
1759 
1760     int maxImageWidth;
1761 
1762     int maxImageHeight;
1763 
1764     AsyncTaskCallback doInBackgroundCallback;
1765 
1766     AsyncTaskCallback postExecuteCallback;
1767 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2011 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.AnimatorSet;
  20  import android.animation.ObjectAnimator;
  21  import android.animation.ValueAnimator;
  22  import android.appwidget.AppWidgetHostView;
  23  import android.appwidget.AppWidgetManager;
  24  import android.appwidget.AppWidgetProviderInfo;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.PackageManager;
  29  import android.content.pm.ResolveInfo;
  30  import android.content.res.Configuration;
  31  import android.content.res.Resources;
  32  import android.content.res.TypedArray;
  33  import android.graphics.Bitmap;
  34  import android.graphics.Bitmap.Config;
  35  import android.graphics.Canvas;
  36  import android.graphics.MaskFilter;
  37  import android.graphics.Matrix;
  38  import android.graphics.Paint;
  39  import android.graphics.Rect;
  40  import android.graphics.RectF;
  41  import android.graphics.TableMaskFilter;
  42  import android.graphics.drawable.Drawable;
  43  import android.os.AsyncTask;
  44  import android.os.Process;
  45  import android.util.AttributeSet;
  46  import android.util.Log;
  47  import android.view.Gravity;
  48  import android.view.KeyEvent;
  49  import android.view.LayoutInflater;
  50  import android.view.MotionEvent;
  51  import android.view.View;
  52  import android.view.ViewConfiguration;
  53  import android.view.ViewGroup;
  54  import android.view.animation.AccelerateInterpolator;
  55  import android.view.animation.DecelerateInterpolator;
  56  import android.widget.GridLayout;
  57  import android.widget.ImageView;
  58  import android.widget.Toast;
  59  
  60  import com.android.launcher.R;
  61  import com.android.launcher2.DropTarget.DragObject;
  62  
  63  import java.util.ArrayList;
  64  import java.util.Collections;
  65  import java.util.Iterator;
  66  import java.util.List;
  67  
  68  /**
  69   * A simple callback interface which also provides the results of the task.
  70   */
  71  interface AsyncTaskCallback {
  72      void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  73  }
  74  
  75  /**
  76   * The data needed to perform either of the custom AsyncTasks.
  77   */
  78  class AsyncTaskPageData {
  79      enum Type {
  80          LoadWidgetPreviewData
  81      }
  82  
  83      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  84              AsyncTaskCallback postR) {
  85          page = p;
  86          items = l;
  87          sourceImages = si;
  88          generatedImages = new ArrayList&lt;Bitmap&gt;();
  89          maxImageWidth = maxImageHeight = -1;
  90          doInBackgroundCallback = bgR;
  91          postExecuteCallback = postR;
  92      }
  93      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
  94              AsyncTaskCallback postR) {
  95          page = p;
  96          items = l;
  97          generatedImages = new ArrayList&lt;Bitmap&gt;();
  98          maxImageWidth = cw;
  99          maxImageHeight = ch;
 100          doInBackgroundCallback = bgR;
 101          postExecuteCallback = postR;
 102      }
 103      void cleanup(boolean cancelled) {
 104          // Clean up any references to source/generated bitmaps
 105          if (sourceImages != null) {
 106              if (cancelled) {
 107                  for (Bitmap b : sourceImages) {
 108                      b.recycle();
 109                  }
 110              }
 111              sourceImages.clear();
 112          }
 113          if (generatedImages != null) {
 114              if (cancelled) {
 115                  for (Bitmap b : generatedImages) {
 116                      b.recycle();
 117                  }
 118              }
 119              generatedImages.clear();
 120          }
 121      }
 122      int page;
 123      ArrayList&lt;Object&gt; items;
 124      ArrayList&lt;Bitmap&gt; sourceImages;
 125      ArrayList&lt;Bitmap&gt; generatedImages;
 126      int maxImageWidth;
 127      int maxImageHeight;
 128      AsyncTaskCallback doInBackgroundCallback;
 129      AsyncTaskCallback postExecuteCallback;
 130  }
 131  
 132  /**
 133   * A generic template for an async task used in AppsCustomize.
 134   */
 135  class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 136      AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 137          page = p;
 138          threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 139          dataType = ty;
 140      }
 141      @Override
 142      protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 143          if (params.length != 1) return null;
 144          // Load each of the widget previews in the background
 145          params[0].doInBackgroundCallback.run(this, params[0]);
 146          return params[0];
 147      }
 148      @Override
 149      protected void onPostExecute(AsyncTaskPageData result) {
 150          // All the widget previews are loaded, so we can just callback to inflate the page
 151          result.postExecuteCallback.run(this, result);
 152      }
 153  
 154      void setThreadPriority(int p) {
 155          threadPriority = p;
 156      }
 157      void syncThreadPriority() {
 158          Process.setThreadPriority(threadPriority);
 159      }
 160  
 161      // The page that this async task is associated with
 162      AsyncTaskPageData.Type dataType;
 163      int page;
 164      int threadPriority;
 165  }
 166  
 167  /**
 168   * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 169   */
 170  public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 171          AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,
 172          PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 173          LauncherTransitionable {
 174      static final String LOG_TAG = &quot;AppsCustomizePagedView&quot;;
 175  
 176      /**
 177       * The different content types that this paged view can show.
 178       */
 179      public enum ContentType {
 180          Applications,
 181          Widgets
 182      }
 183  
 184      // Refs
 185      private Launcher mLauncher;
 186      private DragController mDragController;
 187      private final LayoutInflater mLayoutInflater;
 188      private final PackageManager mPackageManager;
 189  
 190      // Save and Restore
 191      private int mSaveInstanceStateItemIndex = -1;
 192      private PagedViewIcon mPressedIcon;
 193  
 194      // Content
 195      private ArrayList&lt;ApplicationInfo&gt; mApps;
 196      private ArrayList&lt;Object&gt; mWidgets;
 197  
 198      // Cling
 199      private boolean mHasShownAllAppsCling;
 200      private int mClingFocusedX;
 201      private int mClingFocusedY;
 202  
 203      // Caching
 204      private Canvas mCanvas;
 205      private Drawable mDefaultWidgetBackground;
 206      private IconCache mIconCache;
 207  
 208      // Dimens
 209      private int mContentWidth;
 210      private int mAppIconSize;
 211      private int mMaxAppCellCountX, mMaxAppCellCountY;
 212      private int mWidgetCountX, mWidgetCountY;
 213      private int mWidgetWidthGap, mWidgetHeightGap;
 214      private final int mWidgetPreviewIconPaddedDimension;
 215      private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 216      private PagedViewCellLayout mWidgetSpacingLayout;
 217      private int mNumAppsPages;
 218      private int mNumWidgetPages;
 219  
 220      // Relating to the scroll and overscroll effects
 221      Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 222      private static float CAMERA_DISTANCE = 6500;
 223      private static float TRANSITION_SCALE_FACTOR = 0.74f;
 224      private static float TRANSITION_PIVOT = 0.65f;
 225      private static float TRANSITION_MAX_ROTATION = 22;
 226      private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 227      private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 228      private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 229  
 230      // Previews &amp; outlines
 231      ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 232      private static final int sPageSleepDelay = 200;
 233  
 234      private Runnable mInflateWidgetRunnable = null;
 235      private Runnable mBindWidgetRunnable = null;
 236      static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 237      static final int WIDGET_BOUND = 0;
 238      static final int WIDGET_INFLATED = 1;
 239      int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 240      int mWidgetLoadingId = -1;
 241      PendingAddWidgetInfo mCreateWidgetInfo = null;
 242      private boolean mDraggingWidget = false;
 243  
 244      // Deferral of loading widget previews during launcher transitions
 245      private boolean mInTransition;
 246      private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 247          new ArrayList&lt;AsyncTaskPageData&gt;();
 248  
 249      public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 250          super(context, attrs);
 251          mLayoutInflater = LayoutInflater.from(context);
 252          mPackageManager = context.getPackageManager();
 253          mApps = new ArrayList&lt;ApplicationInfo&gt;();
 254          mWidgets = new ArrayList&lt;Object&gt;();
 255          mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 256          mCanvas = new Canvas();
 257          mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 258  
 259          // Save the default widget preview background
 260          Resources resources = context.getResources();
 261          mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 262          mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 263  
 264          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 265          mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 266          mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 267          mWidgetWidthGap =
 268              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 269          mWidgetHeightGap =
 270              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 271          mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 272          mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 273          mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 274          mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 275          a.recycle();
 276          mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 277  
 278          // The padding on the non-matched dimension for the default widget preview icons
 279          // (top + bottom)
 280          mWidgetPreviewIconPaddedDimension =
 281              (int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPercentage)));
 282          mFadeInAdjacentScreens = false;
 283      }
 284  
 285      @Override
 286      protected void init() {
 287          super.init();
 288          mCenterPagesVertically = false;
 289  
 290          Context context = getContext();
 291          Resources r = context.getResources();
 292          setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 293      }
 294  
 295      @Override
 296      protected void onUnhandledTap(MotionEvent ev) {
 297          if (LauncherApplication.isScreenLarge()) {
 298              // Dismiss AppsCustomize if we tap
 299              mLauncher.showWorkspace(true);
 300          }
 301      }
 302  
 303      /** Returns the item index of the center item on this page so that we can restore to this
 304       *  item index when we rotate. */
 305      private int getMiddleComponentIndexOnCurrentPage() {
 306          int i = -1;
 307          if (getPageCount() &gt; 0) {
 308              int currentPage = getCurrentPage();
 309              if (currentPage &lt; mNumAppsPages) {
 310                  PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 311                  PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 312                  int numItemsPerPage = mCellCountX * mCellCountY;
 313                  int childCount = childrenLayout.getChildCount();
 314                  if (childCount &gt; 0) {
 315                      i = (currentPage * numItemsPerPage) + (childCount / 2);
 316                  }
 317              } else {
 318                  int numApps = mApps.size();
 319                  PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 320                  int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 321                  int childCount = layout.getChildCount();
 322                  if (childCount &gt; 0) {
 323                      i = numApps +
 324                          ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 325                  }
 326              }
 327          }
 328          return i;
 329      }
 330  
 331      /** Get the index of the item to restore to if we need to restore the current page. */
 332      int getSaveInstanceStateIndex() {
 333          if (mSaveInstanceStateItemIndex == -1) {
 334              mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 335          }
 336          return mSaveInstanceStateItemIndex;
 337      }
 338  
 339      /** Returns the page in the current orientation which is expected to contain the specified
 340       *  item index. */
 341      int getPageForComponent(int index) {
 342          if (index &lt; 0) return 0;
 343  
 344          if (index &lt; mApps.size()) {
 345              int numItemsPerPage = mCellCountX * mCellCountY;
 346              return (index / numItemsPerPage);
 347          } else {
 348              int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 349              return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 350          }
 351      }
 352  
 353      /**
 354       * This differs from isDataReady as this is the test done if isDataReady is not set.
 355       */
 356      private boolean testDataReady() {
 357          // We only do this test once, and we default to the Applications page, so we only really
 358          // have to wait for there to be apps.
 359          // TODO: What if one of them is validly empty
 360          return !mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty();
 361      }
 362  
 363      /** Restores the page for an item at the specified index */
 364      void restorePageForIndex(int index) {
 365          if (index &lt; 0) return;
 366          mSaveInstanceStateItemIndex = index;
 367      }
 368  
 369      private void updatePageCounts() {
 370          mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 371                  (float) (mWidgetCountX * mWidgetCountY));
 372          mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 373      }
 374  
 375      protected void onDataReady(int width, int height) {
 376          // Note that we transpose the counts in portrait so that we get a similar layout
 377          boolean isLandscape = getResources().getConfiguration().orientation ==
 378              Configuration.ORIENTATION_LANDSCAPE;
 379          int maxCellCountX = Integer.MAX_VALUE;
 380          int maxCellCountY = Integer.MAX_VALUE;
 381          if (LauncherApplication.isScreenLarge()) {
 382              maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 383                  LauncherModel.getCellCountY());
 384              maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 385                  LauncherModel.getCellCountX());
 386          }
 387          if (mMaxAppCellCountX &gt; -1) {
 388              maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 389          }
 390          if (mMaxAppCellCountY &gt; -1) {
 391              maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 392          }
 393  
 394          // Now that the data is ready, we can calculate the content width, the number of cells to
 395          // use for each page
 396          mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 397          mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 398                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 399          mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 400          mCellCountX = mWidgetSpacingLayout.getCellCountX();
 401          mCellCountY = mWidgetSpacingLayout.getCellCountY();
 402          updatePageCounts();
 403  
 404          // Force a measure to update recalculate the gaps
 405          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 406          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 407          mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 408          mContentWidth = mWidgetSpacingLayout.getContentWidth();
 409  
 410          AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 411          final boolean hostIsTransitioning = host.isTransitioning();
 412  
 413          // Restore the page
 414          int page = getPageForComponent(mSaveInstanceStateItemIndex);
 415          invalidatePageData(Math.max(0, page), hostIsTransitioning);
 416  
 417          // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 418          // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 419          // returned while animating)
 420          if (!hostIsTransitioning) {
 421              post(new Runnable() {
 422                  @Override
 423                  public void run() {
 424                      showAllAppsCling();
 425                  }
 426              });
 427          }
 428      }
 429  
 430      void showAllAppsCling() {
 431          if (!mHasShownAllAppsCling &amp;&amp; isDataReady() &amp;&amp; testDataReady()) {
 432              mHasShownAllAppsCling = true;
 433              // Calculate the position for the cling punch through
 434              int[] offset = new int[2];
 435              int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 436              mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 437              // PagedViews are centered horizontally but top aligned
 438              pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 439                      offset[0];
 440              pos[1] += offset[1];
 441              mLauncher.showFirstRunAllAppsCling(pos);
 442          }
 443      }
 444  
 445      @Override
 446      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 447          int width = MeasureSpec.getSize(widthMeasureSpec);
 448          int height = MeasureSpec.getSize(heightMeasureSpec);
 449          if (!isDataReady()) {
 450              if (testDataReady()) {
 451                  setDataIsReady();
 452                  setMeasuredDimension(width, height);
 453                  onDataReady(width, height);
 454              }
 455          }
 456  
 457          super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 458      }
 459  
 460      public void onPackagesUpdated() {
 461          // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered
 462          // by a broadcast receiver, and in order for it to work correctly, we need to know that
 463          // the AppWidgetService has already received and processed the same broadcast. Since there
 464          // is no guarantee about ordering of broadcast receipt, we just delay here. Ideally,
 465          // we should have a more precise way of ensuring the AppWidgetService is up to date.
 466          postDelayed(new Runnable() {
 467             public void run() {
 468                 updatePackages();
 469             }
 470          }, 500);
 471      }
 472  
 473      public void updatePackages() {
 474          // Get the list of widgets and shortcuts
 475          boolean wasEmpty = mWidgets.isEmpty();
 476          mWidgets.clear();
 477          List&lt;AppWidgetProviderInfo&gt; widgets =
 478              AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 479          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 480          List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 481          for (AppWidgetProviderInfo widget : widgets) {
 482              if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -                mWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 484 +                // Ensure that all widgets we show can be added on a workspace of this size</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 485 +                int[] spanXY = mLauncher.getSpanForWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 486 +                int[] minSpanXY = mLauncher.getMinSpanForWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 487 +                int minSpanX = Math.min(spanXY[0], minSpanXY[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 488 +                int minSpanY = Math.min(spanXY[1], minSpanXY[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 489 +                if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 490 +                        minSpanY &lt;= LauncherModel.getCellCountY()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +                    mWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 492 +                }</span>
 493              } else {
 494                  Log.e(LOG_TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 495                          widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 496              }
 497          }
 498          mWidgets.addAll(shortcuts);
 499          Collections.sort(mWidgets,
 500                  new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 501          updatePageCounts();
 502  
 503          if (wasEmpty) {
 504              // The next layout pass will trigger data-ready if both widgets and apps are set, so request
 505              // a layout to do this test and invalidate the page data when ready.
 506              if (testDataReady()) requestLayout();
 507          } else {
 508              cancelAllTasks();
 509              invalidatePageData();
 510          }
 511      }
 512  
 513      @Override
 514      public void onClick(View v) {
 515          // When we have exited all apps or are in transition, disregard clicks
 516          if (!mLauncher.isAllAppsCustomizeOpen() ||
 517                  mLauncher.getWorkspace().isSwitchingState()) return;
 518  
 519          if (v instanceof PagedViewIcon) {
 520              // Animate some feedback to the click
 521              final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 522              mLauncher.startActivitySafely(appInfo.intent, appInfo);
 523  
 524              // Lock the drawable state to pressed until we return to Launcher
 525              if (mPressedIcon != null) {
 526                  mPressedIcon.lockDrawableState();
 527              }
 528          } else if (v instanceof PagedViewWidget) {
 529              // Let the user know that they have to long press to add a widget
 530              Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 531                      Toast.LENGTH_SHORT).show();
 532  
 533              // Create a little animation to show that the widget can move
 534              float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 535              final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 536              AnimatorSet bounce = new AnimatorSet();
 537              ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);
 538              tyuAnim.setDuration(125);
 539              ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);
 540              tydAnim.setDuration(100);
 541              bounce.play(tyuAnim).before(tydAnim);
 542              bounce.setInterpolator(new AccelerateInterpolator());
 543              bounce.start();
 544          }
 545      }
 546  
 547      public boolean onKey(View v, int keyCode, KeyEvent event) {
 548          return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 549      }
 550  
 551      /*
 552       * PagedViewWithDraggableItems implementation
 553       */
 554      @Override
 555      protected void determineDraggingStart(android.view.MotionEvent ev) {
 556          // Disable dragging by pulling an app down for now.
 557      }
 558  
 559      private void beginDraggingApplication(View v) {
 560          mLauncher.getWorkspace().onDragStartedWithItem(v);
 561          mLauncher.getWorkspace().beginDragShared(v, this);
 562      }
 563  
 564      private void loadWidgetInBackground(final PendingAddWidgetInfo info) {
 565          final AppWidgetProviderInfo pInfo = info.info;
 566          if (pInfo.configure != null) {
 567              return;
 568          }
 569  
 570          mBindWidgetRunnable = new Runnable() {
 571              @Override
 572              public void run() {
 573                  mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 574                  AppWidgetManager.getInstance(mLauncher).bindAppWidgetId(mWidgetLoadingId,
 575                          info.componentName);
 576                  mWidgetCleanupState = WIDGET_BOUND;
 577              }
 578          };
 579          post(mBindWidgetRunnable);
 580  
 581          mInflateWidgetRunnable = new Runnable() {
 582              @Override
 583              public void run() {
 584                  AppWidgetHostView hostView =
 585                          mLauncher.getAppWidgetHost().createView(mContext, mWidgetLoadingId, pInfo);
 586                  info.boundWidget = hostView;
 587                  mWidgetCleanupState = WIDGET_INFLATED;
 588                  hostView.setVisibility(INVISIBLE);
 589                  int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 590                          info.spanY, info, false);
 591  
 592                  // We want the first widget layout to be the correct size. This will be important
 593                  // for width size reporting to the AppWidgetManager.
 594                  DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 595                          unScaledSize[1]);
 596                  lp.x = lp.y = 0;
 597                  lp.customPosition = true;
 598                  hostView.setLayoutParams(lp);
 599                  mLauncher.getDragLayer().addView(hostView);
 600              }
 601          };
 602          post(mInflateWidgetRunnable);
 603      }
 604  
 605      @Override
 606      public void onShortPress(View v) {
 607          // We are anticipating a long press, and we use this time to load bind and instantiate
 608          // the widget. This will need to be cleaned up if it turns out no long press occurs.
 609          mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 610          loadWidgetInBackground(mCreateWidgetInfo);
 611      }
 612  
 613      private void cleanupWidgetPreloading() {
 614          PendingAddWidgetInfo info = mCreateWidgetInfo;
 615          mCreateWidgetInfo = null;
 616          if (mWidgetCleanupState &gt;= 0 &amp;&amp; mWidgetLoadingId != -1) {
 617              mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 618          }
 619          if (mWidgetCleanupState == WIDGET_BOUND) {
 620              removeCallbacks(mInflateWidgetRunnable);
 621          } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 622              AppWidgetHostView widget = info.boundWidget;
 623              int widgetId = widget.getAppWidgetId();
 624              mLauncher.getAppWidgetHost().deleteAppWidgetId(widgetId);
 625              mLauncher.getDragLayer().removeView(widget);
 626          }
 627          mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 628          mWidgetLoadingId = -1;
 629      }
 630  
 631      @Override
 632      public void cleanUpShortPress(View v) {
 633          if (!mDraggingWidget) {
 634              cleanupWidgetPreloading();
 635          }
 636      }
 637  
 638      private void beginDraggingWidget(View v) {
 639          mDraggingWidget = true;
 640          // Get the widget preview as the drag representation
 641          ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 642          PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 643  
 644          // Compose the drag image
 645          Bitmap preview;
 646          Bitmap outline;
 647          float scale = 1f;
 648          if (createItemInfo instanceof PendingAddWidgetInfo) {
 649              PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 650              createItemInfo = createWidgetInfo;
 651              int spanX = createItemInfo.spanX;
 652              int spanY = createItemInfo.spanY;
 653              int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 654                      createWidgetInfo, true);
 655  
 656              FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 657              float minScale = 1.25f;
 658              int minWidth, minHeight;
 659              minWidth = Math.max((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 660              minHeight = Math.max((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 661              preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 662                      createWidgetInfo.icon, spanX, spanY, minWidth, minHeight);
 663  
 664              // Determine the image view drawable scale relative to the preview
 665              float[] mv = new float[9];
 666              Matrix m = new Matrix();
 667              m.setRectToRect(
 668                      new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 669                      new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 670                              (float) previewDrawable.getIntrinsicHeight()),
 671                      Matrix.ScaleToFit.START);
 672              m.getValues(mv);
 673              scale = (float) mv[0];
 674          } else {
 675              // Workaround for the fact that we don&#x27;t keep the original ResolveInfo associated with
 676              // the shortcut around.  To get the icon, we just render the preview image (which has
 677              // the shortcut icon) to a new drag bitmap that clips the non-icon space.
 678              preview = Bitmap.createBitmap(mWidgetPreviewIconPaddedDimension,
 679                      mWidgetPreviewIconPaddedDimension, Bitmap.Config.ARGB_8888);
 680              Drawable d = image.getDrawable();
 681              mCanvas.setBitmap(preview);
 682              d.draw(mCanvas);
 683              mCanvas.setBitmap(null);
 684              createItemInfo.spanX = createItemInfo.spanY = 1;
 685          }
 686  
 687          // We use a custom alpha clip table for the default widget previews
 688          Paint alphaClipPaint = null;
 689          if (createItemInfo instanceof PendingAddWidgetInfo) {
 690              if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 691                  MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 692                  alphaClipPaint = new Paint();
 693                  alphaClipPaint.setMaskFilter(alphaClipTable);
 694              }
 695          }
 696  
 697          // Save the preview for the outline generation, then dim the preview
 698          outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 699                  false);
 700  
 701          // Start the drag
 702          alphaClipPaint = null;
 703          mLauncher.lockScreenOrientationOnLargeUI();
 704          mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);
 705          mDragController.startDrag(image, preview, this, createItemInfo,
 706                  DragController.DRAG_ACTION_COPY, null, scale);
 707          outline.recycle();
 708          preview.recycle();
 709      }
 710  
 711      @Override
 712      protected boolean beginDragging(final View v) {
 713          if (!super.beginDragging(v)) return false;
 714  
 715          if (v instanceof PagedViewIcon) {
 716              beginDraggingApplication(v);
 717          } else if (v instanceof PagedViewWidget) {
 718              beginDraggingWidget(v);
 719          }
 720  
 721          // We delay entering spring-loaded mode slightly to make sure the UI
 722          // thready is free of any work.
 723          postDelayed(new Runnable() {
 724              @Override
 725              public void run() {
 726                  // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 727                  if (mLauncher.getDragController().isDragging()) {
 728                      // Dismiss the cling
 729                      mLauncher.dismissAllAppsCling(null);
 730  
 731                      // Reset the alpha on the dragged icon before we drag
 732                      resetDrawableState();
 733  
 734                      // Go into spring loaded mode (must happen before we startDrag())
 735                      mLauncher.enterSpringLoadedDragMode();
 736                  }
 737              }
 738          }, 150);
 739  
 740          return true;
 741      }
 742  
 743      /**
 744       * Clean up after dragging.
 745       *
 746       * @param target where the item was dragged to (can be null if the item was flung)
 747       */
 748      private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 749          if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 750                  !(target instanceof DeleteDropTarget))) {
 751              // Exit spring loaded mode if we have not successfully dropped or have not handled the
 752              // drop in Workspace
 753              mLauncher.exitSpringLoadedDragMode();
 754          }
 755          mLauncher.unlockScreenOrientationOnLargeUI();
 756      }
 757  
 758      @Override
 759      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 760          mInTransition = true;
 761          if (toWorkspace) {
 762              cancelAllTasks();
 763          }
 764      }
 765  
 766      @Override
 767      public View getContent() {
 768          return null;
 769      }
 770  
 771      @Override
 772      public void onLauncherTransitionStep(Launcher l, float t) {
 773      }
 774  
 775      @Override
 776      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 777          mInTransition = false;
 778          for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 779              onSyncWidgetPageItems(d);
 780          }
 781          mDeferredSyncWidgetPageItems.clear();
 782      }
 783  
 784      @Override
 785      public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 786              boolean success) {
 787          // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 788          if (isFlingToDelete) return;
 789  
 790          endDragging(target, false, success);
 791  
 792          // Display an error message if the drag failed due to there not being enough space on the
 793          // target layout we were dropping on.
 794          if (!success) {
 795              boolean showOutOfSpaceMessage = false;
 796              if (target instanceof Workspace) {
 797                  int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 798                  Workspace workspace = (Workspace) target;
 799                  CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 800                  ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 801                  if (layout != null) {
 802                      layout.calculateSpans(itemInfo);
 803                      showOutOfSpaceMessage =
 804                              !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 805                  }
 806              }
 807              if (showOutOfSpaceMessage) {
 808                  mLauncher.showOutOfSpaceMessage(false);
 809              }
 810  
 811              d.deferDragViewCleanupPostAnimation = false;
 812              cleanupWidgetPreloading();
 813          }
 814          mDraggingWidget = false;
 815      }
 816  
 817      @Override
 818      public void onFlingToDeleteCompleted() {
 819          // We just dismiss the drag when we fling, so cleanup here
 820          endDragging(null, true, true);
 821          cleanupWidgetPreloading();
 822          mDraggingWidget = false;
 823      }
 824  
 825      @Override
 826      public boolean supportsFlingToDelete() {
 827          return true;
 828      }
 829  
 830      @Override
 831      protected void onDetachedFromWindow() {
 832          super.onDetachedFromWindow();
 833          cancelAllTasks();
 834      }
 835  
 836      public void clearAllWidgetPages() {
 837          cancelAllTasks();
 838          int count = getChildCount();
 839          for (int i = 0; i &lt; count; i++) {
 840              View v = getPageAt(i);
 841              if (v instanceof PagedViewGridLayout) {
 842                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 843                  mDirtyPageContent.set(i, true);
 844              }
 845          }
 846      }
 847  
 848      private void cancelAllTasks() {
 849          // Clean up all the async tasks
 850          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 851          while (iter.hasNext()) {
 852              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 853              task.cancel(false);
 854              iter.remove();
 855              mDirtyPageContent.set(task.page, true);
 856          }
 857      }
 858  
 859      public void setContentType(ContentType type) {
 860          if (type == ContentType.Widgets) {
 861              invalidatePageData(mNumAppsPages, true);
 862          } else if (type == ContentType.Applications) {
 863              invalidatePageData(0, true);
 864          }
 865      }
 866  
 867      protected void snapToPage(int whichPage, int delta, int duration) {
 868          super.snapToPage(whichPage, delta, duration);
 869          updateCurrentTab(whichPage);
 870  
 871          // Update the thread priorities given the direction lookahead
 872          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 873          while (iter.hasNext()) {
 874              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 875              int pageIndex = task.page;
 876              if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 877                  (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 878                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 879              } else {
 880                  task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 881              }
 882          }
 883      }
 884  
 885      private void updateCurrentTab(int currentPage) {
 886          AppsCustomizeTabHost tabHost = getTabHost();
 887          if (tabHost != null) {
 888              String tag = tabHost.getCurrentTabTag();
 889              if (tag != null) {
 890                  if (currentPage &gt;= mNumAppsPages &amp;&amp;
 891                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 892                      tabHost.setCurrentTabFromContent(ContentType.Widgets);
 893                  } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 894                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 895                      tabHost.setCurrentTabFromContent(ContentType.Applications);
 896                  }
 897              }
 898          }
 899      }
 900  
 901      /*
 902       * Apps PagedView implementation
 903       */
 904      private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 905          int childCount = layout.getChildCount();
 906          for (int i = 0; i &lt; childCount; ++i) {
 907              layout.getChildAt(i).setVisibility(visibility);
 908          }
 909      }
 910      private void setupPage(PagedViewCellLayout layout) {
 911          layout.setCellCount(mCellCountX, mCellCountY);
 912          layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 913          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 914                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 915  
 916          // Note: We force a measure here to get around the fact that when we do layout calculations
 917          // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 918          // expected page width, so we can actually optimize by hiding all the TextView-based
 919          // children that are expensive to measure, and let that happen naturally later.
 920          setVisibilityOnChildren(layout, View.GONE);
 921          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 922          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 923          layout.setMinimumWidth(getPageContentWidth());
 924          layout.measure(widthSpec, heightSpec);
 925          setVisibilityOnChildren(layout, View.VISIBLE);
 926      }
 927  
 928      public void syncAppsPageItems(int page, boolean immediate) {
 929          // ensure that we have the right number of items on the pages
 930          int numCells = mCellCountX * mCellCountY;
 931          int startIndex = page * numCells;
 932          int endIndex = Math.min(startIndex + numCells, mApps.size());
 933          PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 934  
 935          layout.removeAllViewsOnPage();
 936          ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 937          ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 938          for (int i = startIndex; i &lt; endIndex; ++i) {
 939              ApplicationInfo info = mApps.get(i);
 940              PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 941                      R.layout.apps_customize_application, layout, false);
 942              icon.applyFromApplicationInfo(info, true, this);
 943              icon.setOnClickListener(this);
 944              icon.setOnLongClickListener(this);
 945              icon.setOnTouchListener(this);
 946              icon.setOnKeyListener(this);
 947  
 948              int index = i - startIndex;
 949              int x = index % mCellCountX;
 950              int y = index / mCellCountX;
 951              layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 952  
 953              items.add(info);
 954              images.add(info.iconBitmap);
 955          }
 956  
 957          layout.createHardwareLayers();
 958      }
 959  
 960      /**
 961       * A helper to return the priority for loading of the specified widget page.
 962       */
 963      private int getWidgetPageLoadPriority(int page) {
 964          // If we are snapping to another page, use that index as the target page index
 965          int toPage = mCurrentPage;
 966          if (mNextPage &gt; -1) {
 967              toPage = mNextPage;
 968          }
 969  
 970          // We use the distance from the target page as an initial guess of priority, but if there
 971          // are no pages of higher priority than the page specified, then bump up the priority of
 972          // the specified page.
 973          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 974          int minPageDiff = Integer.MAX_VALUE;
 975          while (iter.hasNext()) {
 976              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 977              minPageDiff = Math.abs(task.page - toPage);
 978          }
 979  
 980          int rawPageDiff = Math.abs(page - toPage);
 981          return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 982      }
 983      /**
 984       * Return the appropriate thread priority for loading for a given page (we give the current
 985       * page much higher priority)
 986       */
 987      private int getThreadPriorityForPage(int page) {
 988          // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
 989          int pageDiff = getWidgetPageLoadPriority(page);
 990          if (pageDiff &lt;= 0) {
 991              return Process.THREAD_PRIORITY_LESS_FAVORABLE;
 992          } else if (pageDiff &lt;= 1) {
 993              return Process.THREAD_PRIORITY_LOWEST;
 994          } else {
 995              return Process.THREAD_PRIORITY_LOWEST;
 996          }
 997      }
 998      private int getSleepForPage(int page) {
 999          int pageDiff = getWidgetPageLoadPriority(page);
1000          return Math.max(0, pageDiff * sPageSleepDelay);
1001      }
1002      /**
1003       * Creates and executes a new AsyncTask to load a page of widget previews.
1004       */
1005      private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1006              int cellWidth, int cellHeight, int cellCountX) {
1007  
1008          // Prune all tasks that are no longer needed
1009          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1010          while (iter.hasNext()) {
1011              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1012              int taskPage = task.page;
1013              if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1014                      taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1015                  task.cancel(false);
1016                  iter.remove();
1017              } else {
1018                  task.setThreadPriority(getThreadPriorityForPage(taskPage));
1019              }
1020          }
1021  
1022          // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1023          final int sleepMs = getSleepForPage(page);
1024          AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1025              new AsyncTaskCallback() {
1026                  @Override
1027                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1028                      try {
1029                          try {
1030                              Thread.sleep(sleepMs);
1031                          } catch (Exception e) {}
1032                          loadWidgetPreviewsInBackground(task, data);
1033                      } finally {
1034                          if (task.isCancelled()) {
1035                              data.cleanup(true);
1036                          }
1037                      }
1038                  }
1039              },
1040              new AsyncTaskCallback() {
1041                  @Override
1042                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1043                      mRunningTasks.remove(task);
1044                      if (task.isCancelled()) return;
1045                      // do cleanup inside onSyncWidgetPageItems
1046                      onSyncWidgetPageItems(data);
1047                  }
1048              });
1049  
1050          // Ensure that the task is appropriately prioritized and runs in parallel
1051          AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1052                  AsyncTaskPageData.Type.LoadWidgetPreviewData);
1053          t.setThreadPriority(getThreadPriorityForPage(page));
1054          t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1055          mRunningTasks.add(t);
1056      }
1057  
1058      /*
1059       * Widgets PagedView implementation
1060       */
1061      private void setupPage(PagedViewGridLayout layout) {
1062          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1063                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1064  
1065          // Note: We force a measure here to get around the fact that when we do layout calculations
1066          // immediately after syncing, we don&#x27;t have a proper width.
1067          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1068          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1069          layout.setMinimumWidth(getPageContentWidth());
1070          layout.measure(widthSpec, heightSpec);
1071      }
1072  
1073      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1074          renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f, 0xFFFFFFFF);
1075      }
1076  
1077      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1078              float scale, int multiplyColor) {
1079          if (bitmap != null) {
1080              Canvas c = new Canvas(bitmap);
1081              c.scale(scale, scale);
1082              Rect oldBounds = d.copyBounds();
1083              d.setBounds(x, y, x + w, y + h);
1084              d.draw(c);
1085              d.setBounds(oldBounds); // Restore the bounds
1086              c.setBitmap(null);
1087          }
1088      }
1089      private Bitmap getShortcutPreview(ResolveInfo info) {
1090          // Render the background
1091          int offset = 0;
1092          int bitmapSize = mAppIconSize;
1093          Bitmap preview = Bitmap.createBitmap(bitmapSize, bitmapSize, Config.ARGB_8888);
1094  
1095          // Render the icon
1096          Drawable icon = mIconCache.getFullResIcon(info);
1097          renderDrawableToBitmap(icon, preview, offset, offset, mAppIconSize, mAppIconSize);
1098          return preview;
1099      }
1100  
1101      private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId,
1102              int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {
1103          // Load the preview image if possible
1104          String packageName = provider.getPackageName();
1105          if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1106          if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1107  
1108          Drawable drawable = null;
1109          if (previewImage != 0) {
1110              drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1111              if (drawable == null) {
1112                  Log.w(LOG_TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1113                          Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1114              }
1115          }
1116  
1117          int bitmapWidth;
1118          int bitmapHeight;
1119          boolean widgetPreviewExists = (drawable != null);
1120          if (widgetPreviewExists) {
1121              bitmapWidth = drawable.getIntrinsicWidth();
1122              bitmapHeight = drawable.getIntrinsicHeight();
1123          } else {
1124              if (cellHSpan &lt; 1) cellHSpan = 1;
1125              if (cellVSpan &lt; 1) cellVSpan = 1;
1126              // Determine the size of the bitmap for the preview image we will generate
1127              // TODO: This actually uses the apps customize cell layout params, where as we make want
1128              // the Workspace params for more accuracy.
1129              bitmapWidth = mWidgetSpacingLayout.estimateCellWidth(cellHSpan);
1130              bitmapHeight = mWidgetSpacingLayout.estimateCellHeight(cellVSpan);
1131              if (cellHSpan == cellVSpan) {
1132                  // For square widgets, we just have a fixed size for 1x1 and larger-than-1x1
1133                  int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1134                  if (cellHSpan &lt;= 1) {
1135                      bitmapWidth = bitmapHeight = mAppIconSize + 2 * minOffset;
1136                  } else {
1137                      bitmapWidth = bitmapHeight = mAppIconSize + 4 * minOffset;
1138                  }
1139              }
1140          }
1141  
1142          float scale = 1f;
1143          if (bitmapWidth &gt; maxWidth) {
1144              scale = maxWidth / (float) bitmapWidth;
1145          }
1146          if (bitmapHeight * scale &gt; maxHeight) {
1147              scale = maxHeight / (float) bitmapHeight;
1148          }
1149          if (scale != 1f) {
1150              bitmapWidth = (int) (scale * bitmapWidth);
1151              bitmapHeight = (int) (scale * bitmapHeight);
1152          }
1153  
1154          Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1155  
1156          if (widgetPreviewExists) {
1157              renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1158          } else {
1159              // Generate a preview image if we couldn&#x27;t load one
1160              int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1161              int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1162              float iconScale = Math.min((float) smallestSide / (mAppIconSize + 2 * minOffset), 1f);
1163              if (cellHSpan != 1 || cellVSpan != 1) {
1164                  renderDrawableToBitmap(mDefaultWidgetBackground, preview, 0, 0, bitmapWidth,
1165                          bitmapHeight);
1166              }
1167  
1168              // Draw the icon in the top left corner
1169              try {
1170                  Drawable icon = null;
1171                  int hoffset = (int) (bitmapWidth / 2 - mAppIconSize * iconScale / 2);
1172                  int yoffset = (int) (bitmapHeight / 2 - mAppIconSize * iconScale / 2);
1173                  if (iconId &gt; 0) icon = mIconCache.getFullResIcon(packageName, iconId);
1174                  Resources resources = mLauncher.getResources();
1175                  if (icon == null) icon = resources.getDrawable(R.drawable.ic_launcher_application);
1176  
1177                  renderDrawableToBitmap(icon, preview, hoffset, yoffset,
1178                          (int) (mAppIconSize * iconScale),
1179                          (int) (mAppIconSize * iconScale));
1180              } catch (Resources.NotFoundException e) {}
1181          }
1182          return preview;
1183      }
1184  
1185      public void syncWidgetPageItems(final int page, final boolean immediate) {
1186          int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1187  
1188          // Calculate the dimensions of each cell we are giving to each widget
1189          final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1190          int contentWidth = mWidgetSpacingLayout.getContentWidth();
1191          final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1192                  - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1193          int contentHeight = mWidgetSpacingLayout.getContentHeight();
1194          final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1195                  - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1196  
1197          // Prepare the set of widgets to load previews for in the background
1198          int offset = (page - mNumAppsPages) * numItemsPerPage;
1199          for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1200              items.add(mWidgets.get(i));
1201          }
1202  
1203          // Prepopulate the pages with the other widget info, and fill in the previews later
1204          final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1205          layout.setColumnCount(layout.getCellCountX());
1206          for (int i = 0; i &lt; items.size(); ++i) {
1207              Object rawInfo = items.get(i);
1208              PendingAddItemInfo createItemInfo = null;
1209              PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1210                      R.layout.apps_customize_widget, layout, false);
1211              if (rawInfo instanceof AppWidgetProviderInfo) {
1212                  // Fill in the widget information
1213                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1214                  createItemInfo = new PendingAddWidgetInfo(info, null, null);
1215  
1216                  // Determine the widget spans and min resize spans.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1217 -                int[] spanXY = mLauncher.getSpanForWidget(info, null);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1218 -                int[] size = mLauncher.getWorkspace().estimateItemSize(spanXY[0],</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1219 -                        spanXY[1], createItemInfo, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +                int[] spanXY = mLauncher.getSpanForWidget(info);</span>
1221                  createItemInfo.spanX = spanXY[0];
1222                  createItemInfo.spanY = spanXY[1];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1223 -                int[] minSpanXY = mLauncher.getMinSpanForWidget(info, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1224 +                int[] minSpanXY = mLauncher.getMinSpanForWidget(info);</span>
1225                  createItemInfo.minSpanX = minSpanXY[0];
1226                  createItemInfo.minSpanY = minSpanXY[1];
1227  
1228                  widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1229                  widget.setTag(createItemInfo);
1230                  widget.setShortPressListener(this);
1231              } else if (rawInfo instanceof ResolveInfo) {
1232                  // Fill in the shortcuts information
1233                  ResolveInfo info = (ResolveInfo) rawInfo;
1234                  createItemInfo = new PendingAddItemInfo();
1235                  createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1236                  createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1237                          info.activityInfo.name);
1238                  widget.applyFromResolveInfo(mPackageManager, info);
1239                  widget.setTag(createItemInfo);
1240              }
1241              widget.setOnClickListener(this);
1242              widget.setOnLongClickListener(this);
1243              widget.setOnTouchListener(this);
1244              widget.setOnKeyListener(this);
1245  
1246              // Layout each widget
1247              int ix = i % mWidgetCountX;
1248              int iy = i / mWidgetCountX;
1249              GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1250                      GridLayout.spec(iy, GridLayout.LEFT),
1251                      GridLayout.spec(ix, GridLayout.TOP));
1252              lp.width = cellWidth;
1253              lp.height = cellHeight;
1254              lp.setGravity(Gravity.TOP | Gravity.LEFT);
1255              if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1256              if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1257              layout.addView(widget, lp);
1258          }
1259  
1260          // wait until a call on onLayout to start loading, because
1261          // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1262          // TODO: can we do a measure/layout immediately?
1263          layout.setOnLayoutListener(new Runnable() {
1264              public void run() {
1265                  // Load the widget previews
1266                  int maxPreviewWidth = cellWidth;
1267                  int maxPreviewHeight = cellHeight;
1268                  if (layout.getChildCount() &gt; 0) {
1269                      PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1270                      int[] maxSize = w.getPreviewSize();
1271                      maxPreviewWidth = maxSize[0];
1272                      maxPreviewHeight = maxSize[1];
1273                  }
1274                  if (immediate) {
1275                      AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1276                              maxPreviewWidth, maxPreviewHeight, null, null);
1277                      loadWidgetPreviewsInBackground(null, data);
1278                      onSyncWidgetPageItems(data);
1279                  } else {
1280                      prepareLoadWidgetPreviewsTask(page, items,
1281                              maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1282                  }
1283              }
1284          });
1285      }
1286      private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1287              AsyncTaskPageData data) {
1288          // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1289          // previews synchronously
1290          if (task != null) {
1291              // Ensure that this task starts running at the correct priority
1292              task.syncThreadPriority();
1293          }
1294  
1295          // Load each of the widget/shortcut previews
1296          ArrayList&lt;Object&gt; items = data.items;
1297          ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1298          int count = items.size();
1299          for (int i = 0; i &lt; count; ++i) {
1300              if (task != null) {
1301                  // Ensure we haven&#x27;t been cancelled yet
1302                  if (task.isCancelled()) break;
1303                  // Before work on each item, ensure that this task is running at the correct
1304                  // priority
1305                  task.syncThreadPriority();
1306              }
1307  
1308              Object rawInfo = items.get(i);
1309              if (rawInfo instanceof AppWidgetProviderInfo) {
1310                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1311 -                int[] cellSpans = mLauncher.getSpanForWidget(info, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1312 +                int[] cellSpans = mLauncher.getSpanForWidget(info);</span>
1313  
1314                  int maxWidth = Math.min(data.maxImageWidth,
1315                          mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1316                  int maxHeight = Math.min(data.maxImageHeight,
1317                          mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1318                  Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1319                          cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1320                  images.add(b);
1321              } else if (rawInfo instanceof ResolveInfo) {
1322                  // Fill in the shortcuts information
1323                  ResolveInfo info = (ResolveInfo) rawInfo;
1324                  images.add(getShortcutPreview(info));
1325              }
1326          }
1327      }
1328  
1329      private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1330          if (mInTransition) {
1331              mDeferredSyncWidgetPageItems.add(data);
1332              return;
1333          }
1334          try {
1335              int page = data.page;
1336              PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1337  
1338              ArrayList&lt;Object&gt; items = data.items;
1339              int count = items.size();
1340              for (int i = 0; i &lt; count; ++i) {
1341                  PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1342                  if (widget != null) {
1343                      Bitmap preview = data.generatedImages.get(i);
1344                      widget.applyPreview(new FastBitmapDrawable(preview), i);
1345                  }
1346              }
1347  
1348              layout.createHardwareLayer();
1349              invalidate();
1350  
1351              // Update all thread priorities
1352              Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1353              while (iter.hasNext()) {
1354                  AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1355                  int pageIndex = task.page;
1356                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1357              }
1358          } finally {
1359              data.cleanup(false);
1360          }
1361      }
1362  
1363      @Override
1364      public void syncPages() {
1365          removeAllViews();
1366          cancelAllTasks();
1367  
1368          Context context = getContext();
1369          for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1370              PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1371                      mWidgetCountY);
1372              setupPage(layout);
1373              addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1374                      LayoutParams.MATCH_PARENT));
1375          }
1376  
1377          for (int i = 0; i &lt; mNumAppsPages; ++i) {
1378              PagedViewCellLayout layout = new PagedViewCellLayout(context);
1379              setupPage(layout);
1380              addView(layout);
1381          }
1382      }
1383  
1384      @Override
1385      public void syncPageItems(int page, boolean immediate) {
1386          if (page &lt; mNumAppsPages) {
1387              syncAppsPageItems(page, immediate);
1388          } else {
1389              syncWidgetPageItems(page, immediate);
1390          }
1391      }
1392  
1393      // We want our pages to be z-ordered such that the further a page is to the left, the higher
1394      // it is in the z-order. This is important to insure touch events are handled correctly.
1395      View getPageAt(int index) {
1396          return getChildAt(indexToPage(index));
1397      }
1398  
1399      @Override
1400      protected int indexToPage(int index) {
1401          return getChildCount() - index - 1;
1402      }
1403  
1404      // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1405      @Override
1406      protected void screenScrolled(int screenCenter) {
1407          super.screenScrolled(screenCenter);
1408  
1409          for (int i = 0; i &lt; getChildCount(); i++) {
1410              View v = getPageAt(i);
1411              if (v != null) {
1412                  float scrollProgress = getScrollProgress(screenCenter, v, i);
1413  
1414                  float interpolatedProgress =
1415                          mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1416                  float scale = (1 - interpolatedProgress) +
1417                          interpolatedProgress * TRANSITION_SCALE_FACTOR;
1418                  float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1419  
1420                  float alpha;
1421  
1422                  if (!LauncherApplication.isScreenLarge() || scrollProgress &lt; 0) {
1423                      alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1424                          1 - Math.abs(scrollProgress)) : 1.0f;
1425                  } else {
1426                      // On large screens we need to fade the page as it nears its leftmost position
1427                      alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1428                  }
1429  
1430                  v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1431                  int pageWidth = v.getMeasuredWidth();
1432                  int pageHeight = v.getMeasuredHeight();
1433  
1434                  if (PERFORM_OVERSCROLL_ROTATION) {
1435                      if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1436                          // Overscroll to the left
1437                          v.setPivotX(TRANSITION_PIVOT * pageWidth);
1438                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1439                          scale = 1.0f;
1440                          alpha = 1.0f;
1441                          // On the first page, we don&#x27;t want the page to have any lateral motion
1442                          translationX = 0;
1443                      } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1444                          // Overscroll to the right
1445                          v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1446                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1447                          scale = 1.0f;
1448                          alpha = 1.0f;
1449                          // On the last page, we don&#x27;t want the page to have any lateral motion.
1450                          translationX = 0;
1451                      } else {
1452                          v.setPivotY(pageHeight / 2.0f);
1453                          v.setPivotX(pageWidth / 2.0f);
1454                          v.setRotationY(0f);
1455                      }
1456                  }
1457  
1458                  v.setTranslationX(translationX);
1459                  v.setScaleX(scale);
1460                  v.setScaleY(scale);
1461                  v.setAlpha(alpha);
1462  
1463                  // If the view has 0 alpha, we set it to be invisible so as to prevent
1464                  // it from accepting touches
1465                  if (alpha &lt; ViewConfiguration.ALPHA_THRESHOLD) {
1466                      v.setVisibility(INVISIBLE);
1467                  } else if (v.getVisibility() != VISIBLE) {
1468                      v.setVisibility(VISIBLE);
1469                  }
1470              }
1471          }
1472      }
1473  
1474      protected void overScroll(float amount) {
1475          acceleratedOverScroll(amount);
1476      }
1477  
1478      /**
1479       * Used by the parent to get the content width to set the tab bar to
1480       * @return
1481       */
1482      public int getPageContentWidth() {
1483          return mContentWidth;
1484      }
1485  
1486      @Override
1487      protected void onPageEndMoving() {
1488          super.onPageEndMoving();
1489  
1490          // We reset the save index when we change pages so that it will be recalculated on next
1491          // rotation
1492          mSaveInstanceStateItemIndex = -1;
1493      }
1494  
1495      /*
1496       * AllAppsView implementation
1497       */
1498      @Override
1499      public void setup(Launcher launcher, DragController dragController) {
1500          mLauncher = launcher;
1501          mDragController = dragController;
1502      }
1503      @Override
1504      public void zoom(float zoom, boolean animate) {
1505          // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1506      }
1507      @Override
1508      public boolean isVisible() {
1509          return (getVisibility() == VISIBLE);
1510      }
1511      @Override
1512      public boolean isAnimating() {
1513          return false;
1514      }
1515      @Override
1516      public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1517          mApps = list;
1518          Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1519          updatePageCounts();
1520  
1521          // The next layout pass will trigger data-ready if both widgets and apps are set, so
1522          // request a layout to do this test and invalidate the page data when ready.
1523          if (testDataReady()) requestLayout();
1524      }
1525      private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1526          // We add it in place, in alphabetical order
1527          int count = list.size();
1528          for (int i = 0; i &lt; count; ++i) {
1529              ApplicationInfo info = list.get(i);
1530              int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1531              if (index &lt; 0) {
1532                  mApps.add(-(index + 1), info);
1533              }
1534          }
1535      }
1536      @Override
1537      public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1538          addAppsWithoutInvalidate(list);
1539          updatePageCounts();
1540          invalidatePageData();
1541      }
1542      private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1543          ComponentName removeComponent = item.intent.getComponent();
1544          int length = list.size();
1545          for (int i = 0; i &lt; length; ++i) {
1546              ApplicationInfo info = list.get(i);
1547              if (info.intent.getComponent().equals(removeComponent)) {
1548                  return i;
1549              }
1550          }
1551          return -1;
1552      }
1553      private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1554          // loop through all the apps and remove apps that have the same component
1555          int length = list.size();
1556          for (int i = 0; i &lt; length; ++i) {
1557              ApplicationInfo info = list.get(i);
1558              int removeIndex = findAppByComponent(mApps, info);
1559              if (removeIndex &gt; -1) {
1560                  mApps.remove(removeIndex);
1561              }
1562          }
1563      }
1564      @Override
1565      public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1566          removeAppsWithoutInvalidate(list);
1567          updatePageCounts();
1568          invalidatePageData();
1569      }
1570      @Override
1571      public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1572          // We remove and re-add the updated applications list because it&#x27;s properties may have
1573          // changed (ie. the title), and this will ensure that the items will be in their proper
1574          // place in the list.
1575          removeAppsWithoutInvalidate(list);
1576          addAppsWithoutInvalidate(list);
1577          updatePageCounts();
1578  
1579          invalidatePageData();
1580      }
1581  
1582      @Override
1583      public void reset() {
1584          // If we have reset, then we should not continue to restore the previous state
1585          mSaveInstanceStateItemIndex = -1;
1586  
1587          AppsCustomizeTabHost tabHost = getTabHost();
1588          String tag = tabHost.getCurrentTabTag();
1589          if (tag != null) {
1590              if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1591                  tabHost.setCurrentTabFromContent(ContentType.Applications);
1592              }
1593          }
1594  
1595          if (mCurrentPage != 0) {
1596              invalidatePageData(0);
1597          }
1598      }
1599  
1600      private AppsCustomizeTabHost getTabHost() {
1601          return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1602      }
1603  
1604      @Override
1605      public void dumpState() {
1606          // TODO: Dump information related to current list of Applications, Widgets, etc.
1607          ApplicationInfo.dumpApplicationInfoList(LOG_TAG, &quot;mApps&quot;, mApps);
1608          dumpAppWidgetProviderInfoList(LOG_TAG, &quot;mWidgets&quot;, mWidgets);
1609      }
1610  
1611      private void dumpAppWidgetProviderInfoList(String tag, String label,
1612              ArrayList&lt;Object&gt; list) {
1613          Log.d(tag, label + &quot; size=&quot; + list.size());
1614          for (Object i: list) {
1615              if (i instanceof AppWidgetProviderInfo) {
1616                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1617                  Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1618                          + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1619                          + &quot; initialLayout=&quot; + info.initialLayout
1620                          + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1621              } else if (i instanceof ResolveInfo) {
1622                  ResolveInfo info = (ResolveInfo) i;
1623                  Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1624                          + info.icon);
1625              }
1626          }
1627      }
1628  
1629      @Override
1630      public void surrender() {
1631          // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1632          // should stop this now.
1633  
1634          // Stop all background tasks
1635          cancelAllTasks();
1636      }
1637  
1638      @Override
1639      public void iconPressed(PagedViewIcon icon) {
1640          // Reset the previously pressed icon and store a reference to the pressed icon so that
1641          // we can reset it on return to Launcher (in Launcher.onResume())
1642          if (mPressedIcon != null) {
1643              mPressedIcon.resetDrawableState();
1644          }
1645          mPressedIcon = icon;
1646      }
1647  
1648      public void resetDrawableState() {
1649          if (mPressedIcon != null) {
1650              mPressedIcon.resetDrawableState();
1651              mPressedIcon = null;
1652          }
1653      }
1654  
1655      /*
1656       * We load an extra page on each side to prevent flashes from scrolling and loading of the
1657       * widget previews in the background with the AsyncTasks.
1658       */
1659      final static int sLookBehindPageCount = 2;
1660      final static int sLookAheadPageCount = 2;
1661      protected int getAssociatedLowerPageBound(int page) {
1662          final int count = getChildCount();
1663          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1664          int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1665          return windowMinIndex;
1666      }
1667      protected int getAssociatedUpperPageBound(int page) {
1668          final int count = getChildCount();
1669          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1670          int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1671                  count - 1);
1672          return windowMaxIndex;
1673      }
1674  
1675      @Override
1676      protected String getCurrentPageDescription() {
1677          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1678          int stringId = R.string.default_scroll_format;
1679          int count = 0;
1680  
1681          if (page &lt; mNumAppsPages) {
1682              stringId = R.string.apps_customize_apps_scroll_format;
1683              count = mNumAppsPages;
1684          } else {
1685              page -= mNumAppsPages;
1686              stringId = R.string.apps_customize_widgets_scroll_format;
1687              count = mNumWidgetPages;
1688          }
1689  
1690          return String.format(mContext.getString(stringId), page + 1, count);
1691      }
1692  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2011 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.AnimatorSet;
  20  import android.animation.ObjectAnimator;
  21  import android.animation.ValueAnimator;
  22  import android.appwidget.AppWidgetHostView;
  23  import android.appwidget.AppWidgetManager;
  24  import android.appwidget.AppWidgetProviderInfo;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.PackageManager;
  29  import android.content.pm.ResolveInfo;
  30  import android.content.res.Configuration;
  31  import android.content.res.Resources;
  32  import android.content.res.TypedArray;
  33  import android.graphics.Bitmap;
  34  import android.graphics.Bitmap.Config;
  35  import android.graphics.Canvas;
  36  import android.graphics.MaskFilter;
  37  import android.graphics.Matrix;
  38  import android.graphics.Paint;
  39  import android.graphics.Rect;
  40  import android.graphics.RectF;
  41  import android.graphics.TableMaskFilter;
  42  import android.graphics.drawable.Drawable;
  43  import android.os.AsyncTask;
  44  import android.os.Process;
  45  import android.util.AttributeSet;
  46  import android.util.Log;
  47  import android.view.Gravity;
  48  import android.view.KeyEvent;
  49  import android.view.LayoutInflater;
  50  import android.view.MotionEvent;
  51  import android.view.View;
  52  import android.view.ViewConfiguration;
  53  import android.view.ViewGroup;
  54  import android.view.animation.AccelerateInterpolator;
  55  import android.view.animation.DecelerateInterpolator;
  56  import android.widget.GridLayout;
  57  import android.widget.ImageView;
  58  import android.widget.Toast;
  59  
  60  import com.android.launcher.R;
  61  import com.android.launcher2.DropTarget.DragObject;
  62  
  63  import java.util.ArrayList;
  64  import java.util.Collections;
  65  import java.util.Iterator;
  66  import java.util.List;
  67  
  68  /**
  69   * A simple callback interface which also provides the results of the task.
  70   */
  71  interface AsyncTaskCallback {
  72      void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data);
  73  }
  74  
  75  /**
  76   * The data needed to perform either of the custom AsyncTasks.
  77   */
  78  class AsyncTaskPageData {
  79      enum Type {
  80          LoadWidgetPreviewData
  81      }
  82  
  83      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, ArrayList&lt;Bitmap&gt; si, AsyncTaskCallback bgR,
  84              AsyncTaskCallback postR) {
  85          page = p;
  86          items = l;
  87          sourceImages = si;
  88          generatedImages = new ArrayList&lt;Bitmap&gt;();
  89          maxImageWidth = maxImageHeight = -1;
  90          doInBackgroundCallback = bgR;
  91          postExecuteCallback = postR;
  92      }
  93      AsyncTaskPageData(int p, ArrayList&lt;Object&gt; l, int cw, int ch, AsyncTaskCallback bgR,
  94              AsyncTaskCallback postR) {
  95          page = p;
  96          items = l;
  97          generatedImages = new ArrayList&lt;Bitmap&gt;();
  98          maxImageWidth = cw;
  99          maxImageHeight = ch;
 100          doInBackgroundCallback = bgR;
 101          postExecuteCallback = postR;
 102      }
 103      void cleanup(boolean cancelled) {
 104          // Clean up any references to source/generated bitmaps
 105          if (sourceImages != null) {
 106              if (cancelled) {
 107                  for (Bitmap b : sourceImages) {
 108                      b.recycle();
 109                  }
 110              }
 111              sourceImages.clear();
 112          }
 113          if (generatedImages != null) {
 114              if (cancelled) {
 115                  for (Bitmap b : generatedImages) {
 116                      b.recycle();
 117                  }
 118              }
 119              generatedImages.clear();
 120          }
 121      }
 122      int page;
 123      ArrayList&lt;Object&gt; items;
 124      ArrayList&lt;Bitmap&gt; sourceImages;
 125      ArrayList&lt;Bitmap&gt; generatedImages;
 126      int maxImageWidth;
 127      int maxImageHeight;
 128      AsyncTaskCallback doInBackgroundCallback;
 129      AsyncTaskCallback postExecuteCallback;
 130  }
 131  
 132  /**
 133   * A generic template for an async task used in AppsCustomize.
 134   */
 135  class AppsCustomizeAsyncTask extends AsyncTask&lt;AsyncTaskPageData, Void, AsyncTaskPageData&gt; {
 136      AppsCustomizeAsyncTask(int p, AsyncTaskPageData.Type ty) {
 137          page = p;
 138          threadPriority = Process.THREAD_PRIORITY_DEFAULT;
 139          dataType = ty;
 140      }
 141      @Override
 142      protected AsyncTaskPageData doInBackground(AsyncTaskPageData... params) {
 143          if (params.length != 1) return null;
 144          // Load each of the widget previews in the background
 145          params[0].doInBackgroundCallback.run(this, params[0]);
 146          return params[0];
 147      }
 148      @Override
 149      protected void onPostExecute(AsyncTaskPageData result) {
 150          // All the widget previews are loaded, so we can just callback to inflate the page
 151          result.postExecuteCallback.run(this, result);
 152      }
 153  
 154      void setThreadPriority(int p) {
 155          threadPriority = p;
 156      }
 157      void syncThreadPriority() {
 158          Process.setThreadPriority(threadPriority);
 159      }
 160  
 161      // The page that this async task is associated with
 162      AsyncTaskPageData.Type dataType;
 163      int page;
 164      int threadPriority;
 165  }
 166  
 167  /**
 168   * The Apps/Customize page that displays all the applications, widgets, and shortcuts.
 169   */
 170  public class AppsCustomizePagedView extends PagedViewWithDraggableItems implements
 171          AllAppsView, View.OnClickListener, View.OnKeyListener, DragSource,
 172          PagedViewIcon.PressedCallback, PagedViewWidget.ShortPressListener,
 173          LauncherTransitionable {
 174      static final String LOG_TAG = &quot;AppsCustomizePagedView&quot;;
 175  
 176      /**
 177       * The different content types that this paged view can show.
 178       */
 179      public enum ContentType {
 180          Applications,
 181          Widgets
 182      }
 183  
 184      // Refs
 185      private Launcher mLauncher;
 186      private DragController mDragController;
 187      private final LayoutInflater mLayoutInflater;
 188      private final PackageManager mPackageManager;
 189  
 190      // Save and Restore
 191      private int mSaveInstanceStateItemIndex = -1;
 192      private PagedViewIcon mPressedIcon;
 193  
 194      // Content
 195      private ArrayList&lt;ApplicationInfo&gt; mApps;
 196      private ArrayList&lt;Object&gt; mWidgets;
 197  
 198      // Cling
 199      private boolean mHasShownAllAppsCling;
 200      private int mClingFocusedX;
 201      private int mClingFocusedY;
 202  
 203      // Caching
 204      private Canvas mCanvas;
 205      private Drawable mDefaultWidgetBackground;
 206      private IconCache mIconCache;
 207  
 208      // Dimens
 209      private int mContentWidth;
 210      private int mAppIconSize;
 211      private int mMaxAppCellCountX, mMaxAppCellCountY;
 212      private int mWidgetCountX, mWidgetCountY;
 213      private int mWidgetWidthGap, mWidgetHeightGap;
 214      private final int mWidgetPreviewIconPaddedDimension;
 215      private final float sWidgetPreviewIconPaddingPercentage = 0.25f;
 216      private PagedViewCellLayout mWidgetSpacingLayout;
 217      private int mNumAppsPages;
 218      private int mNumWidgetPages;
 219  
 220      // Relating to the scroll and overscroll effects
 221      Workspace.ZInterpolator mZInterpolator = new Workspace.ZInterpolator(0.5f);
 222      private static float CAMERA_DISTANCE = 6500;
 223      private static float TRANSITION_SCALE_FACTOR = 0.74f;
 224      private static float TRANSITION_PIVOT = 0.65f;
 225      private static float TRANSITION_MAX_ROTATION = 22;
 226      private static final boolean PERFORM_OVERSCROLL_ROTATION = true;
 227      private AccelerateInterpolator mAlphaInterpolator = new AccelerateInterpolator(0.9f);
 228      private DecelerateInterpolator mLeftScreenAlphaInterpolator = new DecelerateInterpolator(4);
 229  
 230      // Previews &amp; outlines
 231      ArrayList&lt;AppsCustomizeAsyncTask&gt; mRunningTasks;
 232      private static final int sPageSleepDelay = 200;
 233  
 234      private Runnable mInflateWidgetRunnable = null;
 235      private Runnable mBindWidgetRunnable = null;
 236      static final int WIDGET_NO_CLEANUP_REQUIRED = -1;
 237      static final int WIDGET_BOUND = 0;
 238      static final int WIDGET_INFLATED = 1;
 239      int mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 240      int mWidgetLoadingId = -1;
 241      PendingAddWidgetInfo mCreateWidgetInfo = null;
 242      private boolean mDraggingWidget = false;
 243  
 244      // Deferral of loading widget previews during launcher transitions
 245      private boolean mInTransition;
 246      private ArrayList&lt;AsyncTaskPageData&gt; mDeferredSyncWidgetPageItems =
 247          new ArrayList&lt;AsyncTaskPageData&gt;();
 248  
 249      public AppsCustomizePagedView(Context context, AttributeSet attrs) {
 250          super(context, attrs);
 251          mLayoutInflater = LayoutInflater.from(context);
 252          mPackageManager = context.getPackageManager();
 253          mApps = new ArrayList&lt;ApplicationInfo&gt;();
 254          mWidgets = new ArrayList&lt;Object&gt;();
 255          mIconCache = ((LauncherApplication) context.getApplicationContext()).getIconCache();
 256          mCanvas = new Canvas();
 257          mRunningTasks = new ArrayList&lt;AppsCustomizeAsyncTask&gt;();
 258  
 259          // Save the default widget preview background
 260          Resources resources = context.getResources();
 261          mDefaultWidgetBackground = resources.getDrawable(R.drawable.default_widget_preview_holo);
 262          mAppIconSize = resources.getDimensionPixelSize(R.dimen.app_icon_size);
 263  
 264          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AppsCustomizePagedView, 0, 0);
 265          mMaxAppCellCountX = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountX, -1);
 266          mMaxAppCellCountY = a.getInt(R.styleable.AppsCustomizePagedView_maxAppCellCountY, -1);
 267          mWidgetWidthGap =
 268              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellWidthGap, 0);
 269          mWidgetHeightGap =
 270              a.getDimensionPixelSize(R.styleable.AppsCustomizePagedView_widgetCellHeightGap, 0);
 271          mWidgetCountX = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountX, 2);
 272          mWidgetCountY = a.getInt(R.styleable.AppsCustomizePagedView_widgetCountY, 2);
 273          mClingFocusedX = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedX, 0);
 274          mClingFocusedY = a.getInt(R.styleable.AppsCustomizePagedView_clingFocusedY, 0);
 275          a.recycle();
 276          mWidgetSpacingLayout = new PagedViewCellLayout(getContext());
 277  
 278          // The padding on the non-matched dimension for the default widget preview icons
 279          // (top + bottom)
 280          mWidgetPreviewIconPaddedDimension =
 281              (int) (mAppIconSize * (1 + (2 * sWidgetPreviewIconPaddingPercentage)));
 282          mFadeInAdjacentScreens = false;
 283      }
 284  
 285      @Override
 286      protected void init() {
 287          super.init();
 288          mCenterPagesVertically = false;
 289  
 290          Context context = getContext();
 291          Resources r = context.getResources();
 292          setDragSlopeThreshold(r.getInteger(R.integer.config_appsCustomizeDragSlopeThreshold)/100f);
 293      }
 294  
 295      @Override
 296      protected void onUnhandledTap(MotionEvent ev) {
 297          if (LauncherApplication.isScreenLarge()) {
 298              // Dismiss AppsCustomize if we tap
 299              mLauncher.showWorkspace(true);
 300          }
 301      }
 302  
 303      /** Returns the item index of the center item on this page so that we can restore to this
 304       *  item index when we rotate. */
 305      private int getMiddleComponentIndexOnCurrentPage() {
 306          int i = -1;
 307          if (getPageCount() &gt; 0) {
 308              int currentPage = getCurrentPage();
 309              if (currentPage &lt; mNumAppsPages) {
 310                  PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(currentPage);
 311                  PagedViewCellLayoutChildren childrenLayout = layout.getChildrenLayout();
 312                  int numItemsPerPage = mCellCountX * mCellCountY;
 313                  int childCount = childrenLayout.getChildCount();
 314                  if (childCount &gt; 0) {
 315                      i = (currentPage * numItemsPerPage) + (childCount / 2);
 316                  }
 317              } else {
 318                  int numApps = mApps.size();
 319                  PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(currentPage);
 320                  int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 321                  int childCount = layout.getChildCount();
 322                  if (childCount &gt; 0) {
 323                      i = numApps +
 324                          ((currentPage - mNumAppsPages) * numItemsPerPage) + (childCount / 2);
 325                  }
 326              }
 327          }
 328          return i;
 329      }
 330  
 331      /** Get the index of the item to restore to if we need to restore the current page. */
 332      int getSaveInstanceStateIndex() {
 333          if (mSaveInstanceStateItemIndex == -1) {
 334              mSaveInstanceStateItemIndex = getMiddleComponentIndexOnCurrentPage();
 335          }
 336          return mSaveInstanceStateItemIndex;
 337      }
 338  
 339      /** Returns the page in the current orientation which is expected to contain the specified
 340       *  item index. */
 341      int getPageForComponent(int index) {
 342          if (index &lt; 0) return 0;
 343  
 344          if (index &lt; mApps.size()) {
 345              int numItemsPerPage = mCellCountX * mCellCountY;
 346              return (index / numItemsPerPage);
 347          } else {
 348              int numItemsPerPage = mWidgetCountX * mWidgetCountY;
 349              return mNumAppsPages + ((index - mApps.size()) / numItemsPerPage);
 350          }
 351      }
 352  
 353      /**
 354       * This differs from isDataReady as this is the test done if isDataReady is not set.
 355       */
 356      private boolean testDataReady() {
 357          // We only do this test once, and we default to the Applications page, so we only really
 358          // have to wait for there to be apps.
 359          // TODO: What if one of them is validly empty
 360          return !mApps.isEmpty() &amp;&amp; !mWidgets.isEmpty();
 361      }
 362  
 363      /** Restores the page for an item at the specified index */
 364      void restorePageForIndex(int index) {
 365          if (index &lt; 0) return;
 366          mSaveInstanceStateItemIndex = index;
 367      }
 368  
 369      private void updatePageCounts() {
 370          mNumWidgetPages = (int) Math.ceil(mWidgets.size() /
 371                  (float) (mWidgetCountX * mWidgetCountY));
 372          mNumAppsPages = (int) Math.ceil((float) mApps.size() / (mCellCountX * mCellCountY));
 373      }
 374  
 375      protected void onDataReady(int width, int height) {
 376          // Note that we transpose the counts in portrait so that we get a similar layout
 377          boolean isLandscape = getResources().getConfiguration().orientation ==
 378              Configuration.ORIENTATION_LANDSCAPE;
 379          int maxCellCountX = Integer.MAX_VALUE;
 380          int maxCellCountY = Integer.MAX_VALUE;
 381          if (LauncherApplication.isScreenLarge()) {
 382              maxCellCountX = (isLandscape ? LauncherModel.getCellCountX() :
 383                  LauncherModel.getCellCountY());
 384              maxCellCountY = (isLandscape ? LauncherModel.getCellCountY() :
 385                  LauncherModel.getCellCountX());
 386          }
 387          if (mMaxAppCellCountX &gt; -1) {
 388              maxCellCountX = Math.min(maxCellCountX, mMaxAppCellCountX);
 389          }
 390          if (mMaxAppCellCountY &gt; -1) {
 391              maxCellCountY = Math.min(maxCellCountY, mMaxAppCellCountY);
 392          }
 393  
 394          // Now that the data is ready, we can calculate the content width, the number of cells to
 395          // use for each page
 396          mWidgetSpacingLayout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 397          mWidgetSpacingLayout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 398                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 399          mWidgetSpacingLayout.calculateCellCount(width, height, maxCellCountX, maxCellCountY);
 400          mCellCountX = mWidgetSpacingLayout.getCellCountX();
 401          mCellCountY = mWidgetSpacingLayout.getCellCountY();
 402          updatePageCounts();
 403  
 404          // Force a measure to update recalculate the gaps
 405          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 406          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 407          mWidgetSpacingLayout.measure(widthSpec, heightSpec);
 408          mContentWidth = mWidgetSpacingLayout.getContentWidth();
 409  
 410          AppsCustomizeTabHost host = (AppsCustomizeTabHost) getTabHost();
 411          final boolean hostIsTransitioning = host.isTransitioning();
 412  
 413          // Restore the page
 414          int page = getPageForComponent(mSaveInstanceStateItemIndex);
 415          invalidatePageData(Math.max(0, page), hostIsTransitioning);
 416  
 417          // Show All Apps cling if we are finished transitioning, otherwise, we will try again when
 418          // the transition completes in AppsCustomizeTabHost (otherwise the wrong offsets will be
 419          // returned while animating)
 420          if (!hostIsTransitioning) {
 421              post(new Runnable() {
 422                  @Override
 423                  public void run() {
 424                      showAllAppsCling();
 425                  }
 426              });
 427          }
 428      }
 429  
 430      void showAllAppsCling() {
 431          if (!mHasShownAllAppsCling &amp;&amp; isDataReady() &amp;&amp; testDataReady()) {
 432              mHasShownAllAppsCling = true;
 433              // Calculate the position for the cling punch through
 434              int[] offset = new int[2];
 435              int[] pos = mWidgetSpacingLayout.estimateCellPosition(mClingFocusedX, mClingFocusedY);
 436              mLauncher.getDragLayer().getLocationInDragLayer(this, offset);
 437              // PagedViews are centered horizontally but top aligned
 438              pos[0] += (getMeasuredWidth() - mWidgetSpacingLayout.getMeasuredWidth()) / 2 +
 439                      offset[0];
 440              pos[1] += offset[1];
 441              mLauncher.showFirstRunAllAppsCling(pos);
 442          }
 443      }
 444  
 445      @Override
 446      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 447          int width = MeasureSpec.getSize(widthMeasureSpec);
 448          int height = MeasureSpec.getSize(heightMeasureSpec);
 449          if (!isDataReady()) {
 450              if (testDataReady()) {
 451                  setDataIsReady();
 452                  setMeasuredDimension(width, height);
 453                  onDataReady(width, height);
 454              }
 455          }
 456  
 457          super.onMeasure(widthMeasureSpec, heightMeasureSpec);
 458      }
 459  
 460      public void onPackagesUpdated() {
 461          // TODO: this isn&#x27;t ideal, but we actually need to delay here. This call is triggered
 462          // by a broadcast receiver, and in order for it to work correctly, we need to know that
 463          // the AppWidgetService has already received and processed the same broadcast. Since there
 464          // is no guarantee about ordering of broadcast receipt, we just delay here. Ideally,
 465          // we should have a more precise way of ensuring the AppWidgetService is up to date.
 466          postDelayed(new Runnable() {
 467             public void run() {
 468                 updatePackages();
 469             }
 470          }, 500);
 471      }
 472  
 473      public void updatePackages() {
 474          // Get the list of widgets and shortcuts
 475          boolean wasEmpty = mWidgets.isEmpty();
 476          mWidgets.clear();
 477          List&lt;AppWidgetProviderInfo&gt; widgets =
 478              AppWidgetManager.getInstance(mLauncher).getInstalledProviders();
 479          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
 480          List&lt;ResolveInfo&gt; shortcuts = mPackageManager.queryIntentActivities(shortcutsIntent, 0);
 481          for (AppWidgetProviderInfo widget : widgets) {
 482              if (widget.minWidth &gt; 0 &amp;&amp; widget.minHeight &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -                mWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 484 +                // Ensure that all widgets we show can be added on a workspace of this size</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 485 +                int[] spanXY = mLauncher.getSpanForWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 486 +                int[] minSpanXY = mLauncher.getMinSpanForWidget(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 487 +                int minSpanX = Math.min(spanXY[0], minSpanXY[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 488 +                int minSpanY = Math.min(spanXY[1], minSpanXY[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 489 +                if (minSpanX &lt;= LauncherModel.getCellCountX() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 490 +                        minSpanY &lt;= LauncherModel.getCellCountY()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +                    mWidgets.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 492 +                }</span>
 493              } else {
 494                  Log.e(LOG_TAG, &quot;Widget &quot; + widget.provider + &quot; has invalid dimensions (&quot; +
 495                          widget.minWidth + &quot;, &quot; + widget.minHeight + &quot;)&quot;);
 496              }
 497          }
 498          mWidgets.addAll(shortcuts);
 499          Collections.sort(mWidgets,
 500                  new LauncherModel.WidgetAndShortcutNameComparator(mPackageManager));
 501          updatePageCounts();
 502  
 503          if (wasEmpty) {
 504              // The next layout pass will trigger data-ready if both widgets and apps are set, so request
 505              // a layout to do this test and invalidate the page data when ready.
 506              if (testDataReady()) requestLayout();
 507          } else {
 508              cancelAllTasks();
 509              invalidatePageData();
 510          }
 511      }
 512  
 513      @Override
 514      public void onClick(View v) {
 515          // When we have exited all apps or are in transition, disregard clicks
 516          if (!mLauncher.isAllAppsCustomizeOpen() ||
 517                  mLauncher.getWorkspace().isSwitchingState()) return;
 518  
 519          if (v instanceof PagedViewIcon) {
 520              // Animate some feedback to the click
 521              final ApplicationInfo appInfo = (ApplicationInfo) v.getTag();
 522              mLauncher.startActivitySafely(appInfo.intent, appInfo);
 523  
 524              // Lock the drawable state to pressed until we return to Launcher
 525              if (mPressedIcon != null) {
 526                  mPressedIcon.lockDrawableState();
 527              }
 528          } else if (v instanceof PagedViewWidget) {
 529              // Let the user know that they have to long press to add a widget
 530              Toast.makeText(getContext(), R.string.long_press_widget_to_add,
 531                      Toast.LENGTH_SHORT).show();
 532  
 533              // Create a little animation to show that the widget can move
 534              float offsetY = getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
 535              final ImageView p = (ImageView) v.findViewById(R.id.widget_preview);
 536              AnimatorSet bounce = new AnimatorSet();
 537              ValueAnimator tyuAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, offsetY);
 538              tyuAnim.setDuration(125);
 539              ValueAnimator tydAnim = ObjectAnimator.ofFloat(p, &quot;translationY&quot;, 0f);
 540              tydAnim.setDuration(100);
 541              bounce.play(tyuAnim).before(tydAnim);
 542              bounce.setInterpolator(new AccelerateInterpolator());
 543              bounce.start();
 544          }
 545      }
 546  
 547      public boolean onKey(View v, int keyCode, KeyEvent event) {
 548          return FocusHelper.handleAppsCustomizeKeyEvent(v,  keyCode, event);
 549      }
 550  
 551      /*
 552       * PagedViewWithDraggableItems implementation
 553       */
 554      @Override
 555      protected void determineDraggingStart(android.view.MotionEvent ev) {
 556          // Disable dragging by pulling an app down for now.
 557      }
 558  
 559      private void beginDraggingApplication(View v) {
 560          mLauncher.getWorkspace().onDragStartedWithItem(v);
 561          mLauncher.getWorkspace().beginDragShared(v, this);
 562      }
 563  
 564      private void loadWidgetInBackground(final PendingAddWidgetInfo info) {
 565          final AppWidgetProviderInfo pInfo = info.info;
 566          if (pInfo.configure != null) {
 567              return;
 568          }
 569  
 570          mBindWidgetRunnable = new Runnable() {
 571              @Override
 572              public void run() {
 573                  mWidgetLoadingId = mLauncher.getAppWidgetHost().allocateAppWidgetId();
 574                  AppWidgetManager.getInstance(mLauncher).bindAppWidgetId(mWidgetLoadingId,
 575                          info.componentName);
 576                  mWidgetCleanupState = WIDGET_BOUND;
 577              }
 578          };
 579          post(mBindWidgetRunnable);
 580  
 581          mInflateWidgetRunnable = new Runnable() {
 582              @Override
 583              public void run() {
 584                  AppWidgetHostView hostView =
 585                          mLauncher.getAppWidgetHost().createView(mContext, mWidgetLoadingId, pInfo);
 586                  info.boundWidget = hostView;
 587                  mWidgetCleanupState = WIDGET_INFLATED;
 588                  hostView.setVisibility(INVISIBLE);
 589                  int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(info.spanX,
 590                          info.spanY, info, false);
 591  
 592                  // We want the first widget layout to be the correct size. This will be important
 593                  // for width size reporting to the AppWidgetManager.
 594                  DragLayer.LayoutParams lp = new DragLayer.LayoutParams(unScaledSize[0],
 595                          unScaledSize[1]);
 596                  lp.x = lp.y = 0;
 597                  lp.customPosition = true;
 598                  hostView.setLayoutParams(lp);
 599                  mLauncher.getDragLayer().addView(hostView);
 600              }
 601          };
 602          post(mInflateWidgetRunnable);
 603      }
 604  
 605      @Override
 606      public void onShortPress(View v) {
 607          // We are anticipating a long press, and we use this time to load bind and instantiate
 608          // the widget. This will need to be cleaned up if it turns out no long press occurs.
 609          mCreateWidgetInfo = new PendingAddWidgetInfo((PendingAddWidgetInfo) v.getTag());
 610          loadWidgetInBackground(mCreateWidgetInfo);
 611      }
 612  
 613      private void cleanupWidgetPreloading() {
 614          PendingAddWidgetInfo info = mCreateWidgetInfo;
 615          mCreateWidgetInfo = null;
 616          if (mWidgetCleanupState &gt;= 0 &amp;&amp; mWidgetLoadingId != -1) {
 617              mLauncher.getAppWidgetHost().deleteAppWidgetId(mWidgetLoadingId);
 618          }
 619          if (mWidgetCleanupState == WIDGET_BOUND) {
 620              removeCallbacks(mInflateWidgetRunnable);
 621          } else if (mWidgetCleanupState == WIDGET_INFLATED) {
 622              AppWidgetHostView widget = info.boundWidget;
 623              int widgetId = widget.getAppWidgetId();
 624              mLauncher.getAppWidgetHost().deleteAppWidgetId(widgetId);
 625              mLauncher.getDragLayer().removeView(widget);
 626          }
 627          mWidgetCleanupState = WIDGET_NO_CLEANUP_REQUIRED;
 628          mWidgetLoadingId = -1;
 629      }
 630  
 631      @Override
 632      public void cleanUpShortPress(View v) {
 633          if (!mDraggingWidget) {
 634              cleanupWidgetPreloading();
 635          }
 636      }
 637  
 638      private void beginDraggingWidget(View v) {
 639          mDraggingWidget = true;
 640          // Get the widget preview as the drag representation
 641          ImageView image = (ImageView) v.findViewById(R.id.widget_preview);
 642          PendingAddItemInfo createItemInfo = (PendingAddItemInfo) v.getTag();
 643  
 644          // Compose the drag image
 645          Bitmap preview;
 646          Bitmap outline;
 647          float scale = 1f;
 648          if (createItemInfo instanceof PendingAddWidgetInfo) {
 649              PendingAddWidgetInfo createWidgetInfo = mCreateWidgetInfo;
 650              createItemInfo = createWidgetInfo;
 651              int spanX = createItemInfo.spanX;
 652              int spanY = createItemInfo.spanY;
 653              int[] size = mLauncher.getWorkspace().estimateItemSize(spanX, spanY,
 654                      createWidgetInfo, true);
 655  
 656              FastBitmapDrawable previewDrawable = (FastBitmapDrawable) image.getDrawable();
 657              float minScale = 1.25f;
 658              int minWidth, minHeight;
 659              minWidth = Math.max((int) (previewDrawable.getIntrinsicWidth() * minScale), size[0]);
 660              minHeight = Math.max((int) (previewDrawable.getIntrinsicHeight() * minScale), size[1]);
 661              preview = getWidgetPreview(createWidgetInfo.componentName, createWidgetInfo.previewImage,
 662                      createWidgetInfo.icon, spanX, spanY, minWidth, minHeight);
 663  
 664              // Determine the image view drawable scale relative to the preview
 665              float[] mv = new float[9];
 666              Matrix m = new Matrix();
 667              m.setRectToRect(
 668                      new RectF(0f, 0f, (float) preview.getWidth(), (float) preview.getHeight()),
 669                      new RectF(0f, 0f, (float) previewDrawable.getIntrinsicWidth(),
 670                              (float) previewDrawable.getIntrinsicHeight()),
 671                      Matrix.ScaleToFit.START);
 672              m.getValues(mv);
 673              scale = (float) mv[0];
 674          } else {
 675              // Workaround for the fact that we don&#x27;t keep the original ResolveInfo associated with
 676              // the shortcut around.  To get the icon, we just render the preview image (which has
 677              // the shortcut icon) to a new drag bitmap that clips the non-icon space.
 678              preview = Bitmap.createBitmap(mWidgetPreviewIconPaddedDimension,
 679                      mWidgetPreviewIconPaddedDimension, Bitmap.Config.ARGB_8888);
 680              Drawable d = image.getDrawable();
 681              mCanvas.setBitmap(preview);
 682              d.draw(mCanvas);
 683              mCanvas.setBitmap(null);
 684              createItemInfo.spanX = createItemInfo.spanY = 1;
 685          }
 686  
 687          // We use a custom alpha clip table for the default widget previews
 688          Paint alphaClipPaint = null;
 689          if (createItemInfo instanceof PendingAddWidgetInfo) {
 690              if (((PendingAddWidgetInfo) createItemInfo).previewImage != 0) {
 691                  MaskFilter alphaClipTable = TableMaskFilter.CreateClipTable(0, 255);
 692                  alphaClipPaint = new Paint();
 693                  alphaClipPaint.setMaskFilter(alphaClipTable);
 694              }
 695          }
 696  
 697          // Save the preview for the outline generation, then dim the preview
 698          outline = Bitmap.createScaledBitmap(preview, preview.getWidth(), preview.getHeight(),
 699                  false);
 700  
 701          // Start the drag
 702          alphaClipPaint = null;
 703          mLauncher.lockScreenOrientationOnLargeUI();
 704          mLauncher.getWorkspace().onDragStartedWithItem(createItemInfo, outline, alphaClipPaint);
 705          mDragController.startDrag(image, preview, this, createItemInfo,
 706                  DragController.DRAG_ACTION_COPY, null, scale);
 707          outline.recycle();
 708          preview.recycle();
 709      }
 710  
 711      @Override
 712      protected boolean beginDragging(final View v) {
 713          if (!super.beginDragging(v)) return false;
 714  
 715          if (v instanceof PagedViewIcon) {
 716              beginDraggingApplication(v);
 717          } else if (v instanceof PagedViewWidget) {
 718              beginDraggingWidget(v);
 719          }
 720  
 721          // We delay entering spring-loaded mode slightly to make sure the UI
 722          // thready is free of any work.
 723          postDelayed(new Runnable() {
 724              @Override
 725              public void run() {
 726                  // We don&#x27;t enter spring-loaded mode if the drag has been cancelled
 727                  if (mLauncher.getDragController().isDragging()) {
 728                      // Dismiss the cling
 729                      mLauncher.dismissAllAppsCling(null);
 730  
 731                      // Reset the alpha on the dragged icon before we drag
 732                      resetDrawableState();
 733  
 734                      // Go into spring loaded mode (must happen before we startDrag())
 735                      mLauncher.enterSpringLoadedDragMode();
 736                  }
 737              }
 738          }, 150);
 739  
 740          return true;
 741      }
 742  
 743      /**
 744       * Clean up after dragging.
 745       *
 746       * @param target where the item was dragged to (can be null if the item was flung)
 747       */
 748      private void endDragging(View target, boolean isFlingToDelete, boolean success) {
 749          if (isFlingToDelete || !success || (target != mLauncher.getWorkspace() &amp;&amp;
 750                  !(target instanceof DeleteDropTarget))) {
 751              // Exit spring loaded mode if we have not successfully dropped or have not handled the
 752              // drop in Workspace
 753              mLauncher.exitSpringLoadedDragMode();
 754          }
 755          mLauncher.unlockScreenOrientationOnLargeUI();
 756      }
 757  
 758      @Override
 759      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
 760          mInTransition = true;
 761          if (toWorkspace) {
 762              cancelAllTasks();
 763          }
 764      }
 765  
 766      @Override
 767      public View getContent() {
 768          return null;
 769      }
 770  
 771      @Override
 772      public void onLauncherTransitionStep(Launcher l, float t) {
 773      }
 774  
 775      @Override
 776      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
 777          mInTransition = false;
 778          for (AsyncTaskPageData d : mDeferredSyncWidgetPageItems) {
 779              onSyncWidgetPageItems(d);
 780          }
 781          mDeferredSyncWidgetPageItems.clear();
 782      }
 783  
 784      @Override
 785      public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
 786              boolean success) {
 787          // Return early and wait for onFlingToDeleteCompleted if this was the result of a fling
 788          if (isFlingToDelete) return;
 789  
 790          endDragging(target, false, success);
 791  
 792          // Display an error message if the drag failed due to there not being enough space on the
 793          // target layout we were dropping on.
 794          if (!success) {
 795              boolean showOutOfSpaceMessage = false;
 796              if (target instanceof Workspace) {
 797                  int currentScreen = mLauncher.getCurrentWorkspaceScreen();
 798                  Workspace workspace = (Workspace) target;
 799                  CellLayout layout = (CellLayout) workspace.getChildAt(currentScreen);
 800                  ItemInfo itemInfo = (ItemInfo) d.dragInfo;
 801                  if (layout != null) {
 802                      layout.calculateSpans(itemInfo);
 803                      showOutOfSpaceMessage =
 804                              !layout.findCellForSpan(null, itemInfo.spanX, itemInfo.spanY);
 805                  }
 806              }
 807              if (showOutOfSpaceMessage) {
 808                  mLauncher.showOutOfSpaceMessage(false);
 809              }
 810  
 811              d.deferDragViewCleanupPostAnimation = false;
 812              cleanupWidgetPreloading();
 813          }
 814          mDraggingWidget = false;
 815      }
 816  
 817      @Override
 818      public void onFlingToDeleteCompleted() {
 819          // We just dismiss the drag when we fling, so cleanup here
 820          endDragging(null, true, true);
 821          cleanupWidgetPreloading();
 822          mDraggingWidget = false;
 823      }
 824  
 825      @Override
 826      public boolean supportsFlingToDelete() {
 827          return true;
 828      }
 829  
 830      @Override
 831      protected void onDetachedFromWindow() {
 832          super.onDetachedFromWindow();
 833          cancelAllTasks();
 834      }
 835  
 836      public void clearAllWidgetPages() {
 837          cancelAllTasks();
 838          int count = getChildCount();
 839          for (int i = 0; i &lt; count; i++) {
 840              View v = getPageAt(i);
 841              if (v instanceof PagedViewGridLayout) {
 842                  ((PagedViewGridLayout) v).removeAllViewsOnPage();
 843                  mDirtyPageContent.set(i, true);
 844              }
 845          }
 846      }
 847  
 848      private void cancelAllTasks() {
 849          // Clean up all the async tasks
 850          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 851          while (iter.hasNext()) {
 852              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 853              task.cancel(false);
 854              iter.remove();
 855              mDirtyPageContent.set(task.page, true);
 856          }
 857      }
 858  
 859      public void setContentType(ContentType type) {
 860          if (type == ContentType.Widgets) {
 861              invalidatePageData(mNumAppsPages, true);
 862          } else if (type == ContentType.Applications) {
 863              invalidatePageData(0, true);
 864          }
 865      }
 866  
 867      protected void snapToPage(int whichPage, int delta, int duration) {
 868          super.snapToPage(whichPage, delta, duration);
 869          updateCurrentTab(whichPage);
 870  
 871          // Update the thread priorities given the direction lookahead
 872          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 873          while (iter.hasNext()) {
 874              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 875              int pageIndex = task.page;
 876              if ((mNextPage &gt; mCurrentPage &amp;&amp; pageIndex &gt;= mCurrentPage) ||
 877                  (mNextPage &lt; mCurrentPage &amp;&amp; pageIndex &lt;= mCurrentPage)) {
 878                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
 879              } else {
 880                  task.setThreadPriority(Process.THREAD_PRIORITY_LOWEST);
 881              }
 882          }
 883      }
 884  
 885      private void updateCurrentTab(int currentPage) {
 886          AppsCustomizeTabHost tabHost = getTabHost();
 887          if (tabHost != null) {
 888              String tag = tabHost.getCurrentTabTag();
 889              if (tag != null) {
 890                  if (currentPage &gt;= mNumAppsPages &amp;&amp;
 891                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Widgets))) {
 892                      tabHost.setCurrentTabFromContent(ContentType.Widgets);
 893                  } else if (currentPage &lt; mNumAppsPages &amp;&amp;
 894                          !tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
 895                      tabHost.setCurrentTabFromContent(ContentType.Applications);
 896                  }
 897              }
 898          }
 899      }
 900  
 901      /*
 902       * Apps PagedView implementation
 903       */
 904      private void setVisibilityOnChildren(ViewGroup layout, int visibility) {
 905          int childCount = layout.getChildCount();
 906          for (int i = 0; i &lt; childCount; ++i) {
 907              layout.getChildAt(i).setVisibility(visibility);
 908          }
 909      }
 910      private void setupPage(PagedViewCellLayout layout) {
 911          layout.setCellCount(mCellCountX, mCellCountY);
 912          layout.setGap(mPageLayoutWidthGap, mPageLayoutHeightGap);
 913          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
 914                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
 915  
 916          // Note: We force a measure here to get around the fact that when we do layout calculations
 917          // immediately after syncing, we don&#x27;t have a proper width.  That said, we already know the
 918          // expected page width, so we can actually optimize by hiding all the TextView-based
 919          // children that are expensive to measure, and let that happen naturally later.
 920          setVisibilityOnChildren(layout, View.GONE);
 921          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
 922          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
 923          layout.setMinimumWidth(getPageContentWidth());
 924          layout.measure(widthSpec, heightSpec);
 925          setVisibilityOnChildren(layout, View.VISIBLE);
 926      }
 927  
 928      public void syncAppsPageItems(int page, boolean immediate) {
 929          // ensure that we have the right number of items on the pages
 930          int numCells = mCellCountX * mCellCountY;
 931          int startIndex = page * numCells;
 932          int endIndex = Math.min(startIndex + numCells, mApps.size());
 933          PagedViewCellLayout layout = (PagedViewCellLayout) getPageAt(page);
 934  
 935          layout.removeAllViewsOnPage();
 936          ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
 937          ArrayList&lt;Bitmap&gt; images = new ArrayList&lt;Bitmap&gt;();
 938          for (int i = startIndex; i &lt; endIndex; ++i) {
 939              ApplicationInfo info = mApps.get(i);
 940              PagedViewIcon icon = (PagedViewIcon) mLayoutInflater.inflate(
 941                      R.layout.apps_customize_application, layout, false);
 942              icon.applyFromApplicationInfo(info, true, this);
 943              icon.setOnClickListener(this);
 944              icon.setOnLongClickListener(this);
 945              icon.setOnTouchListener(this);
 946              icon.setOnKeyListener(this);
 947  
 948              int index = i - startIndex;
 949              int x = index % mCellCountX;
 950              int y = index / mCellCountX;
 951              layout.addViewToCellLayout(icon, -1, i, new PagedViewCellLayout.LayoutParams(x,y, 1,1));
 952  
 953              items.add(info);
 954              images.add(info.iconBitmap);
 955          }
 956  
 957          layout.createHardwareLayers();
 958      }
 959  
 960      /**
 961       * A helper to return the priority for loading of the specified widget page.
 962       */
 963      private int getWidgetPageLoadPriority(int page) {
 964          // If we are snapping to another page, use that index as the target page index
 965          int toPage = mCurrentPage;
 966          if (mNextPage &gt; -1) {
 967              toPage = mNextPage;
 968          }
 969  
 970          // We use the distance from the target page as an initial guess of priority, but if there
 971          // are no pages of higher priority than the page specified, then bump up the priority of
 972          // the specified page.
 973          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
 974          int minPageDiff = Integer.MAX_VALUE;
 975          while (iter.hasNext()) {
 976              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
 977              minPageDiff = Math.abs(task.page - toPage);
 978          }
 979  
 980          int rawPageDiff = Math.abs(page - toPage);
 981          return rawPageDiff - Math.min(rawPageDiff, minPageDiff);
 982      }
 983      /**
 984       * Return the appropriate thread priority for loading for a given page (we give the current
 985       * page much higher priority)
 986       */
 987      private int getThreadPriorityForPage(int page) {
 988          // TODO-APPS_CUSTOMIZE: detect number of cores and set thread priorities accordingly below
 989          int pageDiff = getWidgetPageLoadPriority(page);
 990          if (pageDiff &lt;= 0) {
 991              return Process.THREAD_PRIORITY_LESS_FAVORABLE;
 992          } else if (pageDiff &lt;= 1) {
 993              return Process.THREAD_PRIORITY_LOWEST;
 994          } else {
 995              return Process.THREAD_PRIORITY_LOWEST;
 996          }
 997      }
 998      private int getSleepForPage(int page) {
 999          int pageDiff = getWidgetPageLoadPriority(page);
1000          return Math.max(0, pageDiff * sPageSleepDelay);
1001      }
1002      /**
1003       * Creates and executes a new AsyncTask to load a page of widget previews.
1004       */
1005      private void prepareLoadWidgetPreviewsTask(int page, ArrayList&lt;Object&gt; widgets,
1006              int cellWidth, int cellHeight, int cellCountX) {
1007  
1008          // Prune all tasks that are no longer needed
1009          Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1010          while (iter.hasNext()) {
1011              AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1012              int taskPage = task.page;
1013              if (taskPage &lt; getAssociatedLowerPageBound(mCurrentPage) ||
1014                      taskPage &gt; getAssociatedUpperPageBound(mCurrentPage)) {
1015                  task.cancel(false);
1016                  iter.remove();
1017              } else {
1018                  task.setThreadPriority(getThreadPriorityForPage(taskPage));
1019              }
1020          }
1021  
1022          // We introduce a slight delay to order the loading of side pages so that we don&#x27;t thrash
1023          final int sleepMs = getSleepForPage(page);
1024          AsyncTaskPageData pageData = new AsyncTaskPageData(page, widgets, cellWidth, cellHeight,
1025              new AsyncTaskCallback() {
1026                  @Override
1027                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1028                      try {
1029                          try {
1030                              Thread.sleep(sleepMs);
1031                          } catch (Exception e) {}
1032                          loadWidgetPreviewsInBackground(task, data);
1033                      } finally {
1034                          if (task.isCancelled()) {
1035                              data.cleanup(true);
1036                          }
1037                      }
1038                  }
1039              },
1040              new AsyncTaskCallback() {
1041                  @Override
1042                  public void run(AppsCustomizeAsyncTask task, AsyncTaskPageData data) {
1043                      mRunningTasks.remove(task);
1044                      if (task.isCancelled()) return;
1045                      // do cleanup inside onSyncWidgetPageItems
1046                      onSyncWidgetPageItems(data);
1047                  }
1048              });
1049  
1050          // Ensure that the task is appropriately prioritized and runs in parallel
1051          AppsCustomizeAsyncTask t = new AppsCustomizeAsyncTask(page,
1052                  AsyncTaskPageData.Type.LoadWidgetPreviewData);
1053          t.setThreadPriority(getThreadPriorityForPage(page));
1054          t.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, pageData);
1055          mRunningTasks.add(t);
1056      }
1057  
1058      /*
1059       * Widgets PagedView implementation
1060       */
1061      private void setupPage(PagedViewGridLayout layout) {
1062          layout.setPadding(mPageLayoutPaddingLeft, mPageLayoutPaddingTop,
1063                  mPageLayoutPaddingRight, mPageLayoutPaddingBottom);
1064  
1065          // Note: We force a measure here to get around the fact that when we do layout calculations
1066          // immediately after syncing, we don&#x27;t have a proper width.
1067          int widthSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.AT_MOST);
1068          int heightSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.AT_MOST);
1069          layout.setMinimumWidth(getPageContentWidth());
1070          layout.measure(widthSpec, heightSpec);
1071      }
1072  
1073      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
1074          renderDrawableToBitmap(d, bitmap, x, y, w, h, 1f, 0xFFFFFFFF);
1075      }
1076  
1077      private void renderDrawableToBitmap(Drawable d, Bitmap bitmap, int x, int y, int w, int h,
1078              float scale, int multiplyColor) {
1079          if (bitmap != null) {
1080              Canvas c = new Canvas(bitmap);
1081              c.scale(scale, scale);
1082              Rect oldBounds = d.copyBounds();
1083              d.setBounds(x, y, x + w, y + h);
1084              d.draw(c);
1085              d.setBounds(oldBounds); // Restore the bounds
1086              c.setBitmap(null);
1087          }
1088      }
1089      private Bitmap getShortcutPreview(ResolveInfo info) {
1090          // Render the background
1091          int offset = 0;
1092          int bitmapSize = mAppIconSize;
1093          Bitmap preview = Bitmap.createBitmap(bitmapSize, bitmapSize, Config.ARGB_8888);
1094  
1095          // Render the icon
1096          Drawable icon = mIconCache.getFullResIcon(info);
1097          renderDrawableToBitmap(icon, preview, offset, offset, mAppIconSize, mAppIconSize);
1098          return preview;
1099      }
1100  
1101      private Bitmap getWidgetPreview(ComponentName provider, int previewImage, int iconId,
1102              int cellHSpan, int cellVSpan, int maxWidth, int maxHeight) {
1103          // Load the preview image if possible
1104          String packageName = provider.getPackageName();
1105          if (maxWidth &lt; 0) maxWidth = Integer.MAX_VALUE;
1106          if (maxHeight &lt; 0) maxHeight = Integer.MAX_VALUE;
1107  
1108          Drawable drawable = null;
1109          if (previewImage != 0) {
1110              drawable = mPackageManager.getDrawable(packageName, previewImage, null);
1111              if (drawable == null) {
1112                  Log.w(LOG_TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
1113                          Integer.toHexString(previewImage) + &quot; for provider: &quot; + provider);
1114              }
1115          }
1116  
1117          int bitmapWidth;
1118          int bitmapHeight;
1119          boolean widgetPreviewExists = (drawable != null);
1120          if (widgetPreviewExists) {
1121              bitmapWidth = drawable.getIntrinsicWidth();
1122              bitmapHeight = drawable.getIntrinsicHeight();
1123          } else {
1124              if (cellHSpan &lt; 1) cellHSpan = 1;
1125              if (cellVSpan &lt; 1) cellVSpan = 1;
1126              // Determine the size of the bitmap for the preview image we will generate
1127              // TODO: This actually uses the apps customize cell layout params, where as we make want
1128              // the Workspace params for more accuracy.
1129              bitmapWidth = mWidgetSpacingLayout.estimateCellWidth(cellHSpan);
1130              bitmapHeight = mWidgetSpacingLayout.estimateCellHeight(cellVSpan);
1131              if (cellHSpan == cellVSpan) {
1132                  // For square widgets, we just have a fixed size for 1x1 and larger-than-1x1
1133                  int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1134                  if (cellHSpan &lt;= 1) {
1135                      bitmapWidth = bitmapHeight = mAppIconSize + 2 * minOffset;
1136                  } else {
1137                      bitmapWidth = bitmapHeight = mAppIconSize + 4 * minOffset;
1138                  }
1139              }
1140          }
1141  
1142          float scale = 1f;
1143          if (bitmapWidth &gt; maxWidth) {
1144              scale = maxWidth / (float) bitmapWidth;
1145          }
1146          if (bitmapHeight * scale &gt; maxHeight) {
1147              scale = maxHeight / (float) bitmapHeight;
1148          }
1149          if (scale != 1f) {
1150              bitmapWidth = (int) (scale * bitmapWidth);
1151              bitmapHeight = (int) (scale * bitmapHeight);
1152          }
1153  
1154          Bitmap preview = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Config.ARGB_8888);
1155  
1156          if (widgetPreviewExists) {
1157              renderDrawableToBitmap(drawable, preview, 0, 0, bitmapWidth, bitmapHeight);
1158          } else {
1159              // Generate a preview image if we couldn&#x27;t load one
1160              int minOffset = (int) (mAppIconSize * sWidgetPreviewIconPaddingPercentage);
1161              int smallestSide = Math.min(bitmapWidth, bitmapHeight);
1162              float iconScale = Math.min((float) smallestSide / (mAppIconSize + 2 * minOffset), 1f);
1163              if (cellHSpan != 1 || cellVSpan != 1) {
1164                  renderDrawableToBitmap(mDefaultWidgetBackground, preview, 0, 0, bitmapWidth,
1165                          bitmapHeight);
1166              }
1167  
1168              // Draw the icon in the top left corner
1169              try {
1170                  Drawable icon = null;
1171                  int hoffset = (int) (bitmapWidth / 2 - mAppIconSize * iconScale / 2);
1172                  int yoffset = (int) (bitmapHeight / 2 - mAppIconSize * iconScale / 2);
1173                  if (iconId &gt; 0) icon = mIconCache.getFullResIcon(packageName, iconId);
1174                  Resources resources = mLauncher.getResources();
1175                  if (icon == null) icon = resources.getDrawable(R.drawable.ic_launcher_application);
1176  
1177                  renderDrawableToBitmap(icon, preview, hoffset, yoffset,
1178                          (int) (mAppIconSize * iconScale),
1179                          (int) (mAppIconSize * iconScale));
1180              } catch (Resources.NotFoundException e) {}
1181          }
1182          return preview;
1183      }
1184  
1185      public void syncWidgetPageItems(final int page, final boolean immediate) {
1186          int numItemsPerPage = mWidgetCountX * mWidgetCountY;
1187  
1188          // Calculate the dimensions of each cell we are giving to each widget
1189          final ArrayList&lt;Object&gt; items = new ArrayList&lt;Object&gt;();
1190          int contentWidth = mWidgetSpacingLayout.getContentWidth();
1191          final int cellWidth = ((contentWidth - mPageLayoutPaddingLeft - mPageLayoutPaddingRight
1192                  - ((mWidgetCountX - 1) * mWidgetWidthGap)) / mWidgetCountX);
1193          int contentHeight = mWidgetSpacingLayout.getContentHeight();
1194          final int cellHeight = ((contentHeight - mPageLayoutPaddingTop - mPageLayoutPaddingBottom
1195                  - ((mWidgetCountY - 1) * mWidgetHeightGap)) / mWidgetCountY);
1196  
1197          // Prepare the set of widgets to load previews for in the background
1198          int offset = (page - mNumAppsPages) * numItemsPerPage;
1199          for (int i = offset; i &lt; Math.min(offset + numItemsPerPage, mWidgets.size()); ++i) {
1200              items.add(mWidgets.get(i));
1201          }
1202  
1203          // Prepopulate the pages with the other widget info, and fill in the previews later
1204          final PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1205          layout.setColumnCount(layout.getCellCountX());
1206          for (int i = 0; i &lt; items.size(); ++i) {
1207              Object rawInfo = items.get(i);
1208              PendingAddItemInfo createItemInfo = null;
1209              PagedViewWidget widget = (PagedViewWidget) mLayoutInflater.inflate(
1210                      R.layout.apps_customize_widget, layout, false);
1211              if (rawInfo instanceof AppWidgetProviderInfo) {
1212                  // Fill in the widget information
1213                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
1214                  createItemInfo = new PendingAddWidgetInfo(info, null, null);
1215  
1216                  // Determine the widget spans and min resize spans.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1217 -                int[] spanXY = mLauncher.getSpanForWidget(info, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1218 +                int[] spanXY = mLauncher.getSpanForWidget(info);</span>
1219                  int[] size = mLauncher.getWorkspace().estimateItemSize(spanXY[0],
1220                          spanXY[1], createItemInfo, true);

1221                  createItemInfo.spanX = spanXY[0];
1222                  createItemInfo.spanY = spanXY[1];
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1223 -                int[] minSpanXY = mLauncher.getMinSpanForWidget(info, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1224 +                int[] minSpanXY = mLauncher.getMinSpanForWidget(info);</span>
1225                  createItemInfo.minSpanX = minSpanXY[0];
1226                  createItemInfo.minSpanY = minSpanXY[1];
1227  
1228                  widget.applyFromAppWidgetProviderInfo(info, -1, spanXY);
1229                  widget.setTag(createItemInfo);
1230                  widget.setShortPressListener(this);
1231              } else if (rawInfo instanceof ResolveInfo) {
1232                  // Fill in the shortcuts information
1233                  ResolveInfo info = (ResolveInfo) rawInfo;
1234                  createItemInfo = new PendingAddItemInfo();
1235                  createItemInfo.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
1236                  createItemInfo.componentName = new ComponentName(info.activityInfo.packageName,
1237                          info.activityInfo.name);
1238                  widget.applyFromResolveInfo(mPackageManager, info);
1239                  widget.setTag(createItemInfo);
1240              }
1241              widget.setOnClickListener(this);
1242              widget.setOnLongClickListener(this);
1243              widget.setOnTouchListener(this);
1244              widget.setOnKeyListener(this);
1245  
1246              // Layout each widget
1247              int ix = i % mWidgetCountX;
1248              int iy = i / mWidgetCountX;
1249              GridLayout.LayoutParams lp = new GridLayout.LayoutParams(
1250                      GridLayout.spec(iy, GridLayout.LEFT),
1251                      GridLayout.spec(ix, GridLayout.TOP));
1252              lp.width = cellWidth;
1253              lp.height = cellHeight;
1254              lp.setGravity(Gravity.TOP | Gravity.LEFT);
1255              if (ix &gt; 0) lp.leftMargin = mWidgetWidthGap;
1256              if (iy &gt; 0) lp.topMargin = mWidgetHeightGap;
1257              layout.addView(widget, lp);
1258          }
1259  
1260          // wait until a call on onLayout to start loading, because
1261          // PagedViewWidget.getPreviewSize() will return 0 if it hasn&#x27;t been laid out
1262          // TODO: can we do a measure/layout immediately?
1263          layout.setOnLayoutListener(new Runnable() {
1264              public void run() {
1265                  // Load the widget previews
1266                  int maxPreviewWidth = cellWidth;
1267                  int maxPreviewHeight = cellHeight;
1268                  if (layout.getChildCount() &gt; 0) {
1269                      PagedViewWidget w = (PagedViewWidget) layout.getChildAt(0);
1270                      int[] maxSize = w.getPreviewSize();
1271                      maxPreviewWidth = maxSize[0];
1272                      maxPreviewHeight = maxSize[1];
1273                  }
1274                  if (immediate) {
1275                      AsyncTaskPageData data = new AsyncTaskPageData(page, items,
1276                              maxPreviewWidth, maxPreviewHeight, null, null);
1277                      loadWidgetPreviewsInBackground(null, data);
1278                      onSyncWidgetPageItems(data);
1279                  } else {
1280                      prepareLoadWidgetPreviewsTask(page, items,
1281                              maxPreviewWidth, maxPreviewHeight, mWidgetCountX);
1282                  }
1283              }
1284          });
1285      }
1286      private void loadWidgetPreviewsInBackground(AppsCustomizeAsyncTask task,
1287              AsyncTaskPageData data) {
1288          // loadWidgetPreviewsInBackground can be called without a task to load a set of widget
1289          // previews synchronously
1290          if (task != null) {
1291              // Ensure that this task starts running at the correct priority
1292              task.syncThreadPriority();
1293          }
1294  
1295          // Load each of the widget/shortcut previews
1296          ArrayList&lt;Object&gt; items = data.items;
1297          ArrayList&lt;Bitmap&gt; images = data.generatedImages;
1298          int count = items.size();
1299          for (int i = 0; i &lt; count; ++i) {
1300              if (task != null) {
1301                  // Ensure we haven&#x27;t been cancelled yet
1302                  if (task.isCancelled()) break;
1303                  // Before work on each item, ensure that this task is running at the correct
1304                  // priority
1305                  task.syncThreadPriority();
1306              }
1307  
1308              Object rawInfo = items.get(i);
1309              if (rawInfo instanceof AppWidgetProviderInfo) {
1310                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) rawInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1311 -                int[] cellSpans = mLauncher.getSpanForWidget(info, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1312 +                int[] cellSpans = mLauncher.getSpanForWidget(info);</span>
1313  
1314                  int maxWidth = Math.min(data.maxImageWidth,
1315                          mWidgetSpacingLayout.estimateCellWidth(cellSpans[0]));
1316                  int maxHeight = Math.min(data.maxImageHeight,
1317                          mWidgetSpacingLayout.estimateCellHeight(cellSpans[1]));
1318                  Bitmap b = getWidgetPreview(info.provider, info.previewImage, info.icon,
1319                          cellSpans[0], cellSpans[1], maxWidth, maxHeight);
1320                  images.add(b);
1321              } else if (rawInfo instanceof ResolveInfo) {
1322                  // Fill in the shortcuts information
1323                  ResolveInfo info = (ResolveInfo) rawInfo;
1324                  images.add(getShortcutPreview(info));
1325              }
1326          }
1327      }
1328  
1329      private void onSyncWidgetPageItems(AsyncTaskPageData data) {
1330          if (mInTransition) {
1331              mDeferredSyncWidgetPageItems.add(data);
1332              return;
1333          }
1334          try {
1335              int page = data.page;
1336              PagedViewGridLayout layout = (PagedViewGridLayout) getPageAt(page);
1337  
1338              ArrayList&lt;Object&gt; items = data.items;
1339              int count = items.size();
1340              for (int i = 0; i &lt; count; ++i) {
1341                  PagedViewWidget widget = (PagedViewWidget) layout.getChildAt(i);
1342                  if (widget != null) {
1343                      Bitmap preview = data.generatedImages.get(i);
1344                      widget.applyPreview(new FastBitmapDrawable(preview), i);
1345                  }
1346              }
1347  
1348              layout.createHardwareLayer();
1349              invalidate();
1350  
1351              // Update all thread priorities
1352              Iterator&lt;AppsCustomizeAsyncTask&gt; iter = mRunningTasks.iterator();
1353              while (iter.hasNext()) {
1354                  AppsCustomizeAsyncTask task = (AppsCustomizeAsyncTask) iter.next();
1355                  int pageIndex = task.page;
1356                  task.setThreadPriority(getThreadPriorityForPage(pageIndex));
1357              }
1358          } finally {
1359              data.cleanup(false);
1360          }
1361      }
1362  
1363      @Override
1364      public void syncPages() {
1365          removeAllViews();
1366          cancelAllTasks();
1367  
1368          Context context = getContext();
1369          for (int j = 0; j &lt; mNumWidgetPages; ++j) {
1370              PagedViewGridLayout layout = new PagedViewGridLayout(context, mWidgetCountX,
1371                      mWidgetCountY);
1372              setupPage(layout);
1373              addView(layout, new PagedView.LayoutParams(LayoutParams.MATCH_PARENT,
1374                      LayoutParams.MATCH_PARENT));
1375          }
1376  
1377          for (int i = 0; i &lt; mNumAppsPages; ++i) {
1378              PagedViewCellLayout layout = new PagedViewCellLayout(context);
1379              setupPage(layout);
1380              addView(layout);
1381          }
1382      }
1383  
1384      @Override
1385      public void syncPageItems(int page, boolean immediate) {
1386          if (page &lt; mNumAppsPages) {
1387              syncAppsPageItems(page, immediate);
1388          } else {
1389              syncWidgetPageItems(page, immediate);
1390          }
1391      }
1392  
1393      // We want our pages to be z-ordered such that the further a page is to the left, the higher
1394      // it is in the z-order. This is important to insure touch events are handled correctly.
1395      View getPageAt(int index) {
1396          return getChildAt(indexToPage(index));
1397      }
1398  
1399      @Override
1400      protected int indexToPage(int index) {
1401          return getChildCount() - index - 1;
1402      }
1403  
1404      // In apps customize, we have a scrolling effect which emulates pulling cards off of a stack.
1405      @Override
1406      protected void screenScrolled(int screenCenter) {
1407          super.screenScrolled(screenCenter);
1408  
1409          for (int i = 0; i &lt; getChildCount(); i++) {
1410              View v = getPageAt(i);
1411              if (v != null) {
1412                  float scrollProgress = getScrollProgress(screenCenter, v, i);
1413  
1414                  float interpolatedProgress =
1415                          mZInterpolator.getInterpolation(Math.abs(Math.min(scrollProgress, 0)));
1416                  float scale = (1 - interpolatedProgress) +
1417                          interpolatedProgress * TRANSITION_SCALE_FACTOR;
1418                  float translationX = Math.min(0, scrollProgress) * v.getMeasuredWidth();
1419  
1420                  float alpha;
1421  
1422                  if (!LauncherApplication.isScreenLarge() || scrollProgress &lt; 0) {
1423                      alpha = scrollProgress &lt; 0 ? mAlphaInterpolator.getInterpolation(
1424                          1 - Math.abs(scrollProgress)) : 1.0f;
1425                  } else {
1426                      // On large screens we need to fade the page as it nears its leftmost position
1427                      alpha = mLeftScreenAlphaInterpolator.getInterpolation(1 - scrollProgress);
1428                  }
1429  
1430                  v.setCameraDistance(mDensity * CAMERA_DISTANCE);
1431                  int pageWidth = v.getMeasuredWidth();
1432                  int pageHeight = v.getMeasuredHeight();
1433  
1434                  if (PERFORM_OVERSCROLL_ROTATION) {
1435                      if (i == 0 &amp;&amp; scrollProgress &lt; 0) {
1436                          // Overscroll to the left
1437                          v.setPivotX(TRANSITION_PIVOT * pageWidth);
1438                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1439                          scale = 1.0f;
1440                          alpha = 1.0f;
1441                          // On the first page, we don&#x27;t want the page to have any lateral motion
1442                          translationX = 0;
1443                      } else if (i == getChildCount() - 1 &amp;&amp; scrollProgress &gt; 0) {
1444                          // Overscroll to the right
1445                          v.setPivotX((1 - TRANSITION_PIVOT) * pageWidth);
1446                          v.setRotationY(-TRANSITION_MAX_ROTATION * scrollProgress);
1447                          scale = 1.0f;
1448                          alpha = 1.0f;
1449                          // On the last page, we don&#x27;t want the page to have any lateral motion.
1450                          translationX = 0;
1451                      } else {
1452                          v.setPivotY(pageHeight / 2.0f);
1453                          v.setPivotX(pageWidth / 2.0f);
1454                          v.setRotationY(0f);
1455                      }
1456                  }
1457  
1458                  v.setTranslationX(translationX);
1459                  v.setScaleX(scale);
1460                  v.setScaleY(scale);
1461                  v.setAlpha(alpha);
1462  
1463                  // If the view has 0 alpha, we set it to be invisible so as to prevent
1464                  // it from accepting touches
1465                  if (alpha &lt; ViewConfiguration.ALPHA_THRESHOLD) {
1466                      v.setVisibility(INVISIBLE);
1467                  } else if (v.getVisibility() != VISIBLE) {
1468                      v.setVisibility(VISIBLE);
1469                  }
1470              }
1471          }
1472      }
1473  
1474      protected void overScroll(float amount) {
1475          acceleratedOverScroll(amount);
1476      }
1477  
1478      /**
1479       * Used by the parent to get the content width to set the tab bar to
1480       * @return
1481       */
1482      public int getPageContentWidth() {
1483          return mContentWidth;
1484      }
1485  
1486      @Override
1487      protected void onPageEndMoving() {
1488          super.onPageEndMoving();
1489  
1490          // We reset the save index when we change pages so that it will be recalculated on next
1491          // rotation
1492          mSaveInstanceStateItemIndex = -1;
1493      }
1494  
1495      /*
1496       * AllAppsView implementation
1497       */
1498      @Override
1499      public void setup(Launcher launcher, DragController dragController) {
1500          mLauncher = launcher;
1501          mDragController = dragController;
1502      }
1503      @Override
1504      public void zoom(float zoom, boolean animate) {
1505          // TODO-APPS_CUSTOMIZE: Call back to mLauncher.zoomed()
1506      }
1507      @Override
1508      public boolean isVisible() {
1509          return (getVisibility() == VISIBLE);
1510      }
1511      @Override
1512      public boolean isAnimating() {
1513          return false;
1514      }
1515      @Override
1516      public void setApps(ArrayList&lt;ApplicationInfo&gt; list) {
1517          mApps = list;
1518          Collections.sort(mApps, LauncherModel.APP_NAME_COMPARATOR);
1519          updatePageCounts();
1520  
1521          // The next layout pass will trigger data-ready if both widgets and apps are set, so
1522          // request a layout to do this test and invalidate the page data when ready.
1523          if (testDataReady()) requestLayout();
1524      }
1525      private void addAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1526          // We add it in place, in alphabetical order
1527          int count = list.size();
1528          for (int i = 0; i &lt; count; ++i) {
1529              ApplicationInfo info = list.get(i);
1530              int index = Collections.binarySearch(mApps, info, LauncherModel.APP_NAME_COMPARATOR);
1531              if (index &lt; 0) {
1532                  mApps.add(-(index + 1), info);
1533              }
1534          }
1535      }
1536      @Override
1537      public void addApps(ArrayList&lt;ApplicationInfo&gt; list) {
1538          addAppsWithoutInvalidate(list);
1539          updatePageCounts();
1540          invalidatePageData();
1541      }
1542      private int findAppByComponent(List&lt;ApplicationInfo&gt; list, ApplicationInfo item) {
1543          ComponentName removeComponent = item.intent.getComponent();
1544          int length = list.size();
1545          for (int i = 0; i &lt; length; ++i) {
1546              ApplicationInfo info = list.get(i);
1547              if (info.intent.getComponent().equals(removeComponent)) {
1548                  return i;
1549              }
1550          }
1551          return -1;
1552      }
1553      private void removeAppsWithoutInvalidate(ArrayList&lt;ApplicationInfo&gt; list) {
1554          // loop through all the apps and remove apps that have the same component
1555          int length = list.size();
1556          for (int i = 0; i &lt; length; ++i) {
1557              ApplicationInfo info = list.get(i);
1558              int removeIndex = findAppByComponent(mApps, info);
1559              if (removeIndex &gt; -1) {
1560                  mApps.remove(removeIndex);
1561              }
1562          }
1563      }
1564      @Override
1565      public void removeApps(ArrayList&lt;ApplicationInfo&gt; list) {
1566          removeAppsWithoutInvalidate(list);
1567          updatePageCounts();
1568          invalidatePageData();
1569      }
1570      @Override
1571      public void updateApps(ArrayList&lt;ApplicationInfo&gt; list) {
1572          // We remove and re-add the updated applications list because it&#x27;s properties may have
1573          // changed (ie. the title), and this will ensure that the items will be in their proper
1574          // place in the list.
1575          removeAppsWithoutInvalidate(list);
1576          addAppsWithoutInvalidate(list);
1577          updatePageCounts();
1578  
1579          invalidatePageData();
1580      }
1581  
1582      @Override
1583      public void reset() {
1584          // If we have reset, then we should not continue to restore the previous state
1585          mSaveInstanceStateItemIndex = -1;
1586  
1587          AppsCustomizeTabHost tabHost = getTabHost();
1588          String tag = tabHost.getCurrentTabTag();
1589          if (tag != null) {
1590              if (!tag.equals(tabHost.getTabTagForContentType(ContentType.Applications))) {
1591                  tabHost.setCurrentTabFromContent(ContentType.Applications);
1592              }
1593          }
1594  
1595          if (mCurrentPage != 0) {
1596              invalidatePageData(0);
1597          }
1598      }
1599  
1600      private AppsCustomizeTabHost getTabHost() {
1601          return (AppsCustomizeTabHost) mLauncher.findViewById(R.id.apps_customize_pane);
1602      }
1603  
1604      @Override
1605      public void dumpState() {
1606          // TODO: Dump information related to current list of Applications, Widgets, etc.
1607          ApplicationInfo.dumpApplicationInfoList(LOG_TAG, &quot;mApps&quot;, mApps);
1608          dumpAppWidgetProviderInfoList(LOG_TAG, &quot;mWidgets&quot;, mWidgets);
1609      }
1610  
1611      private void dumpAppWidgetProviderInfoList(String tag, String label,
1612              ArrayList&lt;Object&gt; list) {
1613          Log.d(tag, label + &quot; size=&quot; + list.size());
1614          for (Object i: list) {
1615              if (i instanceof AppWidgetProviderInfo) {
1616                  AppWidgetProviderInfo info = (AppWidgetProviderInfo) i;
1617                  Log.d(tag, &quot;   label=\&quot;&quot; + info.label + &quot;\&quot; previewImage=&quot; + info.previewImage
1618                          + &quot; resizeMode=&quot; + info.resizeMode + &quot; configure=&quot; + info.configure
1619                          + &quot; initialLayout=&quot; + info.initialLayout
1620                          + &quot; minWidth=&quot; + info.minWidth + &quot; minHeight=&quot; + info.minHeight);
1621              } else if (i instanceof ResolveInfo) {
1622                  ResolveInfo info = (ResolveInfo) i;
1623                  Log.d(tag, &quot;   label=\&quot;&quot; + info.loadLabel(mPackageManager) + &quot;\&quot; icon=&quot;
1624                          + info.icon);
1625              }
1626          }
1627      }
1628  
1629      @Override
1630      public void surrender() {
1631          // TODO: If we are in the middle of any process (ie. for holographic outlines, etc) we
1632          // should stop this now.
1633  
1634          // Stop all background tasks
1635          cancelAllTasks();
1636      }
1637  
1638      @Override
1639      public void iconPressed(PagedViewIcon icon) {
1640          // Reset the previously pressed icon and store a reference to the pressed icon so that
1641          // we can reset it on return to Launcher (in Launcher.onResume())
1642          if (mPressedIcon != null) {
1643              mPressedIcon.resetDrawableState();
1644          }
1645          mPressedIcon = icon;
1646      }
1647  
1648      public void resetDrawableState() {
1649          if (mPressedIcon != null) {
1650              mPressedIcon.resetDrawableState();
1651              mPressedIcon = null;
1652          }
1653      }
1654  
1655      /*
1656       * We load an extra page on each side to prevent flashes from scrolling and loading of the
1657       * widget previews in the background with the AsyncTasks.
1658       */
1659      final static int sLookBehindPageCount = 2;
1660      final static int sLookAheadPageCount = 2;
1661      protected int getAssociatedLowerPageBound(int page) {
1662          final int count = getChildCount();
1663          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1664          int windowMinIndex = Math.max(Math.min(page - sLookBehindPageCount, count - windowSize), 0);
1665          return windowMinIndex;
1666      }
1667      protected int getAssociatedUpperPageBound(int page) {
1668          final int count = getChildCount();
1669          int windowSize = Math.min(count, sLookBehindPageCount + sLookAheadPageCount + 1);
1670          int windowMaxIndex = Math.min(Math.max(page + sLookAheadPageCount, windowSize - 1),
1671                  count - 1);
1672          return windowMaxIndex;
1673      }
1674  
1675      @Override
1676      protected String getCurrentPageDescription() {
1677          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
1678          int stringId = R.string.default_scroll_format;
1679          int count = 0;
1680  
1681          if (page &lt; mNumAppsPages) {
1682              stringId = R.string.apps_customize_apps_scroll_format;
1683              count = mNumAppsPages;
1684          } else {
1685              page -= mNumAppsPages;
1686              stringId = R.string.apps_customize_widgets_scroll_format;
1687              count = mNumWidgetPages;
1688          }
1689  
1690          return String.format(mContext.getString(stringId), page + 1, count);
1691      }
1692  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            