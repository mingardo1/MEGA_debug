<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>248</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    248
                    <a href="247.html">prev</a>
                    <a href="249.html">next</a>
                    <a href="248_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_2975e34145b38e44dc8a7def2617e3fe0d15321d_src/com/android/launcher3/WidgetPreviewLoader.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2975e34145b38e44dc8a7def2617e3fe0d15321d:src/com/android/launcher3/WidgetPreviewLoader.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2975e34145b38e44dc8a7def2617e3fe0d15321d^1:src/com/android/launcher3/WidgetPreviewLoader.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;2975e34145b38e44dc8a7def2617e3fe0d15321d^2:src/com/android/launcher3/WidgetPreviewLoader.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;268b8907d1f2fcf9775880c69899b3c6fbe85ea3:src/com/android/launcher3/WidgetPreviewLoader.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [bj], [s], [s]], subset: [[sbj], [bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetProviderInfo;
   4 import android.content.ComponentName;
   5 import android.content.ContentValues;
   6 import android.content.Context;
   7 import android.content.SharedPreferences;
   8 import android.content.pm.ResolveInfo;
   9 import android.content.res.Resources;
  10 import android.database.Cursor;
  11 import android.database.sqlite.SQLiteCantOpenDatabaseException;
  12 import android.database.sqlite.SQLiteDatabase;
  13 import android.database.sqlite.SQLiteDiskIOException;
  14 import android.database.sqlite.SQLiteOpenHelper;
  15 import android.database.sqlite.SQLiteReadOnlyDatabaseException;
  16 import android.graphics.Bitmap;
  17 import android.graphics.Bitmap.Config;
  18 import android.graphics.BitmapFactory;
  19 import android.graphics.BitmapShader;
  20 import android.graphics.Canvas;
  21 import android.graphics.ColorMatrix;
  22 import android.graphics.ColorMatrixColorFilter;
  23 import android.graphics.Paint;
  24 import android.graphics.PorterDuff;
  25 import android.graphics.Rect;
  26 import android.graphics.Shader;
  27 import android.graphics.drawable.BitmapDrawable;
  28 import android.graphics.drawable.Drawable;
  29 import android.os.AsyncTask;
  30 import android.os.Build;
  31 import android.util.Log;
  32 import com.android.launcher3.compat.AppWidgetManagerCompat;
  33 
  34 import java.io.ByteArrayOutputStream;
  35 import java.io.File;
  36 import java.io.IOException;
  37 import java.lang.ref.SoftReference;
  38 import java.lang.ref.WeakReference;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.HashMap;
  42 import java.util.HashSet;
  43 import java.util.List;
  44 import java.util.concurrent.Callable;
  45 import java.util.concurrent.ExecutionException;
  46 
  47 public class WidgetPreviewLoader {
  48 
  49     private static abstract class SoftReferenceThreadLocal&lt;T&gt; {
  50         private ThreadLocal&lt;SoftReference&lt;T&gt;&gt; mThreadLocal;
  51         public SoftReferenceThreadLocal() {
  52             mThreadLocal = new ThreadLocal&lt;SoftReference&lt;T&gt;&gt;();
  53         }
  54 
  55         abstract T initialValue();
  56 
  57         public void set(T t) {
  58             mThreadLocal.set(new SoftReference&lt;T&gt;(t));
  59         }
  60 
  61         public T get() {
  62             SoftReference&lt;T&gt; reference = mThreadLocal.get();
  63             T obj;
  64             if (reference == null) {
  65                 obj = initialValue();
  66                 mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  67                 return obj;
  68             } else {
  69                 obj = reference.get();
  70                 if (obj == null) {
  71                     obj = initialValue();
  72                     mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  73                 }
  74                 return obj;
  75             }
  76         }
  77     }
  78 
  79     private static class CanvasCache extends SoftReferenceThreadLocal&lt;Canvas&gt; {
  80         @Override
  81         protected Canvas initialValue() {
  82             return new Canvas();
  83         }
  84     }
  85 
  86     private static class PaintCache extends SoftReferenceThreadLocal&lt;Paint&gt; {
  87         @Override
  88         protected Paint initialValue() {
  89             return null;
  90         }
  91     }
  92 
  93     private static class BitmapCache extends SoftReferenceThreadLocal&lt;Bitmap&gt; {
  94         @Override
  95         protected Bitmap initialValue() {
  96             return null;
  97         }
  98     }
  99 
 100     private static class RectCache extends SoftReferenceThreadLocal&lt;Rect&gt; {
 101         @Override
 102         protected Rect initialValue() {
 103             return new Rect();
 104         }
 105     }
 106 
 107     private static class BitmapFactoryOptionsCache extends
 108             SoftReferenceThreadLocal&lt;BitmapFactory.Options&gt; {
 109         @Override
 110         protected BitmapFactory.Options initialValue() {
 111             return new BitmapFactory.Options();
 112         }
 113     }
 114 
 115     private static final String TAG = &quot;WidgetPreviewLoader&quot;;
 116     private static final String ANDROID_INCREMENTAL_VERSION_NAME_KEY = &quot;android.incremental.version&quot;;
 117 
 118     private static final float WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE = 0.25f;
 119     private static final HashSet&lt;String&gt; sInvalidPackages = new HashSet&lt;String&gt;();
 120 
 121     // Used for drawing shortcut previews
 122     private final BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 123     private final PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 124     private final CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 125 
 126     // Used for drawing widget previews
 127     private final CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 128     private final RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 129     private final RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 130     private final PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 131     private final PaintCache mDefaultAppWidgetPreviewPaint = new PaintCache();
<abbr title=" 132     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache();"> 132     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache()ðŸ”µ</abbr>
 133 
<abbr title=" 134     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt;();"> 134     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakRefereðŸ”µ</abbr>
<abbr title=" 135     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;();"> 135     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;(ðŸ”µ</abbr>
 136 
 137     private final Context mContext;
 138     private final int mAppIconSize;
 139     private final IconCache mIconCache;
 140     private final AppWidgetManagerCompat mManager;
 141 
 142     private int mPreviewBitmapWidth;
 143     private int mPreviewBitmapHeight;
 144     private String mSize;
 145     private PagedViewCellLayout mWidgetSpacingLayout;
 146 
 147     private String mCachedSelectQuery;
 148 
 149 
 150     private CacheDb mDb;
 151 
 152     private final MainThreadExecutor mMainThreadExecutor = new MainThreadExecutor();
 153 
 154     public WidgetPreviewLoader(Context context) {
 155         LauncherAppState app = LauncherAppState.getInstance();
 156         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 157 
 158         mContext = context;
 159         mAppIconSize = grid.iconSizePx;
 160         mIconCache = app.getIconCache();
 161         mManager = AppWidgetManagerCompat.getInstance(context);
 162 
 163         mDb = app.getWidgetPreviewCacheDb();
 164 
 165         SharedPreferences sp = context.getSharedPreferences(
 166                 LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
 167         final String lastVersionName = sp.getString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, null);
 168         final String versionName = android.os.Build.VERSION.INCREMENTAL;
 169 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 170         final boolean isLollipop = Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP;</span>
 171 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172             // clear all the previews whenever the system version changes, to ensure that previews</span>
 173 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 174         final boolean isLollipopOrGreater = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>
 175 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 176         if (!versionName.equals(lastVersionName)) {
 177             try {
 178                 // clear all the previews whenever the system version changes, to ensure that
 179                 // previews are up-to-date for any apps that might have been updated with the system
 180                 clearDb();
 181             } catch (SQLiteReadOnlyDatabaseException e) {
 182 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 183                 if (isLollipop) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 184                     // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 185                     // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 186                 } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 187                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 188                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 189             } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 190                 throw e;</span>
 191 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195     public void recreateDb() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196         LauncherAppState app = LauncherAppState.getInstance();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 197         app.recreateWidgetPreviewDb();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198         mDb = app.getWidgetPreviewCacheDb();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199     }</span>
 200 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 201                 if (isLollipopOrGreater) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 202                     // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 203                     // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 204                 } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 205                     throw e;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 206                 }</span>
 207 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 208             } finally {
 209                 SharedPreferences.Editor editor = sp.edit();
 210                 editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);
 211                 editor.commit();
 212             }
 213         }
 214     }
 215 
 216     public void recreateDb() {
 217         LauncherAppState app = LauncherAppState.getInstance();
 218         app.recreateWidgetPreviewDb();
 219         mDb = app.getWidgetPreviewCacheDb();
 220     }
 221 
 222     public void setPreviewSize(int previewWidth, int previewHeight,
 223             PagedViewCellLayout widgetSpacingLayout) {
 224         mPreviewBitmapWidth = previewWidth;
 225         mPreviewBitmapHeight = previewHeight;
 226         mSize = previewWidth + &quot;x&quot; + previewHeight;
 227         mWidgetSpacingLayout = widgetSpacingLayout;
 228     }
 229 
 230     public Bitmap getPreview(final Object o) {
 231         final String name = getObjectName(o);
 232         final String packageName = getObjectPackage(o);
 233         // check if the package is valid
 234         synchronized(sInvalidPackages) {
 235             boolean packageValid = !sInvalidPackages.contains(packageName);
 236             if (!packageValid) {
 237                 return null;
 238             }
 239         }
 240         synchronized(mLoadedPreviews) {
 241             // check if it exists in our existing cache
 242             if (mLoadedPreviews.containsKey(name)) {
 243                 WeakReference&lt;Bitmap&gt; bitmapReference = mLoadedPreviews.get(name);
 244                 Bitmap bitmap = bitmapReference.get();
 245                 if (bitmap != null) {
 246                     return bitmap;
 247                 }
 248             }
 249         }
 250 
 251         Bitmap unusedBitmap = null;
 252         synchronized(mUnusedBitmaps) {
 253             // not in cache; we need to load it from the db
 254             while (unusedBitmap == null &amp;&amp; mUnusedBitmaps.size() &gt; 0) {
 255                 Bitmap candidate = mUnusedBitmaps.remove(0).get();
 256                 if (candidate != null &amp;&amp; candidate.isMutable() &amp;&amp;
 257                         candidate.getWidth() == mPreviewBitmapWidth &amp;&amp;
 258                         candidate.getHeight() == mPreviewBitmapHeight) {
 259                     unusedBitmap = candidate;
 260                 }
 261             }
 262             if (unusedBitmap != null) {
 263                 final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 264                 c.setBitmap(unusedBitmap);
 265                 c.drawColor(0, PorterDuff.Mode.CLEAR);
 266                 c.setBitmap(null);
 267             }
 268         }
 269 
 270         if (unusedBitmap == null) {
 271             unusedBitmap = Bitmap.createBitmap(mPreviewBitmapWidth, mPreviewBitmapHeight,
 272                     Bitmap.Config.ARGB_8888);
 273         }
 274         Bitmap preview = readFromDb(name, unusedBitmap);
 275 
 276         if (preview != null) {
 277             synchronized(mLoadedPreviews) {
 278                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 279             }
 280             return preview;
 281         } else {
 282             // it&#x27;s not in the db... we need to generate it
 283             final Bitmap generatedPreview = generatePreview(o, unusedBitmap);
 284             preview = generatedPreview;
 285             if (preview != unusedBitmap) {
 286                 throw new RuntimeException(&quot;generatePreview is not recycling the bitmap &quot; + o);
 287             }
 288 
 289             synchronized(mLoadedPreviews) {
 290                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 291             }
 292 
 293             // write to db on a thread pool... this can be done lazily and improves the performance
 294             // of the first time widget previews are loaded
 295             new AsyncTask&lt;Void, Void, Void&gt;() {
 296                 public Void doInBackground(Void ... args) {
 297                     writeToDb(o, generatedPreview);
 298                     return null;
 299                 }
 300             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 301 
 302             return preview;
 303         }
 304     }
 305 
 306     public void recycleBitmap(Object o, Bitmap bitmapToRecycle) {
 307         String name = getObjectName(o);
 308         synchronized (mLoadedPreviews) {
 309             if (mLoadedPreviews.containsKey(name)) {
 310                 Bitmap b = mLoadedPreviews.get(name).get();
 311                 if (b == bitmapToRecycle) {
 312                     mLoadedPreviews.remove(name);
 313                     if (bitmapToRecycle.isMutable()) {
 314                         synchronized (mUnusedBitmaps) {
 315                             mUnusedBitmaps.add(new SoftReference&lt;Bitmap&gt;(b));
 316                         }
 317                     }
 318                 } else {
 319                     throw new RuntimeException(&quot;Bitmap passed in doesn&#x27;t match up&quot;);
 320                 }
 321             }
 322         }
 323     }
 324 
 325     static class CacheDb extends SQLiteOpenHelper {
 326         final static int DB_VERSION = 2;
 327         final static String TABLE_NAME = &quot;shortcut_and_widget_previews&quot;;
 328         final static String COLUMN_NAME = &quot;name&quot;;
 329         final static String COLUMN_SIZE = &quot;size&quot;;
 330         final static String COLUMN_PREVIEW_BITMAP = &quot;preview_bitmap&quot;;
 331         Context mContext;
 332 
 333         public CacheDb(Context context) {
 334             super(context, new File(context.getCacheDir(),
 335                     LauncherFiles.WIDGET_PREVIEWS_DB).getPath(), null, DB_VERSION);
 336             // Store the context for later use
 337             mContext = context;
 338         }
 339 
 340         @Override
 341         public void onCreate(SQLiteDatabase database) {
 342             database.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME + &quot; (&quot; +
 343                     COLUMN_NAME + &quot; TEXT NOT NULL, &quot; +
 344                     COLUMN_SIZE + &quot; TEXT NOT NULL, &quot; +
 345                     COLUMN_PREVIEW_BITMAP + &quot; BLOB NOT NULL, &quot; +
 346                     &quot;PRIMARY KEY (&quot; + COLUMN_NAME + &quot;, &quot; + COLUMN_SIZE + &quot;) &quot; +
 347                     &quot;);&quot;);
 348         }
 349 
 350         @Override
 351         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 352             if (oldVersion != newVersion) {
 353                 // Delete all the records; they&#x27;ll be repopulated as this is a cache
 354                 db.execSQL(&quot;DELETE FROM &quot; + TABLE_NAME);
 355             }
 356         }
 357     }
 358 
 359     private static final String WIDGET_PREFIX = &quot;Widget:&quot;;
 360     private static final String SHORTCUT_PREFIX = &quot;Shortcut:&quot;;
 361 
 362     private static String getObjectName(Object o) {
 363         // should cache the string builder
 364         StringBuilder sb = new StringBuilder();
 365         String output;
 366         if (o instanceof AppWidgetProviderInfo) {
 367             sb.append(WIDGET_PREFIX);
 368             sb.append(((AppWidgetProviderInfo) o).toString());
 369             output = sb.toString();
 370             sb.setLength(0);
 371         } else {
 372             sb.append(SHORTCUT_PREFIX);
 373 
 374             ResolveInfo info = (ResolveInfo) o;
 375             sb.append(new ComponentName(info.activityInfo.packageName,
 376                     info.activityInfo.name).flattenToString());
 377             output = sb.toString();
 378             sb.setLength(0);
 379         }
 380         return output;
 381     }
 382 
 383     private String getObjectPackage(Object o) {
 384         if (o instanceof AppWidgetProviderInfo) {
 385             return ((AppWidgetProviderInfo) o).provider.getPackageName();
 386         } else {
 387             ResolveInfo info = (ResolveInfo) o;
 388             return info.activityInfo.packageName;
 389         }
 390     }
 391 
 392     private void writeToDb(Object o, Bitmap preview) {
 393         String name = getObjectName(o);
 394         SQLiteDatabase db = mDb.getWritableDatabase();
 395         ContentValues values = new ContentValues();
 396 
 397         values.put(CacheDb.COLUMN_NAME, name);
 398         ByteArrayOutputStream stream = new ByteArrayOutputStream();
 399         preview.compress(Bitmap.CompressFormat.PNG, 100, stream);
 400         values.put(CacheDb.COLUMN_PREVIEW_BITMAP, stream.toByteArray());
 401         values.put(CacheDb.COLUMN_SIZE, mSize);
 402         try {
 403             db.insert(CacheDb.TABLE_NAME, null, values);
 404         } catch (SQLiteDiskIOException e) {
 405             recreateDb();
 406         } catch (SQLiteCantOpenDatabaseException e) {
 407             dumpOpenFiles();
 408             throw e;
 409         }
 410     }
 411 
 412     private void clearDb() {
 413         SQLiteDatabase db = mDb.getWritableDatabase();
 414         // Delete everything
 415         try {
 416             db.delete(CacheDb.TABLE_NAME, null, null);
 417         } catch (SQLiteDiskIOException e) {
 418         } catch (SQLiteCantOpenDatabaseException e) {
 419             dumpOpenFiles();
 420             throw e;
 421         }
 422     }
 423 
 424     public static void removePackageFromDb(final CacheDb cacheDb, final String packageName) {
 425         synchronized(sInvalidPackages) {
 426             sInvalidPackages.add(packageName);
 427         }
 428         new AsyncTask&lt;Void, Void, Void&gt;() {
 429             public Void doInBackground(Void ... args) {
 430                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 431                 try {
 432                     db.delete(CacheDb.TABLE_NAME,
 433                             CacheDb.COLUMN_NAME + &quot; LIKE ? OR &quot; +
 434                             CacheDb.COLUMN_NAME + &quot; LIKE ?&quot;, // SELECT query
 435                             new String[] {
 436                                     WIDGET_PREFIX + packageName + &quot;/%&quot;,
 437                                     SHORTCUT_PREFIX + packageName + &quot;/%&quot;
 438                             } // args to SELECT query
 439                     );
 440                 } catch (SQLiteDiskIOException e) {
 441                 } catch (SQLiteCantOpenDatabaseException e) {
 442                     dumpOpenFiles();
 443                     throw e;
 444                 }
 445                 synchronized(sInvalidPackages) {
 446                     sInvalidPackages.remove(packageName);
 447                 }
 448                 return null;
 449             }
 450         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 451     }
 452 
 453     private static void removeItemFromDb(final CacheDb cacheDb, final String objectName) {
 454         new AsyncTask&lt;Void, Void, Void&gt;() {
 455             public Void doInBackground(Void ... args) {
 456                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 457                 try {
 458                     db.delete(CacheDb.TABLE_NAME,
 459                             CacheDb.COLUMN_NAME + &quot; = ? &quot;, // SELECT query
 460                             new String[] { objectName }); // args to SELECT query
 461                 } catch (SQLiteDiskIOException e) {
 462                 } catch (SQLiteCantOpenDatabaseException e) {
 463                     dumpOpenFiles();
 464                     throw e;
 465                 }
 466                 return null;
 467             }
 468         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 469     }
 470 
 471     private Bitmap readFromDb(String name, Bitmap b) {
 472         if (mCachedSelectQuery == null) {
 473             mCachedSelectQuery = CacheDb.COLUMN_NAME + &quot; = ? AND &quot; +
 474                     CacheDb.COLUMN_SIZE + &quot; = ?&quot;;
 475         }
 476         SQLiteDatabase db = mDb.getReadableDatabase();
 477         Cursor result;
 478         try {
 479             result = db.query(CacheDb.TABLE_NAME,
 480                     new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, // cols to return
 481                     mCachedSelectQuery, // select query
 482                     new String[] { name, mSize }, // args to select query
 483                     null,
 484                     null,
 485                     null,
 486                     null);
 487         } catch (SQLiteDiskIOException e) {
 488             recreateDb();
 489             return null;
 490         } catch (SQLiteCantOpenDatabaseException e) {
 491             dumpOpenFiles();
 492             throw e;
 493         }
 494         if (result.getCount() &gt; 0) {
 495             result.moveToFirst();
 496             byte[] blob = result.getBlob(0);
 497             result.close();
 498             final BitmapFactory.Options opts = mCachedBitmapFactoryOptions.get();
 499             opts.inBitmap = b;
 500             opts.inSampleSize = 1;
 501             try {
 502                 return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);
 503             } catch (IllegalArgumentException e) {
 504                 removeItemFromDb(mDb, name);
 505                 return null;
 506             }
 507         } else {
 508             result.close();
 509             return null;
 510         }
 511     }
 512 
 513     private Bitmap generatePreview(Object info, Bitmap preview) {
 514         if (preview != null &amp;&amp;
 515                 (preview.getWidth() != mPreviewBitmapWidth ||
 516                 preview.getHeight() != mPreviewBitmapHeight)) {
 517             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 518         }
 519         if (info instanceof AppWidgetProviderInfo) {
 520             return generateWidgetPreview((AppWidgetProviderInfo) info, preview);
 521         } else {
 522             return generateShortcutPreview(
 523                     (ResolveInfo) info, mPreviewBitmapWidth, mPreviewBitmapHeight, preview);
 524         }
 525     }
 526 
 527     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, Bitmap preview) {
 528         int[] cellSpans = Launcher.getSpanForWidget(mContext, info);
 529         int maxWidth = maxWidthForWidgetPreview(cellSpans[0]);
 530         int maxHeight = maxHeightForWidgetPreview(cellSpans[1]);
 531         return generateWidgetPreview(info, cellSpans[0], cellSpans[1],
 532                 maxWidth, maxHeight, preview, null);
 533     }
 534 
 535     public int maxWidthForWidgetPreview(int spanX) {
 536         return Math.min(mPreviewBitmapWidth,
 537                 mWidgetSpacingLayout.estimateCellWidth(spanX));
 538     }
 539 
 540     public int maxHeightForWidgetPreview(int spanY) {
 541         return Math.min(mPreviewBitmapHeight,
 542                 mWidgetSpacingLayout.estimateCellHeight(spanY));
 543     }
 544 
 545     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, int cellHSpan, int cellVSpan,
 546             int maxPreviewWidth, int maxPreviewHeight, Bitmap preview, int[] preScaledWidthOut) {
 547         // Load the preview image if possible
 548         if (maxPreviewWidth &lt; 0) maxPreviewWidth = Integer.MAX_VALUE;
 549         if (maxPreviewHeight &lt; 0) maxPreviewHeight = Integer.MAX_VALUE;
 550 
 551         Drawable drawable = null;
 552         if (info.previewImage != 0) {
 553             drawable = mManager.loadPreview(info);
 554             if (drawable != null) {
 555                 drawable = mutateOnMainThread(drawable);
 556             } else {
 557                 Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
 558                         Integer.toHexString(info.previewImage) + &quot; for provider: &quot; + info.provider);
 559             }
 560         }
 561 
 562         int previewWidth;
 563         int previewHeight;
 564         Bitmap defaultPreview = null;
 565         boolean widgetPreviewExists = (drawable != null);
 566         if (widgetPreviewExists) {
 567             previewWidth = drawable.getIntrinsicWidth();
 568             previewHeight = drawable.getIntrinsicHeight();
 569         } else {
 570             // Generate a preview image if we couldn&#x27;t load one
 571             if (cellHSpan &lt; 1) cellHSpan = 1;
 572             if (cellVSpan &lt; 1) cellVSpan = 1;
 573 
 574             // This Drawable is not directly drawn, so there&#x27;s no need to mutate it.
 575             BitmapDrawable previewDrawable = (BitmapDrawable) mContext.getResources()
 576                     .getDrawable(R.drawable.widget_tile);
 577             final int previewDrawableWidth = previewDrawable
 578                     .getIntrinsicWidth();
 579             final int previewDrawableHeight = previewDrawable
 580                     .getIntrinsicHeight();
 581             previewWidth = previewDrawableWidth * cellHSpan;
 582             previewHeight = previewDrawableHeight * cellVSpan;
 583 
 584             defaultPreview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 585             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 586             c.setBitmap(defaultPreview);
 587             Paint p = mDefaultAppWidgetPreviewPaint.get();
 588             if (p == null) {
 589                 p = new Paint();
 590                 p.setShader(new BitmapShader(previewDrawable.getBitmap(),
 591                         Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
 592                 mDefaultAppWidgetPreviewPaint.set(p);
 593             }
 594             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 595             dest.set(0, 0, previewWidth, previewHeight);
 596             c.drawRect(dest, p);
 597             c.setBitmap(null);
 598 
 599             // Draw the icon in the top left corner
 600             int minOffset = (int) (mAppIconSize * WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE);
 601             int smallestSide = Math.min(previewWidth, previewHeight);
 602             float iconScale = Math.min((float) smallestSide
 603                     / (mAppIconSize + 2 * minOffset), 1f);
 604 
 605             try {
 606                 Drawable icon = mManager.loadIcon(info, mIconCache);
 607                 if (icon != null) {
 608                     int hoffset = (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
 609                     int yoffset = (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
 610                     icon = mutateOnMainThread(icon);
 611                     renderDrawableToBitmap(icon, defaultPreview, hoffset,
 612                             yoffset, (int) (mAppIconSize * iconScale),
 613                             (int) (mAppIconSize * iconScale));
 614                 }
 615             } catch (Resources.NotFoundException e) {
 616             }
 617         }
 618 
 619         // Scale to fit width only - let the widget preview be clipped in the
 620         // vertical dimension
 621         float scale = 1f;
 622         if (preScaledWidthOut != null) {
 623             preScaledWidthOut[0] = previewWidth;
 624         }
 625         if (previewWidth &gt; maxPreviewWidth) {
 626             scale = maxPreviewWidth / (float) previewWidth;
 627         }
 628         if (scale != 1f) {
 629             previewWidth = (int) (scale * previewWidth);
 630             previewHeight = (int) (scale * previewHeight);
 631         }
 632 
 633         // If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size
 634         if (preview == null) {
 635             preview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 636         }
 637 
 638         // Draw the scaled preview into the final bitmap
 639         int x = (preview.getWidth() - previewWidth) / 2;
 640         if (widgetPreviewExists) {
 641             renderDrawableToBitmap(drawable, preview, x, 0, previewWidth,
 642                     previewHeight);
 643         } else {
 644             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 645             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
 646             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 647             c.setBitmap(preview);
 648             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
 649             dest.set(x, 0, x + previewWidth, previewHeight);
 650 
 651             Paint p = mCachedAppWidgetPreviewPaint.get();
 652             if (p == null) {
 653                 p = new Paint();
 654                 p.setFilterBitmap(true);
 655                 mCachedAppWidgetPreviewPaint.set(p);
 656             }
 657             c.drawBitmap(defaultPreview, src, dest, p);
 658             c.setBitmap(null);
 659         }
 660         return mManager.getBadgeBitmap(info, preview);
 661     }
 662 
 663     private Bitmap generateShortcutPreview(
 664             ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview) {
 665         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
 666         final Canvas c = mCachedShortcutPreviewCanvas.get();
 667         if (tempBitmap == null ||
 668                 tempBitmap.getWidth() != maxWidth ||
 669                 tempBitmap.getHeight() != maxHeight) {
 670             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 671             mCachedShortcutPreviewBitmap.set(tempBitmap);
 672         } else {
 673             c.setBitmap(tempBitmap);
 674             c.drawColor(0, PorterDuff.Mode.CLEAR);
 675             c.setBitmap(null);
 676         }
 677         // Render the icon
 678         Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info.activityInfo));
 679 
 680         int paddingTop = mContext.
 681                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
 682         int paddingLeft = mContext.
 683                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
 684         int paddingRight = mContext.
 685                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
 686 
 687         int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
 688 
 689         renderDrawableToBitmap(
 690                 icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
 691 
 692         if (preview != null &amp;&amp;
 693                 (preview.getWidth() != maxWidth || preview.getHeight() != maxHeight)) {
 694             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 695         } else if (preview == null) {
 696             preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 697         }
 698 
 699         c.setBitmap(preview);
 700         // Draw a desaturated/scaled version of the icon in the background as a watermark
 701         Paint p = mCachedShortcutPreviewPaint.get();
 702         if (p == null) {
 703             p = new Paint();
 704             ColorMatrix colorMatrix = new ColorMatrix();
 705             colorMatrix.setSaturation(0);
 706             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
 707             p.setAlpha((int) (255 * 0.06f));
 708             mCachedShortcutPreviewPaint.set(p);
 709         }
 710         c.drawBitmap(tempBitmap, 0, 0, p);
 711         c.setBitmap(null);
 712 
 713         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
 714 
 715         return preview;
 716     }
 717 
 718     private static void renderDrawableToBitmap(
 719             Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
 720         if (bitmap != null) {
 721             Canvas c = new Canvas(bitmap);
 722             Rect oldBounds = d.copyBounds();
 723             d.setBounds(x, y, x + w, y + h);
 724             d.draw(c);
 725             d.setBounds(oldBounds); // Restore the bounds
 726             c.setBitmap(null);
 727         }
 728     }
 729 
 730     private Drawable mutateOnMainThread(final Drawable drawable) {
 731         try {
 732             return mMainThreadExecutor.submit(new Callable&lt;Drawable&gt;() {
 733                 @Override
 734                 public Drawable call() throws Exception {
 735                     return drawable.mutate();
 736                 }
 737             }).get();
 738         } catch (InterruptedException e) {
 739             Thread.currentThread().interrupt();
 740             throw new RuntimeException(e);
 741         } catch (ExecutionException e) {
 742             throw new RuntimeException(e);
 743         }
 744     }
 745 
 746     private static final int MAX_OPEN_FILES = 1024;
 747     private static final int SAMPLE_RATE = 23;
 748     /**
 749      * Dumps all files that are open in this process without allocating a file descriptor.
 750      */
 751     private static void dumpOpenFiles() {
 752         try {
 753             Log.i(TAG, &quot;DUMP OF OPEN FILES (sample rate: 1 every &quot; + SAMPLE_RATE + &quot;):&quot;);
 754             final String TYPE_APK = &quot;apk&quot;;
 755             final String TYPE_JAR = &quot;jar&quot;;
 756             final String TYPE_PIPE = &quot;pipe&quot;;
 757             final String TYPE_SOCKET = &quot;socket&quot;;
 758             final String TYPE_DB = &quot;db&quot;;
 759             final String TYPE_ANON_INODE = &quot;anon_inode&quot;;
 760             final String TYPE_DEV = &quot;dev&quot;;
 761             final String TYPE_NON_FS = &quot;non-fs&quot;;
 762             final String TYPE_OTHER = &quot;other&quot;;
 763             List&lt;String&gt; types = Arrays.asList(TYPE_APK, TYPE_JAR, TYPE_PIPE, TYPE_SOCKET, TYPE_DB,
 764                     TYPE_ANON_INODE, TYPE_DEV, TYPE_NON_FS, TYPE_OTHER);
 765             int[] count = new int[types.size()];
 766             int[] duplicates = new int[types.size()];
 767             HashSet&lt;String&gt; files = new HashSet&lt;String&gt;();
 768             int total = 0;
 769             for (int i = 0; i &lt; MAX_OPEN_FILES; i++) {
 770                 // This is a gigantic hack but unfortunately the only way to resolve an fd
 771                 // to a file name. Note that we have to loop over all possible fds because
 772                 // reading the directory would require allocating a new fd. The kernel is
 773                 // currently implemented such that no fd is larger then the current rlimit,
 774                 // which is why it&#x27;s safe to loop over them in such a way.
 775                 String fd = &quot;/proc/self/fd/&quot; + i;
 776                 try {
 777                     // getCanonicalPath() uses readlink behind the scene which doesn&#x27;t require
 778                     // a file descriptor.
 779                     String resolved = new File(fd).getCanonicalPath();
 780                     int type = types.indexOf(TYPE_OTHER);
 781                     if (resolved.startsWith(&quot;/dev/&quot;)) {
 782                         type = types.indexOf(TYPE_DEV);
 783                     } else if (resolved.endsWith(&quot;.apk&quot;)) {
 784                         type = types.indexOf(TYPE_APK);
 785                     } else if (resolved.endsWith(&quot;.jar&quot;)) {
 786                         type = types.indexOf(TYPE_JAR);
 787                     } else if (resolved.contains(&quot;/fd/pipe:&quot;)) {
 788                         type = types.indexOf(TYPE_PIPE);
 789                     } else if (resolved.contains(&quot;/fd/socket:&quot;)) {
 790                         type = types.indexOf(TYPE_SOCKET);
 791                     } else if (resolved.contains(&quot;/fd/anon_inode:&quot;)) {
 792                         type = types.indexOf(TYPE_ANON_INODE);
 793                     } else if (resolved.endsWith(&quot;.db&quot;) || resolved.contains(&quot;/databases/&quot;)) {
 794                         type = types.indexOf(TYPE_DB);
 795                     } else if (resolved.startsWith(&quot;/proc/&quot;) &amp;&amp; resolved.contains(&quot;/fd/&quot;)) {
 796                         // Those are the files that don&#x27;t point anywhere on the file system.
 797                         // getCanonicalPath() wrongly interprets these as relative symlinks and
 798                         // resolves them within /proc/&lt;pid&gt;/fd/.
 799                         type = types.indexOf(TYPE_NON_FS);
 800                     }
 801                     count[type]++;
 802                     total++;
 803                     if (files.contains(resolved)) {
 804                         duplicates[type]++;
 805                     }
 806                     files.add(resolved);
 807                     if (total % SAMPLE_RATE == 0) {
 808                         Log.i(TAG, &quot; fd &quot; + i + &quot;: &quot; + resolved
 809                                 + &quot; (&quot; + types.get(type) + &quot;)&quot;);
 810                     }
 811                 } catch (IOException e) {
 812                     // Ignoring exceptions for non-existing file descriptors.
 813                 }
 814             }
 815             for (int i = 0; i &lt; types.size(); i++) {
 816                 Log.i(TAG, String.format(&quot;Open %10s files: %4d total, %4d duplicates&quot;,
 817                         types.get(i), count[i], duplicates[i]));
 818             }
 819         } catch (Throwable t) {
 820             // Catch everything. This is called from an exception handler that we shouldn&#x27;t upset.
 821             Log.e(TAG, &quot;Unable to log open files.&quot;, t);
 822         }
 823     }
 824 }
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetProviderInfo;
   4 import android.content.ComponentName;
   5 import android.content.ContentValues;
   6 import android.content.Context;
   7 import android.content.SharedPreferences;
   8 import android.content.pm.ResolveInfo;
   9 import android.content.res.Resources;
  10 import android.database.Cursor;
  11 import android.database.sqlite.SQLiteCantOpenDatabaseException;
  12 import android.database.sqlite.SQLiteDatabase;
  13 import android.database.sqlite.SQLiteDiskIOException;
  14 import android.database.sqlite.SQLiteOpenHelper;
  15 import android.database.sqlite.SQLiteReadOnlyDatabaseException;
  16 import android.graphics.Bitmap;
  17 import android.graphics.Bitmap.Config;
  18 import android.graphics.BitmapFactory;
  19 import android.graphics.BitmapShader;
  20 import android.graphics.Canvas;
  21 import android.graphics.ColorMatrix;
  22 import android.graphics.ColorMatrixColorFilter;
  23 import android.graphics.Paint;
  24 import android.graphics.PorterDuff;
  25 import android.graphics.Rect;
  26 import android.graphics.Shader;
  27 import android.graphics.drawable.BitmapDrawable;
  28 import android.graphics.drawable.Drawable;
  29 import android.os.AsyncTask;
  30 import android.os.Build;
  31 import android.util.Log;
  32 import com.android.launcher3.compat.AppWidgetManagerCompat;
  33 
  34 import java.io.ByteArrayOutputStream;
  35 import java.io.File;
  36 import java.io.IOException;
  37 import java.lang.ref.SoftReference;
  38 import java.lang.ref.WeakReference;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.HashMap;
  42 import java.util.HashSet;
  43 import java.util.List;
  44 import java.util.concurrent.Callable;
  45 import java.util.concurrent.ExecutionException;
  46 
  47 public class WidgetPreviewLoader {
  48 
  49     private static abstract class SoftReferenceThreadLocal&lt;T&gt; {
  50         private ThreadLocal&lt;SoftReference&lt;T&gt;&gt; mThreadLocal;
  51         public SoftReferenceThreadLocal() {
  52             mThreadLocal = new ThreadLocal&lt;SoftReference&lt;T&gt;&gt;();
  53         }
  54 
  55         abstract T initialValue();
  56 
  57         public void set(T t) {
  58             mThreadLocal.set(new SoftReference&lt;T&gt;(t));
  59         }
  60 
  61         public T get() {
  62             SoftReference&lt;T&gt; reference = mThreadLocal.get();
  63             T obj;
  64             if (reference == null) {
  65                 obj = initialValue();
  66                 mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  67                 return obj;
  68             } else {
  69                 obj = reference.get();
  70                 if (obj == null) {
  71                     obj = initialValue();
  72                     mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  73                 }
  74                 return obj;
  75             }
  76         }
  77     }
  78 
  79     private static class CanvasCache extends SoftReferenceThreadLocal&lt;Canvas&gt; {
  80         @Override
  81         protected Canvas initialValue() {
  82             return new Canvas();
  83         }
  84     }
  85 
  86     private static class PaintCache extends SoftReferenceThreadLocal&lt;Paint&gt; {
  87         @Override
  88         protected Paint initialValue() {
  89             return null;
  90         }
  91     }
  92 
  93     private static class BitmapCache extends SoftReferenceThreadLocal&lt;Bitmap&gt; {
  94         @Override
  95         protected Bitmap initialValue() {
  96             return null;
  97         }
  98     }
  99 
 100     private static class RectCache extends SoftReferenceThreadLocal&lt;Rect&gt; {
 101         @Override
 102         protected Rect initialValue() {
 103             return new Rect();
 104         }
 105     }
 106 
 107     private static class BitmapFactoryOptionsCache extends
 108             SoftReferenceThreadLocal&lt;BitmapFactory.Options&gt; {
 109         @Override
 110         protected BitmapFactory.Options initialValue() {
 111             return new BitmapFactory.Options();
 112         }
 113     }
 114 
 115     private static final String TAG = &quot;WidgetPreviewLoader&quot;;
 116     private static final String ANDROID_INCREMENTAL_VERSION_NAME_KEY = &quot;android.incremental.version&quot;;
 117 
 118     private static final float WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE = 0.25f;
 119     private static final HashSet&lt;String&gt; sInvalidPackages = new HashSet&lt;String&gt;();
 120 
 121     // Used for drawing shortcut previews
 122     private final BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 123     private final PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 124     private final CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 125 
 126     // Used for drawing widget previews
 127     private final CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 128     private final RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 129     private final RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 130     private final PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 131     private final PaintCache mDefaultAppWidgetPreviewPaint = new PaintCache();
<abbr title=" 132     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache();"> 132     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache()ðŸ”µ</abbr>
 133 
<abbr title=" 134     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt;();"> 134     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakRefereðŸ”µ</abbr>
<abbr title=" 135     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;();"> 135     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;(ðŸ”µ</abbr>
 136 
 137     private final Context mContext;
 138     private final int mAppIconSize;
 139     private final IconCache mIconCache;
 140     private final AppWidgetManagerCompat mManager;
 141 
 142     private int mPreviewBitmapWidth;
 143     private int mPreviewBitmapHeight;
 144     private String mSize;
 145     private PagedViewCellLayout mWidgetSpacingLayout;
 146 
 147     private String mCachedSelectQuery;
 148 
 149 
 150     private CacheDb mDb;
 151 
 152     private final MainThreadExecutor mMainThreadExecutor = new MainThreadExecutor();
 153 
 154     public WidgetPreviewLoader(Context context) {
 155         LauncherAppState app = LauncherAppState.getInstance();
 156         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 157 
 158         mContext = context;
 159         mAppIconSize = grid.iconSizePx;
 160         mIconCache = app.getIconCache();
 161         mManager = AppWidgetManagerCompat.getInstance(context);
 162 
 163         mDb = app.getWidgetPreviewCacheDb();
 164 
 165         SharedPreferences sp = context.getSharedPreferences(
 166                 LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
 167         final String lastVersionName = sp.getString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, null);
 168         final String versionName = android.os.Build.VERSION.INCREMENTAL;
 169 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 170         final boolean isLollipop = Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP;</span>
 171 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 172         if (!versionName.equals(lastVersionName)) {</span>
 173 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 174         final boolean isLollipopOrGreater = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>
 175 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 176         if (!versionName.equals(lastVersionName)) {
 177             try {
 178                 // clear all the previews whenever the system version changes, to ensure that
 179                 // previews are up-to-date for any apps that might have been updated with the system
 180             clearDb();
 181             } catch (SQLiteReadOnlyDatabaseException e) {
 182 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 183                 if (isLollipop) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 184                     // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 185                     // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 186                 } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 187                     throw e;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 188                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 189             } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 190                 throw e;</span>
 191 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192             editor.commit();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193         }</span>
 194 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 195                 if (isLollipopOrGreater) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 196                     // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 197                     // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 198                 } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 199                     throw e;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 200                 }</span>
 201 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 202             } finally {
 203             SharedPreferences.Editor editor = sp.edit();
 204             editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);
 205             editor.commit();
 206         }
 207     }
 208     }
 209 
 210     public void recreateDb() {
 211         LauncherAppState app = LauncherAppState.getInstance();
 212         app.recreateWidgetPreviewDb();
 213         mDb = app.getWidgetPreviewCacheDb();
 214     }
 215 
 216     public void setPreviewSize(int previewWidth, int previewHeight,
 217             PagedViewCellLayout widgetSpacingLayout) {
 218         mPreviewBitmapWidth = previewWidth;
 219         mPreviewBitmapHeight = previewHeight;
 220         mSize = previewWidth + &quot;x&quot; + previewHeight;
 221         mWidgetSpacingLayout = widgetSpacingLayout;
 222     }
 223 
 224     public Bitmap getPreview(final Object o) {
 225         final String name = getObjectName(o);
 226         final String packageName = getObjectPackage(o);
 227         // check if the package is valid
 228         synchronized(sInvalidPackages) {
 229             boolean packageValid = !sInvalidPackages.contains(packageName);
 230             if (!packageValid) {
 231                 return null;
 232             }
 233         }
 234         synchronized(mLoadedPreviews) {
 235             // check if it exists in our existing cache
 236             if (mLoadedPreviews.containsKey(name)) {
 237                 WeakReference&lt;Bitmap&gt; bitmapReference = mLoadedPreviews.get(name);
 238                 Bitmap bitmap = bitmapReference.get();
 239                 if (bitmap != null) {
 240                     return bitmap;
 241                 }
 242             }
 243         }
 244 
 245         Bitmap unusedBitmap = null;
 246         synchronized(mUnusedBitmaps) {
 247             // not in cache; we need to load it from the db
 248             while (unusedBitmap == null &amp;&amp; mUnusedBitmaps.size() &gt; 0) {
 249                 Bitmap candidate = mUnusedBitmaps.remove(0).get();
 250                 if (candidate != null &amp;&amp; candidate.isMutable() &amp;&amp;
 251                         candidate.getWidth() == mPreviewBitmapWidth &amp;&amp;
 252                         candidate.getHeight() == mPreviewBitmapHeight) {
 253                     unusedBitmap = candidate;
 254                 }
 255             }
 256             if (unusedBitmap != null) {
 257                 final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 258                 c.setBitmap(unusedBitmap);
 259                 c.drawColor(0, PorterDuff.Mode.CLEAR);
 260                 c.setBitmap(null);
 261             }
 262         }
 263 
 264         if (unusedBitmap == null) {
 265             unusedBitmap = Bitmap.createBitmap(mPreviewBitmapWidth, mPreviewBitmapHeight,
 266                     Bitmap.Config.ARGB_8888);
 267         }
 268         Bitmap preview = readFromDb(name, unusedBitmap);
 269 
 270         if (preview != null) {
 271             synchronized(mLoadedPreviews) {
 272                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 273             }
 274             return preview;
 275         } else {
 276             // it&#x27;s not in the db... we need to generate it
 277             final Bitmap generatedPreview = generatePreview(o, unusedBitmap);
 278             preview = generatedPreview;
 279             if (preview != unusedBitmap) {
 280                 throw new RuntimeException(&quot;generatePreview is not recycling the bitmap &quot; + o);
 281             }
 282 
 283             synchronized(mLoadedPreviews) {
 284                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 285             }
 286 
 287             // write to db on a thread pool... this can be done lazily and improves the performance
 288             // of the first time widget previews are loaded
 289             new AsyncTask&lt;Void, Void, Void&gt;() {
 290                 public Void doInBackground(Void ... args) {
 291                     writeToDb(o, generatedPreview);
 292                     return null;
 293                 }
 294             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 295 
 296             return preview;
 297         }
 298     }
 299 
 300     public void recycleBitmap(Object o, Bitmap bitmapToRecycle) {
 301         String name = getObjectName(o);
 302         synchronized (mLoadedPreviews) {
 303             if (mLoadedPreviews.containsKey(name)) {
 304                 Bitmap b = mLoadedPreviews.get(name).get();
 305                 if (b == bitmapToRecycle) {
 306                     mLoadedPreviews.remove(name);
 307                     if (bitmapToRecycle.isMutable()) {
 308                         synchronized (mUnusedBitmaps) {
 309                             mUnusedBitmaps.add(new SoftReference&lt;Bitmap&gt;(b));
 310                         }
 311                     }
 312                 } else {
 313                     throw new RuntimeException(&quot;Bitmap passed in doesn&#x27;t match up&quot;);
 314                 }
 315             }
 316         }
 317     }
 318 
 319     static class CacheDb extends SQLiteOpenHelper {
 320         final static int DB_VERSION = 2;
 321         final static String TABLE_NAME = &quot;shortcut_and_widget_previews&quot;;
 322         final static String COLUMN_NAME = &quot;name&quot;;
 323         final static String COLUMN_SIZE = &quot;size&quot;;
 324         final static String COLUMN_PREVIEW_BITMAP = &quot;preview_bitmap&quot;;
 325         Context mContext;
 326 
 327         public CacheDb(Context context) {
 328             super(context, new File(context.getCacheDir(),
 329                     LauncherFiles.WIDGET_PREVIEWS_DB).getPath(), null, DB_VERSION);
 330             // Store the context for later use
 331             mContext = context;
 332         }
 333 
 334         @Override
 335         public void onCreate(SQLiteDatabase database) {
 336             database.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME + &quot; (&quot; +
 337                     COLUMN_NAME + &quot; TEXT NOT NULL, &quot; +
 338                     COLUMN_SIZE + &quot; TEXT NOT NULL, &quot; +
 339                     COLUMN_PREVIEW_BITMAP + &quot; BLOB NOT NULL, &quot; +
 340                     &quot;PRIMARY KEY (&quot; + COLUMN_NAME + &quot;, &quot; + COLUMN_SIZE + &quot;) &quot; +
 341                     &quot;);&quot;);
 342         }
 343 
 344         @Override
 345         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 346             if (oldVersion != newVersion) {
 347                 // Delete all the records; they&#x27;ll be repopulated as this is a cache
 348                 db.execSQL(&quot;DELETE FROM &quot; + TABLE_NAME);
 349             }
 350         }
 351     }
 352 
 353     private static final String WIDGET_PREFIX = &quot;Widget:&quot;;
 354     private static final String SHORTCUT_PREFIX = &quot;Shortcut:&quot;;
 355 
 356     private static String getObjectName(Object o) {
 357         // should cache the string builder
 358         StringBuilder sb = new StringBuilder();
 359         String output;
 360         if (o instanceof AppWidgetProviderInfo) {
 361             sb.append(WIDGET_PREFIX);
 362             sb.append(((AppWidgetProviderInfo) o).toString());
 363             output = sb.toString();
 364             sb.setLength(0);
 365         } else {
 366             sb.append(SHORTCUT_PREFIX);
 367 
 368             ResolveInfo info = (ResolveInfo) o;
 369             sb.append(new ComponentName(info.activityInfo.packageName,
 370                     info.activityInfo.name).flattenToString());
 371             output = sb.toString();
 372             sb.setLength(0);
 373         }
 374         return output;
 375     }
 376 
 377     private String getObjectPackage(Object o) {
 378         if (o instanceof AppWidgetProviderInfo) {
 379             return ((AppWidgetProviderInfo) o).provider.getPackageName();
 380         } else {
 381             ResolveInfo info = (ResolveInfo) o;
 382             return info.activityInfo.packageName;
 383         }
 384     }
 385 
 386     private void writeToDb(Object o, Bitmap preview) {
 387         String name = getObjectName(o);
 388         SQLiteDatabase db = mDb.getWritableDatabase();
 389         ContentValues values = new ContentValues();
 390 
 391         values.put(CacheDb.COLUMN_NAME, name);
 392         ByteArrayOutputStream stream = new ByteArrayOutputStream();
 393         preview.compress(Bitmap.CompressFormat.PNG, 100, stream);
 394         values.put(CacheDb.COLUMN_PREVIEW_BITMAP, stream.toByteArray());
 395         values.put(CacheDb.COLUMN_SIZE, mSize);
 396         try {
 397             db.insert(CacheDb.TABLE_NAME, null, values);
 398         } catch (SQLiteDiskIOException e) {
 399             recreateDb();
 400         } catch (SQLiteCantOpenDatabaseException e) {
 401             dumpOpenFiles();
 402             throw e;
 403         }
 404     }
 405 
 406     private void clearDb() {
 407         SQLiteDatabase db = mDb.getWritableDatabase();
 408         // Delete everything
 409         try {
 410             db.delete(CacheDb.TABLE_NAME, null, null);
 411         } catch (SQLiteDiskIOException e) {
 412         } catch (SQLiteCantOpenDatabaseException e) {
 413             dumpOpenFiles();
 414             throw e;
 415         }
 416     }
 417 
 418     public static void removePackageFromDb(final CacheDb cacheDb, final String packageName) {
 419         synchronized(sInvalidPackages) {
 420             sInvalidPackages.add(packageName);
 421         }
 422         new AsyncTask&lt;Void, Void, Void&gt;() {
 423             public Void doInBackground(Void ... args) {
 424                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 425                 try {
 426                     db.delete(CacheDb.TABLE_NAME,
 427                             CacheDb.COLUMN_NAME + &quot; LIKE ? OR &quot; +
 428                             CacheDb.COLUMN_NAME + &quot; LIKE ?&quot;, // SELECT query
 429                             new String[] {
 430                                     WIDGET_PREFIX + packageName + &quot;/%&quot;,
 431                                     SHORTCUT_PREFIX + packageName + &quot;/%&quot;
 432                             } // args to SELECT query
 433                     );
 434                 } catch (SQLiteDiskIOException e) {
 435                 } catch (SQLiteCantOpenDatabaseException e) {
 436                     dumpOpenFiles();
 437                     throw e;
 438                 }
 439                 synchronized(sInvalidPackages) {
 440                     sInvalidPackages.remove(packageName);
 441                 }
 442                 return null;
 443             }
 444         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 445     }
 446 
 447     private static void removeItemFromDb(final CacheDb cacheDb, final String objectName) {
 448         new AsyncTask&lt;Void, Void, Void&gt;() {
 449             public Void doInBackground(Void ... args) {
 450                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 451                 try {
 452                     db.delete(CacheDb.TABLE_NAME,
 453                             CacheDb.COLUMN_NAME + &quot; = ? &quot;, // SELECT query
 454                             new String[] { objectName }); // args to SELECT query
 455                 } catch (SQLiteDiskIOException e) {
 456                 } catch (SQLiteCantOpenDatabaseException e) {
 457                     dumpOpenFiles();
 458                     throw e;
 459                 }
 460                 return null;
 461             }
 462         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 463     }
 464 
 465     private Bitmap readFromDb(String name, Bitmap b) {
 466         if (mCachedSelectQuery == null) {
 467             mCachedSelectQuery = CacheDb.COLUMN_NAME + &quot; = ? AND &quot; +
 468                     CacheDb.COLUMN_SIZE + &quot; = ?&quot;;
 469         }
 470         SQLiteDatabase db = mDb.getReadableDatabase();
 471         Cursor result;
 472         try {
 473             result = db.query(CacheDb.TABLE_NAME,
 474                     new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, // cols to return
 475                     mCachedSelectQuery, // select query
 476                     new String[] { name, mSize }, // args to select query
 477                     null,
 478                     null,
 479                     null,
 480                     null);
 481         } catch (SQLiteDiskIOException e) {
 482             recreateDb();
 483             return null;
 484         } catch (SQLiteCantOpenDatabaseException e) {
 485             dumpOpenFiles();
 486             throw e;
 487         }
 488         if (result.getCount() &gt; 0) {
 489             result.moveToFirst();
 490             byte[] blob = result.getBlob(0);
 491             result.close();
 492             final BitmapFactory.Options opts = mCachedBitmapFactoryOptions.get();
 493             opts.inBitmap = b;
 494             opts.inSampleSize = 1;
 495             try {
 496                 return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);
 497             } catch (IllegalArgumentException e) {
 498                 removeItemFromDb(mDb, name);
 499                 return null;
 500             }
 501         } else {
 502             result.close();
 503             return null;
 504         }
 505     }
 506 
 507     private Bitmap generatePreview(Object info, Bitmap preview) {
 508         if (preview != null &amp;&amp;
 509                 (preview.getWidth() != mPreviewBitmapWidth ||
 510                 preview.getHeight() != mPreviewBitmapHeight)) {
 511             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 512         }
 513         if (info instanceof AppWidgetProviderInfo) {
 514             return generateWidgetPreview((AppWidgetProviderInfo) info, preview);
 515         } else {
 516             return generateShortcutPreview(
 517                     (ResolveInfo) info, mPreviewBitmapWidth, mPreviewBitmapHeight, preview);
 518         }
 519     }
 520 
 521     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, Bitmap preview) {
 522         int[] cellSpans = Launcher.getSpanForWidget(mContext, info);
 523         int maxWidth = maxWidthForWidgetPreview(cellSpans[0]);
 524         int maxHeight = maxHeightForWidgetPreview(cellSpans[1]);
 525         return generateWidgetPreview(info, cellSpans[0], cellSpans[1],
 526                 maxWidth, maxHeight, preview, null);
 527     }
 528 
 529     public int maxWidthForWidgetPreview(int spanX) {
 530         return Math.min(mPreviewBitmapWidth,
 531                 mWidgetSpacingLayout.estimateCellWidth(spanX));
 532     }
 533 
 534     public int maxHeightForWidgetPreview(int spanY) {
 535         return Math.min(mPreviewBitmapHeight,
 536                 mWidgetSpacingLayout.estimateCellHeight(spanY));
 537     }
 538 
 539     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, int cellHSpan, int cellVSpan,
 540             int maxPreviewWidth, int maxPreviewHeight, Bitmap preview, int[] preScaledWidthOut) {
 541         // Load the preview image if possible
 542         if (maxPreviewWidth &lt; 0) maxPreviewWidth = Integer.MAX_VALUE;
 543         if (maxPreviewHeight &lt; 0) maxPreviewHeight = Integer.MAX_VALUE;
 544 
 545         Drawable drawable = null;
 546         if (info.previewImage != 0) {
 547             drawable = mManager.loadPreview(info);
 548             if (drawable != null) {
 549                 drawable = mutateOnMainThread(drawable);
 550             } else {
 551                 Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
 552                         Integer.toHexString(info.previewImage) + &quot; for provider: &quot; + info.provider);
 553             }
 554         }
 555 
 556         int previewWidth;
 557         int previewHeight;
 558         Bitmap defaultPreview = null;
 559         boolean widgetPreviewExists = (drawable != null);
 560         if (widgetPreviewExists) {
 561             previewWidth = drawable.getIntrinsicWidth();
 562             previewHeight = drawable.getIntrinsicHeight();
 563         } else {
 564             // Generate a preview image if we couldn&#x27;t load one
 565             if (cellHSpan &lt; 1) cellHSpan = 1;
 566             if (cellVSpan &lt; 1) cellVSpan = 1;
 567 
 568             // This Drawable is not directly drawn, so there&#x27;s no need to mutate it.
 569             BitmapDrawable previewDrawable = (BitmapDrawable) mContext.getResources()
 570                     .getDrawable(R.drawable.widget_tile);
 571             final int previewDrawableWidth = previewDrawable
 572                     .getIntrinsicWidth();
 573             final int previewDrawableHeight = previewDrawable
 574                     .getIntrinsicHeight();
 575             previewWidth = previewDrawableWidth * cellHSpan;
 576             previewHeight = previewDrawableHeight * cellVSpan;
 577 
 578             defaultPreview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 579             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 580             c.setBitmap(defaultPreview);
 581             Paint p = mDefaultAppWidgetPreviewPaint.get();
 582             if (p == null) {
 583                 p = new Paint();
 584                 p.setShader(new BitmapShader(previewDrawable.getBitmap(),
 585                         Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
 586                 mDefaultAppWidgetPreviewPaint.set(p);
 587             }
 588             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 589             dest.set(0, 0, previewWidth, previewHeight);
 590             c.drawRect(dest, p);
 591             c.setBitmap(null);
 592 
 593             // Draw the icon in the top left corner
 594             int minOffset = (int) (mAppIconSize * WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE);
 595             int smallestSide = Math.min(previewWidth, previewHeight);
 596             float iconScale = Math.min((float) smallestSide
 597                     / (mAppIconSize + 2 * minOffset), 1f);
 598 
 599             try {
 600                 Drawable icon = mManager.loadIcon(info, mIconCache);
 601                 if (icon != null) {
 602                     int hoffset = (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
 603                     int yoffset = (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
 604                     icon = mutateOnMainThread(icon);
 605                     renderDrawableToBitmap(icon, defaultPreview, hoffset,
 606                             yoffset, (int) (mAppIconSize * iconScale),
 607                             (int) (mAppIconSize * iconScale));
 608                 }
 609             } catch (Resources.NotFoundException e) {
 610             }
 611         }
 612 
 613         // Scale to fit width only - let the widget preview be clipped in the
 614         // vertical dimension
 615         float scale = 1f;
 616         if (preScaledWidthOut != null) {
 617             preScaledWidthOut[0] = previewWidth;
 618         }
 619         if (previewWidth &gt; maxPreviewWidth) {
 620             scale = maxPreviewWidth / (float) previewWidth;
 621         }
 622         if (scale != 1f) {
 623             previewWidth = (int) (scale * previewWidth);
 624             previewHeight = (int) (scale * previewHeight);
 625         }
 626 
 627         // If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size
 628         if (preview == null) {
 629             preview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 630         }
 631 
 632         // Draw the scaled preview into the final bitmap
 633         int x = (preview.getWidth() - previewWidth) / 2;
 634         if (widgetPreviewExists) {
 635             renderDrawableToBitmap(drawable, preview, x, 0, previewWidth,
 636                     previewHeight);
 637         } else {
 638             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 639             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
 640             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 641             c.setBitmap(preview);
 642             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
 643             dest.set(x, 0, x + previewWidth, previewHeight);
 644 
 645             Paint p = mCachedAppWidgetPreviewPaint.get();
 646             if (p == null) {
 647                 p = new Paint();
 648                 p.setFilterBitmap(true);
 649                 mCachedAppWidgetPreviewPaint.set(p);
 650             }
 651             c.drawBitmap(defaultPreview, src, dest, p);
 652             c.setBitmap(null);
 653         }
 654         return mManager.getBadgeBitmap(info, preview);
 655     }
 656 
 657     private Bitmap generateShortcutPreview(
 658             ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview) {
 659         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
 660         final Canvas c = mCachedShortcutPreviewCanvas.get();
 661         if (tempBitmap == null ||
 662                 tempBitmap.getWidth() != maxWidth ||
 663                 tempBitmap.getHeight() != maxHeight) {
 664             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 665             mCachedShortcutPreviewBitmap.set(tempBitmap);
 666         } else {
 667             c.setBitmap(tempBitmap);
 668             c.drawColor(0, PorterDuff.Mode.CLEAR);
 669             c.setBitmap(null);
 670         }
 671         // Render the icon
 672         Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info.activityInfo));
 673 
 674         int paddingTop = mContext.
 675                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
 676         int paddingLeft = mContext.
 677                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
 678         int paddingRight = mContext.
 679                 getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
 680 
 681         int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
 682 
 683         renderDrawableToBitmap(
 684                 icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
 685 
 686         if (preview != null &amp;&amp;
 687                 (preview.getWidth() != maxWidth || preview.getHeight() != maxHeight)) {
 688             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 689         } else if (preview == null) {
 690             preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 691         }
 692 
 693         c.setBitmap(preview);
 694         // Draw a desaturated/scaled version of the icon in the background as a watermark
 695         Paint p = mCachedShortcutPreviewPaint.get();
 696         if (p == null) {
 697             p = new Paint();
 698             ColorMatrix colorMatrix = new ColorMatrix();
 699             colorMatrix.setSaturation(0);
 700             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
 701             p.setAlpha((int) (255 * 0.06f));
 702             mCachedShortcutPreviewPaint.set(p);
 703         }
 704         c.drawBitmap(tempBitmap, 0, 0, p);
 705         c.setBitmap(null);
 706 
 707         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
 708 
 709         return preview;
 710     }
 711 
 712     private static void renderDrawableToBitmap(
 713             Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
 714         if (bitmap != null) {
 715             Canvas c = new Canvas(bitmap);
 716             Rect oldBounds = d.copyBounds();
 717             d.setBounds(x, y, x + w, y + h);
 718             d.draw(c);
 719             d.setBounds(oldBounds); // Restore the bounds
 720             c.setBitmap(null);
 721         }
 722     }
 723 
 724     private Drawable mutateOnMainThread(final Drawable drawable) {
 725         try {
 726             return mMainThreadExecutor.submit(new Callable&lt;Drawable&gt;() {
 727                 @Override
 728                 public Drawable call() throws Exception {
 729                     return drawable.mutate();
 730                 }
 731             }).get();
 732         } catch (InterruptedException e) {
 733             Thread.currentThread().interrupt();
 734             throw new RuntimeException(e);
 735         } catch (ExecutionException e) {
 736             throw new RuntimeException(e);
 737         }
 738     }
 739 
 740     private static final int MAX_OPEN_FILES = 1024;
 741     private static final int SAMPLE_RATE = 23;
 742     /**
 743      * Dumps all files that are open in this process without allocating a file descriptor.
 744      */
 745     private static void dumpOpenFiles() {
 746         try {
 747             Log.i(TAG, &quot;DUMP OF OPEN FILES (sample rate: 1 every &quot; + SAMPLE_RATE + &quot;):&quot;);
 748             final String TYPE_APK = &quot;apk&quot;;
 749             final String TYPE_JAR = &quot;jar&quot;;
 750             final String TYPE_PIPE = &quot;pipe&quot;;
 751             final String TYPE_SOCKET = &quot;socket&quot;;
 752             final String TYPE_DB = &quot;db&quot;;
 753             final String TYPE_ANON_INODE = &quot;anon_inode&quot;;
 754             final String TYPE_DEV = &quot;dev&quot;;
 755             final String TYPE_NON_FS = &quot;non-fs&quot;;
 756             final String TYPE_OTHER = &quot;other&quot;;
 757             List&lt;String&gt; types = Arrays.asList(TYPE_APK, TYPE_JAR, TYPE_PIPE, TYPE_SOCKET, TYPE_DB,
 758                     TYPE_ANON_INODE, TYPE_DEV, TYPE_NON_FS, TYPE_OTHER);
 759             int[] count = new int[types.size()];
 760             int[] duplicates = new int[types.size()];
 761             HashSet&lt;String&gt; files = new HashSet&lt;String&gt;();
 762             int total = 0;
 763             for (int i = 0; i &lt; MAX_OPEN_FILES; i++) {
 764                 // This is a gigantic hack but unfortunately the only way to resolve an fd
 765                 // to a file name. Note that we have to loop over all possible fds because
 766                 // reading the directory would require allocating a new fd. The kernel is
 767                 // currently implemented such that no fd is larger then the current rlimit,
 768                 // which is why it&#x27;s safe to loop over them in such a way.
 769                 String fd = &quot;/proc/self/fd/&quot; + i;
 770                 try {
 771                     // getCanonicalPath() uses readlink behind the scene which doesn&#x27;t require
 772                     // a file descriptor.
 773                     String resolved = new File(fd).getCanonicalPath();
 774                     int type = types.indexOf(TYPE_OTHER);
 775                     if (resolved.startsWith(&quot;/dev/&quot;)) {
 776                         type = types.indexOf(TYPE_DEV);
 777                     } else if (resolved.endsWith(&quot;.apk&quot;)) {
 778                         type = types.indexOf(TYPE_APK);
 779                     } else if (resolved.endsWith(&quot;.jar&quot;)) {
 780                         type = types.indexOf(TYPE_JAR);
 781                     } else if (resolved.contains(&quot;/fd/pipe:&quot;)) {
 782                         type = types.indexOf(TYPE_PIPE);
 783                     } else if (resolved.contains(&quot;/fd/socket:&quot;)) {
 784                         type = types.indexOf(TYPE_SOCKET);
 785                     } else if (resolved.contains(&quot;/fd/anon_inode:&quot;)) {
 786                         type = types.indexOf(TYPE_ANON_INODE);
 787                     } else if (resolved.endsWith(&quot;.db&quot;) || resolved.contains(&quot;/databases/&quot;)) {
 788                         type = types.indexOf(TYPE_DB);
 789                     } else if (resolved.startsWith(&quot;/proc/&quot;) &amp;&amp; resolved.contains(&quot;/fd/&quot;)) {
 790                         // Those are the files that don&#x27;t point anywhere on the file system.
 791                         // getCanonicalPath() wrongly interprets these as relative symlinks and
 792                         // resolves them within /proc/&lt;pid&gt;/fd/.
 793                         type = types.indexOf(TYPE_NON_FS);
 794                     }
 795                     count[type]++;
 796                     total++;
 797                     if (files.contains(resolved)) {
 798                         duplicates[type]++;
 799                     }
 800                     files.add(resolved);
 801                     if (total % SAMPLE_RATE == 0) {
 802                         Log.i(TAG, &quot; fd &quot; + i + &quot;: &quot; + resolved
 803                                 + &quot; (&quot; + types.get(type) + &quot;)&quot;);
 804                     }
 805                 } catch (IOException e) {
 806                     // Ignoring exceptions for non-existing file descriptors.
 807                 }
 808             }
 809             for (int i = 0; i &lt; types.size(); i++) {
 810                 Log.i(TAG, String.format(&quot;Open %10s files: %4d total, %4d duplicates&quot;,
 811                         types.get(i), count[i], duplicates[i]));
 812             }
 813         } catch (Throwable t) {
 814             // Catch everything. This is called from an exception handler that we shouldn&#x27;t upset.
 815             Log.e(TAG, &quot;Unable to log open files.&quot;, t);
 816         }
 817     }
 818 }
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.android.launcher3;
   2 
   3 import android.appwidget.AppWidgetProviderInfo;
   4 import android.content.ComponentName;
   5 import android.content.ContentValues;
   6 import android.content.Context;
   7 import android.content.SharedPreferences;
   8 import android.content.pm.ResolveInfo;
   9 import android.content.res.Resources;
  10 import android.database.Cursor;
  11 import android.database.sqlite.SQLiteCantOpenDatabaseException;
  12 import android.database.sqlite.SQLiteDatabase;
  13 import android.database.sqlite.SQLiteDiskIOException;
  14 import android.database.sqlite.SQLiteOpenHelper;
  15 import android.database.sqlite.SQLiteReadOnlyDatabaseException;
  16 import android.graphics.Bitmap.Config;
  17 import android.graphics.Bitmap;
  18 import android.graphics.BitmapFactory;
  19 import android.graphics.BitmapShader;
  20 import android.graphics.Canvas;
  21 import android.graphics.ColorMatrix;
  22 import android.graphics.ColorMatrixColorFilter;
  23 import android.graphics.Paint;
  24 import android.graphics.PorterDuff;
  25 import android.graphics.Rect;
  26 import android.graphics.Shader;
  27 import android.graphics.drawable.BitmapDrawable;
  28 import android.graphics.drawable.Drawable;
  29 import android.os.AsyncTask;
  30 import android.os.Build;
  31 import android.util.Log;
  32 import com.android.launcher3.compat.AppWidgetManagerCompat;
  33 import java.io.ByteArrayOutputStream;
  34 import java.io.File;
  35 import java.io.IOException;
  36 import java.lang.ref.SoftReference;
  37 import java.lang.ref.WeakReference;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.HashMap;
  41 import java.util.HashSet;
  42 import java.util.List;
  43 import java.util.concurrent.Callable;
  44 import java.util.concurrent.ExecutionException;
  45 
  46 
  47 public class WidgetPreviewLoader {
  48     private static abstract class SoftReferenceThreadLocal&lt;T&gt; {
  49         private ThreadLocal&lt;SoftReference&lt;T&gt;&gt; mThreadLocal;
  50 
  51         public SoftReferenceThreadLocal() {
  52             mThreadLocal = new ThreadLocal&lt;SoftReference&lt;T&gt;&gt;();
  53         }
  54 
  55         abstract T initialValue();
  56 
  57         public void set(T t) {
  58             mThreadLocal.set(new SoftReference&lt;T&gt;(t));
  59         }
  60 
  61         public T get() {
  62             SoftReference&lt;T&gt; reference = mThreadLocal.get();
  63             T obj;
  64             if (reference == null) {
  65                 obj = initialValue();
  66                 mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  67                 return obj;
  68             } else {
  69                 obj = reference.get();
  70                 if (obj == null) {
  71                     obj = initialValue();
  72                     mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  73                 }
  74                 return obj;
  75             }
  76         }
  77     }
  78 
  79     private static class CanvasCache extends SoftReferenceThreadLocal&lt;Canvas&gt; {
  80         @Override
  81         protected Canvas initialValue() {
  82             return new Canvas();
  83         }
  84     }
  85 
  86     private static class PaintCache extends SoftReferenceThreadLocal&lt;Paint&gt; {
  87         @Override
  88         protected Paint initialValue() {
  89             return null;
  90         }
  91     }
  92 
  93     private static class BitmapCache extends SoftReferenceThreadLocal&lt;Bitmap&gt; {
  94         @Override
  95         protected Bitmap initialValue() {
  96             return null;
  97         }
  98     }
  99 
 100     private static class RectCache extends SoftReferenceThreadLocal&lt;Rect&gt; {
 101         @Override
 102         protected Rect initialValue() {
 103             return new Rect();
 104         }
 105     }
 106 
<abbr title=" 107     private static class BitmapFactoryOptionsCache extends SoftReferenceThreadLocal&lt;BitmapFactory.Options&gt; {"> 107     private static class BitmapFactoryOptionsCache extends SoftReferenceThreadLocal&lt;BitmapFactory.OptionsðŸ”µ</abbr>
 108         @Override
 109         protected BitmapFactory.Options initialValue() {
 110             return new BitmapFactory.Options();
 111         }
 112     }
 113 
 114     private static final String TAG = &quot;WidgetPreviewLoader&quot;;
 115 
 116     private static final String ANDROID_INCREMENTAL_VERSION_NAME_KEY = &quot;android.incremental.version&quot;;
 117 
 118     private static final float WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE = 0.25f;
 119 
 120     private static final HashSet&lt;String&gt; sInvalidPackages = new HashSet&lt;String&gt;();
 121 
 122     // Used for drawing shortcut previews
 123     // Used for drawing shortcut previews
 124     private final BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 125 
 126     private final PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 127 
 128     private final CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 129 
 130     // Used for drawing widget previews
 131     // Used for drawing widget previews
 132     private final CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 133 
 134     private final RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 135 
 136     private final RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 137 
 138     private final PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 139 
 140     private final PaintCache mDefaultAppWidgetPreviewPaint = new PaintCache();
 141 
<abbr title=" 142     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache();"> 142     private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache()ðŸ”µ</abbr>
 143 
<abbr title=" 144     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt;();"> 144     private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakRefereðŸ”µ</abbr>
 145 
<abbr title=" 146     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;();"> 146     private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;(ðŸ”µ</abbr>
 147 
 148     private final Context mContext;
 149 
 150     private final int mAppIconSize;
 151 
 152     private final IconCache mIconCache;
 153 
 154     private final AppWidgetManagerCompat mManager;
 155 
 156     private int mPreviewBitmapWidth;
 157 
 158     private int mPreviewBitmapHeight;
 159 
 160     private String mSize;
 161 
 162     private PagedViewCellLayout mWidgetSpacingLayout;
 163 
 164     private String mCachedSelectQuery;
 165 
 166     private CacheDb mDb;
 167 
 168     private final MainThreadExecutor mMainThreadExecutor = new MainThreadExecutor();
 169 
 170     public WidgetPreviewLoader(Context context) {
 171         LauncherAppState app = LauncherAppState.getInstance();
 172         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 173         mContext = context;
 174         mAppIconSize = grid.iconSizePx;
 175         mIconCache = app.getIconCache();
 176         mManager = AppWidgetManagerCompat.getInstance(context);
 177         mDb = app.getWidgetPreviewCacheDb();
<abbr title=" 178         SharedPreferences sp = context.getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);"> 178         SharedPreferences sp = context.getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), CðŸ”µ</abbr>
 179         final String lastVersionName = sp.getString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, null);
 180         final String versionName = android.os.Build.VERSION.INCREMENTAL;
 181         final boolean
 182 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 183 isLollipop</span>
 184 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 185 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 185 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 186 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 187 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 188 isLollipopOrGreater</span>
 189 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 190          = Build.VERSION.SDK_INT
 191 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 192 ==</span>
 193 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 194 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 194 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 195 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 196 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 197 &gt;=</span>
 198 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 199          Build.VERSION_CODES.LOLLIPOP;
 200         if (!versionName.equals(lastVersionName)) {
 201             try {
 202                 // clear all the previews whenever the system version changes, to ensure that
 203                 // previews are up-to-date for any apps that might have been updated with the system
 204                 clearDb();
 205             } catch (SQLiteReadOnlyDatabaseException e) {
 206                 if (
 207 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 208 isLollipop</span>
 209 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 210 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 210 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 211 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 212 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 213 isLollipopOrGreater</span>
 214 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 215                 ) {
 216                     // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only
 217                     // issue, then ignore this error and leave the old previews
 218                 } else {
 219                     throw e;
 220                 }
 221             } catch (java.lang.Exception e) {
 222                 throw e;
 223             } finally {
 224                 SharedPreferences.Editor editor = sp.edit();
 225                 editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);
 226                 editor.commit();
 227             }
 228         }
 229     }
 230 
 231     public void recreateDb() {
 232         LauncherAppState app = LauncherAppState.getInstance();
 233         app.recreateWidgetPreviewDb();
 234         mDb = app.getWidgetPreviewCacheDb();
 235     }
 236 
 237     public void setPreviewSize(int previewWidth, int previewHeight,
 238             PagedViewCellLayout widgetSpacingLayout) {
 239         mPreviewBitmapWidth = previewWidth;
 240         mPreviewBitmapHeight = previewHeight;
 241         mSize = previewWidth + &quot;x&quot; + previewHeight;
 242         mWidgetSpacingLayout = widgetSpacingLayout;
 243     }
 244 
 245     public Bitmap getPreview(final Object o) {
 246         final String name = getObjectName(o);
 247         final String packageName = getObjectPackage(o);
 248         // check if the package is valid
 249         synchronized(sInvalidPackages) {
 250             boolean packageValid = !sInvalidPackages.contains(packageName);
 251             if (!packageValid) {
 252                 return null;
 253             }
 254         }
 255         synchronized(mLoadedPreviews) {
 256             // check if it exists in our existing cache
 257             if (mLoadedPreviews.containsKey(name)) {
 258                 WeakReference&lt;Bitmap&gt; bitmapReference = mLoadedPreviews.get(name);
 259                 Bitmap bitmap = bitmapReference.get();
 260                 if (bitmap != null) {
 261                     return bitmap;
 262                 }
 263             }
 264         }
 265 
 266         Bitmap unusedBitmap = null;
 267         synchronized(mUnusedBitmaps) {
 268             // not in cache; we need to load it from the db
 269             while (unusedBitmap == null &amp;&amp; mUnusedBitmaps.size() &gt; 0) {
 270                 Bitmap candidate = mUnusedBitmaps.remove(0).get();
 271                 if (candidate != null &amp;&amp; candidate.isMutable() &amp;&amp;
 272                         candidate.getWidth() == mPreviewBitmapWidth &amp;&amp;
 273                         candidate.getHeight() == mPreviewBitmapHeight) {
 274                     unusedBitmap = candidate;
 275                 }
 276             }
 277             if (unusedBitmap != null) {
 278                 final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 279                 c.setBitmap(unusedBitmap);
 280                 c.drawColor(0, PorterDuff.Mode.CLEAR);
 281                 c.setBitmap(null);
 282             }
 283         }
 284 
 285         if (unusedBitmap == null) {
 286             unusedBitmap = Bitmap.createBitmap(mPreviewBitmapWidth, mPreviewBitmapHeight,
 287                     Bitmap.Config.ARGB_8888);
 288         }
 289         Bitmap preview = readFromDb(name, unusedBitmap);
 290 
 291         if (preview != null) {
 292             synchronized(mLoadedPreviews) {
 293                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 294             }
 295             return preview;
 296         } else {
 297             // it&#x27;s not in the db... we need to generate it
 298             final Bitmap generatedPreview = generatePreview(o, unusedBitmap);
 299             preview = generatedPreview;
 300             if (preview != unusedBitmap) {
 301                 throw new RuntimeException(&quot;generatePreview is not recycling the bitmap &quot; + o);
 302             }
 303 
 304             synchronized(mLoadedPreviews) {
 305                 mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 306             }
 307 
 308             // write to db on a thread pool... this can be done lazily and improves the performance
 309             // of the first time widget previews are loaded
 310             new AsyncTask&lt;Void, Void, Void&gt;() {
 311                 public Void doInBackground(Void ... args) {
 312                     writeToDb(o, generatedPreview);
 313                     return null;
 314                 }
 315             }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 316 
 317             return preview;
 318         }
 319     }
 320 
 321     public void recycleBitmap(Object o, Bitmap bitmapToRecycle) {
 322         String name = getObjectName(o);
 323         synchronized (mLoadedPreviews) {
 324             if (mLoadedPreviews.containsKey(name)) {
 325                 Bitmap b = mLoadedPreviews.get(name).get();
 326                 if (b == bitmapToRecycle) {
 327                     mLoadedPreviews.remove(name);
 328                     if (bitmapToRecycle.isMutable()) {
 329                         synchronized (mUnusedBitmaps) {
 330                             mUnusedBitmaps.add(new SoftReference&lt;Bitmap&gt;(b));
 331                         }
 332                     }
 333                 } else {
 334                     throw new RuntimeException(&quot;Bitmap passed in doesn&#x27;t match up&quot;);
 335                 }
 336             }
 337         }
 338     }
 339 
 340     static class CacheDb extends SQLiteOpenHelper {
 341         final static int DB_VERSION = 2;
 342 
 343         final static String TABLE_NAME = &quot;shortcut_and_widget_previews&quot;;
 344 
 345         final static String COLUMN_NAME = &quot;name&quot;;
 346 
 347         final static String COLUMN_SIZE = &quot;size&quot;;
 348 
 349         final static String COLUMN_PREVIEW_BITMAP = &quot;preview_bitmap&quot;;
 350 
 351         Context mContext;
 352 
 353         public CacheDb(Context context) {
<abbr title=" 354             super(context, new File(context.getCacheDir(), LauncherFiles.WIDGET_PREVIEWS_DB).getPath(), null, DB_VERSION);"> 354             super(context, new File(context.getCacheDir(), LauncherFiles.WIDGET_PREVIEWS_DB).getPath(), nðŸ”µ</abbr>
 355             // Store the context for later use
 356             mContext = context;
 357         }
 358 
 359         @Override
 360         public void onCreate(SQLiteDatabase database) {
 361             database.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME + &quot; (&quot; +
 362                     COLUMN_NAME + &quot; TEXT NOT NULL, &quot; +
 363                     COLUMN_SIZE + &quot; TEXT NOT NULL, &quot; +
 364                     COLUMN_PREVIEW_BITMAP + &quot; BLOB NOT NULL, &quot; +
 365                     &quot;PRIMARY KEY (&quot; + COLUMN_NAME + &quot;, &quot; + COLUMN_SIZE + &quot;) &quot; +
 366                     &quot;);&quot;);
 367         }
 368 
 369         @Override
 370         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 371             if (oldVersion != newVersion) {
 372                 // Delete all the records; they&#x27;ll be repopulated as this is a cache
 373                 db.execSQL(&quot;DELETE FROM &quot; + TABLE_NAME);
 374             }
 375         }
 376     }
 377 
 378     private static final String WIDGET_PREFIX = &quot;Widget:&quot;;
 379 
 380     private static final String SHORTCUT_PREFIX = &quot;Shortcut:&quot;;
 381 
 382     private static String getObjectName(Object o) {
 383         // should cache the string builder
 384         StringBuilder sb = new StringBuilder();
 385         String output;
 386         if (o instanceof AppWidgetProviderInfo) {
 387             sb.append(WIDGET_PREFIX);
 388             sb.append(((AppWidgetProviderInfo) o).toString());
 389             output = sb.toString();
 390             sb.setLength(0);
 391         } else {
 392             sb.append(SHORTCUT_PREFIX);
 393 
 394             ResolveInfo info = (ResolveInfo) o;
 395             sb.append(new ComponentName(info.activityInfo.packageName,
 396                     info.activityInfo.name).flattenToString());
 397             output = sb.toString();
 398             sb.setLength(0);
 399         }
 400         return output;
 401     }
 402 
 403     private String getObjectPackage(Object o) {
 404         if (o instanceof AppWidgetProviderInfo) {
 405             return ((AppWidgetProviderInfo) o).provider.getPackageName();
 406         } else {
 407             ResolveInfo info = (ResolveInfo) o;
 408             return info.activityInfo.packageName;
 409         }
 410     }
 411 
 412     private void writeToDb(Object o, Bitmap preview) {
 413         String name = getObjectName(o);
 414         SQLiteDatabase db = mDb.getWritableDatabase();
 415         ContentValues values = new ContentValues();
 416 
 417         values.put(CacheDb.COLUMN_NAME, name);
 418         ByteArrayOutputStream stream = new ByteArrayOutputStream();
 419         preview.compress(Bitmap.CompressFormat.PNG, 100, stream);
 420         values.put(CacheDb.COLUMN_PREVIEW_BITMAP, stream.toByteArray());
 421         values.put(CacheDb.COLUMN_SIZE, mSize);
 422         try {
 423             db.insert(CacheDb.TABLE_NAME, null, values);
 424         } catch (SQLiteDiskIOException e) {
 425             recreateDb();
 426         } catch (SQLiteCantOpenDatabaseException e) {
 427             dumpOpenFiles();
 428             throw e;
 429         }
 430     }
 431 
 432     private void clearDb() {
 433         SQLiteDatabase db = mDb.getWritableDatabase();
 434         // Delete everything
 435         try {
 436             db.delete(CacheDb.TABLE_NAME, null, null);
 437         } catch (SQLiteDiskIOException e) {
 438         } catch (SQLiteCantOpenDatabaseException e) {
 439             dumpOpenFiles();
 440             throw e;
 441         }
 442     }
 443 
 444     public static void removePackageFromDb(final CacheDb cacheDb, final String packageName) {
 445         synchronized(sInvalidPackages) {
 446             sInvalidPackages.add(packageName);
 447         }
 448         new AsyncTask&lt;Void, Void, Void&gt;() {
 449             public Void doInBackground(Void ... args) {
 450                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 451                 try {
 452                     db.delete(CacheDb.TABLE_NAME,
 453                             CacheDb.COLUMN_NAME + &quot; LIKE ? OR &quot; +
 454                             CacheDb.COLUMN_NAME + &quot; LIKE ?&quot;, // SELECT query
 455                             new String[] {
 456                                     WIDGET_PREFIX + packageName + &quot;/%&quot;,
 457                                     SHORTCUT_PREFIX + packageName + &quot;/%&quot;
 458                             } // args to SELECT query
 459                     );
 460                 } catch (SQLiteDiskIOException e) {
 461                 } catch (SQLiteCantOpenDatabaseException e) {
 462                     dumpOpenFiles();
 463                     throw e;
 464                 }
 465                 synchronized(sInvalidPackages) {
 466                     sInvalidPackages.remove(packageName);
 467                 }
 468                 return null;
 469             }
 470         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 471     }
 472 
 473     private static void removeItemFromDb(final CacheDb cacheDb, final String objectName) {
 474         new AsyncTask&lt;Void, Void, Void&gt;() {
 475             public Void doInBackground(Void ... args) {
 476                 SQLiteDatabase db = cacheDb.getWritableDatabase();
 477                 try {
 478                     db.delete(CacheDb.TABLE_NAME,
 479                             CacheDb.COLUMN_NAME + &quot; = ? &quot;, // SELECT query
 480                             new String[] { objectName }); // args to SELECT query
 481                 } catch (SQLiteDiskIOException e) {
 482                 } catch (SQLiteCantOpenDatabaseException e) {
 483                     dumpOpenFiles();
 484                     throw e;
 485                 }
 486                 return null;
 487             }
 488         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 489     }
 490 
 491     private Bitmap readFromDb(String name, Bitmap b) {
 492         if (mCachedSelectQuery == null) {
 493             mCachedSelectQuery = CacheDb.COLUMN_NAME + &quot; = ? AND &quot; +
 494                     CacheDb.COLUMN_SIZE + &quot; = ?&quot;;
 495         }
 496         SQLiteDatabase db = mDb.getReadableDatabase();
 497         Cursor result;
 498         try {
 499             result = db.query(CacheDb.TABLE_NAME,
 500                     new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, // cols to return
 501                     mCachedSelectQuery, // select query
 502                     new String[] { name, mSize }, // args to select query
 503                     null,
 504                     null,
 505                     null,
 506                     null);
 507         } catch (SQLiteDiskIOException e) {
 508             recreateDb();
 509             return null;
 510         } catch (SQLiteCantOpenDatabaseException e) {
 511             dumpOpenFiles();
 512             throw e;
 513         }
 514         if (result.getCount() &gt; 0) {
 515             result.moveToFirst();
 516             byte[] blob = result.getBlob(0);
 517             result.close();
 518             final BitmapFactory.Options opts = mCachedBitmapFactoryOptions.get();
 519             opts.inBitmap = b;
 520             opts.inSampleSize = 1;
 521             try {
 522                 return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);
 523             } catch (IllegalArgumentException e) {
 524                 removeItemFromDb(mDb, name);
 525                 return null;
 526             }
 527         } else {
 528             result.close();
 529             return null;
 530         }
 531     }
 532 
 533     private Bitmap generatePreview(Object info, Bitmap preview) {
 534         if (preview != null &amp;&amp;
 535                 (preview.getWidth() != mPreviewBitmapWidth ||
 536                 preview.getHeight() != mPreviewBitmapHeight)) {
 537             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 538         }
 539         if (info instanceof AppWidgetProviderInfo) {
 540             return generateWidgetPreview((AppWidgetProviderInfo) info, preview);
 541         } else {
 542             return generateShortcutPreview(
 543                     (ResolveInfo) info, mPreviewBitmapWidth, mPreviewBitmapHeight, preview);
 544         }
 545     }
 546 
 547     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, Bitmap preview) {
 548         int[] cellSpans = Launcher.getSpanForWidget(mContext, info);
 549         int maxWidth = maxWidthForWidgetPreview(cellSpans[0]);
 550         int maxHeight = maxHeightForWidgetPreview(cellSpans[1]);
 551         return generateWidgetPreview(info, cellSpans[0], cellSpans[1],
 552                 maxWidth, maxHeight, preview, null);
 553     }
 554 
 555     public int maxWidthForWidgetPreview(int spanX) {
 556         return Math.min(mPreviewBitmapWidth,
 557                 mWidgetSpacingLayout.estimateCellWidth(spanX));
 558     }
 559 
 560     public int maxHeightForWidgetPreview(int spanY) {
 561         return Math.min(mPreviewBitmapHeight,
 562                 mWidgetSpacingLayout.estimateCellHeight(spanY));
 563     }
 564 
 565     public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, int cellHSpan, int cellVSpan,
 566             int maxPreviewWidth, int maxPreviewHeight, Bitmap preview, int[] preScaledWidthOut) {
 567         // Load the preview image if possible
 568         if (maxPreviewWidth &lt; 0) maxPreviewWidth = Integer.MAX_VALUE;
 569         if (maxPreviewHeight &lt; 0) maxPreviewHeight = Integer.MAX_VALUE;
 570 
 571         Drawable drawable = null;
 572         if (info.previewImage != 0) {
 573             drawable = mManager.loadPreview(info);
 574             if (drawable != null) {
 575                 drawable = mutateOnMainThread(drawable);
 576             } else {
 577                 Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
 578                         Integer.toHexString(info.previewImage) + &quot; for provider: &quot; + info.provider);
 579             }
 580         }
 581 
 582         int previewWidth;
 583         int previewHeight;
 584         Bitmap defaultPreview = null;
 585         boolean widgetPreviewExists = (drawable != null);
 586         if (widgetPreviewExists) {
 587             previewWidth = drawable.getIntrinsicWidth();
 588             previewHeight = drawable.getIntrinsicHeight();
 589         } else {
 590             // Generate a preview image if we couldn&#x27;t load one
 591             if (cellHSpan &lt; 1) cellHSpan = 1;
 592             if (cellVSpan &lt; 1) cellVSpan = 1;
 593 
 594             // This Drawable is not directly drawn, so there&#x27;s no need to mutate it.
 595             BitmapDrawable previewDrawable = (BitmapDrawable) mContext.getResources()
 596                     .getDrawable(R.drawable.widget_tile);
 597             final int previewDrawableWidth = previewDrawable
 598                     .getIntrinsicWidth();
 599             final int previewDrawableHeight = previewDrawable
 600                     .getIntrinsicHeight();
 601             previewWidth = previewDrawableWidth * cellHSpan;
 602             previewHeight = previewDrawableHeight * cellVSpan;
 603 
 604             defaultPreview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 605             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 606             c.setBitmap(defaultPreview);
 607             Paint p = mDefaultAppWidgetPreviewPaint.get();
 608             if (p == null) {
 609                 p = new Paint();
 610                 p.setShader(new BitmapShader(previewDrawable.getBitmap(),
 611                         Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
 612                 mDefaultAppWidgetPreviewPaint.set(p);
 613             }
 614             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 615             dest.set(0, 0, previewWidth, previewHeight);
 616             c.drawRect(dest, p);
 617             c.setBitmap(null);
 618 
 619             // Draw the icon in the top left corner
 620             int minOffset = (int) (mAppIconSize * WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE);
 621             int smallestSide = Math.min(previewWidth, previewHeight);
 622             float iconScale = Math.min((float) smallestSide
 623                     / (mAppIconSize + 2 * minOffset), 1f);
 624 
 625             try {
 626                 Drawable icon = mManager.loadIcon(info, mIconCache);
 627                 if (icon != null) {
 628                     int hoffset = (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
 629                     int yoffset = (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
 630                     icon = mutateOnMainThread(icon);
 631                     renderDrawableToBitmap(icon, defaultPreview, hoffset,
 632                             yoffset, (int) (mAppIconSize * iconScale),
 633                             (int) (mAppIconSize * iconScale));
 634                 }
 635             } catch (Resources.NotFoundException e) {
 636             }
 637         }
 638 
 639         // Scale to fit width only - let the widget preview be clipped in the
 640         // vertical dimension
 641         float scale = 1f;
 642         if (preScaledWidthOut != null) {
 643             preScaledWidthOut[0] = previewWidth;
 644         }
 645         if (previewWidth &gt; maxPreviewWidth) {
 646             scale = maxPreviewWidth / (float) previewWidth;
 647         }
 648         if (scale != 1f) {
 649             previewWidth = (int) (scale * previewWidth);
 650             previewHeight = (int) (scale * previewHeight);
 651         }
 652 
 653         // If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size
 654         if (preview == null) {
 655             preview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 656         }
 657 
 658         // Draw the scaled preview into the final bitmap
 659         int x = (preview.getWidth() - previewWidth) / 2;
 660         if (widgetPreviewExists) {
 661             renderDrawableToBitmap(drawable, preview, x, 0, previewWidth,
 662                     previewHeight);
 663         } else {
 664             final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 665             final Rect src = mCachedAppWidgetPreviewSrcRect.get();
 666             final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 667             c.setBitmap(preview);
 668             src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
 669             dest.set(x, 0, x + previewWidth, previewHeight);
 670 
 671             Paint p = mCachedAppWidgetPreviewPaint.get();
 672             if (p == null) {
 673                 p = new Paint();
 674                 p.setFilterBitmap(true);
 675                 mCachedAppWidgetPreviewPaint.set(p);
 676             }
 677             c.drawBitmap(defaultPreview, src, dest, p);
 678             c.setBitmap(null);
 679         }
 680         return mManager.getBadgeBitmap(info, preview);
 681     }
 682 
<abbr title=" 683     private Bitmap generateShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview) {"> 683     private Bitmap generateShortcutPreview(ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview)ðŸ”µ</abbr>
 684         Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
 685         final Canvas c = mCachedShortcutPreviewCanvas.get();
<abbr title=" 686         if (((tempBitmap == null) || (tempBitmap.getWidth() != maxWidth)) || (tempBitmap.getHeight() != maxHeight)) {"> 686         if (((tempBitmap == null) || (tempBitmap.getWidth() != maxWidth)) || (tempBitmap.getHeight() != mðŸ”µ</abbr>
 687             tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 688             mCachedShortcutPreviewBitmap.set(tempBitmap);
 689         } else {
 690             c.setBitmap(tempBitmap);
 691             c.drawColor(0, PorterDuff.Mode.CLEAR);
 692             c.setBitmap(null);
 693         }
 694         // Render the icon
 695         Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info.activityInfo));
<abbr title=" 696         int paddingTop = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);"> 696         int paddingTop = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_paddingðŸ”µ</abbr>
<abbr title=" 697         int paddingLeft = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);"> 697         int paddingLeft = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_paddinðŸ”µ</abbr>
<abbr title=" 698         int paddingRight = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);"> 698         int paddingRight = mContext.getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_paddiðŸ”µ</abbr>
 699         int scaledIconWidth = (maxWidth - paddingLeft) - paddingRight;
<abbr title=" 700         renderDrawableToBitmap(icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);"> 700         renderDrawableToBitmap(icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidtðŸ”µ</abbr>
<abbr title=" 701         if ((preview != null) &amp;&amp; ((preview.getWidth() != maxWidth) || (preview.getHeight() != maxHeight))) {"> 701         if ((preview != null) &amp;&amp; ((preview.getWidth() != maxWidth) || (preview.getHeight() != maxHeight))ðŸ”µ</abbr>
 702             throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 703         } else if (preview == null) {
 704             preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 705         }
 706         c.setBitmap(preview);
 707         // Draw a desaturated/scaled version of the icon in the background as a watermark
 708         Paint p = mCachedShortcutPreviewPaint.get();
 709         if (p == null) {
 710             p = new Paint();
 711             ColorMatrix colorMatrix = new ColorMatrix();
 712             colorMatrix.setSaturation(0);
 713             p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
 714             p.setAlpha(((int) (255 * 0.06F)));
 715             mCachedShortcutPreviewPaint.set(p);
 716         }
 717         c.drawBitmap(tempBitmap, 0, 0, p);
 718         c.setBitmap(null);
 719         renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
 720         return preview;
 721     }
 722 
 723     private static void renderDrawableToBitmap(
 724             Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
 725         if (bitmap != null) {
 726             Canvas c = new Canvas(bitmap);
 727             Rect oldBounds = d.copyBounds();
 728             d.setBounds(x, y, x + w, y + h);
 729             d.draw(c);
 730             d.setBounds(oldBounds); // Restore the bounds
 731             c.setBitmap(null);
 732         }
 733     }
 734 
 735     private Drawable mutateOnMainThread(final Drawable drawable) {
 736         try {
 737             return mMainThreadExecutor.submit(new Callable&lt;Drawable&gt;() {
 738                 @Override
 739                 public Drawable call() throws Exception {
 740                     return drawable.mutate();
 741                 }
 742             }).get();
 743         } catch (InterruptedException e) {
 744             Thread.currentThread().interrupt();
 745             throw new RuntimeException(e);
 746         } catch (ExecutionException e) {
 747             throw new RuntimeException(e);
 748         }
 749     }
 750 
 751     private static final int MAX_OPEN_FILES = 1024;
 752 
 753     private static final int SAMPLE_RATE = 23;
 754 
 755     /**
 756      * Dumps all files that are open in this process without allocating a file descriptor.
 757      */
 758     private static void dumpOpenFiles() {
 759         try {
 760             Log.i(TAG, &quot;DUMP OF OPEN FILES (sample rate: 1 every &quot; + SAMPLE_RATE + &quot;):&quot;);
 761             final String TYPE_APK = &quot;apk&quot;;
 762             final String TYPE_JAR = &quot;jar&quot;;
 763             final String TYPE_PIPE = &quot;pipe&quot;;
 764             final String TYPE_SOCKET = &quot;socket&quot;;
 765             final String TYPE_DB = &quot;db&quot;;
 766             final String TYPE_ANON_INODE = &quot;anon_inode&quot;;
 767             final String TYPE_DEV = &quot;dev&quot;;
 768             final String TYPE_NON_FS = &quot;non-fs&quot;;
 769             final String TYPE_OTHER = &quot;other&quot;;
 770             List&lt;String&gt; types = Arrays.asList(TYPE_APK, TYPE_JAR, TYPE_PIPE, TYPE_SOCKET, TYPE_DB,
 771                     TYPE_ANON_INODE, TYPE_DEV, TYPE_NON_FS, TYPE_OTHER);
 772             int[] count = new int[types.size()];
 773             int[] duplicates = new int[types.size()];
 774             HashSet&lt;String&gt; files = new HashSet&lt;String&gt;();
 775             int total = 0;
 776             for (int i = 0; i &lt; MAX_OPEN_FILES; i++) {
 777                 // This is a gigantic hack but unfortunately the only way to resolve an fd
 778                 // to a file name. Note that we have to loop over all possible fds because
 779                 // reading the directory would require allocating a new fd. The kernel is
 780                 // currently implemented such that no fd is larger then the current rlimit,
 781                 // which is why it&#x27;s safe to loop over them in such a way.
 782                 String fd = &quot;/proc/self/fd/&quot; + i;
 783                 try {
 784                     // getCanonicalPath() uses readlink behind the scene which doesn&#x27;t require
 785                     // a file descriptor.
 786                     String resolved = new File(fd).getCanonicalPath();
 787                     int type = types.indexOf(TYPE_OTHER);
 788                     if (resolved.startsWith(&quot;/dev/&quot;)) {
 789                         type = types.indexOf(TYPE_DEV);
 790                     } else if (resolved.endsWith(&quot;.apk&quot;)) {
 791                         type = types.indexOf(TYPE_APK);
 792                     } else if (resolved.endsWith(&quot;.jar&quot;)) {
 793                         type = types.indexOf(TYPE_JAR);
 794                     } else if (resolved.contains(&quot;/fd/pipe:&quot;)) {
 795                         type = types.indexOf(TYPE_PIPE);
 796                     } else if (resolved.contains(&quot;/fd/socket:&quot;)) {
 797                         type = types.indexOf(TYPE_SOCKET);
 798                     } else if (resolved.contains(&quot;/fd/anon_inode:&quot;)) {
 799                         type = types.indexOf(TYPE_ANON_INODE);
 800                     } else if (resolved.endsWith(&quot;.db&quot;) || resolved.contains(&quot;/databases/&quot;)) {
 801                         type = types.indexOf(TYPE_DB);
 802                     } else if (resolved.startsWith(&quot;/proc/&quot;) &amp;&amp; resolved.contains(&quot;/fd/&quot;)) {
 803                         // Those are the files that don&#x27;t point anywhere on the file system.
 804                         // getCanonicalPath() wrongly interprets these as relative symlinks and
 805                         // resolves them within /proc/&lt;pid&gt;/fd/.
 806                         type = types.indexOf(TYPE_NON_FS);
 807                     }
 808                     count[type]++;
 809                     total++;
 810                     if (files.contains(resolved)) {
 811                         duplicates[type]++;
 812                     }
 813                     files.add(resolved);
 814                     if (total % SAMPLE_RATE == 0) {
 815                         Log.i(TAG, &quot; fd &quot; + i + &quot;: &quot; + resolved
 816                                 + &quot; (&quot; + types.get(type) + &quot;)&quot;);
 817                     }
 818                 } catch (IOException e) {
 819                     // Ignoring exceptions for non-existing file descriptors.
 820                 }
 821             }
 822             for (int i = 0; i &lt; types.size(); i++) {
 823                 Log.i(TAG, String.format(&quot;Open %10s files: %4d total, %4d duplicates&quot;,
 824                         types.get(i), count[i], duplicates[i]));
 825             }
 826         } catch (Throwable t) {
 827             // Catch everything. This is called from an exception handler that we shouldn&#x27;t upset.
 828             Log.e(TAG, &quot;Unable to log open files.&quot;, t);
 829         }
 830     }
 831 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.android.launcher3;
   2  
   3  import android.appwidget.AppWidgetProviderInfo;
   4  import android.content.ComponentName;
   5  import android.content.ContentValues;
   6  import android.content.Context;
   7  import android.content.SharedPreferences;
   8  import android.content.pm.ResolveInfo;
   9  import android.content.res.Resources;
  10  import android.database.Cursor;
  11  import android.database.sqlite.SQLiteCantOpenDatabaseException;
  12  import android.database.sqlite.SQLiteDatabase;
  13  import android.database.sqlite.SQLiteDiskIOException;
  14  import android.database.sqlite.SQLiteOpenHelper;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  15 +import android.database.sqlite.SQLiteReadOnlyDatabaseException;</span>
  16  import android.graphics.Bitmap;
  17  import android.graphics.Bitmap.Config;
  18  import android.graphics.BitmapFactory;
  19  import android.graphics.BitmapShader;
  20  import android.graphics.Canvas;
  21  import android.graphics.ColorMatrix;
  22  import android.graphics.ColorMatrixColorFilter;
  23  import android.graphics.Paint;
  24  import android.graphics.PorterDuff;
  25  import android.graphics.Rect;
  26  import android.graphics.Shader;
  27  import android.graphics.drawable.BitmapDrawable;
  28  import android.graphics.drawable.Drawable;
  29  import android.os.AsyncTask;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.os.Build;</span>
  31  import android.util.Log;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -</span>
  33  import com.android.launcher3.compat.AppWidgetManagerCompat;
  34  
  35  import java.io.ByteArrayOutputStream;
  36  import java.io.File;
  37  import java.io.IOException;
  38  import java.lang.ref.SoftReference;
  39  import java.lang.ref.WeakReference;
  40  import java.util.ArrayList;
  41  import java.util.Arrays;
  42  import java.util.HashMap;
  43  import java.util.HashSet;
  44  import java.util.List;
  45  import java.util.concurrent.Callable;
  46  import java.util.concurrent.ExecutionException;
  47  
  48  public class WidgetPreviewLoader {
  49  
  50      private static abstract class SoftReferenceThreadLocal&lt;T&gt; {
  51          private ThreadLocal&lt;SoftReference&lt;T&gt;&gt; mThreadLocal;
  52          public SoftReferenceThreadLocal() {
  53              mThreadLocal = new ThreadLocal&lt;SoftReference&lt;T&gt;&gt;();
  54          }
  55  
  56          abstract T initialValue();
  57  
  58          public void set(T t) {
  59              mThreadLocal.set(new SoftReference&lt;T&gt;(t));
  60          }
  61  
  62          public T get() {
  63              SoftReference&lt;T&gt; reference = mThreadLocal.get();
  64              T obj;
  65              if (reference == null) {
  66                  obj = initialValue();
  67                  mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  68                  return obj;
  69              } else {
  70                  obj = reference.get();
  71                  if (obj == null) {
  72                      obj = initialValue();
  73                      mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  74                  }
  75                  return obj;
  76              }
  77          }
  78      }
  79  
  80      private static class CanvasCache extends SoftReferenceThreadLocal&lt;Canvas&gt; {
  81          @Override
  82          protected Canvas initialValue() {
  83              return new Canvas();
  84          }
  85      }
  86  
  87      private static class PaintCache extends SoftReferenceThreadLocal&lt;Paint&gt; {
  88          @Override
  89          protected Paint initialValue() {
  90              return null;
  91          }
  92      }
  93  
  94      private static class BitmapCache extends SoftReferenceThreadLocal&lt;Bitmap&gt; {
  95          @Override
  96          protected Bitmap initialValue() {
  97              return null;
  98          }
  99      }
 100  
 101      private static class RectCache extends SoftReferenceThreadLocal&lt;Rect&gt; {
 102          @Override
 103          protected Rect initialValue() {
 104              return new Rect();
 105          }
 106      }
 107  
 108      private static class BitmapFactoryOptionsCache extends
 109              SoftReferenceThreadLocal&lt;BitmapFactory.Options&gt; {
 110          @Override
 111          protected BitmapFactory.Options initialValue() {
 112              return new BitmapFactory.Options();
 113          }
 114      }
 115  
 116      private static final String TAG = &quot;WidgetPreviewLoader&quot;;
 117      private static final String ANDROID_INCREMENTAL_VERSION_NAME_KEY = &quot;android.incremental.version&quot;;
 118  
 119      private static final float WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE = 0.25f;
 120      private static final HashSet&lt;String&gt; sInvalidPackages = new HashSet&lt;String&gt;();
 121  
 122      // Used for drawing shortcut previews
 123      private final BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 124      private final PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 125      private final CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 126  
 127      // Used for drawing widget previews
 128      private final CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 129      private final RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 130      private final RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 131      private final PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 132      private final PaintCache mDefaultAppWidgetPreviewPaint = new PaintCache();
 133      private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache();
 134  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -    private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 137 +    private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt;();"> 137 +    private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;String, WeakReference&lt;BitmaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +    private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt;();</span>
 139  
 140      private final Context mContext;
 141      private final int mAppIconSize;
 142      private final IconCache mIconCache;
 143      private final AppWidgetManagerCompat mManager;
 144  
 145      private int mPreviewBitmapWidth;
 146      private int mPreviewBitmapHeight;
 147      private String mSize;
 148      private PagedViewCellLayout mWidgetSpacingLayout;
 149  
 150      private String mCachedSelectQuery;
 151  
 152  
 153      private CacheDb mDb;
 154  
 155      private final MainThreadExecutor mMainThreadExecutor = new MainThreadExecutor();
 156  
 157      public WidgetPreviewLoader(Context context) {
 158          LauncherAppState app = LauncherAppState.getInstance();
 159          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 160  
 161          mContext = context;
 162          mAppIconSize = grid.iconSizePx;
 163          mIconCache = app.getIconCache();
 164          mManager = AppWidgetManagerCompat.getInstance(context);
 165  
 166          mDb = app.getWidgetPreviewCacheDb();
 167  
 168          SharedPreferences sp = context.getSharedPreferences(
 169                  LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
 170          final String lastVersionName = sp.getString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, null);
 171          final String versionName = android.os.Build.VERSION.INCREMENTAL;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        final boolean isLollipop = Build.VERSION.SDK_INT == Build.VERSION_CODES.LOLLIPOP;</span>
 173          if (!versionName.equals(lastVersionName)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -            // clear all the previews whenever the system version changes, to ensure that previews</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -            // are up-to-date for any apps that might have been updated with the system</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -            clearDb();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -            SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -            editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -            editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +                // clear all the previews whenever the system version changes, to ensure that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +                // previews are up-to-date for any apps that might have been updated with the system</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                clearDb();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +            } catch (SQLiteReadOnlyDatabaseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +                if (isLollipop) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                    // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +                    // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +            } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +                throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +                SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +                editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +                editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +            }</span>
 199          }
 200      }
 201  
 202      public void recreateDb() {
 203          LauncherAppState app = LauncherAppState.getInstance();
 204          app.recreateWidgetPreviewDb();
 205          mDb = app.getWidgetPreviewCacheDb();
 206      }
 207  
 208      public void setPreviewSize(int previewWidth, int previewHeight,
 209              PagedViewCellLayout widgetSpacingLayout) {
 210          mPreviewBitmapWidth = previewWidth;
 211          mPreviewBitmapHeight = previewHeight;
 212          mSize = previewWidth + &quot;x&quot; + previewHeight;
 213          mWidgetSpacingLayout = widgetSpacingLayout;
 214      }
 215  
 216      public Bitmap getPreview(final Object o) {
 217          final String name = getObjectName(o);
 218          final String packageName = getObjectPackage(o);
 219          // check if the package is valid
 220          synchronized(sInvalidPackages) {
 221              boolean packageValid = !sInvalidPackages.contains(packageName);
 222              if (!packageValid) {
 223                  return null;
 224              }
 225          }
 226          synchronized(mLoadedPreviews) {
 227              // check if it exists in our existing cache
 228              if (mLoadedPreviews.containsKey(name)) {
 229                  WeakReference&lt;Bitmap&gt; bitmapReference = mLoadedPreviews.get(name);
 230                  Bitmap bitmap = bitmapReference.get();
 231                  if (bitmap != null) {
 232                      return bitmap;
 233                  }
 234              }
 235          }
 236  
 237          Bitmap unusedBitmap = null;
 238          synchronized(mUnusedBitmaps) {
 239              // not in cache; we need to load it from the db
 240              while (unusedBitmap == null &amp;&amp; mUnusedBitmaps.size() &gt; 0) {
 241                  Bitmap candidate = mUnusedBitmaps.remove(0).get();
 242                  if (candidate != null &amp;&amp; candidate.isMutable() &amp;&amp;
 243                          candidate.getWidth() == mPreviewBitmapWidth &amp;&amp;
 244                          candidate.getHeight() == mPreviewBitmapHeight) {
 245                      unusedBitmap = candidate;
 246                  }
 247              }
 248              if (unusedBitmap != null) {
 249                  final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 250                  c.setBitmap(unusedBitmap);
 251                  c.drawColor(0, PorterDuff.Mode.CLEAR);
 252                  c.setBitmap(null);
 253              }
 254          }
 255  
 256          if (unusedBitmap == null) {
 257              unusedBitmap = Bitmap.createBitmap(mPreviewBitmapWidth, mPreviewBitmapHeight,
 258                      Bitmap.Config.ARGB_8888);
 259          }
 260          Bitmap preview = readFromDb(name, unusedBitmap);
 261  
 262          if (preview != null) {
 263              synchronized(mLoadedPreviews) {
 264                  mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 265              }
 266              return preview;
 267          } else {
 268              // it&#x27;s not in the db... we need to generate it
 269              final Bitmap generatedPreview = generatePreview(o, unusedBitmap);
 270              preview = generatedPreview;
 271              if (preview != unusedBitmap) {
 272                  throw new RuntimeException(&quot;generatePreview is not recycling the bitmap &quot; + o);
 273              }
 274  
 275              synchronized(mLoadedPreviews) {
 276                  mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 277              }
 278  
 279              // write to db on a thread pool... this can be done lazily and improves the performance
 280              // of the first time widget previews are loaded
 281              new AsyncTask&lt;Void, Void, Void&gt;() {
 282                  public Void doInBackground(Void ... args) {
 283                      writeToDb(o, generatedPreview);
 284                      return null;
 285                  }
 286              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 287  
 288              return preview;
 289          }
 290      }
 291  
 292      public void recycleBitmap(Object o, Bitmap bitmapToRecycle) {
 293          String name = getObjectName(o);
 294          synchronized (mLoadedPreviews) {
 295              if (mLoadedPreviews.containsKey(name)) {
 296                  Bitmap b = mLoadedPreviews.get(name).get();
 297                  if (b == bitmapToRecycle) {
 298                      mLoadedPreviews.remove(name);
 299                      if (bitmapToRecycle.isMutable()) {
 300                          synchronized (mUnusedBitmaps) {
 301                              mUnusedBitmaps.add(new SoftReference&lt;Bitmap&gt;(b));
 302                          }
 303                      }
 304                  } else {
 305                      throw new RuntimeException(&quot;Bitmap passed in doesn&#x27;t match up&quot;);
 306                  }
 307              }
 308          }
 309      }
 310  
 311      static class CacheDb extends SQLiteOpenHelper {
 312          final static int DB_VERSION = 2;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 313 -        final static String DB_NAME = &quot;widgetpreviews.db&quot;;</span>
 314          final static String TABLE_NAME = &quot;shortcut_and_widget_previews&quot;;
 315          final static String COLUMN_NAME = &quot;name&quot;;
 316          final static String COLUMN_SIZE = &quot;size&quot;;
 317          final static String COLUMN_PREVIEW_BITMAP = &quot;preview_bitmap&quot;;
 318          Context mContext;
 319  
 320          public CacheDb(Context context) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 321 -            super(context, new File(context.getCacheDir(), DB_NAME).getPath(), null, DB_VERSION);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +            super(context, new File(context.getCacheDir(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +                    LauncherFiles.WIDGET_PREVIEWS_DB).getPath(), null, DB_VERSION);</span>
 324              // Store the context for later use
 325              mContext = context;
 326          }
 327  
 328          @Override
 329          public void onCreate(SQLiteDatabase database) {
 330              database.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME + &quot; (&quot; +
 331                      COLUMN_NAME + &quot; TEXT NOT NULL, &quot; +
 332                      COLUMN_SIZE + &quot; TEXT NOT NULL, &quot; +
 333                      COLUMN_PREVIEW_BITMAP + &quot; BLOB NOT NULL, &quot; +
 334                      &quot;PRIMARY KEY (&quot; + COLUMN_NAME + &quot;, &quot; + COLUMN_SIZE + &quot;) &quot; +
 335                      &quot;);&quot;);
 336          }
 337  
 338          @Override
 339          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 340              if (oldVersion != newVersion) {
 341                  // Delete all the records; they&#x27;ll be repopulated as this is a cache
 342                  db.execSQL(&quot;DELETE FROM &quot; + TABLE_NAME);
 343              }
 344          }
 345      }
 346  
 347      private static final String WIDGET_PREFIX = &quot;Widget:&quot;;
 348      private static final String SHORTCUT_PREFIX = &quot;Shortcut:&quot;;
 349  
 350      private static String getObjectName(Object o) {
 351          // should cache the string builder
 352          StringBuilder sb = new StringBuilder();
 353          String output;
 354          if (o instanceof AppWidgetProviderInfo) {
 355              sb.append(WIDGET_PREFIX);
 356              sb.append(((AppWidgetProviderInfo) o).toString());
 357              output = sb.toString();
 358              sb.setLength(0);
 359          } else {
 360              sb.append(SHORTCUT_PREFIX);
 361  
 362              ResolveInfo info = (ResolveInfo) o;
 363              sb.append(new ComponentName(info.activityInfo.packageName,
 364                      info.activityInfo.name).flattenToString());
 365              output = sb.toString();
 366              sb.setLength(0);
 367          }
 368          return output;
 369      }
 370  
 371      private String getObjectPackage(Object o) {
 372          if (o instanceof AppWidgetProviderInfo) {
 373              return ((AppWidgetProviderInfo) o).provider.getPackageName();
 374          } else {
 375              ResolveInfo info = (ResolveInfo) o;
 376              return info.activityInfo.packageName;
 377          }
 378      }
 379  
 380      private void writeToDb(Object o, Bitmap preview) {
 381          String name = getObjectName(o);
 382          SQLiteDatabase db = mDb.getWritableDatabase();
 383          ContentValues values = new ContentValues();
 384  
 385          values.put(CacheDb.COLUMN_NAME, name);
 386          ByteArrayOutputStream stream = new ByteArrayOutputStream();
 387          preview.compress(Bitmap.CompressFormat.PNG, 100, stream);
 388          values.put(CacheDb.COLUMN_PREVIEW_BITMAP, stream.toByteArray());
 389          values.put(CacheDb.COLUMN_SIZE, mSize);
 390          try {
 391              db.insert(CacheDb.TABLE_NAME, null, values);
 392          } catch (SQLiteDiskIOException e) {
 393              recreateDb();
 394          } catch (SQLiteCantOpenDatabaseException e) {
 395              dumpOpenFiles();
 396              throw e;
 397          }
 398      }
 399  
 400      private void clearDb() {
 401          SQLiteDatabase db = mDb.getWritableDatabase();
 402          // Delete everything
 403          try {
 404              db.delete(CacheDb.TABLE_NAME, null, null);
 405          } catch (SQLiteDiskIOException e) {
 406          } catch (SQLiteCantOpenDatabaseException e) {
 407              dumpOpenFiles();
 408              throw e;
 409          }
 410      }
 411  
 412      public static void removePackageFromDb(final CacheDb cacheDb, final String packageName) {
 413          synchronized(sInvalidPackages) {
 414              sInvalidPackages.add(packageName);
 415          }
 416          new AsyncTask&lt;Void, Void, Void&gt;() {
 417              public Void doInBackground(Void ... args) {
 418                  SQLiteDatabase db = cacheDb.getWritableDatabase();
 419                  try {
 420                      db.delete(CacheDb.TABLE_NAME,
 421                              CacheDb.COLUMN_NAME + &quot; LIKE ? OR &quot; +
 422                              CacheDb.COLUMN_NAME + &quot; LIKE ?&quot;, // SELECT query
 423                              new String[] {
 424                                      WIDGET_PREFIX + packageName + &quot;/%&quot;,
 425                                      SHORTCUT_PREFIX + packageName + &quot;/%&quot;
 426                              } // args to SELECT query
 427                      );
 428                  } catch (SQLiteDiskIOException e) {
 429                  } catch (SQLiteCantOpenDatabaseException e) {
 430                      dumpOpenFiles();
 431                      throw e;
 432                  }
 433                  synchronized(sInvalidPackages) {
 434                      sInvalidPackages.remove(packageName);
 435                  }
 436                  return null;
 437              }
 438          }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 439      }
 440  
 441      private static void removeItemFromDb(final CacheDb cacheDb, final String objectName) {
 442          new AsyncTask&lt;Void, Void, Void&gt;() {
 443              public Void doInBackground(Void ... args) {
 444                  SQLiteDatabase db = cacheDb.getWritableDatabase();
 445                  try {
 446                      db.delete(CacheDb.TABLE_NAME,
 447                              CacheDb.COLUMN_NAME + &quot; = ? &quot;, // SELECT query
 448                              new String[] { objectName }); // args to SELECT query
 449                  } catch (SQLiteDiskIOException e) {
 450                  } catch (SQLiteCantOpenDatabaseException e) {
 451                      dumpOpenFiles();
 452                      throw e;
 453                  }
 454                  return null;
 455              }
 456          }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 457      }
 458  
 459      private Bitmap readFromDb(String name, Bitmap b) {
 460          if (mCachedSelectQuery == null) {
 461              mCachedSelectQuery = CacheDb.COLUMN_NAME + &quot; = ? AND &quot; +
 462                      CacheDb.COLUMN_SIZE + &quot; = ?&quot;;
 463          }
 464          SQLiteDatabase db = mDb.getReadableDatabase();
 465          Cursor result;
 466          try {
 467              result = db.query(CacheDb.TABLE_NAME,
 468                      new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, // cols to return
 469                      mCachedSelectQuery, // select query
 470                      new String[] { name, mSize }, // args to select query
 471                      null,
 472                      null,
 473                      null,
 474                      null);
 475          } catch (SQLiteDiskIOException e) {
 476              recreateDb();
 477              return null;
 478          } catch (SQLiteCantOpenDatabaseException e) {
 479              dumpOpenFiles();
 480              throw e;
 481          }
 482          if (result.getCount() &gt; 0) {
 483              result.moveToFirst();
 484              byte[] blob = result.getBlob(0);
 485              result.close();
 486              final BitmapFactory.Options opts = mCachedBitmapFactoryOptions.get();
 487              opts.inBitmap = b;
 488              opts.inSampleSize = 1;
 489              try {
 490                  return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);
 491              } catch (IllegalArgumentException e) {
 492                  removeItemFromDb(mDb, name);
 493                  return null;
 494              }
 495          } else {
 496              result.close();
 497              return null;
 498          }
 499      }
 500  
 501      private Bitmap generatePreview(Object info, Bitmap preview) {
 502          if (preview != null &amp;&amp;
 503                  (preview.getWidth() != mPreviewBitmapWidth ||
 504                  preview.getHeight() != mPreviewBitmapHeight)) {
 505              throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 506          }
 507          if (info instanceof AppWidgetProviderInfo) {
 508              return generateWidgetPreview((AppWidgetProviderInfo) info, preview);
 509          } else {
 510              return generateShortcutPreview(
 511                      (ResolveInfo) info, mPreviewBitmapWidth, mPreviewBitmapHeight, preview);
 512          }
 513      }
 514  
 515      public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, Bitmap preview) {
 516          int[] cellSpans = Launcher.getSpanForWidget(mContext, info);
 517          int maxWidth = maxWidthForWidgetPreview(cellSpans[0]);
 518          int maxHeight = maxHeightForWidgetPreview(cellSpans[1]);
 519          return generateWidgetPreview(info, cellSpans[0], cellSpans[1],
 520                  maxWidth, maxHeight, preview, null);
 521      }
 522  
 523      public int maxWidthForWidgetPreview(int spanX) {
 524          return Math.min(mPreviewBitmapWidth,
 525                  mWidgetSpacingLayout.estimateCellWidth(spanX));
 526      }
 527  
 528      public int maxHeightForWidgetPreview(int spanY) {
 529          return Math.min(mPreviewBitmapHeight,
 530                  mWidgetSpacingLayout.estimateCellHeight(spanY));
 531      }
 532  
 533      public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, int cellHSpan, int cellVSpan,
 534              int maxPreviewWidth, int maxPreviewHeight, Bitmap preview, int[] preScaledWidthOut) {
 535          // Load the preview image if possible
 536          if (maxPreviewWidth &lt; 0) maxPreviewWidth = Integer.MAX_VALUE;
 537          if (maxPreviewHeight &lt; 0) maxPreviewHeight = Integer.MAX_VALUE;
 538  
 539          Drawable drawable = null;
 540          if (info.previewImage != 0) {
 541              drawable = mManager.loadPreview(info);
 542              if (drawable != null) {
 543                  drawable = mutateOnMainThread(drawable);
 544              } else {
 545                  Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
 546                          Integer.toHexString(info.previewImage) + &quot; for provider: &quot; + info.provider);
 547              }
 548          }
 549  
 550          int previewWidth;
 551          int previewHeight;
 552          Bitmap defaultPreview = null;
 553          boolean widgetPreviewExists = (drawable != null);
 554          if (widgetPreviewExists) {
 555              previewWidth = drawable.getIntrinsicWidth();
 556              previewHeight = drawable.getIntrinsicHeight();
 557          } else {
 558              // Generate a preview image if we couldn&#x27;t load one
 559              if (cellHSpan &lt; 1) cellHSpan = 1;
 560              if (cellVSpan &lt; 1) cellVSpan = 1;
 561  
 562              // This Drawable is not directly drawn, so there&#x27;s no need to mutate it.
 563              BitmapDrawable previewDrawable = (BitmapDrawable) mContext.getResources()
 564                      .getDrawable(R.drawable.widget_tile);
 565              final int previewDrawableWidth = previewDrawable
 566                      .getIntrinsicWidth();
 567              final int previewDrawableHeight = previewDrawable
 568                      .getIntrinsicHeight();
 569              previewWidth = previewDrawableWidth * cellHSpan;
 570              previewHeight = previewDrawableHeight * cellVSpan;
 571  
 572              defaultPreview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 573              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 574              c.setBitmap(defaultPreview);
 575              Paint p = mDefaultAppWidgetPreviewPaint.get();
 576              if (p == null) {
 577                  p = new Paint();
 578                  p.setShader(new BitmapShader(previewDrawable.getBitmap(),
 579                          Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
 580                  mDefaultAppWidgetPreviewPaint.set(p);
 581              }
 582              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 583              dest.set(0, 0, previewWidth, previewHeight);
 584              c.drawRect(dest, p);
 585              c.setBitmap(null);
 586  
 587              // Draw the icon in the top left corner
 588              int minOffset = (int) (mAppIconSize * WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE);
 589              int smallestSide = Math.min(previewWidth, previewHeight);
 590              float iconScale = Math.min((float) smallestSide
 591                      / (mAppIconSize + 2 * minOffset), 1f);
 592  
 593              try {
 594                  Drawable icon = mManager.loadIcon(info, mIconCache);
 595                  if (icon != null) {
 596                      int hoffset = (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
 597                      int yoffset = (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
 598                      icon = mutateOnMainThread(icon);
 599                      renderDrawableToBitmap(icon, defaultPreview, hoffset,
 600                              yoffset, (int) (mAppIconSize * iconScale),
 601                              (int) (mAppIconSize * iconScale));
 602                  }
 603              } catch (Resources.NotFoundException e) {
 604              }
 605          }
 606  
 607          // Scale to fit width only - let the widget preview be clipped in the
 608          // vertical dimension
 609          float scale = 1f;
 610          if (preScaledWidthOut != null) {
 611              preScaledWidthOut[0] = previewWidth;
 612          }
 613          if (previewWidth &gt; maxPreviewWidth) {
 614              scale = maxPreviewWidth / (float) previewWidth;
 615          }
 616          if (scale != 1f) {
 617              previewWidth = (int) (scale * previewWidth);
 618              previewHeight = (int) (scale * previewHeight);
 619          }
 620  
 621          // If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size
 622          if (preview == null) {
 623              preview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 624          }
 625  
 626          // Draw the scaled preview into the final bitmap
 627          int x = (preview.getWidth() - previewWidth) / 2;
 628          if (widgetPreviewExists) {
 629              renderDrawableToBitmap(drawable, preview, x, 0, previewWidth,
 630                      previewHeight);
 631          } else {
 632              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 633              final Rect src = mCachedAppWidgetPreviewSrcRect.get();
 634              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 635              c.setBitmap(preview);
 636              src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
 637              dest.set(x, 0, x + previewWidth, previewHeight);
 638  
 639              Paint p = mCachedAppWidgetPreviewPaint.get();
 640              if (p == null) {
 641                  p = new Paint();
 642                  p.setFilterBitmap(true);
 643                  mCachedAppWidgetPreviewPaint.set(p);
 644              }
 645              c.drawBitmap(defaultPreview, src, dest, p);
 646              c.setBitmap(null);
 647          }
 648          return mManager.getBadgeBitmap(info, preview);
 649      }
 650  
 651      private Bitmap generateShortcutPreview(
 652              ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview) {
 653          Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
 654          final Canvas c = mCachedShortcutPreviewCanvas.get();
 655          if (tempBitmap == null ||
 656                  tempBitmap.getWidth() != maxWidth ||
 657                  tempBitmap.getHeight() != maxHeight) {
 658              tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 659              mCachedShortcutPreviewBitmap.set(tempBitmap);
 660          } else {
 661              c.setBitmap(tempBitmap);
 662              c.drawColor(0, PorterDuff.Mode.CLEAR);
 663              c.setBitmap(null);
 664          }
 665          // Render the icon
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -        Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +        Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info.activityInfo));</span>
 668  
 669          int paddingTop = mContext.
 670                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
 671          int paddingLeft = mContext.
 672                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
 673          int paddingRight = mContext.
 674                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
 675  
 676          int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
 677  
 678          renderDrawableToBitmap(
 679                  icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
 680  
 681          if (preview != null &amp;&amp;
 682                  (preview.getWidth() != maxWidth || preview.getHeight() != maxHeight)) {
 683              throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 684          } else if (preview == null) {
 685              preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 686          }
 687  
 688          c.setBitmap(preview);
 689          // Draw a desaturated/scaled version of the icon in the background as a watermark
 690          Paint p = mCachedShortcutPreviewPaint.get();
 691          if (p == null) {
 692              p = new Paint();
 693              ColorMatrix colorMatrix = new ColorMatrix();
 694              colorMatrix.setSaturation(0);
 695              p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
 696              p.setAlpha((int) (255 * 0.06f));
 697              mCachedShortcutPreviewPaint.set(p);
 698          }
 699          c.drawBitmap(tempBitmap, 0, 0, p);
 700          c.setBitmap(null);
 701  
 702          renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
 703  
 704          return preview;
 705      }
 706  
 707      private static void renderDrawableToBitmap(
 708              Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
 709          if (bitmap != null) {
 710              Canvas c = new Canvas(bitmap);
 711              Rect oldBounds = d.copyBounds();
 712              d.setBounds(x, y, x + w, y + h);
 713              d.draw(c);
 714              d.setBounds(oldBounds); // Restore the bounds
 715              c.setBitmap(null);
 716          }
 717      }
 718  
 719      private Drawable mutateOnMainThread(final Drawable drawable) {
 720          try {
 721              return mMainThreadExecutor.submit(new Callable&lt;Drawable&gt;() {
 722                  @Override
 723                  public Drawable call() throws Exception {
 724                      return drawable.mutate();
 725                  }
 726              }).get();
 727          } catch (InterruptedException e) {
 728              Thread.currentThread().interrupt();
 729              throw new RuntimeException(e);
 730          } catch (ExecutionException e) {
 731              throw new RuntimeException(e);
 732          }
 733      }
 734  
 735      private static final int MAX_OPEN_FILES = 1024;
 736      private static final int SAMPLE_RATE = 23;
 737      /**
 738       * Dumps all files that are open in this process without allocating a file descriptor.
 739       */
 740      private static void dumpOpenFiles() {
 741          try {
 742              Log.i(TAG, &quot;DUMP OF OPEN FILES (sample rate: 1 every &quot; + SAMPLE_RATE + &quot;):&quot;);
 743              final String TYPE_APK = &quot;apk&quot;;
 744              final String TYPE_JAR = &quot;jar&quot;;
 745              final String TYPE_PIPE = &quot;pipe&quot;;
 746              final String TYPE_SOCKET = &quot;socket&quot;;
 747              final String TYPE_DB = &quot;db&quot;;
 748              final String TYPE_ANON_INODE = &quot;anon_inode&quot;;
 749              final String TYPE_DEV = &quot;dev&quot;;
 750              final String TYPE_NON_FS = &quot;non-fs&quot;;
 751              final String TYPE_OTHER = &quot;other&quot;;
 752              List&lt;String&gt; types = Arrays.asList(TYPE_APK, TYPE_JAR, TYPE_PIPE, TYPE_SOCKET, TYPE_DB,
 753                      TYPE_ANON_INODE, TYPE_DEV, TYPE_NON_FS, TYPE_OTHER);
 754              int[] count = new int[types.size()];
 755              int[] duplicates = new int[types.size()];
 756              HashSet&lt;String&gt; files = new HashSet&lt;String&gt;();
 757              int total = 0;
 758              for (int i = 0; i &lt; MAX_OPEN_FILES; i++) {
 759                  // This is a gigantic hack but unfortunately the only way to resolve an fd
 760                  // to a file name. Note that we have to loop over all possible fds because
 761                  // reading the directory would require allocating a new fd. The kernel is
 762                  // currently implemented such that no fd is larger then the current rlimit,
 763                  // which is why it&#x27;s safe to loop over them in such a way.
 764                  String fd = &quot;/proc/self/fd/&quot; + i;
 765                  try {
 766                      // getCanonicalPath() uses readlink behind the scene which doesn&#x27;t require
 767                      // a file descriptor.
 768                      String resolved = new File(fd).getCanonicalPath();
 769                      int type = types.indexOf(TYPE_OTHER);
 770                      if (resolved.startsWith(&quot;/dev/&quot;)) {
 771                          type = types.indexOf(TYPE_DEV);
 772                      } else if (resolved.endsWith(&quot;.apk&quot;)) {
 773                          type = types.indexOf(TYPE_APK);
 774                      } else if (resolved.endsWith(&quot;.jar&quot;)) {
 775                          type = types.indexOf(TYPE_JAR);
 776                      } else if (resolved.contains(&quot;/fd/pipe:&quot;)) {
 777                          type = types.indexOf(TYPE_PIPE);
 778                      } else if (resolved.contains(&quot;/fd/socket:&quot;)) {
 779                          type = types.indexOf(TYPE_SOCKET);
 780                      } else if (resolved.contains(&quot;/fd/anon_inode:&quot;)) {
 781                          type = types.indexOf(TYPE_ANON_INODE);
 782                      } else if (resolved.endsWith(&quot;.db&quot;) || resolved.contains(&quot;/databases/&quot;)) {
 783                          type = types.indexOf(TYPE_DB);
 784                      } else if (resolved.startsWith(&quot;/proc/&quot;) &amp;&amp; resolved.contains(&quot;/fd/&quot;)) {
 785                          // Those are the files that don&#x27;t point anywhere on the file system.
 786                          // getCanonicalPath() wrongly interprets these as relative symlinks and
 787                          // resolves them within /proc/&lt;pid&gt;/fd/.
 788                          type = types.indexOf(TYPE_NON_FS);
 789                      }
 790                      count[type]++;
 791                      total++;
 792                      if (files.contains(resolved)) {
 793                          duplicates[type]++;
 794                      }
 795                      files.add(resolved);
 796                      if (total % SAMPLE_RATE == 0) {
 797                          Log.i(TAG, &quot; fd &quot; + i + &quot;: &quot; + resolved
 798                                  + &quot; (&quot; + types.get(type) + &quot;)&quot;);
 799                      }
 800                  } catch (IOException e) {
 801                      // Ignoring exceptions for non-existing file descriptors.
 802                  }
 803              }
 804              for (int i = 0; i &lt; types.size(); i++) {
 805                  Log.i(TAG, String.format(&quot;Open %10s files: %4d total, %4d duplicates&quot;,
 806                          types.get(i), count[i], duplicates[i]));
 807              }
 808          } catch (Throwable t) {
 809              // Catch everything. This is called from an exception handler that we shouldn&#x27;t upset.
 810              Log.e(TAG, &quot;Unable to log open files.&quot;, t);
 811          }
 812      }
 813  }</pre></td>
                            <td><pre>   1  package com.android.launcher3;
   2  
   3  import android.appwidget.AppWidgetProviderInfo;
   4  import android.content.ComponentName;
   5  import android.content.ContentValues;
   6  import android.content.Context;
   7  import android.content.SharedPreferences;
   8  import android.content.pm.ResolveInfo;
   9  import android.content.res.Resources;
  10  import android.database.Cursor;
  11  import android.database.sqlite.SQLiteCantOpenDatabaseException;
  12  import android.database.sqlite.SQLiteDatabase;
  13  import android.database.sqlite.SQLiteDiskIOException;
  14  import android.database.sqlite.SQLiteOpenHelper;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  15 +import android.database.sqlite.SQLiteReadOnlyDatabaseException;</span>
  16  import android.graphics.Bitmap;
  17  import android.graphics.Bitmap.Config;
  18  import android.graphics.BitmapFactory;
  19  import android.graphics.BitmapShader;
  20  import android.graphics.Canvas;
  21  import android.graphics.ColorMatrix;
  22  import android.graphics.ColorMatrixColorFilter;
  23  import android.graphics.Paint;
  24  import android.graphics.PorterDuff;
  25  import android.graphics.Rect;
  26  import android.graphics.Shader;
  27  import android.graphics.drawable.BitmapDrawable;
  28  import android.graphics.drawable.Drawable;
  29  import android.os.AsyncTask;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.os.Build;</span>
  31  import android.util.Log;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -</span>
  33  import com.android.launcher3.compat.AppWidgetManagerCompat;
  34  
  35  import java.io.ByteArrayOutputStream;
  36  import java.io.File;
  37  import java.io.IOException;
  38  import java.lang.ref.SoftReference;
  39  import java.lang.ref.WeakReference;
  40  import java.util.ArrayList;
  41  import java.util.Arrays;
  42  import java.util.HashMap;
  43  import java.util.HashSet;
  44  import java.util.List;
  45  import java.util.concurrent.Callable;
  46  import java.util.concurrent.ExecutionException;
  47  
  48  public class WidgetPreviewLoader {
  49  
  50      private static abstract class SoftReferenceThreadLocal&lt;T&gt; {
  51          private ThreadLocal&lt;SoftReference&lt;T&gt;&gt; mThreadLocal;
  52          public SoftReferenceThreadLocal() {
  53              mThreadLocal = new ThreadLocal&lt;SoftReference&lt;T&gt;&gt;();
  54          }
  55  
  56          abstract T initialValue();
  57  
  58          public void set(T t) {
  59              mThreadLocal.set(new SoftReference&lt;T&gt;(t));
  60          }
  61  
  62          public T get() {
  63              SoftReference&lt;T&gt; reference = mThreadLocal.get();
  64              T obj;
  65              if (reference == null) {
  66                  obj = initialValue();
  67                  mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  68                  return obj;
  69              } else {
  70                  obj = reference.get();
  71                  if (obj == null) {
  72                      obj = initialValue();
  73                      mThreadLocal.set(new SoftReference&lt;T&gt;(obj));
  74                  }
  75                  return obj;
  76              }
  77          }
  78      }
  79  
  80      private static class CanvasCache extends SoftReferenceThreadLocal&lt;Canvas&gt; {
  81          @Override
  82          protected Canvas initialValue() {
  83              return new Canvas();
  84          }
  85      }
  86  
  87      private static class PaintCache extends SoftReferenceThreadLocal&lt;Paint&gt; {
  88          @Override
  89          protected Paint initialValue() {
  90              return null;
  91          }
  92      }
  93  
  94      private static class BitmapCache extends SoftReferenceThreadLocal&lt;Bitmap&gt; {
  95          @Override
  96          protected Bitmap initialValue() {
  97              return null;
  98          }
  99      }
 100  
 101      private static class RectCache extends SoftReferenceThreadLocal&lt;Rect&gt; {
 102          @Override
 103          protected Rect initialValue() {
 104              return new Rect();
 105          }
 106      }
 107  
 108      private static class BitmapFactoryOptionsCache extends
 109              SoftReferenceThreadLocal&lt;BitmapFactory.Options&gt; {
 110          @Override
 111          protected BitmapFactory.Options initialValue() {
 112              return new BitmapFactory.Options();
 113          }
 114      }
 115  
 116      private static final String TAG = &quot;WidgetPreviewLoader&quot;;
 117      private static final String ANDROID_INCREMENTAL_VERSION_NAME_KEY = &quot;android.incremental.version&quot;;
 118  
 119      private static final float WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE = 0.25f;
 120      private static final HashSet&lt;String&gt; sInvalidPackages = new HashSet&lt;String&gt;();
 121  
 122      // Used for drawing shortcut previews
 123      private final BitmapCache mCachedShortcutPreviewBitmap = new BitmapCache();
 124      private final PaintCache mCachedShortcutPreviewPaint = new PaintCache();
 125      private final CanvasCache mCachedShortcutPreviewCanvas = new CanvasCache();
 126  
 127      // Used for drawing widget previews
 128      private final CanvasCache mCachedAppWidgetPreviewCanvas = new CanvasCache();
 129      private final RectCache mCachedAppWidgetPreviewSrcRect = new RectCache();
 130      private final RectCache mCachedAppWidgetPreviewDestRect = new RectCache();
 131      private final PaintCache mCachedAppWidgetPreviewPaint = new PaintCache();
 132      private final PaintCache mDefaultAppWidgetPreviewPaint = new PaintCache();
 133      private final BitmapFactoryOptionsCache mCachedBitmapFactoryOptions = new BitmapFactoryOptionsCache();
 134  
 135      private final HashMap&lt;String, WeakReference&lt;Bitmap&gt;&gt; mLoadedPreviews = new HashMap&lt;&gt;();
 136      private final ArrayList&lt;SoftReference&lt;Bitmap&gt;&gt; mUnusedBitmaps = new ArrayList&lt;&gt;();


 137  
 138      private final Context mContext;
 139      private final int mAppIconSize;
 140      private final IconCache mIconCache;
 141      private final AppWidgetManagerCompat mManager;
 142  
 143      private int mPreviewBitmapWidth;
 144      private int mPreviewBitmapHeight;
 145      private String mSize;
 146      private PagedViewCellLayout mWidgetSpacingLayout;
 147  
 148      private String mCachedSelectQuery;
 149  
 150  
 151      private CacheDb mDb;
 152  
 153      private final MainThreadExecutor mMainThreadExecutor = new MainThreadExecutor();
 154  
 155      public WidgetPreviewLoader(Context context) {
 156          LauncherAppState app = LauncherAppState.getInstance();
 157          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 158  
 159          mContext = context;
 160          mAppIconSize = grid.iconSizePx;
 161          mIconCache = app.getIconCache();
 162          mManager = AppWidgetManagerCompat.getInstance(context);
 163  
 164          mDb = app.getWidgetPreviewCacheDb();
 165  
 166          SharedPreferences sp = context.getSharedPreferences(
 167                  LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
 168          final String lastVersionName = sp.getString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, null);
 169          final String versionName = android.os.Build.VERSION.INCREMENTAL;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +        final boolean isLollipopOrGreater = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>
 171          if (!versionName.equals(lastVersionName)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -            // clear all the previews whenever the system version changes, to ensure that previews</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -            // are up-to-date for any apps that might have been updated with the system</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 174 -            clearDb();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 176 -            SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -            editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -            editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +                // clear all the previews whenever the system version changes, to ensure that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +                // previews are up-to-date for any apps that might have been updated with the system</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +                clearDb();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +            } catch (SQLiteReadOnlyDatabaseException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                if (isLollipopOrGreater) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +                    // Workaround for Bug. 18554839, if we fail to clear the db due to the read-only</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +                    // issue, then ignore this error and leave the old previews</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +                    throw e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +                editor.putString(ANDROID_INCREMENTAL_VERSION_NAME_KEY, versionName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +                editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +            }</span>


 195          }
 196      }
 197  
 198      public void recreateDb() {
 199          LauncherAppState app = LauncherAppState.getInstance();
 200          app.recreateWidgetPreviewDb();
 201          mDb = app.getWidgetPreviewCacheDb();
 202      }
 203  
 204      public void setPreviewSize(int previewWidth, int previewHeight,
 205              PagedViewCellLayout widgetSpacingLayout) {
 206          mPreviewBitmapWidth = previewWidth;
 207          mPreviewBitmapHeight = previewHeight;
 208          mSize = previewWidth + &quot;x&quot; + previewHeight;
 209          mWidgetSpacingLayout = widgetSpacingLayout;
 210      }
 211  
 212      public Bitmap getPreview(final Object o) {
 213          final String name = getObjectName(o);
 214          final String packageName = getObjectPackage(o);
 215          // check if the package is valid
 216          synchronized(sInvalidPackages) {
 217              boolean packageValid = !sInvalidPackages.contains(packageName);
 218              if (!packageValid) {
 219                  return null;
 220              }
 221          }
 222          synchronized(mLoadedPreviews) {
 223              // check if it exists in our existing cache
 224              if (mLoadedPreviews.containsKey(name)) {
 225                  WeakReference&lt;Bitmap&gt; bitmapReference = mLoadedPreviews.get(name);
 226                  Bitmap bitmap = bitmapReference.get();
 227                  if (bitmap != null) {
 228                      return bitmap;
 229                  }
 230              }
 231          }
 232  
 233          Bitmap unusedBitmap = null;
 234          synchronized(mUnusedBitmaps) {
 235              // not in cache; we need to load it from the db
 236              while (unusedBitmap == null &amp;&amp; mUnusedBitmaps.size() &gt; 0) {
 237                  Bitmap candidate = mUnusedBitmaps.remove(0).get();
 238                  if (candidate != null &amp;&amp; candidate.isMutable() &amp;&amp;
 239                          candidate.getWidth() == mPreviewBitmapWidth &amp;&amp;
 240                          candidate.getHeight() == mPreviewBitmapHeight) {
 241                      unusedBitmap = candidate;
 242                  }
 243              }
 244              if (unusedBitmap != null) {
 245                  final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 246                  c.setBitmap(unusedBitmap);
 247                  c.drawColor(0, PorterDuff.Mode.CLEAR);
 248                  c.setBitmap(null);
 249              }
 250          }
 251  
 252          if (unusedBitmap == null) {
 253              unusedBitmap = Bitmap.createBitmap(mPreviewBitmapWidth, mPreviewBitmapHeight,
 254                      Bitmap.Config.ARGB_8888);
 255          }
 256          Bitmap preview = readFromDb(name, unusedBitmap);
 257  
 258          if (preview != null) {
 259              synchronized(mLoadedPreviews) {
 260                  mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 261              }
 262              return preview;
 263          } else {
 264              // it&#x27;s not in the db... we need to generate it
 265              final Bitmap generatedPreview = generatePreview(o, unusedBitmap);
 266              preview = generatedPreview;
 267              if (preview != unusedBitmap) {
 268                  throw new RuntimeException(&quot;generatePreview is not recycling the bitmap &quot; + o);
 269              }
 270  
 271              synchronized(mLoadedPreviews) {
 272                  mLoadedPreviews.put(name, new WeakReference&lt;Bitmap&gt;(preview));
 273              }
 274  
 275              // write to db on a thread pool... this can be done lazily and improves the performance
 276              // of the first time widget previews are loaded
 277              new AsyncTask&lt;Void, Void, Void&gt;() {
 278                  public Void doInBackground(Void ... args) {
 279                      writeToDb(o, generatedPreview);
 280                      return null;
 281                  }
 282              }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 283  
 284              return preview;
 285          }
 286      }
 287  
 288      public void recycleBitmap(Object o, Bitmap bitmapToRecycle) {
 289          String name = getObjectName(o);
 290          synchronized (mLoadedPreviews) {
 291              if (mLoadedPreviews.containsKey(name)) {
 292                  Bitmap b = mLoadedPreviews.get(name).get();
 293                  if (b == bitmapToRecycle) {
 294                      mLoadedPreviews.remove(name);
 295                      if (bitmapToRecycle.isMutable()) {
 296                          synchronized (mUnusedBitmaps) {
 297                              mUnusedBitmaps.add(new SoftReference&lt;Bitmap&gt;(b));
 298                          }
 299                      }
 300                  } else {
 301                      throw new RuntimeException(&quot;Bitmap passed in doesn&#x27;t match up&quot;);
 302                  }
 303              }
 304          }
 305      }
 306  
 307      static class CacheDb extends SQLiteOpenHelper {
 308          final static int DB_VERSION = 2;
 309          final static String DB_NAME = &quot;widgetpreviews.db&quot;;
 310          final static String TABLE_NAME = &quot;shortcut_and_widget_previews&quot;;
 311          final static String COLUMN_NAME = &quot;name&quot;;
 312          final static String COLUMN_SIZE = &quot;size&quot;;
 313          final static String COLUMN_PREVIEW_BITMAP = &quot;preview_bitmap&quot;;
 314          Context mContext;
 315  
 316          public CacheDb(Context context) {
 317              super(context, new File(context.getCacheDir(), DB_NAME).getPath(), null, DB_VERSION);


 318              // Store the context for later use
 319              mContext = context;
 320          }
 321  
 322          @Override
 323          public void onCreate(SQLiteDatabase database) {
 324              database.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + TABLE_NAME + &quot; (&quot; +
 325                      COLUMN_NAME + &quot; TEXT NOT NULL, &quot; +
 326                      COLUMN_SIZE + &quot; TEXT NOT NULL, &quot; +
 327                      COLUMN_PREVIEW_BITMAP + &quot; BLOB NOT NULL, &quot; +
 328                      &quot;PRIMARY KEY (&quot; + COLUMN_NAME + &quot;, &quot; + COLUMN_SIZE + &quot;) &quot; +
 329                      &quot;);&quot;);
 330          }
 331  
 332          @Override
 333          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 334              if (oldVersion != newVersion) {
 335                  // Delete all the records; they&#x27;ll be repopulated as this is a cache
 336                  db.execSQL(&quot;DELETE FROM &quot; + TABLE_NAME);
 337              }
 338          }
 339      }
 340  
 341      private static final String WIDGET_PREFIX = &quot;Widget:&quot;;
 342      private static final String SHORTCUT_PREFIX = &quot;Shortcut:&quot;;
 343  
 344      private static String getObjectName(Object o) {
 345          // should cache the string builder
 346          StringBuilder sb = new StringBuilder();
 347          String output;
 348          if (o instanceof AppWidgetProviderInfo) {
 349              sb.append(WIDGET_PREFIX);
 350              sb.append(((AppWidgetProviderInfo) o).toString());
 351              output = sb.toString();
 352              sb.setLength(0);
 353          } else {
 354              sb.append(SHORTCUT_PREFIX);
 355  
 356              ResolveInfo info = (ResolveInfo) o;
 357              sb.append(new ComponentName(info.activityInfo.packageName,
 358                      info.activityInfo.name).flattenToString());
 359              output = sb.toString();
 360              sb.setLength(0);
 361          }
 362          return output;
 363      }
 364  
 365      private String getObjectPackage(Object o) {
 366          if (o instanceof AppWidgetProviderInfo) {
 367              return ((AppWidgetProviderInfo) o).provider.getPackageName();
 368          } else {
 369              ResolveInfo info = (ResolveInfo) o;
 370              return info.activityInfo.packageName;
 371          }
 372      }
 373  
 374      private void writeToDb(Object o, Bitmap preview) {
 375          String name = getObjectName(o);
 376          SQLiteDatabase db = mDb.getWritableDatabase();
 377          ContentValues values = new ContentValues();
 378  
 379          values.put(CacheDb.COLUMN_NAME, name);
 380          ByteArrayOutputStream stream = new ByteArrayOutputStream();
 381          preview.compress(Bitmap.CompressFormat.PNG, 100, stream);
 382          values.put(CacheDb.COLUMN_PREVIEW_BITMAP, stream.toByteArray());
 383          values.put(CacheDb.COLUMN_SIZE, mSize);
 384          try {
 385              db.insert(CacheDb.TABLE_NAME, null, values);
 386          } catch (SQLiteDiskIOException e) {
 387              recreateDb();
 388          } catch (SQLiteCantOpenDatabaseException e) {
 389              dumpOpenFiles();
 390              throw e;
 391          }
 392      }
 393  
 394      private void clearDb() {
 395          SQLiteDatabase db = mDb.getWritableDatabase();
 396          // Delete everything
 397          try {
 398              db.delete(CacheDb.TABLE_NAME, null, null);
 399          } catch (SQLiteDiskIOException e) {
 400          } catch (SQLiteCantOpenDatabaseException e) {
 401              dumpOpenFiles();
 402              throw e;
 403          }
 404      }
 405  
 406      public static void removePackageFromDb(final CacheDb cacheDb, final String packageName) {
 407          synchronized(sInvalidPackages) {
 408              sInvalidPackages.add(packageName);
 409          }
 410          new AsyncTask&lt;Void, Void, Void&gt;() {
 411              public Void doInBackground(Void ... args) {
 412                  SQLiteDatabase db = cacheDb.getWritableDatabase();
 413                  try {
 414                      db.delete(CacheDb.TABLE_NAME,
 415                              CacheDb.COLUMN_NAME + &quot; LIKE ? OR &quot; +
 416                              CacheDb.COLUMN_NAME + &quot; LIKE ?&quot;, // SELECT query
 417                              new String[] {
 418                                      WIDGET_PREFIX + packageName + &quot;/%&quot;,
 419                                      SHORTCUT_PREFIX + packageName + &quot;/%&quot;
 420                              } // args to SELECT query
 421                      );
 422                  } catch (SQLiteDiskIOException e) {
 423                  } catch (SQLiteCantOpenDatabaseException e) {
 424                      dumpOpenFiles();
 425                      throw e;
 426                  }
 427                  synchronized(sInvalidPackages) {
 428                      sInvalidPackages.remove(packageName);
 429                  }
 430                  return null;
 431              }
 432          }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 433      }
 434  
 435      private static void removeItemFromDb(final CacheDb cacheDb, final String objectName) {
 436          new AsyncTask&lt;Void, Void, Void&gt;() {
 437              public Void doInBackground(Void ... args) {
 438                  SQLiteDatabase db = cacheDb.getWritableDatabase();
 439                  try {
 440                      db.delete(CacheDb.TABLE_NAME,
 441                              CacheDb.COLUMN_NAME + &quot; = ? &quot;, // SELECT query
 442                              new String[] { objectName }); // args to SELECT query
 443                  } catch (SQLiteDiskIOException e) {
 444                  } catch (SQLiteCantOpenDatabaseException e) {
 445                      dumpOpenFiles();
 446                      throw e;
 447                  }
 448                  return null;
 449              }
 450          }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);
 451      }
 452  
 453      private Bitmap readFromDb(String name, Bitmap b) {
 454          if (mCachedSelectQuery == null) {
 455              mCachedSelectQuery = CacheDb.COLUMN_NAME + &quot; = ? AND &quot; +
 456                      CacheDb.COLUMN_SIZE + &quot; = ?&quot;;
 457          }
 458          SQLiteDatabase db = mDb.getReadableDatabase();
 459          Cursor result;
 460          try {
 461              result = db.query(CacheDb.TABLE_NAME,
 462                      new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, // cols to return
 463                      mCachedSelectQuery, // select query
 464                      new String[] { name, mSize }, // args to select query
 465                      null,
 466                      null,
 467                      null,
 468                      null);
 469          } catch (SQLiteDiskIOException e) {
 470              recreateDb();
 471              return null;
 472          } catch (SQLiteCantOpenDatabaseException e) {
 473              dumpOpenFiles();
 474              throw e;
 475          }
 476          if (result.getCount() &gt; 0) {
 477              result.moveToFirst();
 478              byte[] blob = result.getBlob(0);
 479              result.close();
 480              final BitmapFactory.Options opts = mCachedBitmapFactoryOptions.get();
 481              opts.inBitmap = b;
 482              opts.inSampleSize = 1;
 483              try {
 484                  return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);
 485              } catch (IllegalArgumentException e) {
 486                  removeItemFromDb(mDb, name);
 487                  return null;
 488              }
 489          } else {
 490              result.close();
 491              return null;
 492          }
 493      }
 494  
 495      private Bitmap generatePreview(Object info, Bitmap preview) {
 496          if (preview != null &amp;&amp;
 497                  (preview.getWidth() != mPreviewBitmapWidth ||
 498                  preview.getHeight() != mPreviewBitmapHeight)) {
 499              throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 500          }
 501          if (info instanceof AppWidgetProviderInfo) {
 502              return generateWidgetPreview((AppWidgetProviderInfo) info, preview);
 503          } else {
 504              return generateShortcutPreview(
 505                      (ResolveInfo) info, mPreviewBitmapWidth, mPreviewBitmapHeight, preview);
 506          }
 507      }
 508  
 509      public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, Bitmap preview) {
 510          int[] cellSpans = Launcher.getSpanForWidget(mContext, info);
 511          int maxWidth = maxWidthForWidgetPreview(cellSpans[0]);
 512          int maxHeight = maxHeightForWidgetPreview(cellSpans[1]);
 513          return generateWidgetPreview(info, cellSpans[0], cellSpans[1],
 514                  maxWidth, maxHeight, preview, null);
 515      }
 516  
 517      public int maxWidthForWidgetPreview(int spanX) {
 518          return Math.min(mPreviewBitmapWidth,
 519                  mWidgetSpacingLayout.estimateCellWidth(spanX));
 520      }
 521  
 522      public int maxHeightForWidgetPreview(int spanY) {
 523          return Math.min(mPreviewBitmapHeight,
 524                  mWidgetSpacingLayout.estimateCellHeight(spanY));
 525      }
 526  
 527      public Bitmap generateWidgetPreview(AppWidgetProviderInfo info, int cellHSpan, int cellVSpan,
 528              int maxPreviewWidth, int maxPreviewHeight, Bitmap preview, int[] preScaledWidthOut) {
 529          // Load the preview image if possible
 530          if (maxPreviewWidth &lt; 0) maxPreviewWidth = Integer.MAX_VALUE;
 531          if (maxPreviewHeight &lt; 0) maxPreviewHeight = Integer.MAX_VALUE;
 532  
 533          Drawable drawable = null;
 534          if (info.previewImage != 0) {
 535              drawable = mManager.loadPreview(info);
 536              if (drawable != null) {
 537                  drawable = mutateOnMainThread(drawable);
 538              } else {
 539                  Log.w(TAG, &quot;Can&#x27;t load widget preview drawable 0x&quot; +
 540                          Integer.toHexString(info.previewImage) + &quot; for provider: &quot; + info.provider);
 541              }
 542          }
 543  
 544          int previewWidth;
 545          int previewHeight;
 546          Bitmap defaultPreview = null;
 547          boolean widgetPreviewExists = (drawable != null);
 548          if (widgetPreviewExists) {
 549              previewWidth = drawable.getIntrinsicWidth();
 550              previewHeight = drawable.getIntrinsicHeight();
 551          } else {
 552              // Generate a preview image if we couldn&#x27;t load one
 553              if (cellHSpan &lt; 1) cellHSpan = 1;
 554              if (cellVSpan &lt; 1) cellVSpan = 1;
 555  
 556              // This Drawable is not directly drawn, so there&#x27;s no need to mutate it.
 557              BitmapDrawable previewDrawable = (BitmapDrawable) mContext.getResources()
 558                      .getDrawable(R.drawable.widget_tile);
 559              final int previewDrawableWidth = previewDrawable
 560                      .getIntrinsicWidth();
 561              final int previewDrawableHeight = previewDrawable
 562                      .getIntrinsicHeight();
 563              previewWidth = previewDrawableWidth * cellHSpan;
 564              previewHeight = previewDrawableHeight * cellVSpan;
 565  
 566              defaultPreview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 567              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 568              c.setBitmap(defaultPreview);
 569              Paint p = mDefaultAppWidgetPreviewPaint.get();
 570              if (p == null) {
 571                  p = new Paint();
 572                  p.setShader(new BitmapShader(previewDrawable.getBitmap(),
 573                          Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));
 574                  mDefaultAppWidgetPreviewPaint.set(p);
 575              }
 576              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 577              dest.set(0, 0, previewWidth, previewHeight);
 578              c.drawRect(dest, p);
 579              c.setBitmap(null);
 580  
 581              // Draw the icon in the top left corner
 582              int minOffset = (int) (mAppIconSize * WIDGET_PREVIEW_ICON_PADDING_PERCENTAGE);
 583              int smallestSide = Math.min(previewWidth, previewHeight);
 584              float iconScale = Math.min((float) smallestSide
 585                      / (mAppIconSize + 2 * minOffset), 1f);
 586  
 587              try {
 588                  Drawable icon = mManager.loadIcon(info, mIconCache);
 589                  if (icon != null) {
 590                      int hoffset = (int) ((previewDrawableWidth - mAppIconSize * iconScale) / 2);
 591                      int yoffset = (int) ((previewDrawableHeight - mAppIconSize * iconScale) / 2);
 592                      icon = mutateOnMainThread(icon);
 593                      renderDrawableToBitmap(icon, defaultPreview, hoffset,
 594                              yoffset, (int) (mAppIconSize * iconScale),
 595                              (int) (mAppIconSize * iconScale));
 596                  }
 597              } catch (Resources.NotFoundException e) {
 598              }
 599          }
 600  
 601          // Scale to fit width only - let the widget preview be clipped in the
 602          // vertical dimension
 603          float scale = 1f;
 604          if (preScaledWidthOut != null) {
 605              preScaledWidthOut[0] = previewWidth;
 606          }
 607          if (previewWidth &gt; maxPreviewWidth) {
 608              scale = maxPreviewWidth / (float) previewWidth;
 609          }
 610          if (scale != 1f) {
 611              previewWidth = (int) (scale * previewWidth);
 612              previewHeight = (int) (scale * previewHeight);
 613          }
 614  
 615          // If a bitmap is passed in, we use it; otherwise, we create a bitmap of the right size
 616          if (preview == null) {
 617              preview = Bitmap.createBitmap(previewWidth, previewHeight, Config.ARGB_8888);
 618          }
 619  
 620          // Draw the scaled preview into the final bitmap
 621          int x = (preview.getWidth() - previewWidth) / 2;
 622          if (widgetPreviewExists) {
 623              renderDrawableToBitmap(drawable, preview, x, 0, previewWidth,
 624                      previewHeight);
 625          } else {
 626              final Canvas c = mCachedAppWidgetPreviewCanvas.get();
 627              final Rect src = mCachedAppWidgetPreviewSrcRect.get();
 628              final Rect dest = mCachedAppWidgetPreviewDestRect.get();
 629              c.setBitmap(preview);
 630              src.set(0, 0, defaultPreview.getWidth(), defaultPreview.getHeight());
 631              dest.set(x, 0, x + previewWidth, previewHeight);
 632  
 633              Paint p = mCachedAppWidgetPreviewPaint.get();
 634              if (p == null) {
 635                  p = new Paint();
 636                  p.setFilterBitmap(true);
 637                  mCachedAppWidgetPreviewPaint.set(p);
 638              }
 639              c.drawBitmap(defaultPreview, src, dest, p);
 640              c.setBitmap(null);
 641          }
 642          return mManager.getBadgeBitmap(info, preview);
 643      }
 644  
 645      private Bitmap generateShortcutPreview(
 646              ResolveInfo info, int maxWidth, int maxHeight, Bitmap preview) {
 647          Bitmap tempBitmap = mCachedShortcutPreviewBitmap.get();
 648          final Canvas c = mCachedShortcutPreviewCanvas.get();
 649          if (tempBitmap == null ||
 650                  tempBitmap.getWidth() != maxWidth ||
 651                  tempBitmap.getHeight() != maxHeight) {
 652              tempBitmap = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 653              mCachedShortcutPreviewBitmap.set(tempBitmap);
 654          } else {
 655              c.setBitmap(tempBitmap);
 656              c.drawColor(0, PorterDuff.Mode.CLEAR);
 657              c.setBitmap(null);
 658          }
 659          // Render the icon
 660          Drawable icon = mutateOnMainThread(mIconCache.getFullResIcon(info));

 661  
 662          int paddingTop = mContext.
 663                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_top);
 664          int paddingLeft = mContext.
 665                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_left);
 666          int paddingRight = mContext.
 667                  getResources().getDimensionPixelOffset(R.dimen.shortcut_preview_padding_right);
 668  
 669          int scaledIconWidth = (maxWidth - paddingLeft - paddingRight);
 670  
 671          renderDrawableToBitmap(
 672                  icon, tempBitmap, paddingLeft, paddingTop, scaledIconWidth, scaledIconWidth);
 673  
 674          if (preview != null &amp;&amp;
 675                  (preview.getWidth() != maxWidth || preview.getHeight() != maxHeight)) {
 676              throw new RuntimeException(&quot;Improperly sized bitmap passed as argument&quot;);
 677          } else if (preview == null) {
 678              preview = Bitmap.createBitmap(maxWidth, maxHeight, Config.ARGB_8888);
 679          }
 680  
 681          c.setBitmap(preview);
 682          // Draw a desaturated/scaled version of the icon in the background as a watermark
 683          Paint p = mCachedShortcutPreviewPaint.get();
 684          if (p == null) {
 685              p = new Paint();
 686              ColorMatrix colorMatrix = new ColorMatrix();
 687              colorMatrix.setSaturation(0);
 688              p.setColorFilter(new ColorMatrixColorFilter(colorMatrix));
 689              p.setAlpha((int) (255 * 0.06f));
 690              mCachedShortcutPreviewPaint.set(p);
 691          }
 692          c.drawBitmap(tempBitmap, 0, 0, p);
 693          c.setBitmap(null);
 694  
 695          renderDrawableToBitmap(icon, preview, 0, 0, mAppIconSize, mAppIconSize);
 696  
 697          return preview;
 698      }
 699  
 700      private static void renderDrawableToBitmap(
 701              Drawable d, Bitmap bitmap, int x, int y, int w, int h) {
 702          if (bitmap != null) {
 703              Canvas c = new Canvas(bitmap);
 704              Rect oldBounds = d.copyBounds();
 705              d.setBounds(x, y, x + w, y + h);
 706              d.draw(c);
 707              d.setBounds(oldBounds); // Restore the bounds
 708              c.setBitmap(null);
 709          }
 710      }
 711  
 712      private Drawable mutateOnMainThread(final Drawable drawable) {
 713          try {
 714              return mMainThreadExecutor.submit(new Callable&lt;Drawable&gt;() {
 715                  @Override
 716                  public Drawable call() throws Exception {
 717                      return drawable.mutate();
 718                  }
 719              }).get();
 720          } catch (InterruptedException e) {
 721              Thread.currentThread().interrupt();
 722              throw new RuntimeException(e);
 723          } catch (ExecutionException e) {
 724              throw new RuntimeException(e);
 725          }
 726      }
 727  
 728      private static final int MAX_OPEN_FILES = 1024;
 729      private static final int SAMPLE_RATE = 23;
 730      /**
 731       * Dumps all files that are open in this process without allocating a file descriptor.
 732       */
 733      private static void dumpOpenFiles() {
 734          try {
 735              Log.i(TAG, &quot;DUMP OF OPEN FILES (sample rate: 1 every &quot; + SAMPLE_RATE + &quot;):&quot;);
 736              final String TYPE_APK = &quot;apk&quot;;
 737              final String TYPE_JAR = &quot;jar&quot;;
 738              final String TYPE_PIPE = &quot;pipe&quot;;
 739              final String TYPE_SOCKET = &quot;socket&quot;;
 740              final String TYPE_DB = &quot;db&quot;;
 741              final String TYPE_ANON_INODE = &quot;anon_inode&quot;;
 742              final String TYPE_DEV = &quot;dev&quot;;
 743              final String TYPE_NON_FS = &quot;non-fs&quot;;
 744              final String TYPE_OTHER = &quot;other&quot;;
 745              List&lt;String&gt; types = Arrays.asList(TYPE_APK, TYPE_JAR, TYPE_PIPE, TYPE_SOCKET, TYPE_DB,
 746                      TYPE_ANON_INODE, TYPE_DEV, TYPE_NON_FS, TYPE_OTHER);
 747              int[] count = new int[types.size()];
 748              int[] duplicates = new int[types.size()];
 749              HashSet&lt;String&gt; files = new HashSet&lt;String&gt;();
 750              int total = 0;
 751              for (int i = 0; i &lt; MAX_OPEN_FILES; i++) {
 752                  // This is a gigantic hack but unfortunately the only way to resolve an fd
 753                  // to a file name. Note that we have to loop over all possible fds because
 754                  // reading the directory would require allocating a new fd. The kernel is
 755                  // currently implemented such that no fd is larger then the current rlimit,
 756                  // which is why it&#x27;s safe to loop over them in such a way.
 757                  String fd = &quot;/proc/self/fd/&quot; + i;
 758                  try {
 759                      // getCanonicalPath() uses readlink behind the scene which doesn&#x27;t require
 760                      // a file descriptor.
 761                      String resolved = new File(fd).getCanonicalPath();
 762                      int type = types.indexOf(TYPE_OTHER);
 763                      if (resolved.startsWith(&quot;/dev/&quot;)) {
 764                          type = types.indexOf(TYPE_DEV);
 765                      } else if (resolved.endsWith(&quot;.apk&quot;)) {
 766                          type = types.indexOf(TYPE_APK);
 767                      } else if (resolved.endsWith(&quot;.jar&quot;)) {
 768                          type = types.indexOf(TYPE_JAR);
 769                      } else if (resolved.contains(&quot;/fd/pipe:&quot;)) {
 770                          type = types.indexOf(TYPE_PIPE);
 771                      } else if (resolved.contains(&quot;/fd/socket:&quot;)) {
 772                          type = types.indexOf(TYPE_SOCKET);
 773                      } else if (resolved.contains(&quot;/fd/anon_inode:&quot;)) {
 774                          type = types.indexOf(TYPE_ANON_INODE);
 775                      } else if (resolved.endsWith(&quot;.db&quot;) || resolved.contains(&quot;/databases/&quot;)) {
 776                          type = types.indexOf(TYPE_DB);
 777                      } else if (resolved.startsWith(&quot;/proc/&quot;) &amp;&amp; resolved.contains(&quot;/fd/&quot;)) {
 778                          // Those are the files that don&#x27;t point anywhere on the file system.
 779                          // getCanonicalPath() wrongly interprets these as relative symlinks and
 780                          // resolves them within /proc/&lt;pid&gt;/fd/.
 781                          type = types.indexOf(TYPE_NON_FS);
 782                      }
 783                      count[type]++;
 784                      total++;
 785                      if (files.contains(resolved)) {
 786                          duplicates[type]++;
 787                      }
 788                      files.add(resolved);
 789                      if (total % SAMPLE_RATE == 0) {
 790                          Log.i(TAG, &quot; fd &quot; + i + &quot;: &quot; + resolved
 791                                  + &quot; (&quot; + types.get(type) + &quot;)&quot;);
 792                      }
 793                  } catch (IOException e) {
 794                      // Ignoring exceptions for non-existing file descriptors.
 795                  }
 796              }
 797              for (int i = 0; i &lt; types.size(); i++) {
 798                  Log.i(TAG, String.format(&quot;Open %10s files: %4d total, %4d duplicates&quot;,
 799                          types.get(i), count[i], duplicates[i]));
 800              }
 801          } catch (Throwable t) {
 802              // Catch everything. This is called from an exception handler that we shouldn&#x27;t upset.
 803              Log.e(TAG, &quot;Unable to log open files.&quot;, t);
 804          }
 805      }
 806  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            