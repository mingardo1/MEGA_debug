<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>579</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    579
                    <a href="578.html">prev</a>
                    <a href="580.html">next</a>
                    <a href="579_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_c03f8c04714b919999dafa1551d6a2834ce6e15b_src/com/android/launcher3/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c03f8c04714b919999dafa1551d6a2834ce6e15b:src/com/android/launcher3/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c03f8c04714b919999dafa1551d6a2834ce6e15b^1:src/com/android/launcher3/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c03f8c04714b919999dafa1551d6a2834ce6e15b^2:src/com/android/launcher3/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;0c2918f4f4c4a9a6609b82cf23155ed51840f2c8:src/com/android/launcher3/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 202         public void bindShortcutsUpdated(ArrayList&lt;ShortcutInfo&gt; shortcuts);</span>
 203 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 204         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);</span>
 205 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 206         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);</span>
 207 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 208         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 209         public void updatePackageBadge(String packageName);
 210         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 211                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 212         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 213         public void bindSearchablesChanged();
 214         public boolean isAllAppsButtonRank(int rank);
 215         public void onPageBoundSynchronously(int page);
 216         public void dumpLogsToLocalData();
 217     }
 218 
 219     public interface ItemInfoFilter {
 220         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 221     }
 222 
 223     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 224         Context context = app.getContext();
 225 
 226         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 227         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 228         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 229         // resource string.
 230         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 231         ProviderInfo providerInfo =
 232                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 233         ProviderInfo redirectProvider =
 234                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 235 
 236         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 237         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 238 
 239         if (mOldContentProviderExists) {
 240             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 241         } else {
 242             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 243         }
 244 
 245         mApp = app;
 246         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 247         mIconCache = iconCache;
 248 
 249         final Resources res = context.getResources();
 250         Configuration config = res.getConfiguration();
 251         mPreviousConfigMcc = config.mcc;
 252         mLauncherApps = LauncherAppsCompat.getInstance(context);
 253         mUserManager = UserManagerCompat.getInstance(context);
 254     }
 255 
 256     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 257      * posted on the main thread handler. */
 258     private void runOnMainThread(Runnable r) {
 259         runOnMainThread(r, 0);
 260     }
 261     private void runOnMainThread(Runnable r, int type) {
 262         if (sWorkerThread.getThreadId() == Process.myTid()) {
 263             // If we are on the worker thread, post onto the main handler
 264             mHandler.post(r);
 265         } else {
 266             r.run();
 267         }
 268     }
 269 
 270     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 271      * posted on the worker thread handler. */
 272     private static void runOnWorkerThread(Runnable r) {
 273         if (sWorkerThread.getThreadId() == Process.myTid()) {
 274             r.run();
 275         } else {
 276             // If we are not on the worker thread, then post to the worker handler
 277             sWorker.post(r);
 278         }
 279     }
 280 
 281     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 282         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 283     }
 284 
 285     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 286                                  long screen) {
 287         LauncherAppState app = LauncherAppState.getInstance();
 288         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 289         final int xCount = (int) grid.numColumns;
 290         final int yCount = (int) grid.numRows;
 291         boolean[][] occupied = new boolean[xCount][yCount];
 292 
 293         int cellX, cellY, spanX, spanY;
 294         for (int i = 0; i &lt; items.size(); ++i) {
 295             final ItemInfo item = items.get(i);
 296             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 297                 if (item.screenId == screen) {
 298                     cellX = item.cellX;
 299                     cellY = item.cellY;
 300                     spanX = item.spanX;
 301                     spanY = item.spanY;
 302                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 303                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 304                             occupied[x][y] = true;
 305                         }
 306                     }
 307                 }
 308             }
 309         }
 310 
 311         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 312     }
 313     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 314                                                         Intent launchIntent,
 315                                                         int firstScreenIndex,
 316                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 317         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 318         LauncherAppState app = LauncherAppState.getInstance();
 319         LauncherModel model = app.getModel();
 320         boolean found = false;
 321         synchronized (app) {
 322             if (sWorkerThread.getThreadId() != Process.myTid()) {
 323                 // Flush the LauncherModel worker thread, so that if we just did another
 324                 // processInstallShortcut, we give it time for its shortcut to get added to the
 325                 // database (getItemsInLocalCoordinates reads the database)
 326                 model.flushWorkerThread();
 327             }
 328             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 329 
 330             // Try adding to the workspace screens incrementally, starting at the default or center
 331             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 332             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 333             int count = workspaceScreens.size();
 334             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 335                 int[] tmpCoordinates = new int[2];
 336                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 337                         workspaceScreens.get(screen))) {
 338                     // Update the Launcher db
 339                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 340                 }
 341             }
 342         }
 343         return null;
 344     }
 345 
 346     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 347         // Process the updated package state
 348         Runnable r = new Runnable() {
 349             public void run() {
 350                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 351                 if (callbacks != null) {
 352                     callbacks.updatePackageState(installInfo);
 353                 }
 354             }
 355         };
 356         mHandler.post(r);
 357     }
 358 
 359     public void updatePackageBadge(final String packageName) {
 360         // Process the updated package badge
 361         Runnable r = new Runnable() {
 362             public void run() {
 363                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 364                 if (callbacks != null) {
 365                     callbacks.updatePackageBadge(packageName);
 366                 }
 367             }
 368         };
 369         mHandler.post(r);
 370     }
 371 
 372     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 373         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 374 
 375         if (allAppsApps == null) {
 376             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 377         }
 378         if (allAppsApps.isEmpty()) {
 379             return;
 380         }
 381 
 382         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 383         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 384         while (iter.hasNext()) {
 385             ItemInfo a = iter.next();
 386             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 387                 restoredAppsFinal.add((AppInfo) a);
 388             }
 389         }
 390 
 391         // Process the newly added applications and add them to the database first
 392         Runnable r = new Runnable() {
 393             public void run() {
 394                 runOnMainThread(new Runnable() {
 395                     public void run() {
 396                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 397                         if (callbacks == cb &amp;&amp; cb != null) {
 398                             if (!restoredAppsFinal.isEmpty()) {
 399                                 for (AppInfo info : restoredAppsFinal) {
 400                                     final Intent intent = info.getIntent();
 401                                     if (intent != null) {
 402                                         mIconCache.deletePreloadedIcon(intent.getComponent(),
 403                                                 info.user);
 404                                     }
 405                                 }
 406                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 407                             }
 408                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 409                         }
 410                     }
 411                 });
 412             }
 413         };
 414         runOnWorkerThread(r);
 415     }
 416 
 417     public void addAndBindAddedWorkspaceApps(final Context context,
 418             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 419         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 420 
 421         if (workspaceApps == null) {
 422             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 423         }
 424         if (workspaceApps.isEmpty()) {
 425             return;
 426         }
 427         // Process the newly added applications and add them to the database first
 428         Runnable r = new Runnable() {
 429             public void run() {
 430                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 431                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 432                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 433 
 434                 // Get the list of workspace screens.  We need to append to this list and
 435                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 436                 // called.
 437                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 438                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 439                 for (Integer i : orderedScreens.keySet()) {
 440                     long screenId = orderedScreens.get(i);
 441                     workspaceScreens.add(screenId);
 442                 }
 443 
 444                 synchronized(sBgLock) {
 445                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 446                     while (iter.hasNext()) {
 447                         ItemInfo a = iter.next();
 448                         final String name = a.title.toString();
 449                         final Intent launchIntent = a.getIntent();
 450 
 451                         // Short-circuit this logic if the icon exists somewhere on the workspace
 452                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 453                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 454                             if (a instanceof AppInfo &amp;&amp;
 455                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 456                                 restoredAppsFinal.add((AppInfo) a);
 457                             }
 458                             continue;
 459                         }
 460 
 461                         // Add this icon to the db, creating a new page if necessary.  If there
 462                         // is only the empty page then we just add items to the first page.
 463                         // Otherwise, we add them to the next pages.
 464                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 465                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 466                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 467                         if (coords == null) {
 468                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 469 
 470                             // If we can&#x27;t find a valid position, then just add a new screen.
 471                             // This takes time so we need to re-queue the add until the new
 472                             // page is added.  Create as many screens as necessary to satisfy
 473                             // the startSearchPageIndex.
 474                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 475                                     workspaceScreens.size());
 476                             while (numPagesToAdd &gt; 0) {
 477                                 long screenId = lp.generateNewScreenId();
 478                                 // Save the screen id for binding in the workspace
 479                                 workspaceScreens.add(screenId);
 480                                 addedWorkspaceScreensFinal.add(screenId);
 481                                 numPagesToAdd--;
 482                             }
 483 
 484                             // Find the coordinate again
 485                             coords = LauncherModel.findNextAvailableIconSpace(context,
 486                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 487                         }
 488                         if (coords == null) {
 489                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 490                         }
 491 
 492                         ShortcutInfo shortcutInfo;
 493                         if (a instanceof ShortcutInfo) {
 494                             shortcutInfo = (ShortcutInfo) a;
 495                         } else if (a instanceof AppInfo) {
 496                             shortcutInfo = ((AppInfo) a).makeShortcut();
 497                         } else {
 498                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 499                         }
 500 
 501                         // Add the shortcut to the db
 502                         addItemToDatabase(context, shortcutInfo,
 503                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 504                                 coords.first, coords.second[0], coords.second[1], false);
 505                         // Save the ShortcutInfo for binding in the workspace
 506                         addedShortcutsFinal.add(shortcutInfo);
 507                     }
 508                 }
 509 
 510                 // Update the workspace screens
 511                 updateWorkspaceScreenOrder(context, workspaceScreens);
 512 
 513                 if (!addedShortcutsFinal.isEmpty()) {
 514                     runOnMainThread(new Runnable() {
 515                         public void run() {
 516                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 517                             if (callbacks == cb &amp;&amp; cb != null) {
 518                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 519                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 520                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 521                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 521                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 522                                     long lastScreenId = info.screenId;
 523                                     for (ItemInfo i : addedShortcutsFinal) {
 524                                         if (i.screenId == lastScreenId) {
 525                                             addAnimated.add(i);
 526                                         } else {
 527                                             addNotAnimated.add(i);
 528                                         }
 529                                     }
 530                                 }
 531                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 532                                         addNotAnimated, addAnimated, null);
 533                                 if (!restoredAppsFinal.isEmpty()) {
 534                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 535                                 }
 536                             }
 537                         }
 538                     });
 539                 }
 540             }
 541         };
 542         runOnWorkerThread(r);
 543     }
 544 
 545     public void unbindItemInfosAndClearQueuedBindRunnables() {
 546         if (sWorkerThread.getThreadId() == Process.myTid()) {
 547             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 548                     &quot;main thread&quot;);
 549         }
 550 
 551         // Clear any deferred bind runnables
 552         synchronized (mDeferredBindRunnables) {
 553             mDeferredBindRunnables.clear();
 554         }
 555         // Remove any queued bind runnables
 556         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 557         // Unbind all the workspace items
 558         unbindWorkspaceItemsOnMainThread();
 559     }
 560 
 561     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 562     void unbindWorkspaceItemsOnMainThread() {
 563         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 564         // by making a copy of workspace items first.
 565         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 566         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 567         synchronized (sBgLock) {
 568             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 569             tmpAppWidgets.addAll(sBgAppWidgets);
 570         }
 571         Runnable r = new Runnable() {
 572                 @Override
 573                 public void run() {
 574                    for (ItemInfo item : tmpWorkspaceItems) {
 575                        item.unbind();
 576                    }
 577                    for (ItemInfo item : tmpAppWidgets) {
 578                        item.unbind();
 579                    }
 580                 }
 581             };
 582         runOnMainThread(r);
 583     }
 584 
 585     /**
 586      * Adds an item to the DB if it was not created previously, or move it to a new
 587      * &lt;container, screen, cellX, cellY&gt;
 588      */
 589     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 590             long screenId, int cellX, int cellY) {
 591         if (item.container == ItemInfo.NO_ID) {
 592             // From all apps
 593             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 594         } else {
 595             // From somewhere else
 596             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 597         }
 598     }
 599 
 600     static void checkItemInfoLocked(
 601             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 602         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 603         if (modelItem != null &amp;&amp; item != modelItem) {
 604             // check all the data is consistent
 605             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 606                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 607                 ShortcutInfo shortcut = (ShortcutInfo) item;
 608                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 609                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 610                         modelShortcut.id == shortcut.id &amp;&amp;
 611                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 612                         modelShortcut.container == shortcut.container &amp;&amp;
 613                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 614                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 615                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 616                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 617                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 618                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 619                         (modelShortcut.dropPos != null &amp;&amp;
 620                                 shortcut.dropPos != null &amp;&amp;
 621                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 622                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 623                     // For all intents and purposes, this is the same object
 624                     return;
 625                 }
 626             }
 627 
 628             // the modelItem needs to match up perfectly with item if our model is
 629             // to be consistent with the database-- for now, just require
 630             // modelItem == item or the equality check above
 631             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 632                     &quot;modelItem: &quot; +
 633                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 634                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 635             RuntimeException e = new RuntimeException(msg);
 636             if (stackTrace != null) {
 637                 e.setStackTrace(stackTrace);
 638             }
 639             throw e;
 640         }
 641     }
 642 
 643     static void checkItemInfo(final ItemInfo item) {
 644         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 645         final long itemId = item.id;
 646         Runnable r = new Runnable() {
 647             public void run() {
 648                 synchronized (sBgLock) {
 649                     checkItemInfoLocked(itemId, item, stackTrace);
 650                 }
 651             }
 652         };
 653         runOnWorkerThread(r);
 654     }
 655 
 656     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 657             final ItemInfo item, final String callingFunction) {
 658         final long itemId = item.id;
 659         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 660         final ContentResolver cr = context.getContentResolver();
 661 
 662         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 663         Runnable r = new Runnable() {
 664             public void run() {
 665                 cr.update(uri, values, null, null);
 666                 updateItemArrays(item, itemId, stackTrace);
 667             }
 668         };
 669         runOnWorkerThread(r);
 670     }
 671 
 672     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 673             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 674         final ContentResolver cr = context.getContentResolver();
 675 
 676         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 677         Runnable r = new Runnable() {
 678             public void run() {
 679                 ArrayList&lt;ContentProviderOperation&gt; ops =
 680                         new ArrayList&lt;ContentProviderOperation&gt;();
 681                 int count = items.size();
 682                 for (int i = 0; i &lt; count; i++) {
 683                     ItemInfo item = items.get(i);
 684                     final long itemId = item.id;
 685                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 686                     ContentValues values = valuesList.get(i);
 687 
 688                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 689                     updateItemArrays(item, itemId, stackTrace);
 690 
 691                 }
 692                 try {
 693                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 694                 } catch (Exception e) {
 695                     e.printStackTrace();
 696                 }
 697             }
 698         };
 699         runOnWorkerThread(r);
 700     }
 701 
 702     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 703         // Lock on mBgLock *after* the db operation
 704         synchronized (sBgLock) {
 705             checkItemInfoLocked(itemId, item, stackTrace);
 706 
 707             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 708                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 709                 // Item is in a folder, make sure this folder exists
 710                 if (!sBgFolders.containsKey(item.container)) {
 711                     // An items container is being set to a that of an item which is not in
 712                     // the list of Folders.
 713                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 714                             item.container + &quot;, not in the list of folders&quot;;
 715                     Log.e(TAG, msg);
 716                 }
 717             }
 718 
 719             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 720             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 721             // that are on the desktop, as appropriate
 722             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 723             if (modelItem != null &amp;&amp;
 724                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 725                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 726                 switch (modelItem.itemType) {
 727                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 728                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 729                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 730                         if (!sBgWorkspaceItems.contains(modelItem)) {
 731                             sBgWorkspaceItems.add(modelItem);
 732                         }
 733                         break;
 734                     default:
 735                         break;
 736                 }
 737             } else {
 738                 sBgWorkspaceItems.remove(modelItem);
 739             }
 740         }
 741     }
 742 
 743     public void flushWorkerThread() {
 744         mFlushingWorkerThread = true;
 745         Runnable waiter = new Runnable() {
 746                 public void run() {
 747                     synchronized (this) {
 748                         notifyAll();
 749                         mFlushingWorkerThread = false;
 750                     }
 751                 }
 752             };
 753 
 754         synchronized(waiter) {
 755             runOnWorkerThread(waiter);
 756             if (mLoaderTask != null) {
 757                 synchronized(mLoaderTask) {
 758                     mLoaderTask.notify();
 759                 }
 760             }
 761             boolean success = false;
 762             while (!success) {
 763                 try {
 764                     waiter.wait();
 765                     success = true;
 766                 } catch (InterruptedException e) {
 767                 }
 768             }
 769         }
 770     }
 771 
 772     /**
 773      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 774      */
 775     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 776             final long screenId, final int cellX, final int cellY) {
 777         item.container = container;
 778         item.cellX = cellX;
 779         item.cellY = cellY;
 780 
 781         // We store hotseat items in canonical form which is this orientation invariant position
 782         // in the hotseat
 783         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 784                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 785             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 786         } else {
 787             item.screenId = screenId;
 788         }
 789 
 790         final ContentValues values = new ContentValues();
 791         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 792         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 793         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 794         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 795 
 796         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 797     }
 798 
 799     /**
 800      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 801      * cellX, cellY have already been updated on the ItemInfos.
 802      */
 803     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 804             final long container, final int screen) {
 805 
 806         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 807         int count = items.size();
 808 
 809         for (int i = 0; i &lt; count; i++) {
 810             ItemInfo item = items.get(i);
 811             item.container = container;
 812 
 813             // We store hotseat items in canonical form which is this orientation invariant position
 814             // in the hotseat
 815             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 816                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 817                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 818                         item.cellY);
 819             } else {
 820                 item.screenId = screen;
 821             }
 822 
 823             final ContentValues values = new ContentValues();
 824             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 825             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 826             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 827             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 828 
 829             contentValues.add(values);
 830         }
 831         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 832     }
 833 
 834     /**
 835      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 836      */
 837     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 838             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 839         item.container = container;
 840         item.cellX = cellX;
 841         item.cellY = cellY;
 842         item.spanX = spanX;
 843         item.spanY = spanY;
 844 
 845         // We store hotseat items in canonical form which is this orientation invariant position
 846         // in the hotseat
 847         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 848                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 849             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 850         } else {
 851             item.screenId = screenId;
 852         }
 853 
 854         final ContentValues values = new ContentValues();
 855         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 856         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 857         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 858         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 859         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 860         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 861 
 862         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 863     }
 864 
 865     /**
 866      * Update an item to the database in a specified container.
 867      */
 868     static void updateItemInDatabase(Context context, final ItemInfo item) {
 869         final ContentValues values = new ContentValues();
 870         item.onAddToDatabase(context, values);
 871         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 872         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 873     }
 874 
 875     /**
 876      * Returns true if the shortcuts already exists in the database.
 877      * we identify a shortcut by its title and intent.
 878      */
 879     static boolean shortcutExists(Context context, String title, Intent intent) {
 880         final ContentResolver cr = context.getContentResolver();
 881         final Intent intentWithPkg, intentWithoutPkg;
 882 
 883         if (intent.getComponent() != null) {
 884             // If component is not null, an intent with null package will produce
 885             // the same result and should also be a match.
 886             if (intent.getPackage() != null) {
 887                 intentWithPkg = intent;
 888                 intentWithoutPkg = new Intent(intent).setPackage(null);
 889             } else {
 890                 intentWithPkg = new Intent(intent).setPackage(
 891                         intent.getComponent().getPackageName());
 892                 intentWithoutPkg = intent;
 893             }
 894         } else {
 895             intentWithPkg = intent;
 896             intentWithoutPkg = intent;
 897         }
 898         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 899             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 900             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 901         boolean result = false;
 902         try {
 903             result = c.moveToFirst();
 904         } finally {
 905             c.close();
 906         }
 907         return result;
 908     }
 909 
 910     /**
 911      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 912      */
 913     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 914         final ComponentName component = intent.getComponent();
 915         if (component == null) {
 916             return false;
 917         }
 918         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 919     }
 920 
 921     /**
 922      * Returns an ItemInfo array containing all the items in the LauncherModel.
 923      * The ItemInfo.id is not set through this function.
 924      */
 925     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 926         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 927         final ContentResolver cr = context.getContentResolver();
 928         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 929                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 930                 LauncherSettings.Favorites.SCREEN,
 931                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 932                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 933                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 934 
 935         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 936         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 937         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 938         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 939         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 940         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 941         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 942         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 943         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 944         try {
 945             while (c.moveToNext()) {
 946                 ItemInfo item = new ItemInfo();
 947                 item.cellX = c.getInt(cellXIndex);
 948                 item.cellY = c.getInt(cellYIndex);
 949                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 950                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 951                 item.container = c.getInt(containerIndex);
 952                 item.itemType = c.getInt(itemTypeIndex);
 953                 item.screenId = c.getInt(screenIndex);
 954                 long serialNumber = c.getInt(profileIdIndex);
 955                 item.user = userManager.getUserForSerialNumber(serialNumber);
 956                 // Skip if user has been deleted.
 957                 if (item.user != null) {
 958                     items.add(item);
 959                 }
 960             }
 961         } catch (Exception e) {
 962             items.clear();
 963         } finally {
 964             c.close();
 965         }
 966 
 967         return items;
 968     }
 969 
 970     /**
 971      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 972      */
 973     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 974         final ContentResolver cr = context.getContentResolver();
 975         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 976                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 977                 new String[] { String.valueOf(id),
 978                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 979 
 980         try {
 981             if (c.moveToFirst()) {
 982                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 983                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 984                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 985                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 986                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 987                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 988 
 989                 FolderInfo folderInfo = null;
 990                 switch (c.getInt(itemTypeIndex)) {
 991                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 992                         folderInfo = findOrMakeFolder(folderList, id);
 993                         break;
 994                 }
 995 
 996                 folderInfo.title = c.getString(titleIndex);
 997                 folderInfo.id = id;
 998                 folderInfo.container = c.getInt(containerIndex);
 999                 folderInfo.screenId = c.getInt(screenIndex);
1000                 folderInfo.cellX = c.getInt(cellXIndex);
1001                 folderInfo.cellY = c.getInt(cellYIndex);
1002 
1003                 return folderInfo;
1004             }
1005         } finally {
1006             c.close();
1007         }
1008 
1009         return null;
1010     }
1011 
1012     /**
1013      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1014      * cellY fields of the item. Also assigns an ID to the item.
1015      */
1016     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1017             final long screenId, final int cellX, final int cellY, final boolean notify) {
1018         item.container = container;
1019         item.cellX = cellX;
1020         item.cellY = cellY;
1021         // We store hotseat items in canonical form which is this orientation invariant position
1022         // in the hotseat
1023         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1024                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1025             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1026         } else {
1027             item.screenId = screenId;
1028         }
1029 
1030         final ContentValues values = new ContentValues();
1031         final ContentResolver cr = context.getContentResolver();
1032         item.onAddToDatabase(context, values);
1033 
1034         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1035         values.put(LauncherSettings.Favorites._ID, item.id);
1036         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1037 
1038         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1039         Runnable r = new Runnable() {
1040             public void run() {
1041                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1042                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1043 
1044                 // Lock on mBgLock *after* the db operation
1045                 synchronized (sBgLock) {
1046                     checkItemInfoLocked(item.id, item, stackTrace);
1047                     sBgItemsIdMap.put(item.id, item);
1048                     switch (item.itemType) {
1049                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1050                             sBgFolders.put(item.id, (FolderInfo) item);
1051                             // Fall through
1052                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1053                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1054                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1055                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1056                                 sBgWorkspaceItems.add(item);
1057                             } else {
1058                                 if (!sBgFolders.containsKey(item.container)) {
1059                                     // Adding an item to a folder that doesn&#x27;t exist.
1060                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1061                                             &quot; doesn&#x27;t exist&quot;;
1062                                     Log.e(TAG, msg);
1063                                 }
1064                             }
1065                             break;
1066                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1067                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1068                             break;
1069                     }
1070                 }
1071             }
1072         };
1073         runOnWorkerThread(r);
1074     }
1075 
1076     /**
1077      * Creates a new unique child id, for a given cell span across all layouts.
1078      */
1079     static int getCellLayoutChildId(
1080             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1081         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1082                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1083     }
1084 
1085     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1086             final String pn, final UserHandleCompat user) {
1087         ItemInfoFilter filter  = new ItemInfoFilter() {
1088             @Override
1089             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1090                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1091             }
1092         };
1093         return filterItemInfos(sBgItemsIdMap.values(), filter);
1094     }
1095 
1096     /**
1097      * Removes all the items from the database corresponding to the specified package.
1098      */
1099     static void deletePackageFromDatabase(Context context, final String pn,
1100             final UserHandleCompat user) {
1101         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1102     }
1103 
1104     /**
1105      * Removes the specified item from the database
1106      * @param context
1107      * @param item
1108      */
1109     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1110         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1111         items.add(item);
1112         deleteItemsFromDatabase(context, items);
1113     }
1114 
1115     /**
1116      * Removes the specified items from the database
1117      * @param context
1118      * @param item
1119      */
1120     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1121         final ContentResolver cr = context.getContentResolver();
1122 
1123         Runnable r = new Runnable() {
1124             public void run() {
1125                 for (ItemInfo item : items) {
1126                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1127                     cr.delete(uri, null, null);
1128 
1129                     // Lock on mBgLock *after* the db operation
1130                     synchronized (sBgLock) {
1131                         switch (item.itemType) {
1132                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1133                                 sBgFolders.remove(item.id);
1134                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1135                                     if (info.container == item.id) {
1136                                         // We are deleting a folder which still contains items that
1137                                         // think they are contained by that folder.
1138                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1139                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1140                                         Log.e(TAG, msg);
1141                                     }
1142                                 }
1143                                 sBgWorkspaceItems.remove(item);
1144                                 break;
1145                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1146                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1147                                 sBgWorkspaceItems.remove(item);
1148                                 break;
1149                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1150                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1151                                 break;
1152                         }
1153                         sBgItemsIdMap.remove(item.id);
1154                         sBgDbIconCache.remove(item);
1155                     }
1156                 }
1157             }
1158         };
1159         runOnWorkerThread(r);
1160     }
1161 
1162     /**
1163      * Update the order of the workspace screens in the database. The array list contains
1164      * a list of screen ids in the order that they should appear.
1165      */
1166     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1167         // Log to disk
1168         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1169         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1170 
1171         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1172         final ContentResolver cr = context.getContentResolver();
1173         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1174 
1175         // Remove any negative screen ids -- these aren&#x27;t persisted
1176         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1177         while (iter.hasNext()) {
1178             long id = iter.next();
1179             if (id &lt; 0) {
1180                 iter.remove();
1181             }
1182         }
1183 
1184         Runnable r = new Runnable() {
1185             @Override
1186             public void run() {
1187                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1188                 // Clear the table
1189                 ops.add(ContentProviderOperation.newDelete(uri).build());
1190                 int count = screensCopy.size();
1191                 for (int i = 0; i &lt; count; i++) {
1192                     ContentValues v = new ContentValues();
1193                     long screenId = screensCopy.get(i);
1194                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1195                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1196                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1197                 }
1198 
1199                 try {
1200                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1201                 } catch (Exception ex) {
1202                     throw new RuntimeException(ex);
1203                 }
1204 
1205                 synchronized (sBgLock) {
1206                     sBgWorkspaceScreens.clear();
1207                     sBgWorkspaceScreens.addAll(screensCopy);
1208                 }
1209             }
1210         };
1211         runOnWorkerThread(r);
1212     }
1213 
1214     /**
1215      * Remove the contents of the specified folder from the database
1216      */
1217     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1218         final ContentResolver cr = context.getContentResolver();
1219 
1220         Runnable r = new Runnable() {
1221             public void run() {
1222                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1223                 // Lock on mBgLock *after* the db operation
1224                 synchronized (sBgLock) {
1225                     sBgItemsIdMap.remove(info.id);
1226                     sBgFolders.remove(info.id);
1227                     sBgDbIconCache.remove(info);
1228                     sBgWorkspaceItems.remove(info);
1229                 }
1230 
1231                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1232                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1233                 // Lock on mBgLock *after* the db operation
1234                 synchronized (sBgLock) {
1235                     for (ItemInfo childInfo : info.contents) {
1236                         sBgItemsIdMap.remove(childInfo.id);
1237                         sBgDbIconCache.remove(childInfo);
1238                     }
1239                 }
1240             }
1241         };
1242         runOnWorkerThread(r);
1243     }
1244 
1245     /**
1246      * Set this as the current Launcher activity object for the loader.
1247      */
1248     public void initialize(Callbacks callbacks) {
1249         synchronized (mLock) {
1250             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1251         }
1252     }
1253 
1254     @Override
1255     public void onPackageChanged(String packageName, UserHandleCompat user) {
1256         int op = PackageUpdatedTask.OP_UPDATE;
1257         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1258                 user));
1259     }
1260 
1261     @Override
1262     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1263         int op = PackageUpdatedTask.OP_REMOVE;
1264         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1265                 user));
1266     }
1267 
1268     @Override
1269     public void onPackageAdded(String packageName, UserHandleCompat user) {
1270         int op = PackageUpdatedTask.OP_ADD;
1271         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1272                 user));
1273     }
1274 
1275     @Override
1276     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1277             boolean replacing) {
1278         if (!replacing) {
1279             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1280                     user));
1281             if (mAppsCanBeOnRemoveableStorage) {
1282                 // Only rebind if we support removable storage. It catches the
1283                 // case where
1284                 // apps on the external sd card need to be reloaded
1285                 startLoaderFromBackground();
1286             }
1287         } else {
1288             // If we are replacing then just update the packages in the list
1289             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1290                     packageNames, user));
1291         }
1292     }
1293 
1294     @Override
1295     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1296             boolean replacing) {
1297         if (!replacing) {
1298             enqueuePackageUpdated(new PackageUpdatedTask(
1299                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1300                     user));
1301         }
1302 
1303     }
1304 
1305     /**
1306      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1307      * ACTION_PACKAGE_CHANGED.
1308      */
1309     @Override
1310     public void onReceive(Context context, Intent intent) {
1311         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1312 
1313         final String action = intent.getAction();
1314         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1315             // If we have changed locale we need to clear out the labels in all apps/workspace.
1316             forceReload();
1317         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1318              // Check if configuration change was an mcc/mnc change which would affect app resources
1319              // and we would need to clear out the labels in all apps/workspace. Same handling as
1320              // above for ACTION_LOCALE_CHANGED
1321              Configuration currentConfig = context.getResources().getConfiguration();
1322              if (mPreviousConfigMcc != currentConfig.mcc) {
1323                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1324                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1325                    forceReload();
1326              }
1327              // Update previousConfig
1328              mPreviousConfigMcc = currentConfig.mcc;
1329         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1330                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1331             if (mCallbacks != null) {
1332                 Callbacks callbacks = mCallbacks.get();
1333                 if (callbacks != null) {
1334                     callbacks.bindSearchablesChanged();
1335                 }
1336             }
1337         }
1338     }
1339 
1340     void forceReload() {
1341         resetLoadedState(true, true);
1342 
1343         // Do this here because if the launcher activity is running it will be restarted.
1344         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1345         // to reload.
1346         startLoaderFromBackground();
1347     }
1348 
1349     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1350         synchronized (mLock) {
1351             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1352             // mWorkspaceLoaded to true later
1353             stopLoaderLocked();
1354             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1355             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1356         }
1357     }
1358 
1359     /**
1360      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1361      * configuration changes.  So whenever we trigger the loader from the background
1362      * tell the launcher that it needs to re-run the loader when it comes back instead
1363      * of doing it now.
1364      */
1365     public void startLoaderFromBackground() {
1366         boolean runLoader = false;
1367         if (mCallbacks != null) {
1368             Callbacks callbacks = mCallbacks.get();
1369             if (callbacks != null) {
1370                 // Only actually run the loader if they&#x27;re not paused.
1371                 if (!callbacks.setLoadOnResume()) {
1372                     runLoader = true;
1373                 }
1374             }
1375         }
1376         if (runLoader) {
1377             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1378         }
1379     }
1380 
1381     // If there is already a loader task running, tell it to stop.
1382     // returns true if isLaunching() was true on the old task
1383     private boolean stopLoaderLocked() {
1384         boolean isLaunching = false;
1385         LoaderTask oldTask = mLoaderTask;
1386         if (oldTask != null) {
1387             if (oldTask.isLaunching()) {
1388                 isLaunching = true;
1389             }
1390             oldTask.stopLocked();
1391         }
1392         return isLaunching;
1393     }
1394 
1395     public boolean isCurrentCallbacks(Callbacks callbacks) {
1396         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1397     }
1398 
1399     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1400         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1401     }
1402 
1403     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1404         synchronized (mLock) {
1405             if (DEBUG_LOADERS) {
1406                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1407             }
1408 
1409             // Clear any deferred bind-runnables from the synchronized load process
1410             // We must do this before any loading/binding is scheduled below.
1411             synchronized (mDeferredBindRunnables) {
1412                 mDeferredBindRunnables.clear();
1413             }
1414 
1415             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1416             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1417                 // If there is already one running, tell it to stop.
1418                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1419                 isLaunching = isLaunching || stopLoaderLocked();
1420                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1421                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1422                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1423                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1424                 } else {
1425                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1426                     sWorker.post(mLoaderTask);
1427                 }
1428             }
1429         }
1430     }
1431 
1432     void bindRemainingSynchronousPages() {
1433         // Post the remaining side pages to be loaded
1434         if (!mDeferredBindRunnables.isEmpty()) {
1435             Runnable[] deferredBindRunnables = null;
1436             synchronized (mDeferredBindRunnables) {
1437                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1438                         new Runnable[mDeferredBindRunnables.size()]);
1439                 mDeferredBindRunnables.clear();
1440             }
1441             for (final Runnable r : deferredBindRunnables) {
1442                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1443             }
1444         }
1445     }
1446 
1447     public void stopLoader() {
1448         synchronized (mLock) {
1449             if (mLoaderTask != null) {
1450                 mLoaderTask.stopLocked();
1451             }
1452         }
1453     }
1454 
1455     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1456     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1457         final ContentResolver contentResolver = context.getContentResolver();
1458         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1459         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1460         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1461 
1462         try {
1463             final int idIndex = sc.getColumnIndexOrThrow(
1464                     LauncherSettings.WorkspaceScreens._ID);
1465             final int rankIndex = sc.getColumnIndexOrThrow(
1466                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1467             while (sc.moveToNext()) {
1468                 try {
1469                     long screenId = sc.getLong(idIndex);
1470                     int rank = sc.getInt(rankIndex);
1471                     orderedScreens.put(rank, screenId);
1472                 } catch (Exception e) {
<abbr title="1473                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1473                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1474                 }
1475             }
1476         } finally {
1477             sc.close();
1478         }
1479 
1480         // Log to disk
1481         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1482         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1483         for (Integer i : orderedScreens.keySet()) {
1484             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1485         }
1486         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1487                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1488         return orderedScreens;
1489     }
1490 
1491     public boolean isAllAppsLoaded() {
1492         return mAllAppsLoaded;
1493     }
1494 
1495     boolean isLoadingWorkspace() {
1496         synchronized (mLock) {
1497             if (mLoaderTask != null) {
1498                 return mLoaderTask.isLoadingWorkspace();
1499             }
1500         }
1501         return false;
1502     }
1503 
1504     /**
1505      * Runnable for the thread that loads the contents of the launcher:
1506      *   - workspace icons
1507      *   - widgets
1508      *   - all apps icons
1509      */
1510     private class LoaderTask implements Runnable {
1511         private Context mContext;
1512         private boolean mIsLaunching;
1513         private boolean mIsLoadingAndBindingWorkspace;
1514         private boolean mStopped;
1515         private boolean mLoadAndBindStepFinished;
1516         private int mFlags;
1517 
1518         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1519 
1520         LoaderTask(Context context, boolean isLaunching, int flags) {
1521             mContext = context;
1522             mIsLaunching = isLaunching;
1523             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1524             mFlags = flags;
1525         }
1526 
1527         boolean isLaunching() {
1528             return mIsLaunching;
1529         }
1530 
1531         boolean isLoadingWorkspace() {
1532             return mIsLoadingAndBindingWorkspace;
1533         }
1534 
1535         /** Returns whether this is an upgrade path */
1536         private boolean loadAndBindWorkspace() {
1537             mIsLoadingAndBindingWorkspace = true;
1538 
1539             // Load the workspace
1540             if (DEBUG_LOADERS) {
1541                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1542             }
1543 
1544             boolean isUpgradePath = false;
1545             if (!mWorkspaceLoaded) {
1546                 isUpgradePath = loadWorkspace();
1547                 synchronized (LoaderTask.this) {
1548                     if (mStopped) {
1549                         return isUpgradePath;
1550                     }
1551                     mWorkspaceLoaded = true;
1552                 }
1553             }
1554 
1555             // Bind the workspace
1556             bindWorkspace(-1, isUpgradePath);
1557             return isUpgradePath;
1558         }
1559 
1560         private void waitForIdle() {
1561             // Wait until the either we&#x27;re stopped or the other threads are done.
1562             // This way we don&#x27;t start loading all apps until the workspace has settled
1563             // down.
1564             synchronized (LoaderTask.this) {
1565                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1566 
1567                 mHandler.postIdle(new Runnable() {
1568                         public void run() {
1569                             synchronized (LoaderTask.this) {
1570                                 mLoadAndBindStepFinished = true;
1571                                 if (DEBUG_LOADERS) {
1572                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1573                                 }
1574                                 LoaderTask.this.notify();
1575                             }
1576                         }
1577                     });
1578 
1579                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1580                     try {
1581                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1582                         // wait no longer than 1sec at a time
1583                         this.wait(1000);
1584                     } catch (InterruptedException ex) {
1585                         // Ignore
1586                     }
1587                 }
1588                 if (DEBUG_LOADERS) {
1589                     Log.d(TAG, &quot;waited &quot;
1590                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1591                             + &quot;ms for previous step to finish binding&quot;);
1592                 }
1593             }
1594         }
1595 
1596         void runBindSynchronousPage(int synchronousBindPage) {
1597             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1598                 // Ensure that we have a valid page index to load synchronously
1599                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1600                         &quot;valid page index&quot;);
1601             }
1602             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1603                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1604                 // loaded already (we should load everything asynchronously in that case)
1605                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1606             }
1607             synchronized (mLock) {
1608                 if (mIsLoaderTaskRunning) {
1609                     // Ensure that we are never running the background loading at this point since
1610                     // we also touch the background collections
1611                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1612                 }
1613             }
1614 
1615             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1616             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1617             //      this call is synchronous, we can get away with not locking).
1618 
1619             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1620             // operations from the previous activity.  We need to ensure that all queued operations
1621             // are executed before any synchronous binding work is done.
1622             mHandler.flush();
1623 
1624             // Divide the set of loaded items into those that we are binding synchronously, and
1625             // everything else that is to be bound normally (asynchronously).
1626             bindWorkspace(synchronousBindPage, false);
1627             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1628             //      arise from that.
1629             onlyBindAllApps();
1630         }
1631 
1632         public void run() {
1633             boolean isUpgrade = false;
1634 
1635             synchronized (mLock) {
1636                 mIsLoaderTaskRunning = true;
1637             }
1638             // Optimize for end-user experience: if the Launcher is up and // running with the
1639             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1640             // workspace first (default).
1641             keep_running: {
1642                 // Elevate priority when Home launches for the first time to avoid
1643                 // starving at boot time. Staring at a blank home is not cool.
1644                 synchronized (mLock) {
1645                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1646                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1647                     android.os.Process.setThreadPriority(mIsLaunching
1648                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1649                 }
1650                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1651                 isUpgrade = loadAndBindWorkspace();
1652 
1653                 if (mStopped) {
1654                     break keep_running;
1655                 }
1656 
1657                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1658                 // settled down.
1659                 synchronized (mLock) {
1660                     if (mIsLaunching) {
1661                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1662                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1663                     }
1664                 }
1665                 waitForIdle();
1666 
1667                 // second step
1668                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1669                 loadAndBindAllApps();
1670 
1671                 // Restore the default thread priority after we are done loading items
1672                 synchronized (mLock) {
1673                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1674                 }
1675             }
1676 
1677             // Update the saved icons if necessary
1678             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1679             synchronized (sBgLock) {
1680                 for (Object key : sBgDbIconCache.keySet()) {
1681                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1682                 }
1683                 sBgDbIconCache.clear();
1684             }
1685 
1686             if (LauncherAppState.isDisableAllApps()) {
1687                 // Ensure that all the applications that are in the system are
1688                 // represented on the home screen.
1689                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1690                     verifyApplications();
1691                 }
1692             }
1693 
1694             // Clear out this reference, otherwise we end up holding it until all of the
1695             // callback runnables are done.
1696             mContext = null;
1697 
1698             synchronized (mLock) {
1699                 // If we are still the last one to be scheduled, remove ourselves.
1700                 if (mLoaderTask == this) {
1701                     mLoaderTask = null;
1702                 }
1703                 mIsLoaderTaskRunning = false;
1704             }
1705         }
1706 
1707         public void stopLocked() {
1708             synchronized (LoaderTask.this) {
1709                 mStopped = true;
1710                 this.notify();
1711             }
1712         }
1713 
1714         /**
1715          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1716          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1717          * object that was around when the deferred message was scheduled, and if there&#x27;s
1718          * a new Callbacks object around then also return null.  This will save us from
1719          * calling onto it with data that will be ignored.
1720          */
1721         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1722             synchronized (mLock) {
1723                 if (mStopped) {
1724                     return null;
1725                 }
1726 
1727                 if (mCallbacks == null) {
1728                     return null;
1729                 }
1730 
1731                 final Callbacks callbacks = mCallbacks.get();
1732                 if (callbacks != oldCallbacks) {
1733                     return null;
1734                 }
1735                 if (callbacks == null) {
1736                     Log.w(TAG, &quot;no mCallbacks&quot;);
1737                     return null;
1738                 }
1739 
1740                 return callbacks;
1741             }
1742         }
1743 
1744         private void verifyApplications() {
1745             final Context context = mApp.getContext();
1746 
1747             // Cross reference all the applications in our apps list with items in the workspace
1748             ArrayList&lt;ItemInfo&gt; tmpInfos;
1749             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1750             synchronized (sBgLock) {
1751                 for (AppInfo app : mBgAllAppsList.data) {
1752                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1753                     if (tmpInfos.isEmpty()) {
1754                         // We are missing an application icon, so add this to the workspace
1755                         added.add(app);
1756                         // This is a rare event, so lets log it
1757                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1758                     }
1759                 }
1760             }
1761             if (!added.isEmpty()) {
1762                 addAndBindAddedWorkspaceApps(context, added);
1763             }
1764         }
1765 
1766         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1767         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1768                                            AtomicBoolean deleteOnInvalidPlacement) {
1769             LauncherAppState app = LauncherAppState.getInstance();
1770             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1771             final int countX = (int) grid.numColumns;
1772             final int countY = (int) grid.numRows;
1773 
1774             long containerIndex = item.screenId;
1775             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1776                 // Return early if we detect that an item is under the hotseat button
1777                 if (mCallbacks == null ||
1778                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1779                     deleteOnInvalidPlacement.set(true);
1780                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1781                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1782                             + item.cellY + &quot;) occupied by all apps&quot;);
1783                     return false;
1784                 }
1785 
1786                 final ItemInfo[][] hotseatItems =
1787                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1788 
1789                 if (item.screenId &gt;= grid.numHotseatIcons) {
1790                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1791                             + &quot; into hotseat position &quot; + item.screenId
1792                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1793                             + &quot;)&quot;);
1794                     return false;
1795                 }
1796 
1797                 if (hotseatItems != null) {
1798                     if (hotseatItems[(int) item.screenId][0] != null) {
1799                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1800                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1801                                 + item.cellY + &quot;) occupied by &quot;
1802                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1803                                 [(int) item.screenId][0]);
1804                             return false;
1805                     } else {
1806                         hotseatItems[(int) item.screenId][0] = item;
1807                         return true;
1808                     }
1809                 } else {
1810                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1811                     items[(int) item.screenId][0] = item;
1812                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1813                     return true;
1814                 }
1815             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1816                 // Skip further checking if it is not the hotseat or workspace container
1817                 return true;
1818             }
1819 
1820             if (!occupied.containsKey(item.screenId)) {
1821                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1822                 occupied.put(item.screenId, items);
1823             }
1824 
1825             final ItemInfo[][] screens = occupied.get(item.screenId);
1826             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1827                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1828                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1829                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1830                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1831                         + item.cellX + &quot;,&quot; + item.cellY
1832                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1833                 return false;
1834             }
1835 
1836             // Check if any workspace icons overlap with each other
1837             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1838                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1839                     if (screens[x][y] != null) {
1840                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1841                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1842                             + x + &quot;,&quot; + y
1843                             + &quot;) occupied by &quot;
1844                             + screens[x][y]);
1845                         return false;
1846                     }
1847                 }
1848             }
1849             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1850                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1851                     screens[x][y] = item;
1852                 }
1853             }
1854 
1855             return true;
1856         }
1857 
1858         /** Clears all the sBg data structures */
1859         private void clearSBgDataStructures() {
1860             synchronized (sBgLock) {
1861                 sBgWorkspaceItems.clear();
1862                 sBgAppWidgets.clear();
1863                 sBgFolders.clear();
1864                 sBgItemsIdMap.clear();
1865                 sBgDbIconCache.clear();
1866                 sBgWorkspaceScreens.clear();
1867             }
1868         }
1869 
1870         /** Returns whether this is an upgrade path */
1871         private boolean loadWorkspace() {
1872             // Log to disk
1873             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1874 
1875             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1876 
1877             final Context context = mContext;
1878             final ContentResolver contentResolver = context.getContentResolver();
1879             final PackageManager manager = context.getPackageManager();
1880             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1881             final boolean isSafeMode = manager.isSafeMode();
1882             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1883             final boolean isSdCardReady = context.registerReceiver(null,
1884                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1885 
1886             LauncherAppState app = LauncherAppState.getInstance();
1887             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1888             int countX = (int) grid.numColumns;
1889             int countY = (int) grid.numRows;
1890 
1891             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1892                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1893                 LauncherAppState.getLauncherProvider().deleteDatabase();
1894             }
1895 
1896             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1897                 // append the user&#x27;s Launcher2 shortcuts
1898                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1899                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1900             } else {
1901                 // Make sure the default workspace is loaded
1902                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1903                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1904             }
1905 
1906             // This code path is for our old migration code and should no longer be exercised
1907             boolean loadedOldDb = false;
1908 
1909             // Log to disk
1910             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1911 
1912             synchronized (sBgLock) {
1913                 clearSBgDataStructures();
1914                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1915                         .getInstance(mContext).updateAndGetActiveSessionCache();
1916 
1917                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1918                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1919                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1920                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1921                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1922 
1923                 // +1 for the hotseat (it can be larger than the workspace)
1924                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1925                 // before any earlier duplicates)
1926                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1927 
1928                 try {
1929                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1930                     final int intentIndex = c.getColumnIndexOrThrow
1931                             (LauncherSettings.Favorites.INTENT);
1932                     final int titleIndex = c.getColumnIndexOrThrow
1933                             (LauncherSettings.Favorites.TITLE);
1934                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1935                             LauncherSettings.Favorites.ICON_TYPE);
1936                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1937                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1938                             LauncherSettings.Favorites.ICON_PACKAGE);
1939                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1940                             LauncherSettings.Favorites.ICON_RESOURCE);
1941                     final int containerIndex = c.getColumnIndexOrThrow(
1942                             LauncherSettings.Favorites.CONTAINER);
1943                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1944                             LauncherSettings.Favorites.ITEM_TYPE);
1945                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1946                             LauncherSettings.Favorites.APPWIDGET_ID);
1947                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1948                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1949                     final int screenIndex = c.getColumnIndexOrThrow(
1950                             LauncherSettings.Favorites.SCREEN);
1951                     final int cellXIndex = c.getColumnIndexOrThrow
1952                             (LauncherSettings.Favorites.CELLX);
1953                     final int cellYIndex = c.getColumnIndexOrThrow
1954                             (LauncherSettings.Favorites.CELLY);
1955                     final int spanXIndex = c.getColumnIndexOrThrow
1956                             (LauncherSettings.Favorites.SPANX);
1957                     final int spanYIndex = c.getColumnIndexOrThrow(
1958                             LauncherSettings.Favorites.SPANY);
1959                     final int restoredIndex = c.getColumnIndexOrThrow(
1960                             LauncherSettings.Favorites.RESTORED);
1961                     final int profileIdIndex = c.getColumnIndexOrThrow(
1962                             LauncherSettings.Favorites.PROFILE_ID);
1963                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1964                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1965                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1966 
1967                     ShortcutInfo info;
1968                     String intentDescription;
1969                     LauncherAppWidgetInfo appWidgetInfo;
1970                     int container;
1971                     long id;
1972                     Intent intent;
1973                     UserHandleCompat user;
1974 
1975                     while (!mStopped &amp;&amp; c.moveToNext()) {
1976                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1977                         try {
1978                             int itemType = c.getInt(itemTypeIndex);
1979                             boolean restored = 0 != c.getInt(restoredIndex);
1980                             boolean allowMissingTarget = false;
1981 
1982                             switch (itemType) {
1983                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1984                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1985                                 id = c.getLong(idIndex);
1986                                 intentDescription = c.getString(intentIndex);
1987                                 long serialNumber = c.getInt(profileIdIndex);
1988                                 user = mUserManager.getUserForSerialNumber(serialNumber);
1989                                 int promiseType = c.getInt(restoredIndex);
1990                                 int disabledState = 0;
1991                                 if (user == null) {
1992                                     // User has been deleted remove the item.
1993                                     itemsToRemove.add(id);
1994                                     continue;
1995                                 }
1996                                 try {
1997                                     intent = Intent.parseUri(intentDescription, 0);
1998                                     ComponentName cn = intent.getComponent();
1999                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
2000                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
2001                                                 cn.getPackageName(), user);
2002                                         boolean validComponent = validPkg &amp;&amp;
2003                                                 launcherApps.isActivityEnabledForProfile(cn, user);
2004 
2005                                         if (validComponent) {
2006                                             if (restored) {
2007                                                 // no special handling necessary for this item
2008                                                 restoredRows.add(id);
2009                                                 restored = false;
2010                                             }
2011                                         } else if (validPkg) {
2012                                             intent = null;
2013                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2014                                                 // We allow auto install apps to have their intent
2015                                                 // updated after an install.
2016                                                 intent = manager.getLaunchIntentForPackage(
2017                                                         cn.getPackageName());
2018                                                 if (intent != null) {
2019                                                     ContentValues values = new ContentValues();
2020                                                     values.put(LauncherSettings.Favorites.INTENT,
2021                                                             intent.toUri(0));
2022                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2023                                                     String[] args = {Long.toString(id)};
<abbr title="2024                                                     contentResolver.update(contentUri, values, where, args);">2024                                                     contentResolver.update(contentUri, values, where, argðŸ”µ</abbr>
2025                                                 }
2026                                             }
2027 
2028                                             if (intent == null) {
2029                                                 // The app is installed but the component is no
2030                                                 // longer available.
2031                                                 Launcher.addDumpLog(TAG,
2032                                                         &quot;Invalid component removed: &quot; + cn, true);
2033                                                 itemsToRemove.add(id);
2034                                                 continue;
2035                                             } else {
2036                                                 // no special handling necessary for this item
2037                                                 restoredRows.add(id);
2038                                                 restored = false;
2039                                             }
2040                                         } else if (restored) {
2041                                             // Package is not yet available but might be
2042                                             // installed later.
2043                                             Launcher.addDumpLog(TAG,
2044                                                     &quot;package not yet restored: &quot; + cn, true);
2045 
2046                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2047                                                 // Restore has started once.
2048                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2049                                                 // App restore has started. Update the flag
2050                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2051                                                 ContentValues values = new ContentValues();
2052                                                 values.put(LauncherSettings.Favorites.RESTORED,
2053                                                         promiseType);
2054                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2055                                                 String[] args = {Long.toString(id)};
2056                                                 contentResolver.update(contentUri, values, where, args);
2057 
2058                                             } else if (REMOVE_UNRESTORED_ICONS) {
2059                                                 Launcher.addDumpLog(TAG,
2060                                                         &quot;Unrestored package removed: &quot; + cn, true);
2061                                                 itemsToRemove.add(id);
2062                                                 continue;
2063                                             }
2064                                         } else if (launcherApps.isAppEnabled(
2065                                                 manager, cn.getPackageName(),
2066                                                 PackageManager.GET_UNINSTALLED_PACKAGES)) {
2067                                             // Package is present but not available.
2068                                             allowMissingTarget = true;
2069                                             disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2070                                         } else if (!isSdCardReady) {
2071                                             // SdCard is not ready yet. Package might get available,
2072                                             // once it is ready.
2073                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2074                                                     + &quot; (check again later)&quot;, true);
2075                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2076                                             if (pkgs == null) {
2077                                                 pkgs = new HashSet&lt;String&gt;();
2078                                                 sPendingPackages.put(user, pkgs);
2079                                             }
2080                                             pkgs.add(cn.getPackageName());
2081                                             allowMissingTarget = true;
2082                                             // Add the icon on the workspace anyway.
2083 
2084                                         } else {
2085                                             // Do not wait for external media load anymore.
2086                                             // Log the invalid package, and remove it
2087                                             Launcher.addDumpLog(TAG,
2088                                                     &quot;Invalid package removed: &quot; + cn, true);
2089                                             itemsToRemove.add(id);
2090                                             continue;
2091                                         }
2092                                     } else if (cn == null) {
2093                                         // For shortcuts with no component, keep them as they are
2094                                         restoredRows.add(id);
2095                                         restored = false;
2096                                     }
2097                                 } catch (URISyntaxException e) {
2098                                     Launcher.addDumpLog(TAG,
2099                                             &quot;Invalid uri: &quot; + intentDescription, true);
2100                                     continue;
2101                                 }
2102 
2103                                 if (restored) {
2104                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2105                                         Launcher.addDumpLog(TAG,
2106                                                 &quot;constructing info for partially restored package&quot;,
2107                                                 true);
2108                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2109                                         intent = getRestoredItemIntent(c, context, intent);
2110                                     } else {
2111                                         // Don&#x27;t restore items for other profiles.
2112                                         itemsToRemove.add(id);
2113                                         continue;
2114                                     }
2115                                 } else if (itemType ==
2116                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2117                                     info = getShortcutInfo(manager, intent, user, context, c,
2118                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2119                                 } else {
2120                                     info = getShortcutInfo(c, context, iconTypeIndex,
2121                                             iconPackageIndex, iconResourceIndex, iconIndex,
2122                                             titleIndex);
2123 
2124                                     // App shortcuts that used to be automatically added to Launcher
2125                                     // didn&#x27;t always have the correct intent flags set, so do that
2126                                     // here
2127                                     if (intent.getAction() != null &amp;&amp;
2128                                         intent.getCategories() != null &amp;&amp;
2129                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2130                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2131                                         intent.addFlags(
2132                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2133                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2134                                     }
2135                                 }
2136 
2137                                 if (info != null) {
2138                                     info.id = id;
2139                                     info.intent = intent;
2140                                     container = c.getInt(containerIndex);
2141                                     info.container = container;
2142                                     info.screenId = c.getInt(screenIndex);
2143                                     info.cellX = c.getInt(cellXIndex);
2144                                     info.cellY = c.getInt(cellYIndex);
2145                                     info.spanX = 1;
2146                                     info.spanY = 1;
2147                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2148                                     info.isDisabled = disabledState;
2149                                     if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2150                                         info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2151                                     }
2152 
2153                                     // check &amp; update map of what&#x27;s occupied
2154                                     deleteOnInvalidPlacement.set(false);
2155                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2156                                         if (deleteOnInvalidPlacement.get()) {
2157                                             itemsToRemove.add(id);
2158                                         }
2159                                         break;
2160                                     }
2161 
2162                                     switch (container) {
2163                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2164                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2165                                         sBgWorkspaceItems.add(info);
2166                                         break;
2167                                     default:
2168                                         // Item is in a user folder
2169                                         FolderInfo folderInfo =
2170                                                 findOrMakeFolder(sBgFolders, container);
2171                                         folderInfo.add(info);
2172                                         break;
2173                                     }
2174                                     sBgItemsIdMap.put(info.id, info);
2175 
2176                                     // now that we&#x27;ve loaded everthing re-save it with the
2177                                     // icon in case it disappears somehow.
2178                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2179                                 } else {
2180                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2181                                 }
2182                                 break;
2183 
2184                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2185                                 id = c.getLong(idIndex);
2186                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2187 
2188                                 folderInfo.title = c.getString(titleIndex);
2189                                 folderInfo.id = id;
2190                                 container = c.getInt(containerIndex);
2191                                 folderInfo.container = container;
2192                                 folderInfo.screenId = c.getInt(screenIndex);
2193                                 folderInfo.cellX = c.getInt(cellXIndex);
2194                                 folderInfo.cellY = c.getInt(cellYIndex);
2195                                 folderInfo.spanX = 1;
2196                                 folderInfo.spanY = 1;
2197 
2198                                 // check &amp; update map of what&#x27;s occupied
2199                                 deleteOnInvalidPlacement.set(false);
2200                                 if (!checkItemPlacement(occupied, folderInfo,
2201                                         deleteOnInvalidPlacement)) {
2202                                     if (deleteOnInvalidPlacement.get()) {
2203                                         itemsToRemove.add(id);
2204                                     }
2205                                     break;
2206                                 }
2207 
2208                                 switch (container) {
2209                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2210                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2211                                         sBgWorkspaceItems.add(folderInfo);
2212                                         break;
2213                                 }
2214 
2215                                 if (restored) {
2216                                     // no special handling required for restored folders
2217                                     restoredRows.add(id);
2218                                 }
2219 
2220                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2221                                 sBgFolders.put(folderInfo.id, folderInfo);
2222                                 break;
2223 
2224                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2225                                 // Read all Launcher-specific widget details
2226                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2227                                 String savedProvider = c.getString(appWidgetProviderIndex);
2228                                 id = c.getLong(idIndex);
2229                                 final ComponentName component =
2230                                         ComponentName.unflattenFromString(savedProvider);
2231 
2232                                 final int restoreStatus = c.getInt(restoredIndex);
2233                                 final boolean isIdValid = (restoreStatus &amp;
2234                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2235 
2236                                 final boolean wasProviderReady = (restoreStatus &amp;
2237                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2238 
2239                                 final AppWidgetProviderInfo provider = isIdValid
2240                                         ? widgets.getAppWidgetInfo(appWidgetId)
2241                                         : findAppWidgetProviderInfoWithComponent(context, component);
2242 
2243                                 final boolean isProviderReady = isValidProvider(provider);
2244                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2245                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2246                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2247                                     Log.e(TAG, log);
2248                                     Launcher.addDumpLog(TAG, log, false);
2249                                     itemsToRemove.add(id);
2250                                 } else {
2251                                     if (isProviderReady) {
2252                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2253                                                 provider.provider);
2254                                         int[] minSpan =
2255                                                 Launcher.getMinSpanForWidget(context, provider);
2256                                         appWidgetInfo.minSpanX = minSpan[0];
2257                                         appWidgetInfo.minSpanY = minSpan[1];
2258 
2259                                         int status = restoreStatus;
2260                                         if (!wasProviderReady) {
2261                                             // If provider was not previously ready, update the
2262                                             // status and UI flag.
2263 
<abbr title="2264                                             // Id would be valid only if the widget restore broadcast was received.">2264                                             // Id would be valid only if the widget restore broadcast wasðŸ”µ</abbr>
2265                                             if (isIdValid) {
2266                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2267                                             } else {
2268                                                 status &amp;= ~LauncherAppWidgetInfo
2269                                                         .FLAG_PROVIDER_NOT_READY;
2270                                             }
2271                                         }
2272                                         appWidgetInfo.restoreStatus = status;
2273                                     } else {
2274                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2275                                                 + &quot; appWidgetId=&quot; + appWidgetId
2276                                                 + &quot; status =&quot; + restoreStatus);
2277                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2278                                                 component);
2279                                         appWidgetInfo.restoreStatus = restoreStatus;
2280 
<abbr title="2281                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2281                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) ðŸ”µ</abbr>
2282                                             // Restore has started once.
2283                                         } else if (installingPkgs.contains(component.getPackageName())) {
2284                                             // App restore has started. Update the flag
2285                                             appWidgetInfo.restoreStatus |=
2286                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2287                                         } else if (REMOVE_UNRESTORED_ICONS) {
2288                                             Launcher.addDumpLog(TAG,
2289                                                     &quot;Unrestored widget removed: &quot; + component, true);
2290                                             itemsToRemove.add(id);
2291                                             continue;
2292                                         }
2293                                     }
2294 
2295                                     appWidgetInfo.id = id;
2296                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2297                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2298                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2299                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2300                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2301 
2302                                     container = c.getInt(containerIndex);
2303                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2304                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2305                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2306                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2307                                         continue;
2308                                     }
2309 
2310                                     appWidgetInfo.container = c.getInt(containerIndex);
2311                                     // check &amp; update map of what&#x27;s occupied
2312                                     deleteOnInvalidPlacement.set(false);
2313                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2314                                             deleteOnInvalidPlacement)) {
2315                                         if (deleteOnInvalidPlacement.get()) {
2316                                             itemsToRemove.add(id);
2317                                         }
2318                                         break;
2319                                     }
2320 
2321                                     String providerName = appWidgetInfo.providerName.flattenToString();
2322                                     if (!providerName.equals(savedProvider) ||
2323                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2324                                         ContentValues values = new ContentValues();
2325                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2326                                                 providerName);
2327                                         values.put(LauncherSettings.Favorites.RESTORED,
2328                                                 appWidgetInfo.restoreStatus);
2329                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2330                                         String[] args = {Long.toString(id)};
2331                                         contentResolver.update(contentUri, values, where, args);
2332                                     }
2333                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2334                                     sBgAppWidgets.add(appWidgetInfo);
2335                                 }
2336                                 break;
2337                             }
2338                         } catch (Exception e) {
2339                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2340                         }
2341                     }
2342                 } finally {
2343                     if (c != null) {
2344                         c.close();
2345                     }
2346                 }
2347 
2348                 // Break early if we&#x27;ve stopped loading
2349                 if (mStopped) {
2350                     clearSBgDataStructures();
2351                     return false;
2352                 }
2353 
2354                 if (itemsToRemove.size() &gt; 0) {
2355                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2356                             contentUri);
2357                     // Remove dead items
2358                     for (long id : itemsToRemove) {
2359                         if (DEBUG_LOADERS) {
2360                             Log.d(TAG, &quot;Removed id = &quot; + id);
2361                         }
2362                         // Don&#x27;t notify content observers
2363                         try {
2364                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2365                                     null, null);
2366                         } catch (RemoteException e) {
2367                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2368                         }
2369                     }
2370                 }
2371 
2372                 if (restoredRows.size() &gt; 0) {
2373                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2374                             contentUri);
2375                     // Update restored items that no longer require special handling
2376                     try {
2377                         StringBuilder selectionBuilder = new StringBuilder();
2378                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2379                         selectionBuilder.append(&quot; IN (&quot;);
2380                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2381                         selectionBuilder.append(&quot;)&quot;);
2382                         ContentValues values = new ContentValues();
2383                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2384                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2385                                 values, selectionBuilder.toString(), null);
2386                     } catch (RemoteException e) {
2387                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2388                     }
2389                 }
2390 
2391                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2392                     context.registerReceiver(new AppsAvailabilityCheck(),
2393                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2394                             null, sWorker);
2395                 }
2396 
2397                 if (loadedOldDb) {
2398                     long maxScreenId = 0;
2399                     // If we&#x27;re importing we use the old screen order.
2400                     for (ItemInfo item: sBgItemsIdMap.values()) {
2401                         long screenId = item.screenId;
2402                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2403                                 !sBgWorkspaceScreens.contains(screenId)) {
2404                             sBgWorkspaceScreens.add(screenId);
2405                             if (screenId &gt; maxScreenId) {
2406                                 maxScreenId = screenId;
2407                             }
2408                         }
2409                     }
2410                     Collections.sort(sBgWorkspaceScreens);
2411                     // Log to disk
2412                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2413                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2414                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2415 
2416                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2417                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2418 
2419                     // Update the max item id after we load an old db
2420                     long maxItemId = 0;
2421                     // If we&#x27;re importing we use the old screen order.
2422                     for (ItemInfo item: sBgItemsIdMap.values()) {
2423                         maxItemId = Math.max(maxItemId, item.id);
2424                     }
2425                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2426                 } else {
2427                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2428                     for (Integer i : orderedScreens.keySet()) {
2429                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2430                     }
2431                     // Log to disk
2432                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2433                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2434 
2435                     // Remove any empty screens
2436                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2437                     for (ItemInfo item: sBgItemsIdMap.values()) {
2438                         long screenId = item.screenId;
2439                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2440                                 unusedScreens.contains(screenId)) {
2441                             unusedScreens.remove(screenId);
2442                         }
2443                     }
2444 
2445                     // If there are any empty screens remove them, and update.
2446                     if (unusedScreens.size() != 0) {
2447                         // Log to disk
2448                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2449                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2450 
2451                         sBgWorkspaceScreens.removeAll(unusedScreens);
2452                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2453                     }
2454                 }
2455 
2456                 if (DEBUG_LOADERS) {
2457                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2458                     Log.d(TAG, &quot;workspace layout: &quot;);
2459                     int nScreens = occupied.size();
2460                     for (int y = 0; y &lt; countY; y++) {
2461                         String line = &quot;&quot;;
2462 
2463                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2464                         while (iter.hasNext()) {
2465                             long screenId = iter.next();
2466                             if (screenId &gt; 0) {
2467                                 line += &quot; | &quot;;
2468                             }
2469                             for (int x = 0; x &lt; countX; x++) {
2470                                 ItemInfo[][] screen = occupied.get(screenId);
2471                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2472                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2473                                 } else {
2474                                     line += &quot;!&quot;;
2475                                 }
2476                             }
2477                         }
2478                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2479                     }
2480                 }
2481             }
2482             return loadedOldDb;
2483         }
2484 
2485         /** Filters the set of items who are directly or indirectly (via another container) on the
2486          * specified screen. */
2487         private void filterCurrentWorkspaceItems(long currentScreenId,
2488                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2489                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2490                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2491             // Purge any null ItemInfos
2492             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2493             while (iter.hasNext()) {
2494                 ItemInfo i = iter.next();
2495                 if (i == null) {
2496                     iter.remove();
2497                 }
2498             }
2499 
2500             // Order the set of items by their containers first, this allows use to walk through the
2501             // list sequentially, build up a list of containers that are in the specified screen,
2502             // as well as all items in those containers.
2503             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2504             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2505                 @Override
2506                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2507                     return (int) (lhs.container - rhs.container);
2508                 }
2509             });
2510             for (ItemInfo info : allWorkspaceItems) {
2511                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2512                     if (info.screenId == currentScreenId) {
2513                         currentScreenItems.add(info);
2514                         itemsOnScreen.add(info.id);
2515                     } else {
2516                         otherScreenItems.add(info);
2517                     }
2518                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2519                     currentScreenItems.add(info);
2520                     itemsOnScreen.add(info.id);
2521                 } else {
2522                     if (itemsOnScreen.contains(info.container)) {
2523                         currentScreenItems.add(info);
2524                         itemsOnScreen.add(info.id);
2525                     } else {
2526                         otherScreenItems.add(info);
2527                     }
2528                 }
2529             }
2530         }
2531 
2532         /** Filters the set of widgets which are on the specified screen. */
2533         private void filterCurrentAppWidgets(long currentScreenId,
2534                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2535                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2536                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2537 
2538             for (LauncherAppWidgetInfo widget : appWidgets) {
2539                 if (widget == null) continue;
2540                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2541                         widget.screenId == currentScreenId) {
2542                     currentScreenWidgets.add(widget);
2543                 } else {
2544                     otherScreenWidgets.add(widget);
2545                 }
2546             }
2547         }
2548 
2549         /** Filters the set of folders which are on the specified screen. */
2550         private void filterCurrentFolders(long currentScreenId,
2551                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2552                 HashMap&lt;Long, FolderInfo&gt; folders,
2553                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2554                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2555 
2556             for (long id : folders.keySet()) {
2557                 ItemInfo info = itemsIdMap.get(id);
2558                 FolderInfo folder = folders.get(id);
2559                 if (info == null || folder == null) continue;
2560                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2561                         info.screenId == currentScreenId) {
2562                     currentScreenFolders.put(id, folder);
2563                 } else {
2564                     otherScreenFolders.put(id, folder);
2565                 }
2566             }
2567         }
2568 
2569         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2570          * right) */
2571         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2572             final LauncherAppState app = LauncherAppState.getInstance();
2573             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2574             // XXX: review this
2575             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2576                 @Override
2577                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2578                     int cellCountX = (int) grid.numColumns;
2579                     int cellCountY = (int) grid.numRows;
2580                     int screenOffset = cellCountX * cellCountY;
2581                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2582                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2583                             lhs.cellY * cellCountX + lhs.cellX);
2584                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2585                             rhs.cellY * cellCountX + rhs.cellX);
2586                     return (int) (lr - rr);
2587                 }
2588             });
2589         }
2590 
2591         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2592                 final ArrayList&lt;Long&gt; orderedScreens) {
2593             final Runnable r = new Runnable() {
2594                 @Override
2595                 public void run() {
2596                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2597                     if (callbacks != null) {
2598                         callbacks.bindScreens(orderedScreens);
2599                     }
2600                 }
2601             };
2602             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2603         }
2604 
2605         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2606                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2607                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2608                 final HashMap&lt;Long, FolderInfo&gt; folders,
2609                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2610 
2611             final boolean postOnMainThread = (deferredBindRunnables != null);
2612 
2613             // Bind the workspace items
2614             int N = workspaceItems.size();
2615             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2616                 final int start = i;
2617                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2618                 final Runnable r = new Runnable() {
2619                     @Override
2620                     public void run() {
2621                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2622                         if (callbacks != null) {
2623                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2624                                     false);
2625                         }
2626                     }
2627                 };
2628                 if (postOnMainThread) {
2629                     synchronized (deferredBindRunnables) {
2630                         deferredBindRunnables.add(r);
2631                     }
2632                 } else {
2633                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2634                 }
2635             }
2636 
2637             // Bind the folders
2638             if (!folders.isEmpty()) {
2639                 final Runnable r = new Runnable() {
2640                     public void run() {
2641                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2642                         if (callbacks != null) {
2643                             callbacks.bindFolders(folders);
2644                         }
2645                     }
2646                 };
2647                 if (postOnMainThread) {
2648                     synchronized (deferredBindRunnables) {
2649                         deferredBindRunnables.add(r);
2650                     }
2651                 } else {
2652                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2653                 }
2654             }
2655 
2656             // Bind the widgets, one at a time
2657             N = appWidgets.size();
2658             for (int i = 0; i &lt; N; i++) {
2659                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2660                 final Runnable r = new Runnable() {
2661                     public void run() {
2662                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2663                         if (callbacks != null) {
2664                             callbacks.bindAppWidget(widget);
2665                         }
2666                     }
2667                 };
2668                 if (postOnMainThread) {
2669                     deferredBindRunnables.add(r);
2670                 } else {
2671                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2672                 }
2673             }
2674         }
2675 
2676         /**
2677          * Binds all loaded data to actual views on the main thread.
2678          */
2679         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2680             final long t = SystemClock.uptimeMillis();
2681             Runnable r;
2682 
2683             // Don&#x27;t use these two variables in any of the callback runnables.
2684             // Otherwise we hold a reference to them.
2685             final Callbacks oldCallbacks = mCallbacks.get();
2686             if (oldCallbacks == null) {
2687                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2688                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2689                 return;
2690             }
2691 
2692             // Save a copy of all the bg-thread collections
2693             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2694             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2695                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2696             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2697             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2698             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2699             synchronized (sBgLock) {
2700                 workspaceItems.addAll(sBgWorkspaceItems);
2701                 appWidgets.addAll(sBgAppWidgets);
2702                 folders.putAll(sBgFolders);
2703                 itemsIdMap.putAll(sBgItemsIdMap);
2704                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2705             }
2706 
2707             final boolean isLoadingSynchronously =
2708                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2709             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2710                 oldCallbacks.getCurrentWorkspaceScreen();
2711             if (currScreen &gt;= orderedScreenIds.size()) {
2712                 // There may be no workspace screens (just hotseat items and an empty page).
2713                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2714             }
2715             final int currentScreen = currScreen;
2716             final long currentScreenId = currentScreen &lt; 0
2717                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2718 
2719             // Load all the items that are on the current page first (and in the process, unbind
2720             // all the existing workspace items before we call startBinding() below.
2721             unbindWorkspaceItemsOnMainThread();
2722 
2723             // Separate the items that are on the current screen, and all the other remaining items
2724             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2725             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2726             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2727                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2728             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2729                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2730             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2731             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2732 
2733             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2734                     otherWorkspaceItems);
2735             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2736                     otherAppWidgets);
2737             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2738                     otherFolders);
2739             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2740             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2741 
2742             // Tell the workspace that we&#x27;re about to start binding items
2743             r = new Runnable() {
2744                 public void run() {
2745                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2746                     if (callbacks != null) {
2747                         callbacks.startBinding();
2748                     }
2749                 }
2750             };
2751             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2752 
2753             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2754 
2755             // Load items on the current page
2756             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2757                     currentFolders, null);
2758             if (isLoadingSynchronously) {
2759                 r = new Runnable() {
2760                     public void run() {
2761                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2762                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2763                             callbacks.onPageBoundSynchronously(currentScreen);
2764                         }
2765                     }
2766                 };
2767                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2768             }
2769 
2770             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2771             // work until after the first render)
2772             synchronized (mDeferredBindRunnables) {
2773                 mDeferredBindRunnables.clear();
2774             }
2775             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2776                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2777 
2778             // Tell the workspace that we&#x27;re done binding items
2779             r = new Runnable() {
2780                 public void run() {
2781                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2782                     if (callbacks != null) {
2783                         callbacks.finishBindingItems(isUpgradePath);
2784                     }
2785 
2786                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2787                     if (DEBUG_LOADERS) {
2788                         Log.d(TAG, &quot;bound workspace in &quot;
2789                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2790                     }
2791 
2792                     mIsLoadingAndBindingWorkspace = false;
2793                 }
2794             };
2795             if (isLoadingSynchronously) {
2796                 synchronized (mDeferredBindRunnables) {
2797                     mDeferredBindRunnables.add(r);
2798                 }
2799             } else {
2800                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2801             }
2802         }
2803 
2804         private void loadAndBindAllApps() {
2805             if (DEBUG_LOADERS) {
2806                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2807             }
2808             if (!mAllAppsLoaded) {
2809                 loadAllApps();
2810                 synchronized (LoaderTask.this) {
2811                     if (mStopped) {
2812                         return;
2813                     }
2814                     mAllAppsLoaded = true;
2815                 }
2816             } else {
2817                 onlyBindAllApps();
2818             }
2819         }
2820 
2821         private void onlyBindAllApps() {
2822             final Callbacks oldCallbacks = mCallbacks.get();
2823             if (oldCallbacks == null) {
2824                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2825                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2826                 return;
2827             }
2828 
2829             // shallow copy
2830             @SuppressWarnings(&quot;unchecked&quot;)
2831             final ArrayList&lt;AppInfo&gt; list
2832                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2833             Runnable r = new Runnable() {
2834                 public void run() {
2835                     final long t = SystemClock.uptimeMillis();
2836                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2837                     if (callbacks != null) {
2838                         callbacks.bindAllApplications(list);
2839                     }
2840                     if (DEBUG_LOADERS) {
2841                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2842                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2843                     }
2844                 }
2845             };
2846             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2847             if (isRunningOnMainThread) {
2848                 r.run();
2849             } else {
2850                 mHandler.post(r);
2851             }
2852         }
2853 
2854         private void loadAllApps() {
2855             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2856 
2857             final Callbacks oldCallbacks = mCallbacks.get();
2858             if (oldCallbacks == null) {
2859                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2860                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2861                 return;
2862             }
2863 
2864             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2865             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2866 
2867             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2868 
2869             // Clear the list of apps
2870             mBgAllAppsList.clear();
2871             for (UserHandleCompat user : profiles) {
2872                 // Query for the set of apps
2873                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2874                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2875                 if (DEBUG_LOADERS) {
2876                     Log.d(TAG, &quot;getActivityList took &quot;
2877                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2878                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2879                 }
2880                 // Fail if we don&#x27;t have any apps
2881                 if (apps == null || apps.isEmpty()) {
2882                     return;
2883                 }
2884                 // Sort the applications by name
2885                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2886                 Collections.sort(apps,
2887                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2888                 if (DEBUG_LOADERS) {
2889                     Log.d(TAG, &quot;sort took &quot;
2890                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2891                 }
2892 
2893                 // Create the ApplicationInfos
2894                 for (int i = 0; i &lt; apps.size(); i++) {
2895                     LauncherActivityInfoCompat app = apps.get(i);
2896                     // This builds the icon bitmaps.
2897                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2898                 }
2899             }
2900             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2901             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2902             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2903 
2904             // Post callback on main thread
2905             mHandler.post(new Runnable() {
2906                 public void run() {
2907                     final long bindTime = SystemClock.uptimeMillis();
2908                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2909                     if (callbacks != null) {
2910                         callbacks.bindAllApplications(added);
2911                         if (DEBUG_LOADERS) {
2912                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2913                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2914                         }
2915                     } else {
2916                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2917                     }
2918                 }
2919             });
2920 
2921             if (DEBUG_LOADERS) {
2922                 Log.d(TAG, &quot;Icons processed in &quot;
2923                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2924             }
2925         }
2926 
2927         public void dumpState() {
2928             synchronized (sBgLock) {
2929                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2930                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2931                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2932                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2933                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2934             }
2935         }
2936     }
2937 
2938     void enqueuePackageUpdated(PackageUpdatedTask task) {
2939         sWorker.post(task);
2940     }
2941 
2942     private class AppsAvailabilityCheck extends BroadcastReceiver {
2943 
2944         @Override
2945         public void onReceive(Context context, Intent intent) {
2946             synchronized (sBgLock) {
2947                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2948                         .getInstance(mApp.getContext());
2949                 final PackageManager manager = context.getPackageManager();
2950                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2951                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2952                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2953                     UserHandleCompat user = entry.getKey();
2954                     packagesRemoved.clear();
2955                     packagesUnavailable.clear();
2956                     for (String pkg : entry.getValue()) {
2957                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2958                             boolean packageOnSdcard = launcherApps.isAppEnabled(
2959                                     manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
2960                             if (packageOnSdcard) {
2961                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2962                                 packagesUnavailable.add(pkg);
2963                             } else {
2964                                 Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2965                                 packagesRemoved.add(pkg);
2966                             }
2967                         }
2968                     }
2969                     if (!packagesRemoved.isEmpty()) {
2970                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2971                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2972                     }
2973                     if (!packagesUnavailable.isEmpty()) {
2974                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
<abbr title="2975                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">2975                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), userðŸ”µ</abbr>
2976                     }
2977                 }
2978                 sPendingPackages.clear();
2979             }
2980         }
2981     }
2982 
2983     /**
2984      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2985      * runnable was missed by the launcher.
2986      */
2987     public void recheckRestoredItems(final Context context) {
2988         Runnable r = new Runnable() {
2989 
2990             @Override
2991             public void run() {
2992                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2993                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2994                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2995                 synchronized(sBgLock) {
2996                     for (ItemInfo info : sBgItemsIdMap.values()) {
2997                         if (info instanceof ShortcutInfo) {
2998                             ShortcutInfo si = (ShortcutInfo) info;
2999                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
3000                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3001                                             si.getTargetComponent().getPackageName(), user)) {
3002                                 installedPackages.add(si.getTargetComponent().getPackageName());
3003                             }
3004                         } else if (info instanceof LauncherAppWidgetInfo) {
3005                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
3006                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3007                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3008                                             widget.providerName.getPackageName(), user)) {
3009                                 installedPackages.add(widget.providerName.getPackageName());
3010                             }
3011                         }
3012                     }
3013                 }
3014 
3015                 if (!installedPackages.isEmpty()) {
3016                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
3017                     for (String pkg : installedPackages) {
3018                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
3019                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
3020                         }
3021                     }
3022 
3023                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3024                     if (!restoredApps.isEmpty()) {
3025                         mHandler.post(new Runnable() {
3026                             public void run() {
3027                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3028                                 if (callbacks == cb &amp;&amp; cb != null) {
3029                                     callbacks.bindAppsRestored(restoredApps);
3030                                 }
3031                             }
3032                         });
3033                     }
3034 
3035                 }
3036             }
3037         };
3038         sWorker.post(r);
3039     }
3040 
3041     private class PackageUpdatedTask implements Runnable {
3042         int mOp;
3043         String[] mPackages;
3044         UserHandleCompat mUser;
3045 
3046         public static final int OP_NONE = 0;
3047         public static final int OP_ADD = 1;
3048         public static final int OP_UPDATE = 2;
3049         public static final int OP_REMOVE = 3; // uninstlled
3050         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3051 
3052 
3053         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3054             mOp = op;
3055             mPackages = packages;
3056             mUser = user;
3057         }
3058 
3059         public void run() {
3060             final Context context = mApp.getContext();
3061 
3062             final String[] packages = mPackages;
3063             final int N = packages.length;
3064             switch (mOp) {
3065                 case OP_ADD:
3066                     for (int i=0; i&lt;N; i++) {
3067                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3068                         mIconCache.remove(packages[i], mUser);
3069                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3070                     }
3071                     break;
3072                 case OP_UPDATE:
3073                     for (int i=0; i&lt;N; i++) {
3074                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3075                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3076                         WidgetPreviewLoader.removePackageFromDb(
3077                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3078                     }
3079                     break;
3080                 case OP_REMOVE:
3081                 case OP_UNAVAILABLE:
3082                     boolean clearCache = mOp == OP_REMOVE;
3083                     for (int i=0; i&lt;N; i++) {
3084                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3085                         mBgAllAppsList.removePackage(packages[i], mUser, clearCache);
3086                         WidgetPreviewLoader.removePackageFromDb(
3087                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3088                     }
3089                     break;
3090             }
3091 
3092             ArrayList&lt;AppInfo&gt; added = null;
3093             ArrayList&lt;AppInfo&gt; modified = null;
3094             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3095 
3096             if (mBgAllAppsList.added.size() &gt; 0) {
3097                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3098                 mBgAllAppsList.added.clear();
3099             }
3100             if (mBgAllAppsList.modified.size() &gt; 0) {
3101                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3102                 mBgAllAppsList.modified.clear();
3103             }
3104             if (mBgAllAppsList.removed.size() &gt; 0) {
3105                 removedApps.addAll(mBgAllAppsList.removed);
3106                 mBgAllAppsList.removed.clear();
3107             }
3108 
3109             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3110             if (callbacks == null) {
3111                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3112                 return;
3113             }
3114 
3115             if (added != null) {
3116                 // Ensure that we add all the workspace applications to the db
3117                 if (LauncherAppState.isDisableAllApps()) {
3118                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3119                     addAndBindAddedWorkspaceApps(context, addedInfos);
3120                 } else {
3121                     addAppsToAllApps(context, added);
3122                 }
3123             }
3124 
3125             if (modified != null) {
3126                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3127 
3128                 // Update the launcher db to reflect the changes
3129                 for (AppInfo a : modifiedFinal) {
3130                     ArrayList&lt;ItemInfo&gt; infos =
3131                             getItemInfoForComponentName(a.componentName, mUser);
3132                     for (ItemInfo i : infos) {
3133                         if (i instanceof ShortcutInfo &amp;&amp; isShortcutAppTarget((ShortcutInfo) i)) {
3134                             ShortcutInfo info = (ShortcutInfo) i;
3135                             info.title = a.title.toString();
3136                             info.contentDescription = a.contentDescription;
3137                             updateItemInDatabase(context, info);
3138                         }
3139                     }
3140                 }
3141 
3142                 mHandler.post(new Runnable() {
3143                     public void run() {
3144                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3145                         if (callbacks == cb &amp;&amp; cb != null) {
3146                             callbacks.bindAppsUpdated(modifiedFinal);
3147                         }
3148                     }
3149                 });
3150             }
3151 
3152             // Update shortcuts which use an iconResource
3153             if (mOp == OP_ADD || mOp == OP_UPDATE) {
3154                 final ArrayList&lt;ShortcutInfo&gt; iconsChanged = new ArrayList&lt;ShortcutInfo&gt;();
3155                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3156                 // We need to iterate over the items here, so that we can avoid new Bitmap
3157                 // creation on the UI thread.
3158                 synchronized (sBgLock) {
3159                     for (ItemInfo info : sBgWorkspaceItems) {
3160                         if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3161                             ShortcutInfo si = (ShortcutInfo) info;
3162                             if ((si.iconResource != null)
3163                                     &amp;&amp; packageSet.contains(si.getTargetComponent().getPackageName())){
3164                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName,
3165                                         si.iconResource.resourceName, mIconCache, context);
3166                                 if (icon != null) {
3167                                     si.setIcon(icon);
3168                                     si.usingFallbackIcon = false;
3169                                     iconsChanged.add(si);
3170                                     updateItemInDatabase(context, si);
3171                                 }
3172                             }
3173                         }
3174                     }
3175                 }
3176 
3177                 if (!iconsChanged.isEmpty()) {
3178                     mHandler.post(new Runnable() {
3179                         public void run() {
3180                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3181                             if (callbacks == cb &amp;&amp; cb != null) {
3182                                 callbacks.bindShortcutsUpdated(iconsChanged);
3183                             }
3184                         }
3185                     });
3186                 }
3187             }
3188 
3189             final ArrayList&lt;String&gt; removedPackageNames =
3190                     new ArrayList&lt;String&gt;();
3191             if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3192                 // Mark all packages in the broadcast to be removed
3193                 removedPackageNames.addAll(Arrays.asList(packages));
3194             } else if (mOp == OP_UPDATE) {
3195                 // Mark disabled packages in the broadcast to be removed
3196                 for (int i=0; i&lt;N; i++) {
3197                     if (isPackageDisabled(context, packages[i], mUser)) {
3198                         removedPackageNames.add(packages[i]);
3199                     }
3200                 }
3201             }
3202 
3203             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3204                 final int removeReason;
3205                 if (mOp == OP_UNAVAILABLE) {
3206                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3207                 } else {
3208                     // Remove all the components associated with this package
3209                     for (String pn : removedPackageNames) {
3210                         deletePackageFromDatabase(context, pn, mUser);
3211                     }
3212                     // Remove all the specific components
3213                     for (AppInfo a : removedApps) {
3214                         ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3215                         deleteItemsFromDatabase(context, infos);
3216                     }
3217                     removeReason = 0;
3218                 }
3219 
3220                 // Remove any queued items from the install queue
3221                 String spKey = LauncherAppState.getSharedPreferencesKey();
3222                 SharedPreferences sp =
3223                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3224                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3225                 // Call the components-removed callback
3226                 mHandler.post(new Runnable() {
3227                     public void run() {
3228                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3229                         if (callbacks == cb &amp;&amp; cb != null) {
3230                             callbacks.bindComponentsRemoved(
3231                                     removedPackageNames, removedApps, mUser, removeReason);
3232                         }
3233                     }
3234                 });
3235             }
3236 
3237             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3238                     getSortedWidgetsAndShortcuts(context);
3239             mHandler.post(new Runnable() {
3240                 @Override
3241                 public void run() {
3242                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3243                     if (callbacks == cb &amp;&amp; cb != null) {
3244                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3245                     }
3246                 }
3247             });
3248 
3249             // Write all the logs to disk
3250             mHandler.post(new Runnable() {
3251                 public void run() {
3252                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3253                     if (callbacks == cb &amp;&amp; cb != null) {
3254                         callbacks.dumpLogsToLocalData();
3255                     }
3256                 }
3257             });
3258         }
3259     }
3260 
3261     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3262     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3263         PackageManager packageManager = context.getPackageManager();
3264         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3265         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3266 
3267         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3268         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3269         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3270         return widgetsAndShortcuts;
3271     }
3272 
3273     private static boolean isPackageDisabled(Context context, String packageName,
3274             UserHandleCompat user) {
3275         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3276         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3277     }
3278 
3279     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3280             UserHandleCompat user) {
3281         if (cn == null) {
3282             return false;
3283         }
3284         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3285         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3286             return false;
3287         }
3288         return launcherApps.isActivityEnabledForProfile(cn, user);
3289     }
3290 
3291     public static boolean isValidPackage(Context context, String packageName,
3292             UserHandleCompat user) {
3293         if (packageName == null) {
3294             return false;
3295         }
3296         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3297         return launcherApps.isPackageEnabledForProfile(packageName, user);
3298     }
3299 
3300     /**
3301      * Make an ShortcutInfo object for a restored application or shortcut item that points
3302      * to a package that is not yet installed on the system.
3303      */
3304     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3305             int promiseType) {
3306         final ShortcutInfo info = new ShortcutInfo();
3307         info.user = UserHandleCompat.myUserHandle();
3308         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3309 
3310         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3311             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3312             if (!TextUtils.isEmpty(title)) {
3313                 info.title = title;
3314             }
3315             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3316         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3317             if (TextUtils.isEmpty(info.title)) {
3318                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3319             }
3320             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3321         } else {
3322             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3323         }
3324 
3325         info.contentDescription = mUserManager.getBadgedLabelForUser(
3326                 info.title.toString(), info.user);
3327         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3328         info.promisedIntent = intent;
3329         return info;
3330     }
3331 
3332     /**
3333      * Make an Intent object for a restored application or shortcut item that points
3334      * to the market page for the item.
3335      */
3336     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3337         ComponentName componentName = intent.getComponent();
3338         return getMarketIntent(componentName.getPackageName());
3339     }
3340 
3341     static Intent getMarketIntent(String packageName) {
3342         return new Intent(Intent.ACTION_VIEW)
3343             .setData(new Uri.Builder()
3344                 .scheme(&quot;market&quot;)
3345                 .authority(&quot;details&quot;)
3346                 .appendQueryParameter(&quot;id&quot;, packageName)
3347                 .build());
3348     }
3349 
3350     /**
3351      * This is called from the code that adds shortcuts from the intent receiver.  This
3352      * doesn&#x27;t have a Cursor, but
3353      */
3354     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3355             UserHandleCompat user, Context context) {
3356         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3357     }
3358 
3359     /**
3360      * Make an ShortcutInfo object for a shortcut that is an application.
3361      *
3362      * If c is not null, then it will be used to fill in missing data like the title and icon.
3363      */
3364     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3365             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3366             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3367         if (user == null) {
3368             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3369             return null;
3370         }
3371 
3372         ComponentName componentName = intent.getComponent();
3373         if (componentName == null) {
3374             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3375             return null;
3376         }
3377 
3378         Intent newIntent = new Intent(intent.getAction(), null);
3379         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3380         newIntent.setComponent(componentName);
3381         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3382         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3383             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3384             return null;
3385         }
3386 
3387         final ShortcutInfo info = new ShortcutInfo();
3388 
3389         // the resource -- This may implicitly give us back the fallback icon,
3390         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3391         // to avoid saving lots of copies of that in the database, and most apps
3392         // have icons anyway.
3393         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3394 
3395         // the db
3396         if (icon == null) {
3397             if (c != null) {
3398                 icon = getIconFromCursor(c, iconIndex, context);
3399             }
3400         }
3401         // the fallback icon
3402         if (icon == null) {
3403             icon = mIconCache.getDefaultIcon(user);
3404             info.usingFallbackIcon = true;
3405         }
3406         info.setIcon(icon);
3407 
3408         // From the cache.
3409         if (labelCache != null) {
3410             info.title = labelCache.get(componentName);
3411         }
3412 
3413         // from the resource
3414         if (info.title == null &amp;&amp; lai != null) {
3415             info.title = lai.getLabel();
3416             if (labelCache != null) {
3417                 labelCache.put(componentName, info.title);
3418             }
3419         }
3420         // from the db
3421         if (info.title == null) {
3422             if (c != null) {
3423                 info.title =  c.getString(titleIndex);
3424             }
3425         }
3426         // fall back to the class name of the activity
3427         if (info.title == null) {
3428             info.title = componentName.getClassName();
3429         }
3430         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3431         info.user = user;
3432         info.contentDescription = mUserManager.getBadgedLabelForUser(
3433                 info.title.toString(), info.user);
3434         return info;
3435     }
3436 
3437     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3438             ItemInfoFilter f) {
3439         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3440         for (ItemInfo i : infos) {
3441             if (i instanceof ShortcutInfo) {
3442                 ShortcutInfo info = (ShortcutInfo) i;
3443                 ComponentName cn = info.getTargetComponent();
3444                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3445                     filtered.add(info);
3446                 }
3447             } else if (i instanceof FolderInfo) {
3448                 FolderInfo info = (FolderInfo) i;
3449                 for (ShortcutInfo s : info.contents) {
3450                     ComponentName cn = s.getTargetComponent();
3451                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3452                         filtered.add(s);
3453                     }
3454                 }
3455             } else if (i instanceof LauncherAppWidgetInfo) {
3456                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3457                 ComponentName cn = info.providerName;
3458                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3459                     filtered.add(info);
3460                 }
3461             }
3462         }
3463         return new ArrayList&lt;ItemInfo&gt;(filtered);
3464     }
3465 
3466     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3467             final UserHandleCompat user) {
3468         ItemInfoFilter filter  = new ItemInfoFilter() {
3469             @Override
3470             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3471                 if (info.user == null) {
3472                     return cn.equals(cname);
3473                 } else {
3474                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3475                 }
3476             }
3477         };
3478         return filterItemInfos(sBgItemsIdMap.values(), filter);
3479     }
3480 
3481     /**
3482      * @return true if the ShortcutInfo points to an app shortcut target, i.e. it has been added by
3483      * dragging from AllApps list.
3484      */
3485     public static boolean isShortcutAppTarget(ShortcutInfo info) {
3486         // We need to check for ACTION_MAIN otherwise getComponent() might
3487         // return null for some shortcuts (for instance, for shortcuts to
3488         // web pages.)
3489         Intent intent = info.promisedIntent != null ? info.promisedIntent : info.intent;
3490         ComponentName name = intent.getComponent();
3491         return info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3492                 Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null;
3493     }
3494 
3495     /**
3496      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3497      */
3498     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3499             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3500             int titleIndex) {
3501 
3502         Bitmap icon = null;
3503         final ShortcutInfo info = new ShortcutInfo();
3504         // Non-app shortcuts are only supported for current user.
3505         info.user = UserHandleCompat.myUserHandle();
3506         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3507 
3508         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3509 
3510         info.title = c.getString(titleIndex);
3511 
3512         int iconType = c.getInt(iconTypeIndex);
3513         switch (iconType) {
3514         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3515             String packageName = c.getString(iconPackageIndex);
3516             String resourceName = c.getString(iconResourceIndex);
3517             info.customIcon = false;
3518             // the resource
3519             icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);
3520             // the db
3521             if (icon == null) {
3522                 icon = getIconFromCursor(c, iconIndex, context);
3523             }
3524             // the fallback icon
3525             if (icon == null) {
3526                 icon = mIconCache.getDefaultIcon(info.user);
3527                 info.usingFallbackIcon = true;
3528             }
3529             break;
3530         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3531             icon = getIconFromCursor(c, iconIndex, context);
3532             if (icon == null) {
3533                 icon = mIconCache.getDefaultIcon(info.user);
3534                 info.customIcon = false;
3535                 info.usingFallbackIcon = true;
3536             } else {
3537                 info.customIcon = true;
3538             }
3539             break;
3540         default:
3541             icon = mIconCache.getDefaultIcon(info.user);
3542             info.usingFallbackIcon = true;
3543             info.customIcon = false;
3544             break;
3545         }
3546         info.setIcon(icon);
3547         return info;
3548     }
3549 
3550     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3551         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3552         final boolean debug = false;
3553         if (debug) {
3554             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3555                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3556         }
3557         byte[] data = c.getBlob(iconIndex);
3558         try {
3559             return Utilities.createIconBitmap(
3560                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3561         } catch (Exception e) {
3562             return null;
3563         }
3564     }
3565 
3566     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3567             int cellX, int cellY, boolean notify) {
3568         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3569         if (info == null) {
3570             return null;
3571         }
3572         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3573 
3574         return info;
3575     }
3576 
3577     /**
3578      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3579      */
3580     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3581             ComponentName component) {
3582         List&lt;AppWidgetProviderInfo&gt; widgets =
3583             AppWidgetManager.getInstance(context).getInstalledProviders();
3584         for (AppWidgetProviderInfo info : widgets) {
3585             if (info.provider.equals(component)) {
3586                 return info;
3587             }
3588         }
3589         return null;
3590     }
3591 
3592     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3593         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3594         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3595         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3596 
3597         if (intent == null) {
3598             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3599             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3600             return null;
3601         }
3602 
3603         Bitmap icon = null;
3604         boolean customIcon = false;
3605         ShortcutIconResource iconResource = null;
3606 
3607         if (bitmap instanceof Bitmap) {
3608             icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
3609             customIcon = true;
3610         } else {
3611             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3612             if (extra instanceof ShortcutIconResource) {
3613                 iconResource = (ShortcutIconResource) extra;
3614                 icon = Utilities.createIconBitmap(iconResource.packageName,
3615                         iconResource.resourceName, mIconCache, context);
3616             }
3617         }
3618 
3619         final ShortcutInfo info = new ShortcutInfo();
3620 
3621         // Only support intents for current user for now. Intents sent from other
3622         // users wouldn&#x27;t get here without intent forwarding anyway.
3623         info.user = UserHandleCompat.myUserHandle();
3624         if (icon == null) {
3625             if (fallbackIcon != null) {
3626                 icon = fallbackIcon;
3627             } else {
3628                 icon = mIconCache.getDefaultIcon(info.user);
3629                 info.usingFallbackIcon = true;
3630             }
3631         }
3632         info.setIcon(icon);
3633 
3634         info.title = name;
3635         info.contentDescription = mUserManager.getBadgedLabelForUser(
3636                 info.title.toString(), info.user);
3637         info.intent = intent;
3638         info.customIcon = customIcon;
3639         info.iconResource = iconResource;
3640 
3641         return info;
3642     }
3643 
3644     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3645             int iconIndex) {
3646         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3647         if (!mAppsCanBeOnRemoveableStorage) {
3648             return false;
3649         }
3650         // If this icon doesn&#x27;t have a custom icon, check to see
3651         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3652         // we&#x27;re going to show, store what we are going to show back
3653         // into the DB.  We do this so when we&#x27;re loading, if the
3654         // package manager can&#x27;t find an icon (for example because
3655         // the app is on SD) then we can use that instead.
3656         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3657             cache.put(info, c.getBlob(iconIndex));
3658             return true;
3659         }
3660         return false;
3661     }
3662     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3663         boolean needSave = false;
3664         try {
3665             if (data != null) {
3666                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3667                 Bitmap loaded = info.getIcon(mIconCache);
3668                 needSave = !saved.sameAs(loaded);
3669             } else {
3670                 needSave = true;
3671             }
3672         } catch (Exception e) {
3673             needSave = true;
3674         }
3675         if (needSave) {
3676             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3677             // This is slower than is ideal, but this only happens once
3678             // or when the app is updated with a new icon.
3679             updateItemInDatabase(context, info);
3680         }
3681     }
3682 
3683     /**
3684      * Return an existing FolderInfo object if we have encountered this ID previously,
3685      * or make a new one.
3686      */
3687     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3688         // See if a placeholder was created for us already
3689         FolderInfo folderInfo = folders.get(id);
3690         if (folderInfo == null) {
3691             // No placeholder -- create a new instance
3692             folderInfo = new FolderInfo();
3693             folders.put(id, folderInfo);
3694         }
3695         return folderInfo;
3696     }
3697 
3698     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3699         final Collator collator = Collator.getInstance();
3700         return new Comparator&lt;AppInfo&gt;() {
3701             public final int compare(AppInfo a, AppInfo b) {
3702                 if (a.user.equals(b.user)) {
3703                     int result = collator.compare(a.title.toString().trim(),
3704                             b.title.toString().trim());
3705                     if (result == 0) {
3706                         result = a.componentName.compareTo(b.componentName);
3707                     }
3708                     return result;
3709                 } else {
3710                     // TODO Need to figure out rules for sorting
3711                     // profiles, this puts work second.
3712                     return a.user.toString().compareTo(b.user.toString());
3713                 }
3714             }
3715         };
3716     }
3717     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3718             = new Comparator&lt;AppInfo&gt;() {
3719         public final int compare(AppInfo a, AppInfo b) {
3720             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3721             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3722             return 0;
3723         }
3724     };
3725     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3726         if (info.activityInfo != null) {
3727             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3728         } else {
3729             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3730         }
3731     }
3732     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3733         private Collator mCollator;
3734         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3735         ShortcutNameComparator(PackageManager pm) {
3736             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3737             mCollator = Collator.getInstance();
3738         }
3739         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3740             mLabelCache = labelCache;
3741             mCollator = Collator.getInstance();
3742         }
3743         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3744             String labelA, labelB;
3745             ComponentName keyA = a.getComponentName();
3746             ComponentName keyB = b.getComponentName();
3747             if (mLabelCache.containsKey(keyA)) {
3748                 labelA = mLabelCache.get(keyA).toString();
3749             } else {
3750                 labelA = a.getLabel().toString().trim();
3751 
3752                 mLabelCache.put(keyA, labelA);
3753             }
3754             if (mLabelCache.containsKey(keyB)) {
3755                 labelB = mLabelCache.get(keyB).toString();
3756             } else {
3757                 labelB = b.getLabel().toString().trim();
3758 
3759                 mLabelCache.put(keyB, labelB);
3760             }
3761             return mCollator.compare(labelA, labelB);
3762         }
3763     };
3764     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3765         private final AppWidgetManagerCompat mManager;
3766         private final PackageManager mPackageManager;
3767         private final HashMap&lt;Object, String&gt; mLabelCache;
3768         private final Collator mCollator;
3769 
3770         WidgetAndShortcutNameComparator(Context context) {
3771             mManager = AppWidgetManagerCompat.getInstance(context);
3772             mPackageManager = context.getPackageManager();
3773             mLabelCache = new HashMap&lt;Object, String&gt;();
3774             mCollator = Collator.getInstance();
3775         }
3776         public final int compare(Object a, Object b) {
3777             String labelA, labelB;
3778             if (mLabelCache.containsKey(a)) {
3779                 labelA = mLabelCache.get(a);
3780             } else {
3781                 labelA = (a instanceof AppWidgetProviderInfo)
3782                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
3783                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3784                 mLabelCache.put(a, labelA);
3785             }
3786             if (mLabelCache.containsKey(b)) {
3787                 labelB = mLabelCache.get(b);
3788             } else {
3789                 labelB = (b instanceof AppWidgetProviderInfo)
3790                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
3791                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3792                 mLabelCache.put(b, labelB);
3793             }
3794             return mCollator.compare(labelA, labelB);
3795         }
3796     };
3797 
3798     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3799         return (provider != null) &amp;&amp; (provider.provider != null)
3800                 &amp;&amp; (provider.provider.getPackageName() != null);
3801     }
3802 
3803     public void dumpState() {
3804         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3805         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3806         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3807         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3808         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3809         if (mLoaderTask != null) {
3810             mLoaderTask.dumpState();
3811         } else {
3812             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3813         }
3814     }
3815 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201         public void bindShortcutsUpdated(ArrayList&lt;ShortcutInfo&gt; shortcuts);
 202         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 203         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 204         public void updatePackageBadge(String packageName);
 205         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 206                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 207         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 208         public void bindSearchablesChanged();
 209         public boolean isAllAppsButtonRank(int rank);
 210         public void onPageBoundSynchronously(int page);
 211         public void dumpLogsToLocalData();
 212     }
 213 
 214     public interface ItemInfoFilter {
 215         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 216     }
 217 
 218     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 219         Context context = app.getContext();
 220 
 221         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 222         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 223         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 224         // resource string.
 225         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 226         ProviderInfo providerInfo =
 227                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 228         ProviderInfo redirectProvider =
 229                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 230 
 231         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 232         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 233 
 234         if (mOldContentProviderExists) {
 235             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 236         } else {
 237             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 238         }
 239 
 240         mApp = app;
 241         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 242         mIconCache = iconCache;
 243 
 244         final Resources res = context.getResources();
 245         Configuration config = res.getConfiguration();
 246         mPreviousConfigMcc = config.mcc;
 247         mLauncherApps = LauncherAppsCompat.getInstance(context);
 248         mUserManager = UserManagerCompat.getInstance(context);
 249     }
 250 
 251     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 252      * posted on the main thread handler. */
 253     private void runOnMainThread(Runnable r) {
 254         runOnMainThread(r, 0);
 255     }
 256     private void runOnMainThread(Runnable r, int type) {
 257         if (sWorkerThread.getThreadId() == Process.myTid()) {
 258             // If we are on the worker thread, post onto the main handler
 259             mHandler.post(r);
 260         } else {
 261             r.run();
 262         }
 263     }
 264 
 265     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 266      * posted on the worker thread handler. */
 267     private static void runOnWorkerThread(Runnable r) {
 268         if (sWorkerThread.getThreadId() == Process.myTid()) {
 269             r.run();
 270         } else {
 271             // If we are not on the worker thread, then post to the worker handler
 272             sWorker.post(r);
 273         }
 274     }
 275 
 276     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 277         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 278     }
 279 
 280     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 281                                  long screen) {
 282         LauncherAppState app = LauncherAppState.getInstance();
 283         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 284         final int xCount = (int) grid.numColumns;
 285         final int yCount = (int) grid.numRows;
 286         boolean[][] occupied = new boolean[xCount][yCount];
 287 
 288         int cellX, cellY, spanX, spanY;
 289         for (int i = 0; i &lt; items.size(); ++i) {
 290             final ItemInfo item = items.get(i);
 291             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 292                 if (item.screenId == screen) {
 293                     cellX = item.cellX;
 294                     cellY = item.cellY;
 295                     spanX = item.spanX;
 296                     spanY = item.spanY;
 297                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 298                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 299                             occupied[x][y] = true;
 300                         }
 301                     }
 302                 }
 303             }
 304         }
 305 
 306         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 307     }
 308     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 309                                                         Intent launchIntent,
 310                                                         int firstScreenIndex,
 311                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 312         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 313         LauncherAppState app = LauncherAppState.getInstance();
 314         LauncherModel model = app.getModel();
 315         boolean found = false;
 316         synchronized (app) {
 317             if (sWorkerThread.getThreadId() != Process.myTid()) {
 318                 // Flush the LauncherModel worker thread, so that if we just did another
 319                 // processInstallShortcut, we give it time for its shortcut to get added to the
 320                 // database (getItemsInLocalCoordinates reads the database)
 321                 model.flushWorkerThread();
 322             }
 323             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 324 
 325             // Try adding to the workspace screens incrementally, starting at the default or center
 326             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 327             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 328             int count = workspaceScreens.size();
 329             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 330                 int[] tmpCoordinates = new int[2];
 331                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 332                         workspaceScreens.get(screen))) {
 333                     // Update the Launcher db
 334                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 335                 }
 336             }
 337         }
 338         return null;
 339     }
 340 
 341     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 342         // Process the updated package state
 343         Runnable r = new Runnable() {
 344             public void run() {
 345                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 346                 if (callbacks != null) {
 347                     callbacks.updatePackageState(installInfo);
 348                 }
 349             }
 350         };
 351         mHandler.post(r);
 352     }
 353 
 354     public void updatePackageBadge(final String packageName) {
 355         // Process the updated package badge
 356         Runnable r = new Runnable() {
 357             public void run() {
 358                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 359                 if (callbacks != null) {
 360                     callbacks.updatePackageBadge(packageName);
 361                 }
 362             }
 363         };
 364         mHandler.post(r);
 365     }
 366 
 367     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 368         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 369 
 370         if (allAppsApps == null) {
 371             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 372         }
 373         if (allAppsApps.isEmpty()) {
 374             return;
 375         }
 376 
 377         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 378         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 379         while (iter.hasNext()) {
 380             ItemInfo a = iter.next();
 381             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 382                 restoredAppsFinal.add((AppInfo) a);
 383             }
 384         }
 385 
 386         // Process the newly added applications and add them to the database first
 387         Runnable r = new Runnable() {
 388             public void run() {
 389                 runOnMainThread(new Runnable() {
 390                     public void run() {
 391                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 392                         if (callbacks == cb &amp;&amp; cb != null) {
 393                             if (!restoredAppsFinal.isEmpty()) {
 394                                 for (AppInfo info : restoredAppsFinal) {
 395                                     final Intent intent = info.getIntent();
 396                                     if (intent != null) {
 397                                         mIconCache.deletePreloadedIcon(intent.getComponent(),
 398                                                 info.user);
 399                                     }
 400                                 }
 401                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 402                             }
 403                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 404                         }
 405                     }
 406                 });
 407             }
 408         };
 409         runOnWorkerThread(r);
 410     }
 411 
 412     public void addAndBindAddedWorkspaceApps(final Context context,
 413             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 414         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 415 
 416         if (workspaceApps == null) {
 417             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 418         }
 419         if (workspaceApps.isEmpty()) {
 420             return;
 421         }
 422         // Process the newly added applications and add them to the database first
 423         Runnable r = new Runnable() {
 424             public void run() {
 425                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 426                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 427                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 428 
 429                 // Get the list of workspace screens.  We need to append to this list and
 430                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 431                 // called.
 432                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 433                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 434                 for (Integer i : orderedScreens.keySet()) {
 435                     long screenId = orderedScreens.get(i);
 436                     workspaceScreens.add(screenId);
 437                 }
 438 
 439                 synchronized(sBgLock) {
 440                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 441                     while (iter.hasNext()) {
 442                         ItemInfo a = iter.next();
 443                         final String name = a.title.toString();
 444                         final Intent launchIntent = a.getIntent();
 445 
 446                         // Short-circuit this logic if the icon exists somewhere on the workspace
 447                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 448                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 449                             if (a instanceof AppInfo &amp;&amp;
 450                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 451                                 restoredAppsFinal.add((AppInfo) a);
 452                             }
 453                             continue;
 454                         }
 455 
 456                         // Add this icon to the db, creating a new page if necessary.  If there
 457                         // is only the empty page then we just add items to the first page.
 458                         // Otherwise, we add them to the next pages.
 459                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 460                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 461                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 462                         if (coords == null) {
 463                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 464 
 465                             // If we can&#x27;t find a valid position, then just add a new screen.
 466                             // This takes time so we need to re-queue the add until the new
 467                             // page is added.  Create as many screens as necessary to satisfy
 468                             // the startSearchPageIndex.
 469                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 470                                     workspaceScreens.size());
 471                             while (numPagesToAdd &gt; 0) {
 472                                 long screenId = lp.generateNewScreenId();
 473                                 // Save the screen id for binding in the workspace
 474                                 workspaceScreens.add(screenId);
 475                                 addedWorkspaceScreensFinal.add(screenId);
 476                                 numPagesToAdd--;
 477                             }
 478 
 479                             // Find the coordinate again
 480                             coords = LauncherModel.findNextAvailableIconSpace(context,
 481                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 482                         }
 483                         if (coords == null) {
 484                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 485                         }
 486 
 487                         ShortcutInfo shortcutInfo;
 488                         if (a instanceof ShortcutInfo) {
 489                             shortcutInfo = (ShortcutInfo) a;
 490                         } else if (a instanceof AppInfo) {
 491                             shortcutInfo = ((AppInfo) a).makeShortcut();
 492                         } else {
 493                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 494                         }
 495 
 496                         // Add the shortcut to the db
 497                         addItemToDatabase(context, shortcutInfo,
 498                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 499                                 coords.first, coords.second[0], coords.second[1], false);
 500                         // Save the ShortcutInfo for binding in the workspace
 501                         addedShortcutsFinal.add(shortcutInfo);
 502                     }
 503                 }
 504 
 505                 // Update the workspace screens
 506                 updateWorkspaceScreenOrder(context, workspaceScreens);
 507 
 508                 if (!addedShortcutsFinal.isEmpty()) {
 509                     runOnMainThread(new Runnable() {
 510                         public void run() {
 511                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 512                             if (callbacks == cb &amp;&amp; cb != null) {
 513                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 515                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 517                                     long lastScreenId = info.screenId;
 518                                     for (ItemInfo i : addedShortcutsFinal) {
 519                                         if (i.screenId == lastScreenId) {
 520                                             addAnimated.add(i);
 521                                         } else {
 522                                             addNotAnimated.add(i);
 523                                         }
 524                                     }
 525                                 }
 526                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 527                                         addNotAnimated, addAnimated, null);
 528                                 if (!restoredAppsFinal.isEmpty()) {
 529                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 530                                 }
 531                             }
 532                         }
 533                     });
 534                 }
 535             }
 536         };
 537         runOnWorkerThread(r);
 538     }
 539 
 540     public void unbindItemInfosAndClearQueuedBindRunnables() {
 541         if (sWorkerThread.getThreadId() == Process.myTid()) {
 542             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 543                     &quot;main thread&quot;);
 544         }
 545 
 546         // Clear any deferred bind runnables
 547         synchronized (mDeferredBindRunnables) {
 548             mDeferredBindRunnables.clear();
 549         }
 550         // Remove any queued bind runnables
 551         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 552         // Unbind all the workspace items
 553         unbindWorkspaceItemsOnMainThread();
 554     }
 555 
 556     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 557     void unbindWorkspaceItemsOnMainThread() {
 558         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 559         // by making a copy of workspace items first.
 560         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 561         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 562         synchronized (sBgLock) {
 563             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 564             tmpAppWidgets.addAll(sBgAppWidgets);
 565         }
 566         Runnable r = new Runnable() {
 567                 @Override
 568                 public void run() {
 569                    for (ItemInfo item : tmpWorkspaceItems) {
 570                        item.unbind();
 571                    }
 572                    for (ItemInfo item : tmpAppWidgets) {
 573                        item.unbind();
 574                    }
 575                 }
 576             };
 577         runOnMainThread(r);
 578     }
 579 
 580     /**
 581      * Adds an item to the DB if it was not created previously, or move it to a new
 582      * &lt;container, screen, cellX, cellY&gt;
 583      */
 584     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 585             long screenId, int cellX, int cellY) {
 586         if (item.container == ItemInfo.NO_ID) {
 587             // From all apps
 588             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 589         } else {
 590             // From somewhere else
 591             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 592         }
 593     }
 594 
 595     static void checkItemInfoLocked(
 596             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 597         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 598         if (modelItem != null &amp;&amp; item != modelItem) {
 599             // check all the data is consistent
 600             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 601                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 602                 ShortcutInfo shortcut = (ShortcutInfo) item;
 603                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 604                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 605                         modelShortcut.id == shortcut.id &amp;&amp;
 606                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 607                         modelShortcut.container == shortcut.container &amp;&amp;
 608                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 609                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 610                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 611                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 612                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 613                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 614                         (modelShortcut.dropPos != null &amp;&amp;
 615                                 shortcut.dropPos != null &amp;&amp;
 616                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 617                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 618                     // For all intents and purposes, this is the same object
 619                     return;
 620                 }
 621             }
 622 
 623             // the modelItem needs to match up perfectly with item if our model is
 624             // to be consistent with the database-- for now, just require
 625             // modelItem == item or the equality check above
 626             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 627                     &quot;modelItem: &quot; +
 628                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 629                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 630             RuntimeException e = new RuntimeException(msg);
 631             if (stackTrace != null) {
 632                 e.setStackTrace(stackTrace);
 633             }
 634             throw e;
 635         }
 636     }
 637 
 638     static void checkItemInfo(final ItemInfo item) {
 639         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 640         final long itemId = item.id;
 641         Runnable r = new Runnable() {
 642             public void run() {
 643                 synchronized (sBgLock) {
 644                     checkItemInfoLocked(itemId, item, stackTrace);
 645                 }
 646             }
 647         };
 648         runOnWorkerThread(r);
 649     }
 650 
 651     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 652             final ItemInfo item, final String callingFunction) {
 653         final long itemId = item.id;
 654         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 655         final ContentResolver cr = context.getContentResolver();
 656 
 657         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 658         Runnable r = new Runnable() {
 659             public void run() {
 660                 cr.update(uri, values, null, null);
 661                 updateItemArrays(item, itemId, stackTrace);
 662             }
 663         };
 664         runOnWorkerThread(r);
 665     }
 666 
 667     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 668             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 669         final ContentResolver cr = context.getContentResolver();
 670 
 671         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 672         Runnable r = new Runnable() {
 673             public void run() {
 674                 ArrayList&lt;ContentProviderOperation&gt; ops =
 675                         new ArrayList&lt;ContentProviderOperation&gt;();
 676                 int count = items.size();
 677                 for (int i = 0; i &lt; count; i++) {
 678                     ItemInfo item = items.get(i);
 679                     final long itemId = item.id;
 680                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 681                     ContentValues values = valuesList.get(i);
 682 
 683                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 684                     updateItemArrays(item, itemId, stackTrace);
 685 
 686                 }
 687                 try {
 688                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 689                 } catch (Exception e) {
 690                     e.printStackTrace();
 691                 }
 692             }
 693         };
 694         runOnWorkerThread(r);
 695     }
 696 
 697     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 698         // Lock on mBgLock *after* the db operation
 699         synchronized (sBgLock) {
 700             checkItemInfoLocked(itemId, item, stackTrace);
 701 
 702             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 703                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 704                 // Item is in a folder, make sure this folder exists
 705                 if (!sBgFolders.containsKey(item.container)) {
 706                     // An items container is being set to a that of an item which is not in
 707                     // the list of Folders.
 708                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 709                             item.container + &quot;, not in the list of folders&quot;;
 710                     Log.e(TAG, msg);
 711                 }
 712             }
 713 
 714             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 715             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 716             // that are on the desktop, as appropriate
 717             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 718             if (modelItem != null &amp;&amp;
 719                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 720                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 721                 switch (modelItem.itemType) {
 722                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 723                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 724                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 725                         if (!sBgWorkspaceItems.contains(modelItem)) {
 726                             sBgWorkspaceItems.add(modelItem);
 727                         }
 728                         break;
 729                     default:
 730                         break;
 731                 }
 732             } else {
 733                 sBgWorkspaceItems.remove(modelItem);
 734             }
 735         }
 736     }
 737 
 738     public void flushWorkerThread() {
 739         mFlushingWorkerThread = true;
 740         Runnable waiter = new Runnable() {
 741                 public void run() {
 742                     synchronized (this) {
 743                         notifyAll();
 744                         mFlushingWorkerThread = false;
 745                     }
 746                 }
 747             };
 748 
 749         synchronized(waiter) {
 750             runOnWorkerThread(waiter);
 751             if (mLoaderTask != null) {
 752                 synchronized(mLoaderTask) {
 753                     mLoaderTask.notify();
 754                 }
 755             }
 756             boolean success = false;
 757             while (!success) {
 758                 try {
 759                     waiter.wait();
 760                     success = true;
 761                 } catch (InterruptedException e) {
 762                 }
 763             }
 764         }
 765     }
 766 
 767     /**
 768      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 769      */
 770     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 771             final long screenId, final int cellX, final int cellY) {
 772         item.container = container;
 773         item.cellX = cellX;
 774         item.cellY = cellY;
 775 
 776         // We store hotseat items in canonical form which is this orientation invariant position
 777         // in the hotseat
 778         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 779                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 780             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 781         } else {
 782             item.screenId = screenId;
 783         }
 784 
 785         final ContentValues values = new ContentValues();
 786         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 787         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 788         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 789         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 790 
 791         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 792     }
 793 
 794     /**
 795      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 796      * cellX, cellY have already been updated on the ItemInfos.
 797      */
 798     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 799             final long container, final int screen) {
 800 
 801         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 802         int count = items.size();
 803 
 804         for (int i = 0; i &lt; count; i++) {
 805             ItemInfo item = items.get(i);
 806             item.container = container;
 807 
 808             // We store hotseat items in canonical form which is this orientation invariant position
 809             // in the hotseat
 810             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 811                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 812                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 813                         item.cellY);
 814             } else {
 815                 item.screenId = screen;
 816             }
 817 
 818             final ContentValues values = new ContentValues();
 819             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 820             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 821             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 822             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 823 
 824             contentValues.add(values);
 825         }
 826         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 827     }
 828 
 829     /**
 830      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 831      */
 832     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 833             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 834         item.container = container;
 835         item.cellX = cellX;
 836         item.cellY = cellY;
 837         item.spanX = spanX;
 838         item.spanY = spanY;
 839 
 840         // We store hotseat items in canonical form which is this orientation invariant position
 841         // in the hotseat
 842         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 843                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 844             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 845         } else {
 846             item.screenId = screenId;
 847         }
 848 
 849         final ContentValues values = new ContentValues();
 850         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 851         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 852         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 853         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 854         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 855         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 856 
 857         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 858     }
 859 
 860     /**
 861      * Update an item to the database in a specified container.
 862      */
 863     static void updateItemInDatabase(Context context, final ItemInfo item) {
 864         final ContentValues values = new ContentValues();
 865         item.onAddToDatabase(context, values);
 866         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 867         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 868     }
 869 
 870     /**
 871      * Returns true if the shortcuts already exists in the database.
 872      * we identify a shortcut by its title and intent.
 873      */
 874     static boolean shortcutExists(Context context, String title, Intent intent) {
 875         final ContentResolver cr = context.getContentResolver();
 876         final Intent intentWithPkg, intentWithoutPkg;
 877 
 878         if (intent.getComponent() != null) {
 879             // If component is not null, an intent with null package will produce
 880             // the same result and should also be a match.
 881             if (intent.getPackage() != null) {
 882                 intentWithPkg = intent;
 883                 intentWithoutPkg = new Intent(intent).setPackage(null);
 884             } else {
 885                 intentWithPkg = new Intent(intent).setPackage(
 886                         intent.getComponent().getPackageName());
 887                 intentWithoutPkg = intent;
 888             }
 889         } else {
 890             intentWithPkg = intent;
 891             intentWithoutPkg = intent;
 892         }
 893         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 894             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 895             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 896         boolean result = false;
 897         try {
 898             result = c.moveToFirst();
 899         } finally {
 900             c.close();
 901         }
 902         return result;
 903     }
 904 
 905     /**
 906      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 907      */
 908     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 909         final ComponentName component = intent.getComponent();
 910         if (component == null) {
 911             return false;
 912         }
 913         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 914     }
 915 
 916     /**
 917      * Returns an ItemInfo array containing all the items in the LauncherModel.
 918      * The ItemInfo.id is not set through this function.
 919      */
 920     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 921         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 922         final ContentResolver cr = context.getContentResolver();
 923         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 924                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 925                 LauncherSettings.Favorites.SCREEN,
 926                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 927                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 928                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 929 
 930         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 931         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 932         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 933         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 934         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 935         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 936         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 937         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 938         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 939         try {
 940             while (c.moveToNext()) {
 941                 ItemInfo item = new ItemInfo();
 942                 item.cellX = c.getInt(cellXIndex);
 943                 item.cellY = c.getInt(cellYIndex);
 944                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 945                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 946                 item.container = c.getInt(containerIndex);
 947                 item.itemType = c.getInt(itemTypeIndex);
 948                 item.screenId = c.getInt(screenIndex);
 949                 long serialNumber = c.getInt(profileIdIndex);
 950                 item.user = userManager.getUserForSerialNumber(serialNumber);
 951                 // Skip if user has been deleted.
 952                 if (item.user != null) {
 953                     items.add(item);
 954                 }
 955             }
 956         } catch (Exception e) {
 957             items.clear();
 958         } finally {
 959             c.close();
 960         }
 961 
 962         return items;
 963     }
 964 
 965     /**
 966      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 967      */
 968     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 969         final ContentResolver cr = context.getContentResolver();
 970         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 971                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 972                 new String[] { String.valueOf(id),
 973                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 974 
 975         try {
 976             if (c.moveToFirst()) {
 977                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 978                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 979                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 980                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 981                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 982                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 983 
 984                 FolderInfo folderInfo = null;
 985                 switch (c.getInt(itemTypeIndex)) {
 986                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 987                         folderInfo = findOrMakeFolder(folderList, id);
 988                         break;
 989                 }
 990 
 991                 folderInfo.title = c.getString(titleIndex);
 992                 folderInfo.id = id;
 993                 folderInfo.container = c.getInt(containerIndex);
 994                 folderInfo.screenId = c.getInt(screenIndex);
 995                 folderInfo.cellX = c.getInt(cellXIndex);
 996                 folderInfo.cellY = c.getInt(cellYIndex);
 997 
 998                 return folderInfo;
 999             }
1000         } finally {
1001             c.close();
1002         }
1003 
1004         return null;
1005     }
1006 
1007     /**
1008      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1009      * cellY fields of the item. Also assigns an ID to the item.
1010      */
1011     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1012             final long screenId, final int cellX, final int cellY, final boolean notify) {
1013         item.container = container;
1014         item.cellX = cellX;
1015         item.cellY = cellY;
1016         // We store hotseat items in canonical form which is this orientation invariant position
1017         // in the hotseat
1018         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1019                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1020             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1021         } else {
1022             item.screenId = screenId;
1023         }
1024 
1025         final ContentValues values = new ContentValues();
1026         final ContentResolver cr = context.getContentResolver();
1027         item.onAddToDatabase(context, values);
1028 
1029         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1030         values.put(LauncherSettings.Favorites._ID, item.id);
1031         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1032 
1033         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1034         Runnable r = new Runnable() {
1035             public void run() {
1036                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1037                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1038 
1039                 // Lock on mBgLock *after* the db operation
1040                 synchronized (sBgLock) {
1041                     checkItemInfoLocked(item.id, item, stackTrace);
1042                     sBgItemsIdMap.put(item.id, item);
1043                     switch (item.itemType) {
1044                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1045                             sBgFolders.put(item.id, (FolderInfo) item);
1046                             // Fall through
1047                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1048                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1049                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1050                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1051                                 sBgWorkspaceItems.add(item);
1052                             } else {
1053                                 if (!sBgFolders.containsKey(item.container)) {
1054                                     // Adding an item to a folder that doesn&#x27;t exist.
1055                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1056                                             &quot; doesn&#x27;t exist&quot;;
1057                                     Log.e(TAG, msg);
1058                                 }
1059                             }
1060                             break;
1061                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1062                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1063                             break;
1064                     }
1065                 }
1066             }
1067         };
1068         runOnWorkerThread(r);
1069     }
1070 
1071     /**
1072      * Creates a new unique child id, for a given cell span across all layouts.
1073      */
1074     static int getCellLayoutChildId(
1075             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1076         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1077                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1078     }
1079 
1080     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1081             final String pn, final UserHandleCompat user) {
1082         ItemInfoFilter filter  = new ItemInfoFilter() {
1083             @Override
1084             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1085                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1086             }
1087         };
1088         return filterItemInfos(sBgItemsIdMap.values(), filter);
1089     }
1090 
1091     /**
1092      * Removes all the items from the database corresponding to the specified package.
1093      */
1094     static void deletePackageFromDatabase(Context context, final String pn,
1095             final UserHandleCompat user) {
1096         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1097     }
1098 
1099     /**
1100      * Removes the specified item from the database
1101      * @param context
1102      * @param item
1103      */
1104     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1105         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1106         items.add(item);
1107         deleteItemsFromDatabase(context, items);
1108     }
1109 
1110     /**
1111      * Removes the specified items from the database
1112      * @param context
1113      * @param item
1114      */
1115     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1116         final ContentResolver cr = context.getContentResolver();
1117 
1118         Runnable r = new Runnable() {
1119             public void run() {
1120                 for (ItemInfo item : items) {
1121                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1122                     cr.delete(uri, null, null);
1123 
1124                     // Lock on mBgLock *after* the db operation
1125                     synchronized (sBgLock) {
1126                         switch (item.itemType) {
1127                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1128                                 sBgFolders.remove(item.id);
1129                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1130                                     if (info.container == item.id) {
1131                                         // We are deleting a folder which still contains items that
1132                                         // think they are contained by that folder.
1133                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1134                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1135                                         Log.e(TAG, msg);
1136                                     }
1137                                 }
1138                                 sBgWorkspaceItems.remove(item);
1139                                 break;
1140                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1141                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1142                                 sBgWorkspaceItems.remove(item);
1143                                 break;
1144                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1145                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1146                                 break;
1147                         }
1148                         sBgItemsIdMap.remove(item.id);
1149                         sBgDbIconCache.remove(item);
1150                     }
1151                 }
1152             }
1153         };
1154         runOnWorkerThread(r);
1155     }
1156 
1157     /**
1158      * Update the order of the workspace screens in the database. The array list contains
1159      * a list of screen ids in the order that they should appear.
1160      */
1161     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1162         // Log to disk
1163         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1164         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1165 
1166         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1167         final ContentResolver cr = context.getContentResolver();
1168         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1169 
1170         // Remove any negative screen ids -- these aren&#x27;t persisted
1171         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1172         while (iter.hasNext()) {
1173             long id = iter.next();
1174             if (id &lt; 0) {
1175                 iter.remove();
1176             }
1177         }
1178 
1179         Runnable r = new Runnable() {
1180             @Override
1181             public void run() {
1182                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1183                 // Clear the table
1184                 ops.add(ContentProviderOperation.newDelete(uri).build());
1185                 int count = screensCopy.size();
1186                 for (int i = 0; i &lt; count; i++) {
1187                     ContentValues v = new ContentValues();
1188                     long screenId = screensCopy.get(i);
1189                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1190                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1191                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1192                 }
1193 
1194                 try {
1195                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1196                 } catch (Exception ex) {
1197                     throw new RuntimeException(ex);
1198                 }
1199 
1200                 synchronized (sBgLock) {
1201                     sBgWorkspaceScreens.clear();
1202                     sBgWorkspaceScreens.addAll(screensCopy);
1203                 }
1204             }
1205         };
1206         runOnWorkerThread(r);
1207     }
1208 
1209     /**
1210      * Remove the contents of the specified folder from the database
1211      */
1212     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1213         final ContentResolver cr = context.getContentResolver();
1214 
1215         Runnable r = new Runnable() {
1216             public void run() {
1217                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1218                 // Lock on mBgLock *after* the db operation
1219                 synchronized (sBgLock) {
1220                     sBgItemsIdMap.remove(info.id);
1221                     sBgFolders.remove(info.id);
1222                     sBgDbIconCache.remove(info);
1223                     sBgWorkspaceItems.remove(info);
1224                 }
1225 
1226                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1227                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1228                 // Lock on mBgLock *after* the db operation
1229                 synchronized (sBgLock) {
1230                     for (ItemInfo childInfo : info.contents) {
1231                         sBgItemsIdMap.remove(childInfo.id);
1232                         sBgDbIconCache.remove(childInfo);
1233                     }
1234                 }
1235             }
1236         };
1237         runOnWorkerThread(r);
1238     }
1239 
1240     /**
1241      * Set this as the current Launcher activity object for the loader.
1242      */
1243     public void initialize(Callbacks callbacks) {
1244         synchronized (mLock) {
1245             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1246         }
1247     }
1248 
1249     @Override
1250     public void onPackageChanged(String packageName, UserHandleCompat user) {
1251         int op = PackageUpdatedTask.OP_UPDATE;
1252         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1253                 user));
1254     }
1255 
1256     @Override
1257     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1258         int op = PackageUpdatedTask.OP_REMOVE;
1259         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1260                 user));
1261     }
1262 
1263     @Override
1264     public void onPackageAdded(String packageName, UserHandleCompat user) {
1265         int op = PackageUpdatedTask.OP_ADD;
1266         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1267                 user));
1268     }
1269 
1270     @Override
1271     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1272             boolean replacing) {
1273         if (!replacing) {
1274             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1275                     user));
1276             if (mAppsCanBeOnRemoveableStorage) {
1277                 // Only rebind if we support removable storage. It catches the
1278                 // case where
1279                 // apps on the external sd card need to be reloaded
1280                 startLoaderFromBackground();
1281             }
1282         } else {
1283             // If we are replacing then just update the packages in the list
1284             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1285                     packageNames, user));
1286         }
1287     }
1288 
1289     @Override
1290     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1291             boolean replacing) {
1292         if (!replacing) {
1293             enqueuePackageUpdated(new PackageUpdatedTask(
1294                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1295                     user));
1296         }
1297 
1298     }
1299 
1300     /**
1301      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1302      * ACTION_PACKAGE_CHANGED.
1303      */
1304     @Override
1305     public void onReceive(Context context, Intent intent) {
1306         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1307 
1308         final String action = intent.getAction();
1309         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1310             // If we have changed locale we need to clear out the labels in all apps/workspace.
1311             forceReload();
1312         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1313              // Check if configuration change was an mcc/mnc change which would affect app resources
1314              // and we would need to clear out the labels in all apps/workspace. Same handling as
1315              // above for ACTION_LOCALE_CHANGED
1316              Configuration currentConfig = context.getResources().getConfiguration();
1317              if (mPreviousConfigMcc != currentConfig.mcc) {
1318                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1319                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1320                    forceReload();
1321              }
1322              // Update previousConfig
1323              mPreviousConfigMcc = currentConfig.mcc;
1324         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1325                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1326             if (mCallbacks != null) {
1327                 Callbacks callbacks = mCallbacks.get();
1328                 if (callbacks != null) {
1329                     callbacks.bindSearchablesChanged();
1330                 }
1331             }
1332         }
1333     }
1334 
1335     void forceReload() {
1336         resetLoadedState(true, true);
1337 
1338         // Do this here because if the launcher activity is running it will be restarted.
1339         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1340         // to reload.
1341         startLoaderFromBackground();
1342     }
1343 
1344     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1345         synchronized (mLock) {
1346             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1347             // mWorkspaceLoaded to true later
1348             stopLoaderLocked();
1349             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1350             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1351         }
1352     }
1353 
1354     /**
1355      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1356      * configuration changes.  So whenever we trigger the loader from the background
1357      * tell the launcher that it needs to re-run the loader when it comes back instead
1358      * of doing it now.
1359      */
1360     public void startLoaderFromBackground() {
1361         boolean runLoader = false;
1362         if (mCallbacks != null) {
1363             Callbacks callbacks = mCallbacks.get();
1364             if (callbacks != null) {
1365                 // Only actually run the loader if they&#x27;re not paused.
1366                 if (!callbacks.setLoadOnResume()) {
1367                     runLoader = true;
1368                 }
1369             }
1370         }
1371         if (runLoader) {
1372             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1373         }
1374     }
1375 
1376     // If there is already a loader task running, tell it to stop.
1377     // returns true if isLaunching() was true on the old task
1378     private boolean stopLoaderLocked() {
1379         boolean isLaunching = false;
1380         LoaderTask oldTask = mLoaderTask;
1381         if (oldTask != null) {
1382             if (oldTask.isLaunching()) {
1383                 isLaunching = true;
1384             }
1385             oldTask.stopLocked();
1386         }
1387         return isLaunching;
1388     }
1389 
1390     public boolean isCurrentCallbacks(Callbacks callbacks) {
1391         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1392     }
1393 
1394     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1395         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1396     }
1397 
1398     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1399         synchronized (mLock) {
1400             if (DEBUG_LOADERS) {
1401                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1402             }
1403 
1404             // Clear any deferred bind-runnables from the synchronized load process
1405             // We must do this before any loading/binding is scheduled below.
1406             synchronized (mDeferredBindRunnables) {
1407                 mDeferredBindRunnables.clear();
1408             }
1409 
1410             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1411             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1412                 // If there is already one running, tell it to stop.
1413                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1414                 isLaunching = isLaunching || stopLoaderLocked();
1415                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1416                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1417                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1418                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1419                 } else {
1420                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1421                     sWorker.post(mLoaderTask);
1422                 }
1423             }
1424         }
1425     }
1426 
1427     void bindRemainingSynchronousPages() {
1428         // Post the remaining side pages to be loaded
1429         if (!mDeferredBindRunnables.isEmpty()) {
1430             Runnable[] deferredBindRunnables = null;
1431             synchronized (mDeferredBindRunnables) {
1432                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1433                         new Runnable[mDeferredBindRunnables.size()]);
1434                 mDeferredBindRunnables.clear();
1435             }
1436             for (final Runnable r : deferredBindRunnables) {
1437                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1438             }
1439         }
1440     }
1441 
1442     public void stopLoader() {
1443         synchronized (mLock) {
1444             if (mLoaderTask != null) {
1445                 mLoaderTask.stopLocked();
1446             }
1447         }
1448     }
1449 
1450     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1451     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1452         final ContentResolver contentResolver = context.getContentResolver();
1453         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1454         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1455         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1456 
1457         try {
1458             final int idIndex = sc.getColumnIndexOrThrow(
1459                     LauncherSettings.WorkspaceScreens._ID);
1460             final int rankIndex = sc.getColumnIndexOrThrow(
1461                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1462             while (sc.moveToNext()) {
1463                 try {
1464                     long screenId = sc.getLong(idIndex);
1465                     int rank = sc.getInt(rankIndex);
1466                     orderedScreens.put(rank, screenId);
1467                 } catch (Exception e) {
<abbr title="1468                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1468                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1469                 }
1470             }
1471         } finally {
1472             sc.close();
1473         }
1474 
1475         // Log to disk
1476         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1477         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1478         for (Integer i : orderedScreens.keySet()) {
1479             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1480         }
1481         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1482                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1483         return orderedScreens;
1484     }
1485 
1486     public boolean isAllAppsLoaded() {
1487         return mAllAppsLoaded;
1488     }
1489 
1490     boolean isLoadingWorkspace() {
1491         synchronized (mLock) {
1492             if (mLoaderTask != null) {
1493                 return mLoaderTask.isLoadingWorkspace();
1494             }
1495         }
1496         return false;
1497     }
1498 
1499     /**
1500      * Runnable for the thread that loads the contents of the launcher:
1501      *   - workspace icons
1502      *   - widgets
1503      *   - all apps icons
1504      */
1505     private class LoaderTask implements Runnable {
1506         private Context mContext;
1507         private boolean mIsLaunching;
1508         private boolean mIsLoadingAndBindingWorkspace;
1509         private boolean mStopped;
1510         private boolean mLoadAndBindStepFinished;
1511         private int mFlags;
1512 
1513         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1514 
1515         LoaderTask(Context context, boolean isLaunching, int flags) {
1516             mContext = context;
1517             mIsLaunching = isLaunching;
1518             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1519             mFlags = flags;
1520         }
1521 
1522         boolean isLaunching() {
1523             return mIsLaunching;
1524         }
1525 
1526         boolean isLoadingWorkspace() {
1527             return mIsLoadingAndBindingWorkspace;
1528         }
1529 
1530         /** Returns whether this is an upgrade path */
1531         private boolean loadAndBindWorkspace() {
1532             mIsLoadingAndBindingWorkspace = true;
1533 
1534             // Load the workspace
1535             if (DEBUG_LOADERS) {
1536                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1537             }
1538 
1539             boolean isUpgradePath = false;
1540             if (!mWorkspaceLoaded) {
1541                 isUpgradePath = loadWorkspace();
1542                 synchronized (LoaderTask.this) {
1543                     if (mStopped) {
1544                         return isUpgradePath;
1545                     }
1546                     mWorkspaceLoaded = true;
1547                 }
1548             }
1549 
1550             // Bind the workspace
1551             bindWorkspace(-1, isUpgradePath);
1552             return isUpgradePath;
1553         }
1554 
1555         private void waitForIdle() {
1556             // Wait until the either we&#x27;re stopped or the other threads are done.
1557             // This way we don&#x27;t start loading all apps until the workspace has settled
1558             // down.
1559             synchronized (LoaderTask.this) {
1560                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1561 
1562                 mHandler.postIdle(new Runnable() {
1563                         public void run() {
1564                             synchronized (LoaderTask.this) {
1565                                 mLoadAndBindStepFinished = true;
1566                                 if (DEBUG_LOADERS) {
1567                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1568                                 }
1569                                 LoaderTask.this.notify();
1570                             }
1571                         }
1572                     });
1573 
1574                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1575                     try {
1576                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1577                         // wait no longer than 1sec at a time
1578                         this.wait(1000);
1579                     } catch (InterruptedException ex) {
1580                         // Ignore
1581                     }
1582                 }
1583                 if (DEBUG_LOADERS) {
1584                     Log.d(TAG, &quot;waited &quot;
1585                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1586                             + &quot;ms for previous step to finish binding&quot;);
1587                 }
1588             }
1589         }
1590 
1591         void runBindSynchronousPage(int synchronousBindPage) {
1592             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1593                 // Ensure that we have a valid page index to load synchronously
1594                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1595                         &quot;valid page index&quot;);
1596             }
1597             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1598                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1599                 // loaded already (we should load everything asynchronously in that case)
1600                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1601             }
1602             synchronized (mLock) {
1603                 if (mIsLoaderTaskRunning) {
1604                     // Ensure that we are never running the background loading at this point since
1605                     // we also touch the background collections
1606                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1607                 }
1608             }
1609 
1610             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1611             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1612             //      this call is synchronous, we can get away with not locking).
1613 
1614             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1615             // operations from the previous activity.  We need to ensure that all queued operations
1616             // are executed before any synchronous binding work is done.
1617             mHandler.flush();
1618 
1619             // Divide the set of loaded items into those that we are binding synchronously, and
1620             // everything else that is to be bound normally (asynchronously).
1621             bindWorkspace(synchronousBindPage, false);
1622             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1623             //      arise from that.
1624             onlyBindAllApps();
1625         }
1626 
1627         public void run() {
1628             boolean isUpgrade = false;
1629 
1630             synchronized (mLock) {
1631                 mIsLoaderTaskRunning = true;
1632             }
1633             // Optimize for end-user experience: if the Launcher is up and // running with the
1634             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1635             // workspace first (default).
1636             keep_running: {
1637                 // Elevate priority when Home launches for the first time to avoid
1638                 // starving at boot time. Staring at a blank home is not cool.
1639                 synchronized (mLock) {
1640                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1641                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1642                     android.os.Process.setThreadPriority(mIsLaunching
1643                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1644                 }
1645                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1646                 isUpgrade = loadAndBindWorkspace();
1647 
1648                 if (mStopped) {
1649                     break keep_running;
1650                 }
1651 
1652                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1653                 // settled down.
1654                 synchronized (mLock) {
1655                     if (mIsLaunching) {
1656                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1657                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1658                     }
1659                 }
1660                 waitForIdle();
1661 
1662                 // second step
1663                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1664                 loadAndBindAllApps();
1665 
1666                 // Restore the default thread priority after we are done loading items
1667                 synchronized (mLock) {
1668                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1669                 }
1670             }
1671 
1672             // Update the saved icons if necessary
1673             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1674             synchronized (sBgLock) {
1675                 for (Object key : sBgDbIconCache.keySet()) {
1676                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1677                 }
1678                 sBgDbIconCache.clear();
1679             }
1680 
1681             if (LauncherAppState.isDisableAllApps()) {
1682                 // Ensure that all the applications that are in the system are
1683                 // represented on the home screen.
1684                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1685                     verifyApplications();
1686                 }
1687             }
1688 
1689             // Clear out this reference, otherwise we end up holding it until all of the
1690             // callback runnables are done.
1691             mContext = null;
1692 
1693             synchronized (mLock) {
1694                 // If we are still the last one to be scheduled, remove ourselves.
1695                 if (mLoaderTask == this) {
1696                     mLoaderTask = null;
1697                 }
1698                 mIsLoaderTaskRunning = false;
1699             }
1700         }
1701 
1702         public void stopLocked() {
1703             synchronized (LoaderTask.this) {
1704                 mStopped = true;
1705                 this.notify();
1706             }
1707         }
1708 
1709         /**
1710          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1711          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1712          * object that was around when the deferred message was scheduled, and if there&#x27;s
1713          * a new Callbacks object around then also return null.  This will save us from
1714          * calling onto it with data that will be ignored.
1715          */
1716         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1717             synchronized (mLock) {
1718                 if (mStopped) {
1719                     return null;
1720                 }
1721 
1722                 if (mCallbacks == null) {
1723                     return null;
1724                 }
1725 
1726                 final Callbacks callbacks = mCallbacks.get();
1727                 if (callbacks != oldCallbacks) {
1728                     return null;
1729                 }
1730                 if (callbacks == null) {
1731                     Log.w(TAG, &quot;no mCallbacks&quot;);
1732                     return null;
1733                 }
1734 
1735                 return callbacks;
1736             }
1737         }
1738 
1739         private void verifyApplications() {
1740             final Context context = mApp.getContext();
1741 
1742             // Cross reference all the applications in our apps list with items in the workspace
1743             ArrayList&lt;ItemInfo&gt; tmpInfos;
1744             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1745             synchronized (sBgLock) {
1746                 for (AppInfo app : mBgAllAppsList.data) {
1747                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1748                     if (tmpInfos.isEmpty()) {
1749                         // We are missing an application icon, so add this to the workspace
1750                         added.add(app);
1751                         // This is a rare event, so lets log it
1752                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1753                     }
1754                 }
1755             }
1756             if (!added.isEmpty()) {
1757                 addAndBindAddedWorkspaceApps(context, added);
1758             }
1759         }
1760 
1761         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1762         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1763                                            AtomicBoolean deleteOnInvalidPlacement) {
1764             LauncherAppState app = LauncherAppState.getInstance();
1765             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1766             final int countX = (int) grid.numColumns;
1767             final int countY = (int) grid.numRows;
1768 
1769             long containerIndex = item.screenId;
1770             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1771                 // Return early if we detect that an item is under the hotseat button
1772                 if (mCallbacks == null ||
1773                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1774                     deleteOnInvalidPlacement.set(true);
1775                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1776                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1777                             + item.cellY + &quot;) occupied by all apps&quot;);
1778                     return false;
1779                 }
1780 
1781                 final ItemInfo[][] hotseatItems =
1782                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1783 
1784                 if (item.screenId &gt;= grid.numHotseatIcons) {
1785                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1786                             + &quot; into hotseat position &quot; + item.screenId
1787                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1788                             + &quot;)&quot;);
1789                     return false;
1790                 }
1791 
1792                 if (hotseatItems != null) {
1793                     if (hotseatItems[(int) item.screenId][0] != null) {
1794                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1795                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1796                                 + item.cellY + &quot;) occupied by &quot;
1797                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1798                                 [(int) item.screenId][0]);
1799                             return false;
1800                     } else {
1801                         hotseatItems[(int) item.screenId][0] = item;
1802                         return true;
1803                     }
1804                 } else {
1805                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1806                     items[(int) item.screenId][0] = item;
1807                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1808                     return true;
1809                 }
1810             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1811                 // Skip further checking if it is not the hotseat or workspace container
1812                 return true;
1813             }
1814 
1815             if (!occupied.containsKey(item.screenId)) {
1816                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1817                 occupied.put(item.screenId, items);
1818             }
1819 
1820             final ItemInfo[][] screens = occupied.get(item.screenId);
1821             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1822                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1823                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1824                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1825                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1826                         + item.cellX + &quot;,&quot; + item.cellY
1827                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1828                 return false;
1829             }
1830 
1831             // Check if any workspace icons overlap with each other
1832             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1833                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1834                     if (screens[x][y] != null) {
1835                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1836                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1837                             + x + &quot;,&quot; + y
1838                             + &quot;) occupied by &quot;
1839                             + screens[x][y]);
1840                         return false;
1841                     }
1842                 }
1843             }
1844             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1845                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1846                     screens[x][y] = item;
1847                 }
1848             }
1849 
1850             return true;
1851         }
1852 
1853         /** Clears all the sBg data structures */
1854         private void clearSBgDataStructures() {
1855             synchronized (sBgLock) {
1856                 sBgWorkspaceItems.clear();
1857                 sBgAppWidgets.clear();
1858                 sBgFolders.clear();
1859                 sBgItemsIdMap.clear();
1860                 sBgDbIconCache.clear();
1861                 sBgWorkspaceScreens.clear();
1862             }
1863         }
1864 
1865         /** Returns whether this is an upgrade path */
1866         private boolean loadWorkspace() {
1867             // Log to disk
1868             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1869 
1870             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1871 
1872             final Context context = mContext;
1873             final ContentResolver contentResolver = context.getContentResolver();
1874             final PackageManager manager = context.getPackageManager();
1875             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1876             final boolean isSafeMode = manager.isSafeMode();
1877             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1878             final boolean isSdCardReady = context.registerReceiver(null,
1879                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1880 
1881             LauncherAppState app = LauncherAppState.getInstance();
1882             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1883             int countX = (int) grid.numColumns;
1884             int countY = (int) grid.numRows;
1885 
1886             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1887                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1888                 LauncherAppState.getLauncherProvider().deleteDatabase();
1889             }
1890 
1891             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1892                 // append the user&#x27;s Launcher2 shortcuts
1893                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1894                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1895             } else {
1896                 // Make sure the default workspace is loaded
1897                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1898                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1899             }
1900 
1901             // This code path is for our old migration code and should no longer be exercised
1902             boolean loadedOldDb = false;
1903 
1904             // Log to disk
1905             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1906 
1907             synchronized (sBgLock) {
1908                 clearSBgDataStructures();
1909                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1910                         .getInstance(mContext).updateAndGetActiveSessionCache();
1911 
1912                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1913                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1914                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1915                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1916                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1917 
1918                 // +1 for the hotseat (it can be larger than the workspace)
1919                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1920                 // before any earlier duplicates)
1921                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1922 
1923                 try {
1924                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1925                     final int intentIndex = c.getColumnIndexOrThrow
1926                             (LauncherSettings.Favorites.INTENT);
1927                     final int titleIndex = c.getColumnIndexOrThrow
1928                             (LauncherSettings.Favorites.TITLE);
1929                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1930                             LauncherSettings.Favorites.ICON_TYPE);
1931                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1932                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1933                             LauncherSettings.Favorites.ICON_PACKAGE);
1934                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1935                             LauncherSettings.Favorites.ICON_RESOURCE);
1936                     final int containerIndex = c.getColumnIndexOrThrow(
1937                             LauncherSettings.Favorites.CONTAINER);
1938                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1939                             LauncherSettings.Favorites.ITEM_TYPE);
1940                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1941                             LauncherSettings.Favorites.APPWIDGET_ID);
1942                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1943                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1944                     final int screenIndex = c.getColumnIndexOrThrow(
1945                             LauncherSettings.Favorites.SCREEN);
1946                     final int cellXIndex = c.getColumnIndexOrThrow
1947                             (LauncherSettings.Favorites.CELLX);
1948                     final int cellYIndex = c.getColumnIndexOrThrow
1949                             (LauncherSettings.Favorites.CELLY);
1950                     final int spanXIndex = c.getColumnIndexOrThrow
1951                             (LauncherSettings.Favorites.SPANX);
1952                     final int spanYIndex = c.getColumnIndexOrThrow(
1953                             LauncherSettings.Favorites.SPANY);
1954                     final int restoredIndex = c.getColumnIndexOrThrow(
1955                             LauncherSettings.Favorites.RESTORED);
1956                     final int profileIdIndex = c.getColumnIndexOrThrow(
1957                             LauncherSettings.Favorites.PROFILE_ID);
1958                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1959                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1960                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1961 
1962                     ShortcutInfo info;
1963                     String intentDescription;
1964                     LauncherAppWidgetInfo appWidgetInfo;
1965                     int container;
1966                     long id;
1967                     Intent intent;
1968                     UserHandleCompat user;
1969 
1970                     while (!mStopped &amp;&amp; c.moveToNext()) {
1971                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1972                         try {
1973                             int itemType = c.getInt(itemTypeIndex);
1974                             boolean restored = 0 != c.getInt(restoredIndex);
1975                             boolean allowMissingTarget = false;
1976 
1977                             switch (itemType) {
1978                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1979                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1980                                 id = c.getLong(idIndex);
1981                                 intentDescription = c.getString(intentIndex);
1982                                 long serialNumber = c.getInt(profileIdIndex);
1983                                 user = mUserManager.getUserForSerialNumber(serialNumber);
1984                                 int promiseType = c.getInt(restoredIndex);
1985                                 int disabledState = 0;
1986                                 if (user == null) {
1987                                     // User has been deleted remove the item.
1988                                     itemsToRemove.add(id);
1989                                     continue;
1990                                 }
1991                                 try {
1992                                     intent = Intent.parseUri(intentDescription, 0);
1993                                     ComponentName cn = intent.getComponent();
1994                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
1995                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
1996                                                 cn.getPackageName(), user);
1997                                         boolean validComponent = validPkg &amp;&amp;
1998                                                 launcherApps.isActivityEnabledForProfile(cn, user);
1999 
2000                                         if (validComponent) {
2001                                             if (restored) {
2002                                                 // no special handling necessary for this item
2003                                                 restoredRows.add(id);
2004                                                 restored = false;
2005                                             }
2006                                         } else if (validPkg) {
2007                                             intent = null;
2008                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2009                                                 // We allow auto install apps to have their intent
2010                                                 // updated after an install.
2011                                                 intent = manager.getLaunchIntentForPackage(
2012                                                         cn.getPackageName());
2013                                                 if (intent != null) {
2014                                                     ContentValues values = new ContentValues();
2015                                                     values.put(LauncherSettings.Favorites.INTENT,
2016                                                             intent.toUri(0));
2017                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2018                                                     String[] args = {Long.toString(id)};
<abbr title="2019                                                     contentResolver.update(contentUri, values, where, args);">2019                                                     contentResolver.update(contentUri, values, where, argðŸ”µ</abbr>
2020                                                 }
2021                                             }
2022 
2023                                             if (intent == null) {
2024                                                 // The app is installed but the component is no
2025                                                 // longer available.
2026                                                 Launcher.addDumpLog(TAG,
2027                                                         &quot;Invalid component removed: &quot; + cn, true);
2028                                                 itemsToRemove.add(id);
2029                                                 continue;
2030                                             } else {
2031                                                 // no special handling necessary for this item
2032                                                 restoredRows.add(id);
2033                                                 restored = false;
2034                                             }
2035                                         } else if (restored) {
2036                                             // Package is not yet available but might be
2037                                             // installed later.
2038                                             Launcher.addDumpLog(TAG,
2039                                                     &quot;package not yet restored: &quot; + cn, true);
2040 
2041                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2042                                                 // Restore has started once.
2043                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2044                                                 // App restore has started. Update the flag
2045                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2046                                                 ContentValues values = new ContentValues();
2047                                                 values.put(LauncherSettings.Favorites.RESTORED,
2048                                                         promiseType);
2049                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2050                                                 String[] args = {Long.toString(id)};
2051                                                 contentResolver.update(contentUri, values, where, args);
2052 
2053                                             } else if (REMOVE_UNRESTORED_ICONS) {
2054                                                 Launcher.addDumpLog(TAG,
2055                                                         &quot;Unrestored package removed: &quot; + cn, true);
2056                                                 itemsToRemove.add(id);
2057                                                 continue;
2058                                             }
2059                                         } else if (launcherApps.isAppEnabled(
2060                                                 manager, cn.getPackageName(),
2061                                                 PackageManager.GET_UNINSTALLED_PACKAGES)) {
2062                                             // Package is present but not available.
2063                                             allowMissingTarget = true;
2064                                             disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2065                                         } else if (!isSdCardReady) {
2066                                             // SdCard is not ready yet. Package might get available,
2067                                             // once it is ready.
2068                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2069                                                     + &quot; (check again later)&quot;, true);
2070                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2071                                             if (pkgs == null) {
2072                                                 pkgs = new HashSet&lt;String&gt;();
2073                                                 sPendingPackages.put(user, pkgs);
2074                                             }
2075                                             pkgs.add(cn.getPackageName());
2076                                             allowMissingTarget = true;
2077                                             // Add the icon on the workspace anyway.
2078 
2079                                         } else {
2080                                             // Do not wait for external media load anymore.
2081                                             // Log the invalid package, and remove it
2082                                             Launcher.addDumpLog(TAG,
2083                                                     &quot;Invalid package removed: &quot; + cn, true);
2084                                             itemsToRemove.add(id);
2085                                             continue;
2086                                         }
2087                                     } else if (cn == null) {
2088                                         // For shortcuts with no component, keep them as they are
2089                                         restoredRows.add(id);
2090                                         restored = false;
2091                                     }
2092                                 } catch (URISyntaxException e) {
2093                                     Launcher.addDumpLog(TAG,
2094                                             &quot;Invalid uri: &quot; + intentDescription, true);
2095                                     continue;
2096                                 }
2097 
2098                                 if (restored) {
2099                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2100                                         Launcher.addDumpLog(TAG,
2101                                                 &quot;constructing info for partially restored package&quot;,
2102                                                 true);
2103                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2104                                         intent = getRestoredItemIntent(c, context, intent);
2105                                     } else {
2106                                         // Don&#x27;t restore items for other profiles.
2107                                         itemsToRemove.add(id);
2108                                         continue;
2109                                     }
2110                                 } else if (itemType ==
2111                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2112                                     info = getShortcutInfo(manager, intent, user, context, c,
2113                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2114                                 } else {
2115                                     info = getShortcutInfo(c, context, iconTypeIndex,
2116                                             iconPackageIndex, iconResourceIndex, iconIndex,
2117                                             titleIndex);
2118 
2119                                     // App shortcuts that used to be automatically added to Launcher
2120                                     // didn&#x27;t always have the correct intent flags set, so do that
2121                                     // here
2122                                     if (intent.getAction() != null &amp;&amp;
2123                                         intent.getCategories() != null &amp;&amp;
2124                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2125                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2126                                         intent.addFlags(
2127                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2128                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2129                                     }
2130                                 }
2131 
2132                                 if (info != null) {
2133                                     info.id = id;
2134                                     info.intent = intent;
2135                                     container = c.getInt(containerIndex);
2136                                     info.container = container;
2137                                     info.screenId = c.getInt(screenIndex);
2138                                     info.cellX = c.getInt(cellXIndex);
2139                                     info.cellY = c.getInt(cellYIndex);
2140                                     info.spanX = 1;
2141                                     info.spanY = 1;
2142                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2143                                     info.isDisabled = disabledState;
2144                                     if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2145                                         info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2146                                     }
2147 
2148                                     // check &amp; update map of what&#x27;s occupied
2149                                     deleteOnInvalidPlacement.set(false);
2150                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2151                                         if (deleteOnInvalidPlacement.get()) {
2152                                             itemsToRemove.add(id);
2153                                         }
2154                                         break;
2155                                     }
2156 
2157                                     switch (container) {
2158                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2159                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2160                                         sBgWorkspaceItems.add(info);
2161                                         break;
2162                                     default:
2163                                         // Item is in a user folder
2164                                         FolderInfo folderInfo =
2165                                                 findOrMakeFolder(sBgFolders, container);
2166                                         folderInfo.add(info);
2167                                         break;
2168                                     }
2169                                     sBgItemsIdMap.put(info.id, info);
2170 
2171                                     // now that we&#x27;ve loaded everthing re-save it with the
2172                                     // icon in case it disappears somehow.
2173                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2174                                 } else {
2175                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2176                                 }
2177                                 break;
2178 
2179                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2180                                 id = c.getLong(idIndex);
2181                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2182 
2183                                 folderInfo.title = c.getString(titleIndex);
2184                                 folderInfo.id = id;
2185                                 container = c.getInt(containerIndex);
2186                                 folderInfo.container = container;
2187                                 folderInfo.screenId = c.getInt(screenIndex);
2188                                 folderInfo.cellX = c.getInt(cellXIndex);
2189                                 folderInfo.cellY = c.getInt(cellYIndex);
2190                                 folderInfo.spanX = 1;
2191                                 folderInfo.spanY = 1;
2192 
2193                                 // check &amp; update map of what&#x27;s occupied
2194                                 deleteOnInvalidPlacement.set(false);
2195                                 if (!checkItemPlacement(occupied, folderInfo,
2196                                         deleteOnInvalidPlacement)) {
2197                                     if (deleteOnInvalidPlacement.get()) {
2198                                         itemsToRemove.add(id);
2199                                     }
2200                                     break;
2201                                 }
2202 
2203                                 switch (container) {
2204                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2205                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2206                                         sBgWorkspaceItems.add(folderInfo);
2207                                         break;
2208                                 }
2209 
2210                                 if (restored) {
2211                                     // no special handling required for restored folders
2212                                     restoredRows.add(id);
2213                                 }
2214 
2215                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2216                                 sBgFolders.put(folderInfo.id, folderInfo);
2217                                 break;
2218 
2219                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2220                                 // Read all Launcher-specific widget details
2221                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2222                                 String savedProvider = c.getString(appWidgetProviderIndex);
2223                                 id = c.getLong(idIndex);
2224                                 final ComponentName component =
2225                                         ComponentName.unflattenFromString(savedProvider);
2226 
2227                                 final int restoreStatus = c.getInt(restoredIndex);
2228                                 final boolean isIdValid = (restoreStatus &amp;
2229                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2230 
2231                                 final boolean wasProviderReady = (restoreStatus &amp;
2232                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2233 
2234                                 final AppWidgetProviderInfo provider = isIdValid
2235                                         ? widgets.getAppWidgetInfo(appWidgetId)
2236                                         : findAppWidgetProviderInfoWithComponent(context, component);
2237 
2238                                 final boolean isProviderReady = isValidProvider(provider);
2239                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2240                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2241                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2242                                     Log.e(TAG, log);
2243                                     Launcher.addDumpLog(TAG, log, false);
2244                                     itemsToRemove.add(id);
2245                                 } else {
2246                                     if (isProviderReady) {
2247                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2248                                                 provider.provider);
2249                                         int[] minSpan =
2250                                                 Launcher.getMinSpanForWidget(context, provider);
2251                                         appWidgetInfo.minSpanX = minSpan[0];
2252                                         appWidgetInfo.minSpanY = minSpan[1];
2253 
2254                                         int status = restoreStatus;
2255                                         if (!wasProviderReady) {
2256                                             // If provider was not previously ready, update the
2257                                             // status and UI flag.
2258 
<abbr title="2259                                             // Id would be valid only if the widget restore broadcast was received.">2259                                             // Id would be valid only if the widget restore broadcast wasðŸ”µ</abbr>
2260                                             if (isIdValid) {
2261                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2262                                             } else {
2263                                                 status &amp;= ~LauncherAppWidgetInfo
2264                                                         .FLAG_PROVIDER_NOT_READY;
2265                                             }
2266                                         }
2267                                         appWidgetInfo.restoreStatus = status;
2268                                     } else {
2269                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2270                                                 + &quot; appWidgetId=&quot; + appWidgetId
2271                                                 + &quot; status =&quot; + restoreStatus);
2272                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2273                                                 component);
2274                                         appWidgetInfo.restoreStatus = restoreStatus;
2275 
<abbr title="2276                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2276                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) ðŸ”µ</abbr>
2277                                             // Restore has started once.
2278                                         } else if (installingPkgs.contains(component.getPackageName())) {
2279                                             // App restore has started. Update the flag
2280                                             appWidgetInfo.restoreStatus |=
2281                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2282                                         } else if (REMOVE_UNRESTORED_ICONS) {
2283                                             Launcher.addDumpLog(TAG,
2284                                                     &quot;Unrestored widget removed: &quot; + component, true);
2285                                             itemsToRemove.add(id);
2286                                             continue;
2287                                         }
2288                                     }
2289 
2290                                     appWidgetInfo.id = id;
2291                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2292                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2293                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2294                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2295                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2296 
2297                                     container = c.getInt(containerIndex);
2298                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2299                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2300                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2301                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2302                                         continue;
2303                                     }
2304 
2305                                     appWidgetInfo.container = c.getInt(containerIndex);
2306                                     // check &amp; update map of what&#x27;s occupied
2307                                     deleteOnInvalidPlacement.set(false);
2308                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2309                                             deleteOnInvalidPlacement)) {
2310                                         if (deleteOnInvalidPlacement.get()) {
2311                                             itemsToRemove.add(id);
2312                                         }
2313                                         break;
2314                                     }
2315 
2316                                     String providerName = appWidgetInfo.providerName.flattenToString();
2317                                     if (!providerName.equals(savedProvider) ||
2318                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2319                                         ContentValues values = new ContentValues();
2320                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2321                                                 providerName);
2322                                         values.put(LauncherSettings.Favorites.RESTORED,
2323                                                 appWidgetInfo.restoreStatus);
2324                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2325                                         String[] args = {Long.toString(id)};
2326                                         contentResolver.update(contentUri, values, where, args);
2327                                     }
2328                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2329                                     sBgAppWidgets.add(appWidgetInfo);
2330                                 }
2331                                 break;
2332                             }
2333                         } catch (Exception e) {
2334                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2335                         }
2336                     }
2337                 } finally {
2338                     if (c != null) {
2339                         c.close();
2340                     }
2341                 }
2342 
2343                 // Break early if we&#x27;ve stopped loading
2344                 if (mStopped) {
2345                     clearSBgDataStructures();
2346                     return false;
2347                 }
2348 
2349                 if (itemsToRemove.size() &gt; 0) {
2350                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2351                             contentUri);
2352                     // Remove dead items
2353                     for (long id : itemsToRemove) {
2354                         if (DEBUG_LOADERS) {
2355                             Log.d(TAG, &quot;Removed id = &quot; + id);
2356                         }
2357                         // Don&#x27;t notify content observers
2358                         try {
2359                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2360                                     null, null);
2361                         } catch (RemoteException e) {
2362                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2363                         }
2364                     }
2365                 }
2366 
2367                 if (restoredRows.size() &gt; 0) {
2368                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2369                             contentUri);
2370                     // Update restored items that no longer require special handling
2371                     try {
2372                         StringBuilder selectionBuilder = new StringBuilder();
2373                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2374                         selectionBuilder.append(&quot; IN (&quot;);
2375                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2376                         selectionBuilder.append(&quot;)&quot;);
2377                         ContentValues values = new ContentValues();
2378                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2379                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2380                                 values, selectionBuilder.toString(), null);
2381                     } catch (RemoteException e) {
2382                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2383                     }
2384                 }
2385 
2386                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2387                     context.registerReceiver(new AppsAvailabilityCheck(),
2388                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2389                             null, sWorker);
2390                 }
2391 
2392                 if (loadedOldDb) {
2393                     long maxScreenId = 0;
2394                     // If we&#x27;re importing we use the old screen order.
2395                     for (ItemInfo item: sBgItemsIdMap.values()) {
2396                         long screenId = item.screenId;
2397                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2398                                 !sBgWorkspaceScreens.contains(screenId)) {
2399                             sBgWorkspaceScreens.add(screenId);
2400                             if (screenId &gt; maxScreenId) {
2401                                 maxScreenId = screenId;
2402                             }
2403                         }
2404                     }
2405                     Collections.sort(sBgWorkspaceScreens);
2406                     // Log to disk
2407                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2408                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2409                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2410 
2411                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2412                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2413 
2414                     // Update the max item id after we load an old db
2415                     long maxItemId = 0;
2416                     // If we&#x27;re importing we use the old screen order.
2417                     for (ItemInfo item: sBgItemsIdMap.values()) {
2418                         maxItemId = Math.max(maxItemId, item.id);
2419                     }
2420                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2421                 } else {
2422                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2423                     for (Integer i : orderedScreens.keySet()) {
2424                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2425                     }
2426                     // Log to disk
2427                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2428                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2429 
2430                     // Remove any empty screens
2431                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2432                     for (ItemInfo item: sBgItemsIdMap.values()) {
2433                         long screenId = item.screenId;
2434                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2435                                 unusedScreens.contains(screenId)) {
2436                             unusedScreens.remove(screenId);
2437                         }
2438                     }
2439 
2440                     // If there are any empty screens remove them, and update.
2441                     if (unusedScreens.size() != 0) {
2442                         // Log to disk
2443                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2444                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2445 
2446                         sBgWorkspaceScreens.removeAll(unusedScreens);
2447                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2448                     }
2449                 }
2450 
2451                 if (DEBUG_LOADERS) {
2452                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2453                     Log.d(TAG, &quot;workspace layout: &quot;);
2454                     int nScreens = occupied.size();
2455                     for (int y = 0; y &lt; countY; y++) {
2456                         String line = &quot;&quot;;
2457 
2458                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2459                         while (iter.hasNext()) {
2460                             long screenId = iter.next();
2461                             if (screenId &gt; 0) {
2462                                 line += &quot; | &quot;;
2463                             }
2464                             for (int x = 0; x &lt; countX; x++) {
2465                                 ItemInfo[][] screen = occupied.get(screenId);
2466                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2467                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2468                                 } else {
2469                                     line += &quot;!&quot;;
2470                                 }
2471                             }
2472                         }
2473                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2474                     }
2475                 }
2476             }
2477             return loadedOldDb;
2478         }
2479 
2480         /** Filters the set of items who are directly or indirectly (via another container) on the
2481          * specified screen. */
2482         private void filterCurrentWorkspaceItems(long currentScreenId,
2483                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2484                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2485                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2486             // Purge any null ItemInfos
2487             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2488             while (iter.hasNext()) {
2489                 ItemInfo i = iter.next();
2490                 if (i == null) {
2491                     iter.remove();
2492                 }
2493             }
2494 
2495             // Order the set of items by their containers first, this allows use to walk through the
2496             // list sequentially, build up a list of containers that are in the specified screen,
2497             // as well as all items in those containers.
2498             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2499             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2500                 @Override
2501                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2502                     return (int) (lhs.container - rhs.container);
2503                 }
2504             });
2505             for (ItemInfo info : allWorkspaceItems) {
2506                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2507                     if (info.screenId == currentScreenId) {
2508                         currentScreenItems.add(info);
2509                         itemsOnScreen.add(info.id);
2510                     } else {
2511                         otherScreenItems.add(info);
2512                     }
2513                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2514                     currentScreenItems.add(info);
2515                     itemsOnScreen.add(info.id);
2516                 } else {
2517                     if (itemsOnScreen.contains(info.container)) {
2518                         currentScreenItems.add(info);
2519                         itemsOnScreen.add(info.id);
2520                     } else {
2521                         otherScreenItems.add(info);
2522                     }
2523                 }
2524             }
2525         }
2526 
2527         /** Filters the set of widgets which are on the specified screen. */
2528         private void filterCurrentAppWidgets(long currentScreenId,
2529                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2530                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2531                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2532 
2533             for (LauncherAppWidgetInfo widget : appWidgets) {
2534                 if (widget == null) continue;
2535                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2536                         widget.screenId == currentScreenId) {
2537                     currentScreenWidgets.add(widget);
2538                 } else {
2539                     otherScreenWidgets.add(widget);
2540                 }
2541             }
2542         }
2543 
2544         /** Filters the set of folders which are on the specified screen. */
2545         private void filterCurrentFolders(long currentScreenId,
2546                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2547                 HashMap&lt;Long, FolderInfo&gt; folders,
2548                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2549                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2550 
2551             for (long id : folders.keySet()) {
2552                 ItemInfo info = itemsIdMap.get(id);
2553                 FolderInfo folder = folders.get(id);
2554                 if (info == null || folder == null) continue;
2555                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2556                         info.screenId == currentScreenId) {
2557                     currentScreenFolders.put(id, folder);
2558                 } else {
2559                     otherScreenFolders.put(id, folder);
2560                 }
2561             }
2562         }
2563 
2564         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2565          * right) */
2566         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2567             final LauncherAppState app = LauncherAppState.getInstance();
2568             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2569             // XXX: review this
2570             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2571                 @Override
2572                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2573                     int cellCountX = (int) grid.numColumns;
2574                     int cellCountY = (int) grid.numRows;
2575                     int screenOffset = cellCountX * cellCountY;
2576                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2577                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2578                             lhs.cellY * cellCountX + lhs.cellX);
2579                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2580                             rhs.cellY * cellCountX + rhs.cellX);
2581                     return (int) (lr - rr);
2582                 }
2583             });
2584         }
2585 
2586         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2587                 final ArrayList&lt;Long&gt; orderedScreens) {
2588             final Runnable r = new Runnable() {
2589                 @Override
2590                 public void run() {
2591                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2592                     if (callbacks != null) {
2593                         callbacks.bindScreens(orderedScreens);
2594                     }
2595                 }
2596             };
2597             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2598         }
2599 
2600         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2601                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2602                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2603                 final HashMap&lt;Long, FolderInfo&gt; folders,
2604                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2605 
2606             final boolean postOnMainThread = (deferredBindRunnables != null);
2607 
2608             // Bind the workspace items
2609             int N = workspaceItems.size();
2610             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2611                 final int start = i;
2612                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2613                 final Runnable r = new Runnable() {
2614                     @Override
2615                     public void run() {
2616                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2617                         if (callbacks != null) {
2618                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2619                                     false);
2620                         }
2621                     }
2622                 };
2623                 if (postOnMainThread) {
2624                     synchronized (deferredBindRunnables) {
2625                         deferredBindRunnables.add(r);
2626                     }
2627                 } else {
2628                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2629                 }
2630             }
2631 
2632             // Bind the folders
2633             if (!folders.isEmpty()) {
2634                 final Runnable r = new Runnable() {
2635                     public void run() {
2636                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2637                         if (callbacks != null) {
2638                             callbacks.bindFolders(folders);
2639                         }
2640                     }
2641                 };
2642                 if (postOnMainThread) {
2643                     synchronized (deferredBindRunnables) {
2644                         deferredBindRunnables.add(r);
2645                     }
2646                 } else {
2647                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2648                 }
2649             }
2650 
2651             // Bind the widgets, one at a time
2652             N = appWidgets.size();
2653             for (int i = 0; i &lt; N; i++) {
2654                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2655                 final Runnable r = new Runnable() {
2656                     public void run() {
2657                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2658                         if (callbacks != null) {
2659                             callbacks.bindAppWidget(widget);
2660                         }
2661                     }
2662                 };
2663                 if (postOnMainThread) {
2664                     deferredBindRunnables.add(r);
2665                 } else {
2666                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2667                 }
2668             }
2669         }
2670 
2671         /**
2672          * Binds all loaded data to actual views on the main thread.
2673          */
2674         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2675             final long t = SystemClock.uptimeMillis();
2676             Runnable r;
2677 
2678             // Don&#x27;t use these two variables in any of the callback runnables.
2679             // Otherwise we hold a reference to them.
2680             final Callbacks oldCallbacks = mCallbacks.get();
2681             if (oldCallbacks == null) {
2682                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2683                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2684                 return;
2685             }
2686 
2687             // Save a copy of all the bg-thread collections
2688             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2689             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2690                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2691             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2692             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2693             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2694             synchronized (sBgLock) {
2695                 workspaceItems.addAll(sBgWorkspaceItems);
2696                 appWidgets.addAll(sBgAppWidgets);
2697                 folders.putAll(sBgFolders);
2698                 itemsIdMap.putAll(sBgItemsIdMap);
2699                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2700             }
2701 
2702             final boolean isLoadingSynchronously =
2703                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2704             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2705                 oldCallbacks.getCurrentWorkspaceScreen();
2706             if (currScreen &gt;= orderedScreenIds.size()) {
2707                 // There may be no workspace screens (just hotseat items and an empty page).
2708                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2709             }
2710             final int currentScreen = currScreen;
2711             final long currentScreenId = currentScreen &lt; 0
2712                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2713 
2714             // Load all the items that are on the current page first (and in the process, unbind
2715             // all the existing workspace items before we call startBinding() below.
2716             unbindWorkspaceItemsOnMainThread();
2717 
2718             // Separate the items that are on the current screen, and all the other remaining items
2719             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2720             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2721             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2722                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2723             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2724                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2725             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2726             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2727 
2728             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2729                     otherWorkspaceItems);
2730             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2731                     otherAppWidgets);
2732             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2733                     otherFolders);
2734             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2735             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2736 
2737             // Tell the workspace that we&#x27;re about to start binding items
2738             r = new Runnable() {
2739                 public void run() {
2740                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2741                     if (callbacks != null) {
2742                         callbacks.startBinding();
2743                     }
2744                 }
2745             };
2746             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2747 
2748             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2749 
2750             // Load items on the current page
2751             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2752                     currentFolders, null);
2753             if (isLoadingSynchronously) {
2754                 r = new Runnable() {
2755                     public void run() {
2756                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2757                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2758                             callbacks.onPageBoundSynchronously(currentScreen);
2759                         }
2760                     }
2761                 };
2762                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2763             }
2764 
2765             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2766             // work until after the first render)
2767             synchronized (mDeferredBindRunnables) {
2768                 mDeferredBindRunnables.clear();
2769             }
2770             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2771                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2772 
2773             // Tell the workspace that we&#x27;re done binding items
2774             r = new Runnable() {
2775                 public void run() {
2776                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2777                     if (callbacks != null) {
2778                         callbacks.finishBindingItems(isUpgradePath);
2779                     }
2780 
2781                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2782                     if (DEBUG_LOADERS) {
2783                         Log.d(TAG, &quot;bound workspace in &quot;
2784                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2785                     }
2786 
2787                     mIsLoadingAndBindingWorkspace = false;
2788                 }
2789             };
2790             if (isLoadingSynchronously) {
2791                 synchronized (mDeferredBindRunnables) {
2792                     mDeferredBindRunnables.add(r);
2793                 }
2794             } else {
2795                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2796             }
2797         }
2798 
2799         private void loadAndBindAllApps() {
2800             if (DEBUG_LOADERS) {
2801                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2802             }
2803             if (!mAllAppsLoaded) {
2804                 loadAllApps();
2805                 synchronized (LoaderTask.this) {
2806                     if (mStopped) {
2807                         return;
2808                     }
2809                     mAllAppsLoaded = true;
2810                 }
2811             } else {
2812                 onlyBindAllApps();
2813             }
2814         }
2815 
2816         private void onlyBindAllApps() {
2817             final Callbacks oldCallbacks = mCallbacks.get();
2818             if (oldCallbacks == null) {
2819                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2820                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2821                 return;
2822             }
2823 
2824             // shallow copy
2825             @SuppressWarnings(&quot;unchecked&quot;)
2826             final ArrayList&lt;AppInfo&gt; list
2827                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2828             Runnable r = new Runnable() {
2829                 public void run() {
2830                     final long t = SystemClock.uptimeMillis();
2831                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2832                     if (callbacks != null) {
2833                         callbacks.bindAllApplications(list);
2834                     }
2835                     if (DEBUG_LOADERS) {
2836                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2837                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2838                     }
2839                 }
2840             };
2841             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2842             if (isRunningOnMainThread) {
2843                 r.run();
2844             } else {
2845                 mHandler.post(r);
2846             }
2847         }
2848 
2849         private void loadAllApps() {
2850             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2851 
2852             final Callbacks oldCallbacks = mCallbacks.get();
2853             if (oldCallbacks == null) {
2854                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2855                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2856                 return;
2857             }
2858 
2859             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2860             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2861 
2862             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2863 
2864             // Clear the list of apps
2865             mBgAllAppsList.clear();
2866             for (UserHandleCompat user : profiles) {
2867                 // Query for the set of apps
2868                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2869                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2870                 if (DEBUG_LOADERS) {
2871                     Log.d(TAG, &quot;getActivityList took &quot;
2872                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2873                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2874                 }
2875                 // Fail if we don&#x27;t have any apps
2876                 if (apps == null || apps.isEmpty()) {
2877                     return;
2878                 }
2879                 // Sort the applications by name
2880                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2881                 Collections.sort(apps,
2882                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2883                 if (DEBUG_LOADERS) {
2884                     Log.d(TAG, &quot;sort took &quot;
2885                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2886                 }
2887 
2888                 // Create the ApplicationInfos
2889                 for (int i = 0; i &lt; apps.size(); i++) {
2890                     LauncherActivityInfoCompat app = apps.get(i);
2891                     // This builds the icon bitmaps.
2892                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2893                 }
2894             }
2895             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2896             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2897             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2898 
2899             // Post callback on main thread
2900             mHandler.post(new Runnable() {
2901                 public void run() {
2902                     final long bindTime = SystemClock.uptimeMillis();
2903                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2904                     if (callbacks != null) {
2905                         callbacks.bindAllApplications(added);
2906                         if (DEBUG_LOADERS) {
2907                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2908                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2909                         }
2910                     } else {
2911                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2912                     }
2913                 }
2914             });
2915 
2916             if (DEBUG_LOADERS) {
2917                 Log.d(TAG, &quot;Icons processed in &quot;
2918                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2919             }
2920         }
2921 
2922         public void dumpState() {
2923             synchronized (sBgLock) {
2924                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2925                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2926                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2927                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2928                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2929             }
2930         }
2931     }
2932 
2933     void enqueuePackageUpdated(PackageUpdatedTask task) {
2934         sWorker.post(task);
2935     }
2936 
2937     private class AppsAvailabilityCheck extends BroadcastReceiver {
2938 
2939         @Override
2940         public void onReceive(Context context, Intent intent) {
2941             synchronized (sBgLock) {
2942                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2943                         .getInstance(mApp.getContext());
2944                 final PackageManager manager = context.getPackageManager();
2945                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2946                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2947                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2948                     UserHandleCompat user = entry.getKey();
2949                     packagesRemoved.clear();
2950                     packagesUnavailable.clear();
2951                     for (String pkg : entry.getValue()) {
2952                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2953                             boolean packageOnSdcard = launcherApps.isAppEnabled(
2954                                     manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
2955                             if (packageOnSdcard) {
2956                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2957                                 packagesUnavailable.add(pkg);
2958                             } else {
2959                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2960                             packagesRemoved.add(pkg);
2961                         }
2962                     }
2963                     }
2964                     if (!packagesRemoved.isEmpty()) {
2965                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2966                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2967                     }
2968                     if (!packagesUnavailable.isEmpty()) {
2969                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
<abbr title="2970                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">2970                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), userðŸ”µ</abbr>
2971                     }
2972                 }
2973                 sPendingPackages.clear();
2974             }
2975         }
2976     }
2977 
2978     /**
2979      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2980      * runnable was missed by the launcher.
2981      */
2982     public void recheckRestoredItems(final Context context) {
2983         Runnable r = new Runnable() {
2984 
2985             @Override
2986             public void run() {
2987                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2988                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2989                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2990                 synchronized(sBgLock) {
2991                     for (ItemInfo info : sBgItemsIdMap.values()) {
2992                         if (info instanceof ShortcutInfo) {
2993                             ShortcutInfo si = (ShortcutInfo) info;
2994                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
2995                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2996                                             si.getTargetComponent().getPackageName(), user)) {
2997                                 installedPackages.add(si.getTargetComponent().getPackageName());
2998                             }
2999                         } else if (info instanceof LauncherAppWidgetInfo) {
3000                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
3001                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3002                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3003                                             widget.providerName.getPackageName(), user)) {
3004                                 installedPackages.add(widget.providerName.getPackageName());
3005                             }
3006                         }
3007                     }
3008                 }
3009 
3010                 if (!installedPackages.isEmpty()) {
3011                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
3012                     for (String pkg : installedPackages) {
3013                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
3014                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
3015                         }
3016                     }
3017 
3018                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3019                     if (!restoredApps.isEmpty()) {
3020                         mHandler.post(new Runnable() {
3021                             public void run() {
3022                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3023                                 if (callbacks == cb &amp;&amp; cb != null) {
3024                                     callbacks.bindAppsRestored(restoredApps);
3025                                 }
3026                             }
3027                         });
3028                     }
3029 
3030                 }
3031             }
3032         };
3033         sWorker.post(r);
3034     }
3035 
3036     private class PackageUpdatedTask implements Runnable {
3037         int mOp;
3038         String[] mPackages;
3039         UserHandleCompat mUser;
3040 
3041         public static final int OP_NONE = 0;
3042         public static final int OP_ADD = 1;
3043         public static final int OP_UPDATE = 2;
3044         public static final int OP_REMOVE = 3; // uninstlled
3045         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3046 
3047 
3048         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3049             mOp = op;
3050             mPackages = packages;
3051             mUser = user;
3052         }
3053 
3054         public void run() {
3055             final Context context = mApp.getContext();
3056 
3057             final String[] packages = mPackages;
3058             final int N = packages.length;
3059             switch (mOp) {
3060                 case OP_ADD:
3061                     for (int i=0; i&lt;N; i++) {
3062                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3063                         mIconCache.remove(packages[i], mUser);
3064                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3065                     }
3066                     break;
3067                 case OP_UPDATE:
3068                     for (int i=0; i&lt;N; i++) {
3069                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3070                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3071                         WidgetPreviewLoader.removePackageFromDb(
3072                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3073                     }
3074                     break;
3075                 case OP_REMOVE:
3076                 case OP_UNAVAILABLE:
3077                     boolean clearCache = mOp == OP_REMOVE;
3078                     for (int i=0; i&lt;N; i++) {
3079                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3080                         mBgAllAppsList.removePackage(packages[i], mUser, clearCache);
3081                         WidgetPreviewLoader.removePackageFromDb(
3082                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3083                     }
3084                     break;
3085             }
3086 
3087             ArrayList&lt;AppInfo&gt; added = null;
3088             ArrayList&lt;AppInfo&gt; modified = null;
3089             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3090 
3091             if (mBgAllAppsList.added.size() &gt; 0) {
3092                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3093                 mBgAllAppsList.added.clear();
3094             }
3095             if (mBgAllAppsList.modified.size() &gt; 0) {
3096                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3097                 mBgAllAppsList.modified.clear();
3098             }
3099             if (mBgAllAppsList.removed.size() &gt; 0) {
3100                 removedApps.addAll(mBgAllAppsList.removed);
3101                 mBgAllAppsList.removed.clear();
3102             }
3103 
3104             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3105             if (callbacks == null) {
3106                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3107                 return;
3108             }
3109 
3110             if (added != null) {
3111                 // Ensure that we add all the workspace applications to the db
3112                 if (LauncherAppState.isDisableAllApps()) {
3113                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3114                     addAndBindAddedWorkspaceApps(context, addedInfos);
3115                 } else {
3116                     addAppsToAllApps(context, added);
3117                 }
3118             }
3119 
3120             if (modified != null) {
3121                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3122 
3123                 // Update the launcher db to reflect the changes
3124                 for (AppInfo a : modifiedFinal) {
3125                     ArrayList&lt;ItemInfo&gt; infos =
3126                             getItemInfoForComponentName(a.componentName, mUser);
3127                     for (ItemInfo i : infos) {
3128                         if (i instanceof ShortcutInfo &amp;&amp; isShortcutAppTarget((ShortcutInfo) i)) {
3129                             ShortcutInfo info = (ShortcutInfo) i;
3130                             info.title = a.title.toString();
3131                             info.contentDescription = a.contentDescription;
3132                             updateItemInDatabase(context, info);
3133                         }
3134                     }
3135                 }
3136 
3137                 mHandler.post(new Runnable() {
3138                     public void run() {
3139                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3140                         if (callbacks == cb &amp;&amp; cb != null) {
3141                             callbacks.bindAppsUpdated(modifiedFinal);
3142                         }
3143                     }
3144                 });
3145             }
3146 
3147             // Update shortcuts which use an iconResource
3148             if (mOp == OP_ADD || mOp == OP_UPDATE) {
3149                 final ArrayList&lt;ShortcutInfo&gt; iconsChanged = new ArrayList&lt;ShortcutInfo&gt;();
3150                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3151                 // We need to iterate over the items here, so that we can avoid new Bitmap
3152                 // creation on the UI thread.
3153                 synchronized (sBgLock) {
3154                     for (ItemInfo info : sBgWorkspaceItems) {
3155                         if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3156                             ShortcutInfo si = (ShortcutInfo) info;
3157                             if ((si.iconResource != null)
3158                                     &amp;&amp; packageSet.contains(si.getTargetComponent().getPackageName())){
3159                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName,
3160                                         si.iconResource.resourceName, mIconCache, context);
3161                                 if (icon != null) {
3162                                     si.setIcon(icon);
3163                                     si.usingFallbackIcon = false;
3164                                     iconsChanged.add(si);
3165                                     updateItemInDatabase(context, si);
3166                                 }
3167                             }
3168                         }
3169                     }
3170                 }
3171 
3172                 if (!iconsChanged.isEmpty()) {
3173                     mHandler.post(new Runnable() {
3174                         public void run() {
3175                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3176                             if (callbacks == cb &amp;&amp; cb != null) {
3177                                 callbacks.bindShortcutsUpdated(iconsChanged);
3178                             }
3179                         }
3180                     });
3181                 }
3182             }
3183 
3184             final ArrayList&lt;String&gt; removedPackageNames =
3185                     new ArrayList&lt;String&gt;();
3186             if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3187                 // Mark all packages in the broadcast to be removed
3188                 removedPackageNames.addAll(Arrays.asList(packages));
3189             } else if (mOp == OP_UPDATE) {
3190                 // Mark disabled packages in the broadcast to be removed
3191                 for (int i=0; i&lt;N; i++) {
3192                     if (isPackageDisabled(context, packages[i], mUser)) {
3193                         removedPackageNames.add(packages[i]);
3194                     }
3195                 }
3196             }
3197 
3198             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3199                 final int removeReason;
3200                 if (mOp == OP_UNAVAILABLE) {
3201                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3202                 } else {
3203             // Remove all the components associated with this package
3204             for (String pn : removedPackageNames) {
3205                 deletePackageFromDatabase(context, pn, mUser);
3206             }
3207             // Remove all the specific components
3208             for (AppInfo a : removedApps) {
3209                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3210                 deleteItemsFromDatabase(context, infos);
3211             }
3212                     removeReason = 0;
3213                 }
3214 
3215                 // Remove any queued items from the install queue
3216                 String spKey = LauncherAppState.getSharedPreferencesKey();
3217                 SharedPreferences sp =
3218                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3219                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3220                 // Call the components-removed callback
3221                 mHandler.post(new Runnable() {
3222                     public void run() {
3223                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3224                         if (callbacks == cb &amp;&amp; cb != null) {
3225                             callbacks.bindComponentsRemoved(
3226                                     removedPackageNames, removedApps, mUser, removeReason);
3227                         }
3228                     }
3229                 });
3230             }
3231 
3232             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3233                     getSortedWidgetsAndShortcuts(context);
3234             mHandler.post(new Runnable() {
3235                 @Override
3236                 public void run() {
3237                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3238                     if (callbacks == cb &amp;&amp; cb != null) {
3239                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3240                     }
3241                 }
3242             });
3243 
3244             // Write all the logs to disk
3245             mHandler.post(new Runnable() {
3246                 public void run() {
3247                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3248                     if (callbacks == cb &amp;&amp; cb != null) {
3249                         callbacks.dumpLogsToLocalData();
3250                     }
3251                 }
3252             });
3253         }
3254     }
3255 
3256     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3257     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3258         PackageManager packageManager = context.getPackageManager();
3259         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3260         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3261 
3262         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3263         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3264         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3265         return widgetsAndShortcuts;
3266     }
3267 
3268     private static boolean isPackageDisabled(Context context, String packageName,
3269             UserHandleCompat user) {
3270         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3271         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3272     }
3273 
3274     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3275             UserHandleCompat user) {
3276         if (cn == null) {
3277             return false;
3278         }
3279         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3280         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3281             return false;
3282         }
3283         return launcherApps.isActivityEnabledForProfile(cn, user);
3284     }
3285 
3286     public static boolean isValidPackage(Context context, String packageName,
3287             UserHandleCompat user) {
3288         if (packageName == null) {
3289             return false;
3290         }
3291         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3292         return launcherApps.isPackageEnabledForProfile(packageName, user);
3293     }
3294 
3295     /**
3296      * Make an ShortcutInfo object for a restored application or shortcut item that points
3297      * to a package that is not yet installed on the system.
3298      */
3299     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3300             int promiseType) {
3301         final ShortcutInfo info = new ShortcutInfo();
3302         info.user = UserHandleCompat.myUserHandle();
3303         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3304 
3305         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3306             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3307             if (!TextUtils.isEmpty(title)) {
3308                 info.title = title;
3309             }
3310             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3311         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3312             if (TextUtils.isEmpty(info.title)) {
3313                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3314             }
3315             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3316         } else {
3317             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3318         }
3319 
3320         info.contentDescription = mUserManager.getBadgedLabelForUser(
3321                 info.title.toString(), info.user);
3322         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3323         info.promisedIntent = intent;
3324         return info;
3325     }
3326 
3327     /**
3328      * Make an Intent object for a restored application or shortcut item that points
3329      * to the market page for the item.
3330      */
3331     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3332         ComponentName componentName = intent.getComponent();
3333         return getMarketIntent(componentName.getPackageName());
3334     }
3335 
3336     static Intent getMarketIntent(String packageName) {
3337         return new Intent(Intent.ACTION_VIEW)
3338             .setData(new Uri.Builder()
3339                 .scheme(&quot;market&quot;)
3340                 .authority(&quot;details&quot;)
3341                 .appendQueryParameter(&quot;id&quot;, packageName)
3342                 .build());
3343     }
3344 
3345     /**
3346      * This is called from the code that adds shortcuts from the intent receiver.  This
3347      * doesn&#x27;t have a Cursor, but
3348      */
3349     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3350             UserHandleCompat user, Context context) {
3351         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3352     }
3353 
3354     /**
3355      * Make an ShortcutInfo object for a shortcut that is an application.
3356      *
3357      * If c is not null, then it will be used to fill in missing data like the title and icon.
3358      */
3359     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3360             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3361             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3362         if (user == null) {
3363             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3364             return null;
3365         }
3366 
3367         ComponentName componentName = intent.getComponent();
3368         if (componentName == null) {
3369             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3370             return null;
3371         }
3372 
3373         Intent newIntent = new Intent(intent.getAction(), null);
3374         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3375         newIntent.setComponent(componentName);
3376         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3377         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3378             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3379             return null;
3380         }
3381 
3382         final ShortcutInfo info = new ShortcutInfo();
3383 
3384         // the resource -- This may implicitly give us back the fallback icon,
3385         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3386         // to avoid saving lots of copies of that in the database, and most apps
3387         // have icons anyway.
3388         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3389 
3390         // the db
3391         if (icon == null) {
3392             if (c != null) {
3393                 icon = getIconFromCursor(c, iconIndex, context);
3394             }
3395         }
3396         // the fallback icon
3397         if (icon == null) {
3398             icon = mIconCache.getDefaultIcon(user);
3399             info.usingFallbackIcon = true;
3400         }
3401         info.setIcon(icon);
3402 
3403         // From the cache.
3404         if (labelCache != null) {
3405             info.title = labelCache.get(componentName);
3406         }
3407 
3408         // from the resource
3409         if (info.title == null &amp;&amp; lai != null) {
3410             info.title = lai.getLabel();
3411             if (labelCache != null) {
3412                 labelCache.put(componentName, info.title);
3413             }
3414         }
3415         // from the db
3416         if (info.title == null) {
3417             if (c != null) {
3418                 info.title =  c.getString(titleIndex);
3419             }
3420         }
3421         // fall back to the class name of the activity
3422         if (info.title == null) {
3423             info.title = componentName.getClassName();
3424         }
3425         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3426         info.user = user;
3427         info.contentDescription = mUserManager.getBadgedLabelForUser(
3428                 info.title.toString(), info.user);
3429         return info;
3430     }
3431 
3432     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3433             ItemInfoFilter f) {
3434         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3435         for (ItemInfo i : infos) {
3436             if (i instanceof ShortcutInfo) {
3437                 ShortcutInfo info = (ShortcutInfo) i;
3438                 ComponentName cn = info.getTargetComponent();
3439                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3440                     filtered.add(info);
3441                 }
3442             } else if (i instanceof FolderInfo) {
3443                 FolderInfo info = (FolderInfo) i;
3444                 for (ShortcutInfo s : info.contents) {
3445                     ComponentName cn = s.getTargetComponent();
3446                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3447                         filtered.add(s);
3448                     }
3449                 }
3450             } else if (i instanceof LauncherAppWidgetInfo) {
3451                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3452                 ComponentName cn = info.providerName;
3453                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3454                     filtered.add(info);
3455                 }
3456             }
3457         }
3458         return new ArrayList&lt;ItemInfo&gt;(filtered);
3459     }
3460 
3461     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3462             final UserHandleCompat user) {
3463         ItemInfoFilter filter  = new ItemInfoFilter() {
3464             @Override
3465             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3466                 if (info.user == null) {
3467                     return cn.equals(cname);
3468                 } else {
3469                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3470                 }
3471             }
3472         };
3473         return filterItemInfos(sBgItemsIdMap.values(), filter);
3474     }
3475 
3476     /**
3477      * @return true if the ShortcutInfo points to an app shortcut target, i.e. it has been added by
3478      * dragging from AllApps list.
3479      */
3480     public static boolean isShortcutAppTarget(ShortcutInfo info) {
3481         // We need to check for ACTION_MAIN otherwise getComponent() might
3482         // return null for some shortcuts (for instance, for shortcuts to
3483         // web pages.)
3484         Intent intent = info.promisedIntent != null ? info.promisedIntent : info.intent;
3485         ComponentName name = intent.getComponent();
3486         return info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3487                 Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null;
3488     }
3489 
3490     /**
3491      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3492      */
3493     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3494             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3495             int titleIndex) {
3496 
3497         Bitmap icon = null;
3498         final ShortcutInfo info = new ShortcutInfo();
3499         // Non-app shortcuts are only supported for current user.
3500         info.user = UserHandleCompat.myUserHandle();
3501         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3502 
3503         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3504 
3505         info.title = c.getString(titleIndex);
3506 
3507         int iconType = c.getInt(iconTypeIndex);
3508         switch (iconType) {
3509         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3510             String packageName = c.getString(iconPackageIndex);
3511             String resourceName = c.getString(iconResourceIndex);
3512             info.customIcon = false;
3513             // the resource
3514             icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);
3515             // the db
3516             if (icon == null) {
3517                 icon = getIconFromCursor(c, iconIndex, context);
3518             }
3519             // the fallback icon
3520             if (icon == null) {
3521                 icon = mIconCache.getDefaultIcon(info.user);
3522                 info.usingFallbackIcon = true;
3523             }
3524             break;
3525         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3526             icon = getIconFromCursor(c, iconIndex, context);
3527             if (icon == null) {
3528                 icon = mIconCache.getDefaultIcon(info.user);
3529                 info.customIcon = false;
3530                 info.usingFallbackIcon = true;
3531             } else {
3532                 info.customIcon = true;
3533             }
3534             break;
3535         default:
3536             icon = mIconCache.getDefaultIcon(info.user);
3537             info.usingFallbackIcon = true;
3538             info.customIcon = false;
3539             break;
3540         }
3541         info.setIcon(icon);
3542         return info;
3543     }
3544 
3545     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3546         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3547         final boolean debug = false;
3548         if (debug) {
3549             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3550                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3551         }
3552         byte[] data = c.getBlob(iconIndex);
3553         try {
3554             return Utilities.createIconBitmap(
3555                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3556         } catch (Exception e) {
3557             return null;
3558         }
3559     }
3560 
3561     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3562             int cellX, int cellY, boolean notify) {
3563         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3564         if (info == null) {
3565             return null;
3566         }
3567         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3568 
3569         return info;
3570     }
3571 
3572     /**
3573      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3574      */
3575     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3576             ComponentName component) {
3577         List&lt;AppWidgetProviderInfo&gt; widgets =
3578             AppWidgetManager.getInstance(context).getInstalledProviders();
3579         for (AppWidgetProviderInfo info : widgets) {
3580             if (info.provider.equals(component)) {
3581                 return info;
3582             }
3583         }
3584         return null;
3585     }
3586 
3587     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3588         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3589         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3590         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3591 
3592         if (intent == null) {
3593             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3594             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3595             return null;
3596         }
3597 
3598         Bitmap icon = null;
3599         boolean customIcon = false;
3600         ShortcutIconResource iconResource = null;
3601 
3602         if (bitmap instanceof Bitmap) {
3603             icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
3604             customIcon = true;
3605         } else {
3606             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3607             if (extra instanceof ShortcutIconResource) {
3608                     iconResource = (ShortcutIconResource) extra;
3609                 icon = Utilities.createIconBitmap(iconResource.packageName,
3610                         iconResource.resourceName, mIconCache, context);
3611             }
3612         }
3613 
3614         final ShortcutInfo info = new ShortcutInfo();
3615 
3616         // Only support intents for current user for now. Intents sent from other
3617         // users wouldn&#x27;t get here without intent forwarding anyway.
3618         info.user = UserHandleCompat.myUserHandle();
3619         if (icon == null) {
3620             if (fallbackIcon != null) {
3621                 icon = fallbackIcon;
3622             } else {
3623                 icon = mIconCache.getDefaultIcon(info.user);
3624                 info.usingFallbackIcon = true;
3625             }
3626         }
3627         info.setIcon(icon);
3628 
3629         info.title = name;
3630         info.contentDescription = mUserManager.getBadgedLabelForUser(
3631                 info.title.toString(), info.user);
3632         info.intent = intent;
3633         info.customIcon = customIcon;
3634         info.iconResource = iconResource;
3635 
3636         return info;
3637     }
3638 
3639     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3640             int iconIndex) {
3641         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3642         if (!mAppsCanBeOnRemoveableStorage) {
3643             return false;
3644         }
3645         // If this icon doesn&#x27;t have a custom icon, check to see
3646         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3647         // we&#x27;re going to show, store what we are going to show back
3648         // into the DB.  We do this so when we&#x27;re loading, if the
3649         // package manager can&#x27;t find an icon (for example because
3650         // the app is on SD) then we can use that instead.
3651         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3652             cache.put(info, c.getBlob(iconIndex));
3653             return true;
3654         }
3655         return false;
3656     }
3657     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3658         boolean needSave = false;
3659         try {
3660             if (data != null) {
3661                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3662                 Bitmap loaded = info.getIcon(mIconCache);
3663                 needSave = !saved.sameAs(loaded);
3664             } else {
3665                 needSave = true;
3666             }
3667         } catch (Exception e) {
3668             needSave = true;
3669         }
3670         if (needSave) {
3671             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3672             // This is slower than is ideal, but this only happens once
3673             // or when the app is updated with a new icon.
3674             updateItemInDatabase(context, info);
3675         }
3676     }
3677 
3678     /**
3679      * Return an existing FolderInfo object if we have encountered this ID previously,
3680      * or make a new one.
3681      */
3682     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3683         // See if a placeholder was created for us already
3684         FolderInfo folderInfo = folders.get(id);
3685         if (folderInfo == null) {
3686             // No placeholder -- create a new instance
3687             folderInfo = new FolderInfo();
3688             folders.put(id, folderInfo);
3689         }
3690         return folderInfo;
3691     }
3692 
3693     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3694         final Collator collator = Collator.getInstance();
3695         return new Comparator&lt;AppInfo&gt;() {
3696             public final int compare(AppInfo a, AppInfo b) {
3697                 if (a.user.equals(b.user)) {
3698                     int result = collator.compare(a.title.toString().trim(),
3699                             b.title.toString().trim());
3700                     if (result == 0) {
3701                         result = a.componentName.compareTo(b.componentName);
3702                     }
3703                     return result;
3704                 } else {
3705                     // TODO Need to figure out rules for sorting
3706                     // profiles, this puts work second.
3707                     return a.user.toString().compareTo(b.user.toString());
3708                 }
3709             }
3710         };
3711     }
3712     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3713             = new Comparator&lt;AppInfo&gt;() {
3714         public final int compare(AppInfo a, AppInfo b) {
3715             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3716             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3717             return 0;
3718         }
3719     };
3720     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3721         if (info.activityInfo != null) {
3722             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3723         } else {
3724             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3725         }
3726     }
3727     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3728         private Collator mCollator;
3729         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3730         ShortcutNameComparator(PackageManager pm) {
3731             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3732             mCollator = Collator.getInstance();
3733         }
3734         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3735             mLabelCache = labelCache;
3736             mCollator = Collator.getInstance();
3737         }
3738         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3739             String labelA, labelB;
3740             ComponentName keyA = a.getComponentName();
3741             ComponentName keyB = b.getComponentName();
3742             if (mLabelCache.containsKey(keyA)) {
3743                 labelA = mLabelCache.get(keyA).toString();
3744             } else {
3745                 labelA = a.getLabel().toString().trim();
3746 
3747                 mLabelCache.put(keyA, labelA);
3748             }
3749             if (mLabelCache.containsKey(keyB)) {
3750                 labelB = mLabelCache.get(keyB).toString();
3751             } else {
3752                 labelB = b.getLabel().toString().trim();
3753 
3754                 mLabelCache.put(keyB, labelB);
3755             }
3756             return mCollator.compare(labelA, labelB);
3757         }
3758     }
3759     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3760         private final AppWidgetManagerCompat mManager;
3761         private final PackageManager mPackageManager;
3762         private final HashMap&lt;Object, String&gt; mLabelCache;
3763         private final Collator mCollator;
3764 
3765         WidgetAndShortcutNameComparator(Context context) {
3766             mManager = AppWidgetManagerCompat.getInstance(context);
3767             mPackageManager = context.getPackageManager();
3768             mLabelCache = new HashMap&lt;Object, String&gt;();
3769             mCollator = Collator.getInstance();
3770         }
3771         public final int compare(Object a, Object b) {
3772             String labelA, labelB;
3773             if (mLabelCache.containsKey(a)) {
3774                 labelA = mLabelCache.get(a);
3775             } else {
3776                 labelA = (a instanceof AppWidgetProviderInfo)
3777                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
3778                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3779                 mLabelCache.put(a, labelA);
3780             }
3781             if (mLabelCache.containsKey(b)) {
3782                 labelB = mLabelCache.get(b);
3783             } else {
3784                 labelB = (b instanceof AppWidgetProviderInfo)
3785                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
3786                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3787                 mLabelCache.put(b, labelB);
3788             }
3789             return mCollator.compare(labelA, labelB);
3790         }
3791     }
3792 
3793     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3794         return (provider != null) &amp;&amp; (provider.provider != null)
3795                 &amp;&amp; (provider.provider.getPackageName() != null);
3796     }
3797 
3798     public void dumpState() {
3799         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3800         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3801         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3802         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3803         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3804         if (mLoaderTask != null) {
3805             mLoaderTask.dumpState();
3806         } else {
3807             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3808         }
3809     }
3810 }
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderClient;
  24 import android.content.ContentProviderOperation;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent.ShortcutIconResource;
  29 import android.content.Intent;
  30 import android.content.IntentFilter;
  31 import android.content.SharedPreferences;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.ProviderInfo;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.provider.BaseColumns;
  49 import android.text.TextUtils;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import com.android.launcher3.compat.AppWidgetManagerCompat;
  53 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  54 import com.android.launcher3.compat.LauncherAppsCompat;
  55 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  56 import com.android.launcher3.compat.PackageInstallerCompat;
  57 import com.android.launcher3.compat.UserHandleCompat;
  58 import com.android.launcher3.compat.UserManagerCompat;
  59 import java.lang.ref.WeakReference;
  60 import java.net.URISyntaxException;
  61 import java.security.InvalidParameterException;
  62 import java.text.Collator;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collection;
  66 import java.util.Collections;
  67 import java.util.Comparator;
  68 import java.util.HashMap;
  69 import java.util.HashSet;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Map.Entry;
  73 import java.util.Set;
  74 import java.util.TreeMap;
  75 import java.util.concurrent.atomic.AtomicBoolean;
  76 
  77 
  78 /**
  79  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  80  * LauncherModel object held in a static. Also provide APIs for updating the database state
  81  * for the Launcher.
  82  */
<abbr title="  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackCompat {">  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackCðŸ”µ</abbr>
  84     static final boolean DEBUG_LOADERS = false;
  85 
  86     private static final boolean DEBUG_RECEIVER = false;
  87 
  88     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  89 
  90     static final String TAG = &quot;Launcher.Model&quot;;
  91 
  92     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  93     // false = strew non-workspace apps across the workspace on upgrade
  94     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  95     // false = strew non-workspace apps across the workspace on upgrade
  96     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  97 
  98     public static final int LOADER_FLAG_NONE = 0;
  99 
 100     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 101 
 102     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 103 
 104     // batch size for the workspace icons
 105     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 106 
 107     private static final long INVALID_SCREEN_ID = -1L;
 108 
 109     private final boolean mAppsCanBeOnRemoveableStorage;
 110 
 111     private final boolean mOldContentProviderExists;
 112 
 113     private final LauncherAppState mApp;
 114 
 115     private final Object mLock = new Object();
 116 
 117     private DeferredHandler mHandler = new DeferredHandler();
 118 
 119     private LoaderTask mLoaderTask;
 120 
 121     private boolean mIsLoaderTaskRunning;
 122 
 123     private volatile boolean mFlushingWorkerThread;
 124 
 125     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 126     // clear all queued binding runnables when the Launcher activity is destroyed.
 127     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 128 
 129     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 130 
 131     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 132 
 133     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 134 
 135     static {
 136         sWorkerThread.start();
 137     }
 138 
 139     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 140 
 141     // We start off with everything not loaded.  After that, we assume that
 142     // our monitoring of the package manager provides all updates and we never
 143     // need to do a requery.  These are only ever touched from the loader thread.
 144     private boolean mWorkspaceLoaded;
 145 
 146     private boolean mAllAppsLoaded;
 147 
 148     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 149     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 150     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 151     // a normal load, we also clear this set of Runnables.
 152     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 153 
 154     private WeakReference&lt;Callbacks&gt; mCallbacks;
 155 
 156     // &lt; only access in worker thread &gt;
 157     // &lt; only access in worker thread &gt;
 158     AllAppsList mBgAllAppsList;
 159 
 160     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 161     // other locks, this one can generally be held long-term because we never expect any of these
 162     // static data structures to be referenced outside of the worker thread except on the first
 163     // load after configuration change.
 164     static final Object sBgLock = new Object();
 165 
 166     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 167     // LauncherModel to their ids
 168     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 169 
 170     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 171     // created by LauncherModel that are directly on the home screen (however, no widgets or
 172     // shortcuts within folders).
 173     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 174 
 175     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 176     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 177     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 178         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 179 
 180     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 181     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 182 
 183     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 184     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 185 
 186     // sBgWorkspaceScreens is the ordered set of workspace screens.
 187     // sBgWorkspaceScreens is the ordered set of workspace screens.
 188     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 189 
 190     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
<abbr title=" 191     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();"> 191     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleCompðŸ”µ</abbr>
 192 
 193     // &lt;/ only access in worker thread &gt;
 194     // &lt;/ only access in worker thread &gt;
 195 
 196     private IconCache mIconCache;
 197 
 198     protected int mPreviousConfigMcc;
 199 
 200     private final LauncherAppsCompat mLauncherApps;
 201 
 202     private final UserManagerCompat mUserManager;
 203 
 204     public interface Callbacks {
 205         public boolean setLoadOnResume();
 206 
 207         public int getCurrentWorkspaceScreen();
 208 
 209         public void startBinding();
 210 
 211         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 212                               boolean forceAnimateIcons);
 213 
 214         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 215 
 216         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 217 
 218         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 219 
 220         public void finishBindingItems(boolean upgradePath);
 221 
 222         public void bindAppWidget(LauncherAppWidgetInfo info);
 223 
 224         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 225 
 226         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 227                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 228                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 229                                   ArrayList&lt;AppInfo&gt; addedApps);
 230 
 231         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 232 
 233         public void bindShortcutsUpdated(ArrayList&lt;ShortcutInfo&gt; shortcuts);
 234 
 235         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 236 
 237         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 238 
 239         public void updatePackageBadge(String packageName);
 240 
<abbr title=" 241         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);"> 241         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appðŸ”µ</abbr>
 242 
 243         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 244 
 245         public void bindSearchablesChanged();
 246 
 247         public boolean isAllAppsButtonRank(int rank);
 248 
 249         public void onPageBoundSynchronously(int page);
 250 
 251         public void dumpLogsToLocalData();
 252     }
 253 
 254     public interface ItemInfoFilter {
 255         public abstract boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 256     }
 257 
 258     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 259         Context context = app.getContext();
 260         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 261         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 262         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 263         // resource string.
 264         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
<abbr title=" 265         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);"> 265         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY,ðŸ”µ</abbr>
<abbr title=" 266         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthority, 0);"> 266         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthorðŸ”µ</abbr>
 267         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 268         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 269         if (mOldContentProviderExists) {
 270             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 271         } else {
 272             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 273         }
 274         mApp = app;
 275         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 276         mIconCache = iconCache;
 277         final Resources res = context.getResources();
 278         Configuration config = res.getConfiguration();
 279         mPreviousConfigMcc = config.mcc;
 280         mLauncherApps = LauncherAppsCompat.getInstance(context);
 281         mUserManager = UserManagerCompat.getInstance(context);
 282     }
 283 
 284     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 285      * posted on the main thread handler. */
 286     private void runOnMainThread(Runnable r) {
 287         runOnMainThread(r, 0);
 288     }
 289 
 290     private void runOnMainThread(Runnable r, int type) {
 291         if (sWorkerThread.getThreadId() == Process.myTid()) {
 292             // If we are on the worker thread, post onto the main handler
 293             mHandler.post(r);
 294         } else {
 295             r.run();
 296         }
 297     }
 298 
 299     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 300      * posted on the worker thread handler. */
 301     private static void runOnWorkerThread(Runnable r) {
 302         if (sWorkerThread.getThreadId() == Process.myTid()) {
 303             r.run();
 304         } else {
 305             // If we are not on the worker thread, then post to the worker handler
 306             sWorker.post(r);
 307         }
 308     }
 309 
 310     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 311         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 312     }
 313 
 314     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 315                                  long screen) {
 316         LauncherAppState app = LauncherAppState.getInstance();
 317         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 318         final int xCount = (int) grid.numColumns;
 319         final int yCount = (int) grid.numRows;
 320         boolean[][] occupied = new boolean[xCount][yCount];
 321 
 322         int cellX, cellY, spanX, spanY;
 323         for (int i = 0; i &lt; items.size(); ++i) {
 324             final ItemInfo item = items.get(i);
 325             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 326                 if (item.screenId == screen) {
 327                     cellX = item.cellX;
 328                     cellY = item.cellY;
 329                     spanX = item.spanX;
 330                     spanY = item.spanY;
 331                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 332                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 333                             occupied[x][y] = true;
 334                         }
 335                     }
 336                 }
 337             }
 338         }
 339 
 340         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 341     }
 342 
 343     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 344                                                         Intent launchIntent,
 345                                                         int firstScreenIndex,
 346                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 347         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 348         LauncherAppState app = LauncherAppState.getInstance();
 349         LauncherModel model = app.getModel();
 350         boolean found = false;
 351         synchronized (app) {
 352             if (sWorkerThread.getThreadId() != Process.myTid()) {
 353                 // Flush the LauncherModel worker thread, so that if we just did another
 354                 // processInstallShortcut, we give it time for its shortcut to get added to the
 355                 // database (getItemsInLocalCoordinates reads the database)
 356                 model.flushWorkerThread();
 357             }
 358             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 359 
 360             // Try adding to the workspace screens incrementally, starting at the default or center
 361             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 362             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 363             int count = workspaceScreens.size();
 364             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 365                 int[] tmpCoordinates = new int[2];
 366                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 367                         workspaceScreens.get(screen))) {
 368                     // Update the Launcher db
 369                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 370                 }
 371             }
 372         }
 373         return null;
 374     }
 375 
 376     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 377         // Process the updated package state
 378         Runnable r = new Runnable() {
 379             public void run() {
 380                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 381                 if (callbacks != null) {
 382                     callbacks.updatePackageState(installInfo);
 383                 }
 384             }
 385         };
 386         mHandler.post(r);
 387     }
 388 
 389     public void updatePackageBadge(final String packageName) {
 390         // Process the updated package badge
 391         Runnable r = new Runnable() {
 392             public void run() {
 393                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 394                 if (callbacks != null) {
 395                     callbacks.updatePackageBadge(packageName);
 396                 }
 397             }
 398         };
 399         mHandler.post(r);
 400     }
 401 
 402     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 403         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 404 
 405         if (allAppsApps == null) {
 406             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 407         }
 408         if (allAppsApps.isEmpty()) {
 409             return;
 410         }
 411 
 412         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 413         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 414         while (iter.hasNext()) {
 415             ItemInfo a = iter.next();
 416             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 417                 restoredAppsFinal.add((AppInfo) a);
 418             }
 419         }
 420 
 421         // Process the newly added applications and add them to the database first
 422         Runnable r = new Runnable() {
 423             public void run() {
 424                 runOnMainThread(new Runnable() {
 425                     public void run() {
 426                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 427                         if (callbacks == cb &amp;&amp; cb != null) {
 428                             if (!restoredAppsFinal.isEmpty()) {
 429                                 for (AppInfo info : restoredAppsFinal) {
 430                                     final Intent intent = info.getIntent();
 431                                     if (intent != null) {
 432                                         mIconCache.deletePreloadedIcon(intent.getComponent(),
 433                                                 info.user);
 434                                     }
 435                                 }
 436                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 437                             }
 438                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 439                         }
 440                     }
 441                 });
 442             }
 443         };
 444         runOnWorkerThread(r);
 445     }
 446 
 447     public void addAndBindAddedWorkspaceApps(final Context context,
 448             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 449         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 450 
 451         if (workspaceApps == null) {
 452             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 453         }
 454         if (workspaceApps.isEmpty()) {
 455             return;
 456         }
 457         // Process the newly added applications and add them to the database first
 458         Runnable r = new Runnable() {
 459             public void run() {
 460                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 461                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 462                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 463 
 464                 // Get the list of workspace screens.  We need to append to this list and
 465                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 466                 // called.
 467                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 468                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 469                 for (Integer i : orderedScreens.keySet()) {
 470                     long screenId = orderedScreens.get(i);
 471                     workspaceScreens.add(screenId);
 472                 }
 473 
 474                 synchronized(sBgLock) {
 475                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 476                     while (iter.hasNext()) {
 477                         ItemInfo a = iter.next();
 478                         final String name = a.title.toString();
 479                         final Intent launchIntent = a.getIntent();
 480 
 481                         // Short-circuit this logic if the icon exists somewhere on the workspace
 482                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 483                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 484                             if (a instanceof AppInfo &amp;&amp;
 485                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 486                                 restoredAppsFinal.add((AppInfo) a);
 487                             }
 488                             continue;
 489                         }
 490 
 491                         // Add this icon to the db, creating a new page if necessary.  If there
 492                         // is only the empty page then we just add items to the first page.
 493                         // Otherwise, we add them to the next pages.
 494                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 495                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 496                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 497                         if (coords == null) {
 498                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 499 
 500                             // If we can&#x27;t find a valid position, then just add a new screen.
 501                             // This takes time so we need to re-queue the add until the new
 502                             // page is added.  Create as many screens as necessary to satisfy
 503                             // the startSearchPageIndex.
 504                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 505                                     workspaceScreens.size());
 506                             while (numPagesToAdd &gt; 0) {
 507                                 long screenId = lp.generateNewScreenId();
 508                                 // Save the screen id for binding in the workspace
 509                                 workspaceScreens.add(screenId);
 510                                 addedWorkspaceScreensFinal.add(screenId);
 511                                 numPagesToAdd--;
 512                             }
 513 
 514                             // Find the coordinate again
 515                             coords = LauncherModel.findNextAvailableIconSpace(context,
 516                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 517                         }
 518                         if (coords == null) {
 519                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 520                         }
 521 
 522                         ShortcutInfo shortcutInfo;
 523                         if (a instanceof ShortcutInfo) {
 524                             shortcutInfo = (ShortcutInfo) a;
 525                         } else if (a instanceof AppInfo) {
 526                             shortcutInfo = ((AppInfo) a).makeShortcut();
 527                         } else {
 528                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 529                         }
 530 
 531                         // Add the shortcut to the db
 532                         addItemToDatabase(context, shortcutInfo,
 533                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 534                                 coords.first, coords.second[0], coords.second[1], false);
 535                         // Save the ShortcutInfo for binding in the workspace
 536                         addedShortcutsFinal.add(shortcutInfo);
 537                     }
 538                 }
 539 
 540                 // Update the workspace screens
 541                 updateWorkspaceScreenOrder(context, workspaceScreens);
 542 
 543                 if (!addedShortcutsFinal.isEmpty()) {
 544                     runOnMainThread(new Runnable() {
 545                         public void run() {
 546                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 547                             if (callbacks == cb &amp;&amp; cb != null) {
 548                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 549                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 550                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 551                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 551                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - ðŸ”µ</abbr>
 552                                     long lastScreenId = info.screenId;
 553                                     for (ItemInfo i : addedShortcutsFinal) {
 554                                         if (i.screenId == lastScreenId) {
 555                                             addAnimated.add(i);
 556                                         } else {
 557                                             addNotAnimated.add(i);
 558                                         }
 559                                     }
 560                                 }
 561                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 562                                         addNotAnimated, addAnimated, null);
 563                                 if (!restoredAppsFinal.isEmpty()) {
 564                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 565                                 }
 566                             }
 567                         }
 568                     });
 569                 }
 570             }
 571         };
 572         runOnWorkerThread(r);
 573     }
 574 
 575     public void unbindItemInfosAndClearQueuedBindRunnables() {
 576         if (sWorkerThread.getThreadId() == Process.myTid()) {
 577             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 578                     &quot;main thread&quot;);
 579         }
 580 
 581         // Clear any deferred bind runnables
 582         synchronized (mDeferredBindRunnables) {
 583             mDeferredBindRunnables.clear();
 584         }
 585         // Remove any queued bind runnables
 586         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 587         // Unbind all the workspace items
 588         unbindWorkspaceItemsOnMainThread();
 589     }
 590 
 591     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 592     void unbindWorkspaceItemsOnMainThread() {
 593         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 594         // by making a copy of workspace items first.
 595         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 596         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 597         synchronized (sBgLock) {
 598             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 599             tmpAppWidgets.addAll(sBgAppWidgets);
 600         }
 601         Runnable r = new Runnable() {
 602                 @Override
 603                 public void run() {
 604                    for (ItemInfo item : tmpWorkspaceItems) {
 605                        item.unbind();
 606                    }
 607                    for (ItemInfo item : tmpAppWidgets) {
 608                        item.unbind();
 609                    }
 610                 }
 611             };
 612         runOnMainThread(r);
 613     }
 614 
 615     /**
 616      * Adds an item to the DB if it was not created previously, or move it to a new
 617      * &lt;container, screen, cellX, cellY&gt;
 618      */
 619     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 620             long screenId, int cellX, int cellY) {
 621         if (item.container == ItemInfo.NO_ID) {
 622             // From all apps
 623             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 624         } else {
 625             // From somewhere else
 626             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 627         }
 628     }
 629 
 630     static void checkItemInfoLocked(
 631             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 632         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 633         if (modelItem != null &amp;&amp; item != modelItem) {
 634             // check all the data is consistent
 635             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 636                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 637                 ShortcutInfo shortcut = (ShortcutInfo) item;
 638                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 639                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 640                         modelShortcut.id == shortcut.id &amp;&amp;
 641                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 642                         modelShortcut.container == shortcut.container &amp;&amp;
 643                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 644                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 645                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 646                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 647                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 648                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 649                         (modelShortcut.dropPos != null &amp;&amp;
 650                                 shortcut.dropPos != null &amp;&amp;
 651                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 652                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 653                     // For all intents and purposes, this is the same object
 654                     return;
 655                 }
 656             }
 657 
 658             // the modelItem needs to match up perfectly with item if our model is
 659             // to be consistent with the database-- for now, just require
 660             // modelItem == item or the equality check above
 661             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 662                     &quot;modelItem: &quot; +
 663                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 664                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 665             RuntimeException e = new RuntimeException(msg);
 666             if (stackTrace != null) {
 667                 e.setStackTrace(stackTrace);
 668             }
 669             throw e;
 670         }
 671     }
 672 
 673     static void checkItemInfo(final ItemInfo item) {
 674         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 675         final long itemId = item.id;
 676         Runnable r = new Runnable() {
 677             public void run() {
 678                 synchronized (sBgLock) {
 679                     checkItemInfoLocked(itemId, item, stackTrace);
 680                 }
 681             }
 682         };
 683         runOnWorkerThread(r);
 684     }
 685 
 686     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 687             final ItemInfo item, final String callingFunction) {
 688         final long itemId = item.id;
 689         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 690         final ContentResolver cr = context.getContentResolver();
 691 
 692         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 693         Runnable r = new Runnable() {
 694             public void run() {
 695                 cr.update(uri, values, null, null);
 696                 updateItemArrays(item, itemId, stackTrace);
 697             }
 698         };
 699         runOnWorkerThread(r);
 700     }
 701 
 702     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 703             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 704         final ContentResolver cr = context.getContentResolver();
 705 
 706         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 707         Runnable r = new Runnable() {
 708             public void run() {
 709                 ArrayList&lt;ContentProviderOperation&gt; ops =
 710                         new ArrayList&lt;ContentProviderOperation&gt;();
 711                 int count = items.size();
 712                 for (int i = 0; i &lt; count; i++) {
 713                     ItemInfo item = items.get(i);
 714                     final long itemId = item.id;
 715                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 716                     ContentValues values = valuesList.get(i);
 717 
 718                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 719                     updateItemArrays(item, itemId, stackTrace);
 720 
 721                 }
 722                 try {
 723                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 724                 } catch (Exception e) {
 725                     e.printStackTrace();
 726                 }
 727             }
 728         };
 729         runOnWorkerThread(r);
 730     }
 731 
 732     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 733         // Lock on mBgLock *after* the db operation
 734         synchronized (sBgLock) {
 735             checkItemInfoLocked(itemId, item, stackTrace);
 736 
 737             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 738                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 739                 // Item is in a folder, make sure this folder exists
 740                 if (!sBgFolders.containsKey(item.container)) {
 741                     // An items container is being set to a that of an item which is not in
 742                     // the list of Folders.
 743                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 744                             item.container + &quot;, not in the list of folders&quot;;
 745                     Log.e(TAG, msg);
 746                 }
 747             }
 748 
 749             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 750             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 751             // that are on the desktop, as appropriate
 752             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 753             if (modelItem != null &amp;&amp;
 754                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 755                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 756                 switch (modelItem.itemType) {
 757                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 758                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 759                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 760                         if (!sBgWorkspaceItems.contains(modelItem)) {
 761                             sBgWorkspaceItems.add(modelItem);
 762                         }
 763                         break;
 764                     default:
 765                         break;
 766                 }
 767             } else {
 768                 sBgWorkspaceItems.remove(modelItem);
 769             }
 770         }
 771     }
 772 
 773     public void flushWorkerThread() {
 774         mFlushingWorkerThread = true;
 775         Runnable waiter = new Runnable() {
 776                 public void run() {
 777                     synchronized (this) {
 778                         notifyAll();
 779                         mFlushingWorkerThread = false;
 780                     }
 781                 }
 782             };
 783 
 784         synchronized(waiter) {
 785             runOnWorkerThread(waiter);
 786             if (mLoaderTask != null) {
 787                 synchronized(mLoaderTask) {
 788                     mLoaderTask.notify();
 789                 }
 790             }
 791             boolean success = false;
 792             while (!success) {
 793                 try {
 794                     waiter.wait();
 795                     success = true;
 796                 } catch (InterruptedException e) {
 797                 }
 798             }
 799         }
 800     }
 801 
 802     /**
 803      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 804      */
 805     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 806             final long screenId, final int cellX, final int cellY) {
 807         item.container = container;
 808         item.cellX = cellX;
 809         item.cellY = cellY;
 810 
 811         // We store hotseat items in canonical form which is this orientation invariant position
 812         // in the hotseat
 813         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 814                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 815             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 816         } else {
 817             item.screenId = screenId;
 818         }
 819 
 820         final ContentValues values = new ContentValues();
 821         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 822         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 823         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 824         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 825 
 826         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 827     }
 828 
 829     /**
 830      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 831      * cellX, cellY have already been updated on the ItemInfos.
 832      */
 833     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 834             final long container, final int screen) {
 835 
 836         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 837         int count = items.size();
 838 
 839         for (int i = 0; i &lt; count; i++) {
 840             ItemInfo item = items.get(i);
 841             item.container = container;
 842 
 843             // We store hotseat items in canonical form which is this orientation invariant position
 844             // in the hotseat
 845             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 846                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 847                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 848                         item.cellY);
 849             } else {
 850                 item.screenId = screen;
 851             }
 852 
 853             final ContentValues values = new ContentValues();
 854             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 855             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 856             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 857             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 858 
 859             contentValues.add(values);
 860         }
 861         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 862     }
 863 
 864     /**
 865      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 866      */
 867     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 868             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 869         item.container = container;
 870         item.cellX = cellX;
 871         item.cellY = cellY;
 872         item.spanX = spanX;
 873         item.spanY = spanY;
 874 
 875         // We store hotseat items in canonical form which is this orientation invariant position
 876         // in the hotseat
 877         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 878                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 879             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 880         } else {
 881             item.screenId = screenId;
 882         }
 883 
 884         final ContentValues values = new ContentValues();
 885         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 886         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 887         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 888         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 889         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 890         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 891 
 892         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 893     }
 894 
 895     /**
 896      * Update an item to the database in a specified container.
 897      */
 898     static void updateItemInDatabase(Context context, final ItemInfo item) {
 899         final ContentValues values = new ContentValues();
 900         item.onAddToDatabase(context, values);
 901         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 902         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 903     }
 904 
 905     /**
 906      * Returns true if the shortcuts already exists in the database.
 907      * we identify a shortcut by its title and intent.
 908      */
 909     static boolean shortcutExists(Context context, String title, Intent intent) {
 910         final ContentResolver cr = context.getContentResolver();
 911         final Intent intentWithPkg, intentWithoutPkg;
 912 
 913         if (intent.getComponent() != null) {
 914             // If component is not null, an intent with null package will produce
 915             // the same result and should also be a match.
 916             if (intent.getPackage() != null) {
 917                 intentWithPkg = intent;
 918                 intentWithoutPkg = new Intent(intent).setPackage(null);
 919             } else {
 920                 intentWithPkg = new Intent(intent).setPackage(
 921                         intent.getComponent().getPackageName());
 922                 intentWithoutPkg = intent;
 923             }
 924         } else {
 925             intentWithPkg = intent;
 926             intentWithoutPkg = intent;
 927         }
 928         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 929             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 930             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 931         boolean result = false;
 932         try {
 933             result = c.moveToFirst();
 934         } finally {
 935             c.close();
 936         }
 937         return result;
 938     }
 939 
 940     /**
 941      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 942      */
 943     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 944         final ComponentName component = intent.getComponent();
 945         if (component == null) {
 946             return false;
 947         }
 948         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 949     }
 950 
 951     /**
 952      * Returns an ItemInfo array containing all the items in the LauncherModel.
 953      * The ItemInfo.id is not set through this function.
 954      */
 955     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 956         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 957         final ContentResolver cr = context.getContentResolver();
 958         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 959                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 960                 LauncherSettings.Favorites.SCREEN,
 961                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 962                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 963                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 964 
 965         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 966         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 967         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 968         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 969         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 970         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 971         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 972         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 973         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 974         try {
 975             while (c.moveToNext()) {
 976                 ItemInfo item = new ItemInfo();
 977                 item.cellX = c.getInt(cellXIndex);
 978                 item.cellY = c.getInt(cellYIndex);
 979                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 980                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 981                 item.container = c.getInt(containerIndex);
 982                 item.itemType = c.getInt(itemTypeIndex);
 983                 item.screenId = c.getInt(screenIndex);
 984                 long serialNumber = c.getInt(profileIdIndex);
 985                 item.user = userManager.getUserForSerialNumber(serialNumber);
 986                 // Skip if user has been deleted.
 987                 if (item.user != null) {
 988                     items.add(item);
 989                 }
 990             }
 991         } catch (Exception e) {
 992             items.clear();
 993         } finally {
 994             c.close();
 995         }
 996 
 997         return items;
 998     }
 999 
1000     /**
1001      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1002      */
1003     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
1004         final ContentResolver cr = context.getContentResolver();
1005         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1006                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
1007                 new String[] { String.valueOf(id),
1008                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1009 
1010         try {
1011             if (c.moveToFirst()) {
1012                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1013                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1014                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1015                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1016                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1017                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1018 
1019                 FolderInfo folderInfo = null;
1020                 switch (c.getInt(itemTypeIndex)) {
1021                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1022                         folderInfo = findOrMakeFolder(folderList, id);
1023                         break;
1024                 }
1025 
1026                 folderInfo.title = c.getString(titleIndex);
1027                 folderInfo.id = id;
1028                 folderInfo.container = c.getInt(containerIndex);
1029                 folderInfo.screenId = c.getInt(screenIndex);
1030                 folderInfo.cellX = c.getInt(cellXIndex);
1031                 folderInfo.cellY = c.getInt(cellYIndex);
1032 
1033                 return folderInfo;
1034             }
1035         } finally {
1036             c.close();
1037         }
1038 
1039         return null;
1040     }
1041 
1042     /**
1043      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1044      * cellY fields of the item. Also assigns an ID to the item.
1045      */
1046     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1047             final long screenId, final int cellX, final int cellY, final boolean notify) {
1048         item.container = container;
1049         item.cellX = cellX;
1050         item.cellY = cellY;
1051         // We store hotseat items in canonical form which is this orientation invariant position
1052         // in the hotseat
1053         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1054                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1055             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1056         } else {
1057             item.screenId = screenId;
1058         }
1059 
1060         final ContentValues values = new ContentValues();
1061         final ContentResolver cr = context.getContentResolver();
1062         item.onAddToDatabase(context, values);
1063 
1064         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1065         values.put(LauncherSettings.Favorites._ID, item.id);
1066         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1067 
1068         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1069         Runnable r = new Runnable() {
1070             public void run() {
1071                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1072                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1073 
1074                 // Lock on mBgLock *after* the db operation
1075                 synchronized (sBgLock) {
1076                     checkItemInfoLocked(item.id, item, stackTrace);
1077                     sBgItemsIdMap.put(item.id, item);
1078                     switch (item.itemType) {
1079                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1080                             sBgFolders.put(item.id, (FolderInfo) item);
1081                             // Fall through
1082                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1083                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1084                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1085                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1086                                 sBgWorkspaceItems.add(item);
1087                             } else {
1088                                 if (!sBgFolders.containsKey(item.container)) {
1089                                     // Adding an item to a folder that doesn&#x27;t exist.
1090                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1091                                             &quot; doesn&#x27;t exist&quot;;
1092                                     Log.e(TAG, msg);
1093                                 }
1094                             }
1095                             break;
1096                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1097                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1098                             break;
1099                     }
1100                 }
1101             }
1102         };
1103         runOnWorkerThread(r);
1104     }
1105 
1106     /**
1107      * Creates a new unique child id, for a given cell span across all layouts.
1108      */
1109     static int getCellLayoutChildId(
1110             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1111         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1112                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1113     }
1114 
1115     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1116             final String pn, final UserHandleCompat user) {
1117         ItemInfoFilter filter  = new ItemInfoFilter() {
1118             @Override
1119             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1120                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1121             }
1122         };
1123         return filterItemInfos(sBgItemsIdMap.values(), filter);
1124     }
1125 
1126     /**
1127      * Removes all the items from the database corresponding to the specified package.
1128      */
1129     static void deletePackageFromDatabase(Context context, final String pn,
1130             final UserHandleCompat user) {
1131         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1132     }
1133 
1134     /**
1135      * Removes the specified item from the database
1136      * @param context
1137      * @param item
1138      */
1139     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1140         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1141         items.add(item);
1142         deleteItemsFromDatabase(context, items);
1143     }
1144 
1145     /**
1146      * Removes the specified items from the database
1147      * @param context
1148      * @param item
1149      */
1150     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1151         final ContentResolver cr = context.getContentResolver();
1152 
1153         Runnable r = new Runnable() {
1154             public void run() {
1155                 for (ItemInfo item : items) {
1156                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1157                     cr.delete(uri, null, null);
1158 
1159                     // Lock on mBgLock *after* the db operation
1160                     synchronized (sBgLock) {
1161                         switch (item.itemType) {
1162                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1163                                 sBgFolders.remove(item.id);
1164                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1165                                     if (info.container == item.id) {
1166                                         // We are deleting a folder which still contains items that
1167                                         // think they are contained by that folder.
1168                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1169                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1170                                         Log.e(TAG, msg);
1171                                     }
1172                                 }
1173                                 sBgWorkspaceItems.remove(item);
1174                                 break;
1175                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1176                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1177                                 sBgWorkspaceItems.remove(item);
1178                                 break;
1179                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1180                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1181                                 break;
1182                         }
1183                         sBgItemsIdMap.remove(item.id);
1184                         sBgDbIconCache.remove(item);
1185                     }
1186                 }
1187             }
1188         };
1189         runOnWorkerThread(r);
1190     }
1191 
1192     /**
1193      * Update the order of the workspace screens in the database. The array list contains
1194      * a list of screen ids in the order that they should appear.
1195      */
1196     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1197         // Log to disk
1198         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1199         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1200 
1201         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1202         final ContentResolver cr = context.getContentResolver();
1203         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1204 
1205         // Remove any negative screen ids -- these aren&#x27;t persisted
1206         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1207         while (iter.hasNext()) {
1208             long id = iter.next();
1209             if (id &lt; 0) {
1210                 iter.remove();
1211             }
1212         }
1213 
1214         Runnable r = new Runnable() {
1215             @Override
1216             public void run() {
1217                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1218                 // Clear the table
1219                 ops.add(ContentProviderOperation.newDelete(uri).build());
1220                 int count = screensCopy.size();
1221                 for (int i = 0; i &lt; count; i++) {
1222                     ContentValues v = new ContentValues();
1223                     long screenId = screensCopy.get(i);
1224                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1225                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1226                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1227                 }
1228 
1229                 try {
1230                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1231                 } catch (Exception ex) {
1232                     throw new RuntimeException(ex);
1233                 }
1234 
1235                 synchronized (sBgLock) {
1236                     sBgWorkspaceScreens.clear();
1237                     sBgWorkspaceScreens.addAll(screensCopy);
1238                 }
1239             }
1240         };
1241         runOnWorkerThread(r);
1242     }
1243 
1244     /**
1245      * Remove the contents of the specified folder from the database
1246      */
1247     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1248         final ContentResolver cr = context.getContentResolver();
1249 
1250         Runnable r = new Runnable() {
1251             public void run() {
1252                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1253                 // Lock on mBgLock *after* the db operation
1254                 synchronized (sBgLock) {
1255                     sBgItemsIdMap.remove(info.id);
1256                     sBgFolders.remove(info.id);
1257                     sBgDbIconCache.remove(info);
1258                     sBgWorkspaceItems.remove(info);
1259                 }
1260 
1261                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1262                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1263                 // Lock on mBgLock *after* the db operation
1264                 synchronized (sBgLock) {
1265                     for (ItemInfo childInfo : info.contents) {
1266                         sBgItemsIdMap.remove(childInfo.id);
1267                         sBgDbIconCache.remove(childInfo);
1268                     }
1269                 }
1270             }
1271         };
1272         runOnWorkerThread(r);
1273     }
1274 
1275     /**
1276      * Set this as the current Launcher activity object for the loader.
1277      */
1278     public void initialize(Callbacks callbacks) {
1279         synchronized (mLock) {
1280             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1281         }
1282     }
1283 
1284     @Override
1285     public void onPackageChanged(String packageName, UserHandleCompat user) {
1286         int op = PackageUpdatedTask.OP_UPDATE;
1287         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1288                 user));
1289     }
1290 
1291     @Override
1292     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1293         int op = PackageUpdatedTask.OP_REMOVE;
1294         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1295                 user));
1296     }
1297 
1298     @Override
1299     public void onPackageAdded(String packageName, UserHandleCompat user) {
1300         int op = PackageUpdatedTask.OP_ADD;
1301         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1302                 user));
1303     }
1304 
1305     @Override
1306     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1307             boolean replacing) {
1308         if (!replacing) {
1309             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1310                     user));
1311             if (mAppsCanBeOnRemoveableStorage) {
1312                 // Only rebind if we support removable storage. It catches the
1313                 // case where
1314                 // apps on the external sd card need to be reloaded
1315                 startLoaderFromBackground();
1316             }
1317         } else {
1318             // If we are replacing then just update the packages in the list
1319             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1320                     packageNames, user));
1321         }
1322     }
1323 
1324     @Override
1325     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1326             boolean replacing) {
1327         if (!replacing) {
1328             enqueuePackageUpdated(new PackageUpdatedTask(
1329                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1330                     user));
1331         }
1332 
1333     }
1334 
1335     /**
1336      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1337      * ACTION_PACKAGE_CHANGED.
1338      */
1339     @Override
1340     public void onReceive(Context context, Intent intent) {
1341         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1342 
1343         final String action = intent.getAction();
1344         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1345             // If we have changed locale we need to clear out the labels in all apps/workspace.
1346             forceReload();
1347         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1348              // Check if configuration change was an mcc/mnc change which would affect app resources
1349              // and we would need to clear out the labels in all apps/workspace. Same handling as
1350              // above for ACTION_LOCALE_CHANGED
1351              Configuration currentConfig = context.getResources().getConfiguration();
1352              if (mPreviousConfigMcc != currentConfig.mcc) {
1353                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1354                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1355                    forceReload();
1356              }
1357              // Update previousConfig
1358              mPreviousConfigMcc = currentConfig.mcc;
1359         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1360                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1361             if (mCallbacks != null) {
1362                 Callbacks callbacks = mCallbacks.get();
1363                 if (callbacks != null) {
1364                     callbacks.bindSearchablesChanged();
1365                 }
1366             }
1367         }
1368     }
1369 
1370     void forceReload() {
1371         resetLoadedState(true, true);
1372 
1373         // Do this here because if the launcher activity is running it will be restarted.
1374         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1375         // to reload.
1376         startLoaderFromBackground();
1377     }
1378 
1379     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1380         synchronized (mLock) {
1381             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1382             // mWorkspaceLoaded to true later
1383             stopLoaderLocked();
1384             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1385             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1386         }
1387     }
1388 
1389     /**
1390      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1391      * configuration changes.  So whenever we trigger the loader from the background
1392      * tell the launcher that it needs to re-run the loader when it comes back instead
1393      * of doing it now.
1394      */
1395     public void startLoaderFromBackground() {
1396         boolean runLoader = false;
1397         if (mCallbacks != null) {
1398             Callbacks callbacks = mCallbacks.get();
1399             if (callbacks != null) {
1400                 // Only actually run the loader if they&#x27;re not paused.
1401                 if (!callbacks.setLoadOnResume()) {
1402                     runLoader = true;
1403                 }
1404             }
1405         }
1406         if (runLoader) {
1407             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1408         }
1409     }
1410 
1411     // If there is already a loader task running, tell it to stop.
1412     // returns true if isLaunching() was true on the old task
1413     private boolean stopLoaderLocked() {
1414         boolean isLaunching = false;
1415         LoaderTask oldTask = mLoaderTask;
1416         if (oldTask != null) {
1417             if (oldTask.isLaunching()) {
1418                 isLaunching = true;
1419             }
1420             oldTask.stopLocked();
1421         }
1422         return isLaunching;
1423     }
1424 
1425     public boolean isCurrentCallbacks(Callbacks callbacks) {
1426         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1427     }
1428 
1429     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1430         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1431     }
1432 
1433     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1434         synchronized (mLock) {
1435             if (DEBUG_LOADERS) {
1436                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1437             }
1438 
1439             // Clear any deferred bind-runnables from the synchronized load process
1440             // We must do this before any loading/binding is scheduled below.
1441             synchronized (mDeferredBindRunnables) {
1442                 mDeferredBindRunnables.clear();
1443             }
1444 
1445             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1446             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1447                 // If there is already one running, tell it to stop.
1448                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1449                 isLaunching = isLaunching || stopLoaderLocked();
1450                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1451                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1452                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1453                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1454                 } else {
1455                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1456                     sWorker.post(mLoaderTask);
1457                 }
1458             }
1459         }
1460     }
1461 
1462     void bindRemainingSynchronousPages() {
1463         // Post the remaining side pages to be loaded
1464         if (!mDeferredBindRunnables.isEmpty()) {
1465             Runnable[] deferredBindRunnables = null;
1466             synchronized (mDeferredBindRunnables) {
1467                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1468                         new Runnable[mDeferredBindRunnables.size()]);
1469                 mDeferredBindRunnables.clear();
1470             }
1471             for (final Runnable r : deferredBindRunnables) {
1472                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1473             }
1474         }
1475     }
1476 
1477     public void stopLoader() {
1478         synchronized (mLock) {
1479             if (mLoaderTask != null) {
1480                 mLoaderTask.stopLocked();
1481             }
1482         }
1483     }
1484 
1485     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1486     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1487         final ContentResolver contentResolver = context.getContentResolver();
1488         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1489         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1490         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1491 
1492         try {
1493             final int idIndex = sc.getColumnIndexOrThrow(
1494                     LauncherSettings.WorkspaceScreens._ID);
1495             final int rankIndex = sc.getColumnIndexOrThrow(
1496                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1497             while (sc.moveToNext()) {
1498                 try {
1499                     long screenId = sc.getLong(idIndex);
1500                     int rank = sc.getInt(rankIndex);
1501                     orderedScreens.put(rank, screenId);
1502                 } catch (Exception e) {
<abbr title="1503                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1503                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,ðŸ”µ</abbr>
1504                 }
1505             }
1506         } finally {
1507             sc.close();
1508         }
1509 
1510         // Log to disk
1511         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1512         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1513         for (Integer i : orderedScreens.keySet()) {
1514             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1515         }
1516         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1517                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1518         return orderedScreens;
1519     }
1520 
1521     public boolean isAllAppsLoaded() {
1522         return mAllAppsLoaded;
1523     }
1524 
1525     boolean isLoadingWorkspace() {
1526         synchronized (mLock) {
1527             if (mLoaderTask != null) {
1528                 return mLoaderTask.isLoadingWorkspace();
1529             }
1530         }
1531         return false;
1532     }
1533 
1534     /**
1535      * Runnable for the thread that loads the contents of the launcher:
1536      *   - workspace icons
1537      *   - widgets
1538      *   - all apps icons
1539      */
1540     private class LoaderTask implements Runnable {
1541         private Context mContext;
1542 
1543         private boolean mIsLaunching;
1544 
1545         private boolean mIsLoadingAndBindingWorkspace;
1546 
1547         private boolean mStopped;
1548 
1549         private boolean mLoadAndBindStepFinished;
1550 
1551         private int mFlags;
1552 
1553         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1554 
1555         LoaderTask(Context context, boolean isLaunching, int flags) {
1556             mContext = context;
1557             mIsLaunching = isLaunching;
1558             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1559             mFlags = flags;
1560         }
1561 
1562         boolean isLaunching() {
1563             return mIsLaunching;
1564         }
1565 
1566         boolean isLoadingWorkspace() {
1567             return mIsLoadingAndBindingWorkspace;
1568         }
1569 
1570         /** Returns whether this is an upgrade path */
1571         private boolean loadAndBindWorkspace() {
1572             mIsLoadingAndBindingWorkspace = true;
1573 
1574             // Load the workspace
1575             if (DEBUG_LOADERS) {
1576                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1577             }
1578 
1579             boolean isUpgradePath = false;
1580             if (!mWorkspaceLoaded) {
1581                 isUpgradePath = loadWorkspace();
1582                 synchronized (LoaderTask.this) {
1583                     if (mStopped) {
1584                         return isUpgradePath;
1585                     }
1586                     mWorkspaceLoaded = true;
1587                 }
1588             }
1589 
1590             // Bind the workspace
1591             bindWorkspace(-1, isUpgradePath);
1592             return isUpgradePath;
1593         }
1594 
1595         private void waitForIdle() {
1596             // Wait until the either we&#x27;re stopped or the other threads are done.
1597             // This way we don&#x27;t start loading all apps until the workspace has settled
1598             // down.
1599             synchronized (LoaderTask.this) {
1600                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1601 
1602                 mHandler.postIdle(new Runnable() {
1603                         public void run() {
1604                             synchronized (LoaderTask.this) {
1605                                 mLoadAndBindStepFinished = true;
1606                                 if (DEBUG_LOADERS) {
1607                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1608                                 }
1609                                 LoaderTask.this.notify();
1610                             }
1611                         }
1612                     });
1613 
1614                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1615                     try {
1616                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1617                         // wait no longer than 1sec at a time
1618                         this.wait(1000);
1619                     } catch (InterruptedException ex) {
1620                         // Ignore
1621                     }
1622                 }
1623                 if (DEBUG_LOADERS) {
1624                     Log.d(TAG, &quot;waited &quot;
1625                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1626                             + &quot;ms for previous step to finish binding&quot;);
1627                 }
1628             }
1629         }
1630 
1631         void runBindSynchronousPage(int synchronousBindPage) {
1632             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1633                 // Ensure that we have a valid page index to load synchronously
1634                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1635                         &quot;valid page index&quot;);
1636             }
1637             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1638                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1639                 // loaded already (we should load everything asynchronously in that case)
1640                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1641             }
1642             synchronized (mLock) {
1643                 if (mIsLoaderTaskRunning) {
1644                     // Ensure that we are never running the background loading at this point since
1645                     // we also touch the background collections
1646                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1647                 }
1648             }
1649 
1650             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1651             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1652             //      this call is synchronous, we can get away with not locking).
1653 
1654             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1655             // operations from the previous activity.  We need to ensure that all queued operations
1656             // are executed before any synchronous binding work is done.
1657             mHandler.flush();
1658 
1659             // Divide the set of loaded items into those that we are binding synchronously, and
1660             // everything else that is to be bound normally (asynchronously).
1661             bindWorkspace(synchronousBindPage, false);
1662             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1663             //      arise from that.
1664             onlyBindAllApps();
1665         }
1666 
1667         public void run() {
1668             boolean isUpgrade = false;
1669 
1670             synchronized (mLock) {
1671                 mIsLoaderTaskRunning = true;
1672             }
1673             // Optimize for end-user experience: if the Launcher is up and // running with the
1674             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1675             // workspace first (default).
1676             keep_running: {
1677                 // Elevate priority when Home launches for the first time to avoid
1678                 // starving at boot time. Staring at a blank home is not cool.
1679                 synchronized (mLock) {
1680                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1681                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1682                     android.os.Process.setThreadPriority(mIsLaunching
1683                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1684                 }
1685                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1686                 isUpgrade = loadAndBindWorkspace();
1687 
1688                 if (mStopped) {
1689                     break keep_running;
1690                 }
1691 
1692                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1693                 // settled down.
1694                 synchronized (mLock) {
1695                     if (mIsLaunching) {
1696                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1697                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1698                     }
1699                 }
1700                 waitForIdle();
1701 
1702                 // second step
1703                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1704                 loadAndBindAllApps();
1705 
1706                 // Restore the default thread priority after we are done loading items
1707                 synchronized (mLock) {
1708                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1709                 }
1710             }
1711 
1712             // Update the saved icons if necessary
1713             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1714             synchronized (sBgLock) {
1715                 for (Object key : sBgDbIconCache.keySet()) {
1716                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1717                 }
1718                 sBgDbIconCache.clear();
1719             }
1720 
1721             if (LauncherAppState.isDisableAllApps()) {
1722                 // Ensure that all the applications that are in the system are
1723                 // represented on the home screen.
1724                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1725                     verifyApplications();
1726                 }
1727             }
1728 
1729             // Clear out this reference, otherwise we end up holding it until all of the
1730             // callback runnables are done.
1731             mContext = null;
1732 
1733             synchronized (mLock) {
1734                 // If we are still the last one to be scheduled, remove ourselves.
1735                 if (mLoaderTask == this) {
1736                     mLoaderTask = null;
1737                 }
1738                 mIsLoaderTaskRunning = false;
1739             }
1740         }
1741 
1742         public void stopLocked() {
1743             synchronized (LoaderTask.this) {
1744                 mStopped = true;
1745                 this.notify();
1746             }
1747         }
1748 
1749         /**
1750          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1751          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1752          * object that was around when the deferred message was scheduled, and if there&#x27;s
1753          * a new Callbacks object around then also return null.  This will save us from
1754          * calling onto it with data that will be ignored.
1755          */
1756         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1757             synchronized (mLock) {
1758                 if (mStopped) {
1759                     return null;
1760                 }
1761 
1762                 if (mCallbacks == null) {
1763                     return null;
1764                 }
1765 
1766                 final Callbacks callbacks = mCallbacks.get();
1767                 if (callbacks != oldCallbacks) {
1768                     return null;
1769                 }
1770                 if (callbacks == null) {
1771                     Log.w(TAG, &quot;no mCallbacks&quot;);
1772                     return null;
1773                 }
1774 
1775                 return callbacks;
1776             }
1777         }
1778 
1779         private void verifyApplications() {
1780             final Context context = mApp.getContext();
1781 
1782             // Cross reference all the applications in our apps list with items in the workspace
1783             ArrayList&lt;ItemInfo&gt; tmpInfos;
1784             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1785             synchronized (sBgLock) {
1786                 for (AppInfo app : mBgAllAppsList.data) {
1787                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1788                     if (tmpInfos.isEmpty()) {
1789                         // We are missing an application icon, so add this to the workspace
1790                         added.add(app);
1791                         // This is a rare event, so lets log it
1792                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1793                     }
1794                 }
1795             }
1796             if (!added.isEmpty()) {
1797                 addAndBindAddedWorkspaceApps(context, added);
1798             }
1799         }
1800 
1801         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1802         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1803                                            AtomicBoolean deleteOnInvalidPlacement) {
1804             LauncherAppState app = LauncherAppState.getInstance();
1805             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1806             final int countX = (int) grid.numColumns;
1807             final int countY = (int) grid.numRows;
1808 
1809             long containerIndex = item.screenId;
1810             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1811                 // Return early if we detect that an item is under the hotseat button
1812                 if (mCallbacks == null ||
1813                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1814                     deleteOnInvalidPlacement.set(true);
1815                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1816                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1817                             + item.cellY + &quot;) occupied by all apps&quot;);
1818                     return false;
1819                 }
1820 
1821                 final ItemInfo[][] hotseatItems =
1822                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1823 
1824                 if (item.screenId &gt;= grid.numHotseatIcons) {
1825                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1826                             + &quot; into hotseat position &quot; + item.screenId
1827                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1828                             + &quot;)&quot;);
1829                     return false;
1830                 }
1831 
1832                 if (hotseatItems != null) {
1833                     if (hotseatItems[(int) item.screenId][0] != null) {
1834                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1835                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1836                                 + item.cellY + &quot;) occupied by &quot;
1837                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1838                                 [(int) item.screenId][0]);
1839                             return false;
1840                     } else {
1841                         hotseatItems[(int) item.screenId][0] = item;
1842                         return true;
1843                     }
1844                 } else {
1845                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1846                     items[(int) item.screenId][0] = item;
1847                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1848                     return true;
1849                 }
1850             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1851                 // Skip further checking if it is not the hotseat or workspace container
1852                 return true;
1853             }
1854 
1855             if (!occupied.containsKey(item.screenId)) {
1856                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1857                 occupied.put(item.screenId, items);
1858             }
1859 
1860             final ItemInfo[][] screens = occupied.get(item.screenId);
1861             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1862                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1863                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1864                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1865                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1866                         + item.cellX + &quot;,&quot; + item.cellY
1867                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1868                 return false;
1869             }
1870 
1871             // Check if any workspace icons overlap with each other
1872             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1873                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1874                     if (screens[x][y] != null) {
1875                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1876                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1877                             + x + &quot;,&quot; + y
1878                             + &quot;) occupied by &quot;
1879                             + screens[x][y]);
1880                         return false;
1881                     }
1882                 }
1883             }
1884             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1885                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1886                     screens[x][y] = item;
1887                 }
1888             }
1889 
1890             return true;
1891         }
1892 
1893         /** Clears all the sBg data structures */
1894         private void clearSBgDataStructures() {
1895             synchronized (sBgLock) {
1896                 sBgWorkspaceItems.clear();
1897                 sBgAppWidgets.clear();
1898                 sBgFolders.clear();
1899                 sBgItemsIdMap.clear();
1900                 sBgDbIconCache.clear();
1901                 sBgWorkspaceScreens.clear();
1902             }
1903         }
1904 
1905         /** Returns whether this is an upgrade path */
1906         private boolean loadWorkspace() {
1907             // Log to disk
1908             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1909             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1910             final Context context = mContext;
1911             final ContentResolver contentResolver = context.getContentResolver();
1912             final PackageManager manager = context.getPackageManager();
1913             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1914             final boolean isSafeMode = manager.isSafeMode();
1915             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
<abbr title="1916             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;">1916             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiverðŸ”µ</abbr>
1917             LauncherAppState app = LauncherAppState.getInstance();
1918             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1919             int countX = ((int) (grid.numColumns));
1920             int countY = ((int) (grid.numRows));
1921             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1922                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1923                 LauncherAppState.getLauncherProvider().deleteDatabase();
1924             }
1925             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1926                 // append the user&#x27;s Launcher2 shortcuts
1927                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1928                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1929             } else {
1930                 // Make sure the default workspace is loaded
1931                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1932                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1933             }
1934             // This code path is for our old migration code and should no longer be exercised
1935             boolean loadedOldDb = false;
1936             // Log to disk
1937             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1938             synchronized(sBgLock) {
1939                 clearSBgDataStructures();
<abbr title="1940                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updateAndGetActiveSessionCache();">1940                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updatðŸ”µ</abbr>
1941                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1942                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1943                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1944                 if (DEBUG_LOADERS) {
1945                     Log.d(TAG, &quot;loading model from &quot; + contentUri);
1946                 }
1947                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1948                 // +1 for the hotseat (it can be larger than the workspace)
1949                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1950                 // before any earlier duplicates)
1951                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1952                 try {
1953                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1954                     final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1955                     final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1956                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);">1956                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPðŸ”µ</abbr>
1957                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title="1958                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);">1958                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_ðŸ”µ</abbr>
<abbr title="1959                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);">1959                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICONðŸ”µ</abbr>
<abbr title="1960                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1960                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINðŸ”µ</abbr>
<abbr title="1961                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1961                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPðŸ”µ</abbr>
<abbr title="1962                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_ID);">1962                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIðŸ”µ</abbr>
<abbr title="1963                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_PROVIDER);">1963                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.FavoritesðŸ”µ</abbr>
1964                     final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1965                     final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1966                     final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1967                     final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1968                     final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<abbr title="1969                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED);">1969                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTOREDðŸ”µ</abbr>
<abbr title="1970                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);">1970                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILEðŸ”µ</abbr>
1971                     // final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1972                     // final int displayModeIndex = c.getColumnIndexOrThrow(
1973                     // LauncherSettings.Favorites.DISPLAY_MODE);
1974                     ShortcutInfo info;
1975                     String intentDescription;
1976                     LauncherAppWidgetInfo appWidgetInfo;
1977                     int container;
1978                     long id;
1979                     Intent intent;
1980                     UserHandleCompat user;
1981                     while ((!mStopped) &amp;&amp; c.moveToNext()) {
1982                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1983                         try {
1984                             int itemType = c.getInt(itemTypeIndex);
1985                             boolean restored = 0 != c.getInt(restoredIndex);
1986                             boolean allowMissingTarget = false;
1987                             switch (itemType) {
1988                                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1989                                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1990                                     id = c.getLong(idIndex);
1991                                     intentDescription = c.getString(intentIndex);
1992                                     long serialNumber = c.getInt(profileIdIndex);
1993                                     user = mUserManager.getUserForSerialNumber(serialNumber);
1994                                     int promiseType = c.getInt(restoredIndex);
1995                                     int disabledState = 0;
1996                                     if (user == null) {
1997                                         // User has been deleted remove the item.
1998                                         itemsToRemove.add(id);
1999                                         continue;
2000                                     }
2001                                     try {
2002                                         intent = Intent.parseUri(intentDescription, 0);
2003                                         ComponentName cn = intent.getComponent();
2004                                         if ((cn != null) &amp;&amp; (cn.getPackageName() != null)) {
<abbr title="2005                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user);">2005                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cnðŸ”µ</abbr>
<abbr title="2006                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityEnabledForProfile(cn, user);">2006                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityEðŸ”µ</abbr>
2007                                             if (validComponent) {
2008                                                 if (restored) {
2009                                                     // no special handling necessary for this item
2010                                                     restoredRows.add(id);
2011                                                     restored = false;
2012                                                 }
2013                                             } else if (validPkg) {
2014                                                 intent = null;
<abbr title="2015                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {">2015                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != ðŸ”µ</abbr>
2016                                                     // We allow auto install apps to have their intent
2017                                                     // updated after an install.
<abbr title="2018                                                     intent = manager.getLaunchIntentForPackage(cn.getPackageName());">2018                                                     intent = manager.getLaunchIntentForPackage(cn.getPackðŸ”µ</abbr>
2019                                                     if (intent != null) {
2020                                                         ContentValues values = new ContentValues();
<abbr title="2021                                                         values.put(LauncherSettings.Favorites.INTENT, intent.toUri(0));">2021                                                         values.put(LauncherSettings.Favorites.INTENT, intðŸ”µ</abbr>
2022                                                         String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="2023                                                         String[] args = new java.lang.String[]{ Long.toString(id) };">2023                                                         String[] args = new java.lang.String[]{ Long.toStðŸ”µ</abbr>
<abbr title="2024                                                         contentResolver.update(contentUri, values, where, args);">2024                                                         contentResolver.update(contentUri, values, where,ðŸ”µ</abbr>
2025                                                     }
2026                                                 }
2027                                                 if (intent == null) {
2028                                                     // The app is installed but the component is no
2029                                                     // longer available.
<abbr title="2030                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: &quot; + cn, true);">2030                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: ðŸ”µ</abbr>
2031                                                     itemsToRemove.add(id);
2032                                                     continue;
2033                                                 } else {
2034                                                     // no special handling necessary for this item
2035                                                     restoredRows.add(id);
2036                                                     restored = false;
2037                                                 }
2038                                             } else if (restored) {
2039                                                 // Package is not yet available but might be
2040                                                 // installed later.
<abbr title="2041                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cn, true);">2041                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cðŸ”µ</abbr>
<abbr title="2042                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {">2042                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != ðŸ”µ</abbr>
2043                                                     // Restore has started once.
<abbr title="2044                                                 } else if (installingPkgs.contains(cn.getPackageName())) {">2044                                                 } else if (installingPkgs.contains(cn.getPackageName())) ðŸ”µ</abbr>
2045                                                     // App restore has started. Update the flag
2046                                                     promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2047                                                     ContentValues values = new ContentValues();
<abbr title="2048                                                     values.put(LauncherSettings.Favorites.RESTORED, promiseType);">2048                                                     values.put(LauncherSettings.Favorites.RESTORED, promiðŸ”µ</abbr>
2049                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="2050                                                     String[] args = new java.lang.String[]{ Long.toString(id) };">2050                                                     String[] args = new java.lang.String[]{ Long.toStringðŸ”µ</abbr>
<abbr title="2051                                                     contentResolver.update(contentUri, values, where, args);">2051                                                     contentResolver.update(contentUri, values, where, argðŸ”µ</abbr>
2052                                                 } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="2053                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed: &quot; + cn, true);">2053                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed:ðŸ”µ</abbr>
2054                                                     itemsToRemove.add(id);
2055                                                     continue;
2056                                                 }
<abbr title="2057                                             } else if (launcherApps.isAppEnabled(manager, cn.getPackageName(), PackageManager.GET_UNINSTALLED_PACKAGES)) {">2057                                             } else if (launcherApps.isAppEnabled(manager, cn.getPackageNaðŸ”µ</abbr>
2058                                                 // Package is present but not available.
2059                                                 allowMissingTarget = true;
2060                                                 disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2061                                             } else if (!isSdCardReady) {
2062                                                 // SdCard is not ready yet. Package might get available,
2063                                                 // once it is ready.
<abbr title="2064                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (check again later)&quot;, true);">2064                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (ðŸ”µ</abbr>
2065                                                 HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2066                                                 if (pkgs == null) {
2067                                                     pkgs = new HashSet&lt;String&gt;();
2068                                                     sPendingPackages.put(user, pkgs);
2069                                                 }
2070                                                 pkgs.add(cn.getPackageName());
2071                                                 allowMissingTarget = true;
2072                                             // Add the icon on the workspace anyway.
2073                                             } else {
2074                                                 // Do not wait for external media load anymore.
2075                                                 // Log the invalid package, and remove it
<abbr title="2076                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn, true);">2076                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cnðŸ”µ</abbr>
2077                                                 itemsToRemove.add(id);
2078                                                 continue;
2079                                             }
2080                                         } else if (cn == null) {
2081                                             // For shortcuts with no component, keep them as they are
2082                                             restoredRows.add(id);
2083                                             restored = false;
2084                                         }
2085                                     } catch (URISyntaxException e) {
<abbr title="2086                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, true);">2086                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, truðŸ”µ</abbr>
2087                                         continue;
2088                                     }
2089                                     if (restored) {
2090                                         if (user.equals(UserHandleCompat.myUserHandle())) {
<abbr title="2091                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially restored package&quot;, true);">2091                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially resðŸ”µ</abbr>
<abbr title="2092                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType);">2092                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseTypeðŸ”µ</abbr>
2093                                             intent = getRestoredItemIntent(c, context, intent);
2094                                         } else {
2095                                             // Don&#x27;t restore items for other profiles.
2096                                             itemsToRemove.add(id);
2097                                             continue;
2098                                         }
<abbr title="2099                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">2099                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATIðŸ”µ</abbr>
<abbr title="2100                                         info = getShortcutInfo(manager, intent, user, context, c, iconIndex, titleIndex, mLabelCache, allowMissingTarget);">2100                                         info = getShortcutInfo(manager, intent, user, context, c, iconIndðŸ”µ</abbr>
2101                                     } else {
<abbr title="2102                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndex, iconResourceIndex, iconIndex, titleIndex);">2102                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndeðŸ”µ</abbr>
2103                                         // App shortcuts that used to be automatically added to Launcher
2104                                         // didn&#x27;t always have the correct intent flags set, so do that
2105                                         // here
<abbr title="2106                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != null)) &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN)) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {">2106                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != ðŸ”µ</abbr>
<abbr title="2107                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">2107                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_AðŸ”µ</abbr>
2108                                         }
2109                                     }
2110                                     if (info != null) {
2111                                         info.id = id;
2112                                         info.intent = intent;
2113                                         container = c.getInt(containerIndex);
2114                                         info.container = container;
2115                                         info.screenId = c.getInt(screenIndex);
2116                                         info.cellX = c.getInt(cellXIndex);
2117                                         info.cellY = c.getInt(cellYIndex);
2118                                         info.spanX = 1;
2119                                         info.spanY = 1;
2120                                         info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2121                                         info.isDisabled = disabledState;
2122                                         if (isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, intent))) {
2123                                             info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2124                                         }
2125                                         // check &amp; update map of what&#x27;s occupied
2126                                         deleteOnInvalidPlacement.set(false);
<abbr title="2127                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {">2127                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)ðŸ”µ</abbr>
2128                                             if (deleteOnInvalidPlacement.get()) {
2129                                                 itemsToRemove.add(id);
2130                                             }
2131                                             break;
2132                                         }
2133                                         switch (container) {
2134                                             case LauncherSettings.Favorites.CONTAINER_DESKTOP :
2135                                             case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2136                                                 sBgWorkspaceItems.add(info);
2137                                                 break;
2138                                             default :
2139                                                 // Item is in a user folder
<abbr title="2140                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, container);">2140                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, contðŸ”µ</abbr>
2141                                                 folderInfo.add(info);
2142                                                 break;
2143                                         }
2144                                         sBgItemsIdMap.put(info.id, info);
2145                                         // now that we&#x27;ve loaded everthing re-save it with the
2146                                         // icon in case it disappears somehow.
2147                                         queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2148                                     } else {
2149                                         throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2150                                     }
2151                                     break;
2152                                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
2153                                     id = c.getLong(idIndex);
2154                                     FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2155                                     folderInfo.title = c.getString(titleIndex);
2156                                     folderInfo.id = id;
2157                                     container = c.getInt(containerIndex);
2158                                     folderInfo.container = container;
2159                                     folderInfo.screenId = c.getInt(screenIndex);
2160                                     folderInfo.cellX = c.getInt(cellXIndex);
2161                                     folderInfo.cellY = c.getInt(cellYIndex);
2162                                     folderInfo.spanX = 1;
2163                                     folderInfo.spanY = 1;
2164                                     // check &amp; update map of what&#x27;s occupied
2165                                     deleteOnInvalidPlacement.set(false);
<abbr title="2166                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacement)) {">2166                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacemenðŸ”µ</abbr>
2167                                         if (deleteOnInvalidPlacement.get()) {
2168                                             itemsToRemove.add(id);
2169                                         }
2170                                         break;
2171                                     }
2172                                     switch (container) {
2173                                         case LauncherSettings.Favorites.CONTAINER_DESKTOP :
2174                                         case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2175                                             sBgWorkspaceItems.add(folderInfo);
2176                                             break;
2177                                     }
2178                                     if (restored) {
2179                                         // no special handling required for restored folders
2180                                         restoredRows.add(id);
2181                                     }
2182                                     sBgItemsIdMap.put(folderInfo.id, folderInfo);
2183                                     sBgFolders.put(folderInfo.id, folderInfo);
2184                                     break;
2185                                 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
2186                                     // Read all Launcher-specific widget details
2187                                     int appWidgetId = c.getInt(appWidgetIdIndex);
2188                                     String savedProvider = c.getString(appWidgetProviderIndex);
2189                                     id = c.getLong(idIndex);
<abbr title="2190                                     final ComponentName component = ComponentName.unflattenFromString(savedProvider);">2190                                     final ComponentName component = ComponentName.unflattenFromString(savðŸ”µ</abbr>
2191                                     final int restoreStatus = c.getInt(restoredIndex);
<abbr title="2192                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;">2192                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAGðŸ”µ</abbr>
<abbr title="2193                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;">2193                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetInðŸ”µ</abbr>
<abbr title="2194                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWidgetInfo(appWidgetId) : findAppWidgetProviderInfoWithComponent(context, component);">2194                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWiðŸ”µ</abbr>
2195                                     final boolean isProviderReady = isValidProvider(provider);
2196                                     if (((!isSafeMode) &amp;&amp; wasProviderReady) &amp;&amp; (!isProviderReady)) {
<abbr title="2197                                         String log = (((&quot;Deleting widget that isn&#x27;t installed anymore: &quot; + &quot;id=&quot;) + id) + &quot; appWidgetId=&quot;) + appWidgetId;">2197                                         String log = (((&quot;Deleting widget that isn&#x27;t installed anymore: &quot; ðŸ”µ</abbr>
2198                                         Log.e(TAG, log);
2199                                         Launcher.addDumpLog(TAG, log, false);
2200                                         itemsToRemove.add(id);
2201                                     } else {
2202                                         if (isProviderReady) {
<abbr title="2203                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider);">2203                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, providðŸ”µ</abbr>
<abbr title="2204                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provider);">2204                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provideðŸ”µ</abbr>
2205                                             appWidgetInfo.minSpanX = minSpan[0];
2206                                             appWidgetInfo.minSpanY = minSpan[1];
2207                                             int status = restoreStatus;
2208                                             if (!wasProviderReady) {
2209                                                 // If provider was not previously ready, update the
2210                                                 // status and UI flag.
<abbr title="2211                                                 // Id would be valid only if the widget restore broadcast was received.">2211                                                 // Id would be valid only if the widget restore broadcastðŸ”µ</abbr>
2212                                                 if (isIdValid) {
2213                                                     status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2214                                                 } else {
<abbr title="2215                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">2215                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_REðŸ”µ</abbr>
2216                                                 }
2217                                             }
2218                                             appWidgetInfo.restoreStatus = status;
2219                                         } else {
<abbr title="2220                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidgetId=&quot;) + appWidgetId) + &quot; status =&quot;) + restoreStatus);">2220                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidgðŸ”µ</abbr>
<abbr title="2221                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, component);">2221                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, componðŸ”µ</abbr>
2222                                             appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2223                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2223                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTðŸ”µ</abbr>
2224                                                 // Restore has started once.
<abbr title="2225                                             } else if (installingPkgs.contains(component.getPackageName())) {">2225                                             } else if (installingPkgs.contains(component.getPackageName()ðŸ”µ</abbr>
2226                                                 // App restore has started. Update the flag
<abbr title="2227                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;">2227                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAGðŸ”µ</abbr>
2228                                             } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="2229                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + component, true);">2229                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + ðŸ”µ</abbr>
2230                                                 itemsToRemove.add(id);
2231                                                 continue;
2232                                             }
2233                                         }
2234                                         appWidgetInfo.id = id;
2235                                         appWidgetInfo.screenId = c.getInt(screenIndex);
2236                                         appWidgetInfo.cellX = c.getInt(cellXIndex);
2237                                         appWidgetInfo.cellY = c.getInt(cellYIndex);
2238                                         appWidgetInfo.spanX = c.getInt(spanXIndex);
2239                                         appWidgetInfo.spanY = c.getInt(spanYIndex);
2240                                         container = c.getInt(containerIndex);
<abbr title="2241                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {">2241                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;ðŸ”µ</abbr>
<abbr title="2242                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);">2242                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DEðŸ”µ</abbr>
2243                                             continue;
2244                                         }
2245                                         appWidgetInfo.container = c.getInt(containerIndex);
2246                                         // check &amp; update map of what&#x27;s occupied
2247                                         deleteOnInvalidPlacement.set(false);
<abbr title="2248                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPlacement)) {">2248                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPðŸ”µ</abbr>
2249                                             if (deleteOnInvalidPlacement.get()) {
2250                                                 itemsToRemove.add(id);
2251                                             }
2252                                             break;
2253                                         }
<abbr title="2254                                         String providerName = appWidgetInfo.providerName.flattenToString();">2254                                         String providerName = appWidgetInfo.providerName.flattenToString(ðŸ”µ</abbr>
<abbr title="2255                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.restoreStatus != restoreStatus)) {">2255                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.restoðŸ”µ</abbr>
2256                                             ContentValues values = new ContentValues();
<abbr title="2257                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, providerName);">2257                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, proðŸ”µ</abbr>
<abbr title="2258                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo.restoreStatus);">2258                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfoðŸ”µ</abbr>
2259                                             String where = BaseColumns._ID + &quot;= ?&quot;;
2260                                             String[] args = new java.lang.String[]{ Long.toString(id) };
2261                                             contentResolver.update(contentUri, values, where, args);
2262                                         }
2263                                         sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2264                                         sBgAppWidgets.add(appWidgetInfo);
2265                                     }
2266                                     break;
2267                             }
2268                         } catch (java.lang.Exception e) {
2269                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2270                         }
2271                     }
2272                 } finally {
2273                     if (c != null) {
2274                         c.close();
2275                     }
2276                 }
2277                 // Break early if we&#x27;ve stopped loading
2278                 if (mStopped) {
2279                     clearSBgDataStructures();
2280                     return false;
2281                 }
2282                 if (itemsToRemove.size() &gt; 0) {
<abbr title="2283                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUri);">2283                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUrðŸ”µ</abbr>
2284                     // Remove dead items
2285                     for (long id : itemsToRemove) {
2286                         if (DEBUG_LOADERS) {
2287                             Log.d(TAG, &quot;Removed id = &quot; + id);
2288                         }
2289                         // Don&#x27;t notify content observers
2290                         try {
<abbr title="2291                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null);">2291                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, nullðŸ”µ</abbr>
2292                         } catch (RemoteException e) {
2293                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2294                         }
2295                     }
2296                 }
2297                 if (restoredRows.size() &gt; 0) {
<abbr title="2298                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentUri);">2298                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentUðŸ”µ</abbr>
2299                     // Update restored items that no longer require special handling
2300                     try {
2301                         StringBuilder selectionBuilder = new StringBuilder();
2302                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2303                         selectionBuilder.append(&quot; IN (&quot;);
2304                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2305                         selectionBuilder.append(&quot;)&quot;);
2306                         ContentValues values = new ContentValues();
2307                         values.put(LauncherSettings.Favorites.RESTORED, 0);
<abbr title="2308                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, selectionBuilder.toString(), null);">2308                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, seðŸ”µ</abbr>
2309                     } catch (RemoteException e) {
2310                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2311                     }
2312                 }
2313                 if ((!isSdCardReady) &amp;&amp; (!sPendingPackages.isEmpty())) {
<abbr title="2314                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiver.SYSTEM_READY), null, sWorker);">2314                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiveðŸ”µ</abbr>
2315                 }
2316                 if (loadedOldDb) {
2317                     long maxScreenId = 0;
2318                     // If we&#x27;re importing we use the old screen order.
2319                     for (ItemInfo item : sBgItemsIdMap.values()) {
2320                         long screenId = item.screenId;
<abbr title="2321                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkspaceScreens.contains(screenId))) {">2321                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkðŸ”µ</abbr>
2322                             sBgWorkspaceScreens.add(screenId);
2323                             if (screenId &gt; maxScreenId) {
2324                                 maxScreenId = screenId;
2325                             }
2326                         }
2327                     }
2328                     Collections.sort(sBgWorkspaceScreens);
2329                     // Log to disk
2330                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
<abbr title="2331                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2331                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, ðŸ”µ</abbr>
2332                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2333                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2334                     // Update the max item id after we load an old db
2335                     long maxItemId = 0;
2336                     // If we&#x27;re importing we use the old screen order.
2337                     for (ItemInfo item : sBgItemsIdMap.values()) {
2338                         maxItemId = Math.max(maxItemId, item.id);
2339                     }
2340                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2341                 } else {
2342                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2343                     for (Integer i : orderedScreens.keySet()) {
2344                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2345                     }
2346                     // Log to disk
<abbr title="2347                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2347                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, ðŸ”µ</abbr>
2348                     // Remove any empty screens
2349                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2350                     for (ItemInfo item : sBgItemsIdMap.values()) {
2351                         long screenId = item.screenId;
<abbr title="2352                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens.contains(screenId)) {">2352                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScrðŸ”µ</abbr>
2353                             unusedScreens.remove(screenId);
2354                         }
2355                     }
2356                     // If there are any empty screens remove them, and update.
2357                     if (unusedScreens.size() != 0) {
2358                         // Log to disk
<abbr title="2359                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtils.join(&quot;, &quot;, unusedScreens), true);">2359                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtiðŸ”µ</abbr>
2360                         sBgWorkspaceScreens.removeAll(unusedScreens);
2361                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2362                     }
2363                 }
2364                 if (DEBUG_LOADERS) {
2365                     Log.d(TAG, (&quot;loaded workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2366                     Log.d(TAG, &quot;workspace layout: &quot;);
2367                     int nScreens = occupied.size();
2368                     for (int y = 0; y &lt; countY; y++) {
2369                         String line = &quot;&quot;;
2370                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2371                         while (iter.hasNext()) {
2372                             long screenId = iter.next();
2373                             if (screenId &gt; 0) {
2374                                 line += &quot; | &quot;;
2375                             }
2376                             for (int x = 0; x &lt; countX; x++) {
2377                                 ItemInfo[][] screen = occupied.get(screenId);
2378                                 if ((x &lt; screen.length) &amp;&amp; (y &lt; screen[x].length)) {
2379                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2380                                 } else {
2381                                     line += &quot;!&quot;;
2382                                 }
2383                             }
2384                         }
2385                         Log.d(TAG, (&quot;[ &quot; + line) + &quot; ]&quot;);
2386                     }
2387                 }
2388             }
2389             return loadedOldDb;
2390         }
2391 
2392         /** Filters the set of items who are directly or indirectly (via another container) on the
2393          * specified screen. */
2394         private void filterCurrentWorkspaceItems(long currentScreenId,
2395                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2396                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2397                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2398             // Purge any null ItemInfos
2399             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2400             while (iter.hasNext()) {
2401                 ItemInfo i = iter.next();
2402                 if (i == null) {
2403                     iter.remove();
2404                 }
2405             }
2406 
2407             // Order the set of items by their containers first, this allows use to walk through the
2408             // list sequentially, build up a list of containers that are in the specified screen,
2409             // as well as all items in those containers.
2410             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2411             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2412                 @Override
2413                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2414                     return (int) (lhs.container - rhs.container);
2415                 }
2416             });
2417             for (ItemInfo info : allWorkspaceItems) {
2418                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2419                     if (info.screenId == currentScreenId) {
2420                         currentScreenItems.add(info);
2421                         itemsOnScreen.add(info.id);
2422                     } else {
2423                         otherScreenItems.add(info);
2424                     }
2425                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2426                     currentScreenItems.add(info);
2427                     itemsOnScreen.add(info.id);
2428                 } else {
2429                     if (itemsOnScreen.contains(info.container)) {
2430                         currentScreenItems.add(info);
2431                         itemsOnScreen.add(info.id);
2432                     } else {
2433                         otherScreenItems.add(info);
2434                     }
2435                 }
2436             }
2437         }
2438 
2439         /** Filters the set of widgets which are on the specified screen. */
2440         private void filterCurrentAppWidgets(long currentScreenId,
2441                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2442                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2443                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2444 
2445             for (LauncherAppWidgetInfo widget : appWidgets) {
2446                 if (widget == null) continue;
2447                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2448                         widget.screenId == currentScreenId) {
2449                     currentScreenWidgets.add(widget);
2450                 } else {
2451                     otherScreenWidgets.add(widget);
2452                 }
2453             }
2454         }
2455 
2456         /** Filters the set of folders which are on the specified screen. */
2457         private void filterCurrentFolders(long currentScreenId,
2458                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2459                 HashMap&lt;Long, FolderInfo&gt; folders,
2460                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2461                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2462 
2463             for (long id : folders.keySet()) {
2464                 ItemInfo info = itemsIdMap.get(id);
2465                 FolderInfo folder = folders.get(id);
2466                 if (info == null || folder == null) continue;
2467                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2468                         info.screenId == currentScreenId) {
2469                     currentScreenFolders.put(id, folder);
2470                 } else {
2471                     otherScreenFolders.put(id, folder);
2472                 }
2473             }
2474         }
2475 
2476         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2477          * right) */
2478         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2479             final LauncherAppState app = LauncherAppState.getInstance();
2480             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2481             // XXX: review this
2482             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2483                 @Override
2484                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2485                     int cellCountX = (int) grid.numColumns;
2486                     int cellCountY = (int) grid.numRows;
2487                     int screenOffset = cellCountX * cellCountY;
2488                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2489                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2490                             lhs.cellY * cellCountX + lhs.cellX);
2491                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2492                             rhs.cellY * cellCountX + rhs.cellX);
2493                     return (int) (lr - rr);
2494                 }
2495             });
2496         }
2497 
2498         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2499                 final ArrayList&lt;Long&gt; orderedScreens) {
2500             final Runnable r = new Runnable() {
2501                 @Override
2502                 public void run() {
2503                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2504                     if (callbacks != null) {
2505                         callbacks.bindScreens(orderedScreens);
2506                     }
2507                 }
2508             };
2509             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2510         }
2511 
2512         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2513                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2514                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2515                 final HashMap&lt;Long, FolderInfo&gt; folders,
2516                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2517 
2518             final boolean postOnMainThread = (deferredBindRunnables != null);
2519 
2520             // Bind the workspace items
2521             int N = workspaceItems.size();
2522             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2523                 final int start = i;
2524                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2525                 final Runnable r = new Runnable() {
2526                     @Override
2527                     public void run() {
2528                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2529                         if (callbacks != null) {
2530                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2531                                     false);
2532                         }
2533                     }
2534                 };
2535                 if (postOnMainThread) {
2536                     synchronized (deferredBindRunnables) {
2537                         deferredBindRunnables.add(r);
2538                     }
2539                 } else {
2540                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2541                 }
2542             }
2543 
2544             // Bind the folders
2545             if (!folders.isEmpty()) {
2546                 final Runnable r = new Runnable() {
2547                     public void run() {
2548                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2549                         if (callbacks != null) {
2550                             callbacks.bindFolders(folders);
2551                         }
2552                     }
2553                 };
2554                 if (postOnMainThread) {
2555                     synchronized (deferredBindRunnables) {
2556                         deferredBindRunnables.add(r);
2557                     }
2558                 } else {
2559                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2560                 }
2561             }
2562 
2563             // Bind the widgets, one at a time
2564             N = appWidgets.size();
2565             for (int i = 0; i &lt; N; i++) {
2566                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2567                 final Runnable r = new Runnable() {
2568                     public void run() {
2569                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2570                         if (callbacks != null) {
2571                             callbacks.bindAppWidget(widget);
2572                         }
2573                     }
2574                 };
2575                 if (postOnMainThread) {
2576                     deferredBindRunnables.add(r);
2577                 } else {
2578                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2579                 }
2580             }
2581         }
2582 
2583         /**
2584          * Binds all loaded data to actual views on the main thread.
2585          */
2586         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2587             final long t = SystemClock.uptimeMillis();
2588             Runnable r;
2589 
2590             // Don&#x27;t use these two variables in any of the callback runnables.
2591             // Otherwise we hold a reference to them.
2592             final Callbacks oldCallbacks = mCallbacks.get();
2593             if (oldCallbacks == null) {
2594                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2595                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2596                 return;
2597             }
2598 
2599             // Save a copy of all the bg-thread collections
2600             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2601             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2602                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2603             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2604             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2605             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2606             synchronized (sBgLock) {
2607                 workspaceItems.addAll(sBgWorkspaceItems);
2608                 appWidgets.addAll(sBgAppWidgets);
2609                 folders.putAll(sBgFolders);
2610                 itemsIdMap.putAll(sBgItemsIdMap);
2611                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2612             }
2613 
2614             final boolean isLoadingSynchronously =
2615                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2616             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2617                 oldCallbacks.getCurrentWorkspaceScreen();
2618             if (currScreen &gt;= orderedScreenIds.size()) {
2619                 // There may be no workspace screens (just hotseat items and an empty page).
2620                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2621             }
2622             final int currentScreen = currScreen;
2623             final long currentScreenId = currentScreen &lt; 0
2624                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2625 
2626             // Load all the items that are on the current page first (and in the process, unbind
2627             // all the existing workspace items before we call startBinding() below.
2628             unbindWorkspaceItemsOnMainThread();
2629 
2630             // Separate the items that are on the current screen, and all the other remaining items
2631             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2632             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2633             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2634                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2635             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2636                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2637             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2638             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2639 
2640             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2641                     otherWorkspaceItems);
2642             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2643                     otherAppWidgets);
2644             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2645                     otherFolders);
2646             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2647             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2648 
2649             // Tell the workspace that we&#x27;re about to start binding items
2650             r = new Runnable() {
2651                 public void run() {
2652                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2653                     if (callbacks != null) {
2654                         callbacks.startBinding();
2655                     }
2656                 }
2657             };
2658             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2659 
2660             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2661 
2662             // Load items on the current page
2663             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2664                     currentFolders, null);
2665             if (isLoadingSynchronously) {
2666                 r = new Runnable() {
2667                     public void run() {
2668                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2669                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2670                             callbacks.onPageBoundSynchronously(currentScreen);
2671                         }
2672                     }
2673                 };
2674                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2675             }
2676 
2677             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2678             // work until after the first render)
2679             synchronized (mDeferredBindRunnables) {
2680                 mDeferredBindRunnables.clear();
2681             }
2682             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2683                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2684 
2685             // Tell the workspace that we&#x27;re done binding items
2686             r = new Runnable() {
2687                 public void run() {
2688                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2689                     if (callbacks != null) {
2690                         callbacks.finishBindingItems(isUpgradePath);
2691                     }
2692 
2693                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2694                     if (DEBUG_LOADERS) {
2695                         Log.d(TAG, &quot;bound workspace in &quot;
2696                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2697                     }
2698 
2699                     mIsLoadingAndBindingWorkspace = false;
2700                 }
2701             };
2702             if (isLoadingSynchronously) {
2703                 synchronized (mDeferredBindRunnables) {
2704                     mDeferredBindRunnables.add(r);
2705                 }
2706             } else {
2707                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2708             }
2709         }
2710 
2711         private void loadAndBindAllApps() {
2712             if (DEBUG_LOADERS) {
2713                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2714             }
2715             if (!mAllAppsLoaded) {
2716                 loadAllApps();
2717                 synchronized (LoaderTask.this) {
2718                     if (mStopped) {
2719                         return;
2720                     }
2721                     mAllAppsLoaded = true;
2722                 }
2723             } else {
2724                 onlyBindAllApps();
2725             }
2726         }
2727 
2728         private void onlyBindAllApps() {
2729             final Callbacks oldCallbacks = mCallbacks.get();
2730             if (oldCallbacks == null) {
2731                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2732                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2733                 return;
2734             }
2735 
2736             // shallow copy
2737             @SuppressWarnings(&quot;unchecked&quot;)
2738             final ArrayList&lt;AppInfo&gt; list
2739                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2740             Runnable r = new Runnable() {
2741                 public void run() {
2742                     final long t = SystemClock.uptimeMillis();
2743                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2744                     if (callbacks != null) {
2745                         callbacks.bindAllApplications(list);
2746                     }
2747                     if (DEBUG_LOADERS) {
2748                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2749                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2750                     }
2751                 }
2752             };
2753             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2754             if (isRunningOnMainThread) {
2755                 r.run();
2756             } else {
2757                 mHandler.post(r);
2758             }
2759         }
2760 
2761         private void loadAllApps() {
2762             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2763 
2764             final Callbacks oldCallbacks = mCallbacks.get();
2765             if (oldCallbacks == null) {
2766                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2767                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2768                 return;
2769             }
2770 
2771             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2772             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2773 
2774             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2775 
2776             // Clear the list of apps
2777             mBgAllAppsList.clear();
2778             for (UserHandleCompat user : profiles) {
2779                 // Query for the set of apps
2780                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2781                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2782                 if (DEBUG_LOADERS) {
2783                     Log.d(TAG, &quot;getActivityList took &quot;
2784                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2785                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2786                 }
2787                 // Fail if we don&#x27;t have any apps
2788                 if (apps == null || apps.isEmpty()) {
2789                     return;
2790                 }
2791                 // Sort the applications by name
2792                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2793                 Collections.sort(apps,
2794                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2795                 if (DEBUG_LOADERS) {
2796                     Log.d(TAG, &quot;sort took &quot;
2797                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2798                 }
2799 
2800                 // Create the ApplicationInfos
2801                 for (int i = 0; i &lt; apps.size(); i++) {
2802                     LauncherActivityInfoCompat app = apps.get(i);
2803                     // This builds the icon bitmaps.
2804                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2805                 }
2806             }
2807             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2808             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2809             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2810 
2811             // Post callback on main thread
2812             mHandler.post(new Runnable() {
2813                 public void run() {
2814                     final long bindTime = SystemClock.uptimeMillis();
2815                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2816                     if (callbacks != null) {
2817                         callbacks.bindAllApplications(added);
2818                         if (DEBUG_LOADERS) {
2819                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2820                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2821                         }
2822                     } else {
2823                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2824                     }
2825                 }
2826             });
2827 
2828             if (DEBUG_LOADERS) {
2829                 Log.d(TAG, &quot;Icons processed in &quot;
2830                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2831             }
2832         }
2833 
2834         public void dumpState() {
2835             synchronized (sBgLock) {
2836                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2837                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2838                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2839                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2840                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2841             }
2842         }
2843     }
2844 
2845     void enqueuePackageUpdated(PackageUpdatedTask task) {
2846         sWorker.post(task);
2847     }
2848 
2849     private class AppsAvailabilityCheck extends BroadcastReceiver {
2850         @Override
2851         public void onReceive(Context context, Intent intent) {
2852             synchronized(sBgLock) {
<abbr title="2853                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext());">2853                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext())ðŸ”µ</abbr>
2854                 final PackageManager manager = context.getPackageManager();
2855                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2856                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2857                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2858                     UserHandleCompat user = entry.getKey();
2859                     packagesRemoved.clear();
2860                     packagesUnavailable.clear();
2861                     for (String pkg : entry.getValue()) {
2862                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
<abbr title="2863                             boolean packageOnSdcard = launcherApps.isAppEnabled(manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);">2863                             boolean packageOnSdcard = launcherApps.isAppEnabled(manager, pkg, PackageManaðŸ”µ</abbr>
2864                             if (packageOnSdcard) {
2865                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2866                                 packagesUnavailable.add(pkg);
2867                             } else {
2868                                 Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2869                                 packagesRemoved.add(pkg);
2870                             }
2871                         }
2872                     }
2873                     if (!packagesRemoved.isEmpty()) {
<abbr title="2874                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packagesRemoved.toArray(new String[packagesRemoved.size()]), user));">2874                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packagðŸ”µ</abbr>
2875                     }
2876                     if (!packagesUnavailable.isEmpty()) {
<abbr title="2877                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">2877                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, pðŸ”µ</abbr>
2878                     }
2879                 }
2880                 sPendingPackages.clear();
2881             }
2882         }
2883     }
2884 
2885     /**
2886      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2887      * runnable was missed by the launcher.
2888      */
2889     public void recheckRestoredItems(final Context context) {
2890         Runnable r = new Runnable() {
2891 
2892             @Override
2893             public void run() {
2894                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2895                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2896                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2897                 synchronized(sBgLock) {
2898                     for (ItemInfo info : sBgItemsIdMap.values()) {
2899                         if (info instanceof ShortcutInfo) {
2900                             ShortcutInfo si = (ShortcutInfo) info;
2901                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
2902                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2903                                             si.getTargetComponent().getPackageName(), user)) {
2904                                 installedPackages.add(si.getTargetComponent().getPackageName());
2905                             }
2906                         } else if (info instanceof LauncherAppWidgetInfo) {
2907                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
2908                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
2909                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2910                                             widget.providerName.getPackageName(), user)) {
2911                                 installedPackages.add(widget.providerName.getPackageName());
2912                             }
2913                         }
2914                     }
2915                 }
2916 
2917                 if (!installedPackages.isEmpty()) {
2918                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
2919                     for (String pkg : installedPackages) {
2920                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
2921                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
2922                         }
2923                     }
2924 
2925                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2926                     if (!restoredApps.isEmpty()) {
2927                         mHandler.post(new Runnable() {
2928                             public void run() {
2929                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2930                                 if (callbacks == cb &amp;&amp; cb != null) {
2931                                     callbacks.bindAppsRestored(restoredApps);
2932                                 }
2933                             }
2934                         });
2935                     }
2936 
2937                 }
2938             }
2939         };
2940         sWorker.post(r);
2941     }
2942 
2943     private class PackageUpdatedTask implements Runnable {
2944         int mOp;
2945 
2946         String[] mPackages;
2947 
2948         UserHandleCompat mUser;
2949 
2950         public static final int OP_NONE = 0;
2951 
2952         public static final int OP_ADD = 1;
2953 
2954         public static final int OP_UPDATE = 2;
2955 
2956         // uninstlled
2957         public static final int OP_REMOVE = 3; // uninstlled
2958 
2959         // external media unmounted
2960         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2961 
2962         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
2963             mOp = op;
2964             mPackages = packages;
2965             mUser = user;
2966         }
2967 
2968         public void run() {
2969             final Context context = mApp.getContext();
2970             final String[] packages = mPackages;
2971             final int N = packages.length;
2972             switch (mOp) {
2973                 case OP_ADD :
2974                     for (int i = 0; i &lt; N; i++) {
2975                         if (DEBUG_LOADERS) {
2976                             Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2977                         }
2978                         mIconCache.remove(packages[i], mUser);
2979                         mBgAllAppsList.addPackage(context, packages[i], mUser);
2980                     }
2981                     break;
2982                 case OP_UPDATE :
2983                     for (int i = 0; i &lt; N; i++) {
2984                         if (DEBUG_LOADERS) {
2985                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2986                         }
2987                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
<abbr title="2988                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2988                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[ðŸ”µ</abbr>
2989                     }
2990                     break;
2991                 case OP_REMOVE :
2992                 case OP_UNAVAILABLE :
2993                     boolean clearCache = mOp == OP_REMOVE;
2994                     for (int i = 0; i &lt; N; i++) {
2995                         if (DEBUG_LOADERS) {
2996                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2997                         }
2998                         mBgAllAppsList.removePackage(packages[i], mUser, clearCache);
<abbr title="2999                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2999                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[ðŸ”µ</abbr>
3000                     }
3001                     break;
3002             }
3003             ArrayList&lt;AppInfo&gt; added = null;
3004             ArrayList&lt;AppInfo&gt; modified = null;
3005             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3006             if (mBgAllAppsList.added.size() &gt; 0) {
3007                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3008                 mBgAllAppsList.added.clear();
3009             }
3010             if (mBgAllAppsList.modified.size() &gt; 0) {
3011                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3012                 mBgAllAppsList.modified.clear();
3013             }
3014             if (mBgAllAppsList.removed.size() &gt; 0) {
3015                 removedApps.addAll(mBgAllAppsList.removed);
3016                 mBgAllAppsList.removed.clear();
3017             }
3018             final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
3019             if (callbacks == null) {
3020                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3021                 return;
3022             }
3023             if (added != null) {
3024                 // Ensure that we add all the workspace applications to the db
3025                 if (LauncherAppState.isDisableAllApps()) {
3026                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3027                     addAndBindAddedWorkspaceApps(context, addedInfos);
3028                 } else {
3029                     addAppsToAllApps(context, added);
3030                 }
3031             }
3032             if (modified != null) {
3033                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3034                 // Update the launcher db to reflect the changes
3035                 for (AppInfo a : modifiedFinal) {
3036                     ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3037                     for (ItemInfo i : infos) {
3038                         if ((i instanceof ShortcutInfo) &amp;&amp; isShortcutAppTarget(((ShortcutInfo) (i)))) {
3039                             ShortcutInfo info = ((ShortcutInfo) (i));
3040                             info.title = a.title.toString();
3041                             info.contentDescription = a.contentDescription;
3042                             updateItemInDatabase(context, info);
3043                         }
3044                     }
3045                 }
3046                 mHandler.post(new Runnable() {
3047                     public void run() {
3048                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
3049                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
3050                             callbacks.bindAppsUpdated(modifiedFinal);
3051                         }
3052                     }
3053                 });
3054             }
3055             // Update shortcuts which use an iconResource
3056             if ((mOp == OP_ADD) || (mOp == OP_UPDATE)) {
3057                 final ArrayList&lt;ShortcutInfo&gt; iconsChanged = new ArrayList&lt;ShortcutInfo&gt;();
3058                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3059                 // We need to iterate over the items here, so that we can avoid new Bitmap
3060                 // creation on the UI thread.
3061                 synchronized(sBgLock) {
3062                     for (ItemInfo info : sBgWorkspaceItems) {
3063                         if ((info instanceof ShortcutInfo) &amp;&amp; mUser.equals(info.user)) {
3064                             ShortcutInfo si = ((ShortcutInfo) (info));
<abbr title="3065                             if ((si.iconResource != null) &amp;&amp; packageSet.contains(si.getTargetComponent().getPackageName())) {">3065                             if ((si.iconResource != null) &amp;&amp; packageSet.contains(si.getTargetComponent().ðŸ”µ</abbr>
<abbr title="3066                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName, si.iconResource.resourceName, mIconCache, context);">3066                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName, si.ðŸ”µ</abbr>
3067                                 if (icon != null) {
3068                                     si.setIcon(icon);
3069                                     si.usingFallbackIcon = false;
3070                                     iconsChanged.add(si);
3071                                     updateItemInDatabase(context, si);
3072                                 }
3073                             }
3074                         }
3075                     }
3076                 }
3077                 if (!iconsChanged.isEmpty()) {
3078                     mHandler.post(new Runnable() {
3079                         public void run() {
3080                             Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
3081                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
3082                                 callbacks.bindShortcutsUpdated(iconsChanged);
3083                             }
3084                         }
3085                     });
3086                 }
3087             }
3088             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
3089             if ((mOp == OP_REMOVE) || (mOp == OP_UNAVAILABLE)) {
3090                 // Mark all packages in the broadcast to be removed
3091                 removedPackageNames.addAll(Arrays.asList(packages));
3092             } else if (mOp == OP_UPDATE) {
3093                 // Mark disabled packages in the broadcast to be removed
3094                 for (int i = 0; i &lt; N; i++) {
3095                     if (isPackageDisabled(context, packages[i], mUser)) {
3096                         removedPackageNames.add(packages[i]);
3097                     }
3098                 }
3099             }
3100             if ((!removedPackageNames.isEmpty()) || (!removedApps.isEmpty())) {
3101                 final int removeReason;
3102                 if (mOp == OP_UNAVAILABLE) {
3103                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3104                 } else {
3105                     // Remove all the components associated with this package
3106                     for (String pn : removedPackageNames) {
3107                         deletePackageFromDatabase(context, pn, mUser);
3108                     }
3109                     // Remove all the specific components
3110                     for (AppInfo a : removedApps) {
3111                         ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3112                         deleteItemsFromDatabase(context, infos);
3113                     }
3114                     removeReason = 0;
3115                 }
3116                 // Remove any queued items from the install queue
3117                 String spKey = LauncherAppState.getSharedPreferencesKey();
3118                 SharedPreferences sp = context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3119                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3120                 // Call the components-removed callback
3121                 mHandler.post(new Runnable() {
3122                     public void run() {
3123                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
3124                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
<abbr title="3125                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser, removeReason);">3125                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser, remoðŸ”µ</abbr>
3126                         }
3127                     }
3128                 });
3129             }
3130             final ArrayList&lt;Object&gt; widgetsAndShortcuts = getSortedWidgetsAndShortcuts(context);
3131             mHandler.post(new Runnable() {
3132                 @Override
3133                 public void run() {
3134                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
3135                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
3136                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3137                     }
3138                 }
3139             });
3140             // Write all the logs to disk
3141             mHandler.post(new Runnable() {
3142                 public void run() {
3143                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
3144                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
3145                         callbacks.dumpLogsToLocalData();
3146                     }
3147                 }
3148             });
3149         }
3150     }
3151 
3152     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3153     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3154         PackageManager packageManager = context.getPackageManager();
3155         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3156         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3157 
3158         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3159         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3160         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3161         return widgetsAndShortcuts;
3162     }
3163 
3164     private static boolean isPackageDisabled(Context context, String packageName,
3165             UserHandleCompat user) {
3166         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3167         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3168     }
3169 
3170     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3171             UserHandleCompat user) {
3172         if (cn == null) {
3173             return false;
3174         }
3175         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3176         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3177             return false;
3178         }
3179         return launcherApps.isActivityEnabledForProfile(cn, user);
3180     }
3181 
3182     public static boolean isValidPackage(Context context, String packageName,
3183             UserHandleCompat user) {
3184         if (packageName == null) {
3185             return false;
3186         }
3187         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3188         return launcherApps.isPackageEnabledForProfile(packageName, user);
3189     }
3190 
3191     /**
3192      * Make an ShortcutInfo object for a restored application or shortcut item that points
3193      * to a package that is not yet installed on the system.
3194      */
3195     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3196             int promiseType) {
3197         final ShortcutInfo info = new ShortcutInfo();
3198         info.user = UserHandleCompat.myUserHandle();
3199         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3200 
3201         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3202             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3203             if (!TextUtils.isEmpty(title)) {
3204                 info.title = title;
3205             }
3206             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3207         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3208             if (TextUtils.isEmpty(info.title)) {
3209                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3210             }
3211             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3212         } else {
3213             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3214         }
3215 
3216         info.contentDescription = mUserManager.getBadgedLabelForUser(
3217                 info.title.toString(), info.user);
3218         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3219         info.promisedIntent = intent;
3220         return info;
3221     }
3222 
3223     /**
3224      * Make an Intent object for a restored application or shortcut item that points
3225      * to the market page for the item.
3226      */
3227     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3228         ComponentName componentName = intent.getComponent();
3229         return getMarketIntent(componentName.getPackageName());
3230     }
3231 
3232     static Intent getMarketIntent(String packageName) {
3233         return new Intent(Intent.ACTION_VIEW)
3234             .setData(new Uri.Builder()
3235                 .scheme(&quot;market&quot;)
3236                 .authority(&quot;details&quot;)
3237                 .appendQueryParameter(&quot;id&quot;, packageName)
3238                 .build());
3239     }
3240 
3241     /**
3242      * This is called from the code that adds shortcuts from the intent receiver.  This
3243      * doesn&#x27;t have a Cursor, but
3244      */
3245     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3246             UserHandleCompat user, Context context) {
3247         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3248     }
3249 
3250     /**
3251      * Make an ShortcutInfo object for a shortcut that is an application.
3252      *
3253      * If c is not null, then it will be used to fill in missing data like the title and icon.
3254      */
3255     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3256             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3257             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3258         if (user == null) {
3259             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3260             return null;
3261         }
3262 
3263         ComponentName componentName = intent.getComponent();
3264         if (componentName == null) {
3265             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3266             return null;
3267         }
3268 
3269         Intent newIntent = new Intent(intent.getAction(), null);
3270         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3271         newIntent.setComponent(componentName);
3272         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3273         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3274             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3275             return null;
3276         }
3277 
3278         final ShortcutInfo info = new ShortcutInfo();
3279 
3280         // the resource -- This may implicitly give us back the fallback icon,
3281         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3282         // to avoid saving lots of copies of that in the database, and most apps
3283         // have icons anyway.
3284         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3285 
3286         // the db
3287         if (icon == null) {
3288             if (c != null) {
3289                 icon = getIconFromCursor(c, iconIndex, context);
3290             }
3291         }
3292         // the fallback icon
3293         if (icon == null) {
3294             icon = mIconCache.getDefaultIcon(user);
3295             info.usingFallbackIcon = true;
3296         }
3297         info.setIcon(icon);
3298 
3299         // From the cache.
3300         if (labelCache != null) {
3301             info.title = labelCache.get(componentName);
3302         }
3303 
3304         // from the resource
3305         if (info.title == null &amp;&amp; lai != null) {
3306             info.title = lai.getLabel();
3307             if (labelCache != null) {
3308                 labelCache.put(componentName, info.title);
3309             }
3310         }
3311         // from the db
3312         if (info.title == null) {
3313             if (c != null) {
3314                 info.title =  c.getString(titleIndex);
3315             }
3316         }
3317         // fall back to the class name of the activity
3318         if (info.title == null) {
3319             info.title = componentName.getClassName();
3320         }
3321         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3322         info.user = user;
3323         info.contentDescription = mUserManager.getBadgedLabelForUser(
3324                 info.title.toString(), info.user);
3325         return info;
3326     }
3327 
3328     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3329             ItemInfoFilter f) {
3330         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3331         for (ItemInfo i : infos) {
3332             if (i instanceof ShortcutInfo) {
3333                 ShortcutInfo info = (ShortcutInfo) i;
3334                 ComponentName cn = info.getTargetComponent();
3335                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3336                     filtered.add(info);
3337                 }
3338             } else if (i instanceof FolderInfo) {
3339                 FolderInfo info = (FolderInfo) i;
3340                 for (ShortcutInfo s : info.contents) {
3341                     ComponentName cn = s.getTargetComponent();
3342                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3343                         filtered.add(s);
3344                     }
3345                 }
3346             } else if (i instanceof LauncherAppWidgetInfo) {
3347                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3348                 ComponentName cn = info.providerName;
3349                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3350                     filtered.add(info);
3351                 }
3352             }
3353         }
3354         return new ArrayList&lt;ItemInfo&gt;(filtered);
3355     }
3356 
3357     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3358             final UserHandleCompat user) {
3359         ItemInfoFilter filter  = new ItemInfoFilter() {
3360             @Override
3361             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3362                 if (info.user == null) {
3363                     return cn.equals(cname);
3364                 } else {
3365                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3366                 }
3367             }
3368         };
3369         return filterItemInfos(sBgItemsIdMap.values(), filter);
3370     }
3371 
3372     /**
3373      * @return true if the ShortcutInfo points to an app shortcut target, i.e. it has been added by
3374      * dragging from AllApps list.
3375      */
3376     public static boolean isShortcutAppTarget(ShortcutInfo info) {
3377             // We need to check for ACTION_MAIN otherwise getComponent() might
3378             // return null for some shortcuts (for instance, for shortcuts to
3379             // web pages.)
3380         Intent intent = (info.promisedIntent != null) ? info.promisedIntent : info.intent;
3381         ComponentName name = intent.getComponent();
<abbr title="3382         return ((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAIN.equals(intent.getAction())) &amp;&amp; (name != null);">3382         return ((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAINðŸ”µ</abbr>
3383     }
3384 
3385     /**
3386      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3387      */
<abbr title="3388     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex, int titleIndex) {">3388     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageIndðŸ”µ</abbr>
3389         Bitmap icon = null;
3390         final ShortcutInfo info = new ShortcutInfo();
3391         // Non-app shortcuts are only supported for current user.
3392         info.user = UserHandleCompat.myUserHandle();
3393         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3394         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3395         info.title = c.getString(titleIndex);
3396         int iconType = c.getInt(iconTypeIndex);
3397         switch (iconType) {
3398             case LauncherSettings.Favorites.ICON_TYPE_RESOURCE :
3399                 String packageName = c.getString(iconPackageIndex);
3400                 String resourceName = c.getString(iconResourceIndex);
3401                 info.customIcon = false;
3402             // the resource
3403                 icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);
3404                 // the db
3405                 if (icon == null) {
3406                     icon = getIconFromCursor(c, iconIndex, context);
3407                 }
3408                 // the fallback icon
3409                 if (icon == null) {
3410                     icon = mIconCache.getDefaultIcon(info.user);
3411                     info.usingFallbackIcon = true;
3412                 }
3413                 break;
3414             case LauncherSettings.Favorites.ICON_TYPE_BITMAP :
3415                 icon = getIconFromCursor(c, iconIndex, context);
3416                 if (icon == null) {
3417                     icon = mIconCache.getDefaultIcon(info.user);
3418                     info.customIcon = false;
3419                     info.usingFallbackIcon = true;
3420                 } else {
3421                     info.customIcon = true;
3422                 }
3423                 break;
3424             default :
3425                 icon = mIconCache.getDefaultIcon(info.user);
3426                 info.usingFallbackIcon = true;
3427                 info.customIcon = false;
3428                 break;
3429         }
3430         info.setIcon(icon);
3431         return info;
3432     }
3433 
3434     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3435         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3436         final boolean debug = false;
3437         if (debug) {
3438             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3439                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3440         }
3441         byte[] data = c.getBlob(iconIndex);
3442         try {
3443             return Utilities.createIconBitmap(
3444                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3445         } catch (Exception e) {
3446             return null;
3447         }
3448     }
3449 
3450     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3451             int cellX, int cellY, boolean notify) {
3452         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3453         if (info == null) {
3454             return null;
3455         }
3456         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3457 
3458         return info;
3459     }
3460 
3461     /**
3462      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3463      */
3464     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3465             ComponentName component) {
3466         List&lt;AppWidgetProviderInfo&gt; widgets =
3467             AppWidgetManager.getInstance(context).getInstalledProviders();
3468         for (AppWidgetProviderInfo info : widgets) {
3469             if (info.provider.equals(component)) {
3470                 return info;
3471             }
3472         }
3473         return null;
3474     }
3475 
3476     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3477         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3478         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3479         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3480         if (intent == null) {
3481             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3482             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3483             return null;
3484         }
3485         Bitmap icon = null;
3486         boolean customIcon = false;
3487         ShortcutIconResource iconResource = null;
3488         if (bitmap instanceof Bitmap) {
3489             icon = Utilities.createIconBitmap(((Bitmap) (bitmap)), context);
3490             customIcon = true;
3491         } else {
3492             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3493             if (extra instanceof ShortcutIconResource) {
3494                 iconResource = ((ShortcutIconResource) (extra));
<abbr title="3495                 icon = Utilities.createIconBitmap(iconResource.packageName, iconResource.resourceName, mIconCache, context);">3495                 icon = Utilities.createIconBitmap(iconResource.packageName, iconResource.resourceName, mIðŸ”µ</abbr>
3496             }
3497         }
3498         final ShortcutInfo info = new ShortcutInfo();
3499         // Only support intents for current user for now. Intents sent from other
3500         // users wouldn&#x27;t get here without intent forwarding anyway.
3501         info.user = UserHandleCompat.myUserHandle();
3502         if (icon == null) {
3503             if (fallbackIcon != null) {
3504                 icon = fallbackIcon;
3505             } else {
3506                 icon = mIconCache.getDefaultIcon(info.user);
3507                 info.usingFallbackIcon = true;
3508             }
3509         }
3510         info.setIcon(icon);
3511         info.title = name;
3512         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
3513         info.intent = intent;
3514         info.customIcon = customIcon;
3515         info.iconResource = iconResource;
3516         return info;
3517     }
3518 
3519     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3520             int iconIndex) {
3521         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3522         if (!mAppsCanBeOnRemoveableStorage) {
3523             return false;
3524         }
3525         // If this icon doesn&#x27;t have a custom icon, check to see
3526         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3527         // we&#x27;re going to show, store what we are going to show back
3528         // into the DB.  We do this so when we&#x27;re loading, if the
3529         // package manager can&#x27;t find an icon (for example because
3530         // the app is on SD) then we can use that instead.
3531         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3532             cache.put(info, c.getBlob(iconIndex));
3533             return true;
3534         }
3535         return false;
3536     }
3537 
3538     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3539         boolean needSave = false;
3540         try {
3541             if (data != null) {
3542                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3543                 Bitmap loaded = info.getIcon(mIconCache);
3544                 needSave = !saved.sameAs(loaded);
3545             } else {
3546                 needSave = true;
3547             }
3548         } catch (Exception e) {
3549             needSave = true;
3550         }
3551         if (needSave) {
3552             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3553             // This is slower than is ideal, but this only happens once
3554             // or when the app is updated with a new icon.
3555             updateItemInDatabase(context, info);
3556         }
3557     }
3558 
3559     /**
3560      * Return an existing FolderInfo object if we have encountered this ID previously,
3561      * or make a new one.
3562      */
3563     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3564         // See if a placeholder was created for us already
3565         FolderInfo folderInfo = folders.get(id);
3566         if (folderInfo == null) {
3567             // No placeholder -- create a new instance
3568             folderInfo = new FolderInfo();
3569             folders.put(id, folderInfo);
3570         }
3571         return folderInfo;
3572     }
3573 
3574     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3575         final Collator collator = Collator.getInstance();
3576         return new Comparator&lt;AppInfo&gt;() {
3577             public final int compare(AppInfo a, AppInfo b) {
3578                 if (a.user.equals(b.user)) {
3579                     int result = collator.compare(a.title.toString().trim(),
3580                             b.title.toString().trim());
3581                     if (result == 0) {
3582                         result = a.componentName.compareTo(b.componentName);
3583                     }
3584                     return result;
3585                 } else {
3586                     // TODO Need to figure out rules for sorting
3587                     // profiles, this puts work second.
3588                     return a.user.toString().compareTo(b.user.toString());
3589                 }
3590             }
3591         };
3592     }
3593 
3594     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;AppInfo&gt;() {
3595         public final int compare(AppInfo a, AppInfo b) {
3596             if (a.firstInstallTime &lt; b.firstInstallTime) {
3597                 return 1;
3598             }
3599             if (a.firstInstallTime &gt; b.firstInstallTime) {
3600                 return -1;
3601             }
3602             return 0;
3603         }
3604     };
3605 
3606     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3607         if (info.activityInfo != null) {
3608             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3609         } else {
3610             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3611         }
3612     }
3613 
3614     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3615         private Collator mCollator;
3616 
3617         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3618 
3619         ShortcutNameComparator(PackageManager pm) {
3620             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3621             mCollator = Collator.getInstance();
3622         }
3623 
3624         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3625             mLabelCache = labelCache;
3626             mCollator = Collator.getInstance();
3627         }
3628 
3629         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3630             String labelA;
3631             String labelB;
3632             ComponentName keyA = a.getComponentName();
3633             ComponentName keyB = b.getComponentName();
3634             if (mLabelCache.containsKey(keyA)) {
3635                 labelA = mLabelCache.get(keyA).toString();
3636             } else {
3637                 labelA = a.getLabel().toString().trim();
3638                 mLabelCache.put(keyA, labelA);
3639             }
3640             if (mLabelCache.containsKey(keyB)) {
3641                 labelB = mLabelCache.get(keyB).toString();
3642             } else {
3643                 labelB = b.getLabel().toString().trim();
3644                 mLabelCache.put(keyB, labelB);
3645             }
3646             return mCollator.compare(labelA, labelB);
3647         }
3648     }
3649 
3650     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3651         private final AppWidgetManagerCompat mManager;
3652 
3653         private final PackageManager mPackageManager;
3654 
3655         private final HashMap&lt;Object, String&gt; mLabelCache;
3656 
3657         private final Collator mCollator;
3658 
3659         WidgetAndShortcutNameComparator(Context context) {
3660             mManager = AppWidgetManagerCompat.getInstance(context);
3661             mPackageManager = context.getPackageManager();
3662             mLabelCache = new HashMap&lt;Object, String&gt;();
3663             mCollator = Collator.getInstance();
3664         }
3665 
3666         public final int compare(Object a, Object b) {
3667             String labelA;
3668             String labelB;
3669             if (mLabelCache.containsKey(a)) {
3670                 labelA = mLabelCache.get(a);
3671             } else {
<abbr title="3672                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (a))) : ((ResolveInfo) (a)).loadLabel(mPackageManager).toString().trim();">3672                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfðŸ”µ</abbr>
3673                 mLabelCache.put(a, labelA);
3674             }
3675             if (mLabelCache.containsKey(b)) {
3676                 labelB = mLabelCache.get(b);
3677             } else {
<abbr title="3678                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (b))) : ((ResolveInfo) (b)).loadLabel(mPackageManager).toString().trim();">3678                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfðŸ”µ</abbr>
3679                 mLabelCache.put(b, labelB);
3680             }
3681             return mCollator.compare(labelA, labelB);
3682         }
3683     }
3684 
3685     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3686         return (provider != null) &amp;&amp; (provider.provider != null)
3687                 &amp;&amp; (provider.provider.getPackageName() != null);
3688     }
3689 
3690     public void dumpState() {
3691         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3692         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3693         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3694         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3695         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3696         if (mLoaderTask != null) {
3697             mLoaderTask.dumpState();
3698         } else {
3699             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3700         }
3701     }
3702 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentProviderOperation;
  26  import android.content.ContentResolver;
  27  import android.content.ContentValues;
  28  import android.content.Context;
  29  import android.content.Intent;
  30  import android.content.Intent.ShortcutIconResource;
  31  import android.content.IntentFilter;
  32  import android.content.SharedPreferences;
  33  import android.content.pm.PackageManager;
  34  import android.content.pm.ProviderInfo;
  35  import android.content.pm.ResolveInfo;
  36  import android.content.res.Configuration;
  37  import android.content.res.Resources;
  38  import android.database.Cursor;
  39  import android.graphics.Bitmap;
  40  import android.graphics.BitmapFactory;
  41  import android.net.Uri;
  42  import android.os.Environment;
  43  import android.os.Handler;
  44  import android.os.HandlerThread;
  45  import android.os.Parcelable;
  46  import android.os.Process;
  47  import android.os.RemoteException;
  48  import android.os.SystemClock;
  49  import android.provider.BaseColumns;
  50  import android.text.TextUtils;
  51  import android.util.Log;
  52  import android.util.Pair;
  53  
  54  import com.android.launcher3.compat.AppWidgetManagerCompat;
  55  import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56  import com.android.launcher3.compat.LauncherAppsCompat;
  57  import com.android.launcher3.compat.PackageInstallerCompat;
  58  import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59  import com.android.launcher3.compat.UserHandleCompat;
  60  import com.android.launcher3.compat.UserManagerCompat;
  61  
  62  import java.lang.ref.WeakReference;
  63  import java.net.URISyntaxException;
  64  import java.security.InvalidParameterException;
  65  import java.text.Collator;
  66  import java.util.ArrayList;
  67  import java.util.Arrays;
  68  import java.util.Collection;
  69  import java.util.Collections;
  70  import java.util.Comparator;
  71  import java.util.HashMap;
  72  import java.util.HashSet;
  73  import java.util.Iterator;
  74  import java.util.List;
  75  import java.util.Map.Entry;
  76  import java.util.Set;
  77  import java.util.TreeMap;
  78  import java.util.concurrent.atomic.AtomicBoolean;
  79  
  80  /**
  81   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82   * LauncherModel object held in a static. Also provide APIs for updating the database state
  83   * for the Launcher.
  84   */
  85  public class LauncherModel extends BroadcastReceiver
  86          implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87      static final boolean DEBUG_LOADERS = false;
  88      private static final boolean DEBUG_RECEIVER = false;
  89      private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90  
  91      static final String TAG = &quot;Launcher.Model&quot;;
  92  
  93      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94      // false = strew non-workspace apps across the workspace on upgrade
  95      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96      public static final int LOADER_FLAG_NONE = 0;
  97      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99  
 100      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101      private static final long INVALID_SCREEN_ID = -1L;
 102  
 103      private final boolean mAppsCanBeOnRemoveableStorage;
 104      private final boolean mOldContentProviderExists;
 105  
 106      private final LauncherAppState mApp;
 107      private final Object mLock = new Object();
 108      private DeferredHandler mHandler = new DeferredHandler();
 109      private LoaderTask mLoaderTask;
 110      private boolean mIsLoaderTaskRunning;
 111      private volatile boolean mFlushingWorkerThread;
 112  
 113      // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114      // clear all queued binding runnables when the Launcher activity is destroyed.
 115      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117  
 118      private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119  
 120      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121      static {
 122          sWorkerThread.start();
 123      }
 124      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125  
 126      // We start off with everything not loaded.  After that, we assume that
 127      // our monitoring of the package manager provides all updates and we never
 128      // need to do a requery.  These are only ever touched from the loader thread.
 129      private boolean mWorkspaceLoaded;
 130      private boolean mAllAppsLoaded;
 131  
 132      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135      // a normal load, we also clear this set of Runnables.
 136      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137  
 138      private WeakReference&lt;Callbacks&gt; mCallbacks;
 139  
 140      // &lt; only access in worker thread &gt;
 141      AllAppsList mBgAllAppsList;
 142  
 143      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144      // other locks, this one can generally be held long-term because we never expect any of these
 145      // static data structures to be referenced outside of the worker thread except on the first
 146      // load after configuration change.
 147      static final Object sBgLock = new Object();
 148  
 149      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150      // LauncherModel to their ids
 151      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152  
 153      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155      //       shortcuts within folders).
 156      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157  
 158      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161  
 162      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164  
 165      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167  
 168      // sBgWorkspaceScreens is the ordered set of workspace screens.
 169      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170  
 171      // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172      static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173              new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174  
 175      // &lt;/ only access in worker thread &gt;
 176  
 177      private IconCache mIconCache;
 178  
 179      protected int mPreviousConfigMcc;
 180  
 181      private final LauncherAppsCompat mLauncherApps;
 182      private final UserManagerCompat mUserManager;
 183  
 184      public interface Callbacks {
 185          public boolean setLoadOnResume();
 186          public int getCurrentWorkspaceScreen();
 187          public void startBinding();
 188          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                                boolean forceAnimateIcons);
 190          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193          public void finishBindingItems(boolean upgradePath);
 194          public void bindAppWidget(LauncherAppWidgetInfo info);
 195          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                    ArrayList&lt;AppInfo&gt; addedApps);
 200          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        public void bindShortcutsUpdated(ArrayList&lt;ShortcutInfo&gt; shortcuts);</span>
 202          public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203          public void updatePackageBadge(String packageName);
 204          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -                        ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +                        ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);</span>
 207          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 208          public void bindSearchablesChanged();
 209          public boolean isAllAppsButtonRank(int rank);
 210          public void onPageBoundSynchronously(int page);
 211          public void dumpLogsToLocalData();
 212      }
 213  
 214      public interface ItemInfoFilter {
 215          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 216      }
 217  
 218      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 219          Context context = app.getContext();
 220  
 221          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 222          String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 223          // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 224          // resource string.
 225          String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 226          ProviderInfo providerInfo =
 227                  context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 228          ProviderInfo redirectProvider =
 229                  context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 230  
 231          Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 232          mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 233  
 234          if (mOldContentProviderExists) {
 235              Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 236          } else {
 237              Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 238          }
 239  
 240          mApp = app;
 241          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 242          mIconCache = iconCache;
 243  
 244          final Resources res = context.getResources();
 245          Configuration config = res.getConfiguration();
 246          mPreviousConfigMcc = config.mcc;
 247          mLauncherApps = LauncherAppsCompat.getInstance(context);
 248          mUserManager = UserManagerCompat.getInstance(context);
 249      }
 250  
 251      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 252       * posted on the main thread handler. */
 253      private void runOnMainThread(Runnable r) {
 254          runOnMainThread(r, 0);
 255      }
 256      private void runOnMainThread(Runnable r, int type) {
 257          if (sWorkerThread.getThreadId() == Process.myTid()) {
 258              // If we are on the worker thread, post onto the main handler
 259              mHandler.post(r);
 260          } else {
 261              r.run();
 262          }
 263      }
 264  
 265      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 266       * posted on the worker thread handler. */
 267      private static void runOnWorkerThread(Runnable r) {
 268          if (sWorkerThread.getThreadId() == Process.myTid()) {
 269              r.run();
 270          } else {
 271              // If we are not on the worker thread, then post to the worker handler
 272              sWorker.post(r);
 273          }
 274      }
 275  
 276      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 277          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 278      }
 279  
 280      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 281                                   long screen) {
 282          LauncherAppState app = LauncherAppState.getInstance();
 283          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 284          final int xCount = (int) grid.numColumns;
 285          final int yCount = (int) grid.numRows;
 286          boolean[][] occupied = new boolean[xCount][yCount];
 287  
 288          int cellX, cellY, spanX, spanY;
 289          for (int i = 0; i &lt; items.size(); ++i) {
 290              final ItemInfo item = items.get(i);
 291              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 292                  if (item.screenId == screen) {
 293                      cellX = item.cellX;
 294                      cellY = item.cellY;
 295                      spanX = item.spanX;
 296                      spanY = item.spanY;
 297                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 298                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 299                              occupied[x][y] = true;
 300                          }
 301                      }
 302                  }
 303              }
 304          }
 305  
 306          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 307      }
 308      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 309                                                          Intent launchIntent,
 310                                                          int firstScreenIndex,
 311                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 312          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 313          LauncherAppState app = LauncherAppState.getInstance();
 314          LauncherModel model = app.getModel();
 315          boolean found = false;
 316          synchronized (app) {
 317              if (sWorkerThread.getThreadId() != Process.myTid()) {
 318                  // Flush the LauncherModel worker thread, so that if we just did another
 319                  // processInstallShortcut, we give it time for its shortcut to get added to the
 320                  // database (getItemsInLocalCoordinates reads the database)
 321                  model.flushWorkerThread();
 322              }
 323              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 324  
 325              // Try adding to the workspace screens incrementally, starting at the default or center
 326              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 327              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 328              int count = workspaceScreens.size();
 329              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 330                  int[] tmpCoordinates = new int[2];
 331                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 332                          workspaceScreens.get(screen))) {
 333                      // Update the Launcher db
 334                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 335                  }
 336              }
 337          }
 338          return null;
 339      }
 340  
 341      public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 342          // Process the updated package state
 343          Runnable r = new Runnable() {
 344              public void run() {
 345                  Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 346                  if (callbacks != null) {
 347                      callbacks.updatePackageState(installInfo);
 348                  }
 349              }
 350          };
 351          mHandler.post(r);
 352      }
 353  
 354      public void updatePackageBadge(final String packageName) {
 355          // Process the updated package badge
 356          Runnable r = new Runnable() {
 357              public void run() {
 358                  Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 359                  if (callbacks != null) {
 360                      callbacks.updatePackageBadge(packageName);
 361                  }
 362              }
 363          };
 364          mHandler.post(r);
 365      }
 366  
 367      public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 368          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 369  
 370          if (allAppsApps == null) {
 371              throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 372          }
 373          if (allAppsApps.isEmpty()) {
 374              return;
 375          }
 376  
 377          final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 378          Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 379          while (iter.hasNext()) {
 380              ItemInfo a = iter.next();
 381              if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 382                  restoredAppsFinal.add((AppInfo) a);
 383              }
 384          }
 385  
 386          // Process the newly added applications and add them to the database first
 387          Runnable r = new Runnable() {
 388              public void run() {
 389                  runOnMainThread(new Runnable() {
 390                      public void run() {
 391                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 392                          if (callbacks == cb &amp;&amp; cb != null) {
 393                              if (!restoredAppsFinal.isEmpty()) {
 394                                  for (AppInfo info : restoredAppsFinal) {
 395                                      final Intent intent = info.getIntent();
 396                                      if (intent != null) {
 397                                          mIconCache.deletePreloadedIcon(intent.getComponent(),
 398                                                  info.user);
 399                                      }
 400                                  }
 401                                  callbacks.bindAppsUpdated(restoredAppsFinal);
 402                              }
 403                              callbacks.bindAppsAdded(null, null, null, allAppsApps);
 404                          }
 405                      }
 406                  });
 407              }
 408          };
 409          runOnWorkerThread(r);
 410      }
 411  
 412      public void addAndBindAddedWorkspaceApps(final Context context,
 413              final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 414          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 415  
 416          if (workspaceApps == null) {
 417              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 418          }
 419          if (workspaceApps.isEmpty()) {
 420              return;
 421          }
 422          // Process the newly added applications and add them to the database first
 423          Runnable r = new Runnable() {
 424              public void run() {
 425                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 426                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 427                  final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 428  
 429                  // Get the list of workspace screens.  We need to append to this list and
 430                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 431                  // called.
 432                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 433                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 434                  for (Integer i : orderedScreens.keySet()) {
 435                      long screenId = orderedScreens.get(i);
 436                      workspaceScreens.add(screenId);
 437                  }
 438  
 439                  synchronized(sBgLock) {
 440                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 441                      while (iter.hasNext()) {
 442                          ItemInfo a = iter.next();
 443                          final String name = a.title.toString();
 444                          final Intent launchIntent = a.getIntent();
 445  
 446                          // Short-circuit this logic if the icon exists somewhere on the workspace
 447                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 448                              // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 449                              if (a instanceof AppInfo &amp;&amp;
 450                                      LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 451                                  restoredAppsFinal.add((AppInfo) a);
 452                              }
 453                              continue;
 454                          }
 455  
 456                          // Add this icon to the db, creating a new page if necessary.  If there
 457                          // is only the empty page then we just add items to the first page.
 458                          // Otherwise, we add them to the next pages.
 459                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 460                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 461                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 462                          if (coords == null) {
 463                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 464  
 465                              // If we can&#x27;t find a valid position, then just add a new screen.
 466                              // This takes time so we need to re-queue the add until the new
 467                              // page is added.  Create as many screens as necessary to satisfy
 468                              // the startSearchPageIndex.
 469                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 470                                      workspaceScreens.size());
 471                              while (numPagesToAdd &gt; 0) {
 472                                  long screenId = lp.generateNewScreenId();
 473                                  // Save the screen id for binding in the workspace
 474                                  workspaceScreens.add(screenId);
 475                                  addedWorkspaceScreensFinal.add(screenId);
 476                                  numPagesToAdd--;
 477                              }
 478  
 479                              // Find the coordinate again
 480                              coords = LauncherModel.findNextAvailableIconSpace(context,
 481                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 482                          }
 483                          if (coords == null) {
 484                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 485                          }
 486  
 487                          ShortcutInfo shortcutInfo;
 488                          if (a instanceof ShortcutInfo) {
 489                              shortcutInfo = (ShortcutInfo) a;
 490                          } else if (a instanceof AppInfo) {
 491                              shortcutInfo = ((AppInfo) a).makeShortcut();
 492                          } else {
 493                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 494                          }
 495  
 496                          // Add the shortcut to the db
 497                          addItemToDatabase(context, shortcutInfo,
 498                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 499                                  coords.first, coords.second[0], coords.second[1], false);
 500                          // Save the ShortcutInfo for binding in the workspace
 501                          addedShortcutsFinal.add(shortcutInfo);
 502                      }
 503                  }
 504  
 505                  // Update the workspace screens
 506                  updateWorkspaceScreenOrder(context, workspaceScreens);
 507  
 508                  if (!addedShortcutsFinal.isEmpty()) {
 509                      runOnMainThread(new Runnable() {
 510                          public void run() {
 511                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 512                              if (callbacks == cb &amp;&amp; cb != null) {
 513                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 515                                  if (!addedShortcutsFinal.isEmpty()) {
 516                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 517                                      long lastScreenId = info.screenId;
 518                                      for (ItemInfo i : addedShortcutsFinal) {
 519                                          if (i.screenId == lastScreenId) {
 520                                              addAnimated.add(i);
 521                                          } else {
 522                                              addNotAnimated.add(i);
 523                                          }
 524                                      }
 525                                  }
 526                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 527                                          addNotAnimated, addAnimated, null);
 528                                  if (!restoredAppsFinal.isEmpty()) {
 529                                      callbacks.bindAppsUpdated(restoredAppsFinal);
 530                                  }
 531                              }
 532                          }
 533                      });
 534                  }
 535              }
 536          };
 537          runOnWorkerThread(r);
 538      }
 539  
 540      public void unbindItemInfosAndClearQueuedBindRunnables() {
 541          if (sWorkerThread.getThreadId() == Process.myTid()) {
 542              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 543                      &quot;main thread&quot;);
 544          }
 545  
 546          // Clear any deferred bind runnables
 547          synchronized (mDeferredBindRunnables) {
 548              mDeferredBindRunnables.clear();
 549          }
 550          // Remove any queued bind runnables
 551          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 552          // Unbind all the workspace items
 553          unbindWorkspaceItemsOnMainThread();
 554      }
 555  
 556      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 557      void unbindWorkspaceItemsOnMainThread() {
 558          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 559          // by making a copy of workspace items first.
 560          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 561          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 562          synchronized (sBgLock) {
 563              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 564              tmpAppWidgets.addAll(sBgAppWidgets);
 565          }
 566          Runnable r = new Runnable() {
 567                  @Override
 568                  public void run() {
 569                     for (ItemInfo item : tmpWorkspaceItems) {
 570                         item.unbind();
 571                     }
 572                     for (ItemInfo item : tmpAppWidgets) {
 573                         item.unbind();
 574                     }
 575                  }
 576              };
 577          runOnMainThread(r);
 578      }
 579  
 580      /**
 581       * Adds an item to the DB if it was not created previously, or move it to a new
 582       * &lt;container, screen, cellX, cellY&gt;
 583       */
 584      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 585              long screenId, int cellX, int cellY) {
 586          if (item.container == ItemInfo.NO_ID) {
 587              // From all apps
 588              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 589          } else {
 590              // From somewhere else
 591              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 592          }
 593      }
 594  
 595      static void checkItemInfoLocked(
 596              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 597          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 598          if (modelItem != null &amp;&amp; item != modelItem) {
 599              // check all the data is consistent
 600              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 601                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 602                  ShortcutInfo shortcut = (ShortcutInfo) item;
 603                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 604                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 605                          modelShortcut.id == shortcut.id &amp;&amp;
 606                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 607                          modelShortcut.container == shortcut.container &amp;&amp;
 608                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 609                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 610                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 611                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 612                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 613                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 614                          (modelShortcut.dropPos != null &amp;&amp;
 615                                  shortcut.dropPos != null &amp;&amp;
 616                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 617                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 618                      // For all intents and purposes, this is the same object
 619                      return;
 620                  }
 621              }
 622  
 623              // the modelItem needs to match up perfectly with item if our model is
 624              // to be consistent with the database-- for now, just require
 625              // modelItem == item or the equality check above
 626              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 627                      &quot;modelItem: &quot; +
 628                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 629                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 630              RuntimeException e = new RuntimeException(msg);
 631              if (stackTrace != null) {
 632                  e.setStackTrace(stackTrace);
 633              }
 634              throw e;
 635          }
 636      }
 637  
 638      static void checkItemInfo(final ItemInfo item) {
 639          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 640          final long itemId = item.id;
 641          Runnable r = new Runnable() {
 642              public void run() {
 643                  synchronized (sBgLock) {
 644                      checkItemInfoLocked(itemId, item, stackTrace);
 645                  }
 646              }
 647          };
 648          runOnWorkerThread(r);
 649      }
 650  
 651      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 652              final ItemInfo item, final String callingFunction) {
 653          final long itemId = item.id;
 654          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 655          final ContentResolver cr = context.getContentResolver();
 656  
 657          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 658          Runnable r = new Runnable() {
 659              public void run() {
 660                  cr.update(uri, values, null, null);
 661                  updateItemArrays(item, itemId, stackTrace);
 662              }
 663          };
 664          runOnWorkerThread(r);
 665      }
 666  
 667      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 668              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 669          final ContentResolver cr = context.getContentResolver();
 670  
 671          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 672          Runnable r = new Runnable() {
 673              public void run() {
 674                  ArrayList&lt;ContentProviderOperation&gt; ops =
 675                          new ArrayList&lt;ContentProviderOperation&gt;();
 676                  int count = items.size();
 677                  for (int i = 0; i &lt; count; i++) {
 678                      ItemInfo item = items.get(i);
 679                      final long itemId = item.id;
 680                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 681                      ContentValues values = valuesList.get(i);
 682  
 683                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 684                      updateItemArrays(item, itemId, stackTrace);
 685  
 686                  }
 687                  try {
 688                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 689                  } catch (Exception e) {
 690                      e.printStackTrace();
 691                  }
 692              }
 693          };
 694          runOnWorkerThread(r);
 695      }
 696  
 697      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 698          // Lock on mBgLock *after* the db operation
 699          synchronized (sBgLock) {
 700              checkItemInfoLocked(itemId, item, stackTrace);
 701  
 702              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 703                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 704                  // Item is in a folder, make sure this folder exists
 705                  if (!sBgFolders.containsKey(item.container)) {
 706                      // An items container is being set to a that of an item which is not in
 707                      // the list of Folders.
 708                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 709                              item.container + &quot;, not in the list of folders&quot;;
 710                      Log.e(TAG, msg);
 711                  }
 712              }
 713  
 714              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 715              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 716              // that are on the desktop, as appropriate
 717              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 718              if (modelItem != null &amp;&amp;
 719                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 720                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 721                  switch (modelItem.itemType) {
 722                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 723                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 724                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 725                          if (!sBgWorkspaceItems.contains(modelItem)) {
 726                              sBgWorkspaceItems.add(modelItem);
 727                          }
 728                          break;
 729                      default:
 730                          break;
 731                  }
 732              } else {
 733                  sBgWorkspaceItems.remove(modelItem);
 734              }
 735          }
 736      }
 737  
 738      public void flushWorkerThread() {
 739          mFlushingWorkerThread = true;
 740          Runnable waiter = new Runnable() {
 741                  public void run() {
 742                      synchronized (this) {
 743                          notifyAll();
 744                          mFlushingWorkerThread = false;
 745                      }
 746                  }
 747              };
 748  
 749          synchronized(waiter) {
 750              runOnWorkerThread(waiter);
 751              if (mLoaderTask != null) {
 752                  synchronized(mLoaderTask) {
 753                      mLoaderTask.notify();
 754                  }
 755              }
 756              boolean success = false;
 757              while (!success) {
 758                  try {
 759                      waiter.wait();
 760                      success = true;
 761                  } catch (InterruptedException e) {
 762                  }
 763              }
 764          }
 765      }
 766  
 767      /**
 768       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 769       */
 770      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 771              final long screenId, final int cellX, final int cellY) {
 772          item.container = container;
 773          item.cellX = cellX;
 774          item.cellY = cellY;
 775  
 776          // We store hotseat items in canonical form which is this orientation invariant position
 777          // in the hotseat
 778          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 779                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 780              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 781          } else {
 782              item.screenId = screenId;
 783          }
 784  
 785          final ContentValues values = new ContentValues();
 786          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 787          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 788          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 789          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 790  
 791          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 792      }
 793  
 794      /**
 795       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 796       * cellX, cellY have already been updated on the ItemInfos.
 797       */
 798      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 799              final long container, final int screen) {
 800  
 801          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 802          int count = items.size();
 803  
 804          for (int i = 0; i &lt; count; i++) {
 805              ItemInfo item = items.get(i);
 806              item.container = container;
 807  
 808              // We store hotseat items in canonical form which is this orientation invariant position
 809              // in the hotseat
 810              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 811                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 812                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 813                          item.cellY);
 814              } else {
 815                  item.screenId = screen;
 816              }
 817  
 818              final ContentValues values = new ContentValues();
 819              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 820              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 821              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 822              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 823  
 824              contentValues.add(values);
 825          }
 826          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 827      }
 828  
 829      /**
 830       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 831       */
 832      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 833              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 834          item.container = container;
 835          item.cellX = cellX;
 836          item.cellY = cellY;
 837          item.spanX = spanX;
 838          item.spanY = spanY;
 839  
 840          // We store hotseat items in canonical form which is this orientation invariant position
 841          // in the hotseat
 842          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 843                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 844              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 845          } else {
 846              item.screenId = screenId;
 847          }
 848  
 849          final ContentValues values = new ContentValues();
 850          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 851          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 852          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 853          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 854          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 855          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 856  
 857          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 858      }
 859  
 860      /**
 861       * Update an item to the database in a specified container.
 862       */
 863      static void updateItemInDatabase(Context context, final ItemInfo item) {
 864          final ContentValues values = new ContentValues();
 865          item.onAddToDatabase(context, values);
 866          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 867          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 868      }
 869  
 870      /**
 871       * Returns true if the shortcuts already exists in the database.
 872       * we identify a shortcut by its title and intent.
 873       */
 874      static boolean shortcutExists(Context context, String title, Intent intent) {
 875          final ContentResolver cr = context.getContentResolver();
 876          final Intent intentWithPkg, intentWithoutPkg;
 877  
 878          if (intent.getComponent() != null) {
 879              // If component is not null, an intent with null package will produce
 880              // the same result and should also be a match.
 881              if (intent.getPackage() != null) {
 882                  intentWithPkg = intent;
 883                  intentWithoutPkg = new Intent(intent).setPackage(null);
 884              } else {
 885                  intentWithPkg = new Intent(intent).setPackage(
 886                          intent.getComponent().getPackageName());
 887                  intentWithoutPkg = intent;
 888              }
 889          } else {
 890              intentWithPkg = intent;
 891              intentWithoutPkg = intent;
 892          }
 893          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 894              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 895              new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 896          boolean result = false;
 897          try {
 898              result = c.moveToFirst();
 899          } finally {
 900              c.close();
 901          }
 902          return result;
 903      }
 904  
 905      /**
 906       * Returns true if the promise shortcuts with the same package name exists on the workspace.
 907       */
 908      static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 909          final ComponentName component = intent.getComponent();
 910          if (component == null) {
 911              return false;
 912          }
 913          return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 914      }
 915  
 916      /**
 917       * Returns an ItemInfo array containing all the items in the LauncherModel.
 918       * The ItemInfo.id is not set through this function.
 919       */
 920      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 921          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 922          final ContentResolver cr = context.getContentResolver();
 923          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 924                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 925                  LauncherSettings.Favorites.SCREEN,
 926                  LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 927                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 928                  LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 929  
 930          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 931          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 932          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 933          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 934          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 935          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 936          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 937          final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 938          UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 939          try {
 940              while (c.moveToNext()) {
 941                  ItemInfo item = new ItemInfo();
 942                  item.cellX = c.getInt(cellXIndex);
 943                  item.cellY = c.getInt(cellYIndex);
 944                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 945                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 946                  item.container = c.getInt(containerIndex);
 947                  item.itemType = c.getInt(itemTypeIndex);
 948                  item.screenId = c.getInt(screenIndex);
 949                  long serialNumber = c.getInt(profileIdIndex);
 950                  item.user = userManager.getUserForSerialNumber(serialNumber);
 951                  // Skip if user has been deleted.
 952                  if (item.user != null) {
 953                      items.add(item);
 954                  }
 955              }
 956          } catch (Exception e) {
 957              items.clear();
 958          } finally {
 959              c.close();
 960          }
 961  
 962          return items;
 963      }
 964  
 965      /**
 966       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 967       */
 968      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 969          final ContentResolver cr = context.getContentResolver();
 970          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 971                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 972                  new String[] { String.valueOf(id),
 973                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 974  
 975          try {
 976              if (c.moveToFirst()) {
 977                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 978                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 979                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 980                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 981                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 982                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 983  
 984                  FolderInfo folderInfo = null;
 985                  switch (c.getInt(itemTypeIndex)) {
 986                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 987                          folderInfo = findOrMakeFolder(folderList, id);
 988                          break;
 989                  }
 990  
 991                  folderInfo.title = c.getString(titleIndex);
 992                  folderInfo.id = id;
 993                  folderInfo.container = c.getInt(containerIndex);
 994                  folderInfo.screenId = c.getInt(screenIndex);
 995                  folderInfo.cellX = c.getInt(cellXIndex);
 996                  folderInfo.cellY = c.getInt(cellYIndex);
 997  
 998                  return folderInfo;
 999              }
1000          } finally {
1001              c.close();
1002          }
1003  
1004          return null;
1005      }
1006  
1007      /**
1008       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1009       * cellY fields of the item. Also assigns an ID to the item.
1010       */
1011      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1012              final long screenId, final int cellX, final int cellY, final boolean notify) {
1013          item.container = container;
1014          item.cellX = cellX;
1015          item.cellY = cellY;
1016          // We store hotseat items in canonical form which is this orientation invariant position
1017          // in the hotseat
1018          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1019                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1020              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1021          } else {
1022              item.screenId = screenId;
1023          }
1024  
1025          final ContentValues values = new ContentValues();
1026          final ContentResolver cr = context.getContentResolver();
1027          item.onAddToDatabase(context, values);
1028  
1029          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1030          values.put(LauncherSettings.Favorites._ID, item.id);
1031          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1032  
1033          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1034          Runnable r = new Runnable() {
1035              public void run() {
1036                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1037                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1038  
1039                  // Lock on mBgLock *after* the db operation
1040                  synchronized (sBgLock) {
1041                      checkItemInfoLocked(item.id, item, stackTrace);
1042                      sBgItemsIdMap.put(item.id, item);
1043                      switch (item.itemType) {
1044                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1045                              sBgFolders.put(item.id, (FolderInfo) item);
1046                              // Fall through
1047                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1048                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1049                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1050                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1051                                  sBgWorkspaceItems.add(item);
1052                              } else {
1053                                  if (!sBgFolders.containsKey(item.container)) {
1054                                      // Adding an item to a folder that doesn&#x27;t exist.
1055                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1056                                              &quot; doesn&#x27;t exist&quot;;
1057                                      Log.e(TAG, msg);
1058                                  }
1059                              }
1060                              break;
1061                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1062                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1063                              break;
1064                      }
1065                  }
1066              }
1067          };
1068          runOnWorkerThread(r);
1069      }
1070  
1071      /**
1072       * Creates a new unique child id, for a given cell span across all layouts.
1073       */
1074      static int getCellLayoutChildId(
1075              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1076          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1077                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1078      }
1079  
1080      private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1081              final String pn, final UserHandleCompat user) {
1082          ItemInfoFilter filter  = new ItemInfoFilter() {
1083              @Override
1084              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1085                  return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1086              }
1087          };
1088          return filterItemInfos(sBgItemsIdMap.values(), filter);
1089      }
1090  
1091      /**
1092       * Removes all the items from the database corresponding to the specified package.
1093       */
1094      static void deletePackageFromDatabase(Context context, final String pn,
1095              final UserHandleCompat user) {
1096          deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1097      }
1098  
1099      /**
1100       * Removes the specified item from the database
1101       * @param context
1102       * @param item
1103       */
1104      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1105          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1106          items.add(item);
1107          deleteItemsFromDatabase(context, items);
1108      }
1109  
1110      /**
1111       * Removes the specified items from the database
1112       * @param context
1113       * @param item
1114       */
1115      static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1116          final ContentResolver cr = context.getContentResolver();
1117  
1118          Runnable r = new Runnable() {
1119              public void run() {
1120                  for (ItemInfo item : items) {
1121                      final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1122                      cr.delete(uri, null, null);
1123  
1124                      // Lock on mBgLock *after* the db operation
1125                      synchronized (sBgLock) {
1126                          switch (item.itemType) {
1127                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1128                                  sBgFolders.remove(item.id);
1129                                  for (ItemInfo info: sBgItemsIdMap.values()) {
1130                                      if (info.container == item.id) {
1131                                          // We are deleting a folder which still contains items that
1132                                          // think they are contained by that folder.
1133                                          String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1134                                                  &quot;contains items (&quot; + info + &quot;)&quot;;
1135                                          Log.e(TAG, msg);
1136                                      }
1137                                  }
1138                                  sBgWorkspaceItems.remove(item);
1139                                  break;
1140                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1141                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1142                                  sBgWorkspaceItems.remove(item);
1143                                  break;
1144                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1145                                  sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1146                                  break;
1147                          }
1148                          sBgItemsIdMap.remove(item.id);
1149                          sBgDbIconCache.remove(item);
1150                      }
1151                  }
1152              }
1153          };
1154          runOnWorkerThread(r);
1155      }
1156  
1157      /**
1158       * Update the order of the workspace screens in the database. The array list contains
1159       * a list of screen ids in the order that they should appear.
1160       */
1161      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1162          // Log to disk
1163          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1164          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1165  
1166          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1167          final ContentResolver cr = context.getContentResolver();
1168          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1169  
1170          // Remove any negative screen ids -- these aren&#x27;t persisted
1171          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1172          while (iter.hasNext()) {
1173              long id = iter.next();
1174              if (id &lt; 0) {
1175                  iter.remove();
1176              }
1177          }
1178  
1179          Runnable r = new Runnable() {
1180              @Override
1181              public void run() {
1182                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1183                  // Clear the table
1184                  ops.add(ContentProviderOperation.newDelete(uri).build());
1185                  int count = screensCopy.size();
1186                  for (int i = 0; i &lt; count; i++) {
1187                      ContentValues v = new ContentValues();
1188                      long screenId = screensCopy.get(i);
1189                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1190                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1191                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1192                  }
1193  
1194                  try {
1195                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1196                  } catch (Exception ex) {
1197                      throw new RuntimeException(ex);
1198                  }
1199  
1200                  synchronized (sBgLock) {
1201                      sBgWorkspaceScreens.clear();
1202                      sBgWorkspaceScreens.addAll(screensCopy);
1203                  }
1204              }
1205          };
1206          runOnWorkerThread(r);
1207      }
1208  
1209      /**
1210       * Remove the contents of the specified folder from the database
1211       */
1212      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1213          final ContentResolver cr = context.getContentResolver();
1214  
1215          Runnable r = new Runnable() {
1216              public void run() {
1217                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1218                  // Lock on mBgLock *after* the db operation
1219                  synchronized (sBgLock) {
1220                      sBgItemsIdMap.remove(info.id);
1221                      sBgFolders.remove(info.id);
1222                      sBgDbIconCache.remove(info);
1223                      sBgWorkspaceItems.remove(info);
1224                  }
1225  
1226                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1227                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1228                  // Lock on mBgLock *after* the db operation
1229                  synchronized (sBgLock) {
1230                      for (ItemInfo childInfo : info.contents) {
1231                          sBgItemsIdMap.remove(childInfo.id);
1232                          sBgDbIconCache.remove(childInfo);
1233                      }
1234                  }
1235              }
1236          };
1237          runOnWorkerThread(r);
1238      }
1239  
1240      /**
1241       * Set this as the current Launcher activity object for the loader.
1242       */
1243      public void initialize(Callbacks callbacks) {
1244          synchronized (mLock) {
1245              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1246          }
1247      }
1248  
1249      @Override
1250      public void onPackageChanged(String packageName, UserHandleCompat user) {
1251          int op = PackageUpdatedTask.OP_UPDATE;
1252          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1253                  user));
1254      }
1255  
1256      @Override
1257      public void onPackageRemoved(String packageName, UserHandleCompat user) {
1258          int op = PackageUpdatedTask.OP_REMOVE;
1259          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1260                  user));
1261      }
1262  
1263      @Override
1264      public void onPackageAdded(String packageName, UserHandleCompat user) {
1265          int op = PackageUpdatedTask.OP_ADD;
1266          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1267                  user));
1268      }
1269  
1270      @Override
1271      public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1272              boolean replacing) {
1273          if (!replacing) {
1274              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1275                      user));
1276              if (mAppsCanBeOnRemoveableStorage) {
1277                  // Only rebind if we support removable storage. It catches the
1278                  // case where
1279                  // apps on the external sd card need to be reloaded
1280                  startLoaderFromBackground();
1281              }
1282          } else {
1283              // If we are replacing then just update the packages in the list
1284              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1285                      packageNames, user));
1286          }
1287      }
1288  
1289      @Override
1290      public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1291              boolean replacing) {
1292          if (!replacing) {
1293              enqueuePackageUpdated(new PackageUpdatedTask(
1294                      PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1295                      user));
1296          }
1297  
1298      }
1299  
1300      /**
1301       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1302       * ACTION_PACKAGE_CHANGED.
1303       */
1304      @Override
1305      public void onReceive(Context context, Intent intent) {
1306          if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1307  
1308          final String action = intent.getAction();
1309          if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1310              // If we have changed locale we need to clear out the labels in all apps/workspace.
1311              forceReload();
1312          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1313               // Check if configuration change was an mcc/mnc change which would affect app resources
1314               // and we would need to clear out the labels in all apps/workspace. Same handling as
1315               // above for ACTION_LOCALE_CHANGED
1316               Configuration currentConfig = context.getResources().getConfiguration();
1317               if (mPreviousConfigMcc != currentConfig.mcc) {
1318                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1319                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1320                     forceReload();
1321               }
1322               // Update previousConfig
1323               mPreviousConfigMcc = currentConfig.mcc;
1324          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1325                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1326              if (mCallbacks != null) {
1327                  Callbacks callbacks = mCallbacks.get();
1328                  if (callbacks != null) {
1329                      callbacks.bindSearchablesChanged();
1330                  }
1331              }
1332          }
1333      }
1334  
1335      void forceReload() {
1336          resetLoadedState(true, true);
1337  
1338          // Do this here because if the launcher activity is running it will be restarted.
1339          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1340          // to reload.
1341          startLoaderFromBackground();
1342      }
1343  
1344      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1345          synchronized (mLock) {
1346              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1347              // mWorkspaceLoaded to true later
1348              stopLoaderLocked();
1349              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1350              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1351          }
1352      }
1353  
1354      /**
1355       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1356       * configuration changes.  So whenever we trigger the loader from the background
1357       * tell the launcher that it needs to re-run the loader when it comes back instead
1358       * of doing it now.
1359       */
1360      public void startLoaderFromBackground() {
1361          boolean runLoader = false;
1362          if (mCallbacks != null) {
1363              Callbacks callbacks = mCallbacks.get();
1364              if (callbacks != null) {
1365                  // Only actually run the loader if they&#x27;re not paused.
1366                  if (!callbacks.setLoadOnResume()) {
1367                      runLoader = true;
1368                  }
1369              }
1370          }
1371          if (runLoader) {
1372              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1373          }
1374      }
1375  
1376      // If there is already a loader task running, tell it to stop.
1377      // returns true if isLaunching() was true on the old task
1378      private boolean stopLoaderLocked() {
1379          boolean isLaunching = false;
1380          LoaderTask oldTask = mLoaderTask;
1381          if (oldTask != null) {
1382              if (oldTask.isLaunching()) {
1383                  isLaunching = true;
1384              }
1385              oldTask.stopLocked();
1386          }
1387          return isLaunching;
1388      }
1389  
1390      public boolean isCurrentCallbacks(Callbacks callbacks) {
1391          return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1392      }
1393  
1394      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1395          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1396      }
1397  
1398      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1399          synchronized (mLock) {
1400              if (DEBUG_LOADERS) {
1401                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1402              }
1403  
1404              // Clear any deferred bind-runnables from the synchronized load process
1405              // We must do this before any loading/binding is scheduled below.
1406              synchronized (mDeferredBindRunnables) {
1407                  mDeferredBindRunnables.clear();
1408              }
1409  
1410              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1411              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1412                  // If there is already one running, tell it to stop.
1413                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1414                  isLaunching = isLaunching || stopLoaderLocked();
1415                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1416                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1417                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1418                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1419                  } else {
1420                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1421                      sWorker.post(mLoaderTask);
1422                  }
1423              }
1424          }
1425      }
1426  
1427      void bindRemainingSynchronousPages() {
1428          // Post the remaining side pages to be loaded
1429          if (!mDeferredBindRunnables.isEmpty()) {
1430              Runnable[] deferredBindRunnables = null;
1431              synchronized (mDeferredBindRunnables) {
1432                  deferredBindRunnables = mDeferredBindRunnables.toArray(
1433                          new Runnable[mDeferredBindRunnables.size()]);
1434                  mDeferredBindRunnables.clear();
1435              }
1436              for (final Runnable r : deferredBindRunnables) {
1437                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1438              }
1439          }
1440      }
1441  
1442      public void stopLoader() {
1443          synchronized (mLock) {
1444              if (mLoaderTask != null) {
1445                  mLoaderTask.stopLocked();
1446              }
1447          }
1448      }
1449  
1450      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1451      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1452          final ContentResolver contentResolver = context.getContentResolver();
1453          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1454          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1455          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1456  
1457          try {
1458              final int idIndex = sc.getColumnIndexOrThrow(
1459                      LauncherSettings.WorkspaceScreens._ID);
1460              final int rankIndex = sc.getColumnIndexOrThrow(
1461                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1462              while (sc.moveToNext()) {
1463                  try {
1464                      long screenId = sc.getLong(idIndex);
1465                      int rank = sc.getInt(rankIndex);
1466                      orderedScreens.put(rank, screenId);
1467                  } catch (Exception e) {
1468                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1469                  }
1470              }
1471          } finally {
1472              sc.close();
1473          }
1474  
1475          // Log to disk
1476          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1477          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1478          for (Integer i : orderedScreens.keySet()) {
1479              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1480          }
1481          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1482                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1483          return orderedScreens;
1484      }
1485  
1486      public boolean isAllAppsLoaded() {
1487          return mAllAppsLoaded;
1488      }
1489  
1490      boolean isLoadingWorkspace() {
1491          synchronized (mLock) {
1492              if (mLoaderTask != null) {
1493                  return mLoaderTask.isLoadingWorkspace();
1494              }
1495          }
1496          return false;
1497      }
1498  
1499      /**
1500       * Runnable for the thread that loads the contents of the launcher:
1501       *   - workspace icons
1502       *   - widgets
1503       *   - all apps icons
1504       */
1505      private class LoaderTask implements Runnable {
1506          private Context mContext;
1507          private boolean mIsLaunching;
1508          private boolean mIsLoadingAndBindingWorkspace;
1509          private boolean mStopped;
1510          private boolean mLoadAndBindStepFinished;
1511          private int mFlags;
1512  
1513          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1514  
1515          LoaderTask(Context context, boolean isLaunching, int flags) {
1516              mContext = context;
1517              mIsLaunching = isLaunching;
1518              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1519              mFlags = flags;
1520          }
1521  
1522          boolean isLaunching() {
1523              return mIsLaunching;
1524          }
1525  
1526          boolean isLoadingWorkspace() {
1527              return mIsLoadingAndBindingWorkspace;
1528          }
1529  
1530          /** Returns whether this is an upgrade path */
1531          private boolean loadAndBindWorkspace() {
1532              mIsLoadingAndBindingWorkspace = true;
1533  
1534              // Load the workspace
1535              if (DEBUG_LOADERS) {
1536                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1537              }
1538  
1539              boolean isUpgradePath = false;
1540              if (!mWorkspaceLoaded) {
1541                  isUpgradePath = loadWorkspace();
1542                  synchronized (LoaderTask.this) {
1543                      if (mStopped) {
1544                          return isUpgradePath;
1545                      }
1546                      mWorkspaceLoaded = true;
1547                  }
1548              }
1549  
1550              // Bind the workspace
1551              bindWorkspace(-1, isUpgradePath);
1552              return isUpgradePath;
1553          }
1554  
1555          private void waitForIdle() {
1556              // Wait until the either we&#x27;re stopped or the other threads are done.
1557              // This way we don&#x27;t start loading all apps until the workspace has settled
1558              // down.
1559              synchronized (LoaderTask.this) {
1560                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1561  
1562                  mHandler.postIdle(new Runnable() {
1563                          public void run() {
1564                              synchronized (LoaderTask.this) {
1565                                  mLoadAndBindStepFinished = true;
1566                                  if (DEBUG_LOADERS) {
1567                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1568                                  }
1569                                  LoaderTask.this.notify();
1570                              }
1571                          }
1572                      });
1573  
1574                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1575                      try {
1576                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1577                          // wait no longer than 1sec at a time
1578                          this.wait(1000);
1579                      } catch (InterruptedException ex) {
1580                          // Ignore
1581                      }
1582                  }
1583                  if (DEBUG_LOADERS) {
1584                      Log.d(TAG, &quot;waited &quot;
1585                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1586                              + &quot;ms for previous step to finish binding&quot;);
1587                  }
1588              }
1589          }
1590  
1591          void runBindSynchronousPage(int synchronousBindPage) {
1592              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1593                  // Ensure that we have a valid page index to load synchronously
1594                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1595                          &quot;valid page index&quot;);
1596              }
1597              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1598                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1599                  // loaded already (we should load everything asynchronously in that case)
1600                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1601              }
1602              synchronized (mLock) {
1603                  if (mIsLoaderTaskRunning) {
1604                      // Ensure that we are never running the background loading at this point since
1605                      // we also touch the background collections
1606                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1607                  }
1608              }
1609  
1610              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1611              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1612              //      this call is synchronous, we can get away with not locking).
1613  
1614              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1615              // operations from the previous activity.  We need to ensure that all queued operations
1616              // are executed before any synchronous binding work is done.
1617              mHandler.flush();
1618  
1619              // Divide the set of loaded items into those that we are binding synchronously, and
1620              // everything else that is to be bound normally (asynchronously).
1621              bindWorkspace(synchronousBindPage, false);
1622              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1623              //      arise from that.
1624              onlyBindAllApps();
1625          }
1626  
1627          public void run() {
1628              boolean isUpgrade = false;
1629  
1630              synchronized (mLock) {
1631                  mIsLoaderTaskRunning = true;
1632              }
1633              // Optimize for end-user experience: if the Launcher is up and // running with the
1634              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1635              // workspace first (default).
1636              keep_running: {
1637                  // Elevate priority when Home launches for the first time to avoid
1638                  // starving at boot time. Staring at a blank home is not cool.
1639                  synchronized (mLock) {
1640                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1641                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1642                      android.os.Process.setThreadPriority(mIsLaunching
1643                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1644                  }
1645                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1646                  isUpgrade = loadAndBindWorkspace();
1647  
1648                  if (mStopped) {
1649                      break keep_running;
1650                  }
1651  
1652                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1653                  // settled down.
1654                  synchronized (mLock) {
1655                      if (mIsLaunching) {
1656                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1657                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1658                      }
1659                  }
1660                  waitForIdle();
1661  
1662                  // second step
1663                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1664                  loadAndBindAllApps();
1665  
1666                  // Restore the default thread priority after we are done loading items
1667                  synchronized (mLock) {
1668                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1669                  }
1670              }
1671  
1672              // Update the saved icons if necessary
1673              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1674              synchronized (sBgLock) {
1675                  for (Object key : sBgDbIconCache.keySet()) {
1676                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1677                  }
1678                  sBgDbIconCache.clear();
1679              }
1680  
1681              if (LauncherAppState.isDisableAllApps()) {
1682                  // Ensure that all the applications that are in the system are
1683                  // represented on the home screen.
1684                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1685                      verifyApplications();
1686                  }
1687              }
1688  
1689              // Clear out this reference, otherwise we end up holding it until all of the
1690              // callback runnables are done.
1691              mContext = null;
1692  
1693              synchronized (mLock) {
1694                  // If we are still the last one to be scheduled, remove ourselves.
1695                  if (mLoaderTask == this) {
1696                      mLoaderTask = null;
1697                  }
1698                  mIsLoaderTaskRunning = false;
1699              }
1700          }
1701  
1702          public void stopLocked() {
1703              synchronized (LoaderTask.this) {
1704                  mStopped = true;
1705                  this.notify();
1706              }
1707          }
1708  
1709          /**
1710           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1711           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1712           * object that was around when the deferred message was scheduled, and if there&#x27;s
1713           * a new Callbacks object around then also return null.  This will save us from
1714           * calling onto it with data that will be ignored.
1715           */
1716          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1717              synchronized (mLock) {
1718                  if (mStopped) {
1719                      return null;
1720                  }
1721  
1722                  if (mCallbacks == null) {
1723                      return null;
1724                  }
1725  
1726                  final Callbacks callbacks = mCallbacks.get();
1727                  if (callbacks != oldCallbacks) {
1728                      return null;
1729                  }
1730                  if (callbacks == null) {
1731                      Log.w(TAG, &quot;no mCallbacks&quot;);
1732                      return null;
1733                  }
1734  
1735                  return callbacks;
1736              }
1737          }
1738  
1739          private void verifyApplications() {
1740              final Context context = mApp.getContext();
1741  
1742              // Cross reference all the applications in our apps list with items in the workspace
1743              ArrayList&lt;ItemInfo&gt; tmpInfos;
1744              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1745              synchronized (sBgLock) {
1746                  for (AppInfo app : mBgAllAppsList.data) {
1747                      tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1748                      if (tmpInfos.isEmpty()) {
1749                          // We are missing an application icon, so add this to the workspace
1750                          added.add(app);
1751                          // This is a rare event, so lets log it
1752                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1753                      }
1754                  }
1755              }
1756              if (!added.isEmpty()) {
1757                  addAndBindAddedWorkspaceApps(context, added);
1758              }
1759          }
1760  
1761          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1762          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1763                                             AtomicBoolean deleteOnInvalidPlacement) {
1764              LauncherAppState app = LauncherAppState.getInstance();
1765              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1766              final int countX = (int) grid.numColumns;
1767              final int countY = (int) grid.numRows;
1768  
1769              long containerIndex = item.screenId;
1770              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1771                  // Return early if we detect that an item is under the hotseat button
1772                  if (mCallbacks == null ||
1773                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1774                      deleteOnInvalidPlacement.set(true);
1775                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1776                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1777                              + item.cellY + &quot;) occupied by all apps&quot;);
1778                      return false;
1779                  }
1780  
1781                  final ItemInfo[][] hotseatItems =
1782                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1783  
1784                  if (item.screenId &gt;= grid.numHotseatIcons) {
1785                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1786                              + &quot; into hotseat position &quot; + item.screenId
1787                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1788                              + &quot;)&quot;);
1789                      return false;
1790                  }
1791  
1792                  if (hotseatItems != null) {
1793                      if (hotseatItems[(int) item.screenId][0] != null) {
1794                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1795                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1796                                  + item.cellY + &quot;) occupied by &quot;
1797                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1798                                  [(int) item.screenId][0]);
1799                              return false;
1800                      } else {
1801                          hotseatItems[(int) item.screenId][0] = item;
1802                          return true;
1803                      }
1804                  } else {
1805                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1806                      items[(int) item.screenId][0] = item;
1807                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1808                      return true;
1809                  }
1810              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1811                  // Skip further checking if it is not the hotseat or workspace container
1812                  return true;
1813              }
1814  
1815              if (!occupied.containsKey(item.screenId)) {
1816                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1817                  occupied.put(item.screenId, items);
1818              }
1819  
1820              final ItemInfo[][] screens = occupied.get(item.screenId);
1821              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1822                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1823                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1824                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1825                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1826                          + item.cellX + &quot;,&quot; + item.cellY
1827                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1828                  return false;
1829              }
1830  
1831              // Check if any workspace icons overlap with each other
1832              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1833                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1834                      if (screens[x][y] != null) {
1835                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1836                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1837                              + x + &quot;,&quot; + y
1838                              + &quot;) occupied by &quot;
1839                              + screens[x][y]);
1840                          return false;
1841                      }
1842                  }
1843              }
1844              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1845                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1846                      screens[x][y] = item;
1847                  }
1848              }
1849  
1850              return true;
1851          }
1852  
1853          /** Clears all the sBg data structures */
1854          private void clearSBgDataStructures() {
1855              synchronized (sBgLock) {
1856                  sBgWorkspaceItems.clear();
1857                  sBgAppWidgets.clear();
1858                  sBgFolders.clear();
1859                  sBgItemsIdMap.clear();
1860                  sBgDbIconCache.clear();
1861                  sBgWorkspaceScreens.clear();
1862              }
1863          }
1864  
1865          /** Returns whether this is an upgrade path */
1866          private boolean loadWorkspace() {
1867              // Log to disk
1868              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1869  
1870              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1871  
1872              final Context context = mContext;
1873              final ContentResolver contentResolver = context.getContentResolver();
1874              final PackageManager manager = context.getPackageManager();
1875              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1876              final boolean isSafeMode = manager.isSafeMode();
1877              final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1878              final boolean isSdCardReady = context.registerReceiver(null,
1879                      new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1880  
1881              LauncherAppState app = LauncherAppState.getInstance();
1882              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1883              int countX = (int) grid.numColumns;
1884              int countY = (int) grid.numRows;
1885  
1886              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1887                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1888                  LauncherAppState.getLauncherProvider().deleteDatabase();
1889              }
1890  
1891              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1892                  // append the user&#x27;s Launcher2 shortcuts
1893                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1894                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1895              } else {
1896                  // Make sure the default workspace is loaded
1897                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1898                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1899              }
1900  
1901              // This code path is for our old migration code and should no longer be exercised
1902              boolean loadedOldDb = false;
1903  
1904              // Log to disk
1905              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1906  
1907              synchronized (sBgLock) {
1908                  clearSBgDataStructures();
1909                  final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1910                          .getInstance(mContext).updateAndGetActiveSessionCache();
1911  
1912                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1913                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1914                  final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1915                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1916                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1917  
1918                  // +1 for the hotseat (it can be larger than the workspace)
1919                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1920                  // before any earlier duplicates)
1921                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1922  
1923                  try {
1924                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1925                      final int intentIndex = c.getColumnIndexOrThrow
1926                              (LauncherSettings.Favorites.INTENT);
1927                      final int titleIndex = c.getColumnIndexOrThrow
1928                              (LauncherSettings.Favorites.TITLE);
1929                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1930                              LauncherSettings.Favorites.ICON_TYPE);
1931                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1932                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1933                              LauncherSettings.Favorites.ICON_PACKAGE);
1934                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1935                              LauncherSettings.Favorites.ICON_RESOURCE);
1936                      final int containerIndex = c.getColumnIndexOrThrow(
1937                              LauncherSettings.Favorites.CONTAINER);
1938                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1939                              LauncherSettings.Favorites.ITEM_TYPE);
1940                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1941                              LauncherSettings.Favorites.APPWIDGET_ID);
1942                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1943                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1944                      final int screenIndex = c.getColumnIndexOrThrow(
1945                              LauncherSettings.Favorites.SCREEN);
1946                      final int cellXIndex = c.getColumnIndexOrThrow
1947                              (LauncherSettings.Favorites.CELLX);
1948                      final int cellYIndex = c.getColumnIndexOrThrow
1949                              (LauncherSettings.Favorites.CELLY);
1950                      final int spanXIndex = c.getColumnIndexOrThrow
1951                              (LauncherSettings.Favorites.SPANX);
1952                      final int spanYIndex = c.getColumnIndexOrThrow(
1953                              LauncherSettings.Favorites.SPANY);
1954                      final int restoredIndex = c.getColumnIndexOrThrow(
1955                              LauncherSettings.Favorites.RESTORED);
1956                      final int profileIdIndex = c.getColumnIndexOrThrow(
1957                              LauncherSettings.Favorites.PROFILE_ID);
1958                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1959                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1960                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1961  
1962                      ShortcutInfo info;
1963                      String intentDescription;
1964                      LauncherAppWidgetInfo appWidgetInfo;
1965                      int container;
1966                      long id;
1967                      Intent intent;
1968                      UserHandleCompat user;
1969  
1970                      while (!mStopped &amp;&amp; c.moveToNext()) {
1971                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1972                          try {
1973                              int itemType = c.getInt(itemTypeIndex);
1974                              boolean restored = 0 != c.getInt(restoredIndex);
1975                              boolean allowMissingTarget = false;
1976  
1977                              switch (itemType) {
1978                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1979                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1980                                  id = c.getLong(idIndex);
1981                                  intentDescription = c.getString(intentIndex);
1982                                  long serialNumber = c.getInt(profileIdIndex);
1983                                  user = mUserManager.getUserForSerialNumber(serialNumber);
1984                                  int promiseType = c.getInt(restoredIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1985 +                                int disabledState = 0;</span>
1986                                  if (user == null) {
1987                                      // User has been deleted remove the item.
1988                                      itemsToRemove.add(id);
1989                                      continue;
1990                                  }
1991                                  try {
1992                                      intent = Intent.parseUri(intentDescription, 0);
1993                                      ComponentName cn = intent.getComponent();
1994                                      if (cn != null &amp;&amp; cn.getPackageName() != null) {
1995                                          boolean validPkg = launcherApps.isPackageEnabledForProfile(
1996                                                  cn.getPackageName(), user);
1997                                          boolean validComponent = validPkg &amp;&amp;
1998                                                  launcherApps.isActivityEnabledForProfile(cn, user);
1999  
2000                                          if (validComponent) {
2001                                              if (restored) {
2002                                                  // no special handling necessary for this item
2003                                                  restoredRows.add(id);
2004                                                  restored = false;
2005                                              }
2006                                          } else if (validPkg) {
2007                                              intent = null;
2008                                              if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2009                                                  // We allow auto install apps to have their intent
2010                                                  // updated after an install.
2011                                                  intent = manager.getLaunchIntentForPackage(
2012                                                          cn.getPackageName());
2013                                                  if (intent != null) {
2014                                                      ContentValues values = new ContentValues();
2015                                                      values.put(LauncherSettings.Favorites.INTENT,
2016                                                              intent.toUri(0));
2017                                                      String where = BaseColumns._ID + &quot;= ?&quot;;
2018                                                      String[] args = {Long.toString(id)};
2019                                                      contentResolver.update(contentUri, values, where, args);
2020                                                  }
2021                                              }
2022  
2023                                              if (intent == null) {
2024                                                  // The app is installed but the component is no
2025                                                  // longer available.
2026                                                  Launcher.addDumpLog(TAG,
2027                                                          &quot;Invalid component removed: &quot; + cn, true);
2028                                                  itemsToRemove.add(id);
2029                                                  continue;
2030                                              } else {
2031                                                  // no special handling necessary for this item
2032                                                  restoredRows.add(id);
2033                                                  restored = false;
2034                                              }
2035                                          } else if (restored) {
2036                                              // Package is not yet available but might be
2037                                              // installed later.
2038                                              Launcher.addDumpLog(TAG,
2039                                                      &quot;package not yet restored: &quot; + cn, true);
2040  
2041                                              if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2042                                                  // Restore has started once.
2043                                              } else if (installingPkgs.contains(cn.getPackageName())) {
2044                                                  // App restore has started. Update the flag
2045                                                  promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2046                                                  ContentValues values = new ContentValues();
2047                                                  values.put(LauncherSettings.Favorites.RESTORED,
2048                                                          promiseType);
2049                                                  String where = BaseColumns._ID + &quot;= ?&quot;;
2050                                                  String[] args = {Long.toString(id)};
2051                                                  contentResolver.update(contentUri, values, where, args);
2052  
2053                                              } else if (REMOVE_UNRESTORED_ICONS) {
2054                                                  Launcher.addDumpLog(TAG,
2055                                                          &quot;Unrestored package removed: &quot; + cn, true);
2056                                                  itemsToRemove.add(id);
2057                                                  continue;
2058                                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2059 -                                        } else if (isSdCardReady) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2060 -                                            // Do not wait for external media load anymore.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2061 -                                            // Log the invalid package, and remove it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2063 -                                                    &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2064 -                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2065 -                                            continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2066 -                                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2067 +                                        } else if (launcherApps.isAppEnabled(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2068 +                                                manager, cn.getPackageName(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2069 +                                                PackageManager.GET_UNINSTALLED_PACKAGES)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2070 +                                            // Package is present but not available.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2071 +                                            allowMissingTarget = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2072 +                                            disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2073 +                                        } else if (!isSdCardReady) {</span>
2074                                              // SdCard is not ready yet. Package might get available,
2075                                              // once it is ready.
2076                                              Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2077                                                      + &quot; (check again later)&quot;, true);
2078                                              HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2079                                              if (pkgs == null) {
2080                                                  pkgs = new HashSet&lt;String&gt;();
2081                                                  sPendingPackages.put(user, pkgs);
2082                                              }
2083                                              pkgs.add(cn.getPackageName());
2084                                              allowMissingTarget = true;
2085                                              // Add the icon on the workspace anyway.
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2086 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2087 +                                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2088 +                                            // Do not wait for external media load anymore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2089 +                                            // Log the invalid package, and remove it</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2090 +                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2091 +                                                    &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2092 +                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2093 +                                            continue;</span>
2094                                          }
2095                                      } else if (cn == null) {
2096                                          // For shortcuts with no component, keep them as they are
2097                                          restoredRows.add(id);
2098                                          restored = false;
2099                                      }
2100                                  } catch (URISyntaxException e) {
2101                                      Launcher.addDumpLog(TAG,
2102                                              &quot;Invalid uri: &quot; + intentDescription, true);
2103                                      continue;
2104                                  }
2105  
2106                                  if (restored) {
2107                                      if (user.equals(UserHandleCompat.myUserHandle())) {
2108                                          Launcher.addDumpLog(TAG,
2109                                                  &quot;constructing info for partially restored package&quot;,
2110                                                  true);
2111                                          info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2112                                          intent = getRestoredItemIntent(c, context, intent);
2113                                      } else {
2114                                          // Don&#x27;t restore items for other profiles.
2115                                          itemsToRemove.add(id);
2116                                          continue;
2117                                      }
2118                                  } else if (itemType ==
2119                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2120                                      info = getShortcutInfo(manager, intent, user, context, c,
2121                                              iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2122                                  } else {
2123                                      info = getShortcutInfo(c, context, iconTypeIndex,
2124                                              iconPackageIndex, iconResourceIndex, iconIndex,
2125                                              titleIndex);
2126  
2127                                      // App shortcuts that used to be automatically added to Launcher
2128                                      // didn&#x27;t always have the correct intent flags set, so do that
2129                                      // here
2130                                      if (intent.getAction() != null &amp;&amp;
2131                                          intent.getCategories() != null &amp;&amp;
2132                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2133                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2134                                          intent.addFlags(
2135                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2136                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2137                                      }
2138                                  }
2139  
2140                                  if (info != null) {
2141                                      info.id = id;
2142                                      info.intent = intent;
2143                                      container = c.getInt(containerIndex);
2144                                      info.container = container;
2145                                      info.screenId = c.getInt(screenIndex);
2146                                      info.cellX = c.getInt(cellXIndex);
2147                                      info.cellY = c.getInt(cellYIndex);
2148                                      info.spanX = 1;
2149                                      info.spanY = 1;
2150                                      info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2151 -                                    info.isDisabled = isSafeMode</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2152 -                                            &amp;&amp; !Utilities.isSystemApp(context, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2153 +                                    info.isDisabled = disabledState;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2154 +                                    if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2155 +                                        info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2156 +                                    }</span>
2157  
2158                                      // check &amp; update map of what&#x27;s occupied
2159                                      deleteOnInvalidPlacement.set(false);
2160                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2161                                          if (deleteOnInvalidPlacement.get()) {
2162                                              itemsToRemove.add(id);
2163                                          }
2164                                          break;
2165                                      }
2166  
2167                                      switch (container) {
2168                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2169                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2170                                          sBgWorkspaceItems.add(info);
2171                                          break;
2172                                      default:
2173                                          // Item is in a user folder
2174                                          FolderInfo folderInfo =
2175                                                  findOrMakeFolder(sBgFolders, container);
2176                                          folderInfo.add(info);
2177                                          break;
2178                                      }
2179                                      sBgItemsIdMap.put(info.id, info);
2180  
2181                                      // now that we&#x27;ve loaded everthing re-save it with the
2182                                      // icon in case it disappears somehow.
2183                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2184                                  } else {
2185                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2186                                  }
2187                                  break;
2188  
2189                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2190                                  id = c.getLong(idIndex);
2191                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2192  
2193                                  folderInfo.title = c.getString(titleIndex);
2194                                  folderInfo.id = id;
2195                                  container = c.getInt(containerIndex);
2196                                  folderInfo.container = container;
2197                                  folderInfo.screenId = c.getInt(screenIndex);
2198                                  folderInfo.cellX = c.getInt(cellXIndex);
2199                                  folderInfo.cellY = c.getInt(cellYIndex);
2200                                  folderInfo.spanX = 1;
2201                                  folderInfo.spanY = 1;
2202  
2203                                  // check &amp; update map of what&#x27;s occupied
2204                                  deleteOnInvalidPlacement.set(false);
2205                                  if (!checkItemPlacement(occupied, folderInfo,
2206                                          deleteOnInvalidPlacement)) {
2207                                      if (deleteOnInvalidPlacement.get()) {
2208                                          itemsToRemove.add(id);
2209                                      }
2210                                      break;
2211                                  }
2212  
2213                                  switch (container) {
2214                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2215                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2216                                          sBgWorkspaceItems.add(folderInfo);
2217                                          break;
2218                                  }
2219  
2220                                  if (restored) {
2221                                      // no special handling required for restored folders
2222                                      restoredRows.add(id);
2223                                  }
2224  
2225                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2226                                  sBgFolders.put(folderInfo.id, folderInfo);
2227                                  break;
2228  
2229                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2230                                  // Read all Launcher-specific widget details
2231                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2232                                  String savedProvider = c.getString(appWidgetProviderIndex);
2233                                  id = c.getLong(idIndex);
2234                                  final ComponentName component =
2235                                          ComponentName.unflattenFromString(savedProvider);
2236  
2237                                  final int restoreStatus = c.getInt(restoredIndex);
2238                                  final boolean isIdValid = (restoreStatus &amp;
2239                                          LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2240  
2241                                  final boolean wasProviderReady = (restoreStatus &amp;
2242                                          LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2243  
2244                                  final AppWidgetProviderInfo provider = isIdValid
2245                                          ? widgets.getAppWidgetInfo(appWidgetId)
2246                                          : findAppWidgetProviderInfoWithComponent(context, component);
2247  
2248                                  final boolean isProviderReady = isValidProvider(provider);
2249                                  if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2250                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2251                                              + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2252                                      Log.e(TAG, log);
2253                                      Launcher.addDumpLog(TAG, log, false);
2254                                      itemsToRemove.add(id);
2255                                  } else {
2256                                      if (isProviderReady) {
2257                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2258                                                  provider.provider);
2259                                          int[] minSpan =
2260                                                  Launcher.getMinSpanForWidget(context, provider);
2261                                          appWidgetInfo.minSpanX = minSpan[0];
2262                                          appWidgetInfo.minSpanY = minSpan[1];
2263  
2264                                          int status = restoreStatus;
2265                                          if (!wasProviderReady) {
2266                                              // If provider was not previously ready, update the
2267                                              // status and UI flag.
2268  
<abbr title="2269                                              // Id would be valid only if the widget restore broadcast was received.">2269                                              // Id would be valid only if the widget restore broadcast was receivedðŸ”µ</abbr>
2270                                              if (isIdValid) {
2271                                                  status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2272                                              } else {
2273                                                  status &amp;= ~LauncherAppWidgetInfo
2274                                                          .FLAG_PROVIDER_NOT_READY;
2275                                              }
2276                                          }
2277                                          appWidgetInfo.restoreStatus = status;
2278                                      } else {
2279                                          Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2280                                                  + &quot; appWidgetId=&quot; + appWidgetId
2281                                                  + &quot; status =&quot; + restoreStatus);
2282                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2283                                                  component);
2284                                          appWidgetInfo.restoreStatus = restoreStatus;
2285  
2286                                          if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {
2287                                              // Restore has started once.
2288                                          } else if (installingPkgs.contains(component.getPackageName())) {
2289                                              // App restore has started. Update the flag
2290                                              appWidgetInfo.restoreStatus |=
2291                                                      LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2292                                          } else if (REMOVE_UNRESTORED_ICONS) {
2293                                              Launcher.addDumpLog(TAG,
2294                                                      &quot;Unrestored widget removed: &quot; + component, true);
2295                                              itemsToRemove.add(id);
2296                                              continue;
2297                                          }
2298                                      }
2299  
2300                                      appWidgetInfo.id = id;
2301                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2302                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2303                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2304                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2305                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
2306  
2307                                      container = c.getInt(containerIndex);
2308                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2309                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2310                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2311                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2312                                          continue;
2313                                      }
2314  
2315                                      appWidgetInfo.container = c.getInt(containerIndex);
2316                                      // check &amp; update map of what&#x27;s occupied
2317                                      deleteOnInvalidPlacement.set(false);
2318                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2319                                              deleteOnInvalidPlacement)) {
2320                                          if (deleteOnInvalidPlacement.get()) {
2321                                              itemsToRemove.add(id);
2322                                          }
2323                                          break;
2324                                      }
2325  
2326                                      String providerName = appWidgetInfo.providerName.flattenToString();
2327                                      if (!providerName.equals(savedProvider) ||
2328                                              (appWidgetInfo.restoreStatus != restoreStatus)) {
2329                                          ContentValues values = new ContentValues();
2330                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2331                                                  providerName);
2332                                          values.put(LauncherSettings.Favorites.RESTORED,
2333                                                  appWidgetInfo.restoreStatus);
2334                                          String where = BaseColumns._ID + &quot;= ?&quot;;
2335                                          String[] args = {Long.toString(id)};
2336                                          contentResolver.update(contentUri, values, where, args);
2337                                      }
2338                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2339                                      sBgAppWidgets.add(appWidgetInfo);
2340                                  }
2341                                  break;
2342                              }
2343                          } catch (Exception e) {
2344                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2345                          }
2346                      }
2347                  } finally {
2348                      if (c != null) {
2349                          c.close();
2350                      }
2351                  }
2352  
2353                  // Break early if we&#x27;ve stopped loading
2354                  if (mStopped) {
2355                      clearSBgDataStructures();
2356                      return false;
2357                  }
2358  
2359                  if (itemsToRemove.size() &gt; 0) {
2360                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
2361                              contentUri);
2362                      // Remove dead items
2363                      for (long id : itemsToRemove) {
2364                          if (DEBUG_LOADERS) {
2365                              Log.d(TAG, &quot;Removed id = &quot; + id);
2366                          }
2367                          // Don&#x27;t notify content observers
2368                          try {
2369                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2370                                      null, null);
2371                          } catch (RemoteException e) {
2372                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2373                          }
2374                      }
2375                  }
2376  
2377                  if (restoredRows.size() &gt; 0) {
2378                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2379                              contentUri);
2380                      // Update restored items that no longer require special handling
2381                      try {
2382                          StringBuilder selectionBuilder = new StringBuilder();
2383                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2384                          selectionBuilder.append(&quot; IN (&quot;);
2385                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2386                          selectionBuilder.append(&quot;)&quot;);
2387                          ContentValues values = new ContentValues();
2388                          values.put(LauncherSettings.Favorites.RESTORED, 0);
2389                          updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2390                                  values, selectionBuilder.toString(), null);
2391                      } catch (RemoteException e) {
2392                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2393                      }
2394                  }
2395  
2396                  if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2397                      context.registerReceiver(new AppsAvailabilityCheck(),
2398                              new IntentFilter(StartupReceiver.SYSTEM_READY),
2399                              null, sWorker);
2400                  }
2401  
2402                  if (loadedOldDb) {
2403                      long maxScreenId = 0;
2404                      // If we&#x27;re importing we use the old screen order.
2405                      for (ItemInfo item: sBgItemsIdMap.values()) {
2406                          long screenId = item.screenId;
2407                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2408                                  !sBgWorkspaceScreens.contains(screenId)) {
2409                              sBgWorkspaceScreens.add(screenId);
2410                              if (screenId &gt; maxScreenId) {
2411                                  maxScreenId = screenId;
2412                              }
2413                          }
2414                      }
2415                      Collections.sort(sBgWorkspaceScreens);
2416                      // Log to disk
2417                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2418                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2419                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2420  
2421                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2422                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2423  
2424                      // Update the max item id after we load an old db
2425                      long maxItemId = 0;
2426                      // If we&#x27;re importing we use the old screen order.
2427                      for (ItemInfo item: sBgItemsIdMap.values()) {
2428                          maxItemId = Math.max(maxItemId, item.id);
2429                      }
2430                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2431                  } else {
2432                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2433                      for (Integer i : orderedScreens.keySet()) {
2434                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2435                      }
2436                      // Log to disk
2437                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2438                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2439  
2440                      // Remove any empty screens
2441                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2442                      for (ItemInfo item: sBgItemsIdMap.values()) {
2443                          long screenId = item.screenId;
2444                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2445                                  unusedScreens.contains(screenId)) {
2446                              unusedScreens.remove(screenId);
2447                          }
2448                      }
2449  
2450                      // If there are any empty screens remove them, and update.
2451                      if (unusedScreens.size() != 0) {
2452                          // Log to disk
2453                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2454                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2455  
2456                          sBgWorkspaceScreens.removeAll(unusedScreens);
2457                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2458                      }
2459                  }
2460  
2461                  if (DEBUG_LOADERS) {
2462                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2463                      Log.d(TAG, &quot;workspace layout: &quot;);
2464                      int nScreens = occupied.size();
2465                      for (int y = 0; y &lt; countY; y++) {
2466                          String line = &quot;&quot;;
2467  
2468                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2469                          while (iter.hasNext()) {
2470                              long screenId = iter.next();
2471                              if (screenId &gt; 0) {
2472                                  line += &quot; | &quot;;
2473                              }
2474                              for (int x = 0; x &lt; countX; x++) {
2475                                  ItemInfo[][] screen = occupied.get(screenId);
2476                                  if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2477                                      line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2478                                  } else {
2479                                      line += &quot;!&quot;;
2480                                  }
2481                              }
2482                          }
2483                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2484                      }
2485                  }
2486              }
2487              return loadedOldDb;
2488          }
2489  
2490          /** Filters the set of items who are directly or indirectly (via another container) on the
2491           * specified screen. */
2492          private void filterCurrentWorkspaceItems(long currentScreenId,
2493                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2494                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2495                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2496              // Purge any null ItemInfos
2497              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2498              while (iter.hasNext()) {
2499                  ItemInfo i = iter.next();
2500                  if (i == null) {
2501                      iter.remove();
2502                  }
2503              }
2504  
2505              // Order the set of items by their containers first, this allows use to walk through the
2506              // list sequentially, build up a list of containers that are in the specified screen,
2507              // as well as all items in those containers.
2508              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2509              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2510                  @Override
2511                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2512                      return (int) (lhs.container - rhs.container);
2513                  }
2514              });
2515              for (ItemInfo info : allWorkspaceItems) {
2516                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2517                      if (info.screenId == currentScreenId) {
2518                          currentScreenItems.add(info);
2519                          itemsOnScreen.add(info.id);
2520                      } else {
2521                          otherScreenItems.add(info);
2522                      }
2523                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2524                      currentScreenItems.add(info);
2525                      itemsOnScreen.add(info.id);
2526                  } else {
2527                      if (itemsOnScreen.contains(info.container)) {
2528                          currentScreenItems.add(info);
2529                          itemsOnScreen.add(info.id);
2530                      } else {
2531                          otherScreenItems.add(info);
2532                      }
2533                  }
2534              }
2535          }
2536  
2537          /** Filters the set of widgets which are on the specified screen. */
2538          private void filterCurrentAppWidgets(long currentScreenId,
2539                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2540                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2541                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2542  
2543              for (LauncherAppWidgetInfo widget : appWidgets) {
2544                  if (widget == null) continue;
2545                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2546                          widget.screenId == currentScreenId) {
2547                      currentScreenWidgets.add(widget);
2548                  } else {
2549                      otherScreenWidgets.add(widget);
2550                  }
2551              }
2552          }
2553  
2554          /** Filters the set of folders which are on the specified screen. */
2555          private void filterCurrentFolders(long currentScreenId,
2556                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2557                  HashMap&lt;Long, FolderInfo&gt; folders,
2558                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2559                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2560  
2561              for (long id : folders.keySet()) {
2562                  ItemInfo info = itemsIdMap.get(id);
2563                  FolderInfo folder = folders.get(id);
2564                  if (info == null || folder == null) continue;
2565                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2566                          info.screenId == currentScreenId) {
2567                      currentScreenFolders.put(id, folder);
2568                  } else {
2569                      otherScreenFolders.put(id, folder);
2570                  }
2571              }
2572          }
2573  
2574          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2575           * right) */
2576          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2577              final LauncherAppState app = LauncherAppState.getInstance();
2578              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2579              // XXX: review this
2580              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2581                  @Override
2582                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2583                      int cellCountX = (int) grid.numColumns;
2584                      int cellCountY = (int) grid.numRows;
2585                      int screenOffset = cellCountX * cellCountY;
2586                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2587                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2588                              lhs.cellY * cellCountX + lhs.cellX);
2589                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2590                              rhs.cellY * cellCountX + rhs.cellX);
2591                      return (int) (lr - rr);
2592                  }
2593              });
2594          }
2595  
2596          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2597                  final ArrayList&lt;Long&gt; orderedScreens) {
2598              final Runnable r = new Runnable() {
2599                  @Override
2600                  public void run() {
2601                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2602                      if (callbacks != null) {
2603                          callbacks.bindScreens(orderedScreens);
2604                      }
2605                  }
2606              };
2607              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2608          }
2609  
2610          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2611                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2612                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2613                  final HashMap&lt;Long, FolderInfo&gt; folders,
2614                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2615  
2616              final boolean postOnMainThread = (deferredBindRunnables != null);
2617  
2618              // Bind the workspace items
2619              int N = workspaceItems.size();
2620              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2621                  final int start = i;
2622                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2623                  final Runnable r = new Runnable() {
2624                      @Override
2625                      public void run() {
2626                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2627                          if (callbacks != null) {
2628                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2629                                      false);
2630                          }
2631                      }
2632                  };
2633                  if (postOnMainThread) {
2634                      synchronized (deferredBindRunnables) {
2635                          deferredBindRunnables.add(r);
2636                      }
2637                  } else {
2638                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2639                  }
2640              }
2641  
2642              // Bind the folders
2643              if (!folders.isEmpty()) {
2644                  final Runnable r = new Runnable() {
2645                      public void run() {
2646                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2647                          if (callbacks != null) {
2648                              callbacks.bindFolders(folders);
2649                          }
2650                      }
2651                  };
2652                  if (postOnMainThread) {
2653                      synchronized (deferredBindRunnables) {
2654                          deferredBindRunnables.add(r);
2655                      }
2656                  } else {
2657                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2658                  }
2659              }
2660  
2661              // Bind the widgets, one at a time
2662              N = appWidgets.size();
2663              for (int i = 0; i &lt; N; i++) {
2664                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2665                  final Runnable r = new Runnable() {
2666                      public void run() {
2667                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2668                          if (callbacks != null) {
2669                              callbacks.bindAppWidget(widget);
2670                          }
2671                      }
2672                  };
2673                  if (postOnMainThread) {
2674                      deferredBindRunnables.add(r);
2675                  } else {
2676                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2677                  }
2678              }
2679          }
2680  
2681          /**
2682           * Binds all loaded data to actual views on the main thread.
2683           */
2684          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2685              final long t = SystemClock.uptimeMillis();
2686              Runnable r;
2687  
2688              // Don&#x27;t use these two variables in any of the callback runnables.
2689              // Otherwise we hold a reference to them.
2690              final Callbacks oldCallbacks = mCallbacks.get();
2691              if (oldCallbacks == null) {
2692                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2693                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2694                  return;
2695              }
2696  
2697              // Save a copy of all the bg-thread collections
2698              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2699              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2700                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2701              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2702              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2703              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2704              synchronized (sBgLock) {
2705                  workspaceItems.addAll(sBgWorkspaceItems);
2706                  appWidgets.addAll(sBgAppWidgets);
2707                  folders.putAll(sBgFolders);
2708                  itemsIdMap.putAll(sBgItemsIdMap);
2709                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2710              }
2711  
2712              final boolean isLoadingSynchronously =
2713                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2714              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2715                  oldCallbacks.getCurrentWorkspaceScreen();
2716              if (currScreen &gt;= orderedScreenIds.size()) {
2717                  // There may be no workspace screens (just hotseat items and an empty page).
2718                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2719              }
2720              final int currentScreen = currScreen;
2721              final long currentScreenId = currentScreen &lt; 0
2722                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2723  
2724              // Load all the items that are on the current page first (and in the process, unbind
2725              // all the existing workspace items before we call startBinding() below.
2726              unbindWorkspaceItemsOnMainThread();
2727  
2728              // Separate the items that are on the current screen, and all the other remaining items
2729              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2730              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2731              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2732                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2733              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2734                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2735              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2736              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2737  
2738              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2739                      otherWorkspaceItems);
2740              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2741                      otherAppWidgets);
2742              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2743                      otherFolders);
2744              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2745              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2746  
2747              // Tell the workspace that we&#x27;re about to start binding items
2748              r = new Runnable() {
2749                  public void run() {
2750                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2751                      if (callbacks != null) {
2752                          callbacks.startBinding();
2753                      }
2754                  }
2755              };
2756              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2757  
2758              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2759  
2760              // Load items on the current page
2761              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2762                      currentFolders, null);
2763              if (isLoadingSynchronously) {
2764                  r = new Runnable() {
2765                      public void run() {
2766                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2767                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2768                              callbacks.onPageBoundSynchronously(currentScreen);
2769                          }
2770                      }
2771                  };
2772                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2773              }
2774  
2775              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2776              // work until after the first render)
2777              synchronized (mDeferredBindRunnables) {
2778                  mDeferredBindRunnables.clear();
2779              }
2780              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2781                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2782  
2783              // Tell the workspace that we&#x27;re done binding items
2784              r = new Runnable() {
2785                  public void run() {
2786                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2787                      if (callbacks != null) {
2788                          callbacks.finishBindingItems(isUpgradePath);
2789                      }
2790  
2791                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2792                      if (DEBUG_LOADERS) {
2793                          Log.d(TAG, &quot;bound workspace in &quot;
2794                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2795                      }
2796  
2797                      mIsLoadingAndBindingWorkspace = false;
2798                  }
2799              };
2800              if (isLoadingSynchronously) {
2801                  synchronized (mDeferredBindRunnables) {
2802                      mDeferredBindRunnables.add(r);
2803                  }
2804              } else {
2805                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2806              }
2807          }
2808  
2809          private void loadAndBindAllApps() {
2810              if (DEBUG_LOADERS) {
2811                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2812              }
2813              if (!mAllAppsLoaded) {
2814                  loadAllApps();
2815                  synchronized (LoaderTask.this) {
2816                      if (mStopped) {
2817                          return;
2818                      }
2819                      mAllAppsLoaded = true;
2820                  }
2821              } else {
2822                  onlyBindAllApps();
2823              }
2824          }
2825  
2826          private void onlyBindAllApps() {
2827              final Callbacks oldCallbacks = mCallbacks.get();
2828              if (oldCallbacks == null) {
2829                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2830                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2831                  return;
2832              }
2833  
2834              // shallow copy
2835              @SuppressWarnings(&quot;unchecked&quot;)
2836              final ArrayList&lt;AppInfo&gt; list
2837                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2838              Runnable r = new Runnable() {
2839                  public void run() {
2840                      final long t = SystemClock.uptimeMillis();
2841                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2842                      if (callbacks != null) {
2843                          callbacks.bindAllApplications(list);
2844                      }
2845                      if (DEBUG_LOADERS) {
2846                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2847                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2848                      }
2849                  }
2850              };
2851              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2852              if (isRunningOnMainThread) {
2853                  r.run();
2854              } else {
2855                  mHandler.post(r);
2856              }
2857          }
2858  
2859          private void loadAllApps() {
2860              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2861  
2862              final Callbacks oldCallbacks = mCallbacks.get();
2863              if (oldCallbacks == null) {
2864                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2865                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2866                  return;
2867              }
2868  
2869              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2870              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2871  
2872              final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2873  
2874              // Clear the list of apps
2875              mBgAllAppsList.clear();
2876              for (UserHandleCompat user : profiles) {
2877                  // Query for the set of apps
2878                  final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2879                  List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2880                  if (DEBUG_LOADERS) {
2881                      Log.d(TAG, &quot;getActivityList took &quot;
2882                              + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2883                      Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2884                  }
2885                  // Fail if we don&#x27;t have any apps
2886                  if (apps == null || apps.isEmpty()) {
2887                      return;
2888                  }
2889                  // Sort the applications by name
2890                  final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2891                  Collections.sort(apps,
2892                          new LauncherModel.ShortcutNameComparator(mLabelCache));
2893                  if (DEBUG_LOADERS) {
2894                      Log.d(TAG, &quot;sort took &quot;
2895                              + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2896                  }
2897  
2898                  // Create the ApplicationInfos
2899                  for (int i = 0; i &lt; apps.size(); i++) {
2900                      LauncherActivityInfoCompat app = apps.get(i);
2901                      // This builds the icon bitmaps.
2902                      mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2903                  }
2904              }
2905              // Huh? Shouldn&#x27;t this be inside the Runnable below?
2906              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2907              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2908  
2909              // Post callback on main thread
2910              mHandler.post(new Runnable() {
2911                  public void run() {
2912                      final long bindTime = SystemClock.uptimeMillis();
2913                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2914                      if (callbacks != null) {
2915                          callbacks.bindAllApplications(added);
2916                          if (DEBUG_LOADERS) {
2917                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2918                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2919                          }
2920                      } else {
2921                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2922                      }
2923                  }
2924              });
2925  
2926              if (DEBUG_LOADERS) {
2927                  Log.d(TAG, &quot;Icons processed in &quot;
2928                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2929              }
2930          }
2931  
2932          public void dumpState() {
2933              synchronized (sBgLock) {
2934                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2935                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2936                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2937                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2938                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2939              }
2940          }
2941      }
2942  
2943      void enqueuePackageUpdated(PackageUpdatedTask task) {
2944          sWorker.post(task);
2945      }
2946  
2947      private class AppsAvailabilityCheck extends BroadcastReceiver {
2948  
2949          @Override
2950          public void onReceive(Context context, Intent intent) {
2951              synchronized (sBgLock) {
2952                  final LauncherAppsCompat launcherApps = LauncherAppsCompat
2953                          .getInstance(mApp.getContext());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2954 -                ArrayList&lt;String&gt; packagesRemoved;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2955 +                final PackageManager manager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2956 +                final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2957 +                final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();</span>
2958                  for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2959                      UserHandleCompat user = entry.getKey();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2960 -                    packagesRemoved = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2961 +                    packagesRemoved.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2962 +                    packagesUnavailable.clear();</span>
2963                      for (String pkg : entry.getValue()) {
2964                          if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2965 -                            Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2966 -                            packagesRemoved.add(pkg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2967 +                            boolean packageOnSdcard = launcherApps.isAppEnabled(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2968 +                                    manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2969 +                            if (packageOnSdcard) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2970 +                                Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2971 +                                packagesUnavailable.add(pkg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2972 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2973 +                                Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2974 +                                packagesRemoved.add(pkg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2975 +                            }</span>
2976                          }
2977                      }
2978                      if (!packagesRemoved.isEmpty()) {
2979                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2980                                  packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2981 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2982 +                    if (!packagesUnavailable.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2983 +                        enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2984 +                                packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));</span>
2985                      }
2986                  }
2987                  sPendingPackages.clear();
2988              }
2989          }
2990      }
2991  


























































2992      private class PackageUpdatedTask implements Runnable {
2993          int mOp;
2994          String[] mPackages;
2995          UserHandleCompat mUser;
2996  
2997          public static final int OP_NONE = 0;
2998          public static final int OP_ADD = 1;
2999          public static final int OP_UPDATE = 2;
3000          public static final int OP_REMOVE = 3; // uninstlled
3001          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3002  
3003  
3004          public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3005              mOp = op;
3006              mPackages = packages;
3007              mUser = user;
3008          }
3009  
3010          public void run() {
3011              final Context context = mApp.getContext();
3012  
3013              final String[] packages = mPackages;
3014              final int N = packages.length;
3015              switch (mOp) {
3016                  case OP_ADD:
3017                      for (int i=0; i&lt;N; i++) {
3018                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3019                          mIconCache.remove(packages[i], mUser);
3020                          mBgAllAppsList.addPackage(context, packages[i], mUser);
3021                      }
3022                      break;
3023                  case OP_UPDATE:
3024                      for (int i=0; i&lt;N; i++) {
3025                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3026                          mBgAllAppsList.updatePackage(context, packages[i], mUser);
3027                          WidgetPreviewLoader.removePackageFromDb(
3028                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3029                      }
3030                      break;
3031                  case OP_REMOVE:
3032                  case OP_UNAVAILABLE:
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3033 +                    boolean clearCache = mOp == OP_REMOVE;</span>
3034                      for (int i=0; i&lt;N; i++) {
3035                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3036 -                        mBgAllAppsList.removePackage(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3037 +                        mBgAllAppsList.removePackage(packages[i], mUser, clearCache);</span>
3038                          WidgetPreviewLoader.removePackageFromDb(
3039                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3040                      }
3041                      break;
3042              }
3043  
3044              ArrayList&lt;AppInfo&gt; added = null;
3045              ArrayList&lt;AppInfo&gt; modified = null;
3046              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3047  
3048              if (mBgAllAppsList.added.size() &gt; 0) {
3049                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3050                  mBgAllAppsList.added.clear();
3051              }
3052              if (mBgAllAppsList.modified.size() &gt; 0) {
3053                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3054                  mBgAllAppsList.modified.clear();
3055              }
3056              if (mBgAllAppsList.removed.size() &gt; 0) {
3057                  removedApps.addAll(mBgAllAppsList.removed);
3058                  mBgAllAppsList.removed.clear();
3059              }
3060  
3061              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3062              if (callbacks == null) {
3063                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3064                  return;
3065              }
3066  
3067              if (added != null) {
3068                  // Ensure that we add all the workspace applications to the db
3069                  if (LauncherAppState.isDisableAllApps()) {
3070                      final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3071                      addAndBindAddedWorkspaceApps(context, addedInfos);
3072                  } else {
3073                      addAppsToAllApps(context, added);
3074                  }
3075              }
3076  
3077              if (modified != null) {
3078                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3079  
3080                  // Update the launcher db to reflect the changes
3081                  for (AppInfo a : modifiedFinal) {
3082                      ArrayList&lt;ItemInfo&gt; infos =
3083                              getItemInfoForComponentName(a.componentName, mUser);
3084                      for (ItemInfo i : infos) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3085 -                        if (isShortcutInfoUpdateable(i)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3086 +                        if (i instanceof ShortcutInfo &amp;&amp; isShortcutAppTarget((ShortcutInfo) i)) {</span>
3087                              ShortcutInfo info = (ShortcutInfo) i;
3088                              info.title = a.title.toString();
3089                              info.contentDescription = a.contentDescription;
3090                              updateItemInDatabase(context, info);
3091                          }
3092                      }
3093                  }
3094  
3095                  mHandler.post(new Runnable() {
3096                      public void run() {
3097                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3098                          if (callbacks == cb &amp;&amp; cb != null) {
3099                              callbacks.bindAppsUpdated(modifiedFinal);
3100                          }
3101                      }
3102                  });
3103              }
3104  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3105 +            // Update shortcuts which use an iconResource</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3106 +            if (mOp == OP_ADD || mOp == OP_UPDATE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3107 +                final ArrayList&lt;ShortcutInfo&gt; iconsChanged = new ArrayList&lt;ShortcutInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3108 +                HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3109 +                // We need to iterate over the items here, so that we can avoid new Bitmap</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3110 +                // creation on the UI thread.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3111 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3112 +                    for (ItemInfo info : sBgWorkspaceItems) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3113 +                        if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3114 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3115 +                            if ((si.iconResource != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3116 +                                    &amp;&amp; packageSet.contains(si.getTargetComponent().getPackageName())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3117 +                                Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3118 +                                        si.iconResource.resourceName, mIconCache, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3119 +                                if (icon != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3120 +                                    si.setIcon(icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3121 +                                    si.usingFallbackIcon = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3122 +                                    iconsChanged.add(si);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3123 +                                    updateItemInDatabase(context, si);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3124 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3125 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3126 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3127 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3128 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3129 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3130 +                if (!iconsChanged.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3131 +                    mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3132 +                        public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3133 +                            Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3134 +                            if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3135 +                                callbacks.bindShortcutsUpdated(iconsChanged);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3136 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3137 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3138 +                    });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3139 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3140 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3141 +</span>
3142              final ArrayList&lt;String&gt; removedPackageNames =
3143                      new ArrayList&lt;String&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3144 -            if (mOp == OP_REMOVE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3145 +            if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {</span>
3146                  // Mark all packages in the broadcast to be removed
3147                  removedPackageNames.addAll(Arrays.asList(packages));
3148              } else if (mOp == OP_UPDATE) {
3149                  // Mark disabled packages in the broadcast to be removed
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3150 -                final PackageManager pm = context.getPackageManager();</span>
3151                  for (int i=0; i&lt;N; i++) {
3152                      if (isPackageDisabled(context, packages[i], mUser)) {
3153                          removedPackageNames.add(packages[i]);
3154                      }
3155                  }
3156              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3157 -            // Remove all the components associated with this package</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3158 -            for (String pn : removedPackageNames) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3159 -                deletePackageFromDatabase(context, pn, mUser);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3160 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3161 -            // Remove all the specific components</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3162 -            for (AppInfo a : removedApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3163 -                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3164 -                deleteItemsFromDatabase(context, infos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3165 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3166 +</span>
3167              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3168 +                final int removeReason;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3169 +                if (mOp == OP_UNAVAILABLE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3170 +                    removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3171 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3172 +                    // Remove all the components associated with this package</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3173 +                    for (String pn : removedPackageNames) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3174 +                        deletePackageFromDatabase(context, pn, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3175 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3176 +                    // Remove all the specific components</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3177 +                    for (AppInfo a : removedApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3178 +                        ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3179 +                        deleteItemsFromDatabase(context, infos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3180 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3181 +                    removeReason = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3182 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3183 +</span>
3184                  // Remove any queued items from the install queue
3185                  String spKey = LauncherAppState.getSharedPreferencesKey();
3186                  SharedPreferences sp =
3187                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3188                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3189                  // Call the components-removed callback
3190                  mHandler.post(new Runnable() {
3191                      public void run() {
3192                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3193                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3194 -                            callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3195 +                            callbacks.bindComponentsRemoved(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3196 +                                    removedPackageNames, removedApps, mUser, removeReason);</span>
3197                          }
3198                      }
3199                  });
3200              }
3201  
3202              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3203                      getSortedWidgetsAndShortcuts(context);
3204              mHandler.post(new Runnable() {
3205                  @Override
3206                  public void run() {
3207                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3208                      if (callbacks == cb &amp;&amp; cb != null) {
3209                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3210                      }
3211                  }
3212              });
3213  
3214              // Write all the logs to disk
3215              mHandler.post(new Runnable() {
3216                  public void run() {
3217                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3218                      if (callbacks == cb &amp;&amp; cb != null) {
3219                          callbacks.dumpLogsToLocalData();
3220                      }
3221                  }
3222              });
3223          }
3224      }
3225  
3226      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3227      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3228          PackageManager packageManager = context.getPackageManager();
3229          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3230          widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3231  
3232          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3233          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3234          Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3235          return widgetsAndShortcuts;
3236      }
3237  
3238      private static boolean isPackageDisabled(Context context, String packageName,
3239              UserHandleCompat user) {
3240          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3241          return !launcherApps.isPackageEnabledForProfile(packageName, user);
3242      }
3243  
3244      public static boolean isValidPackageActivity(Context context, ComponentName cn,
3245              UserHandleCompat user) {
3246          if (cn == null) {
3247              return false;
3248          }
3249          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3250          if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3251              return false;
3252          }
3253          return launcherApps.isActivityEnabledForProfile(cn, user);
3254      }
3255  
3256      public static boolean isValidPackage(Context context, String packageName,
3257              UserHandleCompat user) {
3258          if (packageName == null) {
3259              return false;
3260          }
3261          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3262          return launcherApps.isPackageEnabledForProfile(packageName, user);
3263      }
3264  
3265      /**
3266       * Make an ShortcutInfo object for a restored application or shortcut item that points
3267       * to a package that is not yet installed on the system.
3268       */
3269      public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3270              int promiseType) {
3271          final ShortcutInfo info = new ShortcutInfo();
3272          info.user = UserHandleCompat.myUserHandle();
3273          mIconCache.getTitleAndIcon(info, intent, info.user, true);
3274  
3275          if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3276              String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3277              if (!TextUtils.isEmpty(title)) {
3278                  info.title = title;
3279              }
3280              info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3281          } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3282              if (TextUtils.isEmpty(info.title)) {
3283                  info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3284              }
3285              info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3286          } else {
3287              throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3288          }
3289  
3290          info.contentDescription = mUserManager.getBadgedLabelForUser(
3291                  info.title.toString(), info.user);
3292          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3293          info.promisedIntent = intent;
3294          return info;
3295      }
3296  
3297      /**
3298       * Make an Intent object for a restored application or shortcut item that points
3299       * to the market page for the item.
3300       */
3301      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3302          ComponentName componentName = intent.getComponent();
3303          return getMarketIntent(componentName.getPackageName());
3304      }
3305  
3306      static Intent getMarketIntent(String packageName) {
3307          return new Intent(Intent.ACTION_VIEW)
3308              .setData(new Uri.Builder()
3309                  .scheme(&quot;market&quot;)
3310                  .authority(&quot;details&quot;)
3311                  .appendQueryParameter(&quot;id&quot;, packageName)
3312                  .build());
3313      }
3314  
3315      /**
3316       * This is called from the code that adds shortcuts from the intent receiver.  This
3317       * doesn&#x27;t have a Cursor, but
3318       */
3319      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3320              UserHandleCompat user, Context context) {
3321          return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3322      }
3323  
3324      /**
3325       * Make an ShortcutInfo object for a shortcut that is an application.
3326       *
3327       * If c is not null, then it will be used to fill in missing data like the title and icon.
3328       */
3329      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3330              UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3331              HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3332          if (user == null) {
3333              Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3334              return null;
3335          }
3336  
3337          ComponentName componentName = intent.getComponent();
3338          if (componentName == null) {
3339              Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3340              return null;
3341          }
3342  
3343          Intent newIntent = new Intent(intent.getAction(), null);
3344          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3345          newIntent.setComponent(componentName);
3346          LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3347          if ((lai == null) &amp;&amp; !allowMissingTarget) {
3348              Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3349              return null;
3350          }
3351  
3352          final ShortcutInfo info = new ShortcutInfo();
3353  
3354          // the resource -- This may implicitly give us back the fallback icon,
3355          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3356          // to avoid saving lots of copies of that in the database, and most apps
3357          // have icons anyway.
3358          Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3359  
3360          // the db
3361          if (icon == null) {
3362              if (c != null) {
3363                  icon = getIconFromCursor(c, iconIndex, context);
3364              }
3365          }
3366          // the fallback icon
3367          if (icon == null) {
3368              icon = mIconCache.getDefaultIcon(user);
3369              info.usingFallbackIcon = true;
3370          }
3371          info.setIcon(icon);
3372  
3373          // From the cache.
3374          if (labelCache != null) {
3375              info.title = labelCache.get(componentName);
3376          }
3377  
3378          // from the resource
3379          if (info.title == null &amp;&amp; lai != null) {
3380              info.title = lai.getLabel();
3381              if (labelCache != null) {
3382                  labelCache.put(componentName, info.title);
3383              }
3384          }
3385          // from the db
3386          if (info.title == null) {
3387              if (c != null) {
3388                  info.title =  c.getString(titleIndex);
3389              }
3390          }
3391          // fall back to the class name of the activity
3392          if (info.title == null) {
3393              info.title = componentName.getClassName();
3394          }
3395          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3396          info.user = user;
3397          info.contentDescription = mUserManager.getBadgedLabelForUser(
3398                  info.title.toString(), info.user);
3399          return info;
3400      }
3401  
3402      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3403              ItemInfoFilter f) {
3404          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3405          for (ItemInfo i : infos) {
3406              if (i instanceof ShortcutInfo) {
3407                  ShortcutInfo info = (ShortcutInfo) i;
3408                  ComponentName cn = info.getTargetComponent();
3409                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3410                      filtered.add(info);
3411                  }
3412              } else if (i instanceof FolderInfo) {
3413                  FolderInfo info = (FolderInfo) i;
3414                  for (ShortcutInfo s : info.contents) {
3415                      ComponentName cn = s.getTargetComponent();
3416                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3417                          filtered.add(s);
3418                      }
3419                  }
3420              } else if (i instanceof LauncherAppWidgetInfo) {
3421                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3422                  ComponentName cn = info.providerName;
3423                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3424                      filtered.add(info);
3425                  }
3426              }
3427          }
3428          return new ArrayList&lt;ItemInfo&gt;(filtered);
3429      }
3430  
3431      private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3432              final UserHandleCompat user) {
3433          ItemInfoFilter filter  = new ItemInfoFilter() {
3434              @Override
3435              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3436                  if (info.user == null) {
3437                      return cn.equals(cname);
3438                  } else {
3439                      return cn.equals(cname) &amp;&amp; info.user.equals(user);
3440                  }
3441              }
3442          };
3443          return filterItemInfos(sBgItemsIdMap.values(), filter);
3444      }
3445  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3446 -    public static boolean isShortcutInfoUpdateable(ItemInfo i) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3447 -        if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3448 -            ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3449 -            // We need to check for ACTION_MAIN otherwise getComponent() might</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3450 -            // return null for some shortcuts (for instance, for shortcuts to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3451 -            // web pages.)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3452 -            Intent intent = info.intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3453 -            ComponentName name = intent.getComponent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3454 -            if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3455 -                    Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3456 -                return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3457 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3458 -            // placeholder shortcuts get special treatment, let them through too.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3459 -            if (info.isPromise()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3460 -                return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3461 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3462 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3463 -        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3464 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3465 +     * @return true if the ShortcutInfo points to an app shortcut target, i.e. it has been added by</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3466 +     * dragging from AllApps list.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3467 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3468 +    public static boolean isShortcutAppTarget(ShortcutInfo info) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3469 +        // We need to check for ACTION_MAIN otherwise getComponent() might</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3470 +        // return null for some shortcuts (for instance, for shortcuts to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3471 +        // web pages.)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3472 +        Intent intent = info.promisedIntent != null ? info.promisedIntent : info.intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3473 +        ComponentName name = intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3474 +        return info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3475 +                Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null;</span>
3476      }
3477  
3478      /**
3479       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3480       */
3481      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3482              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3483              int titleIndex) {
3484  
3485          Bitmap icon = null;
3486          final ShortcutInfo info = new ShortcutInfo();
3487          // Non-app shortcuts are only supported for current user.
3488          info.user = UserHandleCompat.myUserHandle();
3489          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3490  
3491          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3492  
3493          info.title = c.getString(titleIndex);
3494  
3495          int iconType = c.getInt(iconTypeIndex);
3496          switch (iconType) {
3497          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3498              String packageName = c.getString(iconPackageIndex);
3499              String resourceName = c.getString(iconResourceIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3500 -            PackageManager packageManager = context.getPackageManager();</span>
3501              info.customIcon = false;
3502              // the resource
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3503 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3504 -                Resources resources = packageManager.getResourcesForApplication(packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3505 -                if (resources != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3506 -                    final int id = resources.getIdentifier(resourceName, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3507 -                    icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3508 -                            mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3509 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3510 -            } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3511 -                // drop this.  we have other places to look for icons</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3512 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3513 +            icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);</span>
3514              // the db
3515              if (icon == null) {
3516                  icon = getIconFromCursor(c, iconIndex, context);
3517              }
3518              // the fallback icon
3519              if (icon == null) {
3520                  icon = mIconCache.getDefaultIcon(info.user);
3521                  info.usingFallbackIcon = true;
3522              }
3523              break;
3524          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3525              icon = getIconFromCursor(c, iconIndex, context);
3526              if (icon == null) {
3527                  icon = mIconCache.getDefaultIcon(info.user);
3528                  info.customIcon = false;
3529                  info.usingFallbackIcon = true;
3530              } else {
3531                  info.customIcon = true;
3532              }
3533              break;
3534          default:
3535              icon = mIconCache.getDefaultIcon(info.user);
3536              info.usingFallbackIcon = true;
3537              info.customIcon = false;
3538              break;
3539          }
3540          info.setIcon(icon);
3541          return info;
3542      }
3543  
3544      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3545          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3546          final boolean debug = false;
3547          if (debug) {
3548              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3549                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3550          }
3551          byte[] data = c.getBlob(iconIndex);
3552          try {
3553              return Utilities.createIconBitmap(
3554                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3555          } catch (Exception e) {
3556              return null;
3557          }
3558      }
3559  
3560      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3561              int cellX, int cellY, boolean notify) {
3562          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3563          if (info == null) {
3564              return null;
3565          }
3566          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3567  
3568          return info;
3569      }
3570  
3571      /**
3572       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3573       */
3574      static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3575              ComponentName component) {
3576          List&lt;AppWidgetProviderInfo&gt; widgets =
3577              AppWidgetManager.getInstance(context).getInstalledProviders();
3578          for (AppWidgetProviderInfo info : widgets) {
3579              if (info.provider.equals(component)) {
3580                  return info;
3581              }
3582          }
3583          return null;
3584      }
3585  
3586      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3587          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3588          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3589          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3590  
3591          if (intent == null) {
3592              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3593              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3594              return null;
3595          }
3596  
3597          Bitmap icon = null;
3598          boolean customIcon = false;
3599          ShortcutIconResource iconResource = null;
3600  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3601 -        if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3602 -            icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3603 +        if (bitmap instanceof Bitmap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3604 +            icon = Utilities.createIconBitmap((Bitmap) bitmap, context);</span>
3605              customIcon = true;
3606          } else {
3607              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3608 -            if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3609 -                try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3610 -                    iconResource = (ShortcutIconResource) extra;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3611 -                    final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3612 -                    Resources resources = packageManager.getResourcesForApplication(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3613 -                            iconResource.packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3614 -                    final int id = resources.getIdentifier(iconResource.resourceName, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3615 -                    icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3616 -                            mIconCache.getFullResIcon(resources, id),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3617 -                            context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3618 -                } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3619 -                    Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3620 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3621 +            if (extra instanceof ShortcutIconResource) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3622 +                iconResource = (ShortcutIconResource) extra;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3623 +                icon = Utilities.createIconBitmap(iconResource.packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3624 +                        iconResource.resourceName, mIconCache, context);</span>
3625              }
3626          }
3627  
3628          final ShortcutInfo info = new ShortcutInfo();
3629  
3630          // Only support intents for current user for now. Intents sent from other
3631          // users wouldn&#x27;t get here without intent forwarding anyway.
3632          info.user = UserHandleCompat.myUserHandle();
3633          if (icon == null) {
3634              if (fallbackIcon != null) {
3635                  icon = fallbackIcon;
3636              } else {
3637                  icon = mIconCache.getDefaultIcon(info.user);
3638                  info.usingFallbackIcon = true;
3639              }
3640          }
3641          info.setIcon(icon);
3642  
3643          info.title = name;
3644          info.contentDescription = mUserManager.getBadgedLabelForUser(
3645                  info.title.toString(), info.user);
3646          info.intent = intent;
3647          info.customIcon = customIcon;
3648          info.iconResource = iconResource;
3649  
3650          return info;
3651      }
3652  
3653      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3654              int iconIndex) {
3655          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3656          if (!mAppsCanBeOnRemoveableStorage) {
3657              return false;
3658          }
3659          // If this icon doesn&#x27;t have a custom icon, check to see
3660          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3661          // we&#x27;re going to show, store what we are going to show back
3662          // into the DB.  We do this so when we&#x27;re loading, if the
3663          // package manager can&#x27;t find an icon (for example because
3664          // the app is on SD) then we can use that instead.
3665          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3666              cache.put(info, c.getBlob(iconIndex));
3667              return true;
3668          }
3669          return false;
3670      }
3671      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3672          boolean needSave = false;
3673          try {
3674              if (data != null) {
3675                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3676                  Bitmap loaded = info.getIcon(mIconCache);
3677                  needSave = !saved.sameAs(loaded);
3678              } else {
3679                  needSave = true;
3680              }
3681          } catch (Exception e) {
3682              needSave = true;
3683          }
3684          if (needSave) {
3685              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3686              // This is slower than is ideal, but this only happens once
3687              // or when the app is updated with a new icon.
3688              updateItemInDatabase(context, info);
3689          }
3690      }
3691  
3692      /**
3693       * Return an existing FolderInfo object if we have encountered this ID previously,
3694       * or make a new one.
3695       */
3696      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3697          // See if a placeholder was created for us already
3698          FolderInfo folderInfo = folders.get(id);
3699          if (folderInfo == null) {
3700              // No placeholder -- create a new instance
3701              folderInfo = new FolderInfo();
3702              folders.put(id, folderInfo);
3703          }
3704          return folderInfo;
3705      }
3706  
3707      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3708          final Collator collator = Collator.getInstance();
3709          return new Comparator&lt;AppInfo&gt;() {
3710              public final int compare(AppInfo a, AppInfo b) {
3711                  if (a.user.equals(b.user)) {
3712                      int result = collator.compare(a.title.toString().trim(),
3713                              b.title.toString().trim());
3714                      if (result == 0) {
3715                          result = a.componentName.compareTo(b.componentName);
3716                      }
3717                      return result;
3718                  } else {
3719                      // TODO Need to figure out rules for sorting
3720                      // profiles, this puts work second.
3721                      return a.user.toString().compareTo(b.user.toString());
3722                  }
3723              }
3724          };
3725      }
3726      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3727              = new Comparator&lt;AppInfo&gt;() {
3728          public final int compare(AppInfo a, AppInfo b) {
3729              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3730              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3731              return 0;
3732          }
3733      };
3734      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3735          if (info.activityInfo != null) {
3736              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3737          } else {
3738              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3739          }
3740      }
3741      public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3742          private Collator mCollator;
3743          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3744          ShortcutNameComparator(PackageManager pm) {
3745              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3746              mCollator = Collator.getInstance();
3747          }
3748          ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3749              mLabelCache = labelCache;
3750              mCollator = Collator.getInstance();
3751          }
3752          public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3753              String labelA, labelB;
3754              ComponentName keyA = a.getComponentName();
3755              ComponentName keyB = b.getComponentName();
3756              if (mLabelCache.containsKey(keyA)) {
3757                  labelA = mLabelCache.get(keyA).toString();
3758              } else {
3759                  labelA = a.getLabel().toString().trim();
3760  
3761                  mLabelCache.put(keyA, labelA);
3762              }
3763              if (mLabelCache.containsKey(keyB)) {
3764                  labelB = mLabelCache.get(keyB).toString();
3765              } else {
3766                  labelB = b.getLabel().toString().trim();
3767  
3768                  mLabelCache.put(keyB, labelB);
3769              }
3770              return mCollator.compare(labelA, labelB);
3771          }
3772      };
3773      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3774          private final AppWidgetManagerCompat mManager;
3775          private final PackageManager mPackageManager;
3776          private final HashMap&lt;Object, String&gt; mLabelCache;
3777          private final Collator mCollator;
3778  
3779          WidgetAndShortcutNameComparator(Context context) {
3780              mManager = AppWidgetManagerCompat.getInstance(context);
3781              mPackageManager = context.getPackageManager();
3782              mLabelCache = new HashMap&lt;Object, String&gt;();
3783              mCollator = Collator.getInstance();
3784          }
3785          public final int compare(Object a, Object b) {
3786              String labelA, labelB;
3787              if (mLabelCache.containsKey(a)) {
3788                  labelA = mLabelCache.get(a);
3789              } else {
3790                  labelA = (a instanceof AppWidgetProviderInfo)
3791                          ? mManager.loadLabel((AppWidgetProviderInfo) a)
3792                          : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3793                  mLabelCache.put(a, labelA);
3794              }
3795              if (mLabelCache.containsKey(b)) {
3796                  labelB = mLabelCache.get(b);
3797              } else {
3798                  labelB = (b instanceof AppWidgetProviderInfo)
3799                          ? mManager.loadLabel((AppWidgetProviderInfo) b)
3800                          : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3801                  mLabelCache.put(b, labelB);
3802              }
3803              return mCollator.compare(labelA, labelB);
3804          }
3805      };
3806  
3807      static boolean isValidProvider(AppWidgetProviderInfo provider) {
3808          return (provider != null) &amp;&amp; (provider.provider != null)
3809                  &amp;&amp; (provider.provider.getPackageName() != null);
3810      }
3811  
3812      public void dumpState() {
3813          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3814          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3815          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3816          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3817          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3818          if (mLoaderTask != null) {
3819              mLoaderTask.dumpState();
3820          } else {
3821              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3822          }
3823      }
3824  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
  22  import android.content.BroadcastReceiver;
  23  import android.content.ComponentName;
  24  import android.content.ContentProviderClient;
  25  import android.content.ContentProviderOperation;
  26  import android.content.ContentResolver;
  27  import android.content.ContentValues;
  28  import android.content.Context;
  29  import android.content.Intent;
  30  import android.content.Intent.ShortcutIconResource;
  31  import android.content.IntentFilter;
  32  import android.content.SharedPreferences;
  33  import android.content.pm.PackageManager;
  34  import android.content.pm.ProviderInfo;
  35  import android.content.pm.ResolveInfo;
  36  import android.content.res.Configuration;
  37  import android.content.res.Resources;
  38  import android.database.Cursor;
  39  import android.graphics.Bitmap;
  40  import android.graphics.BitmapFactory;
  41  import android.net.Uri;
  42  import android.os.Environment;
  43  import android.os.Handler;
  44  import android.os.HandlerThread;
  45  import android.os.Parcelable;
  46  import android.os.Process;
  47  import android.os.RemoteException;
  48  import android.os.SystemClock;
  49  import android.provider.BaseColumns;
  50  import android.text.TextUtils;
  51  import android.util.Log;
  52  import android.util.Pair;
  53  
  54  import com.android.launcher3.compat.AppWidgetManagerCompat;
  55  import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56  import com.android.launcher3.compat.LauncherAppsCompat;
  57  import com.android.launcher3.compat.PackageInstallerCompat;
  58  import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59  import com.android.launcher3.compat.UserHandleCompat;
  60  import com.android.launcher3.compat.UserManagerCompat;
  61  
  62  import java.lang.ref.WeakReference;
  63  import java.net.URISyntaxException;
  64  import java.security.InvalidParameterException;
  65  import java.text.Collator;
  66  import java.util.ArrayList;
  67  import java.util.Arrays;
  68  import java.util.Collection;
  69  import java.util.Collections;
  70  import java.util.Comparator;
  71  import java.util.HashMap;
  72  import java.util.HashSet;
  73  import java.util.Iterator;
  74  import java.util.List;
  75  import java.util.Map.Entry;
  76  import java.util.Set;
  77  import java.util.TreeMap;
  78  import java.util.concurrent.atomic.AtomicBoolean;
  79  
  80  /**
  81   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82   * LauncherModel object held in a static. Also provide APIs for updating the database state
  83   * for the Launcher.
  84   */
  85  public class LauncherModel extends BroadcastReceiver
  86          implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87      static final boolean DEBUG_LOADERS = false;
  88      private static final boolean DEBUG_RECEIVER = false;
  89      private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90  
  91      static final String TAG = &quot;Launcher.Model&quot;;
  92  
  93      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94      // false = strew non-workspace apps across the workspace on upgrade
  95      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96      public static final int LOADER_FLAG_NONE = 0;
  97      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99  
 100      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101      private static final long INVALID_SCREEN_ID = -1L;
 102  
 103      private final boolean mAppsCanBeOnRemoveableStorage;
 104      private final boolean mOldContentProviderExists;
 105  
 106      private final LauncherAppState mApp;
 107      private final Object mLock = new Object();
 108      private DeferredHandler mHandler = new DeferredHandler();
 109      private LoaderTask mLoaderTask;
 110      private boolean mIsLoaderTaskRunning;
 111      private volatile boolean mFlushingWorkerThread;
 112  
 113      // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114      // clear all queued binding runnables when the Launcher activity is destroyed.
 115      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117  
 118      private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119  
 120      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121      static {
 122          sWorkerThread.start();
 123      }
 124      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125  
 126      // We start off with everything not loaded.  After that, we assume that
 127      // our monitoring of the package manager provides all updates and we never
 128      // need to do a requery.  These are only ever touched from the loader thread.
 129      private boolean mWorkspaceLoaded;
 130      private boolean mAllAppsLoaded;
 131  
 132      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135      // a normal load, we also clear this set of Runnables.
 136      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137  
 138      private WeakReference&lt;Callbacks&gt; mCallbacks;
 139  
 140      // &lt; only access in worker thread &gt;
 141      AllAppsList mBgAllAppsList;
 142  
 143      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144      // other locks, this one can generally be held long-term because we never expect any of these
 145      // static data structures to be referenced outside of the worker thread except on the first
 146      // load after configuration change.
 147      static final Object sBgLock = new Object();
 148  
 149      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150      // LauncherModel to their ids
 151      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152  
 153      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155      //       shortcuts within folders).
 156      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157  
 158      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161  
 162      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164  
 165      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167  
 168      // sBgWorkspaceScreens is the ordered set of workspace screens.
 169      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170  
 171      // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172      static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173              new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174  
 175      // &lt;/ only access in worker thread &gt;
 176  
 177      private IconCache mIconCache;
 178  
 179      protected int mPreviousConfigMcc;
 180  
 181      private final LauncherAppsCompat mLauncherApps;
 182      private final UserManagerCompat mUserManager;
 183  
 184      public interface Callbacks {
 185          public boolean setLoadOnResume();
 186          public int getCurrentWorkspaceScreen();
 187          public void startBinding();
 188          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                                boolean forceAnimateIcons);
 190          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193          public void finishBindingItems(boolean upgradePath);
 194          public void bindAppWidget(LauncherAppWidgetInfo info);
 195          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                    ArrayList&lt;AppInfo&gt; addedApps);
 200          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);</span>
 202          public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203          public void updatePackageBadge(String packageName);
 204          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 205                          ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);

 206          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 207          public void bindSearchablesChanged();
 208          public boolean isAllAppsButtonRank(int rank);
 209          public void onPageBoundSynchronously(int page);
 210          public void dumpLogsToLocalData();
 211      }
 212  
 213      public interface ItemInfoFilter {
 214          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 215      }
 216  
 217      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 218          Context context = app.getContext();
 219  
 220          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 221          String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 222          // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 223          // resource string.
 224          String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 225          ProviderInfo providerInfo =
 226                  context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 227          ProviderInfo redirectProvider =
 228                  context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 229  
 230          Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 231          mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 232  
 233          if (mOldContentProviderExists) {
 234              Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 235          } else {
 236              Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 237          }
 238  
 239          mApp = app;
 240          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 241          mIconCache = iconCache;
 242  
 243          final Resources res = context.getResources();
 244          Configuration config = res.getConfiguration();
 245          mPreviousConfigMcc = config.mcc;
 246          mLauncherApps = LauncherAppsCompat.getInstance(context);
 247          mUserManager = UserManagerCompat.getInstance(context);
 248      }
 249  
 250      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 251       * posted on the main thread handler. */
 252      private void runOnMainThread(Runnable r) {
 253          runOnMainThread(r, 0);
 254      }
 255      private void runOnMainThread(Runnable r, int type) {
 256          if (sWorkerThread.getThreadId() == Process.myTid()) {
 257              // If we are on the worker thread, post onto the main handler
 258              mHandler.post(r);
 259          } else {
 260              r.run();
 261          }
 262      }
 263  
 264      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 265       * posted on the worker thread handler. */
 266      private static void runOnWorkerThread(Runnable r) {
 267          if (sWorkerThread.getThreadId() == Process.myTid()) {
 268              r.run();
 269          } else {
 270              // If we are not on the worker thread, then post to the worker handler
 271              sWorker.post(r);
 272          }
 273      }
 274  
 275      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 276          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 277      }
 278  
 279      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 280                                   long screen) {
 281          LauncherAppState app = LauncherAppState.getInstance();
 282          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 283          final int xCount = (int) grid.numColumns;
 284          final int yCount = (int) grid.numRows;
 285          boolean[][] occupied = new boolean[xCount][yCount];
 286  
 287          int cellX, cellY, spanX, spanY;
 288          for (int i = 0; i &lt; items.size(); ++i) {
 289              final ItemInfo item = items.get(i);
 290              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 291                  if (item.screenId == screen) {
 292                      cellX = item.cellX;
 293                      cellY = item.cellY;
 294                      spanX = item.spanX;
 295                      spanY = item.spanY;
 296                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 297                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 298                              occupied[x][y] = true;
 299                          }
 300                      }
 301                  }
 302              }
 303          }
 304  
 305          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 306      }
 307      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 308                                                          Intent launchIntent,
 309                                                          int firstScreenIndex,
 310                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 311          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 312          LauncherAppState app = LauncherAppState.getInstance();
 313          LauncherModel model = app.getModel();
 314          boolean found = false;
 315          synchronized (app) {
 316              if (sWorkerThread.getThreadId() != Process.myTid()) {
 317                  // Flush the LauncherModel worker thread, so that if we just did another
 318                  // processInstallShortcut, we give it time for its shortcut to get added to the
 319                  // database (getItemsInLocalCoordinates reads the database)
 320                  model.flushWorkerThread();
 321              }
 322              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 323  
 324              // Try adding to the workspace screens incrementally, starting at the default or center
 325              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 326              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 327              int count = workspaceScreens.size();
 328              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 329                  int[] tmpCoordinates = new int[2];
 330                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 331                          workspaceScreens.get(screen))) {
 332                      // Update the Launcher db
 333                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 334                  }
 335              }
 336          }
 337          return null;
 338      }
 339  
 340      public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 341          // Process the updated package state
 342          Runnable r = new Runnable() {
 343              public void run() {
 344                  Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 345                  if (callbacks != null) {
 346                      callbacks.updatePackageState(installInfo);
 347                  }
 348              }
 349          };
 350          mHandler.post(r);
 351      }
 352  
 353      public void updatePackageBadge(final String packageName) {
 354          // Process the updated package badge
 355          Runnable r = new Runnable() {
 356              public void run() {
 357                  Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 358                  if (callbacks != null) {
 359                      callbacks.updatePackageBadge(packageName);
 360                  }
 361              }
 362          };
 363          mHandler.post(r);
 364      }
 365  
 366      public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 367          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 368  
 369          if (allAppsApps == null) {
 370              throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 371          }
 372          if (allAppsApps.isEmpty()) {
 373              return;
 374          }
 375  
 376          final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 377          Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 378          while (iter.hasNext()) {
 379              ItemInfo a = iter.next();
 380              if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 381                  restoredAppsFinal.add((AppInfo) a);
 382              }
 383          }
 384  
 385          // Process the newly added applications and add them to the database first
 386          Runnable r = new Runnable() {
 387              public void run() {
 388                  runOnMainThread(new Runnable() {
 389                      public void run() {
 390                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 391                          if (callbacks == cb &amp;&amp; cb != null) {
 392                              if (!restoredAppsFinal.isEmpty()) {
 393                                  for (AppInfo info : restoredAppsFinal) {
 394                                      final Intent intent = info.getIntent();
 395                                      if (intent != null) {
 396                                          mIconCache.deletePreloadedIcon(intent.getComponent(),
 397                                                  info.user);
 398                                      }
 399                                  }
 400                                  callbacks.bindAppsUpdated(restoredAppsFinal);
 401                              }
 402                              callbacks.bindAppsAdded(null, null, null, allAppsApps);
 403                          }
 404                      }
 405                  });
 406              }
 407          };
 408          runOnWorkerThread(r);
 409      }
 410  
 411      public void addAndBindAddedWorkspaceApps(final Context context,
 412              final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 413          final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 414  
 415          if (workspaceApps == null) {
 416              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 417          }
 418          if (workspaceApps.isEmpty()) {
 419              return;
 420          }
 421          // Process the newly added applications and add them to the database first
 422          Runnable r = new Runnable() {
 423              public void run() {
 424                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 425                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 426                  final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 427  
 428                  // Get the list of workspace screens.  We need to append to this list and
 429                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 430                  // called.
 431                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 432                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 433                  for (Integer i : orderedScreens.keySet()) {
 434                      long screenId = orderedScreens.get(i);
 435                      workspaceScreens.add(screenId);
 436                  }
 437  
 438                  synchronized(sBgLock) {
 439                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 440                      while (iter.hasNext()) {
 441                          ItemInfo a = iter.next();
 442                          final String name = a.title.toString();
 443                          final Intent launchIntent = a.getIntent();
 444  
 445                          // Short-circuit this logic if the icon exists somewhere on the workspace
 446                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 447                              // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 448                              if (a instanceof AppInfo &amp;&amp;
 449                                      LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 450                                  restoredAppsFinal.add((AppInfo) a);
 451                              }
 452                              continue;
 453                          }
 454  
 455                          // Add this icon to the db, creating a new page if necessary.  If there
 456                          // is only the empty page then we just add items to the first page.
 457                          // Otherwise, we add them to the next pages.
 458                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 459                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 460                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 461                          if (coords == null) {
 462                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 463  
 464                              // If we can&#x27;t find a valid position, then just add a new screen.
 465                              // This takes time so we need to re-queue the add until the new
 466                              // page is added.  Create as many screens as necessary to satisfy
 467                              // the startSearchPageIndex.
 468                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 469                                      workspaceScreens.size());
 470                              while (numPagesToAdd &gt; 0) {
 471                                  long screenId = lp.generateNewScreenId();
 472                                  // Save the screen id for binding in the workspace
 473                                  workspaceScreens.add(screenId);
 474                                  addedWorkspaceScreensFinal.add(screenId);
 475                                  numPagesToAdd--;
 476                              }
 477  
 478                              // Find the coordinate again
 479                              coords = LauncherModel.findNextAvailableIconSpace(context,
 480                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 481                          }
 482                          if (coords == null) {
 483                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 484                          }
 485  
 486                          ShortcutInfo shortcutInfo;
 487                          if (a instanceof ShortcutInfo) {
 488                              shortcutInfo = (ShortcutInfo) a;
 489                          } else if (a instanceof AppInfo) {
 490                              shortcutInfo = ((AppInfo) a).makeShortcut();
 491                          } else {
 492                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 493                          }
 494  
 495                          // Add the shortcut to the db
 496                          addItemToDatabase(context, shortcutInfo,
 497                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 498                                  coords.first, coords.second[0], coords.second[1], false);
 499                          // Save the ShortcutInfo for binding in the workspace
 500                          addedShortcutsFinal.add(shortcutInfo);
 501                      }
 502                  }
 503  
 504                  // Update the workspace screens
 505                  updateWorkspaceScreenOrder(context, workspaceScreens);
 506  
 507                  if (!addedShortcutsFinal.isEmpty()) {
 508                      runOnMainThread(new Runnable() {
 509                          public void run() {
 510                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 511                              if (callbacks == cb &amp;&amp; cb != null) {
 512                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 513                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                  if (!addedShortcutsFinal.isEmpty()) {
 515                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 516                                      long lastScreenId = info.screenId;
 517                                      for (ItemInfo i : addedShortcutsFinal) {
 518                                          if (i.screenId == lastScreenId) {
 519                                              addAnimated.add(i);
 520                                          } else {
 521                                              addNotAnimated.add(i);
 522                                          }
 523                                      }
 524                                  }
 525                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 526                                          addNotAnimated, addAnimated, null);
 527                                  if (!restoredAppsFinal.isEmpty()) {
 528                                      callbacks.bindAppsUpdated(restoredAppsFinal);
 529                                  }
 530                              }
 531                          }
 532                      });
 533                  }
 534              }
 535          };
 536          runOnWorkerThread(r);
 537      }
 538  
 539      public void unbindItemInfosAndClearQueuedBindRunnables() {
 540          if (sWorkerThread.getThreadId() == Process.myTid()) {
 541              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 542                      &quot;main thread&quot;);
 543          }
 544  
 545          // Clear any deferred bind runnables
 546          synchronized (mDeferredBindRunnables) {
 547              mDeferredBindRunnables.clear();
 548          }
 549          // Remove any queued bind runnables
 550          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 551          // Unbind all the workspace items
 552          unbindWorkspaceItemsOnMainThread();
 553      }
 554  
 555      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 556      void unbindWorkspaceItemsOnMainThread() {
 557          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 558          // by making a copy of workspace items first.
 559          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 560          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 561          synchronized (sBgLock) {
 562              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 563              tmpAppWidgets.addAll(sBgAppWidgets);
 564          }
 565          Runnable r = new Runnable() {
 566                  @Override
 567                  public void run() {
 568                     for (ItemInfo item : tmpWorkspaceItems) {
 569                         item.unbind();
 570                     }
 571                     for (ItemInfo item : tmpAppWidgets) {
 572                         item.unbind();
 573                     }
 574                  }
 575              };
 576          runOnMainThread(r);
 577      }
 578  
 579      /**
 580       * Adds an item to the DB if it was not created previously, or move it to a new
 581       * &lt;container, screen, cellX, cellY&gt;
 582       */
 583      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 584              long screenId, int cellX, int cellY) {
 585          if (item.container == ItemInfo.NO_ID) {
 586              // From all apps
 587              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 588          } else {
 589              // From somewhere else
 590              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 591          }
 592      }
 593  
 594      static void checkItemInfoLocked(
 595              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 596          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 597          if (modelItem != null &amp;&amp; item != modelItem) {
 598              // check all the data is consistent
 599              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 600                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 601                  ShortcutInfo shortcut = (ShortcutInfo) item;
 602                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 603                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 604                          modelShortcut.id == shortcut.id &amp;&amp;
 605                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 606                          modelShortcut.container == shortcut.container &amp;&amp;
 607                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 608                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 609                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 610                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 611                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 612                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 613                          (modelShortcut.dropPos != null &amp;&amp;
 614                                  shortcut.dropPos != null &amp;&amp;
 615                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 616                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 617                      // For all intents and purposes, this is the same object
 618                      return;
 619                  }
 620              }
 621  
 622              // the modelItem needs to match up perfectly with item if our model is
 623              // to be consistent with the database-- for now, just require
 624              // modelItem == item or the equality check above
 625              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 626                      &quot;modelItem: &quot; +
 627                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 628                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 629              RuntimeException e = new RuntimeException(msg);
 630              if (stackTrace != null) {
 631                  e.setStackTrace(stackTrace);
 632              }
 633              throw e;
 634          }
 635      }
 636  
 637      static void checkItemInfo(final ItemInfo item) {
 638          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 639          final long itemId = item.id;
 640          Runnable r = new Runnable() {
 641              public void run() {
 642                  synchronized (sBgLock) {
 643                      checkItemInfoLocked(itemId, item, stackTrace);
 644                  }
 645              }
 646          };
 647          runOnWorkerThread(r);
 648      }
 649  
 650      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 651              final ItemInfo item, final String callingFunction) {
 652          final long itemId = item.id;
 653          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 654          final ContentResolver cr = context.getContentResolver();
 655  
 656          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 657          Runnable r = new Runnable() {
 658              public void run() {
 659                  cr.update(uri, values, null, null);
 660                  updateItemArrays(item, itemId, stackTrace);
 661              }
 662          };
 663          runOnWorkerThread(r);
 664      }
 665  
 666      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 667              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 668          final ContentResolver cr = context.getContentResolver();
 669  
 670          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 671          Runnable r = new Runnable() {
 672              public void run() {
 673                  ArrayList&lt;ContentProviderOperation&gt; ops =
 674                          new ArrayList&lt;ContentProviderOperation&gt;();
 675                  int count = items.size();
 676                  for (int i = 0; i &lt; count; i++) {
 677                      ItemInfo item = items.get(i);
 678                      final long itemId = item.id;
 679                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 680                      ContentValues values = valuesList.get(i);
 681  
 682                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 683                      updateItemArrays(item, itemId, stackTrace);
 684  
 685                  }
 686                  try {
 687                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 688                  } catch (Exception e) {
 689                      e.printStackTrace();
 690                  }
 691              }
 692          };
 693          runOnWorkerThread(r);
 694      }
 695  
 696      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 697          // Lock on mBgLock *after* the db operation
 698          synchronized (sBgLock) {
 699              checkItemInfoLocked(itemId, item, stackTrace);
 700  
 701              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 702                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 703                  // Item is in a folder, make sure this folder exists
 704                  if (!sBgFolders.containsKey(item.container)) {
 705                      // An items container is being set to a that of an item which is not in
 706                      // the list of Folders.
 707                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 708                              item.container + &quot;, not in the list of folders&quot;;
 709                      Log.e(TAG, msg);
 710                  }
 711              }
 712  
 713              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 714              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 715              // that are on the desktop, as appropriate
 716              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 717              if (modelItem != null &amp;&amp;
 718                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 719                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 720                  switch (modelItem.itemType) {
 721                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 722                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 723                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 724                          if (!sBgWorkspaceItems.contains(modelItem)) {
 725                              sBgWorkspaceItems.add(modelItem);
 726                          }
 727                          break;
 728                      default:
 729                          break;
 730                  }
 731              } else {
 732                  sBgWorkspaceItems.remove(modelItem);
 733              }
 734          }
 735      }
 736  
 737      public void flushWorkerThread() {
 738          mFlushingWorkerThread = true;
 739          Runnable waiter = new Runnable() {
 740                  public void run() {
 741                      synchronized (this) {
 742                          notifyAll();
 743                          mFlushingWorkerThread = false;
 744                      }
 745                  }
 746              };
 747  
 748          synchronized(waiter) {
 749              runOnWorkerThread(waiter);
 750              if (mLoaderTask != null) {
 751                  synchronized(mLoaderTask) {
 752                      mLoaderTask.notify();
 753                  }
 754              }
 755              boolean success = false;
 756              while (!success) {
 757                  try {
 758                      waiter.wait();
 759                      success = true;
 760                  } catch (InterruptedException e) {
 761                  }
 762              }
 763          }
 764      }
 765  
 766      /**
 767       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 768       */
 769      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 770              final long screenId, final int cellX, final int cellY) {
 771          item.container = container;
 772          item.cellX = cellX;
 773          item.cellY = cellY;
 774  
 775          // We store hotseat items in canonical form which is this orientation invariant position
 776          // in the hotseat
 777          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 778                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 779              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 780          } else {
 781              item.screenId = screenId;
 782          }
 783  
 784          final ContentValues values = new ContentValues();
 785          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 786          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 787          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 788          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 789  
 790          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 791      }
 792  
 793      /**
 794       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 795       * cellX, cellY have already been updated on the ItemInfos.
 796       */
 797      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 798              final long container, final int screen) {
 799  
 800          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 801          int count = items.size();
 802  
 803          for (int i = 0; i &lt; count; i++) {
 804              ItemInfo item = items.get(i);
 805              item.container = container;
 806  
 807              // We store hotseat items in canonical form which is this orientation invariant position
 808              // in the hotseat
 809              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 810                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 811                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 812                          item.cellY);
 813              } else {
 814                  item.screenId = screen;
 815              }
 816  
 817              final ContentValues values = new ContentValues();
 818              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 819              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 820              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 821              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 822  
 823              contentValues.add(values);
 824          }
 825          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 826      }
 827  
 828      /**
 829       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 830       */
 831      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 832              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 833          item.container = container;
 834          item.cellX = cellX;
 835          item.cellY = cellY;
 836          item.spanX = spanX;
 837          item.spanY = spanY;
 838  
 839          // We store hotseat items in canonical form which is this orientation invariant position
 840          // in the hotseat
 841          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 842                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 843              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 844          } else {
 845              item.screenId = screenId;
 846          }
 847  
 848          final ContentValues values = new ContentValues();
 849          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 850          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 851          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 852          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 853          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 854          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 855  
 856          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 857      }
 858  
 859      /**
 860       * Update an item to the database in a specified container.
 861       */
 862      static void updateItemInDatabase(Context context, final ItemInfo item) {
 863          final ContentValues values = new ContentValues();
 864          item.onAddToDatabase(context, values);
 865          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 866          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 867      }
 868  
 869      /**
 870       * Returns true if the shortcuts already exists in the database.
 871       * we identify a shortcut by its title and intent.
 872       */
 873      static boolean shortcutExists(Context context, String title, Intent intent) {
 874          final ContentResolver cr = context.getContentResolver();
 875          final Intent intentWithPkg, intentWithoutPkg;
 876  
 877          if (intent.getComponent() != null) {
 878              // If component is not null, an intent with null package will produce
 879              // the same result and should also be a match.
 880              if (intent.getPackage() != null) {
 881                  intentWithPkg = intent;
 882                  intentWithoutPkg = new Intent(intent).setPackage(null);
 883              } else {
 884                  intentWithPkg = new Intent(intent).setPackage(
 885                          intent.getComponent().getPackageName());
 886                  intentWithoutPkg = intent;
 887              }
 888          } else {
 889              intentWithPkg = intent;
 890              intentWithoutPkg = intent;
 891          }
 892          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 893              new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 894              new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 895          boolean result = false;
 896          try {
 897              result = c.moveToFirst();
 898          } finally {
 899              c.close();
 900          }
 901          return result;
 902      }
 903  
 904      /**
 905       * Returns true if the promise shortcuts with the same package name exists on the workspace.
 906       */
 907      static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 908          final ComponentName component = intent.getComponent();
 909          if (component == null) {
 910              return false;
 911          }
 912          return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 913      }
 914  
 915      /**
 916       * Returns an ItemInfo array containing all the items in the LauncherModel.
 917       * The ItemInfo.id is not set through this function.
 918       */
 919      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 920          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 921          final ContentResolver cr = context.getContentResolver();
 922          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 923                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 924                  LauncherSettings.Favorites.SCREEN,
 925                  LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 926                  LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 927                  LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 928  
 929          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 930          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 931          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 932          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 933          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 934          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 935          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 936          final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 937          UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 938          try {
 939              while (c.moveToNext()) {
 940                  ItemInfo item = new ItemInfo();
 941                  item.cellX = c.getInt(cellXIndex);
 942                  item.cellY = c.getInt(cellYIndex);
 943                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 944                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 945                  item.container = c.getInt(containerIndex);
 946                  item.itemType = c.getInt(itemTypeIndex);
 947                  item.screenId = c.getInt(screenIndex);
 948                  long serialNumber = c.getInt(profileIdIndex);
 949                  item.user = userManager.getUserForSerialNumber(serialNumber);
 950                  // Skip if user has been deleted.
 951                  if (item.user != null) {
 952                      items.add(item);
 953                  }
 954              }
 955          } catch (Exception e) {
 956              items.clear();
 957          } finally {
 958              c.close();
 959          }
 960  
 961          return items;
 962      }
 963  
 964      /**
 965       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 966       */
 967      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 968          final ContentResolver cr = context.getContentResolver();
 969          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 970                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 971                  new String[] { String.valueOf(id),
 972                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 973  
 974          try {
 975              if (c.moveToFirst()) {
 976                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 977                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 978                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 979                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 980                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 981                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 982  
 983                  FolderInfo folderInfo = null;
 984                  switch (c.getInt(itemTypeIndex)) {
 985                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 986                          folderInfo = findOrMakeFolder(folderList, id);
 987                          break;
 988                  }
 989  
 990                  folderInfo.title = c.getString(titleIndex);
 991                  folderInfo.id = id;
 992                  folderInfo.container = c.getInt(containerIndex);
 993                  folderInfo.screenId = c.getInt(screenIndex);
 994                  folderInfo.cellX = c.getInt(cellXIndex);
 995                  folderInfo.cellY = c.getInt(cellYIndex);
 996  
 997                  return folderInfo;
 998              }
 999          } finally {
1000              c.close();
1001          }
1002  
1003          return null;
1004      }
1005  
1006      /**
1007       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1008       * cellY fields of the item. Also assigns an ID to the item.
1009       */
1010      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1011              final long screenId, final int cellX, final int cellY, final boolean notify) {
1012          item.container = container;
1013          item.cellX = cellX;
1014          item.cellY = cellY;
1015          // We store hotseat items in canonical form which is this orientation invariant position
1016          // in the hotseat
1017          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1018                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1019              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1020          } else {
1021              item.screenId = screenId;
1022          }
1023  
1024          final ContentValues values = new ContentValues();
1025          final ContentResolver cr = context.getContentResolver();
1026          item.onAddToDatabase(context, values);
1027  
1028          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1029          values.put(LauncherSettings.Favorites._ID, item.id);
1030          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1031  
1032          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1033          Runnable r = new Runnable() {
1034              public void run() {
1035                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1036                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1037  
1038                  // Lock on mBgLock *after* the db operation
1039                  synchronized (sBgLock) {
1040                      checkItemInfoLocked(item.id, item, stackTrace);
1041                      sBgItemsIdMap.put(item.id, item);
1042                      switch (item.itemType) {
1043                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1044                              sBgFolders.put(item.id, (FolderInfo) item);
1045                              // Fall through
1046                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1047                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1048                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1049                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1050                                  sBgWorkspaceItems.add(item);
1051                              } else {
1052                                  if (!sBgFolders.containsKey(item.container)) {
1053                                      // Adding an item to a folder that doesn&#x27;t exist.
1054                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1055                                              &quot; doesn&#x27;t exist&quot;;
1056                                      Log.e(TAG, msg);
1057                                  }
1058                              }
1059                              break;
1060                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1061                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1062                              break;
1063                      }
1064                  }
1065              }
1066          };
1067          runOnWorkerThread(r);
1068      }
1069  
1070      /**
1071       * Creates a new unique child id, for a given cell span across all layouts.
1072       */
1073      static int getCellLayoutChildId(
1074              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1075          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1076                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1077      }
1078  
1079      private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1080              final String pn, final UserHandleCompat user) {
1081          ItemInfoFilter filter  = new ItemInfoFilter() {
1082              @Override
1083              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1084                  return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1085              }
1086          };
1087          return filterItemInfos(sBgItemsIdMap.values(), filter);
1088      }
1089  
1090      /**
1091       * Removes all the items from the database corresponding to the specified package.
1092       */
1093      static void deletePackageFromDatabase(Context context, final String pn,
1094              final UserHandleCompat user) {
1095          deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1096      }
1097  
1098      /**
1099       * Removes the specified item from the database
1100       * @param context
1101       * @param item
1102       */
1103      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1104          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1105          items.add(item);
1106          deleteItemsFromDatabase(context, items);
1107      }
1108  
1109      /**
1110       * Removes the specified items from the database
1111       * @param context
1112       * @param item
1113       */
1114      static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1115          final ContentResolver cr = context.getContentResolver();
1116  
1117          Runnable r = new Runnable() {
1118              public void run() {
1119                  for (ItemInfo item : items) {
1120                      final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1121                      cr.delete(uri, null, null);
1122  
1123                      // Lock on mBgLock *after* the db operation
1124                      synchronized (sBgLock) {
1125                          switch (item.itemType) {
1126                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1127                                  sBgFolders.remove(item.id);
1128                                  for (ItemInfo info: sBgItemsIdMap.values()) {
1129                                      if (info.container == item.id) {
1130                                          // We are deleting a folder which still contains items that
1131                                          // think they are contained by that folder.
1132                                          String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1133                                                  &quot;contains items (&quot; + info + &quot;)&quot;;
1134                                          Log.e(TAG, msg);
1135                                      }
1136                                  }
1137                                  sBgWorkspaceItems.remove(item);
1138                                  break;
1139                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1140                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1141                                  sBgWorkspaceItems.remove(item);
1142                                  break;
1143                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1144                                  sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1145                                  break;
1146                          }
1147                          sBgItemsIdMap.remove(item.id);
1148                          sBgDbIconCache.remove(item);
1149                      }
1150                  }
1151              }
1152          };
1153          runOnWorkerThread(r);
1154      }
1155  
1156      /**
1157       * Update the order of the workspace screens in the database. The array list contains
1158       * a list of screen ids in the order that they should appear.
1159       */
1160      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1161          // Log to disk
1162          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1163          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1164  
1165          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1166          final ContentResolver cr = context.getContentResolver();
1167          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1168  
1169          // Remove any negative screen ids -- these aren&#x27;t persisted
1170          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1171          while (iter.hasNext()) {
1172              long id = iter.next();
1173              if (id &lt; 0) {
1174                  iter.remove();
1175              }
1176          }
1177  
1178          Runnable r = new Runnable() {
1179              @Override
1180              public void run() {
1181                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1182                  // Clear the table
1183                  ops.add(ContentProviderOperation.newDelete(uri).build());
1184                  int count = screensCopy.size();
1185                  for (int i = 0; i &lt; count; i++) {
1186                      ContentValues v = new ContentValues();
1187                      long screenId = screensCopy.get(i);
1188                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1189                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1190                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1191                  }
1192  
1193                  try {
1194                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1195                  } catch (Exception ex) {
1196                      throw new RuntimeException(ex);
1197                  }
1198  
1199                  synchronized (sBgLock) {
1200                      sBgWorkspaceScreens.clear();
1201                      sBgWorkspaceScreens.addAll(screensCopy);
1202                  }
1203              }
1204          };
1205          runOnWorkerThread(r);
1206      }
1207  
1208      /**
1209       * Remove the contents of the specified folder from the database
1210       */
1211      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1212          final ContentResolver cr = context.getContentResolver();
1213  
1214          Runnable r = new Runnable() {
1215              public void run() {
1216                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1217                  // Lock on mBgLock *after* the db operation
1218                  synchronized (sBgLock) {
1219                      sBgItemsIdMap.remove(info.id);
1220                      sBgFolders.remove(info.id);
1221                      sBgDbIconCache.remove(info);
1222                      sBgWorkspaceItems.remove(info);
1223                  }
1224  
1225                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1226                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1227                  // Lock on mBgLock *after* the db operation
1228                  synchronized (sBgLock) {
1229                      for (ItemInfo childInfo : info.contents) {
1230                          sBgItemsIdMap.remove(childInfo.id);
1231                          sBgDbIconCache.remove(childInfo);
1232                      }
1233                  }
1234              }
1235          };
1236          runOnWorkerThread(r);
1237      }
1238  
1239      /**
1240       * Set this as the current Launcher activity object for the loader.
1241       */
1242      public void initialize(Callbacks callbacks) {
1243          synchronized (mLock) {
1244              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1245          }
1246      }
1247  
1248      @Override
1249      public void onPackageChanged(String packageName, UserHandleCompat user) {
1250          int op = PackageUpdatedTask.OP_UPDATE;
1251          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1252                  user));
1253      }
1254  
1255      @Override
1256      public void onPackageRemoved(String packageName, UserHandleCompat user) {
1257          int op = PackageUpdatedTask.OP_REMOVE;
1258          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1259                  user));
1260      }
1261  
1262      @Override
1263      public void onPackageAdded(String packageName, UserHandleCompat user) {
1264          int op = PackageUpdatedTask.OP_ADD;
1265          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1266                  user));
1267      }
1268  
1269      @Override
1270      public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1271              boolean replacing) {
1272          if (!replacing) {
1273              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1274                      user));
1275              if (mAppsCanBeOnRemoveableStorage) {
1276                  // Only rebind if we support removable storage. It catches the
1277                  // case where
1278                  // apps on the external sd card need to be reloaded
1279                  startLoaderFromBackground();
1280              }
1281          } else {
1282              // If we are replacing then just update the packages in the list
1283              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1284                      packageNames, user));
1285          }
1286      }
1287  
1288      @Override
1289      public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1290              boolean replacing) {
1291          if (!replacing) {
1292              enqueuePackageUpdated(new PackageUpdatedTask(
1293                      PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1294                      user));
1295          }
1296  
1297      }
1298  
1299      /**
1300       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1301       * ACTION_PACKAGE_CHANGED.
1302       */
1303      @Override
1304      public void onReceive(Context context, Intent intent) {
1305          if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1306  
1307          final String action = intent.getAction();
1308          if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1309              // If we have changed locale we need to clear out the labels in all apps/workspace.
1310              forceReload();
1311          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1312               // Check if configuration change was an mcc/mnc change which would affect app resources
1313               // and we would need to clear out the labels in all apps/workspace. Same handling as
1314               // above for ACTION_LOCALE_CHANGED
1315               Configuration currentConfig = context.getResources().getConfiguration();
1316               if (mPreviousConfigMcc != currentConfig.mcc) {
1317                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1318                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1319                     forceReload();
1320               }
1321               // Update previousConfig
1322               mPreviousConfigMcc = currentConfig.mcc;
1323          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1324                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1325              if (mCallbacks != null) {
1326                  Callbacks callbacks = mCallbacks.get();
1327                  if (callbacks != null) {
1328                      callbacks.bindSearchablesChanged();
1329                  }
1330              }
1331          }
1332      }
1333  
1334      void forceReload() {
1335          resetLoadedState(true, true);
1336  
1337          // Do this here because if the launcher activity is running it will be restarted.
1338          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1339          // to reload.
1340          startLoaderFromBackground();
1341      }
1342  
1343      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1344          synchronized (mLock) {
1345              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1346              // mWorkspaceLoaded to true later
1347              stopLoaderLocked();
1348              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1349              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1350          }
1351      }
1352  
1353      /**
1354       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1355       * configuration changes.  So whenever we trigger the loader from the background
1356       * tell the launcher that it needs to re-run the loader when it comes back instead
1357       * of doing it now.
1358       */
1359      public void startLoaderFromBackground() {
1360          boolean runLoader = false;
1361          if (mCallbacks != null) {
1362              Callbacks callbacks = mCallbacks.get();
1363              if (callbacks != null) {
1364                  // Only actually run the loader if they&#x27;re not paused.
1365                  if (!callbacks.setLoadOnResume()) {
1366                      runLoader = true;
1367                  }
1368              }
1369          }
1370          if (runLoader) {
1371              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1372          }
1373      }
1374  
1375      // If there is already a loader task running, tell it to stop.
1376      // returns true if isLaunching() was true on the old task
1377      private boolean stopLoaderLocked() {
1378          boolean isLaunching = false;
1379          LoaderTask oldTask = mLoaderTask;
1380          if (oldTask != null) {
1381              if (oldTask.isLaunching()) {
1382                  isLaunching = true;
1383              }
1384              oldTask.stopLocked();
1385          }
1386          return isLaunching;
1387      }
1388  
1389      public boolean isCurrentCallbacks(Callbacks callbacks) {
1390          return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1391      }
1392  
1393      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1394          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1395      }
1396  
1397      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1398          synchronized (mLock) {
1399              if (DEBUG_LOADERS) {
1400                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1401              }
1402  
1403              // Clear any deferred bind-runnables from the synchronized load process
1404              // We must do this before any loading/binding is scheduled below.
1405              synchronized (mDeferredBindRunnables) {
1406                  mDeferredBindRunnables.clear();
1407              }
1408  
1409              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1410              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1411                  // If there is already one running, tell it to stop.
1412                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1413                  isLaunching = isLaunching || stopLoaderLocked();
1414                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1415                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1416                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1417                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1418                  } else {
1419                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1420                      sWorker.post(mLoaderTask);
1421                  }
1422              }
1423          }
1424      }
1425  
1426      void bindRemainingSynchronousPages() {
1427          // Post the remaining side pages to be loaded
1428          if (!mDeferredBindRunnables.isEmpty()) {
1429              Runnable[] deferredBindRunnables = null;
1430              synchronized (mDeferredBindRunnables) {
1431                  deferredBindRunnables = mDeferredBindRunnables.toArray(
1432                          new Runnable[mDeferredBindRunnables.size()]);
1433                  mDeferredBindRunnables.clear();
1434              }
1435              for (final Runnable r : deferredBindRunnables) {
1436                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1437              }
1438          }
1439      }
1440  
1441      public void stopLoader() {
1442          synchronized (mLock) {
1443              if (mLoaderTask != null) {
1444                  mLoaderTask.stopLocked();
1445              }
1446          }
1447      }
1448  
1449      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1450      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1451          final ContentResolver contentResolver = context.getContentResolver();
1452          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1453          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1454          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1455  
1456          try {
1457              final int idIndex = sc.getColumnIndexOrThrow(
1458                      LauncherSettings.WorkspaceScreens._ID);
1459              final int rankIndex = sc.getColumnIndexOrThrow(
1460                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1461              while (sc.moveToNext()) {
1462                  try {
1463                      long screenId = sc.getLong(idIndex);
1464                      int rank = sc.getInt(rankIndex);
1465                      orderedScreens.put(rank, screenId);
1466                  } catch (Exception e) {
1467                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1468                  }
1469              }
1470          } finally {
1471              sc.close();
1472          }
1473  
1474          // Log to disk
1475          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1476          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1477          for (Integer i : orderedScreens.keySet()) {
1478              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1479          }
1480          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1481                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1482          return orderedScreens;
1483      }
1484  
1485      public boolean isAllAppsLoaded() {
1486          return mAllAppsLoaded;
1487      }
1488  
1489      boolean isLoadingWorkspace() {
1490          synchronized (mLock) {
1491              if (mLoaderTask != null) {
1492                  return mLoaderTask.isLoadingWorkspace();
1493              }
1494          }
1495          return false;
1496      }
1497  
1498      /**
1499       * Runnable for the thread that loads the contents of the launcher:
1500       *   - workspace icons
1501       *   - widgets
1502       *   - all apps icons
1503       */
1504      private class LoaderTask implements Runnable {
1505          private Context mContext;
1506          private boolean mIsLaunching;
1507          private boolean mIsLoadingAndBindingWorkspace;
1508          private boolean mStopped;
1509          private boolean mLoadAndBindStepFinished;
1510          private int mFlags;
1511  
1512          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1513  
1514          LoaderTask(Context context, boolean isLaunching, int flags) {
1515              mContext = context;
1516              mIsLaunching = isLaunching;
1517              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1518              mFlags = flags;
1519          }
1520  
1521          boolean isLaunching() {
1522              return mIsLaunching;
1523          }
1524  
1525          boolean isLoadingWorkspace() {
1526              return mIsLoadingAndBindingWorkspace;
1527          }
1528  
1529          /** Returns whether this is an upgrade path */
1530          private boolean loadAndBindWorkspace() {
1531              mIsLoadingAndBindingWorkspace = true;
1532  
1533              // Load the workspace
1534              if (DEBUG_LOADERS) {
1535                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1536              }
1537  
1538              boolean isUpgradePath = false;
1539              if (!mWorkspaceLoaded) {
1540                  isUpgradePath = loadWorkspace();
1541                  synchronized (LoaderTask.this) {
1542                      if (mStopped) {
1543                          return isUpgradePath;
1544                      }
1545                      mWorkspaceLoaded = true;
1546                  }
1547              }
1548  
1549              // Bind the workspace
1550              bindWorkspace(-1, isUpgradePath);
1551              return isUpgradePath;
1552          }
1553  
1554          private void waitForIdle() {
1555              // Wait until the either we&#x27;re stopped or the other threads are done.
1556              // This way we don&#x27;t start loading all apps until the workspace has settled
1557              // down.
1558              synchronized (LoaderTask.this) {
1559                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1560  
1561                  mHandler.postIdle(new Runnable() {
1562                          public void run() {
1563                              synchronized (LoaderTask.this) {
1564                                  mLoadAndBindStepFinished = true;
1565                                  if (DEBUG_LOADERS) {
1566                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1567                                  }
1568                                  LoaderTask.this.notify();
1569                              }
1570                          }
1571                      });
1572  
1573                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1574                      try {
1575                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1576                          // wait no longer than 1sec at a time
1577                          this.wait(1000);
1578                      } catch (InterruptedException ex) {
1579                          // Ignore
1580                      }
1581                  }
1582                  if (DEBUG_LOADERS) {
1583                      Log.d(TAG, &quot;waited &quot;
1584                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1585                              + &quot;ms for previous step to finish binding&quot;);
1586                  }
1587              }
1588          }
1589  
1590          void runBindSynchronousPage(int synchronousBindPage) {
1591              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1592                  // Ensure that we have a valid page index to load synchronously
1593                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1594                          &quot;valid page index&quot;);
1595              }
1596              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1597                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1598                  // loaded already (we should load everything asynchronously in that case)
1599                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1600              }
1601              synchronized (mLock) {
1602                  if (mIsLoaderTaskRunning) {
1603                      // Ensure that we are never running the background loading at this point since
1604                      // we also touch the background collections
1605                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1606                  }
1607              }
1608  
1609              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1610              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1611              //      this call is synchronous, we can get away with not locking).
1612  
1613              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1614              // operations from the previous activity.  We need to ensure that all queued operations
1615              // are executed before any synchronous binding work is done.
1616              mHandler.flush();
1617  
1618              // Divide the set of loaded items into those that we are binding synchronously, and
1619              // everything else that is to be bound normally (asynchronously).
1620              bindWorkspace(synchronousBindPage, false);
1621              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1622              //      arise from that.
1623              onlyBindAllApps();
1624          }
1625  
1626          public void run() {
1627              boolean isUpgrade = false;
1628  
1629              synchronized (mLock) {
1630                  mIsLoaderTaskRunning = true;
1631              }
1632              // Optimize for end-user experience: if the Launcher is up and // running with the
1633              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1634              // workspace first (default).
1635              keep_running: {
1636                  // Elevate priority when Home launches for the first time to avoid
1637                  // starving at boot time. Staring at a blank home is not cool.
1638                  synchronized (mLock) {
1639                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1640                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1641                      android.os.Process.setThreadPriority(mIsLaunching
1642                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1643                  }
1644                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1645                  isUpgrade = loadAndBindWorkspace();
1646  
1647                  if (mStopped) {
1648                      break keep_running;
1649                  }
1650  
1651                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1652                  // settled down.
1653                  synchronized (mLock) {
1654                      if (mIsLaunching) {
1655                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1656                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1657                      }
1658                  }
1659                  waitForIdle();
1660  
1661                  // second step
1662                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1663                  loadAndBindAllApps();
1664  
1665                  // Restore the default thread priority after we are done loading items
1666                  synchronized (mLock) {
1667                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1668                  }
1669              }
1670  
1671              // Update the saved icons if necessary
1672              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1673              synchronized (sBgLock) {
1674                  for (Object key : sBgDbIconCache.keySet()) {
1675                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1676                  }
1677                  sBgDbIconCache.clear();
1678              }
1679  
1680              if (LauncherAppState.isDisableAllApps()) {
1681                  // Ensure that all the applications that are in the system are
1682                  // represented on the home screen.
1683                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1684                      verifyApplications();
1685                  }
1686              }
1687  
1688              // Clear out this reference, otherwise we end up holding it until all of the
1689              // callback runnables are done.
1690              mContext = null;
1691  
1692              synchronized (mLock) {
1693                  // If we are still the last one to be scheduled, remove ourselves.
1694                  if (mLoaderTask == this) {
1695                      mLoaderTask = null;
1696                  }
1697                  mIsLoaderTaskRunning = false;
1698              }
1699          }
1700  
1701          public void stopLocked() {
1702              synchronized (LoaderTask.this) {
1703                  mStopped = true;
1704                  this.notify();
1705              }
1706          }
1707  
1708          /**
1709           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1710           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1711           * object that was around when the deferred message was scheduled, and if there&#x27;s
1712           * a new Callbacks object around then also return null.  This will save us from
1713           * calling onto it with data that will be ignored.
1714           */
1715          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1716              synchronized (mLock) {
1717                  if (mStopped) {
1718                      return null;
1719                  }
1720  
1721                  if (mCallbacks == null) {
1722                      return null;
1723                  }
1724  
1725                  final Callbacks callbacks = mCallbacks.get();
1726                  if (callbacks != oldCallbacks) {
1727                      return null;
1728                  }
1729                  if (callbacks == null) {
1730                      Log.w(TAG, &quot;no mCallbacks&quot;);
1731                      return null;
1732                  }
1733  
1734                  return callbacks;
1735              }
1736          }
1737  
1738          private void verifyApplications() {
1739              final Context context = mApp.getContext();
1740  
1741              // Cross reference all the applications in our apps list with items in the workspace
1742              ArrayList&lt;ItemInfo&gt; tmpInfos;
1743              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1744              synchronized (sBgLock) {
1745                  for (AppInfo app : mBgAllAppsList.data) {
1746                      tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1747                      if (tmpInfos.isEmpty()) {
1748                          // We are missing an application icon, so add this to the workspace
1749                          added.add(app);
1750                          // This is a rare event, so lets log it
1751                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1752                      }
1753                  }
1754              }
1755              if (!added.isEmpty()) {
1756                  addAndBindAddedWorkspaceApps(context, added);
1757              }
1758          }
1759  
1760          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1761          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1762                                             AtomicBoolean deleteOnInvalidPlacement) {
1763              LauncherAppState app = LauncherAppState.getInstance();
1764              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1765              final int countX = (int) grid.numColumns;
1766              final int countY = (int) grid.numRows;
1767  
1768              long containerIndex = item.screenId;
1769              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1770                  // Return early if we detect that an item is under the hotseat button
1771                  if (mCallbacks == null ||
1772                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1773                      deleteOnInvalidPlacement.set(true);
1774                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1775                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1776                              + item.cellY + &quot;) occupied by all apps&quot;);
1777                      return false;
1778                  }
1779  
1780                  final ItemInfo[][] hotseatItems =
1781                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1782  
1783                  if (item.screenId &gt;= grid.numHotseatIcons) {
1784                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1785                              + &quot; into hotseat position &quot; + item.screenId
1786                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1787                              + &quot;)&quot;);
1788                      return false;
1789                  }
1790  
1791                  if (hotseatItems != null) {
1792                      if (hotseatItems[(int) item.screenId][0] != null) {
1793                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1794                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1795                                  + item.cellY + &quot;) occupied by &quot;
1796                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1797                                  [(int) item.screenId][0]);
1798                              return false;
1799                      } else {
1800                          hotseatItems[(int) item.screenId][0] = item;
1801                          return true;
1802                      }
1803                  } else {
1804                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1805                      items[(int) item.screenId][0] = item;
1806                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1807                      return true;
1808                  }
1809              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1810                  // Skip further checking if it is not the hotseat or workspace container
1811                  return true;
1812              }
1813  
1814              if (!occupied.containsKey(item.screenId)) {
1815                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1816                  occupied.put(item.screenId, items);
1817              }
1818  
1819              final ItemInfo[][] screens = occupied.get(item.screenId);
1820              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1821                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1822                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1823                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1824                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1825                          + item.cellX + &quot;,&quot; + item.cellY
1826                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1827                  return false;
1828              }
1829  
1830              // Check if any workspace icons overlap with each other
1831              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1832                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1833                      if (screens[x][y] != null) {
1834                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1835                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1836                              + x + &quot;,&quot; + y
1837                              + &quot;) occupied by &quot;
1838                              + screens[x][y]);
1839                          return false;
1840                      }
1841                  }
1842              }
1843              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1844                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1845                      screens[x][y] = item;
1846                  }
1847              }
1848  
1849              return true;
1850          }
1851  
1852          /** Clears all the sBg data structures */
1853          private void clearSBgDataStructures() {
1854              synchronized (sBgLock) {
1855                  sBgWorkspaceItems.clear();
1856                  sBgAppWidgets.clear();
1857                  sBgFolders.clear();
1858                  sBgItemsIdMap.clear();
1859                  sBgDbIconCache.clear();
1860                  sBgWorkspaceScreens.clear();
1861              }
1862          }
1863  
1864          /** Returns whether this is an upgrade path */
1865          private boolean loadWorkspace() {
1866              // Log to disk
1867              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1868  
1869              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1870  
1871              final Context context = mContext;
1872              final ContentResolver contentResolver = context.getContentResolver();
1873              final PackageManager manager = context.getPackageManager();
1874              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1875              final boolean isSafeMode = manager.isSafeMode();
1876              final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1877              final boolean isSdCardReady = context.registerReceiver(null,
1878                      new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1879  
1880              LauncherAppState app = LauncherAppState.getInstance();
1881              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1882              int countX = (int) grid.numColumns;
1883              int countY = (int) grid.numRows;
1884  
1885              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1886                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1887                  LauncherAppState.getLauncherProvider().deleteDatabase();
1888              }
1889  
1890              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1891                  // append the user&#x27;s Launcher2 shortcuts
1892                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1893                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1894              } else {
1895                  // Make sure the default workspace is loaded
1896                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1897                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1898              }
1899  
1900              // This code path is for our old migration code and should no longer be exercised
1901              boolean loadedOldDb = false;
1902  
1903              // Log to disk
1904              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1905  
1906              synchronized (sBgLock) {
1907                  clearSBgDataStructures();
1908                  final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1909                          .getInstance(mContext).updateAndGetActiveSessionCache();
1910  
1911                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1912                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1913                  final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1914                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1915                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1916  
1917                  // +1 for the hotseat (it can be larger than the workspace)
1918                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1919                  // before any earlier duplicates)
1920                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1921  
1922                  try {
1923                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1924                      final int intentIndex = c.getColumnIndexOrThrow
1925                              (LauncherSettings.Favorites.INTENT);
1926                      final int titleIndex = c.getColumnIndexOrThrow
1927                              (LauncherSettings.Favorites.TITLE);
1928                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1929                              LauncherSettings.Favorites.ICON_TYPE);
1930                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1931                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1932                              LauncherSettings.Favorites.ICON_PACKAGE);
1933                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1934                              LauncherSettings.Favorites.ICON_RESOURCE);
1935                      final int containerIndex = c.getColumnIndexOrThrow(
1936                              LauncherSettings.Favorites.CONTAINER);
1937                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1938                              LauncherSettings.Favorites.ITEM_TYPE);
1939                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1940                              LauncherSettings.Favorites.APPWIDGET_ID);
1941                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1942                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1943                      final int screenIndex = c.getColumnIndexOrThrow(
1944                              LauncherSettings.Favorites.SCREEN);
1945                      final int cellXIndex = c.getColumnIndexOrThrow
1946                              (LauncherSettings.Favorites.CELLX);
1947                      final int cellYIndex = c.getColumnIndexOrThrow
1948                              (LauncherSettings.Favorites.CELLY);
1949                      final int spanXIndex = c.getColumnIndexOrThrow
1950                              (LauncherSettings.Favorites.SPANX);
1951                      final int spanYIndex = c.getColumnIndexOrThrow(
1952                              LauncherSettings.Favorites.SPANY);
1953                      final int restoredIndex = c.getColumnIndexOrThrow(
1954                              LauncherSettings.Favorites.RESTORED);
1955                      final int profileIdIndex = c.getColumnIndexOrThrow(
1956                              LauncherSettings.Favorites.PROFILE_ID);
1957                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1958                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1959                      //        LauncherSettings.Favorites.DISPLAY_MODE);
1960  
1961                      ShortcutInfo info;
1962                      String intentDescription;
1963                      LauncherAppWidgetInfo appWidgetInfo;
1964                      int container;
1965                      long id;
1966                      Intent intent;
1967                      UserHandleCompat user;
1968  
1969                      while (!mStopped &amp;&amp; c.moveToNext()) {
1970                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1971                          try {
1972                              int itemType = c.getInt(itemTypeIndex);
1973                              boolean restored = 0 != c.getInt(restoredIndex);
1974                              boolean allowMissingTarget = false;
1975  
1976                              switch (itemType) {
1977                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1978                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1979                                  id = c.getLong(idIndex);
1980                                  intentDescription = c.getString(intentIndex);
1981                                  long serialNumber = c.getInt(profileIdIndex);
1982                                  user = mUserManager.getUserForSerialNumber(serialNumber);
1983                                  int promiseType = c.getInt(restoredIndex);

1984                                  if (user == null) {
1985                                      // User has been deleted remove the item.
1986                                      itemsToRemove.add(id);
1987                                      continue;
1988                                  }
1989                                  try {
1990                                      intent = Intent.parseUri(intentDescription, 0);
1991                                      ComponentName cn = intent.getComponent();
1992                                      if (cn != null &amp;&amp; cn.getPackageName() != null) {
1993                                          boolean validPkg = launcherApps.isPackageEnabledForProfile(
1994                                                  cn.getPackageName(), user);
1995                                          boolean validComponent = validPkg &amp;&amp;
1996                                                  launcherApps.isActivityEnabledForProfile(cn, user);
1997  
1998                                          if (validComponent) {
1999                                              if (restored) {
2000                                                  // no special handling necessary for this item
2001                                                  restoredRows.add(id);
2002                                                  restored = false;
2003                                              }
2004                                          } else if (validPkg) {
2005                                              intent = null;
2006                                              if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2007                                                  // We allow auto install apps to have their intent
2008                                                  // updated after an install.
2009                                                  intent = manager.getLaunchIntentForPackage(
2010                                                          cn.getPackageName());
2011                                                  if (intent != null) {
2012                                                      ContentValues values = new ContentValues();
2013                                                      values.put(LauncherSettings.Favorites.INTENT,
2014                                                              intent.toUri(0));
2015                                                      String where = BaseColumns._ID + &quot;= ?&quot;;
2016                                                      String[] args = {Long.toString(id)};
2017                                                      contentResolver.update(contentUri, values, where, args);
2018                                                  }
2019                                              }
2020  
2021                                              if (intent == null) {
2022                                                  // The app is installed but the component is no
2023                                                  // longer available.
2024                                                  Launcher.addDumpLog(TAG,
2025                                                          &quot;Invalid component removed: &quot; + cn, true);
2026                                                  itemsToRemove.add(id);
2027                                                  continue;
2028                                              } else {
2029                                                  // no special handling necessary for this item
2030                                                  restoredRows.add(id);
2031                                                  restored = false;
2032                                              }
2033                                          } else if (restored) {
2034                                              // Package is not yet available but might be
2035                                              // installed later.
2036                                              Launcher.addDumpLog(TAG,
2037                                                      &quot;package not yet restored: &quot; + cn, true);
2038  
2039                                              if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2040                                                  // Restore has started once.
2041                                              } else if (installingPkgs.contains(cn.getPackageName())) {
2042                                                  // App restore has started. Update the flag
2043                                                  promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2044                                                  ContentValues values = new ContentValues();
2045                                                  values.put(LauncherSettings.Favorites.RESTORED,
2046                                                          promiseType);
2047                                                  String where = BaseColumns._ID + &quot;= ?&quot;;
2048                                                  String[] args = {Long.toString(id)};
2049                                                  contentResolver.update(contentUri, values, where, args);
2050  
2051                                              } else if (REMOVE_UNRESTORED_ICONS) {
2052                                                  Launcher.addDumpLog(TAG,
2053                                                          &quot;Unrestored package removed: &quot; + cn, true);
2054                                                  itemsToRemove.add(id);
2055                                                  continue;
2056                                              }
2057                                          } else if (isSdCardReady) {
2058                                              // Do not wait for external media load anymore.
2059                                              // Log the invalid package, and remove it
2060                                              Launcher.addDumpLog(TAG,
2061                                                      &quot;Invalid package removed: &quot; + cn, true);
2062                                              itemsToRemove.add(id);
2063                                              continue;
2064                                          } else {







2065                                              // SdCard is not ready yet. Package might get available,
2066                                              // once it is ready.
2067                                              Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2068                                                      + &quot; (check again later)&quot;, true);
2069                                              HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2070                                              if (pkgs == null) {
2071                                                  pkgs = new HashSet&lt;String&gt;();
2072                                                  sPendingPackages.put(user, pkgs);
2073                                              }
2074                                              pkgs.add(cn.getPackageName());
2075                                              allowMissingTarget = true;
2076                                              // Add the icon on the workspace anyway.








2077                                          }
2078                                      } else if (cn == null) {
2079                                          // For shortcuts with no component, keep them as they are
2080                                          restoredRows.add(id);
2081                                          restored = false;
2082                                      }
2083                                  } catch (URISyntaxException e) {
2084                                      Launcher.addDumpLog(TAG,
2085                                              &quot;Invalid uri: &quot; + intentDescription, true);
2086                                      continue;
2087                                  }
2088  
2089                                  if (restored) {
2090                                      if (user.equals(UserHandleCompat.myUserHandle())) {
2091                                          Launcher.addDumpLog(TAG,
2092                                                  &quot;constructing info for partially restored package&quot;,
2093                                                  true);
2094                                          info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2095                                          intent = getRestoredItemIntent(c, context, intent);
2096                                      } else {
2097                                          // Don&#x27;t restore items for other profiles.
2098                                          itemsToRemove.add(id);
2099                                          continue;
2100                                      }
2101                                  } else if (itemType ==
2102                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2103                                      info = getShortcutInfo(manager, intent, user, context, c,
2104                                              iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2105                                  } else {
2106                                      info = getShortcutInfo(c, context, iconTypeIndex,
2107                                              iconPackageIndex, iconResourceIndex, iconIndex,
2108                                              titleIndex);
2109  
2110                                      // App shortcuts that used to be automatically added to Launcher
2111                                      // didn&#x27;t always have the correct intent flags set, so do that
2112                                      // here
2113                                      if (intent.getAction() != null &amp;&amp;
2114                                          intent.getCategories() != null &amp;&amp;
2115                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2116                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2117                                          intent.addFlags(
2118                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2119                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2120                                      }
2121                                  }
2122  
2123                                  if (info != null) {
2124                                      info.id = id;
2125                                      info.intent = intent;
2126                                      container = c.getInt(containerIndex);
2127                                      info.container = container;
2128                                      info.screenId = c.getInt(screenIndex);
2129                                      info.cellX = c.getInt(cellXIndex);
2130                                      info.cellY = c.getInt(cellYIndex);
2131                                      info.spanX = 1;
2132                                      info.spanY = 1;
2133                                      info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2134                                      info.isDisabled = isSafeMode
2135                                              &amp;&amp; !Utilities.isSystemApp(context, intent);




2136  
2137                                      // check &amp; update map of what&#x27;s occupied
2138                                      deleteOnInvalidPlacement.set(false);
2139                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2140                                          if (deleteOnInvalidPlacement.get()) {
2141                                              itemsToRemove.add(id);
2142                                          }
2143                                          break;
2144                                      }
2145  
2146                                      switch (container) {
2147                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2148                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2149                                          sBgWorkspaceItems.add(info);
2150                                          break;
2151                                      default:
2152                                          // Item is in a user folder
2153                                          FolderInfo folderInfo =
2154                                                  findOrMakeFolder(sBgFolders, container);
2155                                          folderInfo.add(info);
2156                                          break;
2157                                      }
2158                                      sBgItemsIdMap.put(info.id, info);
2159  
2160                                      // now that we&#x27;ve loaded everthing re-save it with the
2161                                      // icon in case it disappears somehow.
2162                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2163                                  } else {
2164                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2165                                  }
2166                                  break;
2167  
2168                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2169                                  id = c.getLong(idIndex);
2170                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2171  
2172                                  folderInfo.title = c.getString(titleIndex);
2173                                  folderInfo.id = id;
2174                                  container = c.getInt(containerIndex);
2175                                  folderInfo.container = container;
2176                                  folderInfo.screenId = c.getInt(screenIndex);
2177                                  folderInfo.cellX = c.getInt(cellXIndex);
2178                                  folderInfo.cellY = c.getInt(cellYIndex);
2179                                  folderInfo.spanX = 1;
2180                                  folderInfo.spanY = 1;
2181  
2182                                  // check &amp; update map of what&#x27;s occupied
2183                                  deleteOnInvalidPlacement.set(false);
2184                                  if (!checkItemPlacement(occupied, folderInfo,
2185                                          deleteOnInvalidPlacement)) {
2186                                      if (deleteOnInvalidPlacement.get()) {
2187                                          itemsToRemove.add(id);
2188                                      }
2189                                      break;
2190                                  }
2191  
2192                                  switch (container) {
2193                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2194                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2195                                          sBgWorkspaceItems.add(folderInfo);
2196                                          break;
2197                                  }
2198  
2199                                  if (restored) {
2200                                      // no special handling required for restored folders
2201                                      restoredRows.add(id);
2202                                  }
2203  
2204                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2205                                  sBgFolders.put(folderInfo.id, folderInfo);
2206                                  break;
2207  
2208                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2209                                  // Read all Launcher-specific widget details
2210                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2211                                  String savedProvider = c.getString(appWidgetProviderIndex);
2212                                  id = c.getLong(idIndex);
2213                                  final ComponentName component =
2214                                          ComponentName.unflattenFromString(savedProvider);
2215  
2216                                  final int restoreStatus = c.getInt(restoredIndex);
2217                                  final boolean isIdValid = (restoreStatus &amp;
2218                                          LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2219  
2220                                  final boolean wasProviderReady = (restoreStatus &amp;
2221                                          LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2222  
2223                                  final AppWidgetProviderInfo provider = isIdValid
2224                                          ? widgets.getAppWidgetInfo(appWidgetId)
2225                                          : findAppWidgetProviderInfoWithComponent(context, component);
2226  
2227                                  final boolean isProviderReady = isValidProvider(provider);
2228                                  if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2229                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2230                                              + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2231                                      Log.e(TAG, log);
2232                                      Launcher.addDumpLog(TAG, log, false);
2233                                      itemsToRemove.add(id);
2234                                  } else {
2235                                      if (isProviderReady) {
2236                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2237                                                  provider.provider);
2238                                          int[] minSpan =
2239                                                  Launcher.getMinSpanForWidget(context, provider);
2240                                          appWidgetInfo.minSpanX = minSpan[0];
2241                                          appWidgetInfo.minSpanY = minSpan[1];
2242  
2243                                          int status = restoreStatus;
2244                                          if (!wasProviderReady) {
2245                                              // If provider was not previously ready, update the
2246                                              // status and UI flag.
2247  
<abbr title="2248                                              // Id would be valid only if the widget restore broadcast was received.">2248                                              // Id would be valid only if the widget restore broadcast was receivedðŸ”µ</abbr>
2249                                              if (isIdValid) {
2250                                                  status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2251                                              } else {
2252                                                  status &amp;= ~LauncherAppWidgetInfo
2253                                                          .FLAG_PROVIDER_NOT_READY;
2254                                              }
2255                                          }
2256                                          appWidgetInfo.restoreStatus = status;
2257                                      } else {
2258                                          Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2259                                                  + &quot; appWidgetId=&quot; + appWidgetId
2260                                                  + &quot; status =&quot; + restoreStatus);
2261                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2262                                                  component);
2263                                          appWidgetInfo.restoreStatus = restoreStatus;
2264  
2265                                          if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {
2266                                              // Restore has started once.
2267                                          } else if (installingPkgs.contains(component.getPackageName())) {
2268                                              // App restore has started. Update the flag
2269                                              appWidgetInfo.restoreStatus |=
2270                                                      LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2271                                          } else if (REMOVE_UNRESTORED_ICONS) {
2272                                              Launcher.addDumpLog(TAG,
2273                                                      &quot;Unrestored widget removed: &quot; + component, true);
2274                                              itemsToRemove.add(id);
2275                                              continue;
2276                                          }
2277                                      }
2278  
2279                                      appWidgetInfo.id = id;
2280                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2281                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2282                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2283                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2284                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
2285  
2286                                      container = c.getInt(containerIndex);
2287                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2288                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2289                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2290                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2291                                          continue;
2292                                      }
2293  
2294                                      appWidgetInfo.container = c.getInt(containerIndex);
2295                                      // check &amp; update map of what&#x27;s occupied
2296                                      deleteOnInvalidPlacement.set(false);
2297                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2298                                              deleteOnInvalidPlacement)) {
2299                                          if (deleteOnInvalidPlacement.get()) {
2300                                              itemsToRemove.add(id);
2301                                          }
2302                                          break;
2303                                      }
2304  
2305                                      String providerName = appWidgetInfo.providerName.flattenToString();
2306                                      if (!providerName.equals(savedProvider) ||
2307                                              (appWidgetInfo.restoreStatus != restoreStatus)) {
2308                                          ContentValues values = new ContentValues();
2309                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2310                                                  providerName);
2311                                          values.put(LauncherSettings.Favorites.RESTORED,
2312                                                  appWidgetInfo.restoreStatus);
2313                                          String where = BaseColumns._ID + &quot;= ?&quot;;
2314                                          String[] args = {Long.toString(id)};
2315                                          contentResolver.update(contentUri, values, where, args);
2316                                      }
2317                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2318                                      sBgAppWidgets.add(appWidgetInfo);
2319                                  }
2320                                  break;
2321                              }
2322                          } catch (Exception e) {
2323                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2324                          }
2325                      }
2326                  } finally {
2327                      if (c != null) {
2328                          c.close();
2329                      }
2330                  }
2331  
2332                  // Break early if we&#x27;ve stopped loading
2333                  if (mStopped) {
2334                      clearSBgDataStructures();
2335                      return false;
2336                  }
2337  
2338                  if (itemsToRemove.size() &gt; 0) {
2339                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
2340                              contentUri);
2341                      // Remove dead items
2342                      for (long id : itemsToRemove) {
2343                          if (DEBUG_LOADERS) {
2344                              Log.d(TAG, &quot;Removed id = &quot; + id);
2345                          }
2346                          // Don&#x27;t notify content observers
2347                          try {
2348                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2349                                      null, null);
2350                          } catch (RemoteException e) {
2351                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2352                          }
2353                      }
2354                  }
2355  
2356                  if (restoredRows.size() &gt; 0) {
2357                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2358                              contentUri);
2359                      // Update restored items that no longer require special handling
2360                      try {
2361                          StringBuilder selectionBuilder = new StringBuilder();
2362                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2363                          selectionBuilder.append(&quot; IN (&quot;);
2364                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2365                          selectionBuilder.append(&quot;)&quot;);
2366                          ContentValues values = new ContentValues();
2367                          values.put(LauncherSettings.Favorites.RESTORED, 0);
2368                          updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2369                                  values, selectionBuilder.toString(), null);
2370                      } catch (RemoteException e) {
2371                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2372                      }
2373                  }
2374  
2375                  if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2376                      context.registerReceiver(new AppsAvailabilityCheck(),
2377                              new IntentFilter(StartupReceiver.SYSTEM_READY),
2378                              null, sWorker);
2379                  }
2380  
2381                  if (loadedOldDb) {
2382                      long maxScreenId = 0;
2383                      // If we&#x27;re importing we use the old screen order.
2384                      for (ItemInfo item: sBgItemsIdMap.values()) {
2385                          long screenId = item.screenId;
2386                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2387                                  !sBgWorkspaceScreens.contains(screenId)) {
2388                              sBgWorkspaceScreens.add(screenId);
2389                              if (screenId &gt; maxScreenId) {
2390                                  maxScreenId = screenId;
2391                              }
2392                          }
2393                      }
2394                      Collections.sort(sBgWorkspaceScreens);
2395                      // Log to disk
2396                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2397                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2398                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2399  
2400                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2401                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2402  
2403                      // Update the max item id after we load an old db
2404                      long maxItemId = 0;
2405                      // If we&#x27;re importing we use the old screen order.
2406                      for (ItemInfo item: sBgItemsIdMap.values()) {
2407                          maxItemId = Math.max(maxItemId, item.id);
2408                      }
2409                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2410                  } else {
2411                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2412                      for (Integer i : orderedScreens.keySet()) {
2413                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2414                      }
2415                      // Log to disk
2416                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2417                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2418  
2419                      // Remove any empty screens
2420                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2421                      for (ItemInfo item: sBgItemsIdMap.values()) {
2422                          long screenId = item.screenId;
2423                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2424                                  unusedScreens.contains(screenId)) {
2425                              unusedScreens.remove(screenId);
2426                          }
2427                      }
2428  
2429                      // If there are any empty screens remove them, and update.
2430                      if (unusedScreens.size() != 0) {
2431                          // Log to disk
2432                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2433                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2434  
2435                          sBgWorkspaceScreens.removeAll(unusedScreens);
2436                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2437                      }
2438                  }
2439  
2440                  if (DEBUG_LOADERS) {
2441                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2442                      Log.d(TAG, &quot;workspace layout: &quot;);
2443                      int nScreens = occupied.size();
2444                      for (int y = 0; y &lt; countY; y++) {
2445                          String line = &quot;&quot;;
2446  
2447                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2448                          while (iter.hasNext()) {
2449                              long screenId = iter.next();
2450                              if (screenId &gt; 0) {
2451                                  line += &quot; | &quot;;
2452                              }
2453                              for (int x = 0; x &lt; countX; x++) {
2454                                  ItemInfo[][] screen = occupied.get(screenId);
2455                                  if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2456                                      line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2457                                  } else {
2458                                      line += &quot;!&quot;;
2459                                  }
2460                              }
2461                          }
2462                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2463                      }
2464                  }
2465              }
2466              return loadedOldDb;
2467          }
2468  
2469          /** Filters the set of items who are directly or indirectly (via another container) on the
2470           * specified screen. */
2471          private void filterCurrentWorkspaceItems(long currentScreenId,
2472                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2473                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2474                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2475              // Purge any null ItemInfos
2476              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2477              while (iter.hasNext()) {
2478                  ItemInfo i = iter.next();
2479                  if (i == null) {
2480                      iter.remove();
2481                  }
2482              }
2483  
2484              // Order the set of items by their containers first, this allows use to walk through the
2485              // list sequentially, build up a list of containers that are in the specified screen,
2486              // as well as all items in those containers.
2487              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2488              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2489                  @Override
2490                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2491                      return (int) (lhs.container - rhs.container);
2492                  }
2493              });
2494              for (ItemInfo info : allWorkspaceItems) {
2495                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2496                      if (info.screenId == currentScreenId) {
2497                          currentScreenItems.add(info);
2498                          itemsOnScreen.add(info.id);
2499                      } else {
2500                          otherScreenItems.add(info);
2501                      }
2502                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2503                      currentScreenItems.add(info);
2504                      itemsOnScreen.add(info.id);
2505                  } else {
2506                      if (itemsOnScreen.contains(info.container)) {
2507                          currentScreenItems.add(info);
2508                          itemsOnScreen.add(info.id);
2509                      } else {
2510                          otherScreenItems.add(info);
2511                      }
2512                  }
2513              }
2514          }
2515  
2516          /** Filters the set of widgets which are on the specified screen. */
2517          private void filterCurrentAppWidgets(long currentScreenId,
2518                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2519                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2520                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2521  
2522              for (LauncherAppWidgetInfo widget : appWidgets) {
2523                  if (widget == null) continue;
2524                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2525                          widget.screenId == currentScreenId) {
2526                      currentScreenWidgets.add(widget);
2527                  } else {
2528                      otherScreenWidgets.add(widget);
2529                  }
2530              }
2531          }
2532  
2533          /** Filters the set of folders which are on the specified screen. */
2534          private void filterCurrentFolders(long currentScreenId,
2535                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2536                  HashMap&lt;Long, FolderInfo&gt; folders,
2537                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2538                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2539  
2540              for (long id : folders.keySet()) {
2541                  ItemInfo info = itemsIdMap.get(id);
2542                  FolderInfo folder = folders.get(id);
2543                  if (info == null || folder == null) continue;
2544                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2545                          info.screenId == currentScreenId) {
2546                      currentScreenFolders.put(id, folder);
2547                  } else {
2548                      otherScreenFolders.put(id, folder);
2549                  }
2550              }
2551          }
2552  
2553          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2554           * right) */
2555          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2556              final LauncherAppState app = LauncherAppState.getInstance();
2557              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2558              // XXX: review this
2559              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2560                  @Override
2561                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2562                      int cellCountX = (int) grid.numColumns;
2563                      int cellCountY = (int) grid.numRows;
2564                      int screenOffset = cellCountX * cellCountY;
2565                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2566                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2567                              lhs.cellY * cellCountX + lhs.cellX);
2568                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2569                              rhs.cellY * cellCountX + rhs.cellX);
2570                      return (int) (lr - rr);
2571                  }
2572              });
2573          }
2574  
2575          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2576                  final ArrayList&lt;Long&gt; orderedScreens) {
2577              final Runnable r = new Runnable() {
2578                  @Override
2579                  public void run() {
2580                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2581                      if (callbacks != null) {
2582                          callbacks.bindScreens(orderedScreens);
2583                      }
2584                  }
2585              };
2586              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2587          }
2588  
2589          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2590                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2591                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2592                  final HashMap&lt;Long, FolderInfo&gt; folders,
2593                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2594  
2595              final boolean postOnMainThread = (deferredBindRunnables != null);
2596  
2597              // Bind the workspace items
2598              int N = workspaceItems.size();
2599              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2600                  final int start = i;
2601                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2602                  final Runnable r = new Runnable() {
2603                      @Override
2604                      public void run() {
2605                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2606                          if (callbacks != null) {
2607                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2608                                      false);
2609                          }
2610                      }
2611                  };
2612                  if (postOnMainThread) {
2613                      synchronized (deferredBindRunnables) {
2614                          deferredBindRunnables.add(r);
2615                      }
2616                  } else {
2617                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2618                  }
2619              }
2620  
2621              // Bind the folders
2622              if (!folders.isEmpty()) {
2623                  final Runnable r = new Runnable() {
2624                      public void run() {
2625                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2626                          if (callbacks != null) {
2627                              callbacks.bindFolders(folders);
2628                          }
2629                      }
2630                  };
2631                  if (postOnMainThread) {
2632                      synchronized (deferredBindRunnables) {
2633                          deferredBindRunnables.add(r);
2634                      }
2635                  } else {
2636                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2637                  }
2638              }
2639  
2640              // Bind the widgets, one at a time
2641              N = appWidgets.size();
2642              for (int i = 0; i &lt; N; i++) {
2643                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2644                  final Runnable r = new Runnable() {
2645                      public void run() {
2646                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2647                          if (callbacks != null) {
2648                              callbacks.bindAppWidget(widget);
2649                          }
2650                      }
2651                  };
2652                  if (postOnMainThread) {
2653                      deferredBindRunnables.add(r);
2654                  } else {
2655                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2656                  }
2657              }
2658          }
2659  
2660          /**
2661           * Binds all loaded data to actual views on the main thread.
2662           */
2663          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2664              final long t = SystemClock.uptimeMillis();
2665              Runnable r;
2666  
2667              // Don&#x27;t use these two variables in any of the callback runnables.
2668              // Otherwise we hold a reference to them.
2669              final Callbacks oldCallbacks = mCallbacks.get();
2670              if (oldCallbacks == null) {
2671                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2672                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2673                  return;
2674              }
2675  
2676              // Save a copy of all the bg-thread collections
2677              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2678              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2679                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2680              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2681              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2682              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2683              synchronized (sBgLock) {
2684                  workspaceItems.addAll(sBgWorkspaceItems);
2685                  appWidgets.addAll(sBgAppWidgets);
2686                  folders.putAll(sBgFolders);
2687                  itemsIdMap.putAll(sBgItemsIdMap);
2688                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2689              }
2690  
2691              final boolean isLoadingSynchronously =
2692                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2693              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2694                  oldCallbacks.getCurrentWorkspaceScreen();
2695              if (currScreen &gt;= orderedScreenIds.size()) {
2696                  // There may be no workspace screens (just hotseat items and an empty page).
2697                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2698              }
2699              final int currentScreen = currScreen;
2700              final long currentScreenId = currentScreen &lt; 0
2701                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2702  
2703              // Load all the items that are on the current page first (and in the process, unbind
2704              // all the existing workspace items before we call startBinding() below.
2705              unbindWorkspaceItemsOnMainThread();
2706  
2707              // Separate the items that are on the current screen, and all the other remaining items
2708              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2709              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2710              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2711                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2712              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2713                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2714              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2715              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2716  
2717              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2718                      otherWorkspaceItems);
2719              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2720                      otherAppWidgets);
2721              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2722                      otherFolders);
2723              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2724              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2725  
2726              // Tell the workspace that we&#x27;re about to start binding items
2727              r = new Runnable() {
2728                  public void run() {
2729                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2730                      if (callbacks != null) {
2731                          callbacks.startBinding();
2732                      }
2733                  }
2734              };
2735              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2736  
2737              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2738  
2739              // Load items on the current page
2740              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2741                      currentFolders, null);
2742              if (isLoadingSynchronously) {
2743                  r = new Runnable() {
2744                      public void run() {
2745                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2746                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2747                              callbacks.onPageBoundSynchronously(currentScreen);
2748                          }
2749                      }
2750                  };
2751                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2752              }
2753  
2754              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2755              // work until after the first render)
2756              synchronized (mDeferredBindRunnables) {
2757                  mDeferredBindRunnables.clear();
2758              }
2759              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2760                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2761  
2762              // Tell the workspace that we&#x27;re done binding items
2763              r = new Runnable() {
2764                  public void run() {
2765                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2766                      if (callbacks != null) {
2767                          callbacks.finishBindingItems(isUpgradePath);
2768                      }
2769  
2770                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2771                      if (DEBUG_LOADERS) {
2772                          Log.d(TAG, &quot;bound workspace in &quot;
2773                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2774                      }
2775  
2776                      mIsLoadingAndBindingWorkspace = false;
2777                  }
2778              };
2779              if (isLoadingSynchronously) {
2780                  synchronized (mDeferredBindRunnables) {
2781                      mDeferredBindRunnables.add(r);
2782                  }
2783              } else {
2784                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2785              }
2786          }
2787  
2788          private void loadAndBindAllApps() {
2789              if (DEBUG_LOADERS) {
2790                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2791              }
2792              if (!mAllAppsLoaded) {
2793                  loadAllApps();
2794                  synchronized (LoaderTask.this) {
2795                      if (mStopped) {
2796                          return;
2797                      }
2798                      mAllAppsLoaded = true;
2799                  }
2800              } else {
2801                  onlyBindAllApps();
2802              }
2803          }
2804  
2805          private void onlyBindAllApps() {
2806              final Callbacks oldCallbacks = mCallbacks.get();
2807              if (oldCallbacks == null) {
2808                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2809                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2810                  return;
2811              }
2812  
2813              // shallow copy
2814              @SuppressWarnings(&quot;unchecked&quot;)
2815              final ArrayList&lt;AppInfo&gt; list
2816                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2817              Runnable r = new Runnable() {
2818                  public void run() {
2819                      final long t = SystemClock.uptimeMillis();
2820                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2821                      if (callbacks != null) {
2822                          callbacks.bindAllApplications(list);
2823                      }
2824                      if (DEBUG_LOADERS) {
2825                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2826                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2827                      }
2828                  }
2829              };
2830              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2831              if (isRunningOnMainThread) {
2832                  r.run();
2833              } else {
2834                  mHandler.post(r);
2835              }
2836          }
2837  
2838          private void loadAllApps() {
2839              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2840  
2841              final Callbacks oldCallbacks = mCallbacks.get();
2842              if (oldCallbacks == null) {
2843                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2844                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2845                  return;
2846              }
2847  
2848              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2849              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2850  
2851              final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2852  
2853              // Clear the list of apps
2854              mBgAllAppsList.clear();
2855              for (UserHandleCompat user : profiles) {
2856                  // Query for the set of apps
2857                  final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2858                  List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2859                  if (DEBUG_LOADERS) {
2860                      Log.d(TAG, &quot;getActivityList took &quot;
2861                              + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2862                      Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2863                  }
2864                  // Fail if we don&#x27;t have any apps
2865                  if (apps == null || apps.isEmpty()) {
2866                      return;
2867                  }
2868                  // Sort the applications by name
2869                  final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2870                  Collections.sort(apps,
2871                          new LauncherModel.ShortcutNameComparator(mLabelCache));
2872                  if (DEBUG_LOADERS) {
2873                      Log.d(TAG, &quot;sort took &quot;
2874                              + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2875                  }
2876  
2877                  // Create the ApplicationInfos
2878                  for (int i = 0; i &lt; apps.size(); i++) {
2879                      LauncherActivityInfoCompat app = apps.get(i);
2880                      // This builds the icon bitmaps.
2881                      mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2882                  }
2883              }
2884              // Huh? Shouldn&#x27;t this be inside the Runnable below?
2885              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2886              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2887  
2888              // Post callback on main thread
2889              mHandler.post(new Runnable() {
2890                  public void run() {
2891                      final long bindTime = SystemClock.uptimeMillis();
2892                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2893                      if (callbacks != null) {
2894                          callbacks.bindAllApplications(added);
2895                          if (DEBUG_LOADERS) {
2896                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2897                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2898                          }
2899                      } else {
2900                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2901                      }
2902                  }
2903              });
2904  
2905              if (DEBUG_LOADERS) {
2906                  Log.d(TAG, &quot;Icons processed in &quot;
2907                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2908              }
2909          }
2910  
2911          public void dumpState() {
2912              synchronized (sBgLock) {
2913                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2914                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2915                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2916                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2917                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2918              }
2919          }
2920      }
2921  
2922      void enqueuePackageUpdated(PackageUpdatedTask task) {
2923          sWorker.post(task);
2924      }
2925  
2926      private class AppsAvailabilityCheck extends BroadcastReceiver {
2927  
2928          @Override
2929          public void onReceive(Context context, Intent intent) {
2930              synchronized (sBgLock) {
2931                  final LauncherAppsCompat launcherApps = LauncherAppsCompat
2932                          .getInstance(mApp.getContext());
2933                  ArrayList&lt;String&gt; packagesRemoved;



2934                  for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2935                      UserHandleCompat user = entry.getKey();
2936                      packagesRemoved = new ArrayList&lt;String&gt;();


2937                      for (String pkg : entry.getValue()) {
2938                          if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2939                              Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2940                              packagesRemoved.add(pkg);









2941                          }
2942                      }
2943                      if (!packagesRemoved.isEmpty()) {
2944                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2945                                  packagesRemoved.toArray(new String[packagesRemoved.size()]), user));




2946                      }
2947                  }
2948                  sPendingPackages.clear();
2949              }
2950          }
2951      }
2952  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2953 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2954 +     * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2955 +     * runnable was missed by the launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2956 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2957 +    public void recheckRestoredItems(final Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2958 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2959 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2960 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2961 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2962 +                LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2963 +                HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2964 +                UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2965 +                synchronized(sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2966 +                    for (ItemInfo info : sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2967 +                        if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2968 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2969 +                            if (si.isPromise() &amp;&amp; si.getTargetComponent() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2970 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2971 +                                            si.getTargetComponent().getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2972 +                                installedPackages.add(si.getTargetComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2973 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2974 +                        } else if (info instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2975 +                            LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2976 +                            if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2977 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2978 +                                            widget.providerName.getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2979 +                                installedPackages.add(widget.providerName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2980 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2981 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2982 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2983 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2984 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2985 +                if (!installedPackages.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2986 +                    final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2987 +                    for (String pkg : installedPackages) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2988 +                        for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2989 +                            restoredApps.add(new AppInfo(context, info, user, mIconCache, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2990 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2991 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2992 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2993 +                    final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2994 +                    if (!restoredApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2995 +                        mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2996 +                            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2997 +                                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2998 +                                if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2999 +                                    callbacks.bindAppsRestored(restoredApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3000 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3001 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3002 +                        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3003 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3004 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3005 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3006 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3007 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3008 +        sWorker.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3009 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3010 +</span>
3011      private class PackageUpdatedTask implements Runnable {
3012          int mOp;
3013          String[] mPackages;
3014          UserHandleCompat mUser;
3015  
3016          public static final int OP_NONE = 0;
3017          public static final int OP_ADD = 1;
3018          public static final int OP_UPDATE = 2;
3019          public static final int OP_REMOVE = 3; // uninstlled
3020          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3021  
3022  
3023          public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3024              mOp = op;
3025              mPackages = packages;
3026              mUser = user;
3027          }
3028  
3029          public void run() {
3030              final Context context = mApp.getContext();
3031  
3032              final String[] packages = mPackages;
3033              final int N = packages.length;
3034              switch (mOp) {
3035                  case OP_ADD:
3036                      for (int i=0; i&lt;N; i++) {
3037                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3038                          mIconCache.remove(packages[i], mUser);
3039                          mBgAllAppsList.addPackage(context, packages[i], mUser);
3040                      }
3041                      break;
3042                  case OP_UPDATE:
3043                      for (int i=0; i&lt;N; i++) {
3044                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3045                          mBgAllAppsList.updatePackage(context, packages[i], mUser);
3046                          WidgetPreviewLoader.removePackageFromDb(
3047                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3048                      }
3049                      break;
3050                  case OP_REMOVE:
3051                  case OP_UNAVAILABLE:

3052                      for (int i=0; i&lt;N; i++) {
3053                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3054                          mBgAllAppsList.removePackage(packages[i], mUser);

3055                          WidgetPreviewLoader.removePackageFromDb(
3056                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3057                      }
3058                      break;
3059              }
3060  
3061              ArrayList&lt;AppInfo&gt; added = null;
3062              ArrayList&lt;AppInfo&gt; modified = null;
3063              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3064  
3065              if (mBgAllAppsList.added.size() &gt; 0) {
3066                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3067                  mBgAllAppsList.added.clear();
3068              }
3069              if (mBgAllAppsList.modified.size() &gt; 0) {
3070                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3071                  mBgAllAppsList.modified.clear();
3072              }
3073              if (mBgAllAppsList.removed.size() &gt; 0) {
3074                  removedApps.addAll(mBgAllAppsList.removed);
3075                  mBgAllAppsList.removed.clear();
3076              }
3077  
3078              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3079              if (callbacks == null) {
3080                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3081                  return;
3082              }
3083  
3084              if (added != null) {
3085                  // Ensure that we add all the workspace applications to the db
3086                  if (LauncherAppState.isDisableAllApps()) {
3087                      final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3088                      addAndBindAddedWorkspaceApps(context, addedInfos);
3089                  } else {
3090                      addAppsToAllApps(context, added);
3091                  }
3092              }
3093  
3094              if (modified != null) {
3095                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3096  
3097                  // Update the launcher db to reflect the changes
3098                  for (AppInfo a : modifiedFinal) {
3099                      ArrayList&lt;ItemInfo&gt; infos =
3100                              getItemInfoForComponentName(a.componentName, mUser);
3101                      for (ItemInfo i : infos) {
3102                          if (isShortcutInfoUpdateable(i)) {

3103                              ShortcutInfo info = (ShortcutInfo) i;
3104                              info.title = a.title.toString();
3105                              info.contentDescription = a.contentDescription;
3106                              updateItemInDatabase(context, info);
3107                          }
3108                      }
3109                  }
3110  
3111                  mHandler.post(new Runnable() {
3112                      public void run() {
3113                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3114                          if (callbacks == cb &amp;&amp; cb != null) {
3115                              callbacks.bindAppsUpdated(modifiedFinal);
3116                          }
3117                      }
3118                  });
3119              }
3120  





































3121              final ArrayList&lt;String&gt; removedPackageNames =
3122                      new ArrayList&lt;String&gt;();
3123              if (mOp == OP_REMOVE) {

3124                  // Mark all packages in the broadcast to be removed
3125                  removedPackageNames.addAll(Arrays.asList(packages));
3126              } else if (mOp == OP_UPDATE) {
3127                  // Mark disabled packages in the broadcast to be removed
3128                  final PackageManager pm = context.getPackageManager();
3129                  for (int i=0; i&lt;N; i++) {
3130                      if (isPackageDisabled(context, packages[i], mUser)) {
3131                          removedPackageNames.add(packages[i]);
3132                      }
3133                  }
3134              }
3135              // Remove all the components associated with this package
3136              for (String pn : removedPackageNames) {
3137                  deletePackageFromDatabase(context, pn, mUser);
3138              }
3139              // Remove all the specific components
3140              for (AppInfo a : removedApps) {
3141                  ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3142                  deleteItemsFromDatabase(context, infos);
3143              }

3144              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
















3145                  // Remove any queued items from the install queue
3146                  String spKey = LauncherAppState.getSharedPreferencesKey();
3147                  SharedPreferences sp =
3148                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3149                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3150                  // Call the components-removed callback
3151                  mHandler.post(new Runnable() {
3152                      public void run() {
3153                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3154                          if (callbacks == cb &amp;&amp; cb != null) {
3155                              callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);


3156                          }
3157                      }
3158                  });
3159              }
3160  
3161              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3162                      getSortedWidgetsAndShortcuts(context);
3163              mHandler.post(new Runnable() {
3164                  @Override
3165                  public void run() {
3166                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3167                      if (callbacks == cb &amp;&amp; cb != null) {
3168                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3169                      }
3170                  }
3171              });
3172  
3173              // Write all the logs to disk
3174              mHandler.post(new Runnable() {
3175                  public void run() {
3176                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3177                      if (callbacks == cb &amp;&amp; cb != null) {
3178                          callbacks.dumpLogsToLocalData();
3179                      }
3180                  }
3181              });
3182          }
3183      }
3184  
3185      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3186      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3187          PackageManager packageManager = context.getPackageManager();
3188          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3189          widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3190  
3191          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3192          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3193          Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3194          return widgetsAndShortcuts;
3195      }
3196  
3197      private static boolean isPackageDisabled(Context context, String packageName,
3198              UserHandleCompat user) {
3199          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3200          return !launcherApps.isPackageEnabledForProfile(packageName, user);
3201      }
3202  
3203      public static boolean isValidPackageActivity(Context context, ComponentName cn,
3204              UserHandleCompat user) {
3205          if (cn == null) {
3206              return false;
3207          }
3208          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3209          if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3210              return false;
3211          }
3212          return launcherApps.isActivityEnabledForProfile(cn, user);
3213      }
3214  
3215      public static boolean isValidPackage(Context context, String packageName,
3216              UserHandleCompat user) {
3217          if (packageName == null) {
3218              return false;
3219          }
3220          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3221          return launcherApps.isPackageEnabledForProfile(packageName, user);
3222      }
3223  
3224      /**
3225       * Make an ShortcutInfo object for a restored application or shortcut item that points
3226       * to a package that is not yet installed on the system.
3227       */
3228      public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3229              int promiseType) {
3230          final ShortcutInfo info = new ShortcutInfo();
3231          info.user = UserHandleCompat.myUserHandle();
3232          mIconCache.getTitleAndIcon(info, intent, info.user, true);
3233  
3234          if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3235              String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3236              if (!TextUtils.isEmpty(title)) {
3237                  info.title = title;
3238              }
3239              info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3240          } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3241              if (TextUtils.isEmpty(info.title)) {
3242                  info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3243              }
3244              info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3245          } else {
3246              throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3247          }
3248  
3249          info.contentDescription = mUserManager.getBadgedLabelForUser(
3250                  info.title.toString(), info.user);
3251          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3252          info.promisedIntent = intent;
3253          return info;
3254      }
3255  
3256      /**
3257       * Make an Intent object for a restored application or shortcut item that points
3258       * to the market page for the item.
3259       */
3260      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3261          ComponentName componentName = intent.getComponent();
3262          return getMarketIntent(componentName.getPackageName());
3263      }
3264  
3265      static Intent getMarketIntent(String packageName) {
3266          return new Intent(Intent.ACTION_VIEW)
3267              .setData(new Uri.Builder()
3268                  .scheme(&quot;market&quot;)
3269                  .authority(&quot;details&quot;)
3270                  .appendQueryParameter(&quot;id&quot;, packageName)
3271                  .build());
3272      }
3273  
3274      /**
3275       * This is called from the code that adds shortcuts from the intent receiver.  This
3276       * doesn&#x27;t have a Cursor, but
3277       */
3278      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3279              UserHandleCompat user, Context context) {
3280          return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3281      }
3282  
3283      /**
3284       * Make an ShortcutInfo object for a shortcut that is an application.
3285       *
3286       * If c is not null, then it will be used to fill in missing data like the title and icon.
3287       */
3288      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3289              UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3290              HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3291          if (user == null) {
3292              Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3293              return null;
3294          }
3295  
3296          ComponentName componentName = intent.getComponent();
3297          if (componentName == null) {
3298              Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3299              return null;
3300          }
3301  
3302          Intent newIntent = new Intent(intent.getAction(), null);
3303          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3304          newIntent.setComponent(componentName);
3305          LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3306          if ((lai == null) &amp;&amp; !allowMissingTarget) {
3307              Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3308              return null;
3309          }
3310  
3311          final ShortcutInfo info = new ShortcutInfo();
3312  
3313          // the resource -- This may implicitly give us back the fallback icon,
3314          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3315          // to avoid saving lots of copies of that in the database, and most apps
3316          // have icons anyway.
3317          Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3318  
3319          // the db
3320          if (icon == null) {
3321              if (c != null) {
3322                  icon = getIconFromCursor(c, iconIndex, context);
3323              }
3324          }
3325          // the fallback icon
3326          if (icon == null) {
3327              icon = mIconCache.getDefaultIcon(user);
3328              info.usingFallbackIcon = true;
3329          }
3330          info.setIcon(icon);
3331  
3332          // From the cache.
3333          if (labelCache != null) {
3334              info.title = labelCache.get(componentName);
3335          }
3336  
3337          // from the resource
3338          if (info.title == null &amp;&amp; lai != null) {
3339              info.title = lai.getLabel();
3340              if (labelCache != null) {
3341                  labelCache.put(componentName, info.title);
3342              }
3343          }
3344          // from the db
3345          if (info.title == null) {
3346              if (c != null) {
3347                  info.title =  c.getString(titleIndex);
3348              }
3349          }
3350          // fall back to the class name of the activity
3351          if (info.title == null) {
3352              info.title = componentName.getClassName();
3353          }
3354          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3355          info.user = user;
3356          info.contentDescription = mUserManager.getBadgedLabelForUser(
3357                  info.title.toString(), info.user);
3358          return info;
3359      }
3360  
3361      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3362              ItemInfoFilter f) {
3363          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3364          for (ItemInfo i : infos) {
3365              if (i instanceof ShortcutInfo) {
3366                  ShortcutInfo info = (ShortcutInfo) i;
3367                  ComponentName cn = info.getTargetComponent();
3368                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3369                      filtered.add(info);
3370                  }
3371              } else if (i instanceof FolderInfo) {
3372                  FolderInfo info = (FolderInfo) i;
3373                  for (ShortcutInfo s : info.contents) {
3374                      ComponentName cn = s.getTargetComponent();
3375                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3376                          filtered.add(s);
3377                      }
3378                  }
3379              } else if (i instanceof LauncherAppWidgetInfo) {
3380                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3381                  ComponentName cn = info.providerName;
3382                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3383                      filtered.add(info);
3384                  }
3385              }
3386          }
3387          return new ArrayList&lt;ItemInfo&gt;(filtered);
3388      }
3389  
3390      private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3391              final UserHandleCompat user) {
3392          ItemInfoFilter filter  = new ItemInfoFilter() {
3393              @Override
3394              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3395                  if (info.user == null) {
3396                      return cn.equals(cname);
3397                  } else {
3398                      return cn.equals(cname) &amp;&amp; info.user.equals(user);
3399                  }
3400              }
3401          };
3402          return filterItemInfos(sBgItemsIdMap.values(), filter);
3403      }
3404  
3405      public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3406          if (i instanceof ShortcutInfo) {
3407              ShortcutInfo info = (ShortcutInfo) i;
3408              // We need to check for ACTION_MAIN otherwise getComponent() might
3409              // return null for some shortcuts (for instance, for shortcuts to
3410              // web pages.)
3411              Intent intent = info.intent;
3412              ComponentName name = intent.getComponent();
3413              if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3414                      Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3415                  return true;
3416              }
3417              // placeholder shortcuts get special treatment, let them through too.
3418              if (info.isPromise()) {
3419                  return true;
3420              }
3421          }
3422          return false;












3423      }
3424  
3425      /**
3426       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3427       */
3428      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3429              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3430              int titleIndex) {
3431  
3432          Bitmap icon = null;
3433          final ShortcutInfo info = new ShortcutInfo();
3434          // Non-app shortcuts are only supported for current user.
3435          info.user = UserHandleCompat.myUserHandle();
3436          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3437  
3438          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3439  
3440          info.title = c.getString(titleIndex);
3441  
3442          int iconType = c.getInt(iconTypeIndex);
3443          switch (iconType) {
3444          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3445              String packageName = c.getString(iconPackageIndex);
3446              String resourceName = c.getString(iconResourceIndex);
3447              PackageManager packageManager = context.getPackageManager();
3448              info.customIcon = false;
3449              // the resource
3450              try {
3451                  Resources resources = packageManager.getResourcesForApplication(packageName);
3452                  if (resources != null) {
3453                      final int id = resources.getIdentifier(resourceName, null, null);
3454                      icon = Utilities.createIconBitmap(
3455                              mIconCache.getFullResIcon(resources, id), context);
3456                  }
3457              } catch (Exception e) {
3458                  // drop this.  we have other places to look for icons
3459              }

3460              // the db
3461              if (icon == null) {
3462                  icon = getIconFromCursor(c, iconIndex, context);
3463              }
3464              // the fallback icon
3465              if (icon == null) {
3466                  icon = mIconCache.getDefaultIcon(info.user);
3467                  info.usingFallbackIcon = true;
3468              }
3469              break;
3470          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3471              icon = getIconFromCursor(c, iconIndex, context);
3472              if (icon == null) {
3473                  icon = mIconCache.getDefaultIcon(info.user);
3474                  info.customIcon = false;
3475                  info.usingFallbackIcon = true;
3476              } else {
3477                  info.customIcon = true;
3478              }
3479              break;
3480          default:
3481              icon = mIconCache.getDefaultIcon(info.user);
3482              info.usingFallbackIcon = true;
3483              info.customIcon = false;
3484              break;
3485          }
3486          info.setIcon(icon);
3487          return info;
3488      }
3489  
3490      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3491          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3492          final boolean debug = false;
3493          if (debug) {
3494              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3495                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3496          }
3497          byte[] data = c.getBlob(iconIndex);
3498          try {
3499              return Utilities.createIconBitmap(
3500                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3501          } catch (Exception e) {
3502              return null;
3503          }
3504      }
3505  
3506      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3507              int cellX, int cellY, boolean notify) {
3508          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3509          if (info == null) {
3510              return null;
3511          }
3512          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3513  
3514          return info;
3515      }
3516  
3517      /**
3518       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3519       */
3520      static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3521              ComponentName component) {
3522          List&lt;AppWidgetProviderInfo&gt; widgets =
3523              AppWidgetManager.getInstance(context).getInstalledProviders();
3524          for (AppWidgetProviderInfo info : widgets) {
3525              if (info.provider.equals(component)) {
3526                  return info;
3527              }
3528          }
3529          return null;
3530      }
3531  
3532      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3533          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3534          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3535          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3536  
3537          if (intent == null) {
3538              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3539              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3540              return null;
3541          }
3542  
3543          Bitmap icon = null;
3544          boolean customIcon = false;
3545          ShortcutIconResource iconResource = null;
3546  
3547          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3548              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);


3549              customIcon = true;
3550          } else {
3551              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3552              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3553                  try {
3554                      iconResource = (ShortcutIconResource) extra;
3555                      final PackageManager packageManager = context.getPackageManager();
3556                      Resources resources = packageManager.getResourcesForApplication(
3557                              iconResource.packageName);
3558                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3559                      icon = Utilities.createIconBitmap(
3560                              mIconCache.getFullResIcon(resources, id),
3561                              context);
3562                  } catch (Exception e) {
3563                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3564                  }




3565              }
3566          }
3567  
3568          final ShortcutInfo info = new ShortcutInfo();
3569  
3570          // Only support intents for current user for now. Intents sent from other
3571          // users wouldn&#x27;t get here without intent forwarding anyway.
3572          info.user = UserHandleCompat.myUserHandle();
3573          if (icon == null) {
3574              if (fallbackIcon != null) {
3575                  icon = fallbackIcon;
3576              } else {
3577                  icon = mIconCache.getDefaultIcon(info.user);
3578                  info.usingFallbackIcon = true;
3579              }
3580          }
3581          info.setIcon(icon);
3582  
3583          info.title = name;
3584          info.contentDescription = mUserManager.getBadgedLabelForUser(
3585                  info.title.toString(), info.user);
3586          info.intent = intent;
3587          info.customIcon = customIcon;
3588          info.iconResource = iconResource;
3589  
3590          return info;
3591      }
3592  
3593      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3594              int iconIndex) {
3595          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3596          if (!mAppsCanBeOnRemoveableStorage) {
3597              return false;
3598          }
3599          // If this icon doesn&#x27;t have a custom icon, check to see
3600          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3601          // we&#x27;re going to show, store what we are going to show back
3602          // into the DB.  We do this so when we&#x27;re loading, if the
3603          // package manager can&#x27;t find an icon (for example because
3604          // the app is on SD) then we can use that instead.
3605          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3606              cache.put(info, c.getBlob(iconIndex));
3607              return true;
3608          }
3609          return false;
3610      }
3611      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3612          boolean needSave = false;
3613          try {
3614              if (data != null) {
3615                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3616                  Bitmap loaded = info.getIcon(mIconCache);
3617                  needSave = !saved.sameAs(loaded);
3618              } else {
3619                  needSave = true;
3620              }
3621          } catch (Exception e) {
3622              needSave = true;
3623          }
3624          if (needSave) {
3625              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3626              // This is slower than is ideal, but this only happens once
3627              // or when the app is updated with a new icon.
3628              updateItemInDatabase(context, info);
3629          }
3630      }
3631  
3632      /**
3633       * Return an existing FolderInfo object if we have encountered this ID previously,
3634       * or make a new one.
3635       */
3636      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3637          // See if a placeholder was created for us already
3638          FolderInfo folderInfo = folders.get(id);
3639          if (folderInfo == null) {
3640              // No placeholder -- create a new instance
3641              folderInfo = new FolderInfo();
3642              folders.put(id, folderInfo);
3643          }
3644          return folderInfo;
3645      }
3646  
3647      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3648          final Collator collator = Collator.getInstance();
3649          return new Comparator&lt;AppInfo&gt;() {
3650              public final int compare(AppInfo a, AppInfo b) {
3651                  if (a.user.equals(b.user)) {
3652                      int result = collator.compare(a.title.toString().trim(),
3653                              b.title.toString().trim());
3654                      if (result == 0) {
3655                          result = a.componentName.compareTo(b.componentName);
3656                      }
3657                      return result;
3658                  } else {
3659                      // TODO Need to figure out rules for sorting
3660                      // profiles, this puts work second.
3661                      return a.user.toString().compareTo(b.user.toString());
3662                  }
3663              }
3664          };
3665      }
3666      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3667              = new Comparator&lt;AppInfo&gt;() {
3668          public final int compare(AppInfo a, AppInfo b) {
3669              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3670              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3671              return 0;
3672          }
3673      };
3674      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3675          if (info.activityInfo != null) {
3676              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3677          } else {
3678              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3679          }
3680      }
3681      public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3682          private Collator mCollator;
3683          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3684          ShortcutNameComparator(PackageManager pm) {
3685              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3686              mCollator = Collator.getInstance();
3687          }
3688          ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3689              mLabelCache = labelCache;
3690              mCollator = Collator.getInstance();
3691          }
3692          public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3693              String labelA, labelB;
3694              ComponentName keyA = a.getComponentName();
3695              ComponentName keyB = b.getComponentName();
3696              if (mLabelCache.containsKey(keyA)) {
3697                  labelA = mLabelCache.get(keyA).toString();
3698              } else {
3699                  labelA = a.getLabel().toString().trim();
3700  
3701                  mLabelCache.put(keyA, labelA);
3702              }
3703              if (mLabelCache.containsKey(keyB)) {
3704                  labelB = mLabelCache.get(keyB).toString();
3705              } else {
3706                  labelB = b.getLabel().toString().trim();
3707  
3708                  mLabelCache.put(keyB, labelB);
3709              }
3710              return mCollator.compare(labelA, labelB);
3711          }
3712      };
3713      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3714          private final AppWidgetManagerCompat mManager;
3715          private final PackageManager mPackageManager;
3716          private final HashMap&lt;Object, String&gt; mLabelCache;
3717          private final Collator mCollator;
3718  
3719          WidgetAndShortcutNameComparator(Context context) {
3720              mManager = AppWidgetManagerCompat.getInstance(context);
3721              mPackageManager = context.getPackageManager();
3722              mLabelCache = new HashMap&lt;Object, String&gt;();
3723              mCollator = Collator.getInstance();
3724          }
3725          public final int compare(Object a, Object b) {
3726              String labelA, labelB;
3727              if (mLabelCache.containsKey(a)) {
3728                  labelA = mLabelCache.get(a);
3729              } else {
3730                  labelA = (a instanceof AppWidgetProviderInfo)
3731                          ? mManager.loadLabel((AppWidgetProviderInfo) a)
3732                          : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3733                  mLabelCache.put(a, labelA);
3734              }
3735              if (mLabelCache.containsKey(b)) {
3736                  labelB = mLabelCache.get(b);
3737              } else {
3738                  labelB = (b instanceof AppWidgetProviderInfo)
3739                          ? mManager.loadLabel((AppWidgetProviderInfo) b)
3740                          : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3741                  mLabelCache.put(b, labelB);
3742              }
3743              return mCollator.compare(labelA, labelB);
3744          }
3745      };
3746  
3747      static boolean isValidProvider(AppWidgetProviderInfo provider) {
3748          return (provider != null) &amp;&amp; (provider.provider != null)
3749                  &amp;&amp; (provider.provider.getPackageName() != null);
3750      }
3751  
3752      public void dumpState() {
3753          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3754          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3755          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3756          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3757          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3758          if (mLoaderTask != null) {
3759              mLoaderTask.dumpState();
3760          } else {
3761              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3762          }
3763      }
3764  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            