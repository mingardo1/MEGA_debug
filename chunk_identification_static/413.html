<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>413</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    413
                    <a href="412.html">prev</a>
                    <a href="414.html">next</a>
                    <a href="413_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_e408d12c730a7397701e361d52cac823c1694111_cassandra/cassandra-side/cassandra-all-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAllReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111:cassandra/cassandra-side/cassandra-all-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAllReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^1:cassandra/cassandra-side/cassandra-all-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAllReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e408d12c730a7397701e361d52cac823c1694111^2:cassandra/cassandra-side/cassandra-all-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAllReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;09a8d23c2b8c9e6955f6f68bed4a2fe16cc7fbd3:cassandra/cassandra-side/cassandra-all-side/src/main/java/com/dtstack/flink/sql/side/cassandra/CassandraAllReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[b], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.cassandra;
  20 
  21 import com.datastax.driver.core.*;
  22 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  23 import com.datastax.driver.core.policies.RetryPolicy;
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.dtstack.flink.sql.side.BaseAllReqRow;
  26 import com.dtstack.flink.sql.side.FieldInfo;
  27 import com.dtstack.flink.sql.side.JoinInfo;
  28 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  29 import com.dtstack.flink.sql.util.RowDataComplete;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import org.apache.calcite.sql.JoinType;
  33 import org.apache.commons.collections.CollectionUtils;
  34 import org.apache.commons.lang3.StringUtils;
  35 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  36 import org.apache.flink.table.dataformat.BaseRow;
  37 import org.apache.flink.types.Row;
  38 import org.apache.flink.util.Collector;
  39 import org.slf4j.Logger;
  40 import org.slf4j.LoggerFactory;
  41 
  42 import java.net.InetAddress;
  43 import java.sql.SQLException;
  44 import java.util.ArrayList;
  45 import java.util.Calendar;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.concurrent.atomic.AtomicReference;
  49 
  50 /**
  51  * Reason:
  52  * Date: 2018/11/22
  53  *
  54  * @author xuqianjin
  55  */
  56 public class CassandraAllReqRow extends BaseAllReqRow {
  57 
  58     private static final long serialVersionUID = 54015343561288219L;
  59 
  60     private static final Logger LOG = LoggerFactory.getLogger(CassandraAllReqRow.class);
  61 
  62     private static final int CONN_RETRY_NUM = 3;
  63 
  64     private static final int FETCH_SIZE = 1000;
  65 
  66     private transient Cluster cluster;
  67     private transient Session session = null;
  68 
  69     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  70 
<abbr title="  71     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  71     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoLis🔵</abbr>
<abbr title="  72         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  72         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFie🔵</abbr>
  73     }
  74 
  75     @Override
  76 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  80         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  81             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  82             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  83             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  84         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  85 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  86         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  87             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  88                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  89             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  90                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  91             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  92         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  93 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  94         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  95     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  96 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  97     @Override</span>
  98 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 100     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {"> 100     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoLis🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 101         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));"> 101         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFie🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 102     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 104     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 110             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 110             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 112             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 112             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114                 //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 115                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());"> 115                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119         }</span>
 120 =======
 121 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 122     protected void initCache() throws SQLException {
 123         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 124         cacheRef.set(newCache);
 125         loadData(newCache);
 126     }
 127 
 128     @Override
 129     protected void reloadCache() {
 130         //reload cacheRef and replace to old cacheRef
 131         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 132         try {
 133             loadData(newCache);
 134         } catch (SQLException e) {
 135             LOG.error(&quot;&quot;, e);
 136         }
 137 
 138         cacheRef.set(newCache);
 139         LOG.info(&quot;----- cassandra all cacheRef reload end:{}&quot;, Calendar.getInstance());
 140     }
 141 
 142 
 143     @Override
 144     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 145         List&lt;Object&gt; inputParams = Lists.newArrayList();
 146         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 147             Object equalObj = input.getField(conValIndex);
 148             if (equalObj == null) {
 149                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 150                     Row row = fillData(input, null);
 151                     RowDataComplete.collectRow(out, row);
 152                 }
 153                 return;
 154             }
 155 
 156             inputParams.add(equalObj);
 157         }
 158 
 159         String key = buildKey(inputParams);
 160         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 161         if (CollectionUtils.isEmpty(cacheList)) {
 162             if (sideInfo.getJoinType() == JoinType.LEFT) {
 163                 Row row = fillData(input, null);
 164                 RowDataComplete.collectRow(out, row);
 165             } else {
 166                 return;
 167             }
 168 
 169             return;
 170         }
 171 
 172         for (Map&lt;String, Object&gt; one : cacheList) {
 173             Row row = fillData(input, one);
 174             RowDataComplete.collectRow(out, row);
 175         }
 176 
 177     }
 178 
 179     private String buildKey(List&lt;Object&gt; equalValList) {
 180         StringBuilder sb = new StringBuilder(&quot;&quot;);
 181         for (Object equalVal : equalValList) {
 182             sb.append(equalVal).append(&quot;_&quot;);
 183         }
 184 
 185         return sb.toString();
 186     }
 187 
 188     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 189         StringBuilder sb = new StringBuilder(&quot;&quot;);
 190         for (String equalField : equalFieldList) {
 191             sb.append(val.get(equalField)).append(&quot;_&quot;);
 192         }
 193 
 194         return sb.toString();
 195     }
 196 
 197     private Session getConn(CassandraSideTableInfo tableInfo) {
 198         try {
 199             if (session == null) {
 200                 QueryOptions queryOptions = new QueryOptions();
 201                 //The default consistency level for queries: ConsistencyLevel.TWO.
 202                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 203                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 203                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : 🔵</abbr>
<abbr title=" 204                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 204                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tabl🔵</abbr>
<abbr title=" 205                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 205                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : ta🔵</abbr>
<abbr title=" 206                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();"> 206                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQue🔵</abbr>
<abbr title=" 207                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 207                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
<abbr title=" 208                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 208                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tabl🔵</abbr>
<abbr title=" 209                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 209                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
 210                 Integer cassandraPort = 0;
 211                 String address = tableInfo.getAddress();
 212                 String userName = tableInfo.getUserName();
 213                 String password = tableInfo.getPassword();
 214                 String database = tableInfo.getDatabase();
 215 
 216                 ArrayList serversList = new ArrayList();
 217                 //Read timeout or connection timeout Settings
 218                 SocketOptions so = new SocketOptions()
 219                         .setReadTimeoutMillis(readTimeoutMillis)
 220                         .setConnectTimeoutMillis(connectTimeoutMillis);
 221 
 222                 //The cluster USES hostdistance.local in the same machine room
 223                 //Hostdistance. REMOTE is used for different machine rooms
 224                 //Ignore use HostDistance. IGNORED
 225                 PoolingOptions poolingOptions = new PoolingOptions()
 226                         //Each connection allows a maximum of 64 concurrent requests
 227                         .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 228                         //Have at least two connections to each machine in the cluster
 229                         .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 230                         //There are up to eight connections to each machine in the cluster
 231                         .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 232                         .setMaxQueueSize(maxQueueSize)
 233                         .setPoolTimeoutMillis(poolTimeoutMillis);
 234                 //重试策略
 235                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 236 
 237                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 238                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 239                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 240                 }
 241 
 242                 if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
<abbr title=" 243                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 243                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 244                             .withPort(cassandraPort)
 245                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 246                             .withQueryOptions(queryOptions).build();
 247                 } else {
<abbr title=" 248                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 248                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 249                             .withPort(cassandraPort)
 250                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 251                             .withCredentials(userName, password)
 252                             .withQueryOptions(queryOptions).build();
 253                 }
 254                 // 建立连接 连接已存在的键空间
 255                 session = cluster.connect(database);
 256                 LOG.info(&quot;connect cassandra is successed!&quot;);
 257             }
 258         } catch (Exception e) {
 259             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 260         }
 261         return session;
 262     }
 263 
 264 
 265     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 266         CassandraSideTableInfo tableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
 267         Session session = null;
 268 
 269         try {
 270             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 271                 try {
 272                     session = getConn(tableInfo);
 273                     break;
 274                 } catch (Exception e) {
 275                     if (i == CONN_RETRY_NUM - 1) {
 276                         throw new RuntimeException(&quot;&quot;, e);
 277                     }
 278                     try {
<abbr title=" 279                         String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()"> 279                         String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.🔵</abbr>
 280                                 + &quot;,pwd:&quot; + tableInfo.getPassword();
 281                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 282                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 283                     } catch (InterruptedException e1) {
 284                         LOG.error(&quot;&quot;, e1);
 285                     }
 286                 }
 287 
 288             }
 289 
 290             //load data from table
 291             String sql = sideInfo.getSqlCondition() + &quot; limit &quot; + FETCH_SIZE;
 292             ResultSet resultSet = session.execute(sql);
 293             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 294             for (com.datastax.driver.core.Row row : resultSet) {
 295                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 296                 for (String fieldName : sideFieldNames) {
 297                     oneRow.put(fieldName.trim(), row.getObject(fieldName.trim()));
 298                 }
 299                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 300                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 300                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 301                 list.add(oneRow);
 302             }
 303         } catch (Exception e) {
 304             LOG.error(&quot;&quot;, e);
 305         } finally {
 306             try {
 307                 if (session != null) {
 308                     session.close();
 309                 }
 310             } catch (Exception e) {
 311                 LOG.error(&quot;Error while closing session.&quot;, e);
 312             }
 313             try {
 314                 if (cluster != null) {
 315                     cluster.close();
 316                 }
 317             } catch (Exception e) {
 318                 LOG.error(&quot;Error while closing cluster.&quot;, e);
 319             }
 320         }
 321     }
 322 }
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.cassandra;
  20 
  21 import com.datastax.driver.core.*;
  22 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  23 import org.apache.flink.table.dataformat.BaseRow;
  24 import org.apache.flink.types.Row;
  25 import org.apache.flink.util.Collector;
  26 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  27 import com.datastax.driver.core.policies.RetryPolicy;
  28 import com.dtstack.flink.sql.side.BaseAllReqRow;
  29 import com.dtstack.flink.sql.side.FieldInfo;
  30 import com.dtstack.flink.sql.side.JoinInfo;
  31 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  32 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  33 import com.dtstack.flink.sql.util.RowDataComplete;
  34 import com.google.common.collect.Lists;
  35 import com.google.common.collect.Maps;
  36 import org.apache.calcite.sql.JoinType;
  37 import org.apache.commons.collections.CollectionUtils;
  38 import org.apache.commons.lang3.StringUtils;
  39 import org.slf4j.Logger;
  40 import org.slf4j.LoggerFactory;
  41 
  42 import java.net.InetAddress;
  43 import java.sql.SQLException;
  44 import java.util.ArrayList;
  45 import java.util.Calendar;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.concurrent.atomic.AtomicReference;
  49 
  50 /**
  51  * Reason:
  52  * Date: 2018/11/22
  53  *
  54  * @author xuqianjin
  55  */
  56 public class CassandraAllReqRow extends BaseAllReqRow {
  57 
  58     private static final long serialVersionUID = 54015343561288219L;
  59 
  60     private static final Logger LOG = LoggerFactory.getLogger(CassandraAllReqRow.class);
  61 
  62     private static final int CONN_RETRY_NUM = 3;
  63 
  64     private static final int FETCH_SIZE = 1000;
  65 
  66     private transient Cluster cluster;
  67     private transient Session session = null;
  68 
  69     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  70 
<abbr title="  71     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  71     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoLis🔵</abbr>
<abbr title="  72         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  72         super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFie🔵</abbr>
  73     }
  74 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  75 @Override</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  76     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  78         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  79         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  80             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  81             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  82             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  83         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  84 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  85         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  86             if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  87                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  88             } else {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  89                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  90             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  91         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  92 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  93         return row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  94     }</span>
  95 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  97     public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  98         Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  99         Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 100         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 101             Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 102             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 102             boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRo🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 103 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 104             //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 104             //Type information for indicating event or processing time. However, it behaves like a regula🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 105             if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106                 //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 107                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());"> 107                 obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime())🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110             row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113         for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 114             if (cacheInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 115                 row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 116             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 117                 row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 118             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 119         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121         return row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122     }</span>
 123 =======
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 125 
 126 
 127     @Override
 128     protected void initCache() throws SQLException {
 129         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 130         cacheRef.set(newCache);
 131         loadData(newCache);
 132     }
 133 
 134     @Override
 135     protected void reloadCache() {
 136         //reload cacheRef and replace to old cacheRef
 137         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 138         try {
 139             loadData(newCache);
 140         } catch (SQLException e) {
 141             LOG.error(&quot;&quot;, e);
 142         }
 143 
 144         cacheRef.set(newCache);
 145         LOG.info(&quot;----- cassandra all cacheRef reload end:{}&quot;, Calendar.getInstance());
 146     }
 147 
 148 
 149     @Override
 150     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
 151         List&lt;Object&gt; inputParams = Lists.newArrayList();
 152         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 153             Object equalObj = input.getField(conValIndex);
 154             if (equalObj == null) {
 155                 if(sideInfo.getJoinType() == JoinType.LEFT){
 156                     Row row = fillData(input, null);
 157                     RowDataComplete.collectRow(out, row);
 158                 }
 159                 return;
 160             }
 161 
 162             inputParams.add(equalObj);
 163         }
 164 
 165         String key = buildKey(inputParams);
 166         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 167         if (CollectionUtils.isEmpty(cacheList)) {
 168             if (sideInfo.getJoinType() == JoinType.LEFT) {
 169                 Row row = fillData(input, null);
 170                 RowDataComplete.collectRow(out, row);
 171             } else {
 172                 return;
 173             }
 174 
 175             return;
 176         }
 177 
 178         for (Map&lt;String, Object&gt; one : cacheList) {
 179             Row row = fillData(input, one);
 180             RowDataComplete.collectRow(out, row);
 181         }
 182 
 183     }
 184 
 185     private String buildKey(List&lt;Object&gt; equalValList) {
 186         StringBuilder sb = new StringBuilder(&quot;&quot;);
 187         for (Object equalVal : equalValList) {
 188             sb.append(equalVal).append(&quot;_&quot;);
 189         }
 190 
 191         return sb.toString();
 192     }
 193 
 194     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 195         StringBuilder sb = new StringBuilder(&quot;&quot;);
 196         for (String equalField : equalFieldList) {
 197             sb.append(val.get(equalField)).append(&quot;_&quot;);
 198         }
 199 
 200         return sb.toString();
 201     }
 202 
 203     private Session getConn(CassandraSideTableInfo tableInfo) {
 204         try {
 205             if (session == null) {
 206                 QueryOptions queryOptions = new QueryOptions();
 207                 //The default consistency level for queries: ConsistencyLevel.TWO.
 208                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 209                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 209                 Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : 🔵</abbr>
<abbr title=" 210                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 210                 Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tabl🔵</abbr>
<abbr title=" 211                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 211                 Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : ta🔵</abbr>
<abbr title=" 212                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();"> 212                 Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQue🔵</abbr>
<abbr title=" 213                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 213                 Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
<abbr title=" 214                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 214                 Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tabl🔵</abbr>
<abbr title=" 215                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 215                 Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.🔵</abbr>
 216                 Integer cassandraPort = 0;
 217                 String address = tableInfo.getAddress();
 218                 String userName = tableInfo.getUserName();
 219                 String password = tableInfo.getPassword();
 220                 String database = tableInfo.getDatabase();
 221 
 222                 ArrayList serversList = new ArrayList();
 223                 //Read timeout or connection timeout Settings
 224                 SocketOptions so = new SocketOptions()
 225                         .setReadTimeoutMillis(readTimeoutMillis)
 226                         .setConnectTimeoutMillis(connectTimeoutMillis);
 227 
 228                 //The cluster USES hostdistance.local in the same machine room
 229                 //Hostdistance. REMOTE is used for different machine rooms
 230                 //Ignore use HostDistance. IGNORED
 231                 PoolingOptions poolingOptions = new PoolingOptions()
 232                         //Each connection allows a maximum of 64 concurrent requests
 233                         .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 234                         //Have at least two connections to each machine in the cluster
 235                         .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 236                         //There are up to eight connections to each machine in the cluster
 237                         .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 238                         .setMaxQueueSize(maxQueueSize)
 239                         .setPoolTimeoutMillis(poolTimeoutMillis);
 240                 //重试策略
 241                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 242 
 243                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 244                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 245                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 246                 }
 247 
 248                 if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
<abbr title=" 249                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 249                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 250                             .withPort(cassandraPort)
 251                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 252                             .withQueryOptions(queryOptions).build();
 253                 } else {
<abbr title=" 254                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)"> 254                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 255                             .withPort(cassandraPort)
 256                             .withPoolingOptions(poolingOptions).withSocketOptions(so)
 257                             .withCredentials(userName, password)
 258                             .withQueryOptions(queryOptions).build();
 259                 }
 260                 // 建立连接 连接已存在的键空间
 261                 session = cluster.connect(database);
 262                 LOG.info(&quot;connect cassandra is successed!&quot;);
 263             }
 264         } catch (Exception e) {
 265             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 266         }
 267         return session;
 268     }
 269 
 270 
 271     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 272         CassandraSideTableInfo tableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
 273         Session session = null;
 274 
 275         try {
 276             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 277                 try {
 278                     session = getConn(tableInfo);
 279                     break;
 280                 } catch (Exception e) {
 281                     if (i == CONN_RETRY_NUM - 1) {
 282                         throw new RuntimeException(&quot;&quot;, e);
 283                     }
 284                     try {
<abbr title=" 285                         String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()"> 285                         String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.🔵</abbr>
 286                                 + &quot;,pwd:&quot; + tableInfo.getPassword();
 287                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 288                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 289                     } catch (InterruptedException e1) {
 290                         LOG.error(&quot;&quot;, e1);
 291                     }
 292                 }
 293 
 294             }
 295 
 296             //load data from table
 297             String sql = sideInfo.getSqlCondition() + &quot; limit &quot; + FETCH_SIZE;
 298             ResultSet resultSet = session.execute(sql);
 299             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 300             for (com.datastax.driver.core.Row row : resultSet) {
 301                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 302                 for (String fieldName : sideFieldNames) {
 303                     oneRow.put(fieldName.trim(), row.getObject(fieldName.trim()));
 304                 }
 305                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 306                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());"> 306                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArray🔵</abbr>
 307                 list.add(oneRow);
 308             }
 309         } catch (Exception e) {
 310             LOG.error(&quot;&quot;, e);
 311         } finally {
 312             try {
 313                 if (session != null) {
 314                     session.close();
 315                 }
 316             } catch (Exception e) {
 317                 LOG.error(&quot;Error while closing session.&quot;, e);
 318             }
 319             try {
 320                 if (cluster != null) {
 321                     cluster.close();
 322                 }
 323             } catch (Exception e) {
 324                 LOG.error(&quot;Error while closing cluster.&quot;, e);
 325             }
 326         }
 327     }
 328 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.cassandra;
  19 
  20 import com.datastax.driver.core.*;
  21 import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  22 import com.datastax.driver.core.policies.RetryPolicy;
  23 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  24 import com.dtstack.flink.sql.side.BaseAllReqRow;
  25 import com.dtstack.flink.sql.side.FieldInfo;
  26 import com.dtstack.flink.sql.side.JoinInfo;
  27 import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
  28 import com.dtstack.flink.sql.util.RowDataComplete;
  29 import com.google.common.collect.Lists;
  30 import com.google.common.collect.Maps;
  31 import java.net.InetAddress;
  32 import java.sql.SQLException;
  33 import java.util.ArrayList;
  34 import java.util.Calendar;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.concurrent.atomic.AtomicReference;
  38 import org.apache.calcite.sql.JoinType;
  39 import org.apache.commons.collections.CollectionUtils;
  40 import org.apache.commons.lang3.StringUtils;
  41 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  42 import org.apache.flink.table.dataformat.BaseRow;
  43 import org.apache.flink.types.Row;
  44 import org.apache.flink.util.Collector;
  45 import org.slf4j.Logger;
  46 import org.slf4j.LoggerFactory;
  47 
  48 
  49 /**
  50  * Reason:
  51  * Date: 2018/11/22
  52  *
  53  * @author xuqianjin
  54  */
  55 public class CassandraAllReqRow extends BaseAllReqRow {
  56     private static final long serialVersionUID = 54015343561288219L;
  57 
  58     private static final Logger LOG = LoggerFactory.getLogger(CassandraAllReqRow.class);
  59 
  60     private static final int CONN_RETRY_NUM = 3;
  61 
  62     private static final int FETCH_SIZE = 1000;
  63 
  64     private transient Cluster cluster;
  65 
  66     private transient Session session = null;
  67 
  68     private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  69 
<abbr title="  70     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  70     public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoLis🔵</abbr>
  71         super(new CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  72     }
  73 
  74     @Override
  75     protected void initCache() throws SQLException {
  76         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  77         cacheRef.set(newCache);
  78         loadData(newCache);
  79     }
  80 
  81     @Override
  82     protected void reloadCache() {
  83         //reload cacheRef and replace to old cacheRef
  84         Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
  85         try {
  86             loadData(newCache);
  87         } catch (SQLException e) {
  88             LOG.error(&quot;&quot;, e);
  89         }
  90 
  91         cacheRef.set(newCache);
  92         LOG.info(&quot;----- cassandra all cacheRef reload end:{}&quot;, Calendar.getInstance());
  93     }
  94 
  95     @Override
  96     public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {
  97         List&lt;Object&gt; inputParams = Lists.newArrayList();
  98         for (Integer conValIndex : sideInfo.getEqualValIndex()) {
  99             Object equalObj = input.getField(conValIndex);
 100             if (equalObj == null) {
 101                 if (sideInfo.getJoinType() == JoinType.LEFT) {
 102                     Row row = fillData(input, null);
 103                     RowDataComplete.collectRow(out, row);
 104                 }
 105                 return;
 106             }
 107             inputParams.add(equalObj);
 108         }
 109         String key = buildKey(inputParams);
 110         List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 111         if (CollectionUtils.isEmpty(cacheList)) {
 112             if (sideInfo.getJoinType() == JoinType.LEFT) {
 113                 Row row = fillData(input, null);
 114                 RowDataComplete.collectRow(out, row);
 115             } else {
 116                 return;
 117             }
 118             return;
 119         }
 120         for (Map&lt;String, Object&gt; one : cacheList) {
 121             Row row = fillData(input, one);
 122             RowDataComplete.collectRow(out, row);
 123         }
 124     }
 125 
 126     private String buildKey(List&lt;Object&gt; equalValList) {
 127         StringBuilder sb = new StringBuilder(&quot;&quot;);
 128         for (Object equalVal : equalValList) {
 129             sb.append(equalVal).append(&quot;_&quot;);
 130         }
 131 
 132         return sb.toString();
 133     }
 134 
 135     private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 136         StringBuilder sb = new StringBuilder(&quot;&quot;);
 137         for (String equalField : equalFieldList) {
 138             sb.append(val.get(equalField)).append(&quot;_&quot;);
 139         }
 140 
 141         return sb.toString();
 142     }
 143 
 144     private Session getConn(CassandraSideTableInfo tableInfo) {
 145         try {
 146             if (session == null) {
 147                 QueryOptions queryOptions = new QueryOptions();
 148                 //The default consistency level for queries: ConsistencyLevel.TWO.
 149                 queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 150                 Integer maxRequestsPerConnection = (tableInfo.getMaxRequestsPerConnection() == null) ? 1 : tableInfo.getMaxRequestsPerConnection();"> 150                 Integer maxRequestsPerConnection = (tableInfo.getMaxRequestsPerConnection() == null) ? 1 🔵</abbr>
<abbr title=" 151                 Integer coreConnectionsPerHost = (tableInfo.getCoreConnectionsPerHost() == null) ? 8 : tableInfo.getCoreConnectionsPerHost();"> 151                 Integer coreConnectionsPerHost = (tableInfo.getCoreConnectionsPerHost() == null) ? 8 : ta🔵</abbr>
<abbr title=" 152                 Integer maxConnectionsPerHost = (tableInfo.getMaxConnectionsPerHost() == null) ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 152                 Integer maxConnectionsPerHost = (tableInfo.getMaxConnectionsPerHost() == null) ? 32768 : 🔵</abbr>
<abbr title=" 153                 Integer maxQueueSize = (tableInfo.getMaxQueueSize() == null) ? 100000 : tableInfo.getMaxQueueSize();"> 153                 Integer maxQueueSize = (tableInfo.getMaxQueueSize() == null) ? 100000 : tableInfo.getMaxQ🔵</abbr>
<abbr title=" 154                 Integer readTimeoutMillis = (tableInfo.getReadTimeoutMillis() == null) ? 60000 : tableInfo.getReadTimeoutMillis();"> 154                 Integer readTimeoutMillis = (tableInfo.getReadTimeoutMillis() == null) ? 60000 : tableInf🔵</abbr>
<abbr title=" 155                 Integer connectTimeoutMillis = (tableInfo.getConnectTimeoutMillis() == null) ? 60000 : tableInfo.getConnectTimeoutMillis();"> 155                 Integer connectTimeoutMillis = (tableInfo.getConnectTimeoutMillis() == null) ? 60000 : ta🔵</abbr>
<abbr title=" 156                 Integer poolTimeoutMillis = (tableInfo.getPoolTimeoutMillis() == null) ? 60000 : tableInfo.getPoolTimeoutMillis();"> 156                 Integer poolTimeoutMillis = (tableInfo.getPoolTimeoutMillis() == null) ? 60000 : tableInf🔵</abbr>
 157                 Integer cassandraPort = 0;
 158                 String address = tableInfo.getAddress();
 159                 String userName = tableInfo.getUserName();
 160                 String password = tableInfo.getPassword();
 161                 String database = tableInfo.getDatabase();
 162                 ArrayList serversList = new ArrayList();
 163                 //Read timeout or connection timeout Settings
<abbr title=" 164                 SocketOptions so = new SocketOptions().setReadTimeoutMillis(readTimeoutMillis).setConnectTimeoutMillis(connectTimeoutMillis);"> 164                 SocketOptions so = new SocketOptions().setReadTimeoutMillis(readTimeoutMillis).setConnect🔵</abbr>
 165                 //The cluster USES hostdistance.local in the same machine room
 166                 //Hostdistance. REMOTE is used for different machine rooms
 167                 //Ignore use HostDistance. IGNORED
<abbr title=" 168                 PoolingOptions poolingOptions = //There are up to eight connections to each machine in the cluster"> 168                 PoolingOptions poolingOptions = //There are up to eight connections to each machine in th🔵</abbr>
 169                         //Have at least two connections to each machine in the cluster
 170                         //Each connection allows a maximum of 64 concurrent requests
<abbr title=" 171                 new PoolingOptions().setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection).setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost).setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost).setMaxQueueSize(maxQueueSize).setPoolTimeoutMillis(poolTimeoutMillis);"> 171                 new PoolingOptions().setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnec🔵</abbr>
 172                 // 重试策略
 173                 RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 174                 for (String server : StringUtils.split(address, &quot;,&quot;)) {
 175                     cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 176                     serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 177                 }
<abbr title=" 178                 if ((((userName == null) || userName.isEmpty()) || (password == null)) || password.isEmpty()) {"> 178                 if ((((userName == null) || userName.isEmpty()) || (password == null)) || password.isEmpt🔵</abbr>
<abbr title=" 179                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy).withPort(cassandraPort).withPoolingOptions(poolingOptions).withSocketOptions(so).withQueryOptions(queryOptions).build();"> 179                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 180                 } else {
<abbr title=" 181                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy).withPort(cassandraPort).withPoolingOptions(poolingOptions).withSocketOptions(so).withCredentials(userName, password).withQueryOptions(queryOptions).build();"> 181                     cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy🔵</abbr>
 182                 }
 183                 // 建立连接 连接已存在的键空间
 184                 session = cluster.connect(database);
 185                 LOG.info(&quot;connect cassandra is successed!&quot;);
 186             }
 187         } catch (java.lang.Exception e) {
 188             LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 189         }
 190         return session;
 191     }
 192 
 193     private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 194         CassandraSideTableInfo tableInfo = ((CassandraSideTableInfo) (sideInfo.getSideTableInfo()));
 195         Session session = null;
 196         try {
 197             for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 198                 try {
 199                     session = getConn(tableInfo);
 200                     break;
 201                 } catch (java.lang.Exception e) {
 202                     if (i == (CONN_RETRY_NUM - 1)) {
 203                         throw new RuntimeException(&quot;&quot;, e);
 204                     }
 205                     try {
<abbr title=" 206                         String connInfo = ((((&quot;address:&quot; + tableInfo.getAddress()) + &quot;;userName:&quot;) + tableInfo.getUserName()) + &quot;,pwd:&quot;) + tableInfo.getPassword();"> 206                         String connInfo = ((((&quot;address:&quot; + tableInfo.getAddress()) + &quot;;userName:&quot;) + tabl🔵</abbr>
 207                         LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 208                         Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 209                     } catch (java.lang.InterruptedException e1) {
 210                         LOG.error(&quot;&quot;, e1);
 211                     }
 212                 }
 213             }
 214             // load data from table
 215             String sql = (sideInfo.getSqlCondition() + &quot; limit &quot;) + FETCH_SIZE;
 216             ResultSet resultSet = session.execute(sql);
 217             String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 218             for (Row row : resultSet) {
 219                 Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 220                 for (String fieldName : sideFieldNames) {
 221                     oneRow.put(fieldName.trim(), row.getObject(fieldName.trim()));
 222                 }
 223                 String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
<abbr title=" 224                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newArrayList());"> 224                 List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, ( key) -&gt; Lists.newAr🔵</abbr>
 225                 list.add(oneRow);
 226             }
 227         } catch (java.lang.Exception e) {
 228             LOG.error(&quot;&quot;, e);
 229         } finally {
 230             try {
 231                 if (session != null) {
 232                     session.close();
 233                 }
 234             } catch (java.lang.Exception e) {
 235                 LOG.error(&quot;Error while closing session.&quot;, e);
 236             }
 237             try {
 238                 if (cluster != null) {
 239                     cluster.close();
 240                 }
 241             } catch (java.lang.Exception e) {
 242                 LOG.error(&quot;Error while closing cluster.&quot;, e);
 243             }
 244         }
 245     }
 246 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.cassandra;
  20  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import org.apache.flink.util.Collector;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import com.datastax.driver.core.Cluster;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import com.datastax.driver.core.ConsistencyLevel;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import com.datastax.driver.core.HostDistance;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import com.datastax.driver.core.PoolingOptions;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import com.datastax.driver.core.QueryOptions;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import com.datastax.driver.core.ResultSet;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import com.datastax.driver.core.Session;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import com.datastax.driver.core.SocketOptions;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import com.datastax.driver.core.*;</span>
  36  import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  37  import com.datastax.driver.core.policies.RetryPolicy;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
  39  import com.dtstack.flink.sql.side.BaseAllReqRow;
  40  import com.dtstack.flink.sql.side.FieldInfo;
  41  import com.dtstack.flink.sql.side.JoinInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
  43  import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import com.dtstack.flink.sql.util.RowDataComplete;</span>
  45  import com.google.common.collect.Lists;
  46  import com.google.common.collect.Maps;
  47  import org.apache.calcite.sql.JoinType;
  48  import org.apache.commons.collections.CollectionUtils;
  49  import org.apache.commons.lang3.StringUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import org.apache.flink.table.dataformat.BaseRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import org.apache.flink.util.Collector;</span>
  54  import org.slf4j.Logger;
  55  import org.slf4j.LoggerFactory;
  56  
  57  import java.net.InetAddress;
  58  import java.sql.SQLException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import java.sql.Timestamp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import java.util.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import java.util.ArrayList;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import java.util.Calendar;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.util.List;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import java.util.Map;</span>
  65  import java.util.concurrent.atomic.AtomicReference;
  66  
  67  /**
  68   * Reason:
  69   * Date: 2018/11/22
  70   *
  71   * @author xuqianjin
  72   */
  73  public class CassandraAllReqRow extends BaseAllReqRow {
  74  
  75      private static final long serialVersionUID = 54015343561288219L;
  76  
  77      private static final Logger LOG = LoggerFactory.getLogger(CassandraAllReqRow.class);
  78  
  79      private static final int CONN_RETRY_NUM = 3;
  80  
  81      private static final int FETCH_SIZE = 1000;
  82  
  83      private transient Cluster cluster;
  84      private transient Session session = null;
  85  
  86      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  87  
<abbr title="  88      public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  88      public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abstra🔵</abbr>
<abbr title="  89          super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  89          super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoLis🔵</abbr>
  90      }
  91  
  92      @Override
  93      public Row fillData(Row input, Object sideInput) {
  94          Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;
  95          Row row = new Row(sideInfo.getOutFieldInfoList().size());
  96          for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
  97              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  98 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  98 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 100 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long."> 100 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -                //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -                obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
 107              row.setField(entry.getKey(), obj);
 108          }
 109  
 110          for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {
 111              if (cacheInfo == null) {
 112                  row.setField(entry.getKey(), null);
 113              } else {
 114                  row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));
 115              }
 116          }
 117  
 118          return row;
 119      }
 120  
 121      @Override
 122      protected void initCache() throws SQLException {
 123          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 124          cacheRef.set(newCache);
 125          loadData(newCache);
 126      }
 127  
 128      @Override
 129      protected void reloadCache() {
 130          //reload cacheRef and replace to old cacheRef
 131          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 132          try {
 133              loadData(newCache);
 134          } catch (SQLException e) {
 135              LOG.error(&quot;&quot;, e);
 136          }
 137  
 138          cacheRef.set(newCache);
 139          LOG.info(&quot;----- cassandra all cacheRef reload end:{}&quot;, Calendar.getInstance());
 140      }
 141  
 142  
 143      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -    public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +    public void flatMap(Row input, Collector&lt;BaseRow&gt; out) throws Exception {</span>
 146          List&lt;Object&gt; inputParams = Lists.newArrayList();
 147          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -            Object equalObj = input.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +            Object equalObj = input.getField(conValIndex);</span>
 150              if (equalObj == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                if(sideInfo.getJoinType() == JoinType.LEFT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -                    Row data = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -                    out.collect(new CRow(data, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +                if (sideInfo.getJoinType() == JoinType.LEFT) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +                    Row row = fillData(input, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +                    RowDataComplete.collectRow(out, row);</span>
 157                  }
 158                  return;
 159              }
 160  
 161              inputParams.add(equalObj);
 162          }
 163  
 164          String key = buildKey(inputParams);
 165          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 166          if (CollectionUtils.isEmpty(cacheList)) {
 167              if (sideInfo.getJoinType() == JoinType.LEFT) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -                Row row = fillData(input.row(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 169 -                out.collect(new CRow(row, input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +                Row row = fillData(input, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +                RowDataComplete.collectRow(out, row);</span>
 172              } else {
 173                  return;
 174              }
 175  
 176              return;
 177          }
 178  
 179          for (Map&lt;String, Object&gt; one : cacheList) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -            out.collect(new CRow(fillData(input.row(), one), input.change()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +            Row row = fillData(input, one);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +            RowDataComplete.collectRow(out, row);</span>
 183          }
 184  
 185      }
 186  
 187      private String buildKey(List&lt;Object&gt; equalValList) {
 188          StringBuilder sb = new StringBuilder(&quot;&quot;);
 189          for (Object equalVal : equalValList) {
 190              sb.append(equalVal).append(&quot;_&quot;);
 191          }
 192  
 193          return sb.toString();
 194      }
 195  
 196      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 197          StringBuilder sb = new StringBuilder(&quot;&quot;);
 198          for (String equalField : equalFieldList) {
 199              sb.append(val.get(equalField)).append(&quot;_&quot;);
 200          }
 201  
 202          return sb.toString();
 203      }
 204  
 205      private Session getConn(CassandraSideTableInfo tableInfo) {
 206          try {
 207              if (session == null) {
 208                  QueryOptions queryOptions = new QueryOptions();
 209                  //The default consistency level for queries: ConsistencyLevel.TWO.
 210                  queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 211                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 211                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo🔵</abbr>
<abbr title=" 212                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 212                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.get🔵</abbr>
<abbr title=" 213                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 213                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.g🔵</abbr>
 214                  Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();
<abbr title=" 215                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 215                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTi🔵</abbr>
<abbr title=" 216                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 216                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.get🔵</abbr>
<abbr title=" 217                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 217                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTi🔵</abbr>
 218                  Integer cassandraPort = 0;
 219                  String address = tableInfo.getAddress();
 220                  String userName = tableInfo.getUserName();
 221                  String password = tableInfo.getPassword();
 222                  String database = tableInfo.getDatabase();
 223  
 224                  ArrayList serversList = new ArrayList();
 225                  //Read timeout or connection timeout Settings
 226                  SocketOptions so = new SocketOptions()
 227                          .setReadTimeoutMillis(readTimeoutMillis)
 228                          .setConnectTimeoutMillis(connectTimeoutMillis);
 229  
 230                  //The cluster USES hostdistance.local in the same machine room
 231                  //Hostdistance. REMOTE is used for different machine rooms
 232                  //Ignore use HostDistance. IGNORED
 233                  PoolingOptions poolingOptions = new PoolingOptions()
 234                          //Each connection allows a maximum of 64 concurrent requests
 235                          .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 236                          //Have at least two connections to each machine in the cluster
 237                          .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 238                          //There are up to eight connections to each machine in the cluster
 239                          .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 240                          .setMaxQueueSize(maxQueueSize)
 241                          .setPoolTimeoutMillis(poolTimeoutMillis);
 242                  //重试策略
 243                  RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 244  
 245                  for (String server : StringUtils.split(address, &quot;,&quot;)) {
 246                      cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 247                      serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 248                  }
 249  
 250                  if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
 251                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 252                              .withPort(cassandraPort)
 253                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 254                              .withQueryOptions(queryOptions).build();
 255                  } else {
 256                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 257                              .withPort(cassandraPort)
 258                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 259                              .withCredentials(userName, password)
 260                              .withQueryOptions(queryOptions).build();
 261                  }
 262                  // 建立连接 连接已存在的键空间
 263                  session = cluster.connect(database);
 264                  LOG.info(&quot;connect cassandra is successed!&quot;);
 265              }
 266          } catch (Exception e) {
 267              LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 268          }
 269          return session;
 270      }
 271  
 272  
 273      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 274          CassandraSideTableInfo tableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
 275          Session session = null;
 276  
 277          try {
 278              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 279                  try {
 280                      session = getConn(tableInfo);
 281                      break;
 282                  } catch (Exception e) {
 283                      if (i == CONN_RETRY_NUM - 1) {
 284                          throw new RuntimeException(&quot;&quot;, e);
 285                      }
 286                      try {
<abbr title=" 287                          String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()"> 287                          String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserNa🔵</abbr>
 288                                  + &quot;,pwd:&quot; + tableInfo.getPassword();
 289                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 290                          Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 291                      } catch (InterruptedException e1) {
 292                          LOG.error(&quot;&quot;, e1);
 293                      }
 294                  }
 295  
 296              }
 297  
 298              //load data from table
 299              String sql = sideInfo.getSqlCondition() + &quot; limit &quot; + FETCH_SIZE;
 300              ResultSet resultSet = session.execute(sql);
 301              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 302              for (com.datastax.driver.core.Row row : resultSet) {
 303                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 304                  for (String fieldName : sideFieldNames) {
 305                      oneRow.put(fieldName.trim(), row.getObject(fieldName.trim()));
 306                  }
 307                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 308                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 309                  list.add(oneRow);
 310              }
 311          } catch (Exception e) {
 312              LOG.error(&quot;&quot;, e);
 313          } finally {
 314              try {
 315                  if (session != null) {
 316                      session.close();
 317                  }
 318              } catch (Exception e) {
 319                  LOG.error(&quot;Error while closing session.&quot;, e);
 320              }
 321              try {
 322                  if (cluster != null) {
 323                      cluster.close();
 324                  }
 325              } catch (Exception e) {
 326                  LOG.error(&quot;Error while closing cluster.&quot;, e);
 327              }
 328          }
 329      }
 330  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.cassandra;
  20  
  21  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  22  import org.apache.flink.table.runtime.types.CRow;
  23  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  24  import org.apache.flink.types.Row;
  25  import org.apache.flink.util.Collector;
  26  
  27  import com.datastax.driver.core.Cluster;
  28  import com.datastax.driver.core.ConsistencyLevel;
  29  import com.datastax.driver.core.HostDistance;
  30  import com.datastax.driver.core.PoolingOptions;
  31  import com.datastax.driver.core.QueryOptions;
  32  import com.datastax.driver.core.ResultSet;
  33  import com.datastax.driver.core.Session;
  34  import com.datastax.driver.core.SocketOptions;

  35  import com.datastax.driver.core.policies.DowngradingConsistencyRetryPolicy;
  36  import com.datastax.driver.core.policies.RetryPolicy;

  37  import com.dtstack.flink.sql.side.BaseAllReqRow;
  38  import com.dtstack.flink.sql.side.FieldInfo;
  39  import com.dtstack.flink.sql.side.JoinInfo;
  40  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  41  import com.dtstack.flink.sql.side.cassandra.table.CassandraSideTableInfo;

  42  import com.google.common.collect.Lists;
  43  import com.google.common.collect.Maps;
  44  import org.apache.calcite.sql.JoinType;
  45  import org.apache.commons.collections.CollectionUtils;
  46  import org.apache.commons.lang3.StringUtils;




  47  import org.slf4j.Logger;
  48  import org.slf4j.LoggerFactory;
  49  
  50  import java.net.InetAddress;
  51  import java.sql.SQLException;
  52  import java.sql.Timestamp;
  53  import java.util.*;




  54  import java.util.concurrent.atomic.AtomicReference;
  55  
  56  /**
  57   * Reason:
  58   * Date: 2018/11/22
  59   *
  60   * @author xuqianjin
  61   */
  62  public class CassandraAllReqRow extends BaseAllReqRow {
  63  
  64      private static final long serialVersionUID = 54015343561288219L;
  65  
  66      private static final Logger LOG = LoggerFactory.getLogger(CassandraAllReqRow.class);
  67  
  68      private static final int CONN_RETRY_NUM = 3;
  69  
  70      private static final int FETCH_SIZE = 1000;
  71  
  72      private transient Cluster cluster;
  73      private transient Session session = null;
  74  
  75      private AtomicReference&lt;Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt;&gt; cacheRef = new AtomicReference&lt;&gt;();
  76  
<abbr title="  77      public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  77      public CassandraAllReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abstra🔵</abbr>
<abbr title="  78          super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));">  78          super(new com.dtstack.flink.sql.side.cassandra.CassandraAllSideInfo(rowTypeInfo, joinInfo, outFieldInfoLis🔵</abbr>
  79      }
  80  
  81      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -    public Row fillData(Row input, Object sideInput) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -        Map&lt;String, Object&gt; cacheInfo = (Map&lt;String, Object&gt;) sideInput;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        Row row = new Row(sideInfo.getOutFieldInfoList().size());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -        for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -            Object obj = input.getField(entry.getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  87 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());">  87 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  89 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL timestamp but is serialized as Long.">  89 -            //Type information for indicating event or processing time. However, it behaves like a regular SQL tim🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -            if (obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -                //去除上一层OutputRowtimeProcessFunction 调用时区导致的影响</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -                obj = ((Timestamp) obj).getTime() + (long)LOCAL_TZ.getOffset(((Timestamp) obj).getTime());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -            row.setField(entry.getKey(), obj);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -        for (Map.Entry&lt;Integer, String&gt; entry : sideInfo.getSideFieldNameIndex().entrySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -            if (cacheInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -                row.setField(entry.getKey(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -                row.setField(entry.getKey(), cacheInfo.get(entry.getValue()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -        return row;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -    @Override</span>
 110      protected void initCache() throws SQLException {
 111          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 112          cacheRef.set(newCache);
 113          loadData(newCache);
 114      }
 115  
 116      @Override
 117      protected void reloadCache() {
 118          //reload cacheRef and replace to old cacheRef
 119          Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; newCache = Maps.newConcurrentMap();
 120          try {
 121              loadData(newCache);
 122          } catch (SQLException e) {
 123              LOG.error(&quot;&quot;, e);
 124          }
 125  
 126          cacheRef.set(newCache);
 127          LOG.info(&quot;----- cassandra all cacheRef reload end:{}&quot;, Calendar.getInstance());
 128      }
 129  
 130  
 131      @Override
 132      public void flatMap(CRow input, Collector&lt;CRow&gt; out) throws Exception {

 133          List&lt;Object&gt; inputParams = Lists.newArrayList();
 134          for (Integer conValIndex : sideInfo.getEqualValIndex()) {
 135              Object equalObj = input.row().getField(conValIndex);

 136              if (equalObj == null) {
 137                  if(sideInfo.getJoinType() == JoinType.LEFT){
 138                      Row data = fillData(input.row(), null);
 139                      out.collect(new CRow(data, input.change()));



 140                  }
 141                  return;
 142              }
 143  
 144              inputParams.add(equalObj);
 145          }
 146  
 147          String key = buildKey(inputParams);
 148          List&lt;Map&lt;String, Object&gt;&gt; cacheList = cacheRef.get().get(key);
 149          if (CollectionUtils.isEmpty(cacheList)) {
 150              if (sideInfo.getJoinType() == JoinType.LEFT) {
 151                  Row row = fillData(input.row(), null);
 152                  out.collect(new CRow(row, input.change()));


 153              } else {
 154                  return;
 155              }
 156  
 157              return;
 158          }
 159  
 160          for (Map&lt;String, Object&gt; one : cacheList) {
 161              out.collect(new CRow(fillData(input.row(), one), input.change()));


 162          }
 163  
 164      }
 165  
 166      private String buildKey(List&lt;Object&gt; equalValList) {
 167          StringBuilder sb = new StringBuilder(&quot;&quot;);
 168          for (Object equalVal : equalValList) {
 169              sb.append(equalVal).append(&quot;_&quot;);
 170          }
 171  
 172          return sb.toString();
 173      }
 174  
 175      private String buildKey(Map&lt;String, Object&gt; val, List&lt;String&gt; equalFieldList) {
 176          StringBuilder sb = new StringBuilder(&quot;&quot;);
 177          for (String equalField : equalFieldList) {
 178              sb.append(val.get(equalField)).append(&quot;_&quot;);
 179          }
 180  
 181          return sb.toString();
 182      }
 183  
 184      private Session getConn(CassandraSideTableInfo tableInfo) {
 185          try {
 186              if (session == null) {
 187                  QueryOptions queryOptions = new QueryOptions();
 188                  //The default consistency level for queries: ConsistencyLevel.TWO.
 189                  queryOptions.setConsistencyLevel(ConsistencyLevel.QUORUM);
<abbr title=" 190                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo.getMaxRequestsPerConnection();"> 190                  Integer maxRequestsPerConnection = tableInfo.getMaxRequestsPerConnection() == null ? 1 : tableInfo🔵</abbr>
<abbr title=" 191                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.getCoreConnectionsPerHost();"> 191                  Integer coreConnectionsPerHost = tableInfo.getCoreConnectionsPerHost() == null ? 8 : tableInfo.get🔵</abbr>
<abbr title=" 192                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.getMaxConnectionsPerHost();"> 192                  Integer maxConnectionsPerHost = tableInfo.getMaxConnectionsPerHost() == null ? 32768 : tableInfo.g🔵</abbr>
 193                  Integer maxQueueSize = tableInfo.getMaxQueueSize() == null ? 100000 : tableInfo.getMaxQueueSize();
<abbr title=" 194                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTimeoutMillis();"> 194                  Integer readTimeoutMillis = tableInfo.getReadTimeoutMillis() == null ? 60000 : tableInfo.getReadTi🔵</abbr>
<abbr title=" 195                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.getConnectTimeoutMillis();"> 195                  Integer connectTimeoutMillis = tableInfo.getConnectTimeoutMillis() == null ? 60000 : tableInfo.get🔵</abbr>
<abbr title=" 196                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTimeoutMillis();"> 196                  Integer poolTimeoutMillis = tableInfo.getPoolTimeoutMillis() == null ? 60000 : tableInfo.getPoolTi🔵</abbr>
 197                  Integer cassandraPort = 0;
 198                  String address = tableInfo.getAddress();
 199                  String userName = tableInfo.getUserName();
 200                  String password = tableInfo.getPassword();
 201                  String database = tableInfo.getDatabase();
 202  
 203                  ArrayList serversList = new ArrayList();
 204                  //Read timeout or connection timeout Settings
 205                  SocketOptions so = new SocketOptions()
 206                          .setReadTimeoutMillis(readTimeoutMillis)
 207                          .setConnectTimeoutMillis(connectTimeoutMillis);
 208  
 209                  //The cluster USES hostdistance.local in the same machine room
 210                  //Hostdistance. REMOTE is used for different machine rooms
 211                  //Ignore use HostDistance. IGNORED
 212                  PoolingOptions poolingOptions = new PoolingOptions()
 213                          //Each connection allows a maximum of 64 concurrent requests
 214                          .setMaxRequestsPerConnection(HostDistance.LOCAL, maxRequestsPerConnection)
 215                          //Have at least two connections to each machine in the cluster
 216                          .setCoreConnectionsPerHost(HostDistance.LOCAL, coreConnectionsPerHost)
 217                          //There are up to eight connections to each machine in the cluster
 218                          .setMaxConnectionsPerHost(HostDistance.LOCAL, maxConnectionsPerHost)
 219                          .setMaxQueueSize(maxQueueSize)
 220                          .setPoolTimeoutMillis(poolTimeoutMillis);
 221                  //重试策略
 222                  RetryPolicy retryPolicy = DowngradingConsistencyRetryPolicy.INSTANCE;
 223  
 224                  for (String server : StringUtils.split(address, &quot;,&quot;)) {
 225                      cassandraPort = Integer.parseInt(StringUtils.split(server, &quot;:&quot;)[1]);
 226                      serversList.add(InetAddress.getByName(StringUtils.split(server, &quot;:&quot;)[0]));
 227                  }
 228  
 229                  if (userName == null || userName.isEmpty() || password == null || password.isEmpty()) {
 230                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 231                              .withPort(cassandraPort)
 232                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 233                              .withQueryOptions(queryOptions).build();
 234                  } else {
 235                      cluster = Cluster.builder().addContactPoints(serversList).withRetryPolicy(retryPolicy)
 236                              .withPort(cassandraPort)
 237                              .withPoolingOptions(poolingOptions).withSocketOptions(so)
 238                              .withCredentials(userName, password)
 239                              .withQueryOptions(queryOptions).build();
 240                  }
 241                  // 建立连接 连接已存在的键空间
 242                  session = cluster.connect(database);
 243                  LOG.info(&quot;connect cassandra is successed!&quot;);
 244              }
 245          } catch (Exception e) {
 246              LOG.error(&quot;connect cassandra is error:&quot; + e.getMessage());
 247          }
 248          return session;
 249      }
 250  
 251  
 252      private void loadData(Map&lt;String, List&lt;Map&lt;String, Object&gt;&gt;&gt; tmpCache) throws SQLException {
 253          CassandraSideTableInfo tableInfo = (CassandraSideTableInfo) sideInfo.getSideTableInfo();
 254          Session session = null;
 255  
 256          try {
 257              for (int i = 0; i &lt; CONN_RETRY_NUM; i++) {
 258                  try {
 259                      session = getConn(tableInfo);
 260                      break;
 261                  } catch (Exception e) {
 262                      if (i == CONN_RETRY_NUM - 1) {
 263                          throw new RuntimeException(&quot;&quot;, e);
 264                      }
 265                      try {
<abbr title=" 266                          String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserName()"> 266                          String connInfo = &quot;address:&quot; + tableInfo.getAddress() + &quot;;userName:&quot; + tableInfo.getUserNa🔵</abbr>
 267                                  + &quot;,pwd:&quot; + tableInfo.getPassword();
 268                          LOG.warn(&quot;get conn fail, wait for 5 sec and try again, connInfo:&quot; + connInfo);
 269                          Thread.sleep(LOAD_DATA_ERROR_SLEEP_TIME);
 270                      } catch (InterruptedException e1) {
 271                          LOG.error(&quot;&quot;, e1);
 272                      }
 273                  }
 274  
 275              }
 276  
 277              //load data from table
 278              String sql = sideInfo.getSqlCondition() + &quot; limit &quot; + FETCH_SIZE;
 279              ResultSet resultSet = session.execute(sql);
 280              String[] sideFieldNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 281              for (com.datastax.driver.core.Row row : resultSet) {
 282                  Map&lt;String, Object&gt; oneRow = Maps.newHashMap();
 283                  for (String fieldName : sideFieldNames) {
 284                      oneRow.put(fieldName.trim(), row.getObject(fieldName.trim()));
 285                  }
 286                  String cacheKey = buildKey(oneRow, sideInfo.getEqualFieldList());
 287                  List&lt;Map&lt;String, Object&gt;&gt; list = tmpCache.computeIfAbsent(cacheKey, key -&gt; Lists.newArrayList());
 288                  list.add(oneRow);
 289              }
 290          } catch (Exception e) {
 291              LOG.error(&quot;&quot;, e);
 292          } finally {
 293              try {
 294                  if (session != null) {
 295                      session.close();
 296                  }
 297              } catch (Exception e) {
 298                  LOG.error(&quot;Error while closing session.&quot;, e);
 299              }
 300              try {
 301                  if (cluster != null) {
 302                      cluster.close();
 303                  }
 304              } catch (Exception e) {
 305                  LOG.error(&quot;Error while closing cluster.&quot;, e);
 306              }
 307          }
 308      }
 309  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            