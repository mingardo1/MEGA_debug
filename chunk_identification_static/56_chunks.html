<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>56 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    return new FileInfoThread(taskEntity, &#x27;
                         &#x27;callback);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void closeTimer(boolean isRunning) {\n&#x27;
                         &#x27;    this.isRunning = isRunning;\n&#x27;
                         &#x27;    if (mTimer != null) {\n&#x27;
                         &#x27;      mTimer.purge();\n&#x27;
                         &#x27;      mTimer.cancel();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 开始进度流程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void startRunningFlow() {\n&#x27;
                         &#x27;    closeTimer(true);\n&#x27;
                         &#x27;    mListener.onPostPre(mTotalSize);\n&#x27;
                         &#x27;    mListener.onStart(mCurrentLocation);\n&#x27;
                         &#x27;    mTimer = new Timer(true);\n&#x27;
                         &#x27;    mTimer.schedule(new TimerTask() {\n&#x27;
                         &#x27;      @Override public void run() {\n&#x27;
                         &#x27;        if (!isRunning) {\n&#x27;
                         &#x27;          closeTimer(false);\n&#x27;
                         &#x27;        } else if (mCurrentLocation &gt;= 0) {\n&#x27;
                         &#x27;          mListener.onProgress(mCurrentLocation);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }, 0, 1000);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 启动子任务下载器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void startChildDownload(DownloadTaskEntity &#x27;
                         &#x27;taskEntity) {\n&#x27;
                         &#x27;    ChildDownloadListener listener = new &#x27;
                         &#x27;ChildDownloadListener(taskEntity);\n&#x27;
                         &#x27;    Downloader dt = new Downloader(listener, &#x27;
                         &#x27;taskEntity);\n&#x27;
                         &#x27;    &#x27;
                         &#x27;mDownloaderMap.put(taskEntity.getEntity().getDownloadUrl(), &#x27;
                         &#x27;dt);\n&#x27;
                         &#x27;    if (mExePool.isShutdown()) return;\n&#x27;
                         &#x27;    mExePool.execute(dt);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建子任务下载信息\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private DownloadTaskEntity &#x27;
                         &#x27;createChildDownloadTask(DownloadEntity entity) {\n&#x27;
                         &#x27;    DownloadTaskEntity taskEntity = &#x27;
                         &#x27;mTasksMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;    if (taskEntity != null) {\n&#x27;
                         &#x27;      taskEntity.entity = entity;\n&#x27;
                         &#x27;      return taskEntity;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    taskEntity = new DownloadTaskEntity();\n&#x27;
                         &#x27;    taskEntity.entity = entity;\n&#x27;
                         &#x27;    taskEntity.headers = mTaskEntity.headers;\n&#x27;
                         &#x27;    taskEntity.requestEnum = &#x27;
                         &#x27;mTaskEntity.requestEnum;\n&#x27;
                         &#x27;    taskEntity.redirectUrlKey = &#x27;
                         &#x27;mTaskEntity.redirectUrlKey;\n&#x27;
                         &#x27;    taskEntity.removeFile = mTaskEntity.removeFile;\n&#x27;
                         &#x27;    taskEntity.groupName = mTaskEntity.key;\n&#x27;
                         &#x27;    taskEntity.isGroupTask = true;\n&#x27;
                         &#x27;    taskEntity.key = entity.getDownloadPath();\n&#x27;
                         &#x27;    taskEntity.save();\n&#x27;
                         &#x27;    return taskEntity;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子任务事件监听\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private class ChildDownloadListener implements &#x27;
                         &#x27;IDownloadListener {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    DownloadTaskEntity taskEntity;\n&#x27;
                         &#x27;    DownloadEntity entity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    long lastLen = 0;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    ChildDownloadListener(DownloadTaskEntity entity) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      this.taskEntity = entity;\n&#x27;
                         &#x27;      this.entity = taskEntity.getEntity();\n&#x27;
                         &#x27;      lastLen = this.entity.getCurrentProgress();\n&#x27;
                         &#x27;      this.entity.setFailNum(0);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onPre() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_PRE, -1);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onPostPre(long fileSize) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      entity.setFileSize(fileSize);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;entity.setConvertFileSize(CommonUtil.formatFileSize(fileSize));\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, -1);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onResume(long &#x27;
                         &#x27;resumeLocation) {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;      lastLen = resumeLocation;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onStart(long &#x27;
                         &#x27;startLocation) {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;      lastLen = startLocation;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onProgress(long &#x27;
                         &#x27;currentLocation) {\n&#x27;
                         &#x27;      long speed = currentLocation - lastLen;\n&#x27;
                         &#x27;      mCurrentLocation += speed;\n&#x27;
                         &#x27;      lastLen = currentLocation;\n&#x27;
                         &#x27;      entity.setCurrentProgress(currentLocation);\n&#x27;
                         &#x27;      handleSpeed(speed);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onStop(long stopLocation) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      saveData(IEntity.STATE_STOP, stopLocation);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubStop(entity);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onCancel() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_CANCEL, -1);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubCancel(entity);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onComplete() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_COMPLETE, &#x27;
                         &#x27;entity.getFileSize());\n&#x27;
                         &#x27;      mCompleteNum++;\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubComplete(entity);\n&#x27;
                         &#x27;      //如果子任务完成的数量和总任务数一致，表示任务组任务已经完成\n&#x27;
                         &#x27;      if (mCompleteNum &gt;= &#x27;
                         &#x27;mTaskEntity.getEntity().getSubTask().size()) {\n&#x27;
                         &#x27;        closeTimer(false);\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      } else if (mCompleteNum + mFailNum &gt;= &#x27;
                         &#x27;mActualTaskNum) {\n&#x27;
                         &#x27;        //如果子任务完成数量加上失败的数量和总任务数一致，则任务组停止下载\n&#x27;
                         &#x27;        closeTimer(false);\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onFail() {\n&#x27;
                         &#x27;      entity.setFailNum(entity.getFailNum() + 1);\n&#x27;
                         &#x27;      saveData(IEntity.STATE_FAIL, lastLen);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      reTry();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * 失败后重试下载，如果失败次数超过5次，不再重试\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private void reTry() {\n&#x27;
                         &#x27;      if (entity.getFailNum() &lt; 5) {\n&#x27;
                         &#x27;        reStartTask();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        mListener.onSubFail(entity);\n&#x27;
                         &#x27;        //如果失败的任务数大于实际的下载任务数，任务组停止下载\n&#x27;
                         &#x27;        if (mFailNum &gt;= mActualTaskNum) {\n&#x27;
                         &#x27;          closeTimer(false);\n&#x27;
                         &#x27;          mListener.onStop(mCurrentLocation);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void reStartTask() {\n&#x27;
                         &#x27;      Timer timer = new Timer();\n&#x27;
                         &#x27;      timer.schedule(new TimerTask() {\n&#x27;
                         &#x27;        @Override public void run() {\n&#x27;
                         &#x27;          Downloader dt = &#x27;
                         &#x27;mDownloaderMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;          dt.startDownload();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }, 3000);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void handleSpeed(long speed) {\n&#x27;
                         &#x27;      entity.setSpeed(speed);\n&#x27;
                         &#x27;      entity.setConvertSpeed(speed &lt;= 0 ? &quot;&quot; : &#x27;
                         &#x27;CommonUtil.formatFileSize(speed) + &quot;/s&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void saveData(int state, long location) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      entity.setState(state);\n&#x27;
                         &#x27;      entity.setComplete(state == &#x27;
                         &#x27;IEntity.STATE_COMPLETE);\n&#x27;
                         &#x27;      if (entity.isComplete()) {\n&#x27;
                         &#x27;        &#x27;
                         &#x27;entity.setCompleteTime(System.currentTimeMillis());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;entity.setCurrentProgress(entity.getFileSize());\n&#x27;
                         &#x27;      } else if (location &gt; 0) {\n&#x27;
                         &#x27;        entity.setCurrentProgress(location);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      entity.update();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void supportBreakpoint(boolean &#x27;
                         &#x27;support) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    return new HttpFileInfoThread(taskEntity, &#x27;
                           &#x27;callback);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27; /**\n&#x27;
                         &#x27;  * 子任务事件监听\n&#x27;
                         &#x27;  */\n&#x27;
                         &#x27; private class ChildDownloadListener implements &#x27;
                         &#x27;IDownloadListener {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadTaskEntity taskEntity;\n&#x27;
                         &#x27;  DownloadEntity entity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  long lastLen = 0;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  ChildDownloadListener(DownloadTaskEntity entity) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;   this.taskEntity = entity;\n&#x27;
                         &#x27;   this.entity = taskEntity.getEntity();\n&#x27;
                         &#x27;   lastLen = this.entity.getCurrentProgress();\n&#x27;
                         &#x27;   this.entity.setFailNum(0);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onPre() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_PRE, -1);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onPostPre(long fileSize) {\n&#x27;
                         &#x27;   entity.setFileSize(fileSize);\n&#x27;
                         &#x27;   &#x27;
                         &#x27;entity.setConvertFileSize(CommonUtil.formatFileSize(fileSize));\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, -1);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onResume(long &#x27;
                         &#x27;resumeLocation) {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;   lastLen = resumeLocation;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onStart(long startLocation) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;   lastLen = startLocation;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onProgress(long &#x27;
                         &#x27;currentLocation) {\n&#x27;
                         &#x27;   long speed = currentLocation - lastLen;\n&#x27;
                         &#x27;   mCurrentLocation += speed;\n&#x27;
                         &#x27;   lastLen = currentLocation;\n&#x27;
                         &#x27;   entity.setCurrentProgress(currentLocation);\n&#x27;
                         &#x27;   handleSpeed(speed);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onStop(long stopLocation) {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_STOP, stopLocation);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubStop(entity);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onCancel() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_CANCEL, -1);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubCancel(entity);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onComplete() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_COMPLETE, &#x27;
                         &#x27;entity.getFileSize());\n&#x27;
                         &#x27;   mCompleteNum++;\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubComplete(entity);\n&#x27;
                         &#x27;   //如果子任务完成的数量和总任务数一致，表示任务组任务已经完成\n&#x27;
                         &#x27;   if (mCompleteNum &gt;= &#x27;
                         &#x27;mTaskEntity.getEntity().getSubTask().size()) {\n&#x27;
                         &#x27;    closeTimer(false);\n&#x27;
                         &#x27;    mListener.onComplete();\n&#x27;
                         &#x27;   } else if (mCompleteNum + mFailNum &gt;= &#x27;
                         &#x27;mActualTaskNum) {\n&#x27;
                         &#x27;    //如果子任务完成数量加上失败的数量和总任务数一致，则任务组停止下载\n&#x27;
                         &#x27;    closeTimer(false);\n&#x27;
                         &#x27;    mListener.onComplete();\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onFail() {\n&#x27;
                         &#x27;   entity.setFailNum(entity.getFailNum() + 1);\n&#x27;
                         &#x27;   saveData(IEntity.STATE_FAIL, lastLen);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   reTry();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 失败后重试下载，如果失败次数超过5次，不再重试\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void reTry() {\n&#x27;
                         &#x27;   if (entity.getFailNum() &lt; 5) {\n&#x27;
                         &#x27;    reStartTask();\n&#x27;
                         &#x27;   } else {\n&#x27;
                         &#x27;    mFailNum++;\n&#x27;
                         &#x27;    mListener.onSubFail(entity);\n&#x27;
                         &#x27;    //如果失败的任务数大于实际的下载任务数，任务组停止下载\n&#x27;
                         &#x27;    if (mFailNum &gt;= mActualTaskNum) {\n&#x27;
                         &#x27;     closeTimer(false);\n&#x27;
                         &#x27;     mListener.onStop(mCurrentLocation);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void reStartTask() {\n&#x27;
                         &#x27;   Timer timer = new Timer();\n&#x27;
                         &#x27;   timer.schedule(new TimerTask() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;     Downloader dt = &#x27;
                         &#x27;mDownloaderMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;     dt.startDownload();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;   }, 3000);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void handleSpeed(long speed) {\n&#x27;
                         &#x27;   entity.setSpeed(speed);\n&#x27;
                         &#x27;   entity.setConvertSpeed(speed &lt;= 0 ? &quot;&quot; : &#x27;
                         &#x27;CommonUtil.formatFileSize(speed) + &quot;/s&quot;);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void saveData(int state, long location) {\n&#x27;
                         &#x27;   entity.setState(state);\n&#x27;
                         &#x27;   entity.setComplete(state == &#x27;
                         &#x27;IEntity.STATE_COMPLETE);\n&#x27;
                         &#x27;   if (entity.isComplete()) {\n&#x27;
                         &#x27;    &#x27;
                         &#x27;entity.setCompleteTime(System.currentTimeMillis());\n&#x27;
                         &#x27;    &#x27;
                         &#x27;entity.setCurrentProgress(entity.getFileSize());\n&#x27;
                         &#x27;   } else if (location &gt; 0) {\n&#x27;
                         &#x27;    entity.setCurrentProgress(location);\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;   entity.update();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void supportBreakpoint(boolean &#x27;
                         &#x27;support) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27; }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    return new FileInfoThread(taskEntity, &#x27;
                         &#x27;callback);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void closeTimer(boolean isRunning) {\n&#x27;
                         &#x27;    this.isRunning = isRunning;\n&#x27;
                         &#x27;    if (mTimer != null) {\n&#x27;
                         &#x27;      mTimer.purge();\n&#x27;
                         &#x27;      mTimer.cancel();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 开始进度流程\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void startRunningFlow() {\n&#x27;
                         &#x27;    closeTimer(true);\n&#x27;
                         &#x27;    mListener.onPostPre(mTotalSize);\n&#x27;
                         &#x27;    mListener.onStart(mCurrentLocation);\n&#x27;
                         &#x27;    mTimer = new Timer(true);\n&#x27;
                         &#x27;    mTimer.schedule(new TimerTask() {\n&#x27;
                         &#x27;      @Override public void run() {\n&#x27;
                         &#x27;        if (!isRunning) {\n&#x27;
                         &#x27;          closeTimer(false);\n&#x27;
                         &#x27;        } else if (mCurrentLocation &gt;= 0) {\n&#x27;
                         &#x27;          mListener.onProgress(mCurrentLocation);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }, 0, 1000);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 启动子任务下载器\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void startChildDownload(DownloadTaskEntity &#x27;
                         &#x27;taskEntity) {\n&#x27;
                         &#x27;    ChildDownloadListener listener = new &#x27;
                         &#x27;ChildDownloadListener(taskEntity);\n&#x27;
                         &#x27;    Downloader dt = new Downloader(listener, &#x27;
                         &#x27;taskEntity);\n&#x27;
                         &#x27;    &#x27;
                         &#x27;mDownloaderMap.put(taskEntity.getEntity().getDownloadUrl(), &#x27;
                         &#x27;dt);\n&#x27;
                         &#x27;    if (mExePool.isShutdown()) return;\n&#x27;
                         &#x27;    mExePool.execute(dt);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 创建子任务下载信息\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private DownloadTaskEntity &#x27;
                         &#x27;createChildDownloadTask(DownloadEntity entity) {\n&#x27;
                         &#x27;    DownloadTaskEntity taskEntity = &#x27;
                         &#x27;mTasksMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;    if (taskEntity != null) {\n&#x27;
                         &#x27;      taskEntity.entity = entity;\n&#x27;
                         &#x27;      return taskEntity;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;    taskEntity = new DownloadTaskEntity();\n&#x27;
                         &#x27;    taskEntity.entity = entity;\n&#x27;
                         &#x27;    taskEntity.headers = mTaskEntity.headers;\n&#x27;
                         &#x27;    taskEntity.requestEnum = &#x27;
                         &#x27;mTaskEntity.requestEnum;\n&#x27;
                         &#x27;    taskEntity.redirectUrlKey = &#x27;
                         &#x27;mTaskEntity.redirectUrlKey;\n&#x27;
                         &#x27;    taskEntity.removeFile = mTaskEntity.removeFile;\n&#x27;
                         &#x27;    taskEntity.groupName = mTaskEntity.key;\n&#x27;
                         &#x27;    taskEntity.isGroupTask = true;\n&#x27;
                         &#x27;    taskEntity.key = entity.getDownloadPath();\n&#x27;
                         &#x27;    taskEntity.save();\n&#x27;
                         &#x27;    return taskEntity;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 子任务事件监听\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private class ChildDownloadListener implements &#x27;
                         &#x27;IDownloadListener {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    DownloadTaskEntity taskEntity;\n&#x27;
                         &#x27;    DownloadEntity entity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    long lastLen = 0;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    ChildDownloadListener(DownloadTaskEntity entity) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      this.taskEntity = entity;\n&#x27;
                         &#x27;      this.entity = taskEntity.getEntity();\n&#x27;
                         &#x27;      lastLen = this.entity.getCurrentProgress();\n&#x27;
                         &#x27;      this.entity.setFailNum(0);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onPre() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_PRE, -1);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onPostPre(long fileSize) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      entity.setFileSize(fileSize);\n&#x27;
                         &#x27;      &#x27;
                         &#x27;entity.setConvertFileSize(CommonUtil.formatFileSize(fileSize));\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, -1);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onResume(long &#x27;
                         &#x27;resumeLocation) {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;      lastLen = resumeLocation;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onStart(long &#x27;
                         &#x27;startLocation) {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;      lastLen = startLocation;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onProgress(long &#x27;
                         &#x27;currentLocation) {\n&#x27;
                         &#x27;      long speed = currentLocation - lastLen;\n&#x27;
                         &#x27;      mCurrentLocation += speed;\n&#x27;
                         &#x27;      lastLen = currentLocation;\n&#x27;
                         &#x27;      entity.setCurrentProgress(currentLocation);\n&#x27;
                         &#x27;      handleSpeed(speed);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onStop(long stopLocation) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      saveData(IEntity.STATE_STOP, stopLocation);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubStop(entity);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onCancel() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_CANCEL, -1);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubCancel(entity);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onComplete() {\n&#x27;
                         &#x27;      saveData(IEntity.STATE_COMPLETE, &#x27;
                         &#x27;entity.getFileSize());\n&#x27;
                         &#x27;      mCompleteNum++;\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      mListener.onSubComplete(entity);\n&#x27;
                         &#x27;      //如果子任务完成的数量和总任务数一致，表示任务组任务已经完成\n&#x27;
                         &#x27;      if (mCompleteNum &gt;= &#x27;
                         &#x27;mTaskEntity.getEntity().getSubTask().size()) {\n&#x27;
                         &#x27;        closeTimer(false);\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      } else if (mCompleteNum + mFailNum &gt;= &#x27;
                         &#x27;mActualTaskNum) {\n&#x27;
                         &#x27;        //如果子任务完成数量加上失败的数量和总任务数一致，则任务组停止下载\n&#x27;
                         &#x27;        closeTimer(false);\n&#x27;
                         &#x27;        mListener.onComplete();\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void onFail() {\n&#x27;
                         &#x27;      entity.setFailNum(entity.getFailNum() + 1);\n&#x27;
                         &#x27;      saveData(IEntity.STATE_FAIL, lastLen);\n&#x27;
                         &#x27;      handleSpeed(0);\n&#x27;
                         &#x27;      reTry();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * 失败后重试下载，如果失败次数超过5次，不再重试\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private void reTry() {\n&#x27;
                         &#x27;      if (entity.getFailNum() &lt; 5) {\n&#x27;
                         &#x27;        reStartTask();\n&#x27;
                         &#x27;      } else {\n&#x27;
                         &#x27;        mFailNum++;\n&#x27;
                         &#x27;        mListener.onSubFail(entity);\n&#x27;
                         &#x27;        //如果失败的任务数大于实际的下载任务数，任务组停止下载\n&#x27;
                         &#x27;        if (mFailNum &gt;= mActualTaskNum) {\n&#x27;
                         &#x27;          closeTimer(false);\n&#x27;
                         &#x27;          mListener.onStop(mCurrentLocation);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void reStartTask() {\n&#x27;
                         &#x27;      Timer timer = new Timer();\n&#x27;
                         &#x27;      timer.schedule(new TimerTask() {\n&#x27;
                         &#x27;        @Override public void run() {\n&#x27;
                         &#x27;          Downloader dt = &#x27;
                         &#x27;mDownloaderMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;          dt.startDownload();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }, 3000);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void handleSpeed(long speed) {\n&#x27;
                         &#x27;      entity.setSpeed(speed);\n&#x27;
                         &#x27;      entity.setConvertSpeed(speed &lt;= 0 ? &quot;&quot; : &#x27;
                         &#x27;CommonUtil.formatFileSize(speed) + &quot;/s&quot;);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void saveData(int state, long location) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;      entity.setState(state);\n&#x27;
                         &#x27;      entity.setComplete(state == &#x27;
                         &#x27;IEntity.STATE_COMPLETE);\n&#x27;
                         &#x27;      if (entity.isComplete()) {\n&#x27;
                         &#x27;        &#x27;
                         &#x27;entity.setCompleteTime(System.currentTimeMillis());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;entity.setCurrentProgress(entity.getFileSize());\n&#x27;
                         &#x27;      } else if (location &gt; 0) {\n&#x27;
                         &#x27;        entity.setCurrentProgress(location);\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;      entity.update();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override public void supportBreakpoint(boolean &#x27;
                         &#x27;support) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    return new HttpFileInfoThread(taskEntity, &#x27;
                           &#x27;callback);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27; /**\n&#x27;
                         &#x27;  * 子任务事件监听\n&#x27;
                         &#x27;  */\n&#x27;
                         &#x27; private class ChildDownloadListener implements &#x27;
                         &#x27;IDownloadListener {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  DownloadTaskEntity taskEntity;\n&#x27;
                         &#x27;  DownloadEntity entity;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  long lastLen = 0;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  ChildDownloadListener(DownloadTaskEntity entity) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;   this.taskEntity = entity;\n&#x27;
                         &#x27;   this.entity = taskEntity.getEntity();\n&#x27;
                         &#x27;   lastLen = this.entity.getCurrentProgress();\n&#x27;
                         &#x27;   this.entity.setFailNum(0);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onPre() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_PRE, -1);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onPostPre(long fileSize) {\n&#x27;
                         &#x27;   entity.setFileSize(fileSize);\n&#x27;
                         &#x27;   &#x27;
                         &#x27;entity.setConvertFileSize(CommonUtil.formatFileSize(fileSize));\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, -1);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onResume(long &#x27;
                         &#x27;resumeLocation) {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;   lastLen = resumeLocation;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onStart(long startLocation) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;   saveData(IEntity.STATE_POST_PRE, &#x27;
                         &#x27;IEntity.STATE_RUNNING);\n&#x27;
                         &#x27;   lastLen = startLocation;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onProgress(long &#x27;
                         &#x27;currentLocation) {\n&#x27;
                         &#x27;   long speed = currentLocation - lastLen;\n&#x27;
                         &#x27;   mCurrentLocation += speed;\n&#x27;
                         &#x27;   lastLen = currentLocation;\n&#x27;
                         &#x27;   entity.setCurrentProgress(currentLocation);\n&#x27;
                         &#x27;   handleSpeed(speed);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onStop(long stopLocation) {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_STOP, stopLocation);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubStop(entity);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onCancel() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_CANCEL, -1);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubCancel(entity);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onComplete() {\n&#x27;
                         &#x27;   saveData(IEntity.STATE_COMPLETE, &#x27;
                         &#x27;entity.getFileSize());\n&#x27;
                         &#x27;   mCompleteNum++;\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   mListener.onSubComplete(entity);\n&#x27;
                         &#x27;   //如果子任务完成的数量和总任务数一致，表示任务组任务已经完成\n&#x27;
                         &#x27;   if (mCompleteNum &gt;= &#x27;
                         &#x27;mTaskEntity.getEntity().getSubTask().size()) {\n&#x27;
                         &#x27;    closeTimer(false);\n&#x27;
                         &#x27;    mListener.onComplete();\n&#x27;
                         &#x27;   } else if (mCompleteNum + mFailNum &gt;= &#x27;
                         &#x27;mActualTaskNum) {\n&#x27;
                         &#x27;    //如果子任务完成数量加上失败的数量和总任务数一致，则任务组停止下载\n&#x27;
                         &#x27;    closeTimer(false);\n&#x27;
                         &#x27;    mListener.onComplete();\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void onFail() {\n&#x27;
                         &#x27;   entity.setFailNum(entity.getFailNum() + 1);\n&#x27;
                         &#x27;   saveData(IEntity.STATE_FAIL, lastLen);\n&#x27;
                         &#x27;   handleSpeed(0);\n&#x27;
                         &#x27;   reTry();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 失败后重试下载，如果失败次数超过5次，不再重试\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private void reTry() {\n&#x27;
                         &#x27;   if (entity.getFailNum() &lt; 5) {\n&#x27;
                         &#x27;    reStartTask();\n&#x27;
                         &#x27;   } else {\n&#x27;
                         &#x27;    mFailNum++;\n&#x27;
                         &#x27;    mListener.onSubFail(entity);\n&#x27;
                         &#x27;    //如果失败的任务数大于实际的下载任务数，任务组停止下载\n&#x27;
                         &#x27;    if (mFailNum &gt;= mActualTaskNum) {\n&#x27;
                         &#x27;     closeTimer(false);\n&#x27;
                         &#x27;     mListener.onStop(mCurrentLocation);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void reStartTask() {\n&#x27;
                         &#x27;   Timer timer = new Timer();\n&#x27;
                         &#x27;   timer.schedule(new TimerTask() {\n&#x27;
                         &#x27;    @Override public void run() {\n&#x27;
                         &#x27;     Downloader dt = &#x27;
                         &#x27;mDownloaderMap.get(entity.getDownloadUrl());\n&#x27;
                         &#x27;     dt.startDownload();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;   }, 3000);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void handleSpeed(long speed) {\n&#x27;
                         &#x27;   entity.setSpeed(speed);\n&#x27;
                         &#x27;   entity.setConvertSpeed(speed &lt;= 0 ? &quot;&quot; : &#x27;
                         &#x27;CommonUtil.formatFileSize(speed) + &quot;/s&quot;);\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  private void saveData(int state, long location) {\n&#x27;
                         &#x27;   entity.setState(state);\n&#x27;
                         &#x27;   entity.setComplete(state == &#x27;
                         &#x27;IEntity.STATE_COMPLETE);\n&#x27;
                         &#x27;   if (entity.isComplete()) {\n&#x27;
                         &#x27;    &#x27;
                         &#x27;entity.setCompleteTime(System.currentTimeMillis());\n&#x27;
                         &#x27;    &#x27;
                         &#x27;entity.setCurrentProgress(entity.getFileSize());\n&#x27;
                         &#x27;   } else if (location &gt; 0) {\n&#x27;
                         &#x27;    entity.setCurrentProgress(location);\n&#x27;
                         &#x27;   }\n&#x27;
                         &#x27;   entity.update();\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  @Override public void supportBreakpoint(boolean &#x27;
                         &#x27;support) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  }\n&#x27;
                         &#x27; }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        