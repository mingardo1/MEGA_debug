<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>378</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    378
                    <a href="377.html">prev</a>
                    <a href="379.html">next</a>
                    <a href="378_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_cb68efb9e51ba697e771581059b9c11c3fe66ccb_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;828062ef514a8028632086b1c19ef248140da519:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.common.typeinfo.Types;
  25 import org.apache.flink.api.java.tuple.Tuple2;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  28 import org.apache.flink.streaming.api.datastream.DataStream;
  29 import org.apache.flink.table.api.EnvironmentSettings;
  30 import org.apache.flink.table.api.Table;
  31 import org.apache.flink.table.api.TableSchema;
  32 import org.apache.flink.table.api.java.StreamTableEnvironment;
  33 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  34 import org.apache.flink.table.catalog.CatalogManager;
  35 import org.apache.flink.table.catalog.ObjectIdentifier;
  36 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  37 import org.apache.flink.types.Row;
  38 
  39 import com.dtstack.flink.sql.enums.ECacheType;
  40 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  41 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  42 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  43 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  44 import com.dtstack.flink.sql.util.ClassUtil;
  45 import com.dtstack.flink.sql.util.ParseUtils;
  46 import com.dtstack.flink.sql.util.TableUtils;
  47 import com.google.common.base.Preconditions;
  48 import com.google.common.collect.HashBasedTable;
  49 import com.google.common.collect.Lists;
  50 import com.google.common.collect.Maps;
  51 import com.google.common.collect.Sets;
  52 import org.apache.calcite.sql.SqlBasicCall;
  53 import org.apache.calcite.sql.SqlIdentifier;
  54 import org.apache.calcite.sql.SqlKind;
  55 import org.apache.calcite.sql.SqlNode;
  56 import org.apache.calcite.sql.SqlSelect;
  57 import org.apache.calcite.sql.SqlWithItem;
  58 import org.apache.calcite.sql.parser.SqlParseException;
  59 import org.apache.commons.collections.CollectionUtils;
  60 import org.apache.commons.lang3.StringUtils;
  61 import org.slf4j.Logger;
  62 import org.slf4j.LoggerFactory;
  63 
  64 import java.sql.Timestamp;
  65 import java.time.LocalDateTime;
  66 import java.util.Arrays;
  67 import java.util.LinkedList;
  68 import java.util.List;
  69 import java.util.Map;
  70 import java.util.Queue;
  71 import java.util.Set;
  72 
  73 import static org.apache.calcite.sql.SqlKind.*;
  74 
  75 /**
  76  * Reason:
  77  * Date: 2018/7/24
  78  * Company: www.dtstack.com
  79  * @author xuchao
  80  */
  81 
  82 public class SideSqlExec {
  83 
  84     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  85 
  86     private String localSqlPluginPath = null;
  87 
  88     private String tmpFields = null;
  89 
  90     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  91 
  92     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  93 
  94     public void exec(String sql,
  95                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  96                      StreamTableEnvironment tableEnv,
  97                      Map&lt;String, Table&gt; tableCache,
  98                      CreateTmpTableParser.SqlParserResult createView,
  99                      String scope) throws Exception {
 100         if(localSqlPluginPath == null){
 101             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 102         }
 103 
 104         localTableCache.putAll(tableCache);
 105         try {
 106             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 107         } catch (Exception e) {
 108             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 109         }
 110 
 111         if(createView != null){
 112             LOG.warn(&quot;create view info\n&quot;);
 113             LOG.warn(createView.getExecSql());
 114             LOG.warn(&quot;-----------------&quot;);
 115         }
 116 
 117         SideSQLParser sideSQLParser = new SideSQLParser();
 118         sideSQLParser.setLocalTableCache(localTableCache);
 119         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 120 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 121         Object pollObj = null;</span>
 122 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124         Object pollObj = null;</span>
 125 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 126         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 127         Object pollObj;</span>
 128 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 129         Object pollObj;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131         //need clean</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 132         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 133         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
 134 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 135 
 136         while((pollObj = exeQueue.poll()) != null){
 137 
 138             if(pollObj instanceof SqlNode){
 139                 SqlNode pollSqlNode = (SqlNode) pollObj;
 140 
 141 
 142                 if(pollSqlNode.getKind() == INSERT){
 143                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 144                     if(LOG.isInfoEnabled()){
 145                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 146                     }
 147 
 148                 }else if(pollSqlNode.getKind() == AS){
 149                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 150 
 151                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 152                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 153                     String TableAlias = sqlWithItem.name.toString();
 154                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 155                     tableEnv.registerTable(TableAlias, table);
 156 
 157                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 158                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 158                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 159                     Table table = tableEnv.sqlQuery(pollObj.toString());
 160 
 161                     if (createView.getFieldsInfoStr() == null){
 162                         tableEnv.registerTable(createView.getTableName(), table);
 163                     } else {
 164                         if (checkFieldsInfo(createView, table)){
 165                             table = table.as(tmpFields);
 166                             tableEnv.registerTable(createView.getTableName(), table);
 167                         } else {
 168                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 169                         }
 170                     }
 171 
 172                     localTableCache.put(createView.getTableName(), table);
 173                 }
 174 
 175             }else if (pollObj instanceof JoinInfo){
 176                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 177                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 178             }
 179         }
 180 
 181     }
 182 
 183 
 184     /**
 185      * 解析出as查询的表和字段的关系
 186      * @param asSqlNode
 187      * @param tableCache
 188      * @return
 189      */
 190     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 191         SqlNode info = asSqlNode.getOperands()[0];
 192         SqlNode alias = asSqlNode.getOperands()[1];
 193 
 194         SqlKind infoKind = info.getKind();
 195         if(infoKind != SELECT){
 196             return null;
 197         }
 198 
 199         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 200 
 201         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 202         for (FieldInfo fieldInfo : extractFieldList) {
 203             String tableName = fieldInfo.getTable();
 204             String fieldName = fieldInfo.getFieldName();
 205             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 206             mappingTable.put(tableName, fieldName, mappingFieldName);
 207         }
 208 
 209         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 210         replaceInfo.setMappingTable(mappingTable);
 211         replaceInfo.setTargetTableName(alias.toString());
 212         replaceInfo.setTargetTableAlias(alias.toString());
 213         return replaceInfo;
 214     }
 215 
 216 
 217     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 218         SqlKind sqlKind = sqlNode.getKind();
 219         if(sqlKind != AS){
 220             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 221         }
 222 
 223         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 224         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 225 
 226         AliasInfo aliasInfo = new AliasInfo();
 227         aliasInfo.setName(info.toString());
 228         aliasInfo.setAlias(alias.toString());
 229 
 230         return aliasInfo;
 231     }
 232 
 233     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 234                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 235         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 236         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 237         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 238             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 239             String tableName = fieldInfo.getTable();
 240             String fieldName = fieldInfo.getFieldName();
 241 
 242             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 243             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 243             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 244 
 245             sideOutTypes[i] = fieldInfo.getTypeInformation();
 246             sideOutNames[i] = mappingFieldName;
 247         }
 248         return new RowTypeInfo(sideOutTypes, sideOutNames);
 249     }
 250 
 251 
 252 
 253     /**
 254      *  对时间类型进行类型转换
 255      * @param leftTypeInfo
 256      * @return
 257      */
 258     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 259         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 260         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 261         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 262             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 263         }
 264         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 265         return rowTypeInfo;
 266     }
 267 
 268     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 269         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 270             return TypeInformation.of(LocalDateTime.class);
 271         }
 272         return typeInformation;
 273     }
 274 
 275 
 276 
 277 
 278 
 279 
 280     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 281         this.localSqlPluginPath = localSqlPluginPath;
 282     }
 283 
<abbr title=" 284     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 284     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 285         Table table = localTableCache.get(tableAlias);
 286         if(table == null){
 287             table = localTableCache.get(tableName);
 288         }
 289 
 290         if(table == null){
 291             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 292         }
 293 
 294         return table;
 295     }
 296 
 297 
 298     /**
<abbr title=" 299      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 299      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 300      *
 301      * @return
 302      */
<abbr title=" 303     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 303     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 304         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 305         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 306             return true;
 307         }
 308         return false;
 309     }
 310 
 311     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 312         List&lt;String&gt; res = Lists.newArrayList();
 313         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 314             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 315         });
 316         return res;
 317     }
 318 
<abbr title=" 319     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 319     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 320         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 321         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 322         List&lt;String&gt; conditionFields = Lists.newArrayList();
 323         for(SqlNode sqlNode : sqlNodeList){
 324             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 325                 throw new RuntimeException(&quot;not compare operator.&quot;);
 326             }
 327 
 328             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 329             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 330 
 331             String leftTableName = left.getComponent(0).getSimple();
 332             String rightTableName = right.getComponent(0).getSimple();
 333 
 334             String tableCol = &quot;&quot;;
 335             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 336                 tableCol = left.getComponent(1).getSimple();
 337             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 338                 tableCol = right.getComponent(1).getSimple();
 339             }else{
<abbr title=" 340                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 340                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 341             }
 342             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 343             conditionFields.add(tableCol);
 344         }
 345 
 346         return conditionFields;
 347     }
 348 
 349     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 350                                      SqlNode pollSqlNode,
 351                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 352 
 353         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 354         if (localTableCache.containsKey(aliasInfo.getName())) {
 355             return;
 356         }
 357 
 358         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 359         tableEnv.registerTable(aliasInfo.getAlias(), table);
 360         localTableCache.put(aliasInfo.getAlias(), table);
 361 
 362         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 363 
 364         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 365         if(fieldReplaceInfo == null){
 366            return;
 367         }
 368 
 369         //as 的源表
 370         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 371         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 372         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 373 
 374     }
 375 
 376     private void joinFun(Object pollObj,
 377                          Map&lt;String, Table&gt; localTableCache,
 378                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 379                          StreamTableEnvironment tableEnv) throws Exception{
 380         JoinInfo joinInfo = (JoinInfo) pollObj;
 381 
 382         JoinScope joinScope = new JoinScope();
 383         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 384         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 385         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 386 
<abbr title=" 387         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 387         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 388 
<abbr title=" 389         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 389         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 390         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 391 
 392         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 393         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 394         rightScopeChild.setTableName(joinInfo.getRightTableName());
 395         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 396         if(sideTableInfo == null){
 397             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 398         }
 399 
 400         if(sideTableInfo == null){
 401             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 402         }
 403 
 404         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 405 
 406         joinScope.addScope(leftScopeChild);
 407         joinScope.addScope(rightScopeChild);
 408 
 409         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 410 
 411         //获取两个表的所有字段
<abbr title=" 412         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 412         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 413         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 414         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 414         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 415 
 416         String leftTableAlias = joinInfo.getLeftTableAlias();
 417         Table targetTable = localTableCache.get(leftTableAlias);
 418         if(targetTable == null){
 419             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 420         }
 421 
<abbr title=" 422         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 422         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 423 
 424         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 425 
 426         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 427         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 428             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 428             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 429             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 430             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 431             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 431             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 432         }
 433 
 434         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 435         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 436             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 436             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 437         }else{
<abbr title=" 438             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 438             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 439         }
 440 
 441         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 442 
 443         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 444         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 445 
 446         String targetTableName = joinInfo.getNewTableName();
 447         String targetTableAlias = joinInfo.getNewTableAlias();
 448 
 449         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 450         replaceInfo.setMappingTable(mappingTable);
 451         replaceInfo.setTargetTableName(targetTableName);
 452         replaceInfo.setTargetTableAlias(targetTableAlias);
 453 
 454         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 455                 EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 456                 EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 457                 targetTableName);
<abbr title=" 458         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 458         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 459 
 460         if (!tableExists){
 461             Table joinTable = tableEnv.fromDataStream(dsOut);
 462             tableEnv.createTemporaryView(targetTableName, joinTable);
 463             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 464         }
 465     }
 466 
 467     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 468         String[] fieldNames = schema.getFieldNames();
 469         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 470 
<abbr title=" 471         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 471         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 472         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 472         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 473         return new RowTypeInfo(projectedTypes, projectedNames);
 474     }
 475 
 476 
 477     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 478         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 479         String fieldsInfo = result.getFieldsInfoStr();
 480         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 481         for (int i = 0; i &lt; fields.length; i++) {
 482             String[] filed = fields[i].split(&quot;\\s&quot;);
 483             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 484                 return false;
 485             } else {
 486                 String[] filedNameArr = new String[filed.length - 1];
 487                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 488                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 489                 fieldNames.add(fieldName);
 490                 String fieldType = filed[filed.length - 1 ].trim();
 491                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 492                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 493                 if (fieldClass == tableField){
 494                     continue;
 495                 } else {
 496                     return false;
 497                 }
 498             }
 499         }
 500         tmpFields = String.join(&quot;,&quot;, fieldNames);
 501         return true;
 502     }
 503 
 504 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.common.typeinfo.Types;
  25 import org.apache.flink.api.java.tuple.Tuple2;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  28 import org.apache.flink.streaming.api.datastream.DataStream;
  29 import org.apache.flink.table.api.EnvironmentSettings;
  30 import org.apache.flink.table.api.Table;
  31 import org.apache.flink.table.api.TableSchema;
  32 import org.apache.flink.table.api.java.StreamTableEnvironment;
  33 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  34 import org.apache.flink.table.catalog.CatalogManager;
  35 import org.apache.flink.table.catalog.ObjectIdentifier;
  36 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  37 import org.apache.flink.types.Row;
  38 
  39 import com.dtstack.flink.sql.enums.ECacheType;
  40 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  41 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  42 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  43 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  44 import com.dtstack.flink.sql.util.ClassUtil;
  45 import com.dtstack.flink.sql.util.ParseUtils;
  46 import com.dtstack.flink.sql.util.TableUtils;
  47 import com.google.common.base.Preconditions;
  48 import com.google.common.collect.HashBasedTable;
  49 import com.google.common.collect.Lists;
  50 import com.google.common.collect.Maps;
  51 import com.google.common.collect.Sets;
  52 import org.apache.calcite.sql.SqlBasicCall;
  53 import org.apache.calcite.sql.SqlIdentifier;
  54 import org.apache.calcite.sql.SqlKind;
  55 import org.apache.calcite.sql.SqlNode;
  56 import org.apache.calcite.sql.SqlSelect;
  57 import org.apache.calcite.sql.SqlWithItem;
  58 import org.apache.calcite.sql.parser.SqlParseException;
  59 import org.apache.commons.collections.CollectionUtils;
  60 import org.apache.commons.lang3.StringUtils;
  61 import org.slf4j.Logger;
  62 import org.slf4j.LoggerFactory;
  63 
  64 import java.sql.Timestamp;
  65 import java.time.LocalDateTime;
  66 import java.util.Arrays;
  67 import java.util.LinkedList;
  68 import java.util.List;
  69 import java.util.Map;
  70 import java.util.Queue;
  71 import java.util.Set;
  72 
  73 import static org.apache.calcite.sql.SqlKind.*;
  74 
  75 /**
  76  * Reason:
  77  * Date: 2018/7/24
  78  * Company: www.dtstack.com
  79  * @author xuchao
  80  */
  81 
  82 public class SideSqlExec {
  83 
  84     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  85 
  86     private String localSqlPluginPath = null;
  87 
  88     private String tmpFields = null;
  89 
  90     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  91 
  92     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  93 
  94     public void exec(String sql,
  95                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  96                      StreamTableEnvironment tableEnv,
  97                      Map&lt;String, Table&gt; tableCache,
  98                      CreateTmpTableParser.SqlParserResult createView,
  99                      String scope) throws Exception {
 100         if(localSqlPluginPath == null){
 101             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 102         }
 103 
 104         localTableCache.putAll(tableCache);
 105         try {
 106             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 107         } catch (Exception e) {
 108             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 109         }
 110 
 111         if(createView != null){
 112             LOG.warn(&quot;create view info\n&quot;);
 113             LOG.warn(createView.getExecSql());
 114             LOG.warn(&quot;-----------------&quot;);
 115         }
 116 
 117         SideSQLParser sideSQLParser = new SideSQLParser();
 118         sideSQLParser.setLocalTableCache(localTableCache);
 119         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 120         Object pollObj;
 121 
 122         //need clean
 123         boolean preIsSideJoin = false;
 124         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 125 
 126         while((pollObj = exeQueue.poll()) != null){
 127 
 128             if(pollObj instanceof SqlNode){
 129                 SqlNode pollSqlNode = (SqlNode) pollObj;
 130 
 131 
 132                 if(pollSqlNode.getKind() == INSERT){
 133                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 134                     if(LOG.isInfoEnabled()){
 135                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 136                     }
 137 
 138                 }else if(pollSqlNode.getKind() == AS){
 139                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 140 
 141                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 142                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 143                     String TableAlias = sqlWithItem.name.toString();
 144                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 145                     tableEnv.registerTable(TableAlias, table);
 146 
 147                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 148                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 148                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 149                     Table table = tableEnv.sqlQuery(pollObj.toString());
 150 
 151                     if (createView.getFieldsInfoStr() == null){
 152                         tableEnv.registerTable(createView.getTableName(), table);
 153                     } else {
 154                         if (checkFieldsInfo(createView, table)){
 155                             table = table.as(tmpFields);
 156                             tableEnv.registerTable(createView.getTableName(), table);
 157                         } else {
 158                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 159                         }
 160                     }
 161 
 162                     localTableCache.put(createView.getTableName(), table);
 163                 }
 164 
 165             }else if (pollObj instanceof JoinInfo){
 166                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 167                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 168             }
 169         }
 170 
 171     }
 172 
 173 
 174     /**
 175      * 解析出as查询的表和字段的关系
 176      * @param asSqlNode
 177      * @param tableCache
 178      * @return
 179      */
 180     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 181         SqlNode info = asSqlNode.getOperands()[0];
 182         SqlNode alias = asSqlNode.getOperands()[1];
 183 
 184         SqlKind infoKind = info.getKind();
 185         if(infoKind != SELECT){
 186             return null;
 187         }
 188 
 189         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 190 
 191         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 192         for (FieldInfo fieldInfo : extractFieldList) {
 193             String tableName = fieldInfo.getTable();
 194             String fieldName = fieldInfo.getFieldName();
 195             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 196             mappingTable.put(tableName, fieldName, mappingFieldName);
 197         }
 198 
 199         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 200         replaceInfo.setMappingTable(mappingTable);
 201         replaceInfo.setTargetTableName(alias.toString());
 202         replaceInfo.setTargetTableAlias(alias.toString());
 203         return replaceInfo;
 204     }
 205 
 206 
 207     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 208         SqlKind sqlKind = sqlNode.getKind();
 209         if(sqlKind != AS){
 210             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 211         }
 212 
 213         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 214         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 215 
 216         AliasInfo aliasInfo = new AliasInfo();
 217         aliasInfo.setName(info.toString());
 218         aliasInfo.setAlias(alias.toString());
 219 
 220         return aliasInfo;
 221     }
 222 
 223     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 224                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 225         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 226         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 227         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 228             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 229             String tableName = fieldInfo.getTable();
 230             String fieldName = fieldInfo.getFieldName();
 231 
 232             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 233             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 233             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 234 
 235             sideOutTypes[i] = fieldInfo.getTypeInformation();
 236             sideOutNames[i] = mappingFieldName;
 237         }
 238         return new RowTypeInfo(sideOutTypes, sideOutNames);
 239     }
 240 
 241 
 242 
 243     /**
 244      *  对时间类型进行类型转换
 245      * @param leftTypeInfo
 246      * @return
 247      */
 248     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 249         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 250         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 251         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 252             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 253         }
 254         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 255         return rowTypeInfo;
 256     }
 257 
 258     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 259         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 260             return TypeInformation.of(LocalDateTime.class);
 261         }
 262         return typeInformation;
 263     }
 264 
 265 
 266 
 267 
 268 
 269 
 270     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 271         this.localSqlPluginPath = localSqlPluginPath;
 272     }
 273 
<abbr title=" 274     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 274     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 275         Table table = localTableCache.get(tableAlias);
 276         if(table == null){
 277             table = localTableCache.get(tableName);
 278         }
 279 
 280         if(table == null){
 281             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 282         }
 283 
 284         return table;
 285     }
 286 
 287 
 288     /**
<abbr title=" 289      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 289      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 290      *
 291      * @return
 292      */
<abbr title=" 293     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 293     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 294         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 295         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 296             return true;
 297         }
 298         return false;
 299     }
 300 
 301     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 302         List&lt;String&gt; res = Lists.newArrayList();
 303         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 304             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 305         });
 306         return res;
 307     }
 308 
<abbr title=" 309     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 309     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 310         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 311         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 312         List&lt;String&gt; conditionFields = Lists.newArrayList();
 313         for(SqlNode sqlNode : sqlNodeList){
 314             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 315                 throw new RuntimeException(&quot;not compare operator.&quot;);
 316             }
 317 
 318             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 319             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 320 
 321             String leftTableName = left.getComponent(0).getSimple();
 322             String rightTableName = right.getComponent(0).getSimple();
 323 
 324             String tableCol = &quot;&quot;;
 325             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 326                 tableCol = left.getComponent(1).getSimple();
 327             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 328                 tableCol = right.getComponent(1).getSimple();
 329             }else{
<abbr title=" 330                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 330                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 331             }
 332             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 333             conditionFields.add(tableCol);
 334         }
 335 
 336         return conditionFields;
 337     }
 338 
 339     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 340                                      SqlNode pollSqlNode,
 341                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 342 
 343         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 344         if (localTableCache.containsKey(aliasInfo.getName())) {
 345             return;
 346         }
 347 
 348         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 349         tableEnv.registerTable(aliasInfo.getAlias(), table);
 350         localTableCache.put(aliasInfo.getAlias(), table);
 351 
 352         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 353 
 354         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 355         if(fieldReplaceInfo == null){
 356            return;
 357         }
 358 
 359         //as 的源表
 360         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 361         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 362         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 363 
 364     }
 365 
 366     private void joinFun(Object pollObj,
 367                          Map&lt;String, Table&gt; localTableCache,
 368                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 369                          StreamTableEnvironment tableEnv) throws Exception{
 370         JoinInfo joinInfo = (JoinInfo) pollObj;
 371 
 372         JoinScope joinScope = new JoinScope();
 373         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 374         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 375         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 376 
<abbr title=" 377         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 377         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 378 
<abbr title=" 379         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 379         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 380         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 381 
 382         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 383         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 384         rightScopeChild.setTableName(joinInfo.getRightTableName());
 385         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 386         if(sideTableInfo == null){
 387             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 388         }
 389 
 390         if(sideTableInfo == null){
 391             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 392         }
 393 
 394         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 395 
 396         joinScope.addScope(leftScopeChild);
 397         joinScope.addScope(rightScopeChild);
 398 
 399         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 400 
 401         //获取两个表的所有字段
<abbr title=" 402         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 402         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 403         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 404         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 404         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 405 
 406         String leftTableAlias = joinInfo.getLeftTableAlias();
 407         Table targetTable = localTableCache.get(leftTableAlias);
 408         if(targetTable == null){
 409             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 410         }
 411 
<abbr title=" 412         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 412         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 413 
 414         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 415 
 416         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 417         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 418             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 418             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 419             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 420             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 421             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 421             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 422         }
 423 
 424         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 425         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 426             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 426             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 427         }else{
<abbr title=" 428             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 428             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 429         }
 430 
 431         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 432 
 433         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 434         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 435 
 436         String targetTableName = joinInfo.getNewTableName();
 437         String targetTableAlias = joinInfo.getNewTableAlias();
 438 
 439         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 440         replaceInfo.setMappingTable(mappingTable);
 441         replaceInfo.setTargetTableName(targetTableName);
 442         replaceInfo.setTargetTableAlias(targetTableAlias);
 443 
 444         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(
 445                 EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,
 446                 EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,
 447                 targetTableName);
<abbr title=" 448         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 448         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 449 
 450         if (!tableExists){
 451             Table joinTable = tableEnv.fromDataStream(dsOut);
 452             tableEnv.createTemporaryView(targetTableName, joinTable);
 453             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 454         }
 455     }
 456 
 457     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 458         String[] fieldNames = schema.getFieldNames();
 459         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 460 
<abbr title=" 461         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 461         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 462         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 462         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 463         return new RowTypeInfo(projectedTypes, projectedNames);
 464     }
 465 
 466 
 467     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 468         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 469         String fieldsInfo = result.getFieldsInfoStr();
 470         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 471         for (int i = 0; i &lt; fields.length; i++) {
 472             String[] filed = fields[i].split(&quot;\\s&quot;);
 473             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 474                 return false;
 475             } else {
 476                 String[] filedNameArr = new String[filed.length - 1];
 477                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 478                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 479                 fieldNames.add(fieldName);
 480                 String fieldType = filed[filed.length - 1 ].trim();
 481                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 482                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 483                 if (fieldClass == tableField){
 484                     continue;
 485                 } else {
 486                     return false;
 487                 }
 488             }
 489         }
 490         tmpFields = String.join(&quot;,&quot;, fieldNames);
 491         return true;
 492     }
 493 
 494 }
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.sql.Timestamp;
  34 import java.time.LocalDateTime;
  35 import java.util.Arrays;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Map;
  39 import java.util.Queue;
  40 import java.util.Set;
  41 import org.apache.calcite.sql.SqlBasicCall;
  42 import org.apache.calcite.sql.SqlIdentifier;
  43 import org.apache.calcite.sql.SqlKind;
  44 import org.apache.calcite.sql.SqlNode;
  45 import org.apache.calcite.sql.SqlSelect;
  46 import org.apache.calcite.sql.SqlWithItem;
  47 import org.apache.calcite.sql.parser.SqlParseException;
  48 import org.apache.commons.collections.CollectionUtils;
  49 import org.apache.commons.lang3.StringUtils;
  50 import org.apache.flink.api.common.typeinfo.TypeInformation;
  51 import org.apache.flink.api.common.typeinfo.Types;
  52 import org.apache.flink.api.java.tuple.Tuple2;
  53 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  54 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  55 import org.apache.flink.streaming.api.datastream.DataStream;
  56 import org.apache.flink.table.api.EnvironmentSettings;
  57 import org.apache.flink.table.api.Table;
  58 import org.apache.flink.table.api.TableSchema;
  59 import org.apache.flink.table.api.java.StreamTableEnvironment;
  60 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  61 import org.apache.flink.table.catalog.CatalogManager;
  62 import org.apache.flink.table.catalog.ObjectIdentifier;
  63 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  64 import org.apache.flink.types.Row;
  65 import org.slf4j.Logger;
  66 import org.slf4j.LoggerFactory;
  67 import static org.apache.calcite.sql.SqlKind.*;
  68 
  69 
  70 /**
  71  * Reason:
  72  * Date: 2018/7/24
  73  * Company: www.dtstack.com
  74  * @author xuchao
  75  */
  76 public class SideSqlExec {
  77     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  78 
  79     private String localSqlPluginPath = null;
  80 
  81     private String tmpFields = null;
  82 
  83     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  84 
  85     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  86 
<abbr title="  87     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView, String scope) throws Exception {">  87     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  88         if (localSqlPluginPath == null) {
  89             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  90         }
  91         localTableCache.putAll(tableCache);
  92         try {
  93             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  94         } catch (java.lang.Exception e) {
  95             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  96         }
  97         if (createView != null) {
  98             LOG.warn(&quot;create view info\n&quot;);
  99             LOG.warn(createView.getExecSql());
 100             LOG.warn(&quot;-----------------&quot;);
 101         }
 102         SideSQLParser sideSQLParser = new SideSQLParser();
 103         sideSQLParser.setLocalTableCache(localTableCache);
 104         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 105         Object pollObj;
 106         // need clean
 107         boolean preIsSideJoin = false;
 108         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 109         while ((pollObj = exeQueue.poll()) != null) {
 110             if (pollObj instanceof SqlNode) {
 111                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 112                 if (pollSqlNode.getKind() == INSERT) {
 113                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 114                     if (LOG.isInfoEnabled()) {
 115                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 116                     }
 117                 } else if (pollSqlNode.getKind() == AS) {
 118                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 119                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 120                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 121                     String TableAlias = sqlWithItem.name.toString();
 122                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 123                     tableEnv.registerTable(TableAlias, table);
 124                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 125                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 125                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 126                     Table table = tableEnv.sqlQuery(pollObj.toString());
 127                     if (createView.getFieldsInfoStr() == null) {
 128                         tableEnv.registerTable(createView.getTableName(), table);
 129                     } else if (checkFieldsInfo(createView, table)) {
 130                         table = table.as(tmpFields);
 131                         tableEnv.registerTable(createView.getTableName(), table);
 132                     } else {
 133                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 134                     }
 135                     localTableCache.put(createView.getTableName(), table);
 136                 }
 137             } else if (pollObj instanceof JoinInfo) {
 138                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 139                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 140             }
 141         }
 142     }
 143 
 144     /**
 145      * 解析出as查询的表和字段的关系
 146      * @param asSqlNode
 147      * @param tableCache
 148      * @return
 149      */
 150     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 151         SqlNode info = asSqlNode.getOperands()[0];
 152         SqlNode alias = asSqlNode.getOperands()[1];
 153 
 154         SqlKind infoKind = info.getKind();
 155         if(infoKind != SELECT){
 156             return null;
 157         }
 158 
 159         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 160 
 161         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 162         for (FieldInfo fieldInfo : extractFieldList) {
 163             String tableName = fieldInfo.getTable();
 164             String fieldName = fieldInfo.getFieldName();
 165             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 166             mappingTable.put(tableName, fieldName, mappingFieldName);
 167         }
 168 
 169         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 170         replaceInfo.setMappingTable(mappingTable);
 171         replaceInfo.setTargetTableName(alias.toString());
 172         replaceInfo.setTargetTableAlias(alias.toString());
 173         return replaceInfo;
 174     }
 175 
 176     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 177         SqlKind sqlKind = sqlNode.getKind();
 178         if(sqlKind != AS){
 179             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 180         }
 181 
 182         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 183         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 184 
 185         AliasInfo aliasInfo = new AliasInfo();
 186         aliasInfo.setName(info.toString());
 187         aliasInfo.setAlias(alias.toString());
 188 
 189         return aliasInfo;
 190     }
 191 
 192     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 193                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 194         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 195         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 196         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 197             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 198             String tableName = fieldInfo.getTable();
 199             String fieldName = fieldInfo.getFieldName();
 200 
 201             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 202             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 202             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 203 
 204             sideOutTypes[i] = fieldInfo.getTypeInformation();
 205             sideOutNames[i] = mappingFieldName;
 206         }
 207         return new RowTypeInfo(sideOutTypes, sideOutNames);
 208     }
 209 
 210     /**
 211      *  对时间类型进行类型转换
 212      * @param leftTypeInfo
 213      * @return
 214      */
 215     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 216         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 217         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 218         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 219             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 220         }
 221         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 222         return rowTypeInfo;
 223     }
 224 
 225     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 226         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 227             return TypeInformation.of(LocalDateTime.class);
 228         }
 229         return typeInformation;
 230     }
 231 
 232     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 233         this.localSqlPluginPath = localSqlPluginPath;
 234     }
 235 
<abbr title=" 236     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 236     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 237         Table table = localTableCache.get(tableAlias);
 238         if(table == null){
 239             table = localTableCache.get(tableName);
 240         }
 241 
 242         if(table == null){
 243             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 244         }
 245 
 246         return table;
 247     }
 248 
 249     /**
<abbr title=" 250      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 250      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 251      *
 252      * @return
 253      */
<abbr title=" 254     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 254     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 255         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 256         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 257             return true;
 258         }
 259         return false;
 260     }
 261 
 262     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 263         List&lt;String&gt; res = Lists.newArrayList();
 264         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 265             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 266         });
 267         return res;
 268     }
 269 
<abbr title=" 270     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 270     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 271         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 272         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 273         List&lt;String&gt; conditionFields = Lists.newArrayList();
 274         for(SqlNode sqlNode : sqlNodeList){
 275             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 276                 throw new RuntimeException(&quot;not compare operator.&quot;);
 277             }
 278 
 279             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 280             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 281 
 282             String leftTableName = left.getComponent(0).getSimple();
 283             String rightTableName = right.getComponent(0).getSimple();
 284 
 285             String tableCol = &quot;&quot;;
 286             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 287                 tableCol = left.getComponent(1).getSimple();
 288             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 289                 tableCol = right.getComponent(1).getSimple();
 290             }else{
<abbr title=" 291                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 291                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 292             }
 293             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 294             conditionFields.add(tableCol);
 295         }
 296 
 297         return conditionFields;
 298     }
 299 
 300     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 301                                      SqlNode pollSqlNode,
 302                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 303 
 304         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 305         if (localTableCache.containsKey(aliasInfo.getName())) {
 306             return;
 307         }
 308 
 309         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 310         tableEnv.registerTable(aliasInfo.getAlias(), table);
 311         localTableCache.put(aliasInfo.getAlias(), table);
 312 
 313         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 314 
 315         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 316         if(fieldReplaceInfo == null){
 317            return;
 318         }
 319 
 320         //as 的源表
 321         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 322         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 323         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 324 
 325     }
 326 
<abbr title=" 327     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv) throws Exception {"> 327     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 328         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 329         JoinScope joinScope = new JoinScope();
 330         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 331         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 332         leftScopeChild.setTableName(joinInfo.getLeftTableName());
<abbr title=" 333         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 333         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 334         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 334         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 335         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 336         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 337         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 338         rightScopeChild.setTableName(joinInfo.getRightTableName());
 339         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 340         if (sideTableInfo == null) {
 341             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 342         }
 343         if (sideTableInfo == null) {
 344             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 345         }
 346         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 347         joinScope.addScope(leftScopeChild);
 348         joinScope.addScope(rightScopeChild);
 349         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) (pollObj)).getTableFieldRef();
 350         // 获取两个表的所有字段
<abbr title=" 351         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 351         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 352         // 通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 353         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 353         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldI🔵</abbr>
 354         String leftTableAlias = joinInfo.getLeftTableAlias();
 355         Table targetTable = localTableCache.get(leftTableAlias);
 356         if (targetTable == null) {
 357             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 358         }
<abbr title=" 359         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 359         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 360         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 361         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 362         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 363             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 363             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 364             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 365             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 366             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 366             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 367         }
 368         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 369         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 370             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 370             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 371         } else {
<abbr title=" 372             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 372             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 373         }
 374         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 375         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 376         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 377         String targetTableName = joinInfo.getNewTableName();
 378         String targetTableAlias = joinInfo.getNewTableAlias();
 379         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 380         replaceInfo.setMappingTable(mappingTable);
 381         replaceInfo.setTargetTableName(targetTableName);
 382         replaceInfo.setTargetTableAlias(targetTableAlias);
<abbr title=" 383         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG, EnvironmentSettings.DEFAULT_BUILTIN_DATABASE, targetTableName);"> 383         ObjectIdentifier objectIdentifier = ObjectIdentifier.of(EnvironmentSettings.DEFAULT_BUILTIN_CATAL🔵</abbr>
<abbr title=" 384         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 384         boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tabl🔵</abbr>
 385         if (!tableExists) {
 386             Table joinTable = tableEnv.fromDataStream(dsOut);
 387             tableEnv.createTemporaryView(targetTableName, joinTable);
 388             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 389         }
 390     }
 391 
 392     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 393         String[] fieldNames = schema.getFieldNames();
 394         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
<abbr title=" 395         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]::new);"> 395         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]:🔵</abbr>
<abbr title=" 396         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 396         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(🔵</abbr>
 397         return new RowTypeInfo(projectedTypes, projectedNames);
 398     }
 399 
 400     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 401         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 402         String fieldsInfo = result.getFieldsInfoStr();
 403         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 404         for (int i = 0; i &lt; fields.length; i++) {
 405             String[] filed = fields[i].split(&quot;\\s&quot;);
 406             if ((filed.length &lt; 2) || (fields.length != table.getSchema().getFieldCount())) {
 407                 return false;
 408             } else {
 409                 String[] filedNameArr = new String[filed.length - 1];
 410                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 411                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 412                 fieldNames.add(fieldName);
 413                 String fieldType = filed[filed.length - 1].trim();
 414                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 415                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 416                 if (fieldClass == tableField) {
 417                     continue;
 418                 } else {
 419                     return false;
 420                 }
 421             }
 422         }
 423         tmpFields = String.join(&quot;,&quot;, fieldNames);
 424         return true;
 425     }
 426 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import org.apache.flink.api.common.typeinfo.Types;</span>
  25  import org.apache.flink.api.java.tuple.Tuple2;
  26  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.api.java.typeutils.TupleTypeInfo;</span>
  28  import org.apache.flink.streaming.api.datastream.DataStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import org.apache.flink.table.api.EnvironmentSettings;</span>
  31  import org.apache.flink.table.api.Table;
  32  import org.apache.flink.table.api.TableSchema;
  33  import org.apache.flink.table.api.java.StreamTableEnvironment;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.flink.table.runtime.CRowKeySelector;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import org.apache.flink.table.runtime.types.CRowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import org.apache.flink.table.catalog.CatalogManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.flink.table.catalog.ObjectIdentifier;</span>
  40  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  41  import org.apache.flink.types.Row;
  42  
  43  import com.dtstack.flink.sql.enums.ECacheType;
  44  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  45  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  46  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  47  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  48  import com.dtstack.flink.sql.util.ClassUtil;
  49  import com.dtstack.flink.sql.util.ParseUtils;
  50  import com.dtstack.flink.sql.util.TableUtils;
  51  import com.google.common.base.Preconditions;
  52  import com.google.common.collect.HashBasedTable;
  53  import com.google.common.collect.Lists;
  54  import com.google.common.collect.Maps;
  55  import com.google.common.collect.Sets;
  56  import org.apache.calcite.sql.SqlBasicCall;
  57  import org.apache.calcite.sql.SqlIdentifier;
  58  import org.apache.calcite.sql.SqlKind;
  59  import org.apache.calcite.sql.SqlNode;
  60  import org.apache.calcite.sql.SqlSelect;
  61  import org.apache.calcite.sql.SqlWithItem;
  62  import org.apache.calcite.sql.parser.SqlParseException;
  63  import org.apache.commons.collections.CollectionUtils;
  64  import org.apache.commons.lang3.StringUtils;
  65  import org.slf4j.Logger;
  66  import org.slf4j.LoggerFactory;
  67  
  68  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import java.time.LocalDateTime;</span>
  70  import java.util.Arrays;
  71  import java.util.LinkedList;
  72  import java.util.List;
  73  import java.util.Map;
  74  import java.util.Queue;
  75  import java.util.Set;
  76  
  77  import static org.apache.calcite.sql.SqlKind.*;
  78  
  79  /**
  80   * Reason:
  81   * Date: 2018/7/24
  82   * Company: www.dtstack.com
  83   * @author xuchao
  84   */
  85  
  86  public class SideSqlExec {
  87  
  88      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  89  
  90      private String localSqlPluginPath = null;
  91  
  92      private String tmpFields = null;
  93  
  94      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  95  
  96      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  97  
  98      public void exec(String sql,
  99                       Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 100                       StreamTableEnvironment tableEnv,
 101                       Map&lt;String, Table&gt; tableCache,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -                     StreamQueryConfig queryConfig,</span>
 103                       CreateTmpTableParser.SqlParserResult createView,
 104                       String scope) throws Exception {
 105          if(localSqlPluginPath == null){
 106              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 107          }
 108  
 109          localTableCache.putAll(tableCache);
 110          try {
 111              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 112          } catch (Exception e) {
 113              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 114          }
 115  
 116          if(createView != null){
 117              LOG.warn(&quot;create view info\n&quot;);
 118              LOG.warn(createView.getExecSql());
 119              LOG.warn(&quot;-----------------&quot;);
 120          }
 121  
 122          SideSQLParser sideSQLParser = new SideSQLParser();
 123          sideSQLParser.setLocalTableCache(localTableCache);
 124          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 125          Object pollObj = null;





 126  
 127          while((pollObj = exeQueue.poll()) != null){
 128  
 129              if(pollObj instanceof SqlNode){
 130                  SqlNode pollSqlNode = (SqlNode) pollObj;
 131  
 132  
 133                  if(pollSqlNode.getKind() == INSERT){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
 136                      if(LOG.isInfoEnabled()){
 137                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 138                      }
 139  
 140                  }else if(pollSqlNode.getKind() == AS){
 141                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 142  
 143                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 144                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 145                      String TableAlias = sqlWithItem.name.toString();
 146                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 147                      tableEnv.registerTable(TableAlias, table);
 148  
 149                  } else if (pollSqlNode.getKind() == SELECT){
 150                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 151                      Table table = tableEnv.sqlQuery(pollObj.toString());
 152  
 153                      if (createView.getFieldsInfoStr() == null){
 154                          tableEnv.registerTable(createView.getTableName(), table);
 155                      } else {
 156                          if (checkFieldsInfo(createView, table)){
 157                              table = table.as(tmpFields);
 158                              tableEnv.registerTable(createView.getTableName(), table);
 159                          } else {
 160                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 161                          }
 162                      }
 163  
 164                      localTableCache.put(createView.getTableName(), table);
 165                  }
 166  
 167              }else if (pollObj instanceof JoinInfo){
 168                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 169                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 170              }
 171          }
 172  
 173      }
 174  
 175  
 176      /**
 177       * 解析出as查询的表和字段的关系
 178       * @param asSqlNode
 179       * @param tableCache
 180       * @return
 181       */
 182      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 183          SqlNode info = asSqlNode.getOperands()[0];
 184          SqlNode alias = asSqlNode.getOperands()[1];
 185  
 186          SqlKind infoKind = info.getKind();
 187          if(infoKind != SELECT){
 188              return null;
 189          }
 190  
 191          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 192  
 193          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 194          for (FieldInfo fieldInfo : extractFieldList) {
 195              String tableName = fieldInfo.getTable();
 196              String fieldName = fieldInfo.getFieldName();
 197              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 198              mappingTable.put(tableName, fieldName, mappingFieldName);
 199          }
 200  
 201          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 202          replaceInfo.setMappingTable(mappingTable);
 203          replaceInfo.setTargetTableName(alias.toString());
 204          replaceInfo.setTargetTableAlias(alias.toString());
 205          return replaceInfo;
 206      }
 207  
 208  
 209      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 210          SqlKind sqlKind = sqlNode.getKind();
 211          if(sqlKind != AS){
 212              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 213          }
 214  
 215          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 216          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 217  
 218          AliasInfo aliasInfo = new AliasInfo();
 219          aliasInfo.setName(info.toString());
 220          aliasInfo.setAlias(alias.toString());
 221  
 222          return aliasInfo;
 223      }
 224  
 225      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 226                                             HashBasedTable&lt;String, String, String&gt; mappingTable) {
 227          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 228          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 229          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 230              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 231              String tableName = fieldInfo.getTable();
 232              String fieldName = fieldInfo.getFieldName();
 233  
 234              String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 235              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 235              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr>
 236  
 237              sideOutTypes[i] = fieldInfo.getTypeInformation();
 238              sideOutNames[i] = mappingFieldName;
 239          }
 240          return new RowTypeInfo(sideOutTypes, sideOutNames);
 241      }
 242  
 243  
 244  
 245      /**
 246       *  对时间类型进行类型转换
 247       * @param leftTypeInfo
 248       * @return
 249       */
 250      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 251          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 252          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 253          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 254              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 255          }
 256          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 257          return rowTypeInfo;
 258      }
 259  
 260      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 261          if (typeInformation instanceof TimeIndicatorTypeInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -            return TypeInformation.of(Timestamp.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +            return TypeInformation.of(LocalDateTime.class);</span>
 264          }
 265          return typeInformation;
 266      }
 267  
 268  
 269  
 270  
 271  
 272  
 273      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 274          this.localSqlPluginPath = localSqlPluginPath;
 275      }
 276  
 277      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 278          Table table = localTableCache.get(tableAlias);
 279          if(table == null){
 280              table = localTableCache.get(tableName);
 281          }
 282  
 283          if(table == null){
 284              throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 285          }
 286  
 287          return table;
 288      }
 289  
 290  
 291      /**
<abbr title=" 292       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 292       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 293       *
 294       * @return
 295       */
<abbr title=" 296      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 296      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 297          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 298          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 299              return true;
 300          }
 301          return false;
 302      }
 303  
 304      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 305          List&lt;String&gt; res = Lists.newArrayList();
 306          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 307              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 308          });
 309          return res;
 310      }
 311  
<abbr title=" 312      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 312      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 313          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 314          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 315          List&lt;String&gt; conditionFields = Lists.newArrayList();
 316          for(SqlNode sqlNode : sqlNodeList){
 317              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 318                  throw new RuntimeException(&quot;not compare operator.&quot;);
 319              }
 320  
 321              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 322              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 323  
 324              String leftTableName = left.getComponent(0).getSimple();
 325              String rightTableName = right.getComponent(0).getSimple();
 326  
 327              String tableCol = &quot;&quot;;
 328              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 329                  tableCol = left.getComponent(1).getSimple();
 330              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 331                  tableCol = right.getComponent(1).getSimple();
 332              }else{
<abbr title=" 333                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 333                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 334              }
 335              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 336              conditionFields.add(tableCol);
 337          }
 338  
 339          return conditionFields;
 340      }
 341  
 342      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 343                                       SqlNode pollSqlNode,
 344                                       Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 345  
 346          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 347          if (localTableCache.containsKey(aliasInfo.getName())) {
 348              return;
 349          }
 350  
 351          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 352          tableEnv.registerTable(aliasInfo.getAlias(), table);
 353          localTableCache.put(aliasInfo.getAlias(), table);
 354  
 355          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 356  
 357          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 358          if(fieldReplaceInfo == null){
 359             return;
 360          }
 361  
 362          //as 的源表
 363          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 364          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 365          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 366  
 367      }
 368  
 369      private void joinFun(Object pollObj,
 370                           Map&lt;String, Table&gt; localTableCache,
 371                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 372                           StreamTableEnvironment tableEnv) throws Exception{
 373          JoinInfo joinInfo = (JoinInfo) pollObj;
 374  
 375          JoinScope joinScope = new JoinScope();
 376          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 377          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 378          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 379  
<abbr title=" 380          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 380          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 381 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 381 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 383 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 383 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().ge🔵</abbr></span>
 384          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 385  
 386          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 387          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 388          rightScopeChild.setTableName(joinInfo.getRightTableName());
 389          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 390          if(sideTableInfo == null){
 391              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 392          }
 393  
 394          if(sideTableInfo == null){
 395              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 396          }
 397  
 398          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 399  
 400          joinScope.addScope(leftScopeChild);
 401          joinScope.addScope(rightScopeChild);
 402  
 403          HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 404  
 405          //获取两个表的所有字段
<abbr title=" 406          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 406          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 407          //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 408          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 408          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr>
 409  
 410          String leftTableAlias = joinInfo.getLeftTableAlias();
 411          Table targetTable = localTableCache.get(leftTableAlias);
 412          if(targetTable == null){
 413              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 414          }
 415  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 416 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 416 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 417 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 418 -        DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 419 -                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 420 -                    return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -                }).returns(CRow.class);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 422 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 423 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 423 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().ge🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 425 +        DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);</span>
 426  
 427          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 428          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 429              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 429              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 430              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 431              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 432 -            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 432 -            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 433 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 435 -        DataStream&lt;CRow&gt; dsOut = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 436 +            adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 436 +            adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 438 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +        DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;</span>
 440          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 441              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 441              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 442          }else{
<abbr title=" 443              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 443              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 444          }
 445  
 446          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 447  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -        CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -        dsOut.getTransformation().setOutputType(cRowTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 450 +        TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +        dsOut.getTransformation().setOutputType(tupleTypeInfo);</span>
 452  
 453          String targetTableName = joinInfo.getNewTableName();
 454          String targetTableAlias = joinInfo.getNewTableAlias();
 455  
 456          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 457          replaceInfo.setMappingTable(mappingTable);
 458          replaceInfo.setTargetTableName(targetTableName);
 459          replaceInfo.setTargetTableAlias(targetTableAlias);
 460  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -        if (!tableEnv.isRegistered(targetTableName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +        ObjectIdentifier objectIdentifier = ObjectIdentifier.of(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +                EnvironmentSettings.DEFAULT_BUILTIN_CATALOG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 464 +                EnvironmentSettings.DEFAULT_BUILTIN_DATABASE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +                targetTableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 466 +        boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(objectIdentifier.toObjectPath());"> 466 +        boolean tableExists = tableEnv.getCatalog(EnvironmentSettings.DEFAULT_BUILTIN_CATALOG).get().tableExists(o🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +        if (!tableExists){</span>
 469              Table joinTable = tableEnv.fromDataStream(dsOut);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 470 -            tableEnv.registerTable(targetTableName, joinTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +            tableEnv.createTemporaryView(targetTableName, joinTable);</span>
 472              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 473          }
 474      }
 475  
 476      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 477          String[] fieldNames = schema.getFieldNames();
 478          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 479  
 480          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 481          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 481          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 482          return new RowTypeInfo(projectedTypes, projectedNames);
 483      }
 484  
 485  
 486      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 487          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 488          String fieldsInfo = result.getFieldsInfoStr();
 489          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 490          for (int i = 0; i &lt; fields.length; i++) {
 491              String[] filed = fields[i].split(&quot;\\s&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -            if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +            if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){</span>
 494                  return false;
 495              } else {
 496                  String[] filedNameArr = new String[filed.length - 1];
 497                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 498                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 499                  fieldNames.add(fieldName);
 500                  String fieldType = filed[filed.length - 1 ].trim();
 501                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 502                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 503                  if (fieldClass == tableField){
 504                      continue;
 505                  } else {
 506                      return false;
 507                  }
 508              }
 509          }
 510          tmpFields = String.join(&quot;,&quot;, fieldNames);
 511          return true;
 512      }
 513  
 514  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;

  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;

  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;

  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;



  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
  50  import org.apache.calcite.sql.SqlBasicCall;
  51  import org.apache.calcite.sql.SqlIdentifier;
  52  import org.apache.calcite.sql.SqlKind;
  53  import org.apache.calcite.sql.SqlNode;
  54  import org.apache.calcite.sql.SqlSelect;
  55  import org.apache.calcite.sql.SqlWithItem;
  56  import org.apache.calcite.sql.parser.SqlParseException;
  57  import org.apache.commons.collections.CollectionUtils;
  58  import org.apache.commons.lang3.StringUtils;
  59  import org.slf4j.Logger;
  60  import org.slf4j.LoggerFactory;
  61  
  62  import java.sql.Timestamp;

  63  import java.util.Arrays;
  64  import java.util.LinkedList;
  65  import java.util.List;
  66  import java.util.Map;
  67  import java.util.Queue;
  68  import java.util.Set;
  69  
  70  import static org.apache.calcite.sql.SqlKind.*;
  71  
  72  /**
  73   * Reason:
  74   * Date: 2018/7/24
  75   * Company: www.dtstack.com
  76   * @author xuchao
  77   */
  78  
  79  public class SideSqlExec {
  80  
  81      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  82  
  83      private String localSqlPluginPath = null;
  84  
  85      private String tmpFields = null;
  86  
  87      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  88  
  89      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  90  
  91      public void exec(String sql,
  92                       Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  93                       StreamTableEnvironment tableEnv,
  94                       Map&lt;String, Table&gt; tableCache,
  95                       StreamQueryConfig queryConfig,
  96                       CreateTmpTableParser.SqlParserResult createView,
  97                       String scope) throws Exception {
  98          if(localSqlPluginPath == null){
  99              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 100          }
 101  
 102          localTableCache.putAll(tableCache);
 103          try {
 104              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 105          } catch (Exception e) {
 106              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 107          }
 108  
 109          if(createView != null){
 110              LOG.warn(&quot;create view info\n&quot;);
 111              LOG.warn(createView.getExecSql());
 112              LOG.warn(&quot;-----------------&quot;);
 113          }
 114  
 115          SideSQLParser sideSQLParser = new SideSQLParser();
 116          sideSQLParser.setLocalTableCache(localTableCache);
 117          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -        Object pollObj = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +        Object pollObj;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +        //need clean</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +        boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +        List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
 124  
 125          while((pollObj = exeQueue.poll()) != null){
 126  
 127              if(pollObj instanceof SqlNode){
 128                  SqlNode pollSqlNode = (SqlNode) pollObj;
 129  
 130  
 131                  if(pollSqlNode.getKind() == INSERT){
 132                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);

 133                      if(LOG.isInfoEnabled()){
 134                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 135                      }
 136  
 137                  }else if(pollSqlNode.getKind() == AS){
 138                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 139  
 140                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 141                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 142                      String TableAlias = sqlWithItem.name.toString();
 143                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 144                      tableEnv.registerTable(TableAlias, table);
 145  
 146                  } else if (pollSqlNode.getKind() == SELECT){
 147                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 148                      Table table = tableEnv.sqlQuery(pollObj.toString());
 149  
 150                      if (createView.getFieldsInfoStr() == null){
 151                          tableEnv.registerTable(createView.getTableName(), table);
 152                      } else {
 153                          if (checkFieldsInfo(createView, table)){
 154                              table = table.as(tmpFields);
 155                              tableEnv.registerTable(createView.getTableName(), table);
 156                          } else {
 157                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 158                          }
 159                      }
 160  
 161                      localTableCache.put(createView.getTableName(), table);
 162                  }
 163  
 164              }else if (pollObj instanceof JoinInfo){
 165                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 166                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 167              }
 168          }
 169  
 170      }
 171  
 172  
 173      /**
 174       * 解析出as查询的表和字段的关系
 175       * @param asSqlNode
 176       * @param tableCache
 177       * @return
 178       */
 179      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 180          SqlNode info = asSqlNode.getOperands()[0];
 181          SqlNode alias = asSqlNode.getOperands()[1];
 182  
 183          SqlKind infoKind = info.getKind();
 184          if(infoKind != SELECT){
 185              return null;
 186          }
 187  
 188          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 189  
 190          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 191          for (FieldInfo fieldInfo : extractFieldList) {
 192              String tableName = fieldInfo.getTable();
 193              String fieldName = fieldInfo.getFieldName();
 194              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 195              mappingTable.put(tableName, fieldName, mappingFieldName);
 196          }
 197  
 198          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 199          replaceInfo.setMappingTable(mappingTable);
 200          replaceInfo.setTargetTableName(alias.toString());
 201          replaceInfo.setTargetTableAlias(alias.toString());
 202          return replaceInfo;
 203      }
 204  
 205  
 206      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 207          SqlKind sqlKind = sqlNode.getKind();
 208          if(sqlKind != AS){
 209              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 210          }
 211  
 212          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 213          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 214  
 215          AliasInfo aliasInfo = new AliasInfo();
 216          aliasInfo.setName(info.toString());
 217          aliasInfo.setAlias(alias.toString());
 218  
 219          return aliasInfo;
 220      }
 221  
 222      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 223                                             HashBasedTable&lt;String, String, String&gt; mappingTable) {
 224          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 225          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 226          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 227              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 228              String tableName = fieldInfo.getTable();
 229              String fieldName = fieldInfo.getFieldName();
 230  
 231              String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 232              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 232              Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr>
 233  
 234              sideOutTypes[i] = fieldInfo.getTypeInformation();
 235              sideOutNames[i] = mappingFieldName;
 236          }
 237          return new RowTypeInfo(sideOutTypes, sideOutNames);
 238      }
 239  
 240  
 241  
 242      /**
 243       *  对时间类型进行类型转换
 244       * @param leftTypeInfo
 245       * @return
 246       */
 247      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 248          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 249          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 250          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 251              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 252          }
 253          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 254          return rowTypeInfo;
 255      }
 256  
 257      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 258          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 259              return TypeInformation.of(Timestamp.class);

 260          }
 261          return typeInformation;
 262      }
 263  
 264  
 265  
 266  
 267  
 268  
 269      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 270          this.localSqlPluginPath = localSqlPluginPath;
 271      }
 272  
 273      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 274          Table table = localTableCache.get(tableAlias);
 275          if(table == null){
 276              table = localTableCache.get(tableName);
 277          }
 278  
 279          if(table == null){
 280              throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 281          }
 282  
 283          return table;
 284      }
 285  
 286  
 287      /**
<abbr title=" 288       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 288       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 289       *
 290       * @return
 291       */
<abbr title=" 292      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 292      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 293          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 294          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 295              return true;
 296          }
 297          return false;
 298      }
 299  
 300      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 301          List&lt;String&gt; res = Lists.newArrayList();
 302          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 303              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 304          });
 305          return res;
 306      }
 307  
<abbr title=" 308      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 308      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 309          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 310          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 311          List&lt;String&gt; conditionFields = Lists.newArrayList();
 312          for(SqlNode sqlNode : sqlNodeList){
 313              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 314                  throw new RuntimeException(&quot;not compare operator.&quot;);
 315              }
 316  
 317              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 318              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 319  
 320              String leftTableName = left.getComponent(0).getSimple();
 321              String rightTableName = right.getComponent(0).getSimple();
 322  
 323              String tableCol = &quot;&quot;;
 324              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 325                  tableCol = left.getComponent(1).getSimple();
 326              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 327                  tableCol = right.getComponent(1).getSimple();
 328              }else{
<abbr title=" 329                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 329                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 330              }
 331              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 332              conditionFields.add(tableCol);
 333          }
 334  
 335          return conditionFields;
 336      }
 337  
 338      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 339                                       SqlNode pollSqlNode,
 340                                       Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 341  
 342          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 343          if (localTableCache.containsKey(aliasInfo.getName())) {
 344              return;
 345          }
 346  
 347          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 348          tableEnv.registerTable(aliasInfo.getAlias(), table);
 349          localTableCache.put(aliasInfo.getAlias(), table);
 350  
 351          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 352  
 353          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 354          if(fieldReplaceInfo == null){
 355             return;
 356          }
 357  
 358          //as 的源表
 359          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 360          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 361          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 362  
 363      }
 364  
 365      private void joinFun(Object pollObj,
 366                           Map&lt;String, Table&gt; localTableCache,
 367                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 368                           StreamTableEnvironment tableEnv) throws Exception{
 369          JoinInfo joinInfo = (JoinInfo) pollObj;
 370  
 371          JoinScope joinScope = new JoinScope();
 372          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 373          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 374          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 375  
<abbr title=" 376          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 376          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 377          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 377          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>


 378          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 379  
 380          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 381          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 382          rightScopeChild.setTableName(joinInfo.getRightTableName());
 383          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 384          if(sideTableInfo == null){
 385              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 386          }
 387  
 388          if(sideTableInfo == null){
 389              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 390          }
 391  
 392          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 393  
 394          joinScope.addScope(leftScopeChild);
 395          joinScope.addScope(rightScopeChild);
 396  
 397          HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 398  
 399          //获取两个表的所有字段
<abbr title=" 400          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 400          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 401          //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 402          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 402          sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr>
 403  
 404          String leftTableAlias = joinInfo.getLeftTableAlias();
 405          Table targetTable = localTableCache.get(leftTableAlias);
 406          if(targetTable == null){
 407              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 408          }
 409  
<abbr title=" 410          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 410          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 411  
 412          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 413                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 414                      return new CRow(tp2.f1, tp2.f0);
 415                  }).returns(CRow.class);
 416  



 417  
 418          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 419          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 420              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 420              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 421              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 422              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 423              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 423              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 424          }
 425  
 426          DataStream&lt;CRow&gt; dsOut = null;




 427          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 428              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 428              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 429          }else{
<abbr title=" 430              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 430              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 431          }
 432  
 433          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 434  
 435          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 436          dsOut.getTransformation().setOutputType(cRowTypeInfo);


 437  
 438          String targetTableName = joinInfo.getNewTableName();
 439          String targetTableAlias = joinInfo.getNewTableAlias();
 440  
 441          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 442          replaceInfo.setMappingTable(mappingTable);
 443          replaceInfo.setTargetTableName(targetTableName);
 444          replaceInfo.setTargetTableAlias(targetTableAlias);
 445  
 446          if (!tableEnv.isRegistered(targetTableName)){







 447              Table joinTable = tableEnv.fromDataStream(dsOut);
 448              tableEnv.registerTable(targetTableName, joinTable);

 449              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 450          }
 451      }
 452  
 453      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 454          String[] fieldNames = schema.getFieldNames();
 455          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 456  
 457          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 458          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 458          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 459          return new RowTypeInfo(projectedTypes, projectedNames);
 460      }
 461  
 462  
 463      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 464          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 465          String fieldsInfo = result.getFieldsInfoStr();
 466          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 467          for (int i = 0; i &lt; fields.length; i++) {
 468              String[] filed = fields[i].split(&quot;\\s&quot;);
 469              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){

 470                  return false;
 471              } else {
 472                  String[] filedNameArr = new String[filed.length - 1];
 473                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 474                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 475                  fieldNames.add(fieldName);
 476                  String fieldType = filed[filed.length - 1 ].trim();
 477                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 478                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 479                  if (fieldClass == tableField){
 480                      continue;
 481                  } else {
 482                      return false;
 483                  }
 484              }
 485          }
 486          tmpFields = String.join(&quot;,&quot;, fieldNames);
 487          return true;
 488      }
 489  
 490  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            