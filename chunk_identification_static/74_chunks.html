<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>74 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public class DownloadSchedulers implements &#x27;
                         &#x27;IDownloadSchedulers {\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务预加载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;PRE      = 0;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务开始\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;START    = 1;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;STOP     = 2;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;FAIL     = 3;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;CANCEL   = 4;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;COMPLETE = 5;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;RUNNING  = 6;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 恢复下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;RESUME   = 7;\n&#x27;
                         &#x27;  private static final    String             &#x27;
                         &#x27;TAG      = &quot;DownloadSchedulers&quot;;\n&#x27;
                         &#x27;  private static final    Object             &#x27;
                         &#x27;LOCK     = new Object();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class DownloadSchedulers implements &#x27;
                           &#x27;ISchedulers&lt;DownloadTask&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;DownloadSchedulers&quot;;\n&#x27;
                           &#x27;  private static final Object LOCK = new &#x27;
                           &#x27;Object();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  Map&lt;String, OnSchedulerListener&gt; &#x27;
                         &#x27;mSchedulerListeners = new ConcurrentHashMap&lt;&gt;();\n&#x27;
                         &#x27;  DownloadManager                  &#x27;
                         &#x27;mManager            = &#x27;
                         &#x27;DownloadManager.getInstance();\n&#x27;
                         &#x27;  ITaskQueue mQueue;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private Map&lt;String, &#x27;
                           &#x27;IDownloadSchedulerListener&lt;DownloadTask&gt;&gt; &#x27;
                           &#x27;mSchedulerListeners =\n&#x27;
                           &#x27;      new ConcurrentHashMap&lt;&gt;();\n&#x27;
                           &#x27;  private DownloadTaskQueue mQueue;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        //mQueue.removeTask(entity);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        //mQueue.removeTask(entity);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  @Override public void handleFailTask(final Task &#x27;
                         &#x27;task) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private void handleFailTask(final DownloadTask &#x27;
                           &#x27;task) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (entity.getFailNum() &lt;= &#x27;
                         &#x27;config.getReTryNum()) {\n&#x27;
                         &#x27;          Task task = mQueue.getTask(entity);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (entity.getFailNum() &lt; &#x27;
                           &#x27;config.getReTryNum()) {\n&#x27;
                           &#x27;          DownloadTask task = &#x27;
                           &#x27;mQueue.getTask(entity);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;          startNextTask(entity);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;          startNextTask();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  @Override public void handleFailTask(final Task &#x27;
                         &#x27;task) {\n&#x27;
                         &#x27;    final Configuration config = &#x27;
                         &#x27;Configuration.getInstance();\n&#x27;
                         &#x27;    CountDownTimer timer = new &#x27;
                         &#x27;CountDownTimer(config.getReTryInterval(), 1000) {\n&#x27;
                         &#x27;      @Override public void onTick(long &#x27;
                         &#x27;millisUntilFinished) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      @Override public void onFinish() {\n&#x27;
                         &#x27;        DownloadEntity entity = &#x27;
                         &#x27;task.getDownloadEntity();\n&#x27;
                         &#x27;        if (entity.getFailNum() &lt;= &#x27;
                         &#x27;config.getReTryNum()) {\n&#x27;
                         &#x27;          Task task = mQueue.getTask(entity);\n&#x27;
                         &#x27;          mQueue.reTryStart(task);\n&#x27;
                         &#x27;          try {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;Thread.sleep(config.getReTryInterval());\n&#x27;
                         &#x27;          } catch (InterruptedException e) {\n&#x27;
                         &#x27;            e.printStackTrace();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mQueue.removeTask(entity);\n&#x27;
                         &#x27;          startNextTask(entity);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    };\n&#x27;
                         &#x27;    timer.start();\n&#x27;
                         &#x27;  }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private void handleFailTask(final DownloadTask &#x27;
                           &#x27;task) {\n&#x27;
                           &#x27;    final Configuration config = &#x27;
                           &#x27;Configuration.getInstance();\n&#x27;
                           &#x27;    CountDownTimer timer = new &#x27;
                           &#x27;CountDownTimer(config.getReTryInterval(), 1000) {\n&#x27;
                           &#x27;      @Override public void onTick(long &#x27;
                           &#x27;millisUntilFinished) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      @Override public void onFinish() {\n&#x27;
                           &#x27;        DownloadEntity entity = &#x27;
                           &#x27;task.getDownloadEntity();\n&#x27;
                           &#x27;        if (entity.getFailNum() &lt; &#x27;
                           &#x27;config.getReTryNum()) {\n&#x27;
                           &#x27;          DownloadTask task = &#x27;
                           &#x27;mQueue.getTask(entity);\n&#x27;
                           &#x27;          mQueue.reTryStart(task);\n&#x27;
                           &#x27;          try {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;Thread.sleep(config.getReTryInterval());\n&#x27;
                           &#x27;          } catch (InterruptedException e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mQueue.removeTask(entity);\n&#x27;
                           &#x27;          startNextTask();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;    timer.start();\n&#x27;
                           &#x27;  }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;Task\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\nDownloadTask\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public class DownloadSchedulers implements &#x27;
                         &#x27;IDownloadSchedulers {\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务预加载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;PRE      = 0;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务开始\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;START    = 1;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务停止\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;STOP     = 2;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务失败\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;FAIL     = 3;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务取消\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;CANCEL   = 4;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 任务完成\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;COMPLETE = 5;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 下载中\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;RUNNING  = 6;\n&#x27;
                         &#x27;  /**\n&#x27;
                         &#x27;   * 恢复下载\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  public static final     int                &#x27;
                         &#x27;RESUME   = 7;\n&#x27;
                         &#x27;  private static final    String             &#x27;
                         &#x27;TAG      = &quot;DownloadSchedulers&quot;;\n&#x27;
                         &#x27;  private static final    Object             &#x27;
                         &#x27;LOCK     = new Object();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public class DownloadSchedulers implements &#x27;
                           &#x27;ISchedulers&lt;DownloadTask&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  private static final String TAG = &#x27;
                           &#x27;&quot;DownloadSchedulers&quot;;\n&#x27;
                           &#x27;  private static final Object LOCK = new &#x27;
                           &#x27;Object();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  Map&lt;String, OnSchedulerListener&gt; &#x27;
                         &#x27;mSchedulerListeners = new ConcurrentHashMap&lt;&gt;();\n&#x27;
                         &#x27;  DownloadManager                  &#x27;
                         &#x27;mManager            = &#x27;
                         &#x27;DownloadManager.getInstance();\n&#x27;
                         &#x27;  ITaskQueue mQueue;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private Map&lt;String, &#x27;
                           &#x27;IDownloadSchedulerListener&lt;DownloadTask&gt;&gt; &#x27;
                           &#x27;mSchedulerListeners =\n&#x27;
                           &#x27;      new ConcurrentHashMap&lt;&gt;();\n&#x27;
                           &#x27;  private DownloadTaskQueue mQueue;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;Task\n&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\nDownloadTask\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        //mQueue.removeTask(entity);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        //mQueue.removeTask(entity);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;  @Override public void handleFailTask(final Task &#x27;
                         &#x27;task) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private void handleFailTask(final DownloadTask &#x27;
                           &#x27;task) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;  @Override public void handleFailTask(final Task &#x27;
                         &#x27;task) {\n&#x27;
                         &#x27;    final Configuration config = &#x27;
                         &#x27;Configuration.getInstance();\n&#x27;
                         &#x27;    CountDownTimer timer = new &#x27;
                         &#x27;CountDownTimer(config.getReTryInterval(), 1000) {\n&#x27;
                         &#x27;      @Override public void onTick(long &#x27;
                         &#x27;millisUntilFinished) {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;      @Override public void onFinish() {\n&#x27;
                         &#x27;        DownloadEntity entity = &#x27;
                         &#x27;task.getDownloadEntity();\n&#x27;
                         &#x27;        if (entity.getFailNum() &lt;= &#x27;
                         &#x27;config.getReTryNum()) {\n&#x27;
                         &#x27;          Task task = mQueue.getTask(entity);\n&#x27;
                         &#x27;          mQueue.reTryStart(task);\n&#x27;
                         &#x27;          try {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;Thread.sleep(config.getReTryInterval());\n&#x27;
                         &#x27;          } catch (InterruptedException e) {\n&#x27;
                         &#x27;            e.printStackTrace();\n&#x27;
                         &#x27;          }\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;          mQueue.removeTask(entity);\n&#x27;
                         &#x27;          startNextTask(entity);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;      }\n&#x27;
                         &#x27;    };\n&#x27;
                         &#x27;    timer.start();\n&#x27;
                         &#x27;  }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;  private void handleFailTask(final DownloadTask &#x27;
                           &#x27;task) {\n&#x27;
                           &#x27;    final Configuration config = &#x27;
                           &#x27;Configuration.getInstance();\n&#x27;
                           &#x27;    CountDownTimer timer = new &#x27;
                           &#x27;CountDownTimer(config.getReTryInterval(), 1000) {\n&#x27;
                           &#x27;      @Override public void onTick(long &#x27;
                           &#x27;millisUntilFinished) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;      @Override public void onFinish() {\n&#x27;
                           &#x27;        DownloadEntity entity = &#x27;
                           &#x27;task.getDownloadEntity();\n&#x27;
                           &#x27;        if (entity.getFailNum() &lt; &#x27;
                           &#x27;config.getReTryNum()) {\n&#x27;
                           &#x27;          DownloadTask task = &#x27;
                           &#x27;mQueue.getTask(entity);\n&#x27;
                           &#x27;          mQueue.reTryStart(task);\n&#x27;
                           &#x27;          try {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;Thread.sleep(config.getReTryInterval());\n&#x27;
                           &#x27;          } catch (InterruptedException e) {\n&#x27;
                           &#x27;            e.printStackTrace();\n&#x27;
                           &#x27;          }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;          mQueue.removeTask(entity);\n&#x27;
                           &#x27;          startNextTask();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    };\n&#x27;
                           &#x27;    timer.start();\n&#x27;
                           &#x27;  }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (entity.getFailNum() &lt;= &#x27;
                         &#x27;config.getReTryNum()) {\n&#x27;
                         &#x27;          Task task = mQueue.getTask(entity);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if (entity.getFailNum() &lt; &#x27;
                           &#x27;config.getReTryNum()) {\n&#x27;
                           &#x27;          DownloadTask task = &#x27;
                           &#x27;mQueue.getTask(entity);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;          startNextTask(entity);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;          startNextTask();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        