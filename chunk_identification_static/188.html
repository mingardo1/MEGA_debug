<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>188</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    188
                    <a href="187.html">prev</a>
                    <a href="189.html">next</a>
                    <a href="188_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_692aea06e8e2a934cbc3b09e2c86512228ca614b_core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/util/service/ResourcePurgeServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;692aea06e8e2a934cbc3b09e2c86512228ca614b:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/util/service/ResourcePurgeServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;692aea06e8e2a934cbc3b09e2c86512228ca614b^1:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/util/service/ResourcePurgeServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;692aea06e8e2a934cbc3b09e2c86512228ca614b^2:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/util/service/ResourcePurgeServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;750f8f9bf103dbaee3d988a7c3332eba9d3b9933:core/broadleaf-framework/src/main/java/org/broadleafcommerce/core/util/service/ResourcePurgeServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b]], subset: [[b], [b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.util.service;
  19 
  20 import org.apache.commons.collections.MapUtils;
  21 import org.apache.commons.logging.Log;
  22 import org.apache.commons.logging.LogFactory;
  23 import org.broadleafcommerce.common.exception.ServiceException;
  24 import org.broadleafcommerce.common.notification.service.NotificationDispatcher;
  25 import org.broadleafcommerce.common.notification.service.type.EmailNotification;
  26 import org.broadleafcommerce.common.notification.service.type.NotificationEventType;
  27 import org.broadleafcommerce.common.time.SystemTime;
  28 import org.broadleafcommerce.common.util.TransactionUtils;
  29 import org.broadleafcommerce.core.order.domain.Order;
  30 import org.broadleafcommerce.core.order.domain.OrderImpl;
  31 import org.broadleafcommerce.core.order.service.OrderService;
  32 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  33 import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;
  34 import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;
  35 import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;
  36 import org.broadleafcommerce.core.util.service.type.PurgeOrderHistoryVariableNames;
  37 import org.broadleafcommerce.profile.core.domain.Customer;
  38 import org.broadleafcommerce.profile.core.service.CustomerService;
  39 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  40 import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41 import org.springframework.beans.factory.annotation.Qualifier;</span>
  42 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  43 import org.broadleafcommerce.core.order.domain.Order;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import org.broadleafcommerce.core.order.service.OrderService;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45 import org.broadleafcommerce.core.order.service.type.OrderStatus;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46 import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 import org.broadleafcommerce.profile.core.domain.Customer;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  50 import org.broadleafcommerce.profile.core.service.CustomerService;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  51 import org.springframework.stereotype.Service;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  52 import org.springframework.transaction.PlatformTransactionManager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  53 import org.springframework.transaction.TransactionDefinition;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  54 import org.springframework.transaction.TransactionStatus;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  55 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  56 /**</span>
  57 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  58 import org.hibernate.Session;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  59 import org.hibernate.jdbc.Work;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  60 import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  61 import org.springframework.core.env.Environment;</span>
  62 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  63 import org.springframework.stereotype.Service;
  64 import org.springframework.transaction.PlatformTransactionManager;
  65 import org.springframework.transaction.TransactionDefinition;
  66 import org.springframework.transaction.TransactionStatus;
  67 
  68 import java.sql.Connection;
  69 import java.sql.SQLException;
  70 import java.sql.Statement;
  71 import java.util.*;
  72 
  73 import javax.annotation.Resource;
  74 import javax.persistence.EntityManager;
  75 import javax.persistence.PersistenceContext;
  76 
  77 
  78 /**
<abbr title="  79  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous Customers).">  79  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymoðŸ”µ</abbr>
  80  * {@link ResourcePurgeService} for additional API documentation.
  81  * &lt;p/&gt;
  82  * A basic Quartz scheduled job configuration for calling this service can be configured as follows:
  83  * &lt;p/&gt;
  84  * {@code
  85  * &lt;bean id=&quot;purgeCartConfig&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
  86  * &lt;property name=&quot;sourceMap&quot;&gt;
  87  * &lt;map&gt;
  88  * &lt;entry key=&quot;SECONDS_OLD&quot; value=&quot;2592000&quot;/&gt;
  89  * &lt;entry key=&quot;STATUS&quot; value=&quot;IN_PROCESS&quot;/&gt;
  90  * &lt;/map&gt;
  91  * &lt;/property&gt;
  92  * &lt;/bean&gt;
  93  * &lt;p/&gt;
<abbr title="  94  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;">  94  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactðŸ”µ</abbr>
  95  * &lt;property name=&quot;targetObject&quot; ref=&quot;blResourcePurgeService&quot; /&gt;
  96  * &lt;property name=&quot;targetMethod&quot; value=&quot;purgeCarts&quot; /&gt;
  97  * &lt;property name=&quot;arguments&quot;&gt;
  98  * &lt;list&gt;
  99  * &lt;ref bean=&quot;purgeCartConfig&quot;/&gt;
 100  * &lt;/list&gt;
 101  * &lt;/property&gt;
 102  * &lt;/bean&gt;
 103  * &lt;p/&gt;
 104  * &lt;bean id=&quot;purgeCartTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;
 105  * &lt;property name=&quot;jobDetail&quot; ref=&quot;purgeCartJobDetail&quot; /&gt;
 106  * &lt;property name=&quot;startDelay&quot; value=&quot;30000&quot; /&gt;
 107  * &lt;property name=&quot;repeatInterval&quot; value=&quot;86400000&quot; /&gt;
 108  * &lt;/bean&gt;
 109  * }
 110  *
 111  * @author Jeff Fischer
 112  */
 113 @Service(&quot;blResourcePurgeService&quot;)
 114 public class ResourcePurgeServiceImpl implements ResourcePurgeService {
 115 
 116     private static final Log LOG = LogFactory.getLog(ResourcePurgeServiceImpl.class);
 117 
 118     private static final Long BATCH_SIZE = 50L;
<abbr title=" 119     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48 HOURS"> 119     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48ðŸ”µ</abbr>
 120 
 121     protected PurgeErrorCache customerPurgeErrors = new PurgeErrorCache();
 122     protected PurgeErrorCache historyPurgeErrors = new PurgeErrorCache();
 123     protected PurgeErrorCache cartPurgeErrors = new PurgeErrorCache();
 124 
 125     @Resource(name = &quot;blTransactionManager&quot;)
 126     protected PlatformTransactionManager transactionManager;
 127 
 128     @Resource(name = &quot;blResourcePurgeDao&quot;)
 129     protected ResourcePurgeDao resourcePurgeDao;
 130 
 131     @Resource(name = &quot;blOrderService&quot;)
 132     protected OrderService orderService;
 133 
 134     @Resource(name = &quot;blCustomerService&quot;)
 135     protected CustomerService customerService;
 136 
 137 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 138     @Autowired</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 139     @Qualifier(&quot;blNotificationDispatcher&quot;)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 140     protected NotificationDispatcher notificationDispatcher;</span>
 141 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 142             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +"> 142             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration proviðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146         int processedCount = 0, batchCount = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147         synchronized(cartPurgeErrors) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148             Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 149             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();"> 149             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue(ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 150             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));"> 150             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCarðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151             for (Order cart : carts) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 153                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154                 try {</span>
 155 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156     @Resource(name = &quot;blDeleteStatementGenerator&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 157     protected DeleteStatementGenerator deleteStatementGenerator;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 159     @Autowired</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 160     protected Environment env;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 161 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162     @PersistenceContext(unitName = &quot;blPU&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163     protected EntityManager em;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 164 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 165     @Resource(name = &quot;blResourcePurgeExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 166     protected ResourcePurgeExtensionManager extensionManager;</span>
 167 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 168 
 169     @Override
 170     public void purgeCarts(final Map&lt;String, String&gt; config) {
 171         if (LOG.isDebugEnabled()) {
 172             LOG.debug(&quot;Purging carts&quot;);
 173         }
 174         if (MapUtils.isEmpty(config)) {
<abbr title=" 175             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +"> 175             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration proviðŸ”µ</abbr>
 176                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 177         }
 178         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 179         int processedCount = 0, batchCount = 0;
 180         synchronized (cartPurgeErrors) {
 181             Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
<abbr title=" 182             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();"> 182             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue(ðŸ”µ</abbr>
<abbr title=" 183             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));"> 183             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCarðŸ”µ</abbr>
 184             for (Order cart : carts) {
 185                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 186                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 187                 try {
 188                     deleteCart(cart);
 189                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 190                     processedCount++;
 191                 } catch (Exception e) {
 192                     if (!status.isCompleted()) {
 193                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 194                     }
 195                     LOG.error(String.format(&quot;Not able to purge Cart ID: %d&quot;, cart.getId()), e);
 196                     cartPurgeErrors.add(cart.getId());
 197                 }
 198             }
 199         }
<abbr title=" 200         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, cartPurgeErrors.size()));"> 200         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d faðŸ”µ</abbr>
 201     }
 202 
 203     @Override
 204 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 205     public void notifyCarts(final Map&lt;String, String&gt; config) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 206         if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 207             LOG.debug(&quot;Notifying carts of purge&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 208         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 209         if (MapUtils.isEmpty(config)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 210             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuration provided. &quot; +"> 210             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuraðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 211                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 212         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 213         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 214         int batchCount = 0;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 215         Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 216         batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;&gt;(failedCartIds)).intValue();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 217         List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;&gt;(failedCartIds));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 218         for (Order cart : carts) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 219             notifyCart(cart);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 220         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221     }</span>
 222 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223         synchronized(customerPurgeErrors) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224             Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 225             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 225             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).iðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 226             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 226             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;LongðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227             for (Customer customer : customers) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 228                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231                     deleteCustomer(customer);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232                     TransactionUtils.finalizeTransaction(status, transactionManager, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233                     processedCount++;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234                 } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235                     if (! status.isCompleted()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236                         TransactionUtils.finalizeTransaction(status, transactionManager, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238                     LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239                     customerPurgeErrors.add(customer.getId());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 241             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 242         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 243         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 243         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 244     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 245 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 246     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 247      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 247      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  ExpðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 248      * </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 249      * @param purgeParams configured parameters for the cart purge process</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 250      * @return set of cart ids to ignore/exclude from the next purge run</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 251      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 252     protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 253         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 254         Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 255         return ignoreFailedCartIds;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 256     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257     </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 259      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 259      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 261      * @param purgeParams configured parameters for the Cart purge process</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 262      * @param cartsInError list of cart ids to be ignored/excluded from the query</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 263      * @return list of carts to delete</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 264      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 265     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 265     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;LonðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 266         String[] nameArray = purgeParams.getNameArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 267         OrderStatus[] statusArray = purgeParams.getStatusArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 268         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 269         Boolean isPreview = purgeParams.getIsPreview();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 270         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 270         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, staðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 271     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 272 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 273     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 274      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 274      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 275      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 276      * @param purgeParams configured parameters for the Customer purge process used in the query</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 277      * @param cartsInError list of cart ids to ignore/exclude from the next purge run</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 278      * @return count of carts to delete</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 279      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 280     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 281      * </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 282      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 283     protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 284         String[] nameArray = purgeParams.getNameArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 285         OrderStatus[] statusArray = purgeParams.getStatusArray();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 286         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 287         Boolean isPreview = purgeParams.getIsPreview();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 288         Long cartBatchSize = purgeParams.getBatchSize(); </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 289         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 289         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThresholdðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 290         //return the lesser of the parameter batch size of the count of the orders to purge</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 291         return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount; </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 292     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 293 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 294     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 295      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 295      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 296      *</span>
 297 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 298     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; depends, final Map&lt;String, Integer&gt; config) {"> 298     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStateðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 299 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 300         if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 301             LOG.debug(&quot;Purging historical orders&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 302         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 303 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 304         String enablePurge = env.getProperty(&quot;enable.purge.order.history&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 305 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 306         if (!Boolean.parseBoolean(enablePurge)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 307             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.history to true.&quot;);"> 307             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.hisðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 308             return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 309         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 310 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 311         Integer daysCount = config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 312         Integer batchSize = config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 313 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 314         List&lt;Order&gt; oldOrders = orderService.findOrdersByDaysCount(daysCount, batchSize);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 315         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends);"> 315         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends)ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 316 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 317         List&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderDependencies = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 318 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 319         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));"> 319         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 320 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 321         dependencies.put(&quot;BLC_ORDER&quot;, orderDependencies);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 322 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 323         ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderItemDependencies = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 324         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 324         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 325         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 325         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 326         dependencies.put(&quot;BLC_ORDER_ITEM&quot;, orderItemDependencies);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 327         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));"> 327         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 328         extensionManager.getProxy().addPurgeDependencies(dependencies);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 329         Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 330         exclusions.add(&quot;BLC_ADMIN_USER&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 331         extensionManager.getProxy().addPurgeExclusions(exclusions);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 332         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &quot;?&quot;, dependencies, exclusions);"> 332         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 333         for (Order order : oldOrders) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 334             TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 335                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 336             try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 337                 em.unwrap(Session.class).doWork(new Work() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 338                     @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 339                     public void execute(Connection connection) throws SQLException {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 340                         Statement statement = connection.createStatement();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 341                         for (String value : deleteStatement.values()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 342                             String sql = value.replace(&quot;?&quot;, String.valueOf(order.getId()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 343                             LOG.debug(sql);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 344                             statement.addBatch(sql);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 345                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 346                         extensionManager.getProxy().addPurgeStatements(statement, rootTypeIdValue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 347                         statement.executeBatch();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 348                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 349                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 350                 TransactionUtils.finalizeTransaction(status, transactionManager, false);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 351             } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 352                 if (!status.isCompleted()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 353                     TransactionUtils.finalizeTransaction(status, transactionManager, true);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 354                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 355                 LOG.error(String.format(&quot;Not able to purge Order ID: %d&quot;, order.getId()), e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 356             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 357         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 358 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 359         LOG.info(&quot;Finished purging historical orders.&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 360     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 361 </span>
 362 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 363 
 364     @Override
 365     public void purgeCustomers(final Map&lt;String, String&gt; config) {
 366         if (LOG.isDebugEnabled()) {
 367             LOG.debug(&quot;Purging customers&quot;);
 368         }
 369         if (MapUtils.isEmpty(config)) {
<abbr title=" 370             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. &quot; +"> 370             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration pðŸ”µ</abbr>
 371                     &quot;In the absence of config params, all customers would be candidates for deletion.&quot;);
 372         }
 373         CustomerPurgeParams purgeParams = new CustomerPurgeParams(config).invoke();
 374         int processedCount = 0, batchCount = 0;
 375         synchronized (customerPurgeErrors) {
 376             Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);
<abbr title=" 377             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 377             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).iðŸ”µ</abbr>
<abbr title=" 378             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 378             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;LongðŸ”µ</abbr>
 379             for (Customer customer : customers) {
 380                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,
 381                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 382                 try {
 383                     deleteCustomer(customer);
 384                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 385                     processedCount++;
 386                 } catch (Exception e) {
 387                     if (!status.isCompleted()) {
 388                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 389                     }
 390                     LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);
 391                     customerPurgeErrors.add(customer.getId());
 392                 }
 393             }
 394         }
<abbr title=" 395         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 395         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %ðŸ”µ</abbr>
 396     }
 397 
 398     /**
<abbr title=" 399      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 399      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  ExpðŸ”µ</abbr>
 400      *
 401      * @param purgeParams configured parameters for the cart purge process
 402      * @return set of cart ids to ignore/exclude from the next purge run
 403      */
 404     protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {
 405         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 406         Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 407         return ignoreFailedCartIds;
 408     }
 409 
 410     /**
<abbr title=" 411      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 411      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 412      *
 413      * @param purgeParams  configured parameters for the Cart purge process
 414      * @param cartsInError list of cart ids to be ignored/excluded from the query
 415      * @return list of carts to delete
 416      */
<abbr title=" 417     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 417     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;LonðŸ”µ</abbr>
 418         String[] nameArray = purgeParams.getNameArray();
 419         OrderStatus[] statusArray = purgeParams.getStatusArray();
 420         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 421         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 422         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 422         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, staðŸ”µ</abbr>
 423     }
 424 
 425     /**
<abbr title=" 426      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 426      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieðŸ”µ</abbr>
 427      *
 428      * @param purgeParams configured parameters for the Customer purge process used in the query
 429      * @param cartsInError list of cart ids to ignore/exclude from the next purge run
 430      * @return count of carts to delete
 431      */
 432     /**
 433      *
 434      */
 435     protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {
 436         String[] nameArray = purgeParams.getNameArray();
 437         OrderStatus[] statusArray = purgeParams.getStatusArray();
 438         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 439         Boolean isPreview = purgeParams.getIsPreview();
 440         Long cartBatchSize = purgeParams.getBatchSize();
<abbr title=" 441         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 441         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThresholdðŸ”µ</abbr>
 442         //return the lesser of the parameter batch size of the count of the orders to purge
 443         return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount;
 444     }
 445 
 446     /**
 447      * Notify the cart&#x27;s owner of a pending purge of their cart.
 448      *
 449      * @param cart the cart
 450      */
 451     protected void notifyCart(Order cart) {
 452         String emailAddress = getEmailForCart(cart);
 453         if (emailAddress != null) {
 454             Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();
 455             context.put(&quot;cart&quot;, cart);
 456             context.put(&quot;customer&quot;, cart.getCustomer());
 457             context.put(&quot;emailAddress&quot;, emailAddress);
 458 
 459             try {
<abbr title=" 460                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificationEventType.NOTIFY_ABANDONED_CART, context));"> 460                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificatðŸ”µ</abbr>
 461             } catch (ServiceException e) {
 462                 if (LOG.isDebugEnabled()) {
 463                     LOG.debug(&quot;Failure to send email notification&quot;, e);
 464                 }
 465             }
 466         }
 467     }
 468 
 469     protected String getEmailForCart(Order cart) {
 470         if (cart.getEmailAddress() != null) {
 471             return cart.getEmailAddress();
 472         }
 473 
 474         if (cart.getCustomer() != null &amp;&amp; cart.getCustomer().getEmailAddress() != null) {
 475             return cart.getCustomer().getEmailAddress();
 476         }
 477 
 478         return null;
 479     }
 480 
 481     /**
<abbr title=" 482      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 482      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 483      *
 484      * @param cart the cart to remove
 485      */
 486     protected void deleteCart(Order cart) {
<abbr title=" 487         //We delete the order this way (rather than with a delete query) in order to ensure the cascades take place"> 487         //We delete the order this way (rather than with a delete query) in order to ensure the cascades ðŸ”µ</abbr>
 488         orderService.deleteOrder(cart);
 489     }
 490 
 491     /**
 492      * Get the Customer Ids from cache that should be ignored due to errors in previous purge attempts
 493      *
 494      * @param purgeParams configured parameters for the Customer purge process
 495      * @return set of customer ids to ignore/exclude from the next purge run
 496      */
 497     protected Set&lt;Long&gt; getCustomersInErrorToIgnore(CustomerPurgeParams purgeParams) {
 498         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 499         Set&lt;Long&gt; ignoreFailedCustomerIds = customerPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 500         return ignoreFailedCustomerIds;
 501     }
 502     
 503     /**
<abbr title=" 504      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 504      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 505      *
 506      * @param purgeParams      configured parameters for the Customer purge process
 507      * @param customersInError list of customer ids to be ignored/excluded from the query
 508      * @return list of customers to delete
 509      */
<abbr title=" 510     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; customersInError) {"> 510     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int lengtðŸ”µ</abbr>
 511         Boolean isRegistered = purgeParams.getIsRegistered();
 512         Boolean isDeactivated = purgeParams.getIsDeactivated();
 513         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 514         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 515         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, startPos, length, customersInError);"> 515         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreðŸ”µ</abbr>
 516     }
 517 
 518     /**
<abbr title=" 519      * Get the count of customers to delete from the database. Subclasses may override for custom customer retrieval logic."> 519      * Get the count of customers to delete from the database. Subclasses may override for custom customeðŸ”µ</abbr>
 520      *
 521      * @param purgeParams      configured parameters for the Customer purge process
 522      * @param customersInError list of customer ids to be ignored/excluded from the query
 523      * @return
 524      */
<abbr title=" 525     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInError) {"> 525     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInErrorðŸ”µ</abbr>
 526         Boolean isRegistered = purgeParams.getIsRegistered();
 527         Boolean isDeactivated = purgeParams.getIsDeactivated();
 528         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 529         Boolean isPreview = purgeParams.getIsPreview();
 530         Long customerBatchSize = purgeParams.getBatchSize();
<abbr title=" 531         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, customersInError);"> 531         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, ðŸ”µ</abbr>
 532         //return the lesser of the parameter batch size of the count of the customers to purge
<abbr title=" 533         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCount;"> 533         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : custðŸ”µ</abbr>
 534     }
 535 
 536     /**
<abbr title=" 537      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 537      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 538      *
 539      * @param customer the customer to remove
 540      */
 541     protected void deleteCustomer(Customer customer) {
<abbr title=" 542         //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take place"> 542         //We delete the customer this way (rather than with a delete query) in order to ensure the cascadðŸ”µ</abbr>
 543         customerService.deleteCustomer(customer);
 544     }
 545 
 546     private class CartPurgeParams {
 547 
 548         private Map&lt;String, String&gt; config;
 549         private String[] nameArray;
 550         private OrderStatus[] statusArray;
 551         private Date dateCreatedMinThreshold;
 552         private Boolean isPreview;
 553         private Long batchSize;
 554         private Long failedRetryTime;
 555 
 556         public CartPurgeParams(Map&lt;String, String&gt; config) {
 557             this.config = config;
 558         }
 559 
 560         public String[] getNameArray() {
 561             return nameArray;
 562         }
 563 
 564         public OrderStatus[] getStatusArray() {
 565             return statusArray;
 566         }
 567 
 568         public Date getDateCreatedMinThreshold() {
 569             return dateCreatedMinThreshold;
 570         }
 571 
 572         public Boolean getIsPreview() {
 573             return isPreview;
 574         }
 575 
 576         public Long getBatchSize() {
 577             return batchSize;
 578         }
 579 
 580         public Long getFailedRetryTime() {
 581             return failedRetryTime;
 582         }
 583 
 584         public CartPurgeParams invoke() {
 585             nameArray = null;
 586             statusArray = null;
 587             dateCreatedMinThreshold = null;
 588             isPreview = null;
 589             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 590             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 591 
 592             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 593                 if (PurgeCartVariableNames.STATUS.toString().equals(entry.getKey())) {
 594                     String[] temp = entry.getValue().split(&quot;,&quot;);
 595                     statusArray = new OrderStatus[temp.length];
 596                     int index = 0;
 597                     for (String name : temp) {
 598                         OrderStatus orderStatus = OrderStatus.getInstance(name);
 599                         statusArray[index] = orderStatus;
 600                         index++;
 601                     }
 602                 }
 603                 if (PurgeCartVariableNames.NAME.toString().equals(entry.getKey())) {
 604                     nameArray = entry.getValue().split(&quot;,&quot;);
 605                 }
 606                 if (PurgeCartVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 607                     Long secondsOld = Long.parseLong(entry.getValue());
 608                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 609                 }
 610                 if (PurgeCartVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 611                     isPreview = Boolean.parseBoolean(entry.getValue());
 612                 }
 613                 if (PurgeCartVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 614                     batchSize = Long.parseLong(entry.getValue());
 615                 }
 616                 if (PurgeCartVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 617                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 617                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 618                 }
 619             }
 620             return this;
 621         }
 622     }
 623 
 624     private class CustomerPurgeParams {
 625 
 626         private Map&lt;String, String&gt; config;
 627         private Date dateCreatedMinThreshold;
 628         private Boolean isPreview;
 629         private Boolean isRegistered;
 630         private Boolean isDeactivated;
 631         private Long batchSize;
 632         private Long failedRetryTime;
 633 
 634         public CustomerPurgeParams(Map&lt;String, String&gt; config) {
 635             this.config = config;
 636         }
 637 
 638         public Date getDateCreatedMinThreshold() {
 639             return dateCreatedMinThreshold;
 640         }
 641 
 642         public Boolean getIsPreview() {
 643             return isPreview;
 644         }
 645 
 646         public Boolean getIsRegistered() {
 647             return isRegistered;
 648         }
 649 
 650         public Boolean getIsDeactivated() {
 651             return isDeactivated;
 652         }
 653 
 654         public Long getBatchSize() {
 655             return batchSize;
 656         }
 657 
 658         public Long getFailedRetryTime() {
 659             return failedRetryTime;
 660         }
 661 
 662         public CustomerPurgeParams invoke() {
 663             isRegistered = null;
 664             isDeactivated = null;
 665             dateCreatedMinThreshold = null;
 666             isPreview = null;
 667             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 668             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 669 
 670             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 671                 if (PurgeCustomerVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 672                     Long secondsOld = Long.parseLong(entry.getValue());
 673                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 674                 }
 675                 if (PurgeCustomerVariableNames.IS_REGISTERED.toString().equals(entry.getKey())) {
 676                     isRegistered = Boolean.parseBoolean(entry.getValue());
 677                 }
 678                 if (PurgeCustomerVariableNames.IS_DEACTIVATED.toString().equals(entry.getKey())) {
 679                     isDeactivated = Boolean.parseBoolean(entry.getValue());
 680                 }
 681                 if (PurgeCustomerVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 682                     isPreview = Boolean.parseBoolean(entry.getValue());
 683                 }
 684                 if (PurgeCustomerVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 685                     batchSize = Long.parseLong(entry.getValue());
 686                 }
 687                 if (PurgeCustomerVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 688                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 688                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 689                 }
 690             }
 691             return this;
 692         }
 693     }
 694 
 695     private class PurgeErrorCache {
 696 
 697         private Map&lt;Long, Long&gt; cache = new HashMap&lt;Long, Long&gt;();
 698 
 699         public Long add(Long entry) {
 700             if (!cache.containsKey(entry)) {
 701                 return cache.put(entry, new Long(System.currentTimeMillis()));
 702             }
 703             return null;
 704         }
 705 
 706         public Set&lt;Long&gt; getEntriesSince(long expiredTime) {
 707             for (Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext(); ) {
 708                 Map.Entry&lt;Long, Long&gt; entry = item.next();
 709                 if (entry.getValue().longValue() &lt; expiredTime) {
 710                     item.remove();
 711                 }
 712             }
 713             return cache.keySet();
 714         }
 715 
 716         public int size() {
 717             return cache.size();
 718         }
 719 
 720     }
 721 
 722 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.util.service;
  19 
  20 import org.apache.commons.collections.MapUtils;
  21 import org.apache.commons.logging.Log;
  22 import org.apache.commons.logging.LogFactory;
  23 import org.broadleafcommerce.common.exception.ServiceException;
  24 import org.broadleafcommerce.common.notification.service.NotificationDispatcher;
  25 import org.broadleafcommerce.common.notification.service.type.EmailNotification;
  26 import org.broadleafcommerce.common.notification.service.type.NotificationEventType;
  27 import org.broadleafcommerce.common.time.SystemTime;
  28 import org.broadleafcommerce.common.util.TransactionUtils;
  29 import org.broadleafcommerce.core.order.domain.Order;
  30 import org.broadleafcommerce.core.order.domain.OrderImpl;
  31 import org.broadleafcommerce.core.order.service.OrderService;
  32 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  33 import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;
  34 import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;
  35 import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;
  36 import org.broadleafcommerce.core.util.service.type.PurgeOrderHistoryVariableNames;
  37 import org.broadleafcommerce.profile.core.domain.Customer;
  38 import org.broadleafcommerce.profile.core.service.CustomerService;
  39 import org.hibernate.Session;
  40 import org.hibernate.jdbc.Work;
  41 import org.springframework.beans.factory.annotation.Autowired;
  42 import org.springframework.beans.factory.annotation.Qualifier;
  43 import org.springframework.core.env.Environment;
  44 import org.springframework.stereotype.Service;
  45 import org.springframework.transaction.PlatformTransactionManager;
  46 import org.springframework.transaction.TransactionDefinition;
  47 import org.springframework.transaction.TransactionStatus;
  48 
  49 import java.sql.Connection;
  50 import java.sql.SQLException;
  51 import java.sql.Statement;
  52 import java.util.*;
  53 
  54 import javax.annotation.Resource;
  55 import javax.persistence.EntityManager;
  56 import javax.persistence.PersistenceContext;
  57 
  58 
  59 /**
<abbr title="  60  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous Customers).">  60  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymoðŸ”µ</abbr>
  61  * {@link ResourcePurgeService} for additional API documentation.
  62  * &lt;p/&gt;
  63  * A basic Quartz scheduled job configuration for calling this service can be configured as follows:
  64  * &lt;p/&gt;
  65  * {@code
  66  * &lt;bean id=&quot;purgeCartConfig&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
  67  * &lt;property name=&quot;sourceMap&quot;&gt;
  68  * &lt;map&gt;
  69  * &lt;entry key=&quot;SECONDS_OLD&quot; value=&quot;2592000&quot;/&gt;
  70  * &lt;entry key=&quot;STATUS&quot; value=&quot;IN_PROCESS&quot;/&gt;
  71  * &lt;/map&gt;
  72  * &lt;/property&gt;
  73  * &lt;/bean&gt;
  74  * &lt;p/&gt;
<abbr title="  75  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;">  75  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactðŸ”µ</abbr>
  76  * &lt;property name=&quot;targetObject&quot; ref=&quot;blResourcePurgeService&quot; /&gt;
  77  * &lt;property name=&quot;targetMethod&quot; value=&quot;purgeCarts&quot; /&gt;
  78  * &lt;property name=&quot;arguments&quot;&gt;
  79  * &lt;list&gt;
  80  * &lt;ref bean=&quot;purgeCartConfig&quot;/&gt;
  81  * &lt;/list&gt;
  82  * &lt;/property&gt;
  83  * &lt;/bean&gt;
  84  * &lt;p/&gt;
  85  * &lt;bean id=&quot;purgeCartTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;
  86  * &lt;property name=&quot;jobDetail&quot; ref=&quot;purgeCartJobDetail&quot; /&gt;
  87  * &lt;property name=&quot;startDelay&quot; value=&quot;30000&quot; /&gt;
  88  * &lt;property name=&quot;repeatInterval&quot; value=&quot;86400000&quot; /&gt;
  89  * &lt;/bean&gt;
  90  * }
  91  *
  92  * @author Jeff Fischer
  93  */
  94 @Service(&quot;blResourcePurgeService&quot;)
  95 public class ResourcePurgeServiceImpl implements ResourcePurgeService {
  96 
  97     private static final Log LOG = LogFactory.getLog(ResourcePurgeServiceImpl.class);
  98 
  99     private static final Long BATCH_SIZE = 50L;
<abbr title=" 100     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48 HOURS"> 100     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48ðŸ”µ</abbr>
 101 
 102     protected PurgeErrorCache customerPurgeErrors = new PurgeErrorCache();
 103     protected PurgeErrorCache historyPurgeErrors = new PurgeErrorCache();
 104     protected PurgeErrorCache cartPurgeErrors = new PurgeErrorCache();
 105 
 106     @Resource(name = &quot;blTransactionManager&quot;)
 107     protected PlatformTransactionManager transactionManager;
 108 
 109     @Resource(name = &quot;blResourcePurgeDao&quot;)
 110     protected ResourcePurgeDao resourcePurgeDao;
 111 
 112     @Resource(name = &quot;blOrderService&quot;)
 113     protected OrderService orderService;
 114 
 115     @Resource(name = &quot;blCustomerService&quot;)
 116     protected CustomerService customerService;
 117 
 118     @Autowired
 119     @Qualifier(&quot;blNotificationDispatcher&quot;)
 120     protected NotificationDispatcher notificationDispatcher;
 121 
 122     @Resource(name = &quot;blDeleteStatementGenerator&quot;)
 123     protected DeleteStatementGenerator deleteStatementGenerator;
 124 
 125     @Autowired
 126     protected Environment env;
 127 
 128     @PersistenceContext(unitName = &quot;blPU&quot;)
 129     protected EntityManager em;
 130 
 131     @Resource(name = &quot;blResourcePurgeExtensionManager&quot;)
 132     protected ResourcePurgeExtensionManager extensionManager;
 133 
 134     @Override
 135     public void purgeCarts(final Map&lt;String, String&gt; config) {
 136         if (LOG.isDebugEnabled()) {
 137             LOG.debug(&quot;Purging carts&quot;);
 138         }
 139         if (MapUtils.isEmpty(config)) {
<abbr title=" 140             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +"> 140             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration proviðŸ”µ</abbr>
 141                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 142         }
 143         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 144         int processedCount = 0, batchCount = 0;
 145         synchronized(cartPurgeErrors) {
 146             Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
<abbr title=" 147             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();"> 147             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue(ðŸ”µ</abbr>
<abbr title=" 148             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));"> 148             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCarðŸ”µ</abbr>
 149             for (Order cart : carts) {
 150                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 151                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 152                 try {
 153                     deleteCart(cart);
 154                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 155                     processedCount++;
 156                 } catch (Exception e) {
 157                     if (! status.isCompleted()) {
 158                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 159                     }
 160                     LOG.error(String.format(&quot;Not able to purge Cart ID: %d&quot;, cart.getId()), e);
 161                     cartPurgeErrors.add(cart.getId());
 162                 }
 163             }
 164         }
<abbr title=" 165         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, cartPurgeErrors.size()));"> 165         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d faðŸ”µ</abbr>
 166     }
 167 
 168     @Override
 169     public void notifyCarts(final Map&lt;String, String&gt; config) {
 170         if (LOG.isDebugEnabled()) {
 171             LOG.debug(&quot;Notifying carts of purge&quot;);
 172         }
 173         if (MapUtils.isEmpty(config)) {
<abbr title=" 174             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuration provided. &quot; +"> 174             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuraðŸ”µ</abbr>
 175                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 176         }
 177         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 178         int batchCount = 0;
 179         Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
 180         batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;&gt;(failedCartIds)).intValue();
 181         List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;&gt;(failedCartIds));
 182         for (Order cart : carts) {
 183             notifyCart(cart);
 184         }
 185     }
 186 
 187     @Override
<abbr title=" 188     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; depends, final Map&lt;String, Integer&gt; config) {"> 188     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStateðŸ”µ</abbr>
 189 
 190         if (LOG.isDebugEnabled()) {
 191             LOG.debug(&quot;Purging historical orders&quot;);
 192         }
 193 
 194         String enablePurge = env.getProperty(&quot;enable.purge.order.history&quot;);
 195 
 196         if (!Boolean.parseBoolean(enablePurge)) {
<abbr title=" 197             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.history to true.&quot;);"> 197             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.hisðŸ”µ</abbr>
 198             return;
 199         }
 200 
 201         Integer daysCount = config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());
 202         Integer batchSize = config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());
 203 
 204         List&lt;Order&gt; oldOrders = orderService.findOrdersByDaysCount(daysCount, batchSize);
<abbr title=" 205         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends);"> 205         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends)ðŸ”µ</abbr>
 206 
 207         List&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderDependencies = new ArrayList&lt;&gt;();
 208 
<abbr title=" 209         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));"> 209         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, ðŸ”µ</abbr>
 210 
 211         dependencies.put(&quot;BLC_ORDER&quot;, orderDependencies);
 212 
 213         ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderItemDependencies = new ArrayList&lt;&gt;();
<abbr title=" 214         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 214         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, ðŸ”µ</abbr>
<abbr title=" 215         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 215         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORðŸ”µ</abbr>
 216         dependencies.put(&quot;BLC_ORDER_ITEM&quot;, orderItemDependencies);
<abbr title=" 217         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));"> 217         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.ðŸ”µ</abbr>
 218         extensionManager.getProxy().addPurgeDependencies(dependencies);
 219         Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();
 220         exclusions.add(&quot;BLC_ADMIN_USER&quot;);
 221         extensionManager.getProxy().addPurgeExclusions(exclusions);
<abbr title=" 222         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &quot;?&quot;, dependencies, exclusions);"> 222         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrðŸ”µ</abbr>
 223         for (Order order : oldOrders) {
 224             TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 225                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 226             try {
 227                 em.unwrap(Session.class).doWork(new Work() {
 228                     @Override
 229                     public void execute(Connection connection) throws SQLException {
 230                         Statement statement = connection.createStatement();
 231                         for (String value : deleteStatement.values()) {
 232                             String sql = value.replace(&quot;?&quot;, String.valueOf(order.getId()));
 233                             LOG.debug(sql);
 234                             statement.addBatch(sql);
 235                         }
 236                         extensionManager.getProxy().addPurgeStatements(statement, rootTypeIdValue);
 237                         statement.executeBatch();
 238                     }
 239                 });
 240                 TransactionUtils.finalizeTransaction(status, transactionManager, false);
 241             } catch (Exception e) {
 242                 if (!status.isCompleted()) {
 243                     TransactionUtils.finalizeTransaction(status, transactionManager, true);
 244                 }
 245                 LOG.error(String.format(&quot;Not able to purge Order ID: %d&quot;, order.getId()), e);
 246             }
 247         }
 248 
 249         LOG.info(&quot;Finished purging historical orders.&quot;);
 250     }
 251 
 252 
 253     @Override
 254     public void purgeCustomers(final Map&lt;String, String&gt; config) {
 255         if (LOG.isDebugEnabled()) {
 256             LOG.debug(&quot;Purging customers&quot;);
 257         }
 258         if (MapUtils.isEmpty(config)) {
<abbr title=" 259             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. &quot; +"> 259             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration pðŸ”µ</abbr>
 260                     &quot;In the absence of config params, all customers would be candidates for deletion.&quot;);
 261         }
 262         CustomerPurgeParams purgeParams = new CustomerPurgeParams(config).invoke();
 263         int processedCount = 0, batchCount = 0;
 264         synchronized(customerPurgeErrors) {
 265             Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);
<abbr title=" 266             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 266             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).iðŸ”µ</abbr>
<abbr title=" 267             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 267             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;LongðŸ”µ</abbr>
 268             for (Customer customer : customers) {
 269                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,
 270                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 271                 try {
 272                     deleteCustomer(customer);
 273                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 274                     processedCount++;
 275                 } catch (Exception e) {
 276                     if (! status.isCompleted()) {
 277                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 278                     }
 279                     LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);
 280                     customerPurgeErrors.add(customer.getId());
 281                 }
 282             }
 283         }
<abbr title=" 284         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 284         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %ðŸ”µ</abbr>
 285     }
 286 
 287     /**
<abbr title=" 288      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 288      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  ExpðŸ”µ</abbr>
 289      *
 290      * @param purgeParams configured parameters for the cart purge process
 291      * @return set of cart ids to ignore/exclude from the next purge run
 292      */
 293     protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {
 294         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 295         Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 296         return ignoreFailedCartIds;
 297     }
 298 
 299     /**
<abbr title=" 300      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 300      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 301      *
 302      * @param purgeParams  configured parameters for the Cart purge process
 303      * @param cartsInError list of cart ids to be ignored/excluded from the query
 304      * @return list of carts to delete
 305      */
<abbr title=" 306     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 306     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;LonðŸ”µ</abbr>
 307         String[] nameArray = purgeParams.getNameArray();
 308         OrderStatus[] statusArray = purgeParams.getStatusArray();
 309         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 310         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 311         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 311         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, staðŸ”µ</abbr>
 312     }
 313 
 314     /**
<abbr title=" 315      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 315      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieðŸ”µ</abbr>
 316      *
 317      * @param purgeParams configured parameters for the Customer purge process used in the query
 318      * @param cartsInError list of cart ids to ignore/exclude from the next purge run
 319      * @return count of carts to delete
 320      */
 321     /**
 322      *
 323      */
 324     protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {
 325         String[] nameArray = purgeParams.getNameArray();
 326         OrderStatus[] statusArray = purgeParams.getStatusArray();
 327         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 328         Boolean isPreview = purgeParams.getIsPreview();
 329         Long cartBatchSize = purgeParams.getBatchSize();
<abbr title=" 330         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 330         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThresholdðŸ”µ</abbr>
 331         //return the lesser of the parameter batch size of the count of the orders to purge
 332         return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount;
 333     }
 334 
 335     /**
 336      * Notify the cart&#x27;s owner of a pending purge of their cart.
 337      *
 338      * @param cart the cart
 339      */
 340     protected void notifyCart(Order cart) {
 341         String emailAddress = getEmailForCart(cart);
 342         if (emailAddress != null) {
 343             Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();
 344             context.put(&quot;cart&quot;, cart);
 345             context.put(&quot;customer&quot;, cart.getCustomer());
 346             context.put(&quot;emailAddress&quot;, emailAddress);
 347 
 348             try {
<abbr title=" 349                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificationEventType.NOTIFY_ABANDONED_CART, context));"> 349                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificatðŸ”µ</abbr>
 350             } catch (ServiceException e) {
 351                 if (LOG.isDebugEnabled()) {
 352                     LOG.debug(&quot;Failure to send email notification&quot;, e);
 353                 }
 354             }
 355         }
 356     }
 357 
 358     protected String getEmailForCart(Order cart) {
 359         if (cart.getEmailAddress() != null) {
 360             return cart.getEmailAddress();
 361         }
 362 
 363         if (cart.getCustomer() != null &amp;&amp; cart.getCustomer().getEmailAddress() != null) {
 364             return cart.getCustomer().getEmailAddress();
 365         }
 366 
 367         return null;
 368     }
 369 
 370     /**
<abbr title=" 371      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 371      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 372      *
 373      * @param cart the cart to remove
 374      */
 375     protected void deleteCart(Order cart) {
<abbr title=" 376         //We delete the order this way (rather than with a delete query) in order to ensure the cascades take place"> 376         //We delete the order this way (rather than with a delete query) in order to ensure the cascades ðŸ”µ</abbr>
 377         orderService.deleteOrder(cart);
 378     }
 379 
 380     /**
 381      * Get the Customer Ids from cache that should be ignored due to errors in previous purge attempts
 382      *
 383      * @param purgeParams configured parameters for the Customer purge process
 384      * @return set of customer ids to ignore/exclude from the next purge run
 385      */
 386     protected Set&lt;Long&gt; getCustomersInErrorToIgnore(CustomerPurgeParams purgeParams) {
 387         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 388         Set&lt;Long&gt; ignoreFailedCustomerIds = customerPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 389         return ignoreFailedCustomerIds;
 390     }
 391 
 392     /**
<abbr title=" 393      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 393      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 394      *
 395      * @param purgeParams      configured parameters for the Customer purge process
 396      * @param customersInError list of customer ids to be ignored/excluded from the query
 397      * @return list of customers to delete
 398      */
<abbr title=" 399     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; customersInError) {"> 399     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int lengtðŸ”µ</abbr>
 400         Boolean isRegistered = purgeParams.getIsRegistered();
 401         Boolean isDeactivated = purgeParams.getIsDeactivated();
 402         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 403         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 404         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, startPos, length, customersInError);"> 404         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreðŸ”µ</abbr>
 405     }
 406 
 407     /**
<abbr title=" 408      * Get the count of customers to delete from the database. Subclasses may override for custom customer retrieval logic."> 408      * Get the count of customers to delete from the database. Subclasses may override for custom customeðŸ”µ</abbr>
 409      *
 410      * @param purgeParams      configured parameters for the Customer purge process
 411      * @param customersInError list of customer ids to be ignored/excluded from the query
 412      * @return
 413      */
<abbr title=" 414     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInError) {"> 414     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInErrorðŸ”µ</abbr>
 415         Boolean isRegistered = purgeParams.getIsRegistered();
 416         Boolean isDeactivated = purgeParams.getIsDeactivated();
 417         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 418         Boolean isPreview = purgeParams.getIsPreview();
 419         Long customerBatchSize = purgeParams.getBatchSize();
<abbr title=" 420         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, customersInError);"> 420         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, ðŸ”µ</abbr>
 421         //return the lesser of the parameter batch size of the count of the customers to purge
<abbr title=" 422         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCount;"> 422         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : custðŸ”µ</abbr>
 423     }
 424 
 425     /**
<abbr title=" 426      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 426      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 427      *
 428      * @param customer the customer to remove
 429      */
 430     protected void deleteCustomer(Customer customer) {
<abbr title=" 431         //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take place"> 431         //We delete the customer this way (rather than with a delete query) in order to ensure the cascadðŸ”µ</abbr>
 432         customerService.deleteCustomer(customer);
 433     }
 434 
 435     private class CartPurgeParams {
 436 
 437         private Map&lt;String, String&gt; config;
 438         private String[] nameArray;
 439         private OrderStatus[] statusArray;
 440         private Date dateCreatedMinThreshold;
 441         private Boolean isPreview;
 442         private Long batchSize;
 443         private Long failedRetryTime;
 444 
 445         public CartPurgeParams(Map&lt;String, String&gt; config) {
 446             this.config = config;
 447         }
 448 
 449         public String[] getNameArray() {
 450             return nameArray;
 451         }
 452 
 453         public OrderStatus[] getStatusArray() {
 454             return statusArray;
 455         }
 456 
 457         public Date getDateCreatedMinThreshold() {
 458             return dateCreatedMinThreshold;
 459         }
 460 
 461         public Boolean getIsPreview() {
 462             return isPreview;
 463         }
 464 
 465         public Long getBatchSize() {
 466             return batchSize;
 467         }
 468 
 469         public Long getFailedRetryTime() {
 470             return failedRetryTime;
 471         }
 472 
 473         public CartPurgeParams invoke() {
 474             nameArray = null;
 475             statusArray = null;
 476             dateCreatedMinThreshold = null;
 477             isPreview = null;
 478             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 479             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 480 
 481             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 482                 if (PurgeCartVariableNames.STATUS.toString().equals(entry.getKey())) {
 483                     String[] temp = entry.getValue().split(&quot;,&quot;);
 484                     statusArray = new OrderStatus[temp.length];
 485                     int index = 0;
 486                     for (String name : temp) {
 487                         OrderStatus orderStatus = OrderStatus.getInstance(name);
 488                         statusArray[index] = orderStatus;
 489                         index++;
 490                     }
 491                 }
 492                 if (PurgeCartVariableNames.NAME.toString().equals(entry.getKey())) {
 493                     nameArray = entry.getValue().split(&quot;,&quot;);
 494                 }
 495                 if (PurgeCartVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 496                     Long secondsOld = Long.parseLong(entry.getValue());
 497                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 498                 }
 499                 if (PurgeCartVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 500                     isPreview = Boolean.parseBoolean(entry.getValue());
 501                 }
 502                 if (PurgeCartVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 503                     batchSize = Long.parseLong(entry.getValue());
 504                 }
 505                 if (PurgeCartVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 506                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 506                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 507                 }
 508             }
 509             return this;
 510         }
 511     }
 512 
 513     private class CustomerPurgeParams {
 514 
 515         private Map&lt;String, String&gt; config;
 516         private Date dateCreatedMinThreshold;
 517         private Boolean isPreview;
 518         private Boolean isRegistered;
 519         private Boolean isDeactivated;
 520         private Long batchSize;
 521         private Long failedRetryTime;
 522 
 523         public CustomerPurgeParams(Map&lt;String, String&gt; config) {
 524             this.config = config;
 525         }
 526 
 527         public Date getDateCreatedMinThreshold() {
 528             return dateCreatedMinThreshold;
 529         }
 530 
 531         public Boolean getIsPreview() {
 532             return isPreview;
 533         }
 534 
 535         public Boolean getIsRegistered() {
 536             return isRegistered;
 537         }
 538 
 539         public Boolean getIsDeactivated() {
 540             return isDeactivated;
 541         }
 542 
 543         public Long getBatchSize() {
 544             return batchSize;
 545         }
 546 
 547         public Long getFailedRetryTime() {
 548             return failedRetryTime;
 549         }
 550 
 551         public CustomerPurgeParams invoke() {
 552             isRegistered = null;
 553             isDeactivated = null;
 554             dateCreatedMinThreshold = null;
 555             isPreview = null;
 556             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 557             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 558 
 559             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 560                 if (PurgeCustomerVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 561                     Long secondsOld = Long.parseLong(entry.getValue());
 562                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 563                 }
 564                 if (PurgeCustomerVariableNames.IS_REGISTERED.toString().equals(entry.getKey())) {
 565                     isRegistered = Boolean.parseBoolean(entry.getValue());
 566                 }
 567                 if (PurgeCustomerVariableNames.IS_DEACTIVATED.toString().equals(entry.getKey())) {
 568                     isDeactivated = Boolean.parseBoolean(entry.getValue());
 569                 }
 570                 if (PurgeCustomerVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 571                     isPreview = Boolean.parseBoolean(entry.getValue());
 572                 }
 573                 if (PurgeCustomerVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 574                     batchSize = Long.parseLong(entry.getValue());
 575                 }
 576                 if (PurgeCustomerVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 577                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 577                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 578                 }
 579             }
 580             return this;
 581         }
 582     }
 583 
 584     private class PurgeErrorCache {
 585 
 586         private Map&lt;Long, Long&gt; cache = new HashMap&lt;Long, Long&gt;();
 587 
 588         public Long add(Long entry) {
 589             if (! cache.containsKey(entry)) {
 590                 return cache.put(entry, new Long(System.currentTimeMillis()));
 591             }
 592             return null;
 593         }
 594 
 595         public Set&lt;Long&gt; getEntriesSince(long expiredTime) {
 596             for(Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext(); ) {
 597                 Map.Entry&lt;Long, Long&gt; entry = item.next();
 598                 if(entry.getValue().longValue() &lt; expiredTime) {
 599                   item.remove();
 600                 }
 601             }
 602             return cache.keySet();
 603         }
 604 
 605         public int size() {
 606             return cache.size();
 607         }
 608 
 609     }
 610 
 611 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Framework
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.core.util.service;
  19 
  20 import java.sql.Connection;
  21 import java.sql.SQLException;
  22 import java.sql.Statement;
  23 import java.util.*;
  24 import javax.annotation.Resource;
  25 import javax.persistence.EntityManager;
  26 import javax.persistence.PersistenceContext;
  27 import org.apache.commons.collections.MapUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.broadleafcommerce.common.exception.ServiceException;
  31 import org.broadleafcommerce.common.notification.service.NotificationDispatcher;
  32 import org.broadleafcommerce.common.notification.service.type.EmailNotification;
  33 import org.broadleafcommerce.common.notification.service.type.NotificationEventType;
  34 import org.broadleafcommerce.common.time.SystemTime;
  35 import org.broadleafcommerce.common.util.TransactionUtils;
  36 import org.broadleafcommerce.core.order.domain.Order;
  37 import org.broadleafcommerce.core.order.domain.OrderImpl;
  38 import org.broadleafcommerce.core.order.service.OrderService;
  39 import org.broadleafcommerce.core.order.service.type.OrderStatus;
  40 import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;
  41 import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;
  42 import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;
  43 import org.broadleafcommerce.core.util.service.type.PurgeOrderHistoryVariableNames;
  44 import org.broadleafcommerce.profile.core.domain.Customer;
  45 import org.broadleafcommerce.profile.core.service.CustomerService;
  46 import org.hibernate.Session;
  47 import org.hibernate.jdbc.Work;
  48 import org.springframework.beans.factory.annotation.Autowired;
  49 import org.springframework.beans.factory.annotation.Qualifier;
  50 import org.springframework.core.env.Environment;
  51 import org.springframework.stereotype.Service;
  52 import org.springframework.transaction.PlatformTransactionManager;
  53 import org.springframework.transaction.TransactionDefinition;
  54 import org.springframework.transaction.TransactionStatus;
  55 
  56 
  57 /**
<abbr title="  58  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous Customers).">  58  * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymoðŸ”µ</abbr>
  59  * {@link ResourcePurgeService} for additional API documentation.
  60  * &lt;p/&gt;
  61  * A basic Quartz scheduled job configuration for calling this service can be configured as follows:
  62  * &lt;p/&gt;
  63  * {@code
  64  * &lt;bean id=&quot;purgeCartConfig&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
  65  * &lt;property name=&quot;sourceMap&quot;&gt;
  66  * &lt;map&gt;
  67  * &lt;entry key=&quot;SECONDS_OLD&quot; value=&quot;2592000&quot;/&gt;
  68  * &lt;entry key=&quot;STATUS&quot; value=&quot;IN_PROCESS&quot;/&gt;
  69  * &lt;/map&gt;
  70  * &lt;/property&gt;
  71  * &lt;/bean&gt;
  72  * &lt;p/&gt;
<abbr title="  73  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;">  73  * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactðŸ”µ</abbr>
  74  * &lt;property name=&quot;targetObject&quot; ref=&quot;blResourcePurgeService&quot; /&gt;
  75  * &lt;property name=&quot;targetMethod&quot; value=&quot;purgeCarts&quot; /&gt;
  76  * &lt;property name=&quot;arguments&quot;&gt;
  77  * &lt;list&gt;
  78  * &lt;ref bean=&quot;purgeCartConfig&quot;/&gt;
  79  * &lt;/list&gt;
  80  * &lt;/property&gt;
  81  * &lt;/bean&gt;
  82  * &lt;p/&gt;
  83  * &lt;bean id=&quot;purgeCartTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;
  84  * &lt;property name=&quot;jobDetail&quot; ref=&quot;purgeCartJobDetail&quot; /&gt;
  85  * &lt;property name=&quot;startDelay&quot; value=&quot;30000&quot; /&gt;
  86  * &lt;property name=&quot;repeatInterval&quot; value=&quot;86400000&quot; /&gt;
  87  * &lt;/bean&gt;
  88  *}
  89  * @author Jeff Fischer
  90  */
  91 @Service(&quot;blResourcePurgeService&quot;)
  92 public class ResourcePurgeServiceImpl implements ResourcePurgeService {
  93     private static final Log LOG = LogFactory.getLog(ResourcePurgeServiceImpl.class);
  94 
  95     private static final Long BATCH_SIZE = 50L;
  96 
  97     //48 HOURS
<abbr title="  98     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48 HOURS">  98     private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48ðŸ”µ</abbr>
  99 
 100     protected PurgeErrorCache customerPurgeErrors = new PurgeErrorCache();
 101 
 102     protected PurgeErrorCache historyPurgeErrors = new PurgeErrorCache();
 103 
 104     protected PurgeErrorCache cartPurgeErrors = new PurgeErrorCache();
 105 
 106     @Resource(name = &quot;blTransactionManager&quot;)
 107     protected PlatformTransactionManager transactionManager;
 108 
 109     @Resource(name = &quot;blResourcePurgeDao&quot;)
 110     protected ResourcePurgeDao resourcePurgeDao;
 111 
 112     @Resource(name = &quot;blOrderService&quot;)
 113     protected OrderService orderService;
 114 
 115     @Resource(name = &quot;blCustomerService&quot;)
 116     protected CustomerService customerService;
 117 
 118     @Autowired
 119     @Qualifier(&quot;blNotificationDispatcher&quot;)
 120     protected NotificationDispatcher notificationDispatcher;
 121 
 122     @Resource(name = &quot;blDeleteStatementGenerator&quot;)
 123     protected DeleteStatementGenerator deleteStatementGenerator;
 124 
 125     @Autowired
 126     protected Environment env;
 127 
 128     @PersistenceContext(unitName = &quot;blPU&quot;)
 129     protected EntityManager em;
 130 
 131     @Resource(name = &quot;blResourcePurgeExtensionManager&quot;)
 132     protected ResourcePurgeExtensionManager extensionManager;
 133 
 134     @Override
 135     public void purgeCarts(final Map&lt;String, String&gt; config) {
 136         if (LOG.isDebugEnabled()) {
 137             LOG.debug(&quot;Purging carts&quot;);
 138         }
 139         if (MapUtils.isEmpty(config)) {
<abbr title=" 140             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +"> 140             throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration proviðŸ”µ</abbr>
 141                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 142         }
 143         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 144         int processedCount = 0, batchCount = 0;
 145         synchronized(cartPurgeErrors) {
 146             Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
<abbr title=" 147             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();"> 147             batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue(ðŸ”µ</abbr>
<abbr title=" 148             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));"> 148             List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCarðŸ”µ</abbr>
 149             for (Order cart : carts) {
 150                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 151                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 152                 try {
 153                     deleteCart(cart);
 154                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 155                     processedCount++;
 156                 } catch (Exception e) {
 157                     if (! status.isCompleted()) {
 158                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 159                     }
 160                     LOG.error(String.format(&quot;Not able to purge Cart ID: %d&quot;, cart.getId()), e);
 161                     cartPurgeErrors.add(cart.getId());
 162                 }
 163             }
 164         }
<abbr title=" 165         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, cartPurgeErrors.size()));"> 165         LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d faðŸ”µ</abbr>
 166     }
 167 
 168     @Override
 169     public void notifyCarts(final Map&lt;String, String&gt; config) {
 170         if (LOG.isDebugEnabled()) {
 171             LOG.debug(&quot;Notifying carts of purge&quot;);
 172         }
 173         if (MapUtils.isEmpty(config)) {
<abbr title=" 174             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuration provided. &quot; +"> 174             throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuraðŸ”µ</abbr>
 175                     &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 176         }
 177         CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 178         int batchCount = 0;
 179         Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
 180         batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;&gt;(failedCartIds)).intValue();
 181         List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;&gt;(failedCartIds));
 182         for (Order cart : carts) {
 183             notifyCart(cart);
 184         }
 185     }
 186 
 187     @Override
<abbr title=" 188     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; depends, final Map&lt;String, Integer&gt; config) {"> 188     public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStateðŸ”µ</abbr>
 189 
 190         if (LOG.isDebugEnabled()) {
 191             LOG.debug(&quot;Purging historical orders&quot;);
 192         }
 193 
 194         String enablePurge = env.getProperty(&quot;enable.purge.order.history&quot;);
 195 
 196         if (!Boolean.parseBoolean(enablePurge)) {
<abbr title=" 197             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.history to true.&quot;);"> 197             LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.hisðŸ”µ</abbr>
 198             return;
 199         }
 200 
 201         Integer daysCount = config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());
 202         Integer batchSize = config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());
 203 
 204         List&lt;Order&gt; oldOrders = orderService.findOrdersByDaysCount(daysCount, batchSize);
<abbr title=" 205         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends);"> 205         Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends)ðŸ”µ</abbr>
 206 
 207         List&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderDependencies = new ArrayList&lt;&gt;();
 208 
<abbr title=" 209         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));"> 209         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, ðŸ”µ</abbr>
 210 
 211         dependencies.put(&quot;BLC_ORDER&quot;, orderDependencies);
 212 
 213         ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderItemDependencies = new ArrayList&lt;&gt;();
<abbr title=" 214         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 214         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, ðŸ”µ</abbr>
<abbr title=" 215         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 215         orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORðŸ”µ</abbr>
 216         dependencies.put(&quot;BLC_ORDER_ITEM&quot;, orderItemDependencies);
<abbr title=" 217         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));"> 217         dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.ðŸ”µ</abbr>
 218         extensionManager.getProxy().addPurgeDependencies(dependencies);
 219         Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();
 220         exclusions.add(&quot;BLC_ADMIN_USER&quot;);
 221         extensionManager.getProxy().addPurgeExclusions(exclusions);
<abbr title=" 222         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &quot;?&quot;, dependencies, exclusions);"> 222         Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrðŸ”µ</abbr>
 223         for (Order order : oldOrders) {
 224             TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 225                     TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 226             try {
 227                 em.unwrap(Session.class).doWork(new Work() {
 228                     @Override
 229                     public void execute(Connection connection) throws SQLException {
 230                         Statement statement = connection.createStatement();
 231                         for (String value : deleteStatement.values()) {
 232                             String sql = value.replace(&quot;?&quot;, String.valueOf(order.getId()));
 233                             LOG.debug(sql);
 234                             statement.addBatch(sql);
 235                         }
 236                         extensionManager.getProxy().addPurgeStatements(statement, rootTypeIdValue);
 237                         statement.executeBatch();
 238                     }
 239                 });
 240                 TransactionUtils.finalizeTransaction(status, transactionManager, false);
 241             } catch (Exception e) {
 242                 if (!status.isCompleted()) {
 243                     TransactionUtils.finalizeTransaction(status, transactionManager, true);
 244                 }
 245                 LOG.error(String.format(&quot;Not able to purge Order ID: %d&quot;, order.getId()), e);
 246             }
 247         }
 248 
 249         LOG.info(&quot;Finished purging historical orders.&quot;);
 250     }
 251 
 252     @Override
 253     public void purgeCustomers(final Map&lt;String, String&gt; config) {
 254         if (LOG.isDebugEnabled()) {
 255             LOG.debug(&quot;Purging customers&quot;);
 256         }
 257         if (MapUtils.isEmpty(config)) {
<abbr title=" 258             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. &quot; +"> 258             throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration pðŸ”µ</abbr>
 259                     &quot;In the absence of config params, all customers would be candidates for deletion.&quot;);
 260         }
 261         CustomerPurgeParams purgeParams = new CustomerPurgeParams(config).invoke();
 262         int processedCount = 0, batchCount = 0;
 263         synchronized(customerPurgeErrors) {
 264             Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);
<abbr title=" 265             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 265             batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).iðŸ”µ</abbr>
<abbr title=" 266             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 266             List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;LongðŸ”µ</abbr>
 267             for (Customer customer : customers) {
 268                 TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,
 269                         TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 270                 try {
 271                     deleteCustomer(customer);
 272                     TransactionUtils.finalizeTransaction(status, transactionManager, false);
 273                     processedCount++;
 274                 } catch (Exception e) {
 275                     if (! status.isCompleted()) {
 276                         TransactionUtils.finalizeTransaction(status, transactionManager, true);
 277                     }
 278                     LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);
 279                     customerPurgeErrors.add(customer.getId());
 280                 }
 281             }
 282         }
<abbr title=" 283         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 283         LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %ðŸ”µ</abbr>
 284     }
 285 
 286     /**
<abbr title=" 287      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 287      * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  ExpðŸ”µ</abbr>
 288      *
 289      * @param purgeParams configured parameters for the cart purge process
 290      * @return set of cart ids to ignore/exclude from the next purge run
 291      */
 292     protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {
 293         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 294         Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 295         return ignoreFailedCartIds;
 296     }
 297 
 298     /**
<abbr title=" 299      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 299      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 300      *
 301      * @param purgeParams configured parameters for the Cart purge process
 302      * @param cartsInError list of cart ids to be ignored/excluded from the query
 303      * @return list of carts to delete
 304      */
<abbr title=" 305     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 305     protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;LonðŸ”µ</abbr>
 306         String[] nameArray = purgeParams.getNameArray();
 307         OrderStatus[] statusArray = purgeParams.getStatusArray();
 308         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 309         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 310         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 310         return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, staðŸ”µ</abbr>
 311     }
 312 
 313     /**
<abbr title=" 314      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 314      * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieðŸ”µ</abbr>
 315      *
 316      * @param purgeParams configured parameters for the Customer purge process used in the query
 317      * @param cartsInError list of cart ids to ignore/exclude from the next purge run
 318      * @return count of carts to delete
 319      */
 320     /**
 321      *
 322      */
 323     protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {
 324         String[] nameArray = purgeParams.getNameArray();
 325         OrderStatus[] statusArray = purgeParams.getStatusArray();
 326         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 327         Boolean isPreview = purgeParams.getIsPreview();
 328         Long cartBatchSize = purgeParams.getBatchSize();
<abbr title=" 329         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 329         Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThresholdðŸ”µ</abbr>
 330         //return the lesser of the parameter batch size of the count of the orders to purge
 331         return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount;
 332     }
 333 
 334     /**
 335      * Notify the cart&#x27;s owner of a pending purge of their cart.
 336      *
 337      * @param cart the cart
 338      */
 339     protected void notifyCart(Order cart) {
 340         String emailAddress = getEmailForCart(cart);
 341         if (emailAddress != null) {
 342             Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();
 343             context.put(&quot;cart&quot;, cart);
 344             context.put(&quot;customer&quot;, cart.getCustomer());
 345             context.put(&quot;emailAddress&quot;, emailAddress);
 346 
 347             try {
<abbr title=" 348                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificationEventType.NOTIFY_ABANDONED_CART, context));"> 348                 notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificatðŸ”µ</abbr>
 349             } catch (ServiceException e) {
 350                 if (LOG.isDebugEnabled()) {
 351                     LOG.debug(&quot;Failure to send email notification&quot;, e);
 352                 }
 353             }
 354         }
 355     }
 356 
 357     protected String getEmailForCart(Order cart) {
 358         if (cart.getEmailAddress() != null) {
 359             return cart.getEmailAddress();
 360         }
 361 
 362         if (cart.getCustomer() != null &amp;&amp; cart.getCustomer().getEmailAddress() != null) {
 363             return cart.getCustomer().getEmailAddress();
 364         }
 365 
 366         return null;
 367     }
 368 
 369     /**
<abbr title=" 370      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 370      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 371      *
 372      * @param cart the cart to remove
 373      */
 374     protected void deleteCart(Order cart) {
<abbr title=" 375         //We delete the order this way (rather than with a delete query) in order to ensure the cascades take place"> 375         //We delete the order this way (rather than with a delete query) in order to ensure the cascades ðŸ”µ</abbr>
 376         orderService.deleteOrder(cart);
 377     }
 378 
 379     /**
 380      * Get the Customer Ids from cache that should be ignored due to errors in previous purge attempts
 381      *
 382      * @param purgeParams configured parameters for the Customer purge process
 383      * @return set of customer ids to ignore/exclude from the next purge run
 384      */
 385     protected Set&lt;Long&gt; getCustomersInErrorToIgnore(CustomerPurgeParams purgeParams) {
 386         long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 387         Set&lt;Long&gt; ignoreFailedCustomerIds = customerPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 388         return ignoreFailedCustomerIds;
 389     }
 390 
 391     /**
<abbr title=" 392      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 392      * Get the list of carts to delete from the database. Subclasses may override for custom cart retrievðŸ”µ</abbr>
 393      *
 394      * @param purgeParams configured parameters for the Customer purge process
 395      * @param customersInError list of customer ids to be ignored/excluded from the query
 396      * @return list of customers to delete
 397      */
<abbr title=" 398     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; customersInError) {"> 398     protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int lengtðŸ”µ</abbr>
 399         Boolean isRegistered = purgeParams.getIsRegistered();
 400         Boolean isDeactivated = purgeParams.getIsDeactivated();
 401         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 402         Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 403         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, startPos, length, customersInError);"> 403         return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreðŸ”µ</abbr>
 404     }
 405 
 406     /**
<abbr title=" 407      * Get the count of customers to delete from the database. Subclasses may override for custom customer retrieval logic."> 407      * Get the count of customers to delete from the database. Subclasses may override for custom customeðŸ”µ</abbr>
 408      *
 409      * @param purgeParams configured parameters for the Customer purge process
 410      * @param customersInError list of customer ids to be ignored/excluded from the query
 411      * @return
 412      */
<abbr title=" 413     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInError) {"> 413     protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInErrorðŸ”µ</abbr>
 414         Boolean isRegistered = purgeParams.getIsRegistered();
 415         Boolean isDeactivated = purgeParams.getIsDeactivated();
 416         Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 417         Boolean isPreview = purgeParams.getIsPreview();
 418         Long customerBatchSize = purgeParams.getBatchSize();
<abbr title=" 419         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, customersInError);"> 419         Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, ðŸ”µ</abbr>
 420         //return the lesser of the parameter batch size of the count of the customers to purge
<abbr title=" 421         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCount;"> 421         return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : custðŸ”µ</abbr>
 422     }
 423 
 424     /**
<abbr title=" 425      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic."> 425      * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logiðŸ”µ</abbr>
 426      *
 427      * @param customer the customer to remove
 428      */
 429     protected void deleteCustomer(Customer customer) {
<abbr title=" 430         //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take place"> 430         //We delete the customer this way (rather than with a delete query) in order to ensure the cascadðŸ”µ</abbr>
 431         customerService.deleteCustomer(customer);
 432     }
 433 
 434     private class CartPurgeParams {
 435         private Map&lt;String, String&gt; config;
 436 
 437         private String[] nameArray;
 438 
 439         private OrderStatus[] statusArray;
 440 
 441         private Date dateCreatedMinThreshold;
 442 
 443         private Boolean isPreview;
 444 
 445         private Long batchSize;
 446 
 447         private Long failedRetryTime;
 448 
 449         public CartPurgeParams(Map&lt;String, String&gt; config) {
 450             this.config = config;
 451         }
 452 
 453         public String[] getNameArray() {
 454             return nameArray;
 455         }
 456 
 457         public OrderStatus[] getStatusArray() {
 458             return statusArray;
 459         }
 460 
 461         public Date getDateCreatedMinThreshold() {
 462             return dateCreatedMinThreshold;
 463         }
 464 
 465         public Boolean getIsPreview() {
 466             return isPreview;
 467         }
 468 
 469         public Long getBatchSize() {
 470             return batchSize;
 471         }
 472 
 473         public Long getFailedRetryTime() {
 474             return failedRetryTime;
 475         }
 476 
 477         public CartPurgeParams invoke() {
 478             nameArray = null;
 479             statusArray = null;
 480             dateCreatedMinThreshold = null;
 481             isPreview = null;
 482             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 483             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 484             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 485                 if (PurgeCartVariableNames.STATUS.toString().equals(entry.getKey())) {
 486                     String[] temp = entry.getValue().split(&quot;,&quot;);
 487                     statusArray = new OrderStatus[temp.length];
 488                     int index = 0;
 489                     for (String name : temp) {
 490                         OrderStatus orderStatus = OrderStatus.getInstance(name);
 491                         statusArray[index] = orderStatus;
 492                         index++;
 493                     }
 494                 }
 495                 if (PurgeCartVariableNames.NAME.toString().equals(entry.getKey())) {
 496                     nameArray = entry.getValue().split(&quot;,&quot;);
 497                 }
 498                 if (PurgeCartVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 499                     Long secondsOld = Long.parseLong(entry.getValue());
 500                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 501                 }
 502                 if (PurgeCartVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 503                     isPreview = Boolean.parseBoolean(entry.getValue());
 504                 }
 505                 if (PurgeCartVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 506                     batchSize = Long.parseLong(entry.getValue());
 507                 }
 508                 if (PurgeCartVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 509                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 509                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 510                 }
 511             }
 512             return this;
 513         }
 514     }
 515 
 516     private class CustomerPurgeParams {
 517         private Map&lt;String, String&gt; config;
 518 
 519         private Date dateCreatedMinThreshold;
 520 
 521         private Boolean isPreview;
 522 
 523         private Boolean isRegistered;
 524 
 525         private Boolean isDeactivated;
 526 
 527         private Long batchSize;
 528 
 529         private Long failedRetryTime;
 530 
 531         public CustomerPurgeParams(Map&lt;String, String&gt; config) {
 532             this.config = config;
 533         }
 534 
 535         public Date getDateCreatedMinThreshold() {
 536             return dateCreatedMinThreshold;
 537         }
 538 
 539         public Boolean getIsPreview() {
 540             return isPreview;
 541         }
 542 
 543         public Boolean getIsRegistered() {
 544             return isRegistered;
 545         }
 546 
 547         public Boolean getIsDeactivated() {
 548             return isDeactivated;
 549         }
 550 
 551         public Long getBatchSize() {
 552             return batchSize;
 553         }
 554 
 555         public Long getFailedRetryTime() {
 556             return failedRetryTime;
 557         }
 558 
 559         public CustomerPurgeParams invoke() {
 560             isRegistered = null;
 561             isDeactivated = null;
 562             dateCreatedMinThreshold = null;
 563             isPreview = null;
 564             batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 565             failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 566             for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 567                 if (PurgeCustomerVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 568                     Long secondsOld = Long.parseLong(entry.getValue());
 569                     dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 570                 }
 571                 if (PurgeCustomerVariableNames.IS_REGISTERED.toString().equals(entry.getKey())) {
 572                     isRegistered = Boolean.parseBoolean(entry.getValue());
 573                 }
 574                 if (PurgeCustomerVariableNames.IS_DEACTIVATED.toString().equals(entry.getKey())) {
 575                     isDeactivated = Boolean.parseBoolean(entry.getValue());
 576                 }
 577                 if (PurgeCustomerVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 578                     isPreview = Boolean.parseBoolean(entry.getValue());
 579                 }
 580                 if (PurgeCustomerVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 581                     batchSize = Long.parseLong(entry.getValue());
 582                 }
 583                 if (PurgeCustomerVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
<abbr title=" 584                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);"> 584                     failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 10ðŸ”µ</abbr>
 585                 }
 586             }
 587             return this;
 588         }
 589     }
 590 
 591     private class PurgeErrorCache {
 592         private Map&lt;Long, Long&gt; cache = new HashMap&lt;Long, Long&gt;();
 593 
 594         public Long add(Long entry) {
 595             if (!cache.containsKey(entry)) {
 596                 return cache.put(entry, new Long(System.currentTimeMillis()));
 597             }
 598             return null;
 599         }
 600 
 601         public Set&lt;Long&gt; getEntriesSince(long expiredTime) {
 602             for (Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext();) {
 603                 Map.Entry&lt;Long, Long&gt; entry = item.next();
 604                 if (entry.getValue().longValue() &lt; expiredTime) {
 605                     item.remove();
 606                 }
 607             }
 608             return cache.keySet();
 609         }
 610 
 611         public int size() {
 612             return cache.size();
 613         }
 614     }
 615 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.util.service;
  19  
  20  import java.util.ArrayList;
  21  import java.util.Date;
  22  import java.util.HashMap;
  23  import java.util.Iterator;
  24  import java.util.List;
  25  import java.util.Map;
  26  import java.util.Set;
  27  
  28  import javax.annotation.Resource;
  29  
  30  import org.apache.commons.collections.MapUtils;
  31  import org.apache.commons.logging.Log;
  32  import org.apache.commons.logging.LogFactory;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.broadleafcommerce.common.exception.ServiceException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import org.broadleafcommerce.common.notification.service.NotificationDispatcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.broadleafcommerce.common.notification.service.type.EmailNotification;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.broadleafcommerce.common.notification.service.type.NotificationEventType;</span>
  37  import org.broadleafcommerce.common.time.SystemTime;
  38  import org.broadleafcommerce.common.util.TransactionUtils;
  39  import org.broadleafcommerce.core.order.domain.Order;

  40  import org.broadleafcommerce.core.order.service.OrderService;
  41  import org.broadleafcommerce.core.order.service.type.OrderStatus;
  42  import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;
  43  import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;
  44  import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;

  45  import org.broadleafcommerce.profile.core.domain.Customer;
  46  import org.broadleafcommerce.profile.core.service.CustomerService;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import org.springframework.beans.factory.annotation.Qualifier;</span>


  49  import org.springframework.stereotype.Service;
  50  import org.springframework.transaction.PlatformTransactionManager;
  51  import org.springframework.transaction.TransactionDefinition;
  52  import org.springframework.transaction.TransactionStatus;










  53  
  54  /**
<abbr title="  55   * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous Customers).">  55   * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous CustomðŸ”µ</abbr>
  56   * {@link ResourcePurgeService} for additional API documentation.
  57   * &lt;p/&gt;
  58   * A basic Quartz scheduled job configuration for calling this service can be configured as follows:
  59   * &lt;p/&gt;
  60   * {@code
  61   * &lt;bean id=&quot;purgeCartConfig&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
  62   * &lt;property name=&quot;sourceMap&quot;&gt;
  63   * &lt;map&gt;
  64   * &lt;entry key=&quot;SECONDS_OLD&quot; value=&quot;2592000&quot;/&gt;
  65   * &lt;entry key=&quot;STATUS&quot; value=&quot;IN_PROCESS&quot;/&gt;
  66   * &lt;/map&gt;
  67   * &lt;/property&gt;
  68   * &lt;/bean&gt;
  69   * &lt;p/&gt;
  70   * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;
  71   * &lt;property name=&quot;targetObject&quot; ref=&quot;blResourcePurgeService&quot; /&gt;
  72   * &lt;property name=&quot;targetMethod&quot; value=&quot;purgeCarts&quot; /&gt;
  73   * &lt;property name=&quot;arguments&quot;&gt;
  74   * &lt;list&gt;
  75   * &lt;ref bean=&quot;purgeCartConfig&quot;/&gt;
  76   * &lt;/list&gt;
  77   * &lt;/property&gt;
  78   * &lt;/bean&gt;
  79   * &lt;p/&gt;
  80   * &lt;bean id=&quot;purgeCartTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;
  81   * &lt;property name=&quot;jobDetail&quot; ref=&quot;purgeCartJobDetail&quot; /&gt;
  82   * &lt;property name=&quot;startDelay&quot; value=&quot;30000&quot; /&gt;
  83   * &lt;property name=&quot;repeatInterval&quot; value=&quot;86400000&quot; /&gt;
  84   * &lt;/bean&gt;
  85   *}


  86   * @author Jeff Fischer
  87   */
  88  @Service(&quot;blResourcePurgeService&quot;)
  89  public class ResourcePurgeServiceImpl implements ResourcePurgeService {
  90  
  91      private static final Log LOG = LogFactory.getLog(ResourcePurgeServiceImpl.class);
  92  
  93      private static final Long BATCH_SIZE = 50L;
  94      private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48 HOURS
  95  
  96      protected PurgeErrorCache customerPurgeErrors = new PurgeErrorCache();

  97      protected PurgeErrorCache cartPurgeErrors = new PurgeErrorCache();
  98  
  99      @Resource(name = &quot;blTransactionManager&quot;)
 100      protected PlatformTransactionManager transactionManager;
 101  
 102      @Resource(name = &quot;blResourcePurgeDao&quot;)
 103      protected ResourcePurgeDao resourcePurgeDao;
 104  
 105      @Resource(name = &quot;blOrderService&quot;)
 106      protected OrderService orderService;
 107  
 108      @Resource(name = &quot;blCustomerService&quot;)
 109      protected CustomerService customerService;












 110  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +    @Autowired</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +    @Qualifier(&quot;blNotificationDispatcher&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    protected NotificationDispatcher notificationDispatcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +</span>
 115      @Override
 116      public void purgeCarts(final Map&lt;String, String&gt; config) {
 117          if (LOG.isDebugEnabled()) {
 118              LOG.debug(&quot;Purging carts&quot;);
 119          }
 120          if (MapUtils.isEmpty(config)) {
 121              throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +
 122                      &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 123          }
 124          CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 125          int processedCount = 0, batchCount = 0;
 126          synchronized(cartPurgeErrors) {

 127              Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
 128              batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();
 129              List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));
 130              for (Order cart : carts) {
 131                  TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 132                          TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 133                  try {
 134                      deleteCart(cart);
 135                      TransactionUtils.finalizeTransaction(status, transactionManager, false);
 136                      processedCount++;
 137                  } catch (Exception e) {
 138                      if (! status.isCompleted()) {

 139                          TransactionUtils.finalizeTransaction(status, transactionManager, true);
 140                      }
 141                      LOG.error(String.format(&quot;Not able to purge Cart ID: %d&quot;, cart.getId()), e);
 142                      cartPurgeErrors.add(cart.getId());
 143                  }
 144              }
 145          }
<abbr title=" 146          LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, cartPurgeErrors.size()));"> 146          LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures caðŸ”µ</abbr>
 147      }
 148  
 149      @Override
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +    public void notifyCarts(final Map&lt;String, String&gt; config) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +            LOG.debug(&quot;Notifying carts of purge&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +        if (MapUtils.isEmpty(config)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 155 +            throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuration provided. &quot; +"> 155 +            throw new IllegalArgumentException(&quot;Cannot notify carts of purge since there was no configuration provðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +                    &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +        CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +        int batchCount = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +        Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +        batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;&gt;(failedCartIds)).intValue();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +        List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;&gt;(failedCartIds));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        for (Order cart : carts) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            notifyCart(cart);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    @Override</span>















































 169      public void purgeCustomers(final Map&lt;String, String&gt; config) {
 170          if (LOG.isDebugEnabled()) {
 171              LOG.debug(&quot;Purging customers&quot;);
 172          }
 173          if (MapUtils.isEmpty(config)) {
<abbr title=" 174              throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. &quot; +"> 174              throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. ðŸ”µ</abbr>
 175                      &quot;In the absence of config params, all customers would be candidates for deletion.&quot;);
 176          }
 177          CustomerPurgeParams purgeParams = new CustomerPurgeParams(config).invoke();
 178          int processedCount = 0, batchCount = 0;
 179          synchronized(customerPurgeErrors) {

 180              Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);
<abbr title=" 181              batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 181              batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue()ðŸ”µ</abbr>
<abbr title=" 182              List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 182              List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCðŸ”µ</abbr>
 183              for (Customer customer : customers) {
 184                  TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,
 185                          TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 186                  try {
 187                      deleteCustomer(customer);
 188                      TransactionUtils.finalizeTransaction(status, transactionManager, false);
 189                      processedCount++;
 190                  } catch (Exception e) {
 191                      if (! status.isCompleted()) {

 192                          TransactionUtils.finalizeTransaction(status, transactionManager, true);
 193                      }
 194                      LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);
 195                      customerPurgeErrors.add(customer.getId());
 196                  }
 197              }
 198          }
<abbr title=" 199          LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 199          LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failureðŸ”µ</abbr>
 200      }
 201  
 202      /**
<abbr title=" 203       * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 203       * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cachðŸ”µ</abbr>
 204       *
 205       * @param purgeParams configured parameters for the cart purge process
 206       * @return set of cart ids to ignore/exclude from the next purge run
 207       */
 208      protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {
 209          long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 210          Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 211          return ignoreFailedCartIds;
 212      }
 213  
 214      /**
 215       * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic.
 216       *
 217       * @param purgeParams configured parameters for the Cart purge process

 218       * @param cartsInError list of cart ids to be ignored/excluded from the query
 219       * @return list of carts to delete
 220       */
<abbr title=" 221      protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 221      protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsIðŸ”µ</abbr>
 222          String[] nameArray = purgeParams.getNameArray();
 223          OrderStatus[] statusArray = purgeParams.getStatusArray();
 224          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 225          Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 226          return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 226          return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, leðŸ”µ</abbr>
 227      }
 228  
 229      /**
<abbr title=" 230       * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 230       * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logicðŸ”µ</abbr>
 231       *
 232       * @param purgeParams configured parameters for the Customer purge process used in the query
 233       * @param cartsInError list of cart ids to ignore/exclude from the next purge run
 234       * @return count of carts to delete
 235       */
 236      /**
 237       *
 238       */
 239      protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {
 240          String[] nameArray = purgeParams.getNameArray();
 241          OrderStatus[] statusArray = purgeParams.getStatusArray();
 242          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 243          Boolean isPreview = purgeParams.getIsPreview();
 244          Long cartBatchSize = purgeParams.getBatchSize();
<abbr title=" 245          Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 245          Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreviðŸ”µ</abbr>
 246          //return the lesser of the parameter batch size of the count of the orders to purge
 247          return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount;
 248      }
 249  
 250      /**
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +     * Notify the cart&#x27;s owner of a pending purge of their cart.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +     * @param cart the cart</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +    protected void notifyCart(Order cart) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +        String emailAddress = getEmailForCart(cart);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +        if (emailAddress != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +            Map&lt;String, Object&gt; context = new HashMap&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +            context.put(&quot;cart&quot;, cart);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +            context.put(&quot;customer&quot;, cart.getCustomer());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +            context.put(&quot;emailAddress&quot;, emailAddress);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 264 +                notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificationEventType.NOTIFY_ABANDONED_CART, context));"> 264 +                notificationDispatcher.dispatchNotification(new EmailNotification(emailAddress, NotificationEventTðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +            } catch (ServiceException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +                if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +                    LOG.debug(&quot;Failure to send email notification&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +    protected String getEmailForCart(Order cart) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +        if (cart.getEmailAddress() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +            return cart.getEmailAddress();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +        if (cart.getCustomer() != null &amp;&amp; cart.getCustomer().getEmailAddress() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +            return cart.getCustomer().getEmailAddress();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +        return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +    /**</span>
 286       * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic.
 287       *
 288       * @param cart the cart to remove
 289       */
 290      protected void deleteCart(Order cart) {
<abbr title=" 291          //We delete the order this way (rather than with a delete query) in order to ensure the cascades take place"> 291          //We delete the order this way (rather than with a delete query) in order to ensure the cascades take placðŸ”µ</abbr>
 292          orderService.deleteOrder(cart);
 293      }
 294  
 295      /**
 296       * Get the Customer Ids from cache that should be ignored due to errors in previous purge attempts
 297       *
 298       * @param purgeParams configured parameters for the Customer purge process
 299       * @return set of customer ids to ignore/exclude from the next purge run
 300       */
 301      protected Set&lt;Long&gt; getCustomersInErrorToIgnore(CustomerPurgeParams purgeParams) {
 302          long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 303          Set&lt;Long&gt; ignoreFailedCustomerIds = customerPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 304          return ignoreFailedCustomerIds;
 305      }
 306  
 307      /**
 308       * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic.
 309       *
 310       * @param purgeParams configured parameters for the Customer purge process

 311       * @param customersInError list of customer ids to be ignored/excluded from the query
 312       * @return list of customers to delete
 313       */
<abbr title=" 314      protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; customersInError) {"> 314      protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;LðŸ”µ</abbr>
 315          Boolean isRegistered = purgeParams.getIsRegistered();
 316          Boolean isDeactivated = purgeParams.getIsDeactivated();
 317          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 318          Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 319          return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, startPos, length, customersInError);"> 319          return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, staðŸ”µ</abbr>
 320      }
 321  
 322      /**
<abbr title=" 323       * Get the count of customers to delete from the database. Subclasses may override for custom customer retrieval logic."> 323       * Get the count of customers to delete from the database. Subclasses may override for custom customer retrievðŸ”µ</abbr>
 324       *
 325       * @param purgeParams configured parameters for the Customer purge process

 326       * @param customersInError list of customer ids to be ignored/excluded from the query
 327       * @return
 328       */
 329      protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInError) {
 330          Boolean isRegistered = purgeParams.getIsRegistered();
 331          Boolean isDeactivated = purgeParams.getIsDeactivated();
 332          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 333          Boolean isPreview = purgeParams.getIsPreview();
 334          Long customerBatchSize = purgeParams.getBatchSize();
<abbr title=" 335          Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, customersInError);"> 335          Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivðŸ”µ</abbr>
 336          //return the lesser of the parameter batch size of the count of the customers to purge
<abbr title=" 337          return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCount;"> 337          return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCounðŸ”µ</abbr>
 338      }
 339  
 340      /**
 341       * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic.
 342       *
 343       * @param customer the customer to remove
 344       */
 345      protected void deleteCustomer(Customer customer) {
<abbr title=" 346          //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take place"> 346          //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take pðŸ”µ</abbr>
 347          customerService.deleteCustomer(customer);
 348      }
 349  
 350      private class CartPurgeParams {
 351  
 352          private Map&lt;String, String&gt; config;
 353          private String[] nameArray;
 354          private OrderStatus[] statusArray;
 355          private Date dateCreatedMinThreshold;
 356          private Boolean isPreview;
 357          private Long batchSize;
 358          private Long failedRetryTime;
 359  
 360          public CartPurgeParams(Map&lt;String, String&gt; config) {
 361              this.config = config;
 362          }
 363  
 364          public String[] getNameArray() {
 365              return nameArray;
 366          }
 367  
 368          public OrderStatus[] getStatusArray() {
 369              return statusArray;
 370          }
 371  
 372          public Date getDateCreatedMinThreshold() {
 373              return dateCreatedMinThreshold;
 374          }
 375  
 376          public Boolean getIsPreview() {
 377              return isPreview;
 378          }
 379  
 380          public Long getBatchSize() {
 381              return batchSize;
 382          }
 383  
 384          public Long getFailedRetryTime() {
 385              return failedRetryTime;
 386          }
 387  
 388          public CartPurgeParams invoke() {
 389              nameArray = null;
 390              statusArray = null;
 391              dateCreatedMinThreshold = null;
 392              isPreview = null;
 393              batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 394              failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 395  
 396              for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 397                  if (PurgeCartVariableNames.STATUS.toString().equals(entry.getKey())) {
 398                      String[] temp = entry.getValue().split(&quot;,&quot;);
 399                      statusArray = new OrderStatus[temp.length];
 400                      int index = 0;
 401                      for (String name : temp) {
 402                          OrderStatus orderStatus = OrderStatus.getInstance(name);
 403                          statusArray[index] = orderStatus;
 404                          index++;
 405                      }
 406                  }
 407                  if (PurgeCartVariableNames.NAME.toString().equals(entry.getKey())) {
 408                      nameArray = entry.getValue().split(&quot;,&quot;);
 409                  }
 410                  if (PurgeCartVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 411                      Long secondsOld = Long.parseLong(entry.getValue());
 412                      dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 413                  }
 414                  if (PurgeCartVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 415                      isPreview = Boolean.parseBoolean(entry.getValue());
 416                  }
 417                  if (PurgeCartVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 418                      batchSize = Long.parseLong(entry.getValue());
 419                  }
 420                  if (PurgeCartVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
 421                      failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);
 422                  }
 423              }
 424              return this;
 425          }
 426      }
 427  
 428      private class CustomerPurgeParams {
 429  
 430          private Map&lt;String, String&gt; config;
 431          private Date dateCreatedMinThreshold;
 432          private Boolean isPreview;
 433          private Boolean isRegistered;
 434          private Boolean isDeactivated;
 435          private Long batchSize;
 436          private Long failedRetryTime;
 437  
 438          public CustomerPurgeParams(Map&lt;String, String&gt; config) {
 439              this.config = config;
 440          }
 441  
 442          public Date getDateCreatedMinThreshold() {
 443              return dateCreatedMinThreshold;
 444          }
 445  
 446          public Boolean getIsPreview() {
 447              return isPreview;
 448          }
 449  
 450          public Boolean getIsRegistered() {
 451              return isRegistered;
 452          }
 453  
 454          public Boolean getIsDeactivated() {
 455              return isDeactivated;
 456          }
 457  
 458          public Long getBatchSize() {
 459              return batchSize;
 460          }
 461  
 462          public Long getFailedRetryTime() {
 463              return failedRetryTime;
 464          }
 465  
 466          public CustomerPurgeParams invoke() {
 467              isRegistered = null;
 468              isDeactivated = null;
 469              dateCreatedMinThreshold = null;
 470              isPreview = null;
 471              batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 472              failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 473  
 474              for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 475                  if (PurgeCustomerVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 476                      Long secondsOld = Long.parseLong(entry.getValue());
 477                      dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 478                  }
 479                  if (PurgeCustomerVariableNames.IS_REGISTERED.toString().equals(entry.getKey())) {
 480                      isRegistered = Boolean.parseBoolean(entry.getValue());
 481                  }
 482                  if (PurgeCustomerVariableNames.IS_DEACTIVATED.toString().equals(entry.getKey())) {
 483                      isDeactivated = Boolean.parseBoolean(entry.getValue());
 484                  }
 485                  if (PurgeCustomerVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 486                      isPreview = Boolean.parseBoolean(entry.getValue());
 487                  }
 488                  if (PurgeCustomerVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 489                      batchSize = Long.parseLong(entry.getValue());
 490                  }
 491                  if (PurgeCustomerVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
 492                      failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);
 493                  }
 494              }
 495              return this;
 496          }
 497      }
 498  
 499      private class PurgeErrorCache {
 500  
 501          private Map&lt;Long, Long&gt; cache = new HashMap&lt;Long, Long&gt;();
 502  
 503          public Long add(Long entry) {
 504              if (! cache.containsKey(entry)) {

 505                  return cache.put(entry, new Long(System.currentTimeMillis()));
 506              }
 507              return null;
 508          }
 509  
 510          public Set&lt;Long&gt; getEntriesSince(long expiredTime) {
 511              for(Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext(); ) {

 512                  Map.Entry&lt;Long, Long&gt; entry = item.next();
 513                  if(entry.getValue().longValue() &lt; expiredTime) {
 514                    item.remove();


 515                  }
 516              }
 517              return cache.keySet();
 518          }
 519  
 520          public int size() {
 521              return cache.size();
 522          }
 523  
 524      }
 525  
 526  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Framework
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.core.util.service;
  19  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 -import java.util.Date;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import java.util.HashMap;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import java.util.Iterator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import java.util.Map;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 -import java.util.Set;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import javax.annotation.Resource;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -</span>
  30  import org.apache.commons.collections.MapUtils;
  31  import org.apache.commons.logging.Log;
  32  import org.apache.commons.logging.LogFactory;




  33  import org.broadleafcommerce.common.time.SystemTime;
  34  import org.broadleafcommerce.common.util.TransactionUtils;
  35  import org.broadleafcommerce.core.order.domain.Order;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.broadleafcommerce.core.order.domain.OrderImpl;</span>
  37  import org.broadleafcommerce.core.order.service.OrderService;
  38  import org.broadleafcommerce.core.order.service.type.OrderStatus;
  39  import org.broadleafcommerce.core.util.dao.ResourcePurgeDao;
  40  import org.broadleafcommerce.core.util.service.type.PurgeCartVariableNames;
  41  import org.broadleafcommerce.core.util.service.type.PurgeCustomerVariableNames;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +import org.broadleafcommerce.core.util.service.type.PurgeOrderHistoryVariableNames;</span>
  43  import org.broadleafcommerce.profile.core.domain.Customer;
  44  import org.broadleafcommerce.profile.core.service.CustomerService;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import org.hibernate.Session;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import org.hibernate.jdbc.Work;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import org.springframework.beans.factory.annotation.Autowired;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import org.springframework.core.env.Environment;</span>
  49  import org.springframework.stereotype.Service;
  50  import org.springframework.transaction.PlatformTransactionManager;
  51  import org.springframework.transaction.TransactionDefinition;
  52  import org.springframework.transaction.TransactionStatus;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import java.sql.Connection;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +import java.sql.SQLException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +import java.sql.Statement;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import java.util.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import javax.annotation.Resource;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import javax.persistence.EntityManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import javax.persistence.PersistenceContext;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +</span>
  63  
  64  /**
<abbr title="  65   * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous Customers).">  65   * Service capable of deleting old or defunct entities from the persistence layer (e.g. Carts and anonymous CustomðŸ”µ</abbr>
  66   * {@link ResourcePurgeService} for additional API documentation.
  67   * &lt;p/&gt;
  68   * A basic Quartz scheduled job configuration for calling this service can be configured as follows:
  69   * &lt;p/&gt;
  70   * {@code
  71   * &lt;bean id=&quot;purgeCartConfig&quot; class=&quot;org.springframework.beans.factory.config.MapFactoryBean&quot;&gt;
  72   * &lt;property name=&quot;sourceMap&quot;&gt;
  73   * &lt;map&gt;
  74   * &lt;entry key=&quot;SECONDS_OLD&quot; value=&quot;2592000&quot;/&gt;
  75   * &lt;entry key=&quot;STATUS&quot; value=&quot;IN_PROCESS&quot;/&gt;
  76   * &lt;/map&gt;
  77   * &lt;/property&gt;
  78   * &lt;/bean&gt;
  79   * &lt;p/&gt;
  80   * &lt;bean id=&quot;purgeCartJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;
  81   * &lt;property name=&quot;targetObject&quot; ref=&quot;blResourcePurgeService&quot; /&gt;
  82   * &lt;property name=&quot;targetMethod&quot; value=&quot;purgeCarts&quot; /&gt;
  83   * &lt;property name=&quot;arguments&quot;&gt;
  84   * &lt;list&gt;
  85   * &lt;ref bean=&quot;purgeCartConfig&quot;/&gt;
  86   * &lt;/list&gt;
  87   * &lt;/property&gt;
  88   * &lt;/bean&gt;
  89   * &lt;p/&gt;
  90   * &lt;bean id=&quot;purgeCartTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;
  91   * &lt;property name=&quot;jobDetail&quot; ref=&quot;purgeCartJobDetail&quot; /&gt;
  92   * &lt;property name=&quot;startDelay&quot; value=&quot;30000&quot; /&gt;
  93   * &lt;property name=&quot;repeatInterval&quot; value=&quot;86400000&quot; /&gt;
  94   * &lt;/bean&gt;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 - *}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 + * }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 + *</span>
  98   * @author Jeff Fischer
  99   */
 100  @Service(&quot;blResourcePurgeService&quot;)
 101  public class ResourcePurgeServiceImpl implements ResourcePurgeService {
 102  
 103      private static final Log LOG = LogFactory.getLog(ResourcePurgeServiceImpl.class);
 104  
 105      private static final Long BATCH_SIZE = 50L;
 106      private static final Long PURGE_ERROR_CACHE_RETRY_SECONDS = System.currentTimeMillis() - 172800; //48 HOURS
 107  
 108      protected PurgeErrorCache customerPurgeErrors = new PurgeErrorCache();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +    protected PurgeErrorCache historyPurgeErrors = new PurgeErrorCache();</span>
 110      protected PurgeErrorCache cartPurgeErrors = new PurgeErrorCache();
 111  
 112      @Resource(name = &quot;blTransactionManager&quot;)
 113      protected PlatformTransactionManager transactionManager;
 114  
 115      @Resource(name = &quot;blResourcePurgeDao&quot;)
 116      protected ResourcePurgeDao resourcePurgeDao;
 117  
 118      @Resource(name = &quot;blOrderService&quot;)
 119      protected OrderService orderService;
 120  
 121      @Resource(name = &quot;blCustomerService&quot;)
 122      protected CustomerService customerService;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +    @Resource(name = &quot;blDeleteStatementGenerator&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    protected DeleteStatementGenerator deleteStatementGenerator;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +    @Autowired</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +    protected Environment env;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +    @PersistenceContext(unitName = &quot;blPU&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +    protected EntityManager em;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    @Resource(name = &quot;blResourcePurgeExtensionManager&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    protected ResourcePurgeExtensionManager extensionManager;</span>
 135  




 136      @Override
 137      public void purgeCarts(final Map&lt;String, String&gt; config) {
 138          if (LOG.isDebugEnabled()) {
 139              LOG.debug(&quot;Purging carts&quot;);
 140          }
 141          if (MapUtils.isEmpty(config)) {
 142              throw new IllegalArgumentException(&quot;Cannot purge carts since there was no configuration provided. &quot; +
 143                      &quot;In the absence of config params, all carts would be candidates for deletion.&quot;);
 144          }
 145          CartPurgeParams purgeParams = new CartPurgeParams(config).invoke();
 146          int processedCount = 0, batchCount = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -        synchronized(cartPurgeErrors) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +        synchronized (cartPurgeErrors) {</span>
 149              Set&lt;Long&gt; failedCartIds = getCartsInErrorToIgnore(purgeParams);
 150              batchCount = getCartsToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCartIds)).intValue();
 151              List&lt;Order&gt; carts = getCartsToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCartIds));
 152              for (Order cart : carts) {
 153                  TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,
 154                          TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 155                  try {
 156                      deleteCart(cart);
 157                      TransactionUtils.finalizeTransaction(status, transactionManager, false);
 158                      processedCount++;
 159                  } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -                    if (! status.isCompleted()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +                    if (!status.isCompleted()) {</span>
 162                          TransactionUtils.finalizeTransaction(status, transactionManager, true);
 163                      }
 164                      LOG.error(String.format(&quot;Not able to purge Cart ID: %d&quot;, cart.getId()), e);
 165                      cartPurgeErrors.add(cart.getId());
 166                  }
 167              }
 168          }
<abbr title=" 169          LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, cartPurgeErrors.size()));"> 169          LOG.info(String.format(&quot;Cart purge batch processed.  Purged %d from total batch size of %d, %d failures caðŸ”µ</abbr>
 170      }
 171  
 172      @Override
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 173 +    public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; depends, final Map&lt;String, Integer&gt; config) {"> 173 +    public void purgeOrderHistory(Class&lt;?&gt; rootType, String rootTypeIdValue, Map&lt;String, List&lt;DeleteStatementGenerðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        if (LOG.isDebugEnabled()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +            LOG.debug(&quot;Purging historical orders&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +        String enablePurge = env.getProperty(&quot;enable.purge.order.history&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +        if (!Boolean.parseBoolean(enablePurge)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 182 +            LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.history to true.&quot;);"> 182 +            LOG.info(&quot;Save protection. Purging history is off. Please set property enable.purge.order.history to tðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +        Integer daysCount = config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +        Integer batchSize = config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        List&lt;Order&gt; oldOrders = orderService.findOrdersByDaysCount(daysCount, batchSize);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +        Map&lt;String, List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; dependencies = new HashMap&lt;&gt;(depends);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +        List&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderDependencies = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 194 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));"> 194 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &quot;ORDER_ID&quot;, &quot;ORDER_IDðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +        dependencies.put(&quot;BLC_ORDER&quot;, orderDependencies);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +        ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; orderItemDependencies = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 199 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 199 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &quot;ORDER_MUðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 200 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));"> 200 +        orderDependencies.add(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &quot;ORDER_ITEM_ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +        dependencies.put(&quot;BLC_ORDER_ITEM&quot;, orderItemDependencies);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 202 +        dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));"> 202 +        dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, Collections.singletonList(new DeleteStatementGeneratorImpl.PathElemeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +        extensionManager.getProxy().addPurgeDependencies(dependencies);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +        Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +        exclusions.add(&quot;BLC_ADMIN_USER&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +        extensionManager.getProxy().addPurgeExclusions(exclusions);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 207 +        Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &quot;?&quot;, dependencies, exclusions);"> 207 +        Map&lt;String, String&gt; deleteStatement = deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.cðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +        for (Order order : oldOrders) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +            TransactionStatus status = TransactionUtils.createTransaction(&quot;Cart Purge&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                    TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +                em.unwrap(Session.class).doWork(new Work() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +                    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                    public void execute(Connection connection) throws SQLException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +                        Statement statement = connection.createStatement();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                        for (String value : deleteStatement.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                            String sql = value.replace(&quot;?&quot;, String.valueOf(order.getId()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +                            LOG.debug(sql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +                            statement.addBatch(sql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +                        extensionManager.getProxy().addPurgeStatements(statement, rootTypeIdValue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +                        statement.executeBatch();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +                TransactionUtils.finalizeTransaction(status, transactionManager, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +            } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +                if (!status.isCompleted()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +                    TransactionUtils.finalizeTransaction(status, transactionManager, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                LOG.error(String.format(&quot;Not able to purge Order ID: %d&quot;, order.getId()), e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        LOG.info(&quot;Finished purging historical orders.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +    @Override</span>
 239      public void purgeCustomers(final Map&lt;String, String&gt; config) {
 240          if (LOG.isDebugEnabled()) {
 241              LOG.debug(&quot;Purging customers&quot;);
 242          }
 243          if (MapUtils.isEmpty(config)) {
<abbr title=" 244              throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. &quot; +"> 244              throw new IllegalArgumentException(&quot;Cannot purge customers since there was no configuration provided. ðŸ”µ</abbr>
 245                      &quot;In the absence of config params, all customers would be candidates for deletion.&quot;);
 246          }
 247          CustomerPurgeParams purgeParams = new CustomerPurgeParams(config).invoke();
 248          int processedCount = 0, batchCount = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -        synchronized(customerPurgeErrors) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +        synchronized (customerPurgeErrors) {</span>
 251              Set&lt;Long&gt; failedCustomerIds = getCustomersInErrorToIgnore(purgeParams);
<abbr title=" 252              batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue();"> 252              batchCount = getCustomersToPurgeLength(purgeParams, new ArrayList&lt;Long&gt;(failedCustomerIds)).intValue()ðŸ”µ</abbr>
<abbr title=" 253              List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCustomerIds));"> 253              List&lt;Customer&gt; customers = getCustomersToPurge(purgeParams, 0, batchCount, new ArrayList&lt;Long&gt;(failedCðŸ”µ</abbr>
 254              for (Customer customer : customers) {
 255                  TransactionStatus status = TransactionUtils.createTransaction(&quot;Customer Purge&quot;,
 256                          TransactionDefinition.PROPAGATION_REQUIRED, transactionManager, false);
 257                  try {
 258                      deleteCustomer(customer);
 259                      TransactionUtils.finalizeTransaction(status, transactionManager, false);
 260                      processedCount++;
 261                  } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -                    if (! status.isCompleted()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +                    if (!status.isCompleted()) {</span>
 264                          TransactionUtils.finalizeTransaction(status, transactionManager, true);
 265                      }
 266                      LOG.error(String.format(&quot;Not able to purge Customer ID: %d&quot;, customer.getId()), e);
 267                      customerPurgeErrors.add(customer.getId());
 268                  }
 269              }
 270          }
<abbr title=" 271          LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failures cached&quot;, processedCount, batchCount, customerPurgeErrors.size()));"> 271          LOG.info(String.format(&quot;Customer purge batch processed.  Purged %d from total batch size of %d, %d failureðŸ”µ</abbr>
 272      }
 273  
 274      /**
<abbr title=" 275       * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cached errors removed."> 275       * Get the Carts Ids from cache that should be ignored due to errors in previous purge attempts.  Expired cachðŸ”µ</abbr>
 276       *
 277       * @param purgeParams configured parameters for the cart purge process
 278       * @return set of cart ids to ignore/exclude from the next purge run
 279       */
 280      protected Set&lt;Long&gt; getCartsInErrorToIgnore(CartPurgeParams purgeParams) {
 281          long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 282          Set&lt;Long&gt; ignoreFailedCartIds = cartPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 283          return ignoreFailedCartIds;
 284      }
 285  
 286      /**
 287       * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic.
 288       *
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -     * @param purgeParams configured parameters for the Cart purge process</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +     * @param purgeParams  configured parameters for the Cart purge process</span>
 291       * @param cartsInError list of cart ids to be ignored/excluded from the query
 292       * @return list of carts to delete
 293       */
<abbr title=" 294      protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsInError) {"> 294      protected List&lt;Order&gt; getCartsToPurge(CartPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; cartsIðŸ”µ</abbr>
 295          String[] nameArray = purgeParams.getNameArray();
 296          OrderStatus[] statusArray = purgeParams.getStatusArray();
 297          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 298          Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 299          return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, length, cartsInError);"> 299          return resourcePurgeDao.findCarts(nameArray, statusArray, dateCreatedMinThreshold, isPreview, startPos, leðŸ”µ</abbr>
 300      }
 301  
 302      /**
<abbr title=" 303       * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logic."> 303       * Get the count of carts to delete from the database. Subclasses may override for custom cart retrieval logicðŸ”µ</abbr>
 304       *
 305       * @param purgeParams configured parameters for the Customer purge process used in the query
 306       * @param cartsInError list of cart ids to ignore/exclude from the next purge run
 307       * @return count of carts to delete
 308       */
 309      /**
 310       *
 311       */
 312      protected Long getCartsToPurgeLength(CartPurgeParams purgeParams, List&lt;Long&gt; cartsInError) {
 313          String[] nameArray = purgeParams.getNameArray();
 314          OrderStatus[] statusArray = purgeParams.getStatusArray();
 315          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 316          Boolean isPreview = purgeParams.getIsPreview();
 317          Long cartBatchSize = purgeParams.getBatchSize();
<abbr title=" 318          Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreview, cartsInError);"> 318          Long orderCount = resourcePurgeDao.findCartsCount(nameArray, statusArray, dateCreatedMinThreshold, isPreviðŸ”µ</abbr>
 319          //return the lesser of the parameter batch size of the count of the orders to purge
 320          return cartBatchSize != null &amp;&amp; cartBatchSize &lt; orderCount ? cartBatchSize : orderCount;
 321      }
 322  
 323      /**



































 324       * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic.
 325       *
 326       * @param cart the cart to remove
 327       */
 328      protected void deleteCart(Order cart) {
<abbr title=" 329          //We delete the order this way (rather than with a delete query) in order to ensure the cascades take place"> 329          //We delete the order this way (rather than with a delete query) in order to ensure the cascades take placðŸ”µ</abbr>
 330          orderService.deleteOrder(cart);
 331      }
 332  
 333      /**
 334       * Get the Customer Ids from cache that should be ignored due to errors in previous purge attempts
 335       *
 336       * @param purgeParams configured parameters for the Customer purge process
 337       * @return set of customer ids to ignore/exclude from the next purge run
 338       */
 339      protected Set&lt;Long&gt; getCustomersInErrorToIgnore(CustomerPurgeParams purgeParams) {
 340          long ignoreFailedExpiration = purgeParams.getFailedRetryTime().longValue();
 341          Set&lt;Long&gt; ignoreFailedCustomerIds = customerPurgeErrors.getEntriesSince(ignoreFailedExpiration);
 342          return ignoreFailedCustomerIds;
 343      }
 344  
 345      /**
 346       * Get the list of carts to delete from the database. Subclasses may override for custom cart retrieval logic.
 347       *
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 348 -     * @param purgeParams configured parameters for the Customer purge process</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +     * @param purgeParams      configured parameters for the Customer purge process</span>
 350       * @param customersInError list of customer ids to be ignored/excluded from the query
 351       * @return list of customers to delete
 352       */
<abbr title=" 353      protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;Long&gt; customersInError) {"> 353      protected List&lt;Customer&gt; getCustomersToPurge(CustomerPurgeParams purgeParams, int startPos, int length, List&lt;LðŸ”µ</abbr>
 354          Boolean isRegistered = purgeParams.getIsRegistered();
 355          Boolean isDeactivated = purgeParams.getIsDeactivated();
 356          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 357          Boolean isPreview = purgeParams.getIsPreview();
<abbr title=" 358          return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, startPos, length, customersInError);"> 358          return resourcePurgeDao.findCustomers(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, staðŸ”µ</abbr>
 359      }
 360  
 361      /**
<abbr title=" 362       * Get the count of customers to delete from the database. Subclasses may override for custom customer retrieval logic."> 362       * Get the count of customers to delete from the database. Subclasses may override for custom customer retrievðŸ”µ</abbr>
 363       *
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -     * @param purgeParams configured parameters for the Customer purge process</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +     * @param purgeParams      configured parameters for the Customer purge process</span>
 366       * @param customersInError list of customer ids to be ignored/excluded from the query
 367       * @return
 368       */
 369      protected Long getCustomersToPurgeLength(CustomerPurgeParams purgeParams, List&lt;Long&gt; customersInError) {
 370          Boolean isRegistered = purgeParams.getIsRegistered();
 371          Boolean isDeactivated = purgeParams.getIsDeactivated();
 372          Date dateCreatedMinThreshold = purgeParams.getDateCreatedMinThreshold();
 373          Boolean isPreview = purgeParams.getIsPreview();
 374          Long customerBatchSize = purgeParams.getBatchSize();
<abbr title=" 375          Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivated, isPreview, customersInError);"> 375          Long customersCount = resourcePurgeDao.findCustomersCount(dateCreatedMinThreshold, isRegistered, isDeactivðŸ”µ</abbr>
 376          //return the lesser of the parameter batch size of the count of the customers to purge
<abbr title=" 377          return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCount;"> 377          return customerBatchSize != null &amp;&amp; customerBatchSize &lt; customersCount ? customerBatchSize : customersCounðŸ”µ</abbr>
 378      }
 379  
 380      /**
 381       * Remove the cart from the persistence layer. Subclasses may override for custom cart retrieval logic.
 382       *
 383       * @param customer the customer to remove
 384       */
 385      protected void deleteCustomer(Customer customer) {
<abbr title=" 386          //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take place"> 386          //We delete the customer this way (rather than with a delete query) in order to ensure the cascades take pðŸ”µ</abbr>
 387          customerService.deleteCustomer(customer);
 388      }
 389  
 390      private class CartPurgeParams {
 391  
 392          private Map&lt;String, String&gt; config;
 393          private String[] nameArray;
 394          private OrderStatus[] statusArray;
 395          private Date dateCreatedMinThreshold;
 396          private Boolean isPreview;
 397          private Long batchSize;
 398          private Long failedRetryTime;
 399  
 400          public CartPurgeParams(Map&lt;String, String&gt; config) {
 401              this.config = config;
 402          }
 403  
 404          public String[] getNameArray() {
 405              return nameArray;
 406          }
 407  
 408          public OrderStatus[] getStatusArray() {
 409              return statusArray;
 410          }
 411  
 412          public Date getDateCreatedMinThreshold() {
 413              return dateCreatedMinThreshold;
 414          }
 415  
 416          public Boolean getIsPreview() {
 417              return isPreview;
 418          }
 419  
 420          public Long getBatchSize() {
 421              return batchSize;
 422          }
 423  
 424          public Long getFailedRetryTime() {
 425              return failedRetryTime;
 426          }
 427  
 428          public CartPurgeParams invoke() {
 429              nameArray = null;
 430              statusArray = null;
 431              dateCreatedMinThreshold = null;
 432              isPreview = null;
 433              batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 434              failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 435  
 436              for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 437                  if (PurgeCartVariableNames.STATUS.toString().equals(entry.getKey())) {
 438                      String[] temp = entry.getValue().split(&quot;,&quot;);
 439                      statusArray = new OrderStatus[temp.length];
 440                      int index = 0;
 441                      for (String name : temp) {
 442                          OrderStatus orderStatus = OrderStatus.getInstance(name);
 443                          statusArray[index] = orderStatus;
 444                          index++;
 445                      }
 446                  }
 447                  if (PurgeCartVariableNames.NAME.toString().equals(entry.getKey())) {
 448                      nameArray = entry.getValue().split(&quot;,&quot;);
 449                  }
 450                  if (PurgeCartVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 451                      Long secondsOld = Long.parseLong(entry.getValue());
 452                      dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 453                  }
 454                  if (PurgeCartVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 455                      isPreview = Boolean.parseBoolean(entry.getValue());
 456                  }
 457                  if (PurgeCartVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 458                      batchSize = Long.parseLong(entry.getValue());
 459                  }
 460                  if (PurgeCartVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
 461                      failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);
 462                  }
 463              }
 464              return this;
 465          }
 466      }
 467  
 468      private class CustomerPurgeParams {
 469  
 470          private Map&lt;String, String&gt; config;
 471          private Date dateCreatedMinThreshold;
 472          private Boolean isPreview;
 473          private Boolean isRegistered;
 474          private Boolean isDeactivated;
 475          private Long batchSize;
 476          private Long failedRetryTime;
 477  
 478          public CustomerPurgeParams(Map&lt;String, String&gt; config) {
 479              this.config = config;
 480          }
 481  
 482          public Date getDateCreatedMinThreshold() {
 483              return dateCreatedMinThreshold;
 484          }
 485  
 486          public Boolean getIsPreview() {
 487              return isPreview;
 488          }
 489  
 490          public Boolean getIsRegistered() {
 491              return isRegistered;
 492          }
 493  
 494          public Boolean getIsDeactivated() {
 495              return isDeactivated;
 496          }
 497  
 498          public Long getBatchSize() {
 499              return batchSize;
 500          }
 501  
 502          public Long getFailedRetryTime() {
 503              return failedRetryTime;
 504          }
 505  
 506          public CustomerPurgeParams invoke() {
 507              isRegistered = null;
 508              isDeactivated = null;
 509              dateCreatedMinThreshold = null;
 510              isPreview = null;
 511              batchSize = ResourcePurgeServiceImpl.BATCH_SIZE;
 512              failedRetryTime = ResourcePurgeServiceImpl.PURGE_ERROR_CACHE_RETRY_SECONDS;
 513  
 514              for (Map.Entry&lt;String, String&gt; entry : config.entrySet()) {
 515                  if (PurgeCustomerVariableNames.SECONDS_OLD.toString().equals(entry.getKey())) {
 516                      Long secondsOld = Long.parseLong(entry.getValue());
 517                      dateCreatedMinThreshold = new Date(SystemTime.asMillis() - (secondsOld * 1000));
 518                  }
 519                  if (PurgeCustomerVariableNames.IS_REGISTERED.toString().equals(entry.getKey())) {
 520                      isRegistered = Boolean.parseBoolean(entry.getValue());
 521                  }
 522                  if (PurgeCustomerVariableNames.IS_DEACTIVATED.toString().equals(entry.getKey())) {
 523                      isDeactivated = Boolean.parseBoolean(entry.getValue());
 524                  }
 525                  if (PurgeCustomerVariableNames.IS_PREVIEW.toString().equals(entry.getKey())) {
 526                      isPreview = Boolean.parseBoolean(entry.getValue());
 527                  }
 528                  if (PurgeCustomerVariableNames.BATCH_SIZE.toString().equals(entry.getKey())) {
 529                      batchSize = Long.parseLong(entry.getValue());
 530                  }
 531                  if (PurgeCustomerVariableNames.RETRY_FAILED_SECONDS.toString().equals(entry.getKey())) {
 532                      failedRetryTime = System.currentTimeMillis() - (Long.parseLong(entry.getValue()) * 1000);
 533                  }
 534              }
 535              return this;
 536          }
 537      }
 538  
 539      private class PurgeErrorCache {
 540  
 541          private Map&lt;Long, Long&gt; cache = new HashMap&lt;Long, Long&gt;();
 542  
 543          public Long add(Long entry) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 544 -            if (! cache.containsKey(entry)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +            if (!cache.containsKey(entry)) {</span>
 546                  return cache.put(entry, new Long(System.currentTimeMillis()));
 547              }
 548              return null;
 549          }
 550  
 551          public Set&lt;Long&gt; getEntriesSince(long expiredTime) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -            for(Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext(); ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +            for (Iterator&lt;Map.Entry&lt;Long, Long&gt;&gt; item = cache.entrySet().iterator(); item.hasNext(); ) {</span>
 554                  Map.Entry&lt;Long, Long&gt; entry = item.next();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -                if(entry.getValue().longValue() &lt; expiredTime) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -                  item.remove();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 557 +                if (entry.getValue().longValue() &lt; expiredTime) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +                    item.remove();</span>
 559                  }
 560              }
 561              return cache.keySet();
 562          }
 563  
 564          public int size() {
 565              return cache.size();
 566          }
 567  
 568      }
 569  
 570  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            