<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>562 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    // This method looks in the specified direction &#x27;
                         &#x27;to see if there is an additional view\n&#x27;
                         &#x27;    // immediately adjecent in that direction\n&#x27;
                         &#x27;    private boolean &#x27;
                         &#x27;addViewInDirection(ArrayList&lt;View&gt; views, Rect &#x27;
                         &#x27;boundingRect, int[] direction,\n&#x27;
                         &#x27;            boolean[][] occupied) {\n&#x27;
                         &#x27;        boolean found = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int childCount = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildCount();\n&#x27;
                         &#x27;        Rect r0 = new Rect(boundingRect);\n&#x27;
                         &#x27;        Rect r1 = new Rect();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = 0;\n&#x27;
                         &#x27;        int deltaY = 0;\n&#x27;
                         &#x27;        if (direction[1] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top - 1, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaY = -1;\n&#x27;
                         &#x27;        } else if (direction[1] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom + 1);\n&#x27;
                         &#x27;            deltaY = 1;\n&#x27;
                         &#x27;        } else if (direction[0] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left - 1, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = -1;\n&#x27;
                         &#x27;        } else if (direction[0] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right + 1, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = 1;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (int i = 0; i &lt; childCount; i++) {\n&#x27;
                         &#x27;            View child = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildAt(i);\n&#x27;
                         &#x27;            if (views.contains(child)) continue;\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;child.getLayoutParams();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            r1.set(lp.tmpCellX, lp.tmpCellY, &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            if (Rect.intersects(r0, r1)) {\n&#x27;
                         &#x27;                if (!lp.canReorder) {\n&#x27;
                         &#x27;                    return false;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                boolean pushed = false;\n&#x27;
                         &#x27;                for (int x = lp.tmpCellX; x &lt; &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan; x++) {\n&#x27;
                         &#x27;                    for (int y = lp.tmpCellY; y &lt; &#x27;
                         &#x27;lp.tmpCellY + lp.cellVSpan; y++) {\n&#x27;
                         &#x27;                        boolean inBounds = x - &#x27;
                         &#x27;deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX\n&#x27;
                         &#x27;                                &amp;&amp; y - deltaY &gt;= 0 &#x27;
                         &#x27;&amp;&amp; y - deltaY &lt; mCountY;\n&#x27;
                         &#x27;                        if (inBounds &amp;&amp; occupied[x - &#x27;
                         &#x27;deltaX][y - deltaY]) {\n&#x27;
                         &#x27;                            pushed = true;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                if (pushed) {\n&#x27;
                         &#x27;                    views.add(child);\n&#x27;
                         &#x27;                    boundingRect.union(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                            lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;                    found = true;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return found;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private boolean &#x27;
                         &#x27;pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect &#x27;
                         &#x27;rectOccupiedByPotentialDrop,\n&#x27;
                         &#x27;            int[] direction) {\n&#x27;
                         &#x27;        if (views.size() == 0) return true;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        boolean success = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        // We construct a rect which represents the &#x27;
                         &#x27;entire group of views\n&#x27;
                         &#x27;        Rect boundingRect = null;\n&#x27;
                         &#x27;        for (View v: views) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            if (boundingRect == null) {\n&#x27;
                         &#x27;                boundingRect = new Rect(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                        lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                boundingRect.union(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                        lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) &#x27;
                         &#x27;views.clone();\n&#x27;
                         &#x27;        while (addViewInDirection(dup, boundingRect, &#x27;
                         &#x27;direction, mTmpOccupied)) {\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, mTmpOccupied, &#x27;
                         &#x27;false); \n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        boolean[][] blockOccupied = new &#x27;
                         &#x27;boolean[boundingRect.width()][boundingRect.height()];\n&#x27;
                         &#x27;        int top = boundingRect.top;\n&#x27;
                         &#x27;        int left = boundingRect.left;\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX - left, &#x27;
                         &#x27;lp.tmpCellY - top, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, blockOccupied, &#x27;
                         &#x27;true); \n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;markCellsForRect(rectOccupiedByPotentialDrop, &#x27;
                         &#x27;mTmpOccupied, true);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;findNearestAreaInDirection(boundingRect.left, &#x27;
                         &#x27;boundingRect.top, boundingRect.width(),\n&#x27;
                         &#x27;                boundingRect.height(), direction, &#x27;
                         &#x27;mTmpOccupied, blockOccupied, mTempLocation);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = mTempLocation[0] - &#x27;
                         &#x27;boundingRect.left;\n&#x27;
                         &#x27;        int deltaY = mTempLocation[1] - &#x27;
                         &#x27;boundingRect.top;\n&#x27;
                         &#x27;        if (mTempLocation[0] &gt;= 0 &amp;&amp; &#x27;
                         &#x27;mTempLocation[1] &gt;= 0) {\n&#x27;
                         &#x27;            for (View v: dup) {\n&#x27;
                         &#x27;                LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;                lp.tmpCellX += deltaX;\n&#x27;
                         &#x27;                lp.tmpCellY += deltaY;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            success = true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, mTmpOccupied, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return success;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;private boolean addViewInDirection(ArrayList&lt;View&gt; &#x27;
                         &#x27;views, Rect boundingRect, int[] direction,\n&#x27;
                         &#x27;            boolean[][] occupied) {\n&#x27;
                         &#x27;        boolean found = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int childCount = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildCount();\n&#x27;
                         &#x27;        Rect r0 = new Rect(boundingRect);\n&#x27;
                         &#x27;        Rect r1 = new Rect();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = 0;\n&#x27;
                         &#x27;        int deltaY = 0;\n&#x27;
                         &#x27;        if (direction[1] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top - 1, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaY = -1;\n&#x27;
                         &#x27;        } else if (direction[1] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom + 1);\n&#x27;
                         &#x27;            deltaY = 1;\n&#x27;
                         &#x27;        } else if (direction[0] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left - 1, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = -1;\n&#x27;
                         &#x27;        } else if (direction[0] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right + 1, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = 1;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (int i = 0; i &lt; childCount; i++) {\n&#x27;
                         &#x27;            View child = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildAt(i);\n&#x27;
                         &#x27;            if (views.contains(child)) continue;\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;child.getLayoutParams();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            r1.set(lp.tmpCellX, lp.tmpCellY, &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            if (Rect.intersects(r0, r1)) {\n&#x27;
                         &#x27;                if (!lp.canReorder) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;@Override\n&#x27;
                           &#x27;    public boolean shouldDelayChildPressedState() &#x27;
                           &#x27;{\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    // This method looks in the specified direction &#x27;
                         &#x27;to see if there is an additional view\n&#x27;
                         &#x27;    // immediately adjecent in that direction\n&#x27;
                         &#x27;    private boolean &#x27;
                         &#x27;addViewInDirection(ArrayList&lt;View&gt; views, Rect &#x27;
                         &#x27;boundingRect, int[] direction,\n&#x27;
                         &#x27;            boolean[][] occupied) {\n&#x27;
                         &#x27;        boolean found = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int childCount = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildCount();\n&#x27;
                         &#x27;        Rect r0 = new Rect(boundingRect);\n&#x27;
                         &#x27;        Rect r1 = new Rect();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = 0;\n&#x27;
                         &#x27;        int deltaY = 0;\n&#x27;
                         &#x27;        if (direction[1] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top - 1, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaY = -1;\n&#x27;
                         &#x27;        } else if (direction[1] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom + 1);\n&#x27;
                         &#x27;            deltaY = 1;\n&#x27;
                         &#x27;        } else if (direction[0] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left - 1, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = -1;\n&#x27;
                         &#x27;        } else if (direction[0] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right + 1, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = 1;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (int i = 0; i &lt; childCount; i++) {\n&#x27;
                         &#x27;            View child = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildAt(i);\n&#x27;
                         &#x27;            if (views.contains(child)) continue;\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;child.getLayoutParams();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            r1.set(lp.tmpCellX, lp.tmpCellY, &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            if (Rect.intersects(r0, r1)) {\n&#x27;
                         &#x27;                if (!lp.canReorder) {\n&#x27;
                         &#x27;                    return false;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                boolean pushed = false;\n&#x27;
                         &#x27;                for (int x = lp.tmpCellX; x &lt; &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan; x++) {\n&#x27;
                         &#x27;                    for (int y = lp.tmpCellY; y &lt; &#x27;
                         &#x27;lp.tmpCellY + lp.cellVSpan; y++) {\n&#x27;
                         &#x27;                        boolean inBounds = x - &#x27;
                         &#x27;deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX\n&#x27;
                         &#x27;                                &amp;&amp; y - deltaY &gt;= 0 &#x27;
                         &#x27;&amp;&amp; y - deltaY &lt; mCountY;\n&#x27;
                         &#x27;                        if (inBounds &amp;&amp; occupied[x - &#x27;
                         &#x27;deltaX][y - deltaY]) {\n&#x27;
                         &#x27;                            pushed = true;\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;                if (pushed) {\n&#x27;
                         &#x27;                    views.add(child);\n&#x27;
                         &#x27;                    boundingRect.union(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                            lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;                    found = true;\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return found;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private boolean &#x27;
                         &#x27;pushViewsToTempLocation(ArrayList&lt;View&gt; views, Rect &#x27;
                         &#x27;rectOccupiedByPotentialDrop,\n&#x27;
                         &#x27;            int[] direction) {\n&#x27;
                         &#x27;        if (views.size() == 0) return true;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        boolean success = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        // We construct a rect which represents the &#x27;
                         &#x27;entire group of views\n&#x27;
                         &#x27;        Rect boundingRect = null;\n&#x27;
                         &#x27;        for (View v: views) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            if (boundingRect == null) {\n&#x27;
                         &#x27;                boundingRect = new Rect(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                        lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                boundingRect.union(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.tmpCellX + lp.cellHSpan,\n&#x27;
                         &#x27;                        lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) &#x27;
                         &#x27;views.clone();\n&#x27;
                         &#x27;        while (addViewInDirection(dup, boundingRect, &#x27;
                         &#x27;direction, mTmpOccupied)) {\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, mTmpOccupied, &#x27;
                         &#x27;false); \n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        boolean[][] blockOccupied = new &#x27;
                         &#x27;boolean[boundingRect.width()][boundingRect.height()];\n&#x27;
                         &#x27;        int top = boundingRect.top;\n&#x27;
                         &#x27;        int left = boundingRect.left;\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX - left, &#x27;
                         &#x27;lp.tmpCellY - top, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, blockOccupied, &#x27;
                         &#x27;true); \n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;markCellsForRect(rectOccupiedByPotentialDrop, &#x27;
                         &#x27;mTmpOccupied, true);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;findNearestAreaInDirection(boundingRect.left, &#x27;
                         &#x27;boundingRect.top, boundingRect.width(),\n&#x27;
                         &#x27;                boundingRect.height(), direction, &#x27;
                         &#x27;mTmpOccupied, blockOccupied, mTempLocation);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = mTempLocation[0] - &#x27;
                         &#x27;boundingRect.left;\n&#x27;
                         &#x27;        int deltaY = mTempLocation[1] - &#x27;
                         &#x27;boundingRect.top;\n&#x27;
                         &#x27;        if (mTempLocation[0] &gt;= 0 &amp;&amp; &#x27;
                         &#x27;mTempLocation[1] &gt;= 0) {\n&#x27;
                         &#x27;            for (View v: dup) {\n&#x27;
                         &#x27;                LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;                lp.tmpCellX += deltaX;\n&#x27;
                         &#x27;                lp.tmpCellY += deltaY;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            success = true;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (View v: dup) {\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;v.getLayoutParams();\n&#x27;
                         &#x27;            markCellsForView(lp.tmpCellX, &#x27;
                         &#x27;lp.tmpCellY, lp.cellHSpan,\n&#x27;
                         &#x27;                    lp.cellVSpan, mTmpOccupied, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return success;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;private boolean addViewInDirection(ArrayList&lt;View&gt; &#x27;
                         &#x27;views, Rect boundingRect, int[] direction,\n&#x27;
                         &#x27;            boolean[][] occupied) {\n&#x27;
                         &#x27;        boolean found = false;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int childCount = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildCount();\n&#x27;
                         &#x27;        Rect r0 = new Rect(boundingRect);\n&#x27;
                         &#x27;        Rect r1 = new Rect();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        int deltaX = 0;\n&#x27;
                         &#x27;        int deltaY = 0;\n&#x27;
                         &#x27;        if (direction[1] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top - 1, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaY = -1;\n&#x27;
                         &#x27;        } else if (direction[1] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom + 1);\n&#x27;
                         &#x27;            deltaY = 1;\n&#x27;
                         &#x27;        } else if (direction[0] &lt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left - 1, r0.top, r0.right, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = -1;\n&#x27;
                         &#x27;        } else if (direction[0] &gt; 0) {\n&#x27;
                         &#x27;            r0.set(r0.left, r0.top, r0.right + 1, &#x27;
                         &#x27;r0.bottom);\n&#x27;
                         &#x27;            deltaX = 1;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        for (int i = 0; i &lt; childCount; i++) {\n&#x27;
                         &#x27;            View child = &#x27;
                         &#x27;mShortcutsAndWidgets.getChildAt(i);\n&#x27;
                         &#x27;            if (views.contains(child)) continue;\n&#x27;
                         &#x27;            LayoutParams lp = (LayoutParams) &#x27;
                         &#x27;child.getLayoutParams();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            r1.set(lp.tmpCellX, lp.tmpCellY, &#x27;
                         &#x27;lp.tmpCellX + lp.cellHSpan, lp.tmpCellY + &#x27;
                         &#x27;lp.cellVSpan);\n&#x27;
                         &#x27;            if (Rect.intersects(r0, r1)) {\n&#x27;
                         &#x27;                if (!lp.canReorder) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;@Override\n&#x27;
                           &#x27;    public boolean shouldDelayChildPressedState() &#x27;
                           &#x27;{\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        