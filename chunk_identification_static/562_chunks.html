<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>562 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.balancereader;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.dao.DataAccessResourceFailureException;\n&#x27;
                         &#x27;import org.springframework.stereotype.Component;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * Defines an interface for reacting to new &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * @param accountId    the account associated with &#x27;
                         &#x27;the transaction\n&#x27;
                         &#x27; * @param amount       the amount of change in &#x27;
                         &#x27;balance for the account\n&#x27;
                         &#x27; * @param transaction  the full transaction object\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;interface LedgerReaderCallback {\n&#x27;
                         &#x27;    void processTransaction(Transaction &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;}\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * LedgerReader listens for and reacts to incoming &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;@Component\n&#x27;
                         &#x27;public final class LedgerReader {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        LogManager.getLogger(LedgerReader.class);\n&#x27;
                         &#x27;    private static final long &#x27;
                         &#x27;STARTING_TRANSACTION_ID = -1;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Autowired\n&#x27;
                         &#x27;    private TransactionRepository dbRepo;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Value(&quot;${POLL_MS:100}&quot;)\n&#x27;
                         &#x27;    private Integer pollMs;\n&#x27;
                         &#x27;    @Value(&quot;${LOCAL_ROUTING_NUM}&quot;)\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Thread backgroundThread;\n&#x27;
                         &#x27;    private LedgerReaderCallback callback;\n&#x27;
                         &#x27;    private long latestId;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * LedgerReader setup\n&#x27;
                         &#x27;     * Synchronously loads all existing &#x27;
                         &#x27;transactions, and then starts\n&#x27;
                         &#x27;     * a background thread to listen for future &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param callback to process transactions\n&#x27;
                         &#x27;     * @throws IllegalStateException if callback is &#x27;
                         &#x27;null\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public void &#x27;
                         &#x27;startWithCallback(LedgerReaderCallback callback)\n&#x27;
                         &#x27;        throws IllegalStateException {\n&#x27;
                         &#x27;        if (callback == null) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalStateException(&quot;callback is null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.callback = callback;\n&#x27;
                         &#x27;        // get the latest transaction id in ledger\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            Long dbId = dbRepo.latestId();\n&#x27;
                         &#x27;            this.latestId = (dbId != null ? dbId : &#x27;
                         &#x27;this.latestId);\n&#x27;
                         &#x27;            LOGGER.debug(String.format(&quot;Transaction &#x27;
                         &#x27;starting id: %d&quot;,\n&#x27;
                         &#x27;                latestId));\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;            | DataAccessResourceFailureException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            LOGGER.warn(&quot;Could not contact ledger &#x27;
                         &#x27;database at init&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        this.backgroundThread = new Thread(new &#x27;
                         &#x27;Runnable() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                boolean alive = true;\n&#x27;
                         &#x27;                while (alive) {\n&#x27;
                         &#x27;                    // sleep between polls\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Thread.sleep(pollMs);\n&#x27;
                         &#x27;                    } catch (InterruptedException e) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;LedgerReader &#x27;
                         &#x27;sleep interrupted&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // check for new updates in &#x27;
                         &#x27;ledger\n&#x27;
                         &#x27;                    Long remoteLatest;\n&#x27;
                         &#x27;                    try {\n&#x27;
                         &#x27;                        Long dbId = &#x27;
                         &#x27;dbRepo.latestId();\n&#x27;
                         &#x27;                        remoteLatest = (dbId != null &#x27;
                         &#x27;? dbId : remoteLatest);\n&#x27;
                         &#x27;                    } catch &#x27;
                         &#x27;(ResourceAccessException\n&#x27;
                         &#x27;                        | &#x27;
                         &#x27;DataAccessResourceFailureException e) {\n&#x27;
                         &#x27;                        remoteLatest = latestId;\n&#x27;
                         &#x27;                        LOGGER.warn(&quot;Could not reach &#x27;
                         &#x27;ledger database&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                    // if there are new &#x27;
                         &#x27;transactions, poll the database\n&#x27;
                         &#x27;                    if (remoteLatest &gt; latestId) {\n&#x27;
                         &#x27;                        latestId = &#x27;
                         &#x27;pollTransactions(latestId);\n&#x27;
                         &#x27;                    } else if (remoteLatest &lt; &#x27;
                         &#x27;latestId) {\n&#x27;
                         &#x27;                        // remote database out of &#x27;
                         &#x27;sync\n&#x27;
                         &#x27;                        // suspend processing &#x27;
                         &#x27;transactions to reset service\n&#x27;
                         &#x27;                        alive = false;\n&#x27;
                         &#x27;                        LOGGER.error(&quot;Remote &#x27;
                         &#x27;transaction id out of sync&quot;);\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;        LOGGER.info(&quot;Starting background thread.&quot;);\n&#x27;
                         &#x27;        this.backgroundThread.start();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Poll for new transactions\n&#x27;
                         &#x27;     * Execute callback for each one\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param startingId the transaction to start &#x27;
                         &#x27;reading after.\n&#x27;
                         &#x27;     *                            -1 = start reading &#x27;
                         &#x27;at beginning of the ledger\n&#x27;
                         &#x27;     * @return long id of latest transaction &#x27;
                         &#x27;processed\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private long pollTransactions(long startingId) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        long latestId = startingId;\n&#x27;
                         &#x27;        Iterable&lt;Transaction&gt; transactionList = &#x27;
                         &#x27;dbRepo.findLatest(startingId);\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Polling Transactions&quot;);\n&#x27;
                         &#x27;        for (Transaction transaction : &#x27;
                         &#x27;transactionList) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;callback.processTransaction(transaction);\n&#x27;
                         &#x27;            latestId = &#x27;
                         &#x27;transaction.getTransactionId();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return latestId;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Indicates health of LedgerReader\n&#x27;
                         &#x27;     * @return false if background thread dies\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    public boolean isAlive() {\n&#x27;
                         &#x27;        return backgroundThread == null || &#x27;
                         &#x27;backgroundThread.isAlive();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        