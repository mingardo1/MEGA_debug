<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>341</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    341
                    <a href="340.html">prev</a>
                    <a href="342.html">next</a>
                    <a href="341_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_50c469a5b6542133ec852cd19a999679ea4093ed_core/src/main/java/com/dtstack/flink/sql/dirtyManager/manager/DirtyDataManager.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;50c469a5b6542133ec852cd19a999679ea4093ed:core/src/main/java/com/dtstack/flink/sql/dirtyManager/manager/DirtyDataManager.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;50c469a5b6542133ec852cd19a999679ea4093ed^1:core/src/main/java/com/dtstack/flink/sql/dirtyManager/manager/DirtyDataManager.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;50c469a5b6542133ec852cd19a999679ea4093ed^2:core/src/main/java/com/dtstack/flink/sql/dirtyManager/manager/DirtyDataManager.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;7ee482dc6e85e6f2df3f43d9a97b8b96edb606f7:core/src/main/java/com/dtstack/flink/sql/dirtyManager/manager/DirtyDataManager.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [sbj], [b], [b], [j], [j], [s]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.dirtyManager.manager;
  20 
  21 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22 import com.dtstack.flink.sql.dirtyManager.consumer.AbstractDirtyDataConsumer;
  23 import com.dtstack.flink.sql.dirtyManager.entity.DirtyDataEntity;
  24 import com.dtstack.flink.sql.factory.DTThreadFactory;
  25 import com.dtstack.flink.sql.util.PluginUtil;
  26 import org.slf4j.Logger;
  27 import org.slf4j.LoggerFactory;
  28 
  29 import java.io.File;
  30 import java.io.Serializable;
  31 import java.lang.reflect.Constructor;
  32 import java.util.Map;
  33 import java.util.concurrent.ExecutorService;
  34 import java.util.concurrent.Executors;
  35 import java.util.concurrent.Future;
  36 import java.util.concurrent.LinkedBlockingQueue;
  37 import java.util.concurrent.ThreadPoolExecutor;
  38 import java.util.concurrent.TimeUnit;
  39 import java.util.concurrent.atomic.AtomicLong;
  40 
  41 /**
  42  * @author tiezhu
  43  * Company dtstack
  44  * Date 2020/8/27 星期四
  45  */
  46 public class DirtyDataManager implements Serializable {
  47 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  48 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 </span>
  50 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  51 </span>
  52 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  53     private static final long serialVersionUID = 7190970299538893497L;
  54 
  55     private static final Logger LOG = LoggerFactory.getLogger(DirtyDataManager.class);
  56 
  57     private static final String CLASS_PRE_STR = &quot;com.dtstack.flink.sql.dirty&quot;;
  58 
  59     private static final String CLASS_POST_STR = &quot;DirtyDataConsumer&quot;;
  60 
  61     private static final String DIRTY_CONSUMER_PATH = &quot;dirtyData&quot;;
  62 
  63     /**
  64      * 写入队列阻塞时间
  65      */
  66     private long blockingInterval;
  67 
  68     /**
  69      * 缓存脏数据信息队列
  70      */
  71     public final LinkedBlockingQueue&lt;DirtyDataEntity&gt; queue = new LinkedBlockingQueue&lt;&gt;();
  72 
  73     /**
  74      * 统计manager收集到的脏数据条数
  75      */
  76     private final AtomicLong count = new AtomicLong(0);
  77 
  78     /**
  79      * 脏数据写入队列失败条数
  80      */
  81     private final AtomicLong errorCount = new AtomicLong(0);
  82 
  83 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  84     public AbstractDirtyDataConsumer consumer;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  85 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  86     private final ExecutorService executor = Executors.newSingleThreadExecutor();</span>
  87 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89      * 通过参数生成manager实例，并同时将consumer实例化</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90      */</span>
  91 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  92     private double errorLimitRate;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  93 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  94     public static AbstractDirtyDataConsumer consumer;</span>
  95 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  96 
  97     private static ThreadPoolExecutor dirtyDataConsumer;
  98 
  99     public final static int MAX_POOL_SIZE_LIMIT = 5;
 100 
 101     private final static int MAX_TASK_QUEUE_SIZE = 100;
 102 
 103     private final static String DEFAULT_TYPE = &quot;console&quot;;
 104 
 105     private final static String DEFAULT_ERROR_LIMIT_RATE = &quot;0.8&quot;;
 106 
 107     private final static String DEFAULT_BLOCKING_INTERVAL = &quot;60&quot;;
 108 
 109     /**
 110      * 通过参数生成manager实例，并同时将consumer实例化
 111      */
 112     public static DirtyDataManager newInstance(Map&lt;String, String&gt; properties) throws Exception {
 113         DirtyDataManager manager = new DirtyDataManager();
 114 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 115         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 116         manager.consumer = createConsumer(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117         manager.consumer.init(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118         manager.executor.execute(manager.consumer);</span>
 119 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120         Thread dirtyDataConsumer = new Thread(consumer.setQueue(manager.queue), &quot;dirtyData Consumer&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121         dirtyDataConsumer.start();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122         return manager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126      * 通过动态加载的方式加载Consumer</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 127      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 128     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {"> 128     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Except🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 129         String type = properties.getOrDefault(&quot;type&quot;, &quot;print&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 130         String consumerType = DIRTY_CONSUMER_PATH + File.separator + type;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 131         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 131         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 132         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_STR);"> 132         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLA🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 133 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 134         return ClassLoaderManager.newInstance(consumerJar, cl -&gt; {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135             Class&lt;?&gt; clazz = cl.loadClass(className);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136             Constructor&lt;?&gt; constructor = clazz.getConstructor();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137             return (AbstractDirtyDataConsumer) constructor.newInstance();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140 </span>
 141 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 142         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLOCKING_INTERVAL));"> 142         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLO🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 143         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERROR_LIMIT_RATE));"> 143         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERR🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 144         consumer = createConsumer(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 145         consumer.init(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 146         consumer.setQueue(manager.queue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 147         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,"> 147         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 148                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;), new ThreadPoolExecutor.CallerRunsPolicy());"> 148                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;),🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149         dirtyDataConsumer.execute(consumer);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 150 </span>
 151 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 152         return manager;
 153     }
 154 
 155     /**
 156      * 通过动态加载的方式加载Consumer
 157      */
<abbr title=" 158     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {"> 158     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Except🔵</abbr>
 159         String type = properties.getOrDefault(&quot;type&quot;, DEFAULT_TYPE);
 160         String consumerType = DIRTY_CONSUMER_PATH + File.separator + type;
<abbr title=" 161         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 161         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPa🔵</abbr>
<abbr title=" 162         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_STR);"> 162         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLA🔵</abbr>
 163 
 164         return ClassLoaderManager.newInstance(consumerJar, cl -&gt; {
 165             Class&lt;?&gt; clazz = cl.loadClass(className);
 166             Constructor&lt;?&gt; constructor = clazz.getConstructor();
 167             return (AbstractDirtyDataConsumer) constructor.newInstance();
 168         });
 169     }
 170 
 171     /**
 172      * 脏数据收集任务停止，任务停止之前，需要将队列中所有的数据清空
 173      * TODO consumer 关闭时仍有数据没有消费到，假如有500条数据，在结束时实际消费数量可能只有493
 174      */
 175     public void close() {
 176 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 177         if (!queue.isEmpty() &amp;&amp; checkConsumer()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 178             executor.shutdown();</span>
 179 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 180         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 181         LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 182         consumer.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 183     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 184 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 185     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 186      * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比列，那么manager任务失败</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 187      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 188     public void collectDirtyData(String dataInfo, String cause, String field) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 189         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);"> 189         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 190         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 191             queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192             count.incrementAndGet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 193         } catch (Exception ignored) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 194             LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 195             LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 196             if (errorCount.get() &gt; Math.ceil(count.longValue() * 0.8)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 197                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);"> 197                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 198             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 199         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 200     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 201 </span>
 202 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 203         if (checkConsumer()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 204             LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 205             consumer.close();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 206             dirtyDataConsumer.shutdownNow();</span>
 207 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 208         }
 209 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 210         LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 211         this.consumer.isRunning.compareAndSet(true, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 212         executor.shutdownNow();</span>
 213 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217      * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比列，那么manager任务失败</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219     public void collectDirtyData(String dataInfo, String cause, String field) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 220         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);"> 220         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222             queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223             count.incrementAndGet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224         } catch (Exception ignored) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225             LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226             LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227             if (errorCount.get() &gt; Math.ceil(count.longValue() * 0.8)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 228                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);"> 228                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 229             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 230         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233     /**</span>
 234 =======
 235 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 236     }
 237 
 238     /**
 239      * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比例，那么manager任务失败
 240      */
 241     public void collectDirtyData(String dataInfo, String cause, String field) {
<abbr title=" 242         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);"> 242         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause🔵</abbr>
 243         try {
 244             queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);
 245             count.incrementAndGet();
 246         } catch (Exception ignored) {
 247             LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());
 248             LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());
 249             if (errorCount.get() &gt; Math.ceil(count.longValue() * errorLimitRate)) {
<abbr title=" 250                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);"> 250                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;🔵</abbr>
 251             }
 252         }
 253     }
 254 
 255     /**
 256      * 查看consumer当前状态
 257      */
 258     public boolean checkConsumer() {
 259         return this.consumer.isRunning();
 260     }
 261 
 262     /**
 263      * 首字母大写
 264      */
 265     private static String upperCaseFirstChar(String str) {
 266         return str.substring(0, 1).toUpperCase() + str.substring(1);
 267     }
 268 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.dirtyManager.manager;
  20 
  21 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22 import com.dtstack.flink.sql.dirtyManager.consumer.AbstractDirtyDataConsumer;
  23 import com.dtstack.flink.sql.dirtyManager.entity.DirtyDataEntity;
  24 import com.dtstack.flink.sql.factory.DTThreadFactory;
  25 import com.dtstack.flink.sql.util.PluginUtil;
  26 import org.slf4j.Logger;
  27 import org.slf4j.LoggerFactory;
  28 
  29 import java.io.File;
  30 import java.io.Serializable;
  31 import java.lang.reflect.Constructor;
  32 import java.util.Map;
  33 import java.util.concurrent.ExecutorService;
  34 import java.util.concurrent.Executors;
  35 import java.util.concurrent.Future;
  36 import java.util.concurrent.LinkedBlockingQueue;
  37 import java.util.concurrent.ThreadPoolExecutor;
  38 import java.util.concurrent.TimeUnit;
  39 import java.util.concurrent.atomic.AtomicLong;
  40 
  41 /**
  42  * @author tiezhu
  43  * Company dtstack
  44  * Date 2020/8/27 星期四
  45  */
  46 public class DirtyDataManager implements Serializable {
  47     private static final long serialVersionUID = 7190970299538893497L;
  48 
  49     private static final Logger LOG = LoggerFactory.getLogger(DirtyDataManager.class);
  50 
  51     private static final String CLASS_PRE_STR = &quot;com.dtstack.flink.sql.dirty&quot;;
  52 
  53     private static final String CLASS_POST_STR = &quot;DirtyDataConsumer&quot;;
  54 
  55     private static final String DIRTY_CONSUMER_PATH = &quot;dirtyData&quot;;
  56 
  57     /**
  58      * 写入队列阻塞时间
  59      */
  60     private long blockingInterval;
  61 
  62     /**
  63      * 缓存脏数据信息队列
  64      */
  65     public final LinkedBlockingQueue&lt;DirtyDataEntity&gt; queue = new LinkedBlockingQueue&lt;&gt;();
  66 
  67     /**
  68      * 统计manager收集到的脏数据条数
  69      */
  70     private final AtomicLong count = new AtomicLong(0);
  71 
  72     /**
  73      * 脏数据写入队列失败条数
  74      */
  75     private final AtomicLong errorCount = new AtomicLong(0);
  76 
  77     private double errorLimitRate;
  78 
  79     public AbstractDirtyDataConsumer consumer;
  80 
  81     private final ExecutorService executor = Executors.newSingleThreadExecutor();
  82 
  83     private static ThreadPoolExecutor dirtyDataConsumer;
  84 
  85     public final static int MAX_POOL_SIZE_LIMIT = 5;
  86 
  87     private final static int MAX_TASK_QUEUE_SIZE = 100;
  88 
  89     private final static String DEFAULT_TYPE = &quot;console&quot;;
  90 
  91     private final static String DEFAULT_ERROR_LIMIT_RATE = &quot;0.8&quot;;
  92 
  93     private final static String DEFAULT_BLOCKING_INTERVAL = &quot;60&quot;;
  94 
  95     /**
  96      * 通过参数生成manager实例，并同时将consumer实例化
  97      */
  98     public static DirtyDataManager newInstance(Map&lt;String, String&gt; properties) throws Exception {
  99         DirtyDataManager manager = new DirtyDataManager();
 100 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 101         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 102         manager.consumer = createConsumer(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 103         manager.consumer.init(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 104         manager.executor.execute(manager.consumer);</span>
 105 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 106         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 107         consumer = createConsumer(properties);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 108         consumer.init(properties);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 109         //TODO 使用线程池创建线程，不要用thread</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 110         Thread dirtyDataConsumer = new Thread(consumer.setQueue(manager.queue), &quot;dirtyData Consumer&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 111         dirtyDataConsumer.start();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 112         return manager;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 113     }</span>
 114 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 115         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLOCKING_INTERVAL));"> 115         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLO🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 116         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERROR_LIMIT_RATE));"> 116         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERR🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 117         consumer = createConsumer(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 118         consumer.init(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 119         consumer.setQueue(manager.queue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 120         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,"> 120         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 121                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;), new ThreadPoolExecutor.CallerRunsPolicy());"> 121                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;),🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 122         dirtyDataConsumer.execute(consumer);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 123 </span>
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 125         return manager;
 126     }
 127 
 128     /**
 129      * 通过动态加载的方式加载Consumer
 130      */
<abbr title=" 131     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {"> 131     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Except🔵</abbr>
 132         String type = properties.getOrDefault(&quot;type&quot;, DEFAULT_TYPE);
 133         String consumerType = DIRTY_CONSUMER_PATH + File.separator + type;
<abbr title=" 134         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 134         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPa🔵</abbr>
<abbr title=" 135         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_STR);"> 135         String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLA🔵</abbr>
 136 
 137         return ClassLoaderManager.newInstance(consumerJar, cl -&gt; {
 138             Class&lt;?&gt; clazz = cl.loadClass(className);
 139             Constructor&lt;?&gt; constructor = clazz.getConstructor();
 140             return (AbstractDirtyDataConsumer) constructor.newInstance();
 141         });
 142     }
 143 
 144     /**
 145      * 脏数据收集任务停止，任务停止之前，需要将队列中所有的数据清空
 146      * TODO consumer 关闭时仍有数据没有消费到，假如有500条数据，在结束时实际消费数量可能只有493
 147      */
 148     public void close() {
 149 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150         if (!queue.isEmpty() &amp;&amp; checkConsumer()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151             executor.shutdown();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152         }</span>
 153 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154         if (!queue.isEmpty() &amp;&amp; checkConsumer()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 155             consumer.consume();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156         }</span>
 157 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158         if (checkConsumer()) {</span>
 159 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 160         LOG.info(&quot;dirty consumer is closing ...&quot;);
 161 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162         this.consumer.isRunning.compareAndSet(true, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 163         executor.shutdownNow();</span>
 164 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 165         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 166         LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167         consumer.close();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168     }</span>
 169 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 170             consumer.close();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 171             dirtyDataConsumer.shutdownNow();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 172         }</span>
 173 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 174     }
 175 
 176     /**
 177      * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比例，那么manager任务失败
 178      */
 179     public void collectDirtyData(String dataInfo, String cause, String field) {
<abbr title=" 180         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);"> 180         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause🔵</abbr>
 181         try {
 182             queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);
 183             count.incrementAndGet();
 184         } catch (Exception ignored) {
 185             LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());
 186             LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());
 187             if (errorCount.get() &gt; Math.ceil(count.longValue() * errorLimitRate)) {
<abbr title=" 188                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);"> 188                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;🔵</abbr>
 189             }
 190         }
 191     }
 192 
 193     /**
 194      * 查看consumer当前状态
 195      */
 196     public boolean checkConsumer() {
 197         return this.consumer.isRunning();
 198     }
 199 
 200     /**
 201      * 首字母大写
 202      */
 203     private static String upperCaseFirstChar(String str) {
 204         return str.substring(0, 1).toUpperCase() + str.substring(1);
 205     }
 206 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.dirtyManager.manager;
  19 
  20 import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  21 import com.dtstack.flink.sql.dirtyManager.consumer.AbstractDirtyDataConsumer;
  22 import com.dtstack.flink.sql.dirtyManager.entity.DirtyDataEntity;
  23 import com.dtstack.flink.sql.factory.DTThreadFactory;
  24 import com.dtstack.flink.sql.util.PluginUtil;
  25 import java.io.File;
  26 import java.io.Serializable;
  27 import java.lang.reflect.Constructor;
  28 import java.util.Map;
  29 import java.util.concurrent.ExecutorService;
  30 import java.util.concurrent.Executors;
  31 import java.util.concurrent.Future;
  32 import java.util.concurrent.LinkedBlockingQueue;
  33 import java.util.concurrent.ThreadPoolExecutor;
  34 import java.util.concurrent.TimeUnit;
  35 import java.util.concurrent.atomic.AtomicLong;
  36 import org.slf4j.Logger;
  37 import org.slf4j.LoggerFactory;
  38 
  39 
  40 /**
  41  * @author tiezhu
  42  * Company dtstack
  43  * Date 2020/8/27 星期四
  44  */
  45 public class DirtyDataManager implements Serializable {
  46     private static final long serialVersionUID = 7190970299538893497L;
  47 
  48     private static final Logger LOG = LoggerFactory.getLogger(DirtyDataManager.class);
  49 
  50     private static final String CLASS_PRE_STR = &quot;com.dtstack.flink.sql.dirty&quot;;
  51 
  52     private static final String CLASS_POST_STR = &quot;DirtyDataConsumer&quot;;
  53 
  54     private static final String DIRTY_CONSUMER_PATH = &quot;dirtyData&quot;;
  55 
  56     /**
  57      * 写入队列阻塞时间
  58      */
  59     private long blockingInterval;
  60 
  61     /**
  62      * 缓存脏数据信息队列
  63      */
  64     public final LinkedBlockingQueue&lt;DirtyDataEntity&gt; queue = new LinkedBlockingQueue&lt;&gt;();
  65 
  66     /**
  67      * 统计manager收集到的脏数据条数
  68      */
  69     private final AtomicLong count = new AtomicLong(0);
  70 
  71     /**
  72      * 脏数据写入队列失败条数
  73      */
  74     private final AtomicLong errorCount = new AtomicLong(0);
  75 
  76     private double errorLimitRate;
  77 
  78     public AbstractDirtyDataConsumer consumer;
  79 
  80     private final ExecutorService executor = Executors.newSingleThreadExecutor();
  81 
  82     private static ThreadPoolExecutor dirtyDataConsumer;
  83 
  84     public final static int MAX_POOL_SIZE_LIMIT = 5;
  85 
  86     private final static int MAX_TASK_QUEUE_SIZE = 100;
  87 
  88     private final static String DEFAULT_TYPE = &quot;console&quot;;
  89 
  90     private final static String DEFAULT_ERROR_LIMIT_RATE = &quot;0.8&quot;;
  91 
  92     private final static String DEFAULT_BLOCKING_INTERVAL = &quot;60&quot;;
  93 
  94     /**
  95      * 通过参数生成manager实例，并同时将consumer实例化
  96      */
  97     public static DirtyDataManager newInstance(Map&lt;String, String&gt; properties) throws Exception {
  98         DirtyDataManager manager = new DirtyDataManager();
  99 
 100 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 101         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 102         manager.consumer = createConsumer(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 103         manager.consumer.init(properties);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 104         manager.executor.execute(manager.consumer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 105 </span>
 106 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 107 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 107 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 108 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 109 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 110         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLOCKING_INTERVAL));"> 110         manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLO🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 111         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERROR_LIMIT_RATE));"> 111         manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERR🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 112         consumer = createConsumer(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 113         consumer.init(properties);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 114         consumer.setQueue(manager.queue);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 115         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,"> 115         dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 116                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;), new ThreadPoolExecutor.CallerRunsPolicy());"> 116                 new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;),🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 117         dirtyDataConsumer.execute(consumer);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 118 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 119 </span>
 120 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 121         return manager;
 122     }
 123 
 124     /**
 125      * 通过动态加载的方式加载Consumer
 126      */
<abbr title=" 127     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {"> 127     private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Except🔵</abbr>
 128         String type = properties.getOrDefault(&quot;type&quot;, DEFAULT_TYPE);
 129         String consumerType = (DIRTY_CONSUMER_PATH + File.separator) + type;
<abbr title=" 130         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 130         String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPa🔵</abbr>
<abbr title=" 131         String className = (((CLASS_PRE_STR + &quot;.&quot;) + type.toLowerCase()) + &quot;.&quot;) + upperCaseFirstChar(type + CLASS_POST_STR);"> 131         String className = (((CLASS_PRE_STR + &quot;.&quot;) + type.toLowerCase()) + &quot;.&quot;) + upperCaseFirstChar(type🔵</abbr>
 132         return ClassLoaderManager.newInstance(consumerJar, ( cl) -&gt; {
 133             Class&lt;?&gt; clazz = cl.loadClass(className);
 134             Constructor&lt;?&gt; constructor = clazz.getConstructor();
 135             return ((AbstractDirtyDataConsumer) (constructor.newInstance()));
 136         });
 137     }
 138 
 139     /**
 140      * 脏数据收集任务停止，任务停止之前，需要将队列中所有的数据清空
 141      * TODO consumer 关闭时仍有数据没有消费到，假如有500条数据，在结束时实际消费数量可能只有493
 142      */
 143     public void close()
 144 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 145 {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146         if (!queue.isEmpty() &amp;&amp; checkConsumer()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147             executor.shutdown();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 149         LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 150         this.consumer.isRunning.compareAndSet(true, false);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 151         executor.shutdownNow();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 152     }</span>
 153 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 154 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 154 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 155 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 157 {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158         if (checkConsumer()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 159             LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 160             consumer.close();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 161             dirtyDataConsumer.shutdownNow();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163     }</span>
 164 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 165 
 166 
 167     /**
 168      * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比例，那么manager任务失败
 169      */
 170     public void collectDirtyData(String dataInfo, String cause, String field) {
<abbr title=" 171         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);"> 171         DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause🔵</abbr>
 172         try {
 173             queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);
 174             count.incrementAndGet();
 175         } catch (java.lang.Exception ignored) {
 176             LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());
 177             LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());
 178             if (errorCount.get() &gt; Math.ceil(count.longValue() * errorLimitRate)) {
<abbr title=" 179                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);"> 179                 throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;🔵</abbr>
 180             }
 181         }
 182     }
 183 
 184     /**
 185      * 查看consumer当前状态
 186      */
 187     public boolean checkConsumer() {
 188         return this.consumer.isRunning();
 189     }
 190 
 191     /**
 192      * 首字母大写
 193      */
 194     private static String upperCaseFirstChar(String str) {
 195         return str.substring(0, 1).toUpperCase() + str.substring(1);
 196     }
 197 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   * http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.dirtyManager.manager;
  20  
  21  import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22  import com.dtstack.flink.sql.dirtyManager.consumer.AbstractDirtyDataConsumer;
  23  import com.dtstack.flink.sql.dirtyManager.entity.DirtyDataEntity;

  24  import com.dtstack.flink.sql.util.PluginUtil;
  25  import org.slf4j.Logger;
  26  import org.slf4j.LoggerFactory;
  27  
  28  import java.io.File;
  29  import java.io.Serializable;
  30  import java.lang.reflect.Constructor;
  31  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import java.util.concurrent.ExecutorService;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import java.util.concurrent.Executors;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import java.util.concurrent.Future;</span>
  35  import java.util.concurrent.LinkedBlockingQueue;

  36  import java.util.concurrent.TimeUnit;
  37  import java.util.concurrent.atomic.AtomicLong;
  38  
  39  /**
  40   * @author tiezhu
  41   * Company dtstack
  42   * Date 2020/8/27 星期四
  43   */
  44  public class DirtyDataManager implements Serializable {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -    //TODO 需要确保产生脏数据后至少一次是成功发送给了consumer，至于consumer是否成功消费，manager不需要关心</span>

  46      private static final long serialVersionUID = 7190970299538893497L;
  47  
  48      private static final Logger LOG = LoggerFactory.getLogger(DirtyDataManager.class);
  49  
  50      private static final String CLASS_PRE_STR = &quot;com.dtstack.flink.sql.dirty&quot;;
  51  
  52      private static final String CLASS_POST_STR = &quot;DirtyDataConsumer&quot;;
  53  
  54      private static final String DIRTY_CONSUMER_PATH = &quot;dirtyData&quot;;
  55  
  56      /**
  57       * 写入队列阻塞时间
  58       */
  59      private long blockingInterval = 60;

  60  
  61      /**
  62       * 缓存脏数据信息队列
  63       */
  64      public final LinkedBlockingQueue&lt;DirtyDataEntity&gt; queue = new LinkedBlockingQueue&lt;&gt;();
  65  
  66      /**
  67       * 统计manager收集到的脏数据条数
  68       */
  69      private final AtomicLong count = new AtomicLong(0);
  70  
  71      /**
  72       * 脏数据写入队列失败条数
  73       */
  74      private final AtomicLong errorCount = new AtomicLong(0);
  75  


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -    public static AbstractDirtyDataConsumer consumer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +    public AbstractDirtyDataConsumer consumer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +    private final ExecutorService executor = Executors.newSingleThreadExecutor();</span>









  80  
  81      /**
  82       * 通过参数生成manager实例，并同时将consumer实例化
  83       */
  84      public static DirtyDataManager newInstance(Map&lt;String, String&gt; properties) throws Exception {
  85          DirtyDataManager manager = new DirtyDataManager();
  86          manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -        consumer = createConsumer(properties);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -        consumer.init(properties);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -        //TODO 使用线程池创建线程，不要用thread</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -        Thread dirtyDataConsumer = new Thread(consumer.setQueue(manager.queue), &quot;dirtyData Consumer&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -        dirtyDataConsumer.start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +        manager.consumer = createConsumer(properties);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +        manager.consumer.init(properties);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +        manager.executor.execute(manager.consumer);</span>


  95          return manager;
  96      }
  97  
  98      /**
  99       * 通过动态加载的方式加载Consumer
 100       */
 101      private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {
 102          String type = properties.getOrDefault(&quot;type&quot;, &quot;print&quot;);

 103          String consumerType = DIRTY_CONSUMER_PATH + File.separator + type;
<abbr title=" 104          String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 104          String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null🔵</abbr>
<abbr title=" 105          String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_STR);"> 105          String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_S🔵</abbr>
 106  
 107          return ClassLoaderManager.newInstance(consumerJar, cl -&gt; {
 108              Class&lt;?&gt; clazz = cl.loadClass(className);
 109              Constructor&lt;?&gt; constructor = clazz.getConstructor();
 110              return (AbstractDirtyDataConsumer) constructor.newInstance();
 111          });
 112      }
 113  
 114      /**
 115       * 脏数据收集任务停止，任务停止之前，需要将队列中所有的数据清空

 116       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    public void close() throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    public void close() {</span>
 119          if (!queue.isEmpty() &amp;&amp; checkConsumer()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -            consumer.consume();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +            executor.shutdown();</span>




 122          }
 123          LOG.info(&quot;dirty consumer is closing ...&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -        consumer.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +        this.consumer.isRunning.compareAndSet(true, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +        executor.shutdownNow();</span>
 127      }
 128  
 129      /**
 130       * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比列，那么manager任务失败

 131       */
 132      public void collectDirtyData(String dataInfo, String cause, String field) {
 133          DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);
 134          try {
 135              queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);
 136              count.incrementAndGet();
 137          } catch (Exception ignored) {
 138              LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());
 139              LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());
 140              if (errorCount.get() &gt; Math.ceil(count.longValue() * 0.8)) {

 141                  throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);
 142              }
 143          }
 144      }
 145  
 146      /**
 147       * 查看consumer当前状态
 148       */
 149      public boolean checkConsumer() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -        return consumer.isRunning();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        return this.consumer.isRunning();</span>
 152      }
 153  
 154      /**
 155       * 首字母大写
 156       */
 157      private static String upperCaseFirstChar(String str) {
 158          return str.substring(0, 1).toUpperCase() + str.substring(1);
 159      }
 160  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   * http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.dirtyManager.manager;
  20  
  21  import com.dtstack.flink.sql.classloader.ClassLoaderManager;
  22  import com.dtstack.flink.sql.dirtyManager.consumer.AbstractDirtyDataConsumer;
  23  import com.dtstack.flink.sql.dirtyManager.entity.DirtyDataEntity;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.dtstack.flink.sql.factory.DTThreadFactory;</span>
  25  import com.dtstack.flink.sql.util.PluginUtil;
  26  import org.slf4j.Logger;
  27  import org.slf4j.LoggerFactory;
  28  
  29  import java.io.File;
  30  import java.io.Serializable;
  31  import java.lang.reflect.Constructor;
  32  import java.util.Map;



  33  import java.util.concurrent.LinkedBlockingQueue;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import java.util.concurrent.ThreadPoolExecutor;</span>
  35  import java.util.concurrent.TimeUnit;
  36  import java.util.concurrent.atomic.AtomicLong;
  37  
  38  /**
  39   * @author tiezhu
  40   * Company dtstack
  41   * Date 2020/8/27 星期四
  42   */
  43  public class DirtyDataManager implements Serializable {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  44 -    //TODO 需要确保产生脏数据后至少一次是成功发送给了consumer，至于consumer是否成功消费，manager不需要关心</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +</span>
  46      private static final long serialVersionUID = 7190970299538893497L;
  47  
  48      private static final Logger LOG = LoggerFactory.getLogger(DirtyDataManager.class);
  49  
  50      private static final String CLASS_PRE_STR = &quot;com.dtstack.flink.sql.dirty&quot;;
  51  
  52      private static final String CLASS_POST_STR = &quot;DirtyDataConsumer&quot;;
  53  
  54      private static final String DIRTY_CONSUMER_PATH = &quot;dirtyData&quot;;
  55  
  56      /**
  57       * 写入队列阻塞时间
  58       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -    private long blockingInterval = 60;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +    private long blockingInterval;</span>
  61  
  62      /**
  63       * 缓存脏数据信息队列
  64       */
  65      public final LinkedBlockingQueue&lt;DirtyDataEntity&gt; queue = new LinkedBlockingQueue&lt;&gt;();
  66  
  67      /**
  68       * 统计manager收集到的脏数据条数
  69       */
  70      private final AtomicLong count = new AtomicLong(0);
  71  
  72      /**
  73       * 脏数据写入队列失败条数
  74       */
  75      private final AtomicLong errorCount = new AtomicLong(0);
  76  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +    private double errorLimitRate;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +</span>
  79      public static AbstractDirtyDataConsumer consumer;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +    private static ThreadPoolExecutor dirtyDataConsumer;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +    public final static int MAX_POOL_SIZE_LIMIT = 5;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +    private final static int MAX_TASK_QUEUE_SIZE = 100;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +    private final static String DEFAULT_TYPE = &quot;console&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +    private final static String DEFAULT_ERROR_LIMIT_RATE = &quot;0.8&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +    private final static String DEFAULT_BLOCKING_INTERVAL = &quot;60&quot;;</span>
  92  
  93      /**
  94       * 通过参数生成manager实例，并同时将consumer实例化
  95       */
  96      public static DirtyDataManager newInstance(Map&lt;String, String&gt; properties) throws Exception {
  97          DirtyDataManager manager = new DirtyDataManager();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -        manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, &quot;60&quot;));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  99 +        manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLOCKING_INTERVAL));">  99 +        manager.blockingInterval = Long.parseLong(properties.getOrDefault(&quot;blockingInterval&quot;, DEFAULT_BLOCKING_INT🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 100 +        manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERROR_LIMIT_RATE));"> 100 +        manager.errorLimitRate = Double.parseDouble(properties.getOrDefault(&quot;errorLimitRate&quot;, DEFAULT_ERROR_LIMIT_🔵</abbr></span>
 101          consumer = createConsumer(properties);
 102          consumer.init(properties);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -        //TODO 使用线程池创建线程，不要用thread</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -        Thread dirtyDataConsumer = new Thread(consumer.setQueue(manager.queue), &quot;dirtyData Consumer&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -        dirtyDataConsumer.start();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +        consumer.setQueue(manager.queue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 107 +        dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECONDS,"> 107 +        dirtyDataConsumer = new ThreadPoolExecutor(MAX_POOL_SIZE_LIMIT, MAX_POOL_SIZE_LIMIT, 0, TimeUnit.MILLISECO🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 108 +                new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;), new ThreadPoolExecutor.CallerRunsPolicy());"> 108 +                new LinkedBlockingQueue&lt;&gt;(MAX_TASK_QUEUE_SIZE), new DTThreadFactory(&quot;dirtyDataConsumer&quot;), new Thre🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +        dirtyDataConsumer.execute(consumer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
 111          return manager;
 112      }
 113  
 114      /**
 115       * 通过动态加载的方式加载Consumer
 116       */
 117      private static AbstractDirtyDataConsumer createConsumer(Map&lt;String, String&gt; properties) throws Exception {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -        String type = properties.getOrDefault(&quot;type&quot;, &quot;print&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +        String type = properties.getOrDefault(&quot;type&quot;, DEFAULT_TYPE);</span>
 120          String consumerType = DIRTY_CONSUMER_PATH + File.separator + type;
<abbr title=" 121          String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null), &quot;shipfile&quot;);"> 121          String consumerJar = PluginUtil.getJarFileDirPath(consumerType, properties.getOrDefault(&quot;pluginPath&quot;, null🔵</abbr>
<abbr title=" 122          String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_STR);"> 122          String className = CLASS_PRE_STR + &quot;.&quot; + type.toLowerCase() + &quot;.&quot; + upperCaseFirstChar(type + CLASS_POST_S🔵</abbr>
 123  
 124          return ClassLoaderManager.newInstance(consumerJar, cl -&gt; {
 125              Class&lt;?&gt; clazz = cl.loadClass(className);
 126              Constructor&lt;?&gt; constructor = clazz.getConstructor();
 127              return (AbstractDirtyDataConsumer) constructor.newInstance();
 128          });
 129      }
 130  
 131      /**
 132       * 脏数据收集任务停止，任务停止之前，需要将队列中所有的数据清空
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +     * TODO consumer 关闭时仍有数据没有消费到，假如有500条数据，在结束时实际消费数量可能只有493</span>
 134       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -    public void close() throws Exception {</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -        if (!queue.isEmpty() &amp;&amp; checkConsumer()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -            consumer.consume();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +    public void close() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +        if (checkConsumer()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +            LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +            consumer.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +            dirtyDataConsumer.shutdownNow();</span>
 143          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -        LOG.info(&quot;dirty consumer is closing ...&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -        consumer.close();</span>


 146      }
 147  
 148      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -     * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比列，那么manager任务失败</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +     * 收集脏数据放入队列缓存中，记录放入失败的数目和存入队列中的总数目，如果放入失败的数目超过一定比例，那么manager任务失败</span>
 151       */
 152      public void collectDirtyData(String dataInfo, String cause, String field) {
 153          DirtyDataEntity dirtyDataEntity = new DirtyDataEntity(dataInfo, System.currentTimeMillis(), cause, field);
 154          try {
 155              queue.offer(dirtyDataEntity, blockingInterval, TimeUnit.MILLISECONDS);
 156              count.incrementAndGet();
 157          } catch (Exception ignored) {
 158              LOG.warn(&quot;dirty Data insert error ... Failed number: &quot; + errorCount.incrementAndGet());
 159              LOG.warn(&quot;error dirty data:&quot; + dirtyDataEntity.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -            if (errorCount.get() &gt; Math.ceil(count.longValue() * 0.8)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +            if (errorCount.get() &gt; Math.ceil(count.longValue() * errorLimitRate)) {</span>
 162                  throw new RuntimeException(&quot;The number of failed number reaches the limit, manager fails&quot;);
 163              }
 164          }
 165      }
 166  
 167      /**
 168       * 查看consumer当前状态
 169       */
 170      public boolean checkConsumer() {
 171          return consumer.isRunning();

 172      }
 173  
 174      /**
 175       * 首字母大写
 176       */
 177      private static String upperCaseFirstChar(String str) {
 178          return str.substring(0, 1).toUpperCase() + str.substring(1);
 179      }
 180  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            