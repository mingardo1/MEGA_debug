<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>429</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    429
                    <a href="428.html">prev</a>
                    <a href="430.html">next</a>
                    <a href="429_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_fb6068711e9082e8c3732bafbba78c750536283d_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb6068711e9082e8c3732bafbba78c750536283d:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb6068711e9082e8c3732bafbba78c750536283d^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;fb6068711e9082e8c3732bafbba78c750536283d^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;daac9736e82aa1c14e11841d602338de20669727:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [bj], [s], [s]], subset: [[bj], [sbj], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 import com.android.launcher3.compat.UserManagerCompat;
  32 import com.android.launcher3.compat.UserHandleCompat;
  33 
  34 import android.app.backup.BackupDataInputStream;
  35 import android.app.backup.BackupDataOutput;
  36 import android.app.backup.BackupHelper;
  37 import android.app.backup.BackupManager;
  38 import android.appwidget.AppWidgetManager;
  39 import android.appwidget.AppWidgetProviderInfo;
  40 import android.content.ComponentName;
  41 import android.content.ContentResolver;
  42 import android.content.ContentValues;
  43 import android.content.Context;
  44 import android.content.Intent;
  45 import android.database.Cursor;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.graphics.drawable.Drawable;
  49 import android.os.ParcelFileDescriptor;
  50 import android.text.TextUtils;
  51 import android.util.Base64;
  52 import android.util.Log;
  53 
  54 import java.io.ByteArrayOutputStream;
  55 import java.io.FileInputStream;
  56 import java.io.FileOutputStream;
  57 import java.io.IOException;
  58 import java.net.URISyntaxException;
  59 import java.util.ArrayList;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.zip.CRC32;
  65 
  66 /**
  67  * Persist the launcher home state across calamities.
  68  */
  69 public class LauncherBackupHelper implements BackupHelper {
  70 
  71     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /** icons are large, dribble them out */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /** widgets contain previews, which are very large, dribble them out */
  82     private static final int MAX_WIDGETS_PER_PASS = 5;
  83 
  84     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85 
  86     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87 
  88     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89 
  90     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91             android.graphics.Bitmap.CompressFormat.PNG;
  92 
  93     private static BackupManager sBackupManager;
  94 
  95     private static final String[] FAVORITE_PROJECTION = {
  96             Favorites._ID,                     // 0
  97             Favorites.MODIFIED,                // 1
  98             Favorites.INTENT,                  // 2
  99             Favorites.APPWIDGET_PROVIDER,      // 3
 100             Favorites.APPWIDGET_ID,            // 4
 101             Favorites.CELLX,                   // 5
 102             Favorites.CELLY,                   // 6
 103             Favorites.CONTAINER,               // 7
 104             Favorites.ICON,                    // 8
 105             Favorites.ICON_PACKAGE,            // 9
 106             Favorites.ICON_RESOURCE,           // 10
 107             Favorites.ICON_TYPE,               // 11
 108             Favorites.ITEM_TYPE,               // 12
 109             Favorites.SCREEN,                  // 13
 110             Favorites.SPANX,                   // 14
 111             Favorites.SPANY,                   // 15
 112             Favorites.TITLE,                   // 16
 113             Favorites.PROFILE_ID,              // 17
 114     };
 115 
 116     private static final int ID_INDEX = 0;
 117     private static final int ID_MODIFIED = 1;
 118     private static final int INTENT_INDEX = 2;
 119     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 120     private static final int APPWIDGET_ID_INDEX = 4;
 121     private static final int CELLX_INDEX = 5;
 122     private static final int CELLY_INDEX = 6;
 123     private static final int CONTAINER_INDEX = 7;
 124     private static final int ICON_INDEX = 8;
 125     private static final int ICON_PACKAGE_INDEX = 9;
 126     private static final int ICON_RESOURCE_INDEX = 10;
 127     private static final int ICON_TYPE_INDEX = 11;
 128     private static final int ITEM_TYPE_INDEX = 12;
 129     private static final int SCREEN_INDEX = 13;
 130     private static final int SPANX_INDEX = 14;
 131     private static final int SPANY_INDEX = 15;
 132     private static final int TITLE_INDEX = 16;
 133     private static final int PROFILE_ID_INDEX = 17;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136             WorkspaceScreens._ID,              // 0
 137             WorkspaceScreens.MODIFIED,         // 1
 138             WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private static IconCache mIconCache;
 144 
 145     private final Context mContext;
 146 
 147     private final boolean mRestoreEnabled;
 148 
 149     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 150 
 151     private final ArrayList&lt;Key&gt; mKeys;
 152 
 153     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 154         mContext = context;
 155         mRestoreEnabled = restoreEnabled;
 156         mKeys = new ArrayList&lt;Key&gt;();
 157     }
 158 
 159     private void dataChanged() {
 160         if (sBackupManager == null) {
 161             sBackupManager = new BackupManager(mContext);
 162         }
 163         sBackupManager.dataChanged();
 164     }
 165 
 166     /**
 167      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 168      *
 169      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 170      *
 171      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 172      *
 173      * @param oldState notes from the last backup
 174      * @param data incremental key/value pairs to persist off-device
 175      * @param newState notes for the next backup
 176      * @throws IOException
 177      */
 178     @Override
 179     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 180             ParcelFileDescriptor newState) {
 181         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 182 
 183         Journal in = readJournal(oldState);
 184         Journal out = new Journal();
 185 
 186         long lastBackupTime = in.t;
 187         out.t = System.currentTimeMillis();
 188         out.rows = 0;
 189         out.bytes = 0;
 190 
 191         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 192 
 193         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 194         if (launcherIsReady()) {
 195             try {
 196                 backupFavorites(in, data, out, keys);
 197                 backupScreens(in, data, out, keys);
 198                 backupIcons(in, data, out, keys);
 199                 backupWidgets(in, data, out, keys);
 200             } catch (IOException e) {
 201                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 202             }
 203             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 204         } else {
 205             out = in;
 206         }
 207 
 208 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 209 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216      * Restore launcher configuration from the restored data stream.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218      * &lt;P&gt;Keys may arrive in any order.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220      * @param data the key/value pair from the server</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 221      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 222     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 223     public void restoreEntity(BackupDataInputStream data) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 224         Log.v(TAG, &quot;restoreEntity&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 225         if (mKeys == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 226             mKeys = new ArrayList&lt;Key&gt;();</span>
 227 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 228         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 229 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 230         writeJournal(newState, out);
 231         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 232     }
 233 
 234     /**
 235      * Restore launcher configuration from the restored data stream.
 236      *
 237      * &lt;P&gt;Keys may arrive in any order.
 238      *
 239      * @param data the key/value pair from the server
 240      */
 241     @Override
 242     public void restoreEntity(BackupDataInputStream data) {
 243         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 244         byte[] buffer = new byte[512];
 245             String backupKey = data.getKey();
 246             int dataSize = data.size();
 247             if (buffer.length &lt; dataSize) {
 248                 buffer = new byte[dataSize];
 249             }
 250             Key key = null;
 251         int bytesRead = 0;
 252         try {
 253             bytesRead = data.read(buffer, 0, dataSize);
 254             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 255         } catch (IOException e) {
 256             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 257         }
 258         try {
 259             key = backupKeyToKey(backupKey);
 260             mKeys.add(key);
 261             switch (key.type) {
 262                 case Key.FAVORITE:
 263                     restoreFavorite(key, buffer, dataSize, mKeys);
 264                     break;
 265 
 266                 case Key.SCREEN:
 267                     restoreScreen(key, buffer, dataSize, mKeys);
 268                     break;
 269 
 270                 case Key.ICON:
 271                     restoreIcon(key, buffer, dataSize, mKeys);
 272                     break;
 273 
 274                 case Key.WIDGET:
 275                     restoreWidget(key, buffer, dataSize, mKeys);
 276                     break;
 277 
 278                 default:
 279                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 280                     break;
 281             }
 282         } catch (KeyParsingException e) {
 283             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 284         }
 285 
 286     }
 287 
 288     /**
 289      * Record the restore state for the next backup.
 290      *
 291      * @param newState notes about the backup state after restore.
 292      */
 293     @Override
 294     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 295         // clear the output journal time, to force a full backup to
 296         // will catch any changes the restore process might have made
 297         Journal out = new Journal();
 298         out.t = 0;
 299 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 300         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 301 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 302         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 303         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 304         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 305         mKeys.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 306     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 307 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 308     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 309      * Write all modified favorites to the data stream.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 310      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 311      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 312      * @param in notes from last backup</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 313      * @param data output stream for key/value pairs</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 314      * @param out notes about this backup</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 315      * @param keys keys to mark as clean in the notes for next backup</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 316      * @throws IOException</span>
 317 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 318         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 319 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 320         writeJournal(newState, out);
 321         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 322         mKeys.clear();
 323     }
 324 
 325     /**
 326      * Write all modified favorites to the data stream.
 327      *
 328      *
 329      * @param in notes from last backup
 330      * @param data output stream for key/value pairs
 331      * @param out notes about this backup
 332      * @param keys keys to mark as clean in the notes for next backup
 333      * @throws IOException
 334      */
 335     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 336             ArrayList&lt;Key&gt; keys)
 337             throws IOException {
 338         // read the old ID set
 339         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 340         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 341 
 342         // persist things that have changed since the last backup
 343         ContentResolver cr = mContext.getContentResolver();
 344         // Don&#x27;t backup apps in other profiles for now.
 345         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 346                 getUserSelectionArg(), null, null);
 347         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 348         try {
 349             cursor.moveToPosition(-1);
 350             while(cursor.moveToNext()) {
 351                 final long id = cursor.getLong(ID_INDEX);
 352                 final long updateTime = cursor.getLong(ID_MODIFIED);
 353                 Key key = getKey(Key.FAVORITE, id);
 354                 keys.add(key);
 355                 final String backupKey = keyToBackupKey(key);
 356                 currentIds.add(backupKey);
 357                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 358                     byte[] blob = packFavorite(cursor);
 359                     writeRowToBackup(key, blob, out, data);
 360                 } else {
 361                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 362                 }
 363             }
 364         } finally {
 365             cursor.close();
 366         }
 367         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 368 
 369         // these IDs must have been deleted
 370         savedIds.removeAll(currentIds);
 371         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 372     }
 373 
 374     /**
 375      * Read a favorite from the stream.
 376      *
 377      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 378      *
 379      * @param key identifier for the row
 380      * @param buffer the serialized proto from the stream, may be larger than dataSize
 381      * @param dataSize the size of the proto from the stream
 382      * @param keys keys to mark as clean in the notes for next backup
 383      */
 384     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 385         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 386         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 387                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 388 
 389         if (!mRestoreEnabled) {
 390             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 391             return;
 392         }
 393 
 394         try {
 395             ContentResolver cr = mContext.getContentResolver();
 396             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 397             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 398         } catch (InvalidProtocolBufferNanoException e) {
 399             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 400         }
 401     }
 402 
 403     /**
 404      * Write all modified screens to the data stream.
 405      *
 406      *
 407      * @param in notes from last backup
 408      * @param data output stream for key/value pairs
 409      * @param out notes about this backup
 410      * @param keys keys to mark as clean in the notes for next backup
 411      * @throws IOException
 412      */
 413     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 414             ArrayList&lt;Key&gt; keys)
 415             throws IOException {
 416         // read the old ID set
 417         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 418         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 419 
 420         // persist things that have changed since the last backup
 421         ContentResolver cr = mContext.getContentResolver();
 422         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 423                 null, null, null);
 424         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 425         try {
 426             cursor.moveToPosition(-1);
 427             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 428             while(cursor.moveToNext()) {
 429                 final long id = cursor.getLong(ID_INDEX);
 430                 final long updateTime = cursor.getLong(ID_MODIFIED);
 431                 Key key = getKey(Key.SCREEN, id);
 432                 keys.add(key);
 433                 final String backupKey = keyToBackupKey(key);
 434                 currentIds.add(backupKey);
 435                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 436                     byte[] blob = packScreen(cursor);
 437                     writeRowToBackup(key, blob, out, data);
 438                 } else {
 439                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 440                 }
 441             }
 442         } finally {
 443             cursor.close();
 444         }
 445         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 446 
 447         // these IDs must have been deleted
 448         savedIds.removeAll(currentIds);
 449         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 450     }
 451 
 452     /**
 453      * Read a screen from the stream.
 454      *
 455      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 456      *
 457      * @param key identifier for the row
 458      * @param buffer the serialized proto from the stream, may be larger than dataSize
 459      * @param dataSize the size of the proto from the stream
 460      * @param keys keys to mark as clean in the notes for next backup
 461      */
 462     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 463         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 464         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 465                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 466 
 467         if (!mRestoreEnabled) {
 468             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 469             return;
 470         }
 471 
 472         try {
 473             ContentResolver cr = mContext.getContentResolver();
 474             ContentValues values = unpackScreen(buffer, 0, dataSize);
 475             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 476 
 477         } catch (InvalidProtocolBufferNanoException e) {
 478             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 479         }
 480     }
 481 
 482     /**
 483      * Write all the static icon resources we need to render placeholders
 484      * for a package that is not installed.
 485      *
 486      * @param in notes from last backup
 487      * @param data output stream for key/value pairs
 488      * @param out notes about this backup
 489      * @param keys keys to mark as clean in the notes for next backup
 490      * @throws IOException
 491      */
 492     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 493             ArrayList&lt;Key&gt; keys) throws IOException {
 494         // persist icons that haven&#x27;t been persisted yet
 495         if (!initializeIconCache()) {
 496             dataChanged(); // try again later
 497             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 498             return;
 499         }
 500         final ContentResolver cr = mContext.getContentResolver();
 501         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 502         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 503 
 504         // read the old ID set
 505         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 506         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 507 
 508         // Don&#x27;t backup apps in other profiles for now.
 509         int startRows = out.rows;
 510         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 511 
 512         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 513                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 514                 getUserSelectionArg();
 515         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 516                 where, null, null);
 517         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 518         try {
 519             cursor.moveToPosition(-1);
 520             while(cursor.moveToNext()) {
 521                 final long id = cursor.getLong(ID_INDEX);
 522                 final String intentDescription = cursor.getString(INTENT_INDEX);
 523                 try {
 524                     Intent intent = Intent.parseUri(intentDescription, 0);
 525                     ComponentName cn = intent.getComponent();
 526                     Key key = null;
 527                     String backupKey = null;
 528                     if (cn != null) {
 529                         key = getKey(Key.ICON, cn.flattenToShortString());
 530                         backupKey = keyToBackupKey(key);
 531                         currentIds.add(backupKey);
 532                     } else {
 533                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 534                     }
 535                     if (savedIds.contains(backupKey)) {
 536                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 537 
 538                         // remember that we already backed this up previously
 539                         keys.add(key);
 540                     } else if (backupKey != null) {
 541                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 542                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 543                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 544                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 545                             keys.add(key);
 546                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 547                                 byte[] blob = packIcon(dpi, icon);
 548                                 writeRowToBackup(key, blob, out, data);
 549                             }
 550                         } else {
 551                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 552                             // too many icons for this pass, request another.
 553                             dataChanged();
 554                         }
 555                     }
 556                 } catch (URISyntaxException e) {
 557                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 558                 } catch (IOException e) {
 559                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 560                 }
 561 
 562             }
 563         } finally {
 564             cursor.close();
 565         }
 566         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 567 
 568         // these IDs must have been deleted
 569         savedIds.removeAll(currentIds);
 570         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 571     }
 572 
 573     /**
 574      * Read an icon from the stream.
 575      *
 576      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 577      *
 578      * @param key identifier for the row
 579      * @param buffer the serialized proto from the stream, may be larger than dataSize
 580      * @param dataSize the size of the proto from the stream
 581      * @param keys keys to mark as clean in the notes for next backup
 582      */
 583     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 584         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 585         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 586                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 587 
 588         try {
 589             Resource res = unpackIcon(buffer, 0, dataSize);
 590             if (DEBUG) {
 591                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 592             }
 593             if (DEBUG_PAYLOAD) {
 594                 Log.d(TAG, &quot;read &quot; +
 595                         Base64.encodeToString(res.data, 0, res.data.length,
 596                                 Base64.NO_WRAP));
 597             }
 598             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 599             if (icon == null) {
 600                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 601             }
 602 
 603             if (!mRestoreEnabled) {
 604                 if (VERBOSE) {
 605                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 606                 }
 607                 return;
 608             } else {
 609                 if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 610                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 611                         icon, res.dpi);
 612             }
 613         } catch (IOException e) {
 614             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 615         }
 616     }
 617 
 618     /**
 619      * Write all the static widget resources we need to render placeholders
 620      * for a package that is not installed.
 621      *
 622      * @param in notes from last backup
 623      * @param data output stream for key/value pairs
 624      * @param out notes about this backup
 625      * @param keys keys to mark as clean in the notes for next backup
 626      * @throws IOException
 627      */
 628     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 629             ArrayList&lt;Key&gt; keys) throws IOException {
 630         // persist static widget info that hasn&#x27;t been persisted yet
 631         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 632         if (appState == null || !initializeIconCache()) {
 633             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 634             return;
 635         }
 636         final ContentResolver cr = mContext.getContentResolver();
 637         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 638         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 639         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 640         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 641         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 642 
 643         // read the old ID set
 644         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 645         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 646 
 647         int startRows = out.rows;
 648         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 649         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 650                 + getUserSelectionArg();
 651         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 652                 where, null, null);
 653         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 654         try {
 655             cursor.moveToPosition(-1);
 656             while(cursor.moveToNext()) {
 657                 final long id = cursor.getLong(ID_INDEX);
 658                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 659                 final int spanX = cursor.getInt(SPANX_INDEX);
 660                 final int spanY = cursor.getInt(SPANY_INDEX);
 661                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 662                 Key key = null;
 663                 String backupKey = null;
 664                 if (provider != null) {
 665                     key = getKey(Key.WIDGET, providerName);
 666                     backupKey = keyToBackupKey(key);
 667                     currentIds.add(backupKey);
 668                 } else {
 669                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 670                 }
 671                 if (savedIds.contains(backupKey)) {
 672                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 673 
 674                     // remember that we already backed this up previously
 675                     keys.add(key);
 676                 } else if (backupKey != null) {
 677                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 678                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 679                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 680                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 681                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 682                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 683                         keys.add(key);
 684                         writeRowToBackup(key, blob, out, data);
 685 
 686                     } else {
 687                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 688                         // too many widgets for this pass, request another.
 689                         dataChanged();
 690                     }
 691                 }
 692             }
 693         } finally {
 694             cursor.close();
 695         }
 696         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 697 
 698         // these IDs must have been deleted
 699         savedIds.removeAll(currentIds);
 700         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 701     }
 702 
 703     /**
 704      * Read a widget from the stream.
 705      *
 706      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 707      *
 708      * @param key identifier for the row
 709      * @param buffer the serialized proto from the stream, may be larger than dataSize
 710      * @param dataSize the size of the proto from the stream
 711      * @param keys keys to mark as clean in the notes for next backup
 712      */
 713     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 714         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 715         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 716                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 717         try {
 718             Widget widget = unpackWidget(buffer, 0, dataSize);
 719             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 720             if (widget.icon.data != null)  {
 721                 Bitmap icon = BitmapFactory
 722                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 723                 if (icon == null) {
 724                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 725                 } else {
 726                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 727                             icon, widget.icon.dpi);
 728                 }
 729             }
 730 
 731             if (!mRestoreEnabled) {
 732                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 733                 return;
 734             } else {
 735                 // future site of widget table mutation
 736             }
 737         } catch (InvalidProtocolBufferNanoException e) {
 738             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 739         }
 740     }
 741 
 742     /** create a new key, with an integer ID.
 743      *
 744      * &lt;P&gt; Keys contain their own checksum instead of using
 745      * the heavy-weight CheckedMessage wrapper.
 746      */
 747     private Key getKey(int type, long id) {
 748         Key key = new Key();
 749         key.type = type;
 750         key.id = id;
 751         key.checksum = checkKey(key);
 752         return key;
 753     }
 754 
 755     /** create a new key for a named object.
 756      *
 757      * &lt;P&gt; Keys contain their own checksum instead of using
 758      * the heavy-weight CheckedMessage wrapper.
 759      */
 760     private Key getKey(int type, String name) {
 761         Key key = new Key();
 762         key.type = type;
 763         key.name = name;
 764         key.checksum = checkKey(key);
 765         return key;
 766     }
 767 
 768     /** keys need to be strings, serialize and encode. */
 769     private String keyToBackupKey(Key key) {
 770         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 771     }
 772 
 773     /** keys need to be strings, decode and parse. */
 774     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 775         try {
 776             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 777             if (key.checksum != checkKey(key)) {
 778                 key = null;
 779                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 780             }
 781             return key;
 782         } catch (InvalidProtocolBufferNanoException e) {
 783             throw new KeyParsingException(e);
 784         } catch (IllegalArgumentException e) {
 785             throw new KeyParsingException(e);
 786         }
 787     }
 788 
 789     private String getKeyName(Key key) {
 790         if (TextUtils.isEmpty(key.name)) {
 791             return Long.toString(key.id);
 792         } else {
 793             return key.name;
 794         }
 795 
 796     }
 797 
 798     private String geKeyType(Key key) {
 799         switch (key.type) {
 800             case Key.FAVORITE:
 801                 return &quot;favorite&quot;;
 802             case Key.SCREEN:
 803                 return &quot;screen&quot;;
 804             case Key.ICON:
 805                 return &quot;icon&quot;;
 806             case Key.WIDGET:
 807                 return &quot;widget&quot;;
 808             default:
 809                 return &quot;anonymous&quot;;
 810         }
 811     }
 812 
 813     /** Compute the checksum over the important bits of a key. */
 814     private long checkKey(Key key) {
 815         CRC32 checksum = new CRC32();
 816         checksum.update(key.type);
 817         checksum.update((int) (key.id &amp; 0xffff));
 818         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 819         if (!TextUtils.isEmpty(key.name)) {
 820             checksum.update(key.name.getBytes());
 821         }
 822         return checksum.getValue();
 823     }
 824 
 825     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 826     private byte[] packFavorite(Cursor c) {
 827         Favorite favorite = new Favorite();
 828         favorite.id = c.getLong(ID_INDEX);
 829         favorite.screen = c.getInt(SCREEN_INDEX);
 830         favorite.container = c.getInt(CONTAINER_INDEX);
 831         favorite.cellX = c.getInt(CELLX_INDEX);
 832         favorite.cellY = c.getInt(CELLY_INDEX);
 833         favorite.spanX = c.getInt(SPANX_INDEX);
 834         favorite.spanY = c.getInt(SPANY_INDEX);
 835         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 836         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 837             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 838             if (!TextUtils.isEmpty(iconPackage)) {
 839                 favorite.iconPackage = iconPackage;
 840             }
 841             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 842             if (!TextUtils.isEmpty(iconResource)) {
 843                 favorite.iconResource = iconResource;
 844             }
 845         }
 846         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 847             byte[] blob = c.getBlob(ICON_INDEX);
 848             if (blob != null &amp;&amp; blob.length &gt; 0) {
 849                 favorite.icon = blob;
 850             }
 851         }
 852         String title = c.getString(TITLE_INDEX);
 853         if (!TextUtils.isEmpty(title)) {
 854             favorite.title = title;
 855         }
 856         String intentDescription = c.getString(INTENT_INDEX);
 857         if (!TextUtils.isEmpty(intentDescription)) {
 858             try {
 859                 Intent intent = Intent.parseUri(intentDescription, 0);
 860                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 861                 favorite.intent = intent.toUri(0);
 862             } catch (URISyntaxException e) {
 863                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 864            }
 865         }
 866         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 867         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 868             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 869             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 870             if (!TextUtils.isEmpty(appWidgetProvider)) {
 871                 favorite.appWidgetProvider = appWidgetProvider;
 872             }
 873         }
 874 
 875         return writeCheckedBytes(favorite);
 876     }
 877 
 878     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 879     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 880             throws InvalidProtocolBufferNanoException {
 881         Favorite favorite = new Favorite();
 882         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 883         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 884                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 885         ContentValues values = new ContentValues();
 886         values.put(Favorites._ID, favorite.id);
 887         values.put(Favorites.SCREEN, favorite.screen);
 888         values.put(Favorites.CONTAINER, favorite.container);
 889         values.put(Favorites.CELLX, favorite.cellX);
 890         values.put(Favorites.CELLY, favorite.cellY);
 891         values.put(Favorites.SPANX, favorite.spanX);
 892         values.put(Favorites.SPANY, favorite.spanY);
 893         values.put(Favorites.ICON_TYPE, favorite.iconType);
 894         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 895             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 896             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 897         }
 898         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 899             values.put(Favorites.ICON, favorite.icon);
 900         }
 901         if (!TextUtils.isEmpty(favorite.title)) {
 902             values.put(Favorites.TITLE, favorite.title);
 903         } else {
 904             values.put(Favorites.TITLE, &quot;&quot;);
 905         }
 906         if (!TextUtils.isEmpty(favorite.intent)) {
 907             values.put(Favorites.INTENT, favorite.intent);
 908         }
 909         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 910 
 911         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 912         long userSerialNumber =
 913                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 914         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 915 
 916         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 917             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 918                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 919             }
 920             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 921             values.put(LauncherSettings.Favorites.RESTORED,
 922                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 923                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 924                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 925         } else {
 926             // Let LauncherModel know we&#x27;ve been here.
 927             values.put(LauncherSettings.Favorites.RESTORED, 1);
 928         }
 929 
 930         return values;
 931     }
 932 
 933     /** Serialize a Screen for persistence, including a checksum wrapper. */
 934     private byte[] packScreen(Cursor c) {
 935         Screen screen = new Screen();
 936         screen.id = c.getLong(ID_INDEX);
 937         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 938 
 939         return writeCheckedBytes(screen);
 940     }
 941 
 942     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 943     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 944             throws InvalidProtocolBufferNanoException {
 945         Screen screen = new Screen();
 946         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 947         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 948         ContentValues values = new ContentValues();
 949         values.put(WorkspaceScreens._ID, screen.id);
 950         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 951         return values;
 952     }
 953 
 954     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 955     private byte[] packIcon(int dpi, Bitmap icon) {
 956         Resource res = new Resource();
 957         res.dpi = dpi;
 958         ByteArrayOutputStream os = new ByteArrayOutputStream();
 959         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 960             res.data = os.toByteArray();
 961         }
 962         return writeCheckedBytes(res);
 963     }
 964 
 965     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 966     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 967             throws InvalidProtocolBufferNanoException {
 968         Resource res = new Resource();
 969         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 970         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 971         return res;
 972     }
 973 
 974     /** Serialize a widget for persistence, including a checksum wrapper. */
 975     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 976             ComponentName provider) {
 977         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 978         Widget widget = new Widget();
 979         widget.provider = provider.flattenToShortString();
 980         widget.label = info.label;
 981         widget.configure = info.configure != null;
 982         if (info.icon != 0) {
 983             widget.icon = new Resource();
 984             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 985             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 986             ByteArrayOutputStream os = new ByteArrayOutputStream();
 987             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 988                 widget.icon.data = os.toByteArray();
 989                 widget.icon.dpi = dpi;
 990             }
 991         }
 992         if (info.previewImage != 0) {
 993             widget.preview = new Resource();
 994             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 995             ByteArrayOutputStream os = new ByteArrayOutputStream();
 996             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 997                 widget.preview.data = os.toByteArray();
 998                 widget.preview.dpi = dpi;
 999             }
1000         }
1001         return writeCheckedBytes(widget);
1002     }
1003 
1004     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
1005     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
1006             throws InvalidProtocolBufferNanoException {
1007         Widget widget = new Widget();
1008         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
1009         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
1010         return widget;
1011     }
1012 
1013     /**
1014      * Read the old journal from the input file.
1015      *
1016      * In the event of any error, just pretend we didn&#x27;t have a journal,
1017      * in that case, do a full backup.
1018      *
1019      * @param oldState the read-0only file descriptor pointing to the old journal
1020      * @return a Journal protocol buffer
1021      */
1022     private Journal readJournal(ParcelFileDescriptor oldState) {
1023         Journal journal = new Journal();
1024         if (oldState == null) {
1025             return journal;
1026         }
1027         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1028         try {
1029             int availableBytes = inStream.available();
1030             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1031             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1032                 byte[] buffer = new byte[availableBytes];
1033                 int bytesRead = 0;
1034                 boolean valid = false;
1035                 InvalidProtocolBufferNanoException lastProtoException = null;
1036                 while (availableBytes &gt; 0) {
1037                     try {
1038                         // OMG what are you doing? This is crazy inefficient!
1039                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1040                         // However, we don&#x27;t know how many bytes to expect (oops).
1041                         // So we have to step through *slowly*, watching for the end.
1042                         int result = inStream.read(buffer, bytesRead, 1);
1043                         if (result &gt; 0) {
1044                             availableBytes -= result;
1045                             bytesRead += result;
1046                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1047                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1048                             }
1049                         } else {
1050                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1051                             // stop reading and see what there is to parse
1052                             availableBytes = 0;
1053                         }
1054                     } catch (IOException e) {
1055                         buffer = null;
1056                         availableBytes = 0;
1057                     }
1058 
1059                     // check the buffer to see if we have a valid journal
1060                     try {
1061                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1062                         // if we are here, then we have read a valid, checksum-verified journal
1063                         valid = true;
1064                         availableBytes = 0;
1065                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1066                     } catch (InvalidProtocolBufferNanoException e) {
1067                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1068                         lastProtoException = e;
1069                         journal.clear();
1070                     }
1071                 }
1072                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1073                 if (!valid) {
1074                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1075                 }
1076             }
1077         } catch (IOException e) {
1078             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1079         } finally {
1080             try {
1081                 inStream.close();
1082             } catch (IOException e) {
1083                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1084             }
1085         }
1086         return journal;
1087     }
1088 
1089     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1090             BackupDataOutput data) throws IOException {
1091         String backupKey = keyToBackupKey(key);
1092         data.writeEntityHeader(backupKey, blob.length);
1093         data.writeEntityData(blob, blob.length);
1094         out.rows++;
1095         out.bytes += blob.length;
1096         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1097                 getKeyName(key) + &quot;/&quot; + blob.length);
1098         if(DEBUG_PAYLOAD) {
1099             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1100             final int chunkSize = 1024;
1101             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1102                 int end = offset + chunkSize;
1103                 end = Math.min(end, encoded.length());
1104                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1105             }
1106         }
1107     }
1108 
1109     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1110         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1111         for(int i = 0; i &lt; in.key.length; i++) {
1112             Key key = in.key[i];
1113             if (key.type == type) {
1114                 savedIds.add(keyToBackupKey(key));
1115             }
1116         }
1117         return savedIds;
1118     }
1119 
1120     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1121             throws IOException {
1122         int rows = 0;
1123         for(String deleted: deletedIds) {
1124             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1125             data.writeEntityHeader(deleted, -1);
1126             rows++;
1127         }
1128         return rows;
1129     }
1130 
1131     /**
1132      * Write the new journal to the output file.
1133      *
1134      * In the event of any error, just pretend we didn&#x27;t have a journal,
1135      * in that case, do a full backup.
1136 
1137      * @param newState the write-only file descriptor pointing to the new journal
1138      * @param journal a Journal protocol buffer
1139      */
1140     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1141         FileOutputStream outStream = null;
1142         try {
1143             outStream = new FileOutputStream(newState.getFileDescriptor());
1144             final byte[] journalBytes = writeCheckedBytes(journal);
1145             outStream.write(journalBytes);
1146             outStream.close();
1147             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1148         } catch (IOException e) {
1149             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1150         }
1151     }
1152 
1153     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1154     private byte[] writeCheckedBytes(MessageNano proto) {
1155         CheckedMessage wrapper = new CheckedMessage();
1156         wrapper.payload = MessageNano.toByteArray(proto);
1157         CRC32 checksum = new CRC32();
1158         checksum.update(wrapper.payload);
1159         wrapper.checksum = checksum.getValue();
1160         return MessageNano.toByteArray(wrapper);
1161     }
1162 
1163     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1164     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1165             throws InvalidProtocolBufferNanoException {
1166         CheckedMessage wrapper = new CheckedMessage();
1167         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1168         CRC32 checksum = new CRC32();
1169         checksum.update(wrapper.payload);
1170         if (wrapper.checksum != checksum.getValue()) {
1171             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1172         }
1173         return wrapper.payload;
1174     }
1175 
1176     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1177         if (mWidgetMap == null) {
1178             List&lt;AppWidgetProviderInfo&gt; widgets =
1179                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1180             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1181             for (AppWidgetProviderInfo info : widgets) {
1182                 mWidgetMap.put(info.provider, info);
1183             }
1184         }
1185         return mWidgetMap.get(component);
1186     }
1187 
1188 
1189     private boolean initializeIconCache() {
1190         if (mIconCache != null) {
1191             return true;
1192         }
1193 
1194         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1195         if (appState == null) {
1196             Throwable stackTrace = new Throwable();
1197             stackTrace.fillInStackTrace();
1198             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1199             return false;
1200         }
1201         mIconCache = appState.getIconCache();
1202         return mIconCache != null;
1203     }
1204 
1205 
1206    // check if the launcher is in a state to support backup
1207     private boolean launcherIsReady() {
1208         ContentResolver cr = mContext.getContentResolver();
1209         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1210         if (cursor == null) {
1211             // launcher data has been wiped, do nothing
1212             return false;
1213         }
1214         cursor.close();
1215 
1216         if (!initializeIconCache()) {
1217             // launcher services are unavailable, try again later
1218             dataChanged();
1219             return false;
1220         }
1221 
1222         return true;
1223     }
1224 
1225     private String getUserSelectionArg() {
1226         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1227                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1228     }
1229 
1230     private class KeyParsingException extends Throwable {
1231         private KeyParsingException(Throwable cause) {
1232             super(cause);
1233         }
1234 
1235         public KeyParsingException(String reason) {
1236             super(reason);
1237         }
1238     }
1239 }
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 import com.android.launcher3.compat.UserManagerCompat;
  32 import com.android.launcher3.compat.UserHandleCompat;
  33 
  34 import android.app.backup.BackupDataInputStream;
  35 import android.app.backup.BackupHelper;
  36 import android.app.backup.BackupDataOutput;
  37 import android.app.backup.BackupManager;
  38 import android.appwidget.AppWidgetManager;
  39 import android.appwidget.AppWidgetProviderInfo;
  40 import android.content.ComponentName;
  41 import android.content.ContentResolver;
  42 import android.content.ContentValues;
  43 import android.content.Context;
  44 import android.content.Intent;
  45 import android.database.Cursor;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.graphics.drawable.Drawable;
  49 import android.os.ParcelFileDescriptor;
  50 import android.text.TextUtils;
  51 import android.util.Base64;
  52 import android.util.Log;
  53 
  54 import java.io.ByteArrayOutputStream;
  55 import java.io.FileInputStream;
  56 import java.io.FileOutputStream;
  57 import java.io.IOException;
  58 import java.net.URISyntaxException;
  59 import java.util.ArrayList;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.zip.CRC32;
  65 
  66 /**
  67  * Persist the launcher home state across calamities.
  68  */
  69 public class LauncherBackupHelper implements BackupHelper {
  70 
  71     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /** icons are large, dribble them out */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /** widgets contain previews, which are very large, dribble them out */
  82     private static final int MAX_WIDGETS_PER_PASS = 5;
  83 
  84     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85 
  86     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87 
  88     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89 
  90     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91             android.graphics.Bitmap.CompressFormat.PNG;
  92 
  93     private static BackupManager sBackupManager;
  94 
  95     private static final String[] FAVORITE_PROJECTION = {
  96             Favorites._ID,                     // 0
  97             Favorites.MODIFIED,                // 1
  98             Favorites.INTENT,                  // 2
  99             Favorites.APPWIDGET_PROVIDER,      // 3
 100             Favorites.APPWIDGET_ID,            // 4
 101             Favorites.CELLX,                   // 5
 102             Favorites.CELLY,                   // 6
 103             Favorites.CONTAINER,               // 7
 104             Favorites.ICON,                    // 8
 105             Favorites.ICON_PACKAGE,            // 9
 106             Favorites.ICON_RESOURCE,           // 10
 107             Favorites.ICON_TYPE,               // 11
 108             Favorites.ITEM_TYPE,               // 12
 109             Favorites.SCREEN,                  // 13
 110             Favorites.SPANX,                   // 14
 111             Favorites.SPANY,                   // 15
 112             Favorites.TITLE,                   // 16
 113             Favorites.PROFILE_ID,              // 17
 114     };
 115 
 116     private static final int ID_INDEX = 0;
 117     private static final int ID_MODIFIED = 1;
 118     private static final int INTENT_INDEX = 2;
 119     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 120     private static final int APPWIDGET_ID_INDEX = 4;
 121     private static final int CELLX_INDEX = 5;
 122     private static final int CELLY_INDEX = 6;
 123     private static final int CONTAINER_INDEX = 7;
 124     private static final int ICON_INDEX = 8;
 125     private static final int ICON_PACKAGE_INDEX = 9;
 126     private static final int ICON_RESOURCE_INDEX = 10;
 127     private static final int ICON_TYPE_INDEX = 11;
 128     private static final int ITEM_TYPE_INDEX = 12;
 129     private static final int SCREEN_INDEX = 13;
 130     private static final int SPANX_INDEX = 14;
 131     private static final int SPANY_INDEX = 15;
 132     private static final int TITLE_INDEX = 16;
 133     private static final int PROFILE_ID_INDEX = 17;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136             WorkspaceScreens._ID,              // 0
 137             WorkspaceScreens.MODIFIED,         // 1
 138             WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private static IconCache mIconCache;
 144 
 145     private final Context mContext;
 146 
 147     private final boolean mRestoreEnabled;
 148 
 149     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 150 
 151     private final ArrayList&lt;Key&gt; mKeys;
 152 
 153     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 154         mContext = context;
 155         mRestoreEnabled = restoreEnabled;
 156         mKeys = new ArrayList&lt;Key&gt;();
 157     }
 158 
 159     private void dataChanged() {
 160         if (sBackupManager == null) {
 161             sBackupManager = new BackupManager(mContext);
 162         }
 163         sBackupManager.dataChanged();
 164     }
 165 
 166     /**
 167      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 168      *
 169      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 170      *
 171      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 172      *
 173      * @param oldState notes from the last backup
 174      * @param data incremental key/value pairs to persist off-device
 175      * @param newState notes for the next backup
 176      * @throws IOException
 177      */
 178     @Override
 179     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 180             ParcelFileDescriptor newState) {
 181         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 182 
 183         Journal in = readJournal(oldState);
 184         Journal out = new Journal();
 185 
 186         long lastBackupTime = in.t;
 187         out.t = System.currentTimeMillis();
 188         out.rows = 0;
 189         out.bytes = 0;
 190 
 191         Log.v(TAG, &quot;lastBackupTime=&quot; + lastBackupTime);
 192 
 193         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 194         if (launcherIsReady()) {
 195         try {
 196             backupFavorites(in, data, out, keys);
 197             backupScreens(in, data, out, keys);
 198             backupIcons(in, data, out, keys);
 199             backupWidgets(in, data, out, keys);
 200         } catch (IOException e) {
 201             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 202         }
 203             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 204         } else {
 205             out = in;
 206         }
 207 
 208 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 209 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 210         out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 211         writeJournal(newState, out);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 212         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 213     }</span>
 214 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 215         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 216 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 217         writeJournal(newState, out);
 218         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 219     }
 220 
 221     /**
 222      * Restore launcher configuration from the restored data stream.
 223      *
 224      * &lt;P&gt;Keys may arrive in any order.
 225      *
 226      * @param data the key/value pair from the server
 227      */
 228     @Override
 229     public void restoreEntity(BackupDataInputStream data) {
 230         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 231         byte[] buffer = new byte[512];
 232             String backupKey = data.getKey();
 233             int dataSize = data.size();
 234             if (buffer.length &lt; dataSize) {
 235                 buffer = new byte[dataSize];
 236             }
 237             Key key = null;
 238         int bytesRead = 0;
 239         try {
 240             bytesRead = data.read(buffer, 0, dataSize);
 241             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 242         } catch (IOException e) {
 243             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 244         }
 245         try {
 246             key = backupKeyToKey(backupKey);
 247             mKeys.add(key);
 248             switch (key.type) {
 249                 case Key.FAVORITE:
 250                     restoreFavorite(key, buffer, dataSize, mKeys);
 251                     break;
 252 
 253                 case Key.SCREEN:
 254                     restoreScreen(key, buffer, dataSize, mKeys);
 255                     break;
 256 
 257                 case Key.ICON:
 258                     restoreIcon(key, buffer, dataSize, mKeys);
 259                     break;
 260 
 261                 case Key.WIDGET:
 262                     restoreWidget(key, buffer, dataSize, mKeys);
 263                     break;
 264 
 265                 default:
 266                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 267                     break;
 268             }
 269         } catch (KeyParsingException e) {
 270             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 271         }
 272 
 273     }
 274 
 275     /**
 276      * Record the restore state for the next backup.
 277      *
 278      * @param newState notes about the backup state after restore.
 279      */
 280     @Override
 281     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 282         // clear the output journal time, to force a full backup to
 283         // will catch any changes the restore process might have made
 284         Journal out = new Journal();
 285         out.t = 0;
 286 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 287         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 288 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 289         out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
 290 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 291         out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 292 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 293         writeJournal(newState, out);
 294         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 295         mKeys.clear();
 296     }
 297 
 298     /**
 299      * Write all modified favorites to the data stream.
 300      *
 301      *
 302      * @param in notes from last backup
 303      * @param data output stream for key/value pairs
 304      * @param out notes about this backup
 305      * @param keys keys to mark as clean in the notes for next backup
 306      * @throws IOException
 307      */
 308     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 309             ArrayList&lt;Key&gt; keys)
 310             throws IOException {
 311         // read the old ID set
 312         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 313         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 314 
 315         // persist things that have changed since the last backup
 316         ContentResolver cr = mContext.getContentResolver();
 317         // Don&#x27;t backup apps in other profiles for now.
 318         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 319                 getUserSelectionArg(), null, null);
 320         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 321         try {
 322             cursor.moveToPosition(-1);
 323             while(cursor.moveToNext()) {
 324                 final long id = cursor.getLong(ID_INDEX);
 325                 final long updateTime = cursor.getLong(ID_MODIFIED);
 326                 Key key = getKey(Key.FAVORITE, id);
 327                 keys.add(key);
 328                 final String backupKey = keyToBackupKey(key);
 329                 currentIds.add(backupKey);
 330                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 331                     byte[] blob = packFavorite(cursor);
 332                     writeRowToBackup(key, blob, out, data);
 333                 } else {
 334                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 335                 }
 336             }
 337         } finally {
 338             cursor.close();
 339         }
 340         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 341 
 342         // these IDs must have been deleted
 343         savedIds.removeAll(currentIds);
 344         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 345     }
 346 
 347     /**
 348      * Read a favorite from the stream.
 349      *
 350      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 351      *
 352      * @param key identifier for the row
 353      * @param buffer the serialized proto from the stream, may be larger than dataSize
 354      * @param dataSize the size of the proto from the stream
 355      * @param keys keys to mark as clean in the notes for next backup
 356      */
 357     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 358         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 359         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 360                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 361 
 362         if (!mRestoreEnabled) {
 363             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 364             return;
 365         }
 366 
 367         try {
 368             ContentResolver cr = mContext.getContentResolver();
 369             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 370             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 371         } catch (InvalidProtocolBufferNanoException e) {
 372             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 373         }
 374     }
 375 
 376     /**
 377      * Write all modified screens to the data stream.
 378      *
 379      *
 380      * @param in notes from last backup
 381      * @param data output stream for key/value pairs
 382      * @param out notes about this backup
 383      * @param keys keys to mark as clean in the notes for next backup
 384      * @throws IOException
 385      */
 386     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 387             ArrayList&lt;Key&gt; keys)
 388             throws IOException {
 389         // read the old ID set
 390         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 391         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 392 
 393         // persist things that have changed since the last backup
 394         ContentResolver cr = mContext.getContentResolver();
 395         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 396                 null, null, null);
 397         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 398         try {
 399             cursor.moveToPosition(-1);
 400             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 401             while(cursor.moveToNext()) {
 402                 final long id = cursor.getLong(ID_INDEX);
 403                 final long updateTime = cursor.getLong(ID_MODIFIED);
 404                 Key key = getKey(Key.SCREEN, id);
 405                 keys.add(key);
 406                 final String backupKey = keyToBackupKey(key);
 407                 currentIds.add(backupKey);
 408                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 409                     byte[] blob = packScreen(cursor);
 410                     writeRowToBackup(key, blob, out, data);
 411                 } else {
 412                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 413                 }
 414             }
 415         } finally {
 416             cursor.close();
 417         }
 418         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 419 
 420         // these IDs must have been deleted
 421         savedIds.removeAll(currentIds);
 422         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 423     }
 424 
 425     /**
 426      * Read a screen from the stream.
 427      *
 428      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 429      *
 430      * @param key identifier for the row
 431      * @param buffer the serialized proto from the stream, may be larger than dataSize
 432      * @param dataSize the size of the proto from the stream
 433      * @param keys keys to mark as clean in the notes for next backup
 434      */
 435     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 436         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 437         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 438                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 439 
 440         if (!mRestoreEnabled) {
 441             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 442             return;
 443         }
 444 
 445         try {
 446             ContentResolver cr = mContext.getContentResolver();
 447             ContentValues values = unpackScreen(buffer, 0, dataSize);
 448             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 449 
 450         } catch (InvalidProtocolBufferNanoException e) {
 451             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 452         }
 453     }
 454 
 455     /**
 456      * Write all the static icon resources we need to render placeholders
 457      * for a package that is not installed.
 458      *
 459      * @param in notes from last backup
 460      * @param data output stream for key/value pairs
 461      * @param out notes about this backup
 462      * @param keys keys to mark as clean in the notes for next backup
 463      * @throws IOException
 464      */
 465     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 466             ArrayList&lt;Key&gt; keys) throws IOException {
 467         // persist icons that haven&#x27;t been persisted yet
 468         if (!initializeIconCache()) {
 469             dataChanged(); // try again later
 470             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 471             return;
 472         }
 473         final ContentResolver cr = mContext.getContentResolver();
 474         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 475         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 476 
 477         // read the old ID set
 478         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 479         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 480 
 481         // Don&#x27;t backup apps in other profiles for now.
 482         int startRows = out.rows;
 483         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 484 
 485         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 486                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 487                 getUserSelectionArg();
 488         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 489                 where, null, null);
 490         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 491         try {
 492             cursor.moveToPosition(-1);
 493             while(cursor.moveToNext()) {
 494                 final long id = cursor.getLong(ID_INDEX);
 495                 final String intentDescription = cursor.getString(INTENT_INDEX);
 496                 try {
 497                     Intent intent = Intent.parseUri(intentDescription, 0);
 498                     ComponentName cn = intent.getComponent();
 499                     Key key = null;
 500                     String backupKey = null;
 501                     if (cn != null) {
 502                         key = getKey(Key.ICON, cn.flattenToShortString());
 503                         backupKey = keyToBackupKey(key);
 504                         currentIds.add(backupKey);
 505                     } else {
 506                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 507                     }
 508                     if (savedIds.contains(backupKey)) {
 509                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 510 
 511                         // remember that we already backed this up previously
 512                         keys.add(key);
 513                     } else if (backupKey != null) {
 514                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 515                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 516                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 517                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 518                             keys.add(key);
 519                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 520                                 byte[] blob = packIcon(dpi, icon);
 521                                 writeRowToBackup(key, blob, out, data);
 522                             }
 523                         } else {
 524                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 525                             // too many icons for this pass, request another.
 526                             dataChanged();
 527                         }
 528                     }
 529                 } catch (URISyntaxException e) {
 530                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 531                 } catch (IOException e) {
 532                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 533                 }
 534 
 535             }
 536         } finally {
 537             cursor.close();
 538         }
 539         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 540 
 541         // these IDs must have been deleted
 542         savedIds.removeAll(currentIds);
 543         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 544     }
 545 
 546     /**
 547      * Read an icon from the stream.
 548      *
 549      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 550      *
 551      * @param key identifier for the row
 552      * @param buffer the serialized proto from the stream, may be larger than dataSize
 553      * @param dataSize the size of the proto from the stream
 554      * @param keys keys to mark as clean in the notes for next backup
 555      */
 556     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 557         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 558         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 559                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 560 
 561         try {
 562             Resource res = unpackIcon(buffer, 0, dataSize);
 563             if (DEBUG) {
 564                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 565             }
 566             if (DEBUG_PAYLOAD) {
 567                 Log.d(TAG, &quot;read &quot; +
 568                     Base64.encodeToString(res.data, 0, res.data.length,
 569                             Base64.NO_WRAP));
 570             }
 571             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 572             if (icon == null) {
 573                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 574             }
 575 
 576             if (!mRestoreEnabled) {
 577                 if (VERBOSE) {
 578                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 579                 }
 580                 return;
 581             } else {
 582                 if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 583                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 584                         icon, res.dpi);
 585             }
 586         } catch (IOException e) {
 587             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 588         }
 589     }
 590 
 591     /**
 592      * Write all the static widget resources we need to render placeholders
 593      * for a package that is not installed.
 594      *
 595      * @param in notes from last backup
 596      * @param data output stream for key/value pairs
 597      * @param out notes about this backup
 598      * @param keys keys to mark as clean in the notes for next backup
 599      * @throws IOException
 600      */
 601     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 602             ArrayList&lt;Key&gt; keys) throws IOException {
 603         // persist static widget info that hasn&#x27;t been persisted yet
 604         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 605         if (appState == null || !initializeIconCache()) {
 606             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 607             return;
 608         }
 609         final ContentResolver cr = mContext.getContentResolver();
 610         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 611         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 612         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 613         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 614         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 615 
 616         // read the old ID set
 617         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 618         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 619 
 620         int startRows = out.rows;
 621         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 622         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 623                 + getUserSelectionArg();
 624         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 625                 where, null, null);
 626         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 627         try {
 628             cursor.moveToPosition(-1);
 629             while(cursor.moveToNext()) {
 630                 final long id = cursor.getLong(ID_INDEX);
 631                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 632                 final int spanX = cursor.getInt(SPANX_INDEX);
 633                 final int spanY = cursor.getInt(SPANY_INDEX);
 634                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 635                 Key key = null;
 636                 String backupKey = null;
 637                 if (provider != null) {
 638                     key = getKey(Key.WIDGET, providerName);
 639                     backupKey = keyToBackupKey(key);
 640                     currentIds.add(backupKey);
 641                 } else {
 642                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 643                 }
 644                 if (savedIds.contains(backupKey)) {
 645                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 646 
 647                     // remember that we already backed this up previously
 648                     keys.add(key);
 649                 } else if (backupKey != null) {
 650                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 651                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 652                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 653                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 654                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 655                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 656                         keys.add(key);
 657                         writeRowToBackup(key, blob, out, data);
 658 
 659                     } else {
 660                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 661                         // too many widgets for this pass, request another.
 662                         dataChanged();
 663                     }
 664                 }
 665             }
 666         } finally {
 667             cursor.close();
 668         }
 669         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 670 
 671         // these IDs must have been deleted
 672         savedIds.removeAll(currentIds);
 673         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 674     }
 675 
 676     /**
 677      * Read a widget from the stream.
 678      *
 679      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 680      *
 681      * @param key identifier for the row
 682      * @param buffer the serialized proto from the stream, may be larger than dataSize
 683      * @param dataSize the size of the proto from the stream
 684      * @param keys keys to mark as clean in the notes for next backup
 685      */
 686     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 687         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 688         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 689                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 690         try {
 691             Widget widget = unpackWidget(buffer, 0, dataSize);
 692             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 693             if (widget.icon.data != null)  {
 694                 Bitmap icon = BitmapFactory
 695                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 696                 if (icon == null) {
 697                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 698                 } else {
 699                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 700                             icon, widget.icon.dpi);
 701                 }
 702             }
 703 
 704             if (!mRestoreEnabled) {
 705                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 706                 return;
 707             } else {
 708                 // future site of widget table mutation
 709             }
 710         } catch (InvalidProtocolBufferNanoException e) {
 711             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 712         }
 713     }
 714 
 715     /** create a new key, with an integer ID.
 716      *
 717      * &lt;P&gt; Keys contain their own checksum instead of using
 718      * the heavy-weight CheckedMessage wrapper.
 719      */
 720     private Key getKey(int type, long id) {
 721         Key key = new Key();
 722         key.type = type;
 723         key.id = id;
 724         key.checksum = checkKey(key);
 725         return key;
 726     }
 727 
 728     /** create a new key for a named object.
 729      *
 730      * &lt;P&gt; Keys contain their own checksum instead of using
 731      * the heavy-weight CheckedMessage wrapper.
 732      */
 733     private Key getKey(int type, String name) {
 734         Key key = new Key();
 735         key.type = type;
 736         key.name = name;
 737         key.checksum = checkKey(key);
 738         return key;
 739     }
 740 
 741     /** keys need to be strings, serialize and encode. */
 742     private String keyToBackupKey(Key key) {
 743         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 744     }
 745 
 746     /** keys need to be strings, decode and parse. */
 747     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 748         try {
 749             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 750             if (key.checksum != checkKey(key)) {
 751                 key = null;
 752                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 753             }
 754             return key;
 755         } catch (InvalidProtocolBufferNanoException e) {
 756             throw new KeyParsingException(e);
 757         } catch (IllegalArgumentException e) {
 758             throw new KeyParsingException(e);
 759         }
 760     }
 761 
 762     private String getKeyName(Key key) {
 763         if (TextUtils.isEmpty(key.name)) {
 764             return Long.toString(key.id);
 765         } else {
 766             return key.name;
 767         }
 768 
 769     }
 770 
 771     private String geKeyType(Key key) {
 772         switch (key.type) {
 773             case Key.FAVORITE:
 774                 return &quot;favorite&quot;;
 775             case Key.SCREEN:
 776                 return &quot;screen&quot;;
 777             case Key.ICON:
 778                 return &quot;icon&quot;;
 779             case Key.WIDGET:
 780                 return &quot;widget&quot;;
 781             default:
 782                 return &quot;anonymous&quot;;
 783         }
 784     }
 785 
 786     /** Compute the checksum over the important bits of a key. */
 787     private long checkKey(Key key) {
 788         CRC32 checksum = new CRC32();
 789         checksum.update(key.type);
 790         checksum.update((int) (key.id &amp; 0xffff));
 791         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 792         if (!TextUtils.isEmpty(key.name)) {
 793             checksum.update(key.name.getBytes());
 794         }
 795         return checksum.getValue();
 796     }
 797 
 798     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 799     private byte[] packFavorite(Cursor c) {
 800         Favorite favorite = new Favorite();
 801         favorite.id = c.getLong(ID_INDEX);
 802         favorite.screen = c.getInt(SCREEN_INDEX);
 803         favorite.container = c.getInt(CONTAINER_INDEX);
 804         favorite.cellX = c.getInt(CELLX_INDEX);
 805         favorite.cellY = c.getInt(CELLY_INDEX);
 806         favorite.spanX = c.getInt(SPANX_INDEX);
 807         favorite.spanY = c.getInt(SPANY_INDEX);
 808         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 809         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 810             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 811             if (!TextUtils.isEmpty(iconPackage)) {
 812                 favorite.iconPackage = iconPackage;
 813             }
 814             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 815             if (!TextUtils.isEmpty(iconResource)) {
 816                 favorite.iconResource = iconResource;
 817             }
 818         }
 819         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 820             byte[] blob = c.getBlob(ICON_INDEX);
 821             if (blob != null &amp;&amp; blob.length &gt; 0) {
 822                 favorite.icon = blob;
 823             }
 824         }
 825         String title = c.getString(TITLE_INDEX);
 826         if (!TextUtils.isEmpty(title)) {
 827             favorite.title = title;
 828         }
 829         String intentDescription = c.getString(INTENT_INDEX);
 830         if (!TextUtils.isEmpty(intentDescription)) {
 831             try {
 832                 Intent intent = Intent.parseUri(intentDescription, 0);
 833                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 834                 favorite.intent = intent.toUri(0);
 835             } catch (URISyntaxException e) {
 836                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 837            }
 838         }
 839         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 840         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 841             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 842             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 843             if (!TextUtils.isEmpty(appWidgetProvider)) {
 844                 favorite.appWidgetProvider = appWidgetProvider;
 845             }
 846         }
 847 
 848         return writeCheckedBytes(favorite);
 849     }
 850 
 851     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 852     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 853             throws InvalidProtocolBufferNanoException {
 854         Favorite favorite = new Favorite();
 855         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 856         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 857                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 858         ContentValues values = new ContentValues();
 859         values.put(Favorites._ID, favorite.id);
 860         values.put(Favorites.SCREEN, favorite.screen);
 861         values.put(Favorites.CONTAINER, favorite.container);
 862         values.put(Favorites.CELLX, favorite.cellX);
 863         values.put(Favorites.CELLY, favorite.cellY);
 864         values.put(Favorites.SPANX, favorite.spanX);
 865         values.put(Favorites.SPANY, favorite.spanY);
 866         values.put(Favorites.ICON_TYPE, favorite.iconType);
 867         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 868             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 869             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 870         }
 871         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 872             values.put(Favorites.ICON, favorite.icon);
 873         }
 874         if (!TextUtils.isEmpty(favorite.title)) {
 875             values.put(Favorites.TITLE, favorite.title);
 876         } else {
 877             values.put(Favorites.TITLE, &quot;&quot;);
 878         }
 879         if (!TextUtils.isEmpty(favorite.intent)) {
 880             values.put(Favorites.INTENT, favorite.intent);
 881         }
 882         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 883 
 884         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 885         long userSerialNumber =
 886                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 887         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 888 
 889         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 890             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 891                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 892             }
 893             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 894             values.put(LauncherSettings.Favorites.RESTORED,
 895                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 896                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 897                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 898         } else {
 899             // Let LauncherModel know we&#x27;ve been here.
 900             values.put(LauncherSettings.Favorites.RESTORED, 1);
 901         }
 902 
 903         return values;
 904     }
 905 
 906     /** Serialize a Screen for persistence, including a checksum wrapper. */
 907     private byte[] packScreen(Cursor c) {
 908         Screen screen = new Screen();
 909         screen.id = c.getLong(ID_INDEX);
 910         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 911 
 912         return writeCheckedBytes(screen);
 913     }
 914 
 915     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 916     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 917             throws InvalidProtocolBufferNanoException {
 918         Screen screen = new Screen();
 919         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 920         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 921         ContentValues values = new ContentValues();
 922         values.put(WorkspaceScreens._ID, screen.id);
 923         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 924         return values;
 925     }
 926 
 927     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 928     private byte[] packIcon(int dpi, Bitmap icon) {
 929         Resource res = new Resource();
 930         res.dpi = dpi;
 931         ByteArrayOutputStream os = new ByteArrayOutputStream();
 932         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 933             res.data = os.toByteArray();
 934         }
 935         return writeCheckedBytes(res);
 936     }
 937 
 938     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 939     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 940             throws InvalidProtocolBufferNanoException {
 941         Resource res = new Resource();
 942         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 943         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 944         return res;
 945     }
 946 
 947     /** Serialize a widget for persistence, including a checksum wrapper. */
 948     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 949             ComponentName provider) {
 950         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 951         Widget widget = new Widget();
 952         widget.provider = provider.flattenToShortString();
 953         widget.label = info.label;
 954         widget.configure = info.configure != null;
 955         if (info.icon != 0) {
 956             widget.icon = new Resource();
 957             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 958             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 959             ByteArrayOutputStream os = new ByteArrayOutputStream();
 960             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 961                 widget.icon.data = os.toByteArray();
 962                 widget.icon.dpi = dpi;
 963             }
 964         }
 965         if (info.previewImage != 0) {
 966             widget.preview = new Resource();
 967             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 968             ByteArrayOutputStream os = new ByteArrayOutputStream();
 969             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 970                 widget.preview.data = os.toByteArray();
 971                 widget.preview.dpi = dpi;
 972             }
 973         }
 974         return writeCheckedBytes(widget);
 975     }
 976 
 977     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 978     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 979             throws InvalidProtocolBufferNanoException {
 980         Widget widget = new Widget();
 981         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 982         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 983         return widget;
 984     }
 985 
 986     /**
 987      * Read the old journal from the input file.
 988      *
 989      * In the event of any error, just pretend we didn&#x27;t have a journal,
 990      * in that case, do a full backup.
 991      *
 992      * @param oldState the read-0only file descriptor pointing to the old journal
 993      * @return a Journal protocol buffer
 994      */
 995     private Journal readJournal(ParcelFileDescriptor oldState) {
 996         Journal journal = new Journal();
 997         if (oldState == null) {
 998             return journal;
 999         }
1000         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1001         try {
1002             int availableBytes = inStream.available();
1003             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1004             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1005                 byte[] buffer = new byte[availableBytes];
1006                 int bytesRead = 0;
1007                 boolean valid = false;
1008                 InvalidProtocolBufferNanoException lastProtoException = null;
1009                 while (availableBytes &gt; 0) {
1010                     try {
1011                         // OMG what are you doing? This is crazy inefficient!
1012                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1013                         // However, we don&#x27;t know how many bytes to expect (oops).
1014                         // So we have to step through *slowly*, watching for the end.
1015                         int result = inStream.read(buffer, bytesRead, 1);
1016                         if (result &gt; 0) {
1017                             availableBytes -= result;
1018                             bytesRead += result;
1019                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1020                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1021                             }
1022                         } else {
1023                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1024                             // stop reading and see what there is to parse
1025                             availableBytes = 0;
1026                         }
1027                     } catch (IOException e) {
1028                         buffer = null;
1029                         availableBytes = 0;
1030                     }
1031 
1032                     // check the buffer to see if we have a valid journal
1033                     try {
1034                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1035                         // if we are here, then we have read a valid, checksum-verified journal
1036                         valid = true;
1037                         availableBytes = 0;
1038                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1039                     } catch (InvalidProtocolBufferNanoException e) {
1040                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1041                         lastProtoException = e;
1042                         journal.clear();
1043                     }
1044                 }
1045                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1046                 if (!valid) {
1047                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1048                 }
1049             }
1050         } catch (IOException e) {
1051             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1052         } finally {
1053             try {
1054                 inStream.close();
1055             } catch (IOException e) {
1056                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1057             }
1058         }
1059         return journal;
1060     }
1061 
1062     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1063             BackupDataOutput data) throws IOException {
1064         String backupKey = keyToBackupKey(key);
1065         data.writeEntityHeader(backupKey, blob.length);
1066         data.writeEntityData(blob, blob.length);
1067         out.rows++;
1068         out.bytes += blob.length;
1069         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1070                 getKeyName(key) + &quot;/&quot; + blob.length);
1071         if(DEBUG_PAYLOAD) {
1072             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1073             final int chunkSize = 1024;
1074             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1075                 int end = offset + chunkSize;
1076                 end = Math.min(end, encoded.length());
1077                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1078             }
1079         }
1080     }
1081 
1082     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1083         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1084         for(int i = 0; i &lt; in.key.length; i++) {
1085             Key key = in.key[i];
1086             if (key.type == type) {
1087                 savedIds.add(keyToBackupKey(key));
1088             }
1089         }
1090         return savedIds;
1091     }
1092 
1093     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1094             throws IOException {
1095         int rows = 0;
1096         for(String deleted: deletedIds) {
1097             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1098             data.writeEntityHeader(deleted, -1);
1099             rows++;
1100         }
1101         return rows;
1102     }
1103 
1104     /**
1105      * Write the new journal to the output file.
1106      *
1107      * In the event of any error, just pretend we didn&#x27;t have a journal,
1108      * in that case, do a full backup.
1109 
1110      * @param newState the write-only file descriptor pointing to the new journal
1111      * @param journal a Journal protocol buffer
1112      */
1113     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1114         FileOutputStream outStream = null;
1115         try {
1116             outStream = new FileOutputStream(newState.getFileDescriptor());
1117             final byte[] journalBytes = writeCheckedBytes(journal);
1118             outStream.write(journalBytes);
1119             outStream.close();
1120             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1121         } catch (IOException e) {
1122             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1123         }
1124     }
1125 
1126     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1127     private byte[] writeCheckedBytes(MessageNano proto) {
1128         CheckedMessage wrapper = new CheckedMessage();
1129         wrapper.payload = MessageNano.toByteArray(proto);
1130         CRC32 checksum = new CRC32();
1131         checksum.update(wrapper.payload);
1132         wrapper.checksum = checksum.getValue();
1133         return MessageNano.toByteArray(wrapper);
1134     }
1135 
1136     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1137     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1138             throws InvalidProtocolBufferNanoException {
1139         CheckedMessage wrapper = new CheckedMessage();
1140         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1141         CRC32 checksum = new CRC32();
1142         checksum.update(wrapper.payload);
1143         if (wrapper.checksum != checksum.getValue()) {
1144             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1145         }
1146         return wrapper.payload;
1147     }
1148 
1149     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1150         if (mWidgetMap == null) {
1151             List&lt;AppWidgetProviderInfo&gt; widgets =
1152                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1153             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1154             for (AppWidgetProviderInfo info : widgets) {
1155                 mWidgetMap.put(info.provider, info);
1156             }
1157         }
1158         return mWidgetMap.get(component);
1159     }
1160 
1161 
1162     private boolean initializeIconCache() {
1163         if (mIconCache != null) {
1164             return true;
1165         }
1166 
1167         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1168         if (appState == null) {
1169             Throwable stackTrace = new Throwable();
1170             stackTrace.fillInStackTrace();
1171             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1172             return false;
1173         }
1174         mIconCache = appState.getIconCache();
1175         return mIconCache != null;
1176     }
1177 
1178 
1179    // check if the launcher is in a state to support backup
1180     private boolean launcherIsReady() {
1181         ContentResolver cr = mContext.getContentResolver();
1182         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1183         if (cursor == null) {
1184             // launcher data has been wiped, do nothing
1185             return false;
1186         }
1187         cursor.close();
1188 
1189         if (!initializeIconCache()) {
1190             // launcher services are unavailable, try again later
1191             dataChanged();
1192             return false;
1193         }
1194 
1195         return true;
1196     }
1197 
1198     private String getUserSelectionArg() {
1199         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1200                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1201     }
1202 
1203     private class KeyParsingException extends Throwable {
1204         private KeyParsingException(Throwable cause) {
1205             super(cause);
1206         }
1207 
1208         public KeyParsingException(String reason) {
1209             super(reason);
1210         }
1211     }
1212 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.database.Cursor;
  30 import android.graphics.Bitmap;
  31 import android.graphics.BitmapFactory;
  32 import android.graphics.drawable.Drawable;
  33 import android.os.ParcelFileDescriptor;
  34 import android.text.TextUtils;
  35 import android.util.Base64;
  36 import android.util.Log;
  37 import com.android.launcher3.LauncherSettings.Favorites;
  38 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  39 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  40 import com.android.launcher3.backup.BackupProtos.Favorite;
  41 import com.android.launcher3.backup.BackupProtos.Journal;
  42 import com.android.launcher3.backup.BackupProtos.Key;
  43 import com.android.launcher3.backup.BackupProtos.Resource;
  44 import com.android.launcher3.backup.BackupProtos.Screen;
  45 import com.android.launcher3.backup.BackupProtos.Widget;
  46 import com.android.launcher3.backup.BackupProtos;
  47 import com.android.launcher3.compat.UserHandleCompat;
  48 import com.android.launcher3.compat.UserManagerCompat;
  49 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  50 import com.google.protobuf.nano.MessageNano;
  51 import java.io.ByteArrayOutputStream;
  52 import java.io.FileInputStream;
  53 import java.io.FileOutputStream;
  54 import java.io.IOException;
  55 import java.net.URISyntaxException;
  56 import java.util.ArrayList;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.List;
  60 import java.util.Set;
  61 import java.util.zip.CRC32;
  62 
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  69 
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71 
  72     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  73 
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /**
  79      * icons are large, dribble them out
  80      */
  81     private static final int MAX_ICONS_PER_PASS = 10;
  82 
  83     /**
  84      * widgets contain previews, which are very large, dribble them out
  85      */
  86     private static final int MAX_WIDGETS_PER_PASS = 5;
  87 
  88     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  89 
  90     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  91 
  92     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  93 
  94     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  95             android.graphics.Bitmap.CompressFormat.PNG;
  96 
  97     private static BackupManager sBackupManager;
  98 
  99     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
 100     Favorites.MODIFIED, // 1
 101     Favorites.INTENT, // 2
 102     Favorites.APPWIDGET_PROVIDER// 3
 103     , Favorites.APPWIDGET_ID// 4
 104     , Favorites.CELLX, // 5
 105     Favorites.CELLY, // 6
 106     Favorites.CONTAINER, // 7
 107     Favorites.ICON, // 8
 108     Favorites.ICON_PACKAGE// 9
 109     , Favorites.ICON_RESOURCE// 10
 110     , Favorites.ICON_TYPE, // 11
 111     Favorites.ITEM_TYPE, // 12
 112     Favorites.SCREEN, // 13
 113     Favorites.SPANX, // 14
 114     Favorites.SPANY, // 15
 115     Favorites.TITLE, // 16
 116             // 17
 117     Favorites.PROFILE_ID };
 118 
 119     private static final int ID_INDEX = 0;
 120 
 121     private static final int ID_MODIFIED = 1;
 122 
 123     private static final int INTENT_INDEX = 2;
 124 
 125     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 126 
 127     private static final int APPWIDGET_ID_INDEX = 4;
 128 
 129     private static final int CELLX_INDEX = 5;
 130 
 131     private static final int CELLY_INDEX = 6;
 132 
 133     private static final int CONTAINER_INDEX = 7;
 134 
 135     private static final int ICON_INDEX = 8;
 136 
 137     private static final int ICON_PACKAGE_INDEX = 9;
 138 
 139     private static final int ICON_RESOURCE_INDEX = 10;
 140 
 141     private static final int ICON_TYPE_INDEX = 11;
 142 
 143     private static final int ITEM_TYPE_INDEX = 12;
 144 
 145     private static final int SCREEN_INDEX = 13;
 146 
 147     private static final int SPANX_INDEX = 14;
 148 
 149     private static final int SPANY_INDEX = 15;
 150 
 151     private static final int TITLE_INDEX = 16;
 152 
 153     private static final int PROFILE_ID_INDEX = 17;
 154 
 155     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 156     WorkspaceScreens.MODIFIED// 1
 157     , WorkspaceScreens.SCREEN_RANK// 2
 158      };
 159 
 160     private static final int SCREEN_RANK_INDEX = 2;
 161 
 162     private static IconCache mIconCache;
 163 
 164     private final Context mContext;
 165 
 166     private final boolean mRestoreEnabled;
 167 
 168     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 169 
 170     private final ArrayList&lt;Key&gt; mKeys;
 171 
 172     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 173         mContext = context;
 174         mRestoreEnabled = restoreEnabled;
 175         mKeys = new ArrayList&lt;Key&gt;();
 176     }
 177 
 178     private void dataChanged() {
 179         if (sBackupManager == null) {
 180             sBackupManager = new BackupManager(mContext);
 181         }
 182         sBackupManager.dataChanged();
 183     }
 184 
 185     /**
 186      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 187      *
 188      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 189      *
 190      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 191      *
 192      * @param oldState notes from the last backup
 193      * @param data incremental key/value pairs to persist off-device
 194      * @param newState notes for the next backup
 195      * @throws IOException
 196      */
 197     @Override
<abbr title=" 198     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 198     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor </abbr>
 199         if (VERBOSE) {
 200             Log.v(TAG, &quot;onBackup&quot;);
 201         }
 202         Journal in = readJournal(oldState);
 203         Journal out = new Journal();
 204         long lastBackupTime = in.t;
 205         out.t = System.currentTimeMillis();
 206         out.rows = 0;
 207         out.bytes = 0;
 208         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 209         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 210         if (launcherIsReady()) {
 211             try {
 212                 backupFavorites(in, data, out, keys);
 213                 backupScreens(in, data, out, keys);
 214                 backupIcons(in, data, out, keys);
 215                 backupWidgets(in, data, out, keys);
 216             } catch (IOException e) {
 217                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 218             }
 219             out.key = keys.toArray(
 220 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 221 new BackupProtos.Key[keys.size()]</span>
 222 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 223 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 223 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 224 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 225 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 226 BackupProtos.Key.emptyArray()</span>
 227 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 228             );
 229         } else {
 230             out = in;
 231         }
 232         writeJournal(newState, out);
 233         Log.v(TAG, (((&quot;onBackup: wrote &quot; + out.bytes) + &quot;b in &quot;) + out.rows) + &quot; rows.&quot;);
 234     }
 235 
 236     /**
 237      * Restore launcher configuration from the restored data stream.
 238      *
 239      * &lt;P&gt;Keys may arrive in any order.
 240      *
 241      * @param data the key/value pair from the server
 242      */
 243     @Override
 244     public void restoreEntity(BackupDataInputStream data) {
 245         if (VERBOSE) {
 246             Log.v(TAG, &quot;restoreEntity&quot;);
 247         }
 248         byte[] buffer = new byte[512];
 249         String backupKey = data.getKey();
 250         int dataSize = data.size();
 251         if (buffer.length &lt; dataSize) {
 252             buffer = new byte[dataSize];
 253         }
 254         Key key = null;
 255         int bytesRead = 0;
 256         try {
 257             bytesRead = data.read(buffer, 0, dataSize);
 258             if (DEBUG) {
 259                 Log.d(TAG, (((&quot;read &quot; + bytesRead) + &quot; of &quot;) + dataSize) + &quot; available&quot;);
 260             }
 261         } catch (IOException e) {
 262             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 263         }
 264         try {
 265             key = backupKeyToKey(backupKey);
 266             mKeys.add(key);
 267             switch (key.type) {
 268                 case Key.FAVORITE :
 269                     restoreFavorite(key, buffer, dataSize, mKeys);
 270                     break;
 271                 case Key.SCREEN :
 272                     restoreScreen(key, buffer, dataSize, mKeys);
 273                     break;
 274                 case Key.ICON :
 275                     restoreIcon(key, buffer, dataSize, mKeys);
 276                     break;
 277                 case Key.WIDGET :
 278                     restoreWidget(key, buffer, dataSize, mKeys);
 279                     break;
 280                 default :
 281                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 282                     break;
 283             }
 284         } catch (LauncherBackupHelper.KeyParsingException e) {
 285             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 286         }
 287     }
 288 
 289     /**
 290      * Record the restore state for the next backup.
 291      *
 292      * @param newState notes about the backup state after restore.
 293      */
 294     @Override
 295     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 296         // clear the output journal time, to force a full backup to
 297         // will catch any changes the restore process might have made
 298         Journal out = new Journal();
 299         out.t = 0;
 300         out.key = mKeys.toArray(
 301 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 302 new BackupProtos.Key[mKeys.size()]</span>
 303 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 304 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 304 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw</abbr></span>
 305 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 306 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 307 BackupProtos.Key.emptyArray()</span>
 308 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 309         );
 310         writeJournal(newState, out);
 311         Log.v(TAG, (&quot;onRestore: read &quot; + mKeys.size()) + &quot; rows&quot;);
 312         mKeys.clear();
 313     }
 314 
 315     /**
 316      * Write all modified favorites to the data stream.
 317      *
 318      *
 319      * @param in notes from last backup
 320      * @param data output stream for key/value pairs
 321      * @param out notes about this backup
 322      * @param keys keys to mark as clean in the notes for next backup
 323      * @throws IOException
 324      */
<abbr title=" 325     private void backupFavorites(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 325     private void backupFavorites(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) thr</abbr>
 326         // read the old ID set
 327         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 328         if (DEBUG) {
 329             Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 330         }
 331         // persist things that have changed since the last backup
 332         ContentResolver cr = mContext.getContentResolver();
 333         // Don&#x27;t backup apps in other profiles for now.
<abbr title=" 334         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null, null);"> 334         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null,</abbr>
 335         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 336         try {
 337             cursor.moveToPosition(-1);
 338             while (cursor.moveToNext()) {
 339                 final long id = cursor.getLong(ID_INDEX);
 340                 final long updateTime = cursor.getLong(ID_MODIFIED);
 341                 Key key = getKey(Key.FAVORITE, id);
 342                 keys.add(key);
 343                 final String backupKey = keyToBackupKey(key);
 344                 currentIds.add(backupKey);
 345                 if ((!savedIds.contains(backupKey)) || (updateTime &gt;= in.t)) {
 346                     byte[] blob = packFavorite(cursor);
 347                     writeRowToBackup(key, blob, out, data);
 348                 } else if (VERBOSE) {
 349                     Log.v(TAG, ((&quot;favorite &quot; + id) + &quot; was too old: &quot;) + updateTime);
 350                 }
 351             }
 352         } finally {
 353             cursor.close();
 354         }
 355         if (DEBUG) {
 356             Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 357         }
 358         // these IDs must have been deleted
 359         savedIds.removeAll(currentIds);
 360         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 361     }
 362 
 363     /**
 364      * Read a favorite from the stream.
 365      *
 366      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 367      *
 368      * @param key identifier for the row
 369      * @param buffer the serialized proto from the stream, may be larger than dataSize
 370      * @param dataSize the size of the proto from the stream
 371      * @param keys keys to mark as clean in the notes for next backup
 372      */
 373     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 374         if (VERBOSE) {
 375             Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 376         }
 377         if (DEBUG) {
<abbr title=" 378             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 378             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 379         }
 380         if (!mRestoreEnabled) {
 381             if (VERBOSE) {
 382                 Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 383             }
 384             return;
 385         }
 386         try {
 387             ContentResolver cr = mContext.getContentResolver();
 388             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 389             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 390         } catch (InvalidProtocolBufferNanoException e) {
 391             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 392         }
 393     }
 394 
 395     /**
 396      * Write all modified screens to the data stream.
 397      *
 398      *
 399      * @param in notes from last backup
 400      * @param data output stream for key/value pairs
 401      * @param out notes about this backup
 402      * @param keys keys to mark as clean in the notes for next backup
 403      * @throws IOException
 404      */
<abbr title=" 405     private void backupScreens(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 405     private void backupScreens(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throw</abbr>
 406         // read the old ID set
 407         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 408         if (DEBUG) {
 409             Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 410         }
 411         // persist things that have changed since the last backup
 412         ContentResolver cr = mContext.getContentResolver();
 413         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION, null, null, null);
 414         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 415         try {
 416             cursor.moveToPosition(-1);
 417             if (DEBUG) {
 418                 Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 419             }
 420             while (cursor.moveToNext()) {
 421                 final long id = cursor.getLong(ID_INDEX);
 422                 final long updateTime = cursor.getLong(ID_MODIFIED);
 423                 Key key = getKey(Key.SCREEN, id);
 424                 keys.add(key);
 425                 final String backupKey = keyToBackupKey(key);
 426                 currentIds.add(backupKey);
 427                 if ((!savedIds.contains(backupKey)) || (updateTime &gt;= in.t)) {
 428                     byte[] blob = packScreen(cursor);
 429                     writeRowToBackup(key, blob, out, data);
 430                 } else if (VERBOSE) {
 431                     Log.v(TAG, ((&quot;screen &quot; + id) + &quot; was too old: &quot;) + updateTime);
 432                 }
 433             }
 434         } finally {
 435             cursor.close();
 436         }
 437         if (DEBUG) {
 438             Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 439         }
 440         // these IDs must have been deleted
 441         savedIds.removeAll(currentIds);
 442         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 443     }
 444 
 445     /**
 446      * Read a screen from the stream.
 447      *
 448      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 449      *
 450      * @param key identifier for the row
 451      * @param buffer the serialized proto from the stream, may be larger than dataSize
 452      * @param dataSize the size of the proto from the stream
 453      * @param keys keys to mark as clean in the notes for next backup
 454      */
 455     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 456         if (VERBOSE) {
 457             Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 458         }
 459         if (DEBUG) {
<abbr title=" 460             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 460             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 461         }
 462         if (!mRestoreEnabled) {
 463             if (VERBOSE) {
 464                 Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 465             }
 466             return;
 467         }
 468         try {
 469             ContentResolver cr = mContext.getContentResolver();
 470             ContentValues values = unpackScreen(buffer, 0, dataSize);
 471             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 472         } catch (InvalidProtocolBufferNanoException e) {
 473             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 474         }
 475     }
 476 
 477     /**
 478      * Write all the static icon resources we need to render placeholders
 479      * for a package that is not installed.
 480      *
 481      * @param in notes from last backup
 482      * @param data output stream for key/value pairs
 483      * @param out notes about this backup
 484      * @param keys keys to mark as clean in the notes for next backup
 485      * @throws IOException
 486      */
<abbr title=" 487     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 487     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws </abbr>
 488         // persist icons that haven&#x27;t been persisted yet
 489         if (!initializeIconCache()) {
 490             dataChanged();// try again later
 491 
 492             if (DEBUG) {
 493                 Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 494             }
 495             return;
 496         }
 497         final ContentResolver cr = mContext.getContentResolver();
 498         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 499         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 500         // read the old ID set
 501         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 502         if (DEBUG) {
 503             Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 504         }
 505         // Don&#x27;t backup apps in other profiles for now.
 506         int startRows = out.rows;
 507         if (DEBUG) {
 508             Log.d(TAG, &quot;starting here: &quot; + startRows);
 509         }
<abbr title=" 510         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; OR &quot;) + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_SHORTCUT) + &quot;) AND &quot;) + getUserSelectionArg();"> 510         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; O</abbr>
 511         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 512         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 513         try {
 514             cursor.moveToPosition(-1);
 515             while (cursor.moveToNext()) {
 516                 final long id = cursor.getLong(ID_INDEX);
 517                 final String intentDescription = cursor.getString(INTENT_INDEX);
 518                 try {
 519                     Intent intent = Intent.parseUri(intentDescription, 0);
 520                     ComponentName cn = intent.getComponent();
 521                     Key key = null;
 522                     String backupKey = null;
 523                     if (cn != null) {
 524                         key = getKey(Key.ICON, cn.flattenToShortString());
 525                         backupKey = keyToBackupKey(key);
 526                         currentIds.add(backupKey);
 527                     } else {
 528                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 529                     }
 530                     if (savedIds.contains(backupKey)) {
 531                         if (VERBOSE) {
 532                             Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 533                         }
 534                         // remember that we already backed this up previously
 535                         keys.add(key);
 536                     } else if (backupKey != null) {
 537                         if (DEBUG) {
 538                             Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 539                         }
 540                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 541                             if (VERBOSE) {
 542                                 Log.v(TAG, &quot;saving icon &quot; + backupKey);
 543                             }
 544                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 545                             keys.add(key);
 546                             if ((icon != null) &amp;&amp; (!mIconCache.isDefaultIcon(icon, myUserHandle))) {
 547                                 byte[] blob = packIcon(dpi, icon);
 548                                 writeRowToBackup(key, blob, out, data);
 549                             }
 550                         } else {
 551                             if (VERBOSE) {
 552                                 Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 553                             }
 554                             // too many icons for this pass, request another.
 555                             dataChanged();
 556                         }
 557                     }
 558                 } catch (URISyntaxException e) {
 559                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 560                 } catch (IOException e) {
 561                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 562                 }
 563             }
 564         } finally {
 565             cursor.close();
 566         }
 567         if (DEBUG) {
 568             Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 569         }
 570         // these IDs must have been deleted
 571         savedIds.removeAll(currentIds);
 572         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 573     }
 574 
 575     /**
 576      * Read an icon from the stream.
 577      *
 578      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 579      *
 580      * @param key identifier for the row
 581      * @param buffer the serialized proto from the stream, may be larger than dataSize
 582      * @param dataSize the size of the proto from the stream
 583      * @param keys keys to mark as clean in the notes for next backup
 584      */
 585     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 586         if (VERBOSE) {
 587             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 588         }
 589         if (DEBUG) {
<abbr title=" 590             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 590             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 591         }
 592         try {
 593             Resource res = unpackIcon(buffer, 0, dataSize);
 594             if (DEBUG) {
 595                 Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 596             }
 597             if (DEBUG_PAYLOAD) {
<abbr title=" 598                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP));"> 598                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP))</abbr>
 599             }
 600             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 601             if (icon == null) {
 602                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 603             }
 604             if (!mRestoreEnabled) {
 605                 if (VERBOSE) {
 606                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 607                 }
 608                 return;
 609             } else {
 610                 if (VERBOSE) {
 611                     Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 612                 }
<abbr title=" 613                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);"> 613                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dp</abbr>
 614             }
 615         } catch (IOException e) {
 616             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 617         }
 618     }
 619 
 620     /**
 621      * Write all the static widget resources we need to render placeholders
 622      * for a package that is not installed.
 623      *
 624      * @param in notes from last backup
 625      * @param data output stream for key/value pairs
 626      * @param out notes about this backup
 627      * @param keys keys to mark as clean in the notes for next backup
 628      * @throws IOException
 629      */
<abbr title=" 630     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 630     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throw</abbr>
 631         // persist static widget info that hasn&#x27;t been persisted yet
 632         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 633         if ((appState == null) || (!initializeIconCache())) {
 634             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 635             return;
 636         }
 637         final ContentResolver cr = mContext.getContentResolver();
 638         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 639         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 640         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 641         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 642         if (DEBUG) {
 643             Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 644         }
 645         // read the old ID set
 646         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 647         if (DEBUG) {
 648             Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 649         }
 650         int startRows = out.rows;
 651         if (DEBUG) {
 652             Log.d(TAG, &quot;starting here: &quot; + startRows);
 653         }
<abbr title=" 654         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUserSelectionArg();"> 654         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUse</abbr>
 655         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 656         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 657         try {
 658             cursor.moveToPosition(-1);
 659             while (cursor.moveToNext()) {
 660                 final long id = cursor.getLong(ID_INDEX);
 661                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 662                 final int spanX = cursor.getInt(SPANX_INDEX);
 663                 final int spanY = cursor.getInt(SPANY_INDEX);
 664                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 665                 Key key = null;
 666                 String backupKey = null;
 667                 if (provider != null) {
 668                     key = getKey(Key.WIDGET, providerName);
 669                     backupKey = keyToBackupKey(key);
 670                     currentIds.add(backupKey);
 671                 } else {
 672                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 673                 }
 674                 if (savedIds.contains(backupKey)) {
 675                     if (VERBOSE) {
 676                         Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 677                     }
 678                     // remember that we already backed this up previously
 679                     keys.add(key);
 680                 } else if (backupKey != null) {
 681                     if (DEBUG) {
 682                         Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 683                     }
 684                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 685                         if (VERBOSE) {
 686                             Log.v(TAG, &quot;saving widget &quot; + backupKey);
 687                         }
<abbr title=" 688                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeightPx, widgetSpacingLayout);"> 688                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHei</abbr>
 689                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 690                         keys.add(key);
 691                         writeRowToBackup(key, blob, out, data);
 692                     } else {
 693                         if (VERBOSE) {
 694                             Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 695                         }
 696                         // too many widgets for this pass, request another.
 697                         dataChanged();
 698                     }
 699                 }
 700             }
 701         } finally {
 702             cursor.close();
 703         }
 704         if (DEBUG) {
 705             Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 706         }
 707         // these IDs must have been deleted
 708         savedIds.removeAll(currentIds);
 709         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 710     }
 711 
 712     /**
 713      * Read a widget from the stream.
 714      *
 715      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 716      *
 717      * @param key identifier for the row
 718      * @param buffer the serialized proto from the stream, may be larger than dataSize
 719      * @param dataSize the size of the proto from the stream
 720      * @param keys keys to mark as clean in the notes for next backup
 721      */
 722     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 723         if (VERBOSE) {
 724             Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 725         }
 726         if (DEBUG) {
<abbr title=" 727             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 727             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, </abbr>
 728         }
 729         try {
 730             Widget widget = unpackWidget(buffer, 0, dataSize);
 731             if (DEBUG) {
 732                 Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 733             }
 734             if (widget.icon.data != null) {
<abbr title=" 735                 Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length);"> 735                 Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length)</abbr>
 736                 if (icon == null) {
 737                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 738                 } else {
<abbr title=" 739                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider), icon, widget.icon.dpi);"> 739                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider), i</abbr>
 740                 }
 741             }
 742             if (!mRestoreEnabled) {
 743                 if (VERBOSE) {
 744                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 745                 }
 746                 return;
 747             } else {
 748                 // future site of widget table mutation
 749             }
 750         } catch (InvalidProtocolBufferNanoException e) {
 751             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 752         }
 753     }
 754 
 755     /** create a new key, with an integer ID.
 756      *
 757      * &lt;P&gt; Keys contain their own checksum instead of using
 758      * the heavy-weight CheckedMessage wrapper.
 759      */
 760     private Key getKey(int type, long id) {
 761         Key key = new Key();
 762         key.type = type;
 763         key.id = id;
 764         key.checksum = checkKey(key);
 765         return key;
 766     }
 767 
 768     /** create a new key for a named object.
 769      *
 770      * &lt;P&gt; Keys contain their own checksum instead of using
 771      * the heavy-weight CheckedMessage wrapper.
 772      */
 773     private Key getKey(int type, String name) {
 774         Key key = new Key();
 775         key.type = type;
 776         key.name = name;
 777         key.checksum = checkKey(key);
 778         return key;
 779     }
 780 
 781     /** keys need to be strings, serialize and encode. */
 782     private String keyToBackupKey(Key key) {
 783         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 784     }
 785 
 786     /** keys need to be strings, decode and parse. */
 787     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 788         try {
 789             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 790             if (key.checksum != checkKey(key)) {
 791                 key = null;
 792                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 793             }
 794             return key;
 795         } catch (InvalidProtocolBufferNanoException e) {
 796             throw new KeyParsingException(e);
 797         } catch (IllegalArgumentException e) {
 798             throw new KeyParsingException(e);
 799         }
 800     }
 801 
 802     private String getKeyName(Key key) {
 803         if (TextUtils.isEmpty(key.name)) {
 804             return Long.toString(key.id);
 805         } else {
 806             return key.name;
 807         }
 808 
 809     }
 810 
 811     private String geKeyType(Key key) {
 812         switch (key.type) {
 813             case Key.FAVORITE:
 814                 return &quot;favorite&quot;;
 815             case Key.SCREEN:
 816                 return &quot;screen&quot;;
 817             case Key.ICON:
 818                 return &quot;icon&quot;;
 819             case Key.WIDGET:
 820                 return &quot;widget&quot;;
 821             default:
 822                 return &quot;anonymous&quot;;
 823         }
 824     }
 825 
 826     /** Compute the checksum over the important bits of a key. */
 827     private long checkKey(Key key) {
 828         CRC32 checksum = new CRC32();
 829         checksum.update(key.type);
 830         checksum.update((int) (key.id &amp; 0xffff));
 831         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 832         if (!TextUtils.isEmpty(key.name)) {
 833             checksum.update(key.name.getBytes());
 834         }
 835         return checksum.getValue();
 836     }
 837 
 838     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 839     private byte[] packFavorite(Cursor c) {
 840         Favorite favorite = new Favorite();
 841         favorite.id = c.getLong(ID_INDEX);
 842         favorite.screen = c.getInt(SCREEN_INDEX);
 843         favorite.container = c.getInt(CONTAINER_INDEX);
 844         favorite.cellX = c.getInt(CELLX_INDEX);
 845         favorite.cellY = c.getInt(CELLY_INDEX);
 846         favorite.spanX = c.getInt(SPANX_INDEX);
 847         favorite.spanY = c.getInt(SPANY_INDEX);
 848         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 849         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 850             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 851             if (!TextUtils.isEmpty(iconPackage)) {
 852                 favorite.iconPackage = iconPackage;
 853             }
 854             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 855             if (!TextUtils.isEmpty(iconResource)) {
 856                 favorite.iconResource = iconResource;
 857             }
 858         }
 859         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 860             byte[] blob = c.getBlob(ICON_INDEX);
 861             if ((blob != null) &amp;&amp; (blob.length &gt; 0)) {
 862                 favorite.icon = blob;
 863             }
 864         }
 865         String title = c.getString(TITLE_INDEX);
 866         if (!TextUtils.isEmpty(title)) {
 867             favorite.title = title;
 868         }
 869         String intentDescription = c.getString(INTENT_INDEX);
 870         if (!TextUtils.isEmpty(intentDescription)) {
 871             try {
 872                 Intent intent = Intent.parseUri(intentDescription, 0);
 873                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 874                 favorite.intent = intent.toUri(0);
 875             } catch (URISyntaxException e) {
 876                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 877             }
 878         }
 879         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 880         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 881             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 882             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 883             if (!TextUtils.isEmpty(appWidgetProvider)) {
 884                 favorite.appWidgetProvider = appWidgetProvider;
 885             }
 886         }
 887         return writeCheckedBytes(favorite);
 888     }
 889 
 890     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
<abbr title=" 891     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 891     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolB</abbr>
 892         Favorite favorite = new Favorite();
 893         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 894         if (VERBOSE) {
<abbr title=" 895             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));"> 895             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.</abbr>
 896         }
 897         ContentValues values = new ContentValues();
 898         values.put(Favorites._ID, favorite.id);
 899         values.put(Favorites.SCREEN, favorite.screen);
 900         values.put(Favorites.CONTAINER, favorite.container);
 901         values.put(Favorites.CELLX, favorite.cellX);
 902         values.put(Favorites.CELLY, favorite.cellY);
 903         values.put(Favorites.SPANX, favorite.spanX);
 904         values.put(Favorites.SPANY, favorite.spanY);
 905         values.put(Favorites.ICON_TYPE, favorite.iconType);
 906         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 907             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 908             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 909         }
 910         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 911             values.put(Favorites.ICON, favorite.icon);
 912         }
 913         if (!TextUtils.isEmpty(favorite.title)) {
 914             values.put(Favorites.TITLE, favorite.title);
 915         } else {
 916             values.put(Favorites.TITLE, &quot;&quot;);
 917         }
 918         if (!TextUtils.isEmpty(favorite.intent)) {
 919             values.put(Favorites.INTENT, favorite.intent);
 920         }
 921         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 922         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
<abbr title=" 923         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);"> 923         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHand</abbr>
 924         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 925         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 926             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 927                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 928             }
 929             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<abbr title=" 930             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) | LauncherAppWidgetInfo.FLAG_UI_NOT_READY);"> 930             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | La</abbr>
 931         } else {
 932             // Let LauncherModel know we&#x27;ve been here.
 933             values.put(LauncherSettings.Favorites.RESTORED, 1);
 934         }
 935         return values;
 936     }
 937 
 938     /** Serialize a Screen for persistence, including a checksum wrapper. */
 939     private byte[] packScreen(Cursor c) {
 940         Screen screen = new Screen();
 941         screen.id = c.getLong(ID_INDEX);
 942         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 943 
 944         return writeCheckedBytes(screen);
 945     }
 946 
 947     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
<abbr title=" 948     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 948     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf</abbr>
 949         Screen screen = new Screen();
 950         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 951         if (VERBOSE) {
 952             Log.v(TAG, ((&quot;unpacked screen &quot; + screen.id) + &quot;/&quot;) + screen.rank);
 953         }
 954         ContentValues values = new ContentValues();
 955         values.put(WorkspaceScreens._ID, screen.id);
 956         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 957         return values;
 958     }
 959 
 960     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 961     private byte[] packIcon(int dpi, Bitmap icon) {
 962         Resource res = new Resource();
 963         res.dpi = dpi;
 964         ByteArrayOutputStream os = new ByteArrayOutputStream();
 965         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 966             res.data = os.toByteArray();
 967         }
 968         return writeCheckedBytes(res);
 969     }
 970 
 971     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<abbr title=" 972     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 972     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf</abbr>
 973         Resource res = new Resource();
 974         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 975         if (VERBOSE) {
 976             Log.v(TAG, ((&quot;unpacked icon &quot; + res.dpi) + &quot;/&quot;) + res.data.length);
 977         }
 978         return res;
 979     }
 980 
 981     /** Serialize a widget for persistence, including a checksum wrapper. */
 982     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 983             ComponentName provider) {
 984         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 985         Widget widget = new Widget();
 986         widget.provider = provider.flattenToShortString();
 987         widget.label = info.label;
 988         widget.configure = info.configure != null;
 989         if (info.icon != 0) {
 990             widget.icon = new Resource();
 991             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 992             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 993             ByteArrayOutputStream os = new ByteArrayOutputStream();
 994             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 995                 widget.icon.data = os.toByteArray();
 996                 widget.icon.dpi = dpi;
 997             }
 998         }
 999         if (info.previewImage != 0) {
1000             widget.preview = new Resource();
1001             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1002             ByteArrayOutputStream os = new ByteArrayOutputStream();
1003             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1004                 widget.preview.data = os.toByteArray();
1005                 widget.preview.dpi = dpi;
1006             }
1007         }
1008         return writeCheckedBytes(widget);
1009     }
1010 
1011     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
<abbr title="1012     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {">1012     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNano</abbr>
1013         Widget widget = new Widget();
1014         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
1015         if (VERBOSE) {
1016             Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
1017         }
1018         return widget;
1019     }
1020 
1021     /**
1022      * Read the old journal from the input file.
1023      *
1024      * In the event of any error, just pretend we didn&#x27;t have a journal,
1025      * in that case, do a full backup.
1026      *
1027      * @param oldState the read-0only file descriptor pointing to the old journal
1028      * @return a Journal protocol bugffer
1029      */
1030     private Journal readJournal(ParcelFileDescriptor oldState) {
1031         Journal journal = new Journal();
1032         if (oldState == null) {
1033             return journal;
1034         }
1035         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1036         try {
1037             int availableBytes = inStream.available();
1038             if (DEBUG) {
1039                 Log.d(TAG, &quot;available &quot; + availableBytes);
1040             }
1041             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1042                 byte[] buffer = new byte[availableBytes];
1043                 int bytesRead = 0;
1044                 boolean valid = false;
1045                 InvalidProtocolBufferNanoException lastProtoException = null;
1046                 while (availableBytes &gt; 0) {
1047                     try {
1048                         // OMG what are you doing? This is crazy inefficient!
1049                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1050                         // However, we don&#x27;t know how many bytes to expect (oops).
1051                         // So we have to step through *slowly*, watching for the end.
1052                         int result = inStream.read(buffer, bytesRead, 1);
1053                         if (result &gt; 0) {
1054                             availableBytes -= result;
1055                             bytesRead += result;
1056                             if (DEBUG &amp;&amp; ((bytesRead % 100) == 0)) {
1057                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1058                             }
1059                         } else {
1060                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1061                             // stop reading and see what there is to parse
1062                             availableBytes = 0;
1063                         }
1064                     } catch (IOException e) {
1065                         buffer = null;
1066                         availableBytes = 0;
1067                     }
1068                     // check the buffer to see if we have a valid journal
1069                     try {
1070                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1071                         // if we are here, then we have read a valid, checksum-verified journal
1072                         valid = true;
1073                         availableBytes = 0;
1074                         if (VERBOSE) {
1075                             Log.v(TAG, (&quot;read &quot; + bytesRead) + &quot; bytes of journal&quot;);
1076                         }
1077                     } catch (InvalidProtocolBufferNanoException e) {
1078                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1079                         lastProtoException = e;
1080                         journal.clear();
1081                     }
1082                 }
1083                 if (DEBUG) {
1084                     Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1085                 }
1086                 if (!valid) {
1087                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1088                 }
1089             }
1090         } catch (IOException e) {
1091             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1092         } finally {
1093             try {
1094                 inStream.close();
1095             } catch (IOException e) {
1096                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1097             }
1098         }
1099         return journal;
1100     }
1101 
<abbr title="1102     private void writeRowToBackup(Key key, byte[] blob, Journal out, BackupDataOutput data) throws IOException {">1102     private void writeRowToBackup(Key key, byte[] blob, Journal out, BackupDataOutput data) throws IOExce</abbr>
1103         String backupKey = keyToBackupKey(key);
1104         data.writeEntityHeader(backupKey, blob.length);
1105         data.writeEntityData(blob, blob.length);
1106         out.rows++;
1107         out.bytes += blob.length;
1108         if (VERBOSE) {
<abbr title="1109             Log.v(TAG, ((((((&quot;saving &quot; + geKeyType(key)) + &quot; &quot;) + backupKey) + &quot;: &quot;) + getKeyName(key)) + &quot;/&quot;) + blob.length);">1109             Log.v(TAG, ((((((&quot;saving &quot; + geKeyType(key)) + &quot; &quot;) + backupKey) + &quot;: &quot;) + getKeyName(key)) +</abbr>
1110         }
1111         if (DEBUG_PAYLOAD) {
1112             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1113             final int chunkSize = 1024;
1114             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1115                 int end = offset + chunkSize;
1116                 end = Math.min(end, encoded.length());
1117                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1118             }
1119         }
1120     }
1121 
1122     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1123         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1124         for(int i = 0; i &lt; in.key.length; i++) {
1125             Key key = in.key[i];
1126             if (key.type == type) {
1127                 savedIds.add(keyToBackupKey(key));
1128             }
1129         }
1130         return savedIds;
1131     }
1132 
<abbr title="1133     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data) throws IOException {">1133     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data) throws IOExcep</abbr>
1134         int rows = 0;
1135         for (String deleted : deletedIds) {
1136             if (VERBOSE) {
1137                 Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1138             }
1139             data.writeEntityHeader(deleted, -1);
1140             rows++;
1141         }
1142         return rows;
1143     }
1144 
1145     /**
1146      * Write the new journal to the output file.
1147      *
1148      * In the event of any error, just pretend we didn&#x27;t have a journal,
1149      * in that case, do a full backup.
1150 
1151      * @param newState the write-only file descriptor pointing to the new journal
1152      * @param journal a Journal protocol buffer
1153      */
1154     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1155         FileOutputStream outStream = null;
1156         try {
1157             outStream = new FileOutputStream(newState.getFileDescriptor());
1158             final byte[] journalBytes = writeCheckedBytes(journal);
1159             outStream.write(journalBytes);
1160             outStream.close();
1161             if (VERBOSE) {
1162                 Log.v(TAG, (&quot;wrote &quot; + journalBytes.length) + &quot; bytes of journal&quot;);
1163             }
1164         } catch (IOException e) {
1165             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1166         }
1167     }
1168 
1169     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1170     private byte[] writeCheckedBytes(MessageNano proto) {
1171         CheckedMessage wrapper = new CheckedMessage();
1172         wrapper.payload = MessageNano.toByteArray(proto);
1173         CRC32 checksum = new CRC32();
1174         checksum.update(wrapper.payload);
1175         wrapper.checksum = checksum.getValue();
1176         return MessageNano.toByteArray(wrapper);
1177     }
1178 
1179     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<abbr title="1180     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {">1180     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtoco</abbr>
1181         CheckedMessage wrapper = new CheckedMessage();
1182         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1183         CRC32 checksum = new CRC32();
1184         checksum.update(wrapper.payload);
1185         if (wrapper.checksum != checksum.getValue()) {
1186             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1187         }
1188         return wrapper.payload;
1189     }
1190 
1191     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1192         if (mWidgetMap == null) {
1193             List&lt;AppWidgetProviderInfo&gt; widgets =
1194                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1195             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1196             for (AppWidgetProviderInfo info : widgets) {
1197                 mWidgetMap.put(info.provider, info);
1198             }
1199         }
1200         return mWidgetMap.get(component);
1201     }
1202 
1203     private boolean initializeIconCache() {
1204         if (mIconCache != null) {
1205             return true;
1206         }
1207         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1208         if (appState == null) {
1209             Throwable stackTrace = new Throwable();
1210             stackTrace.fillInStackTrace();
1211             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1212             return false;
1213         }
1214         mIconCache = appState.getIconCache();
1215         return mIconCache != null;
1216     }
1217 
1218 // check if the launcher is in a state to support backup
1219     private boolean launcherIsReady() {
1220         ContentResolver cr = mContext.getContentResolver();
1221         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1222         if (cursor == null) {
1223             // launcher data has been wiped, do nothing
1224             return false;
1225         }
1226         cursor.close();
1227         if (!initializeIconCache()) {
1228             // launcher services are unavailable, try again later
1229             dataChanged();
1230             return false;
1231         }
1232         return true;
1233     }
1234 
1235     private String getUserSelectionArg() {
1236         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1237                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1238     }
1239 
1240     private class KeyParsingException extends Throwable {
1241         private KeyParsingException(Throwable cause) {
1242             super(cause);
1243         }
1244 
1245         public KeyParsingException(String reason) {
1246             super(reason);
1247         }
1248     }
1249 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  16 -</span>
  17  package com.android.launcher3;
  18  
  19  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  20  import com.google.protobuf.nano.MessageNano;
  21  
  22  import com.android.launcher3.LauncherSettings.Favorites;
  23  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  24  import com.android.launcher3.backup.BackupProtos;
  25  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  26  import com.android.launcher3.backup.BackupProtos.Favorite;
  27  import com.android.launcher3.backup.BackupProtos.Journal;
  28  import com.android.launcher3.backup.BackupProtos.Key;
  29  import com.android.launcher3.backup.BackupProtos.Resource;
  30  import com.android.launcher3.backup.BackupProtos.Screen;
  31  import com.android.launcher3.backup.BackupProtos.Widget;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import com.android.launcher3.compat.UserManagerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import com.android.launcher3.compat.UserHandleCompat;</span>
  34  
  35  import android.app.backup.BackupDataInputStream;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import android.app.backup.BackupDataOutput;</span>
  37  import android.app.backup.BackupHelper;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  38 -import android.app.backup.BackupDataInput;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import android.app.backup.BackupDataOutput;</span>
  40  import android.app.backup.BackupManager;
  41  import android.appwidget.AppWidgetManager;
  42  import android.appwidget.AppWidgetProviderInfo;
  43  import android.content.ComponentName;
  44  import android.content.ContentResolver;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import android.content.ContentValues;</span>
  46  import android.content.Context;
  47  import android.content.Intent;
  48  import android.database.Cursor;
  49  import android.graphics.Bitmap;
  50  import android.graphics.BitmapFactory;
  51  import android.graphics.drawable.Drawable;
  52  import android.os.ParcelFileDescriptor;
  53  import android.text.TextUtils;
  54  import android.util.Base64;
  55  import android.util.Log;
  56  
  57  import java.io.ByteArrayOutputStream;
  58  import java.io.FileInputStream;
  59  import java.io.FileOutputStream;
  60  import java.io.IOException;
  61  import java.net.URISyntaxException;
  62  import java.util.ArrayList;
  63  import java.util.HashMap;
  64  import java.util.HashSet;
  65  import java.util.List;
  66  import java.util.Set;
  67  import java.util.zip.CRC32;
  68  
  69  /**
  70   * Persist the launcher home state across calamities.
  71   */
  72  public class LauncherBackupHelper implements BackupHelper {
  73  
  74      private static final String TAG = &quot;LauncherBackupHelper&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -    private static final boolean DEBUG = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +    private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +    private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;</span>
  78      private static final boolean DEBUG_PAYLOAD = false;
  79  
  80      private static final int MAX_JOURNAL_SIZE = 1000000;
  81  
  82      /** icons are large, dribble them out */
  83      private static final int MAX_ICONS_PER_PASS = 10;
  84  
  85      /** widgets contain previews, which are very large, dribble them out */
  86      private static final int MAX_WIDGETS_PER_PASS = 5;
  87  
  88      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  89  
  90      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +    public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;</span>
  93  
  94      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  95              android.graphics.Bitmap.CompressFormat.PNG;
  96  
  97      private static BackupManager sBackupManager;
  98  
  99      private static final String[] FAVORITE_PROJECTION = {
 100              Favorites._ID,                     // 0
 101              Favorites.MODIFIED,                // 1
 102              Favorites.INTENT,                  // 2
 103              Favorites.APPWIDGET_PROVIDER,      // 3
 104              Favorites.APPWIDGET_ID,            // 4
 105              Favorites.CELLX,                   // 5
 106              Favorites.CELLY,                   // 6
 107              Favorites.CONTAINER,               // 7
 108              Favorites.ICON,                    // 8
 109              Favorites.ICON_PACKAGE,            // 9
 110              Favorites.ICON_RESOURCE,           // 10
 111              Favorites.ICON_TYPE,               // 11
 112              Favorites.ITEM_TYPE,               // 12
 113              Favorites.SCREEN,                  // 13
 114              Favorites.SPANX,                   // 14
 115              Favorites.SPANY,                   // 15
 116              Favorites.TITLE,                   // 16
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +            Favorites.PROFILE_ID,              // 17</span>
 118      };
 119  
 120      private static final int ID_INDEX = 0;
 121      private static final int ID_MODIFIED = 1;
 122      private static final int INTENT_INDEX = 2;
 123      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 124      private static final int APPWIDGET_ID_INDEX = 4;
 125      private static final int CELLX_INDEX = 5;
 126      private static final int CELLY_INDEX = 6;
 127      private static final int CONTAINER_INDEX = 7;
 128      private static final int ICON_INDEX = 8;
 129      private static final int ICON_PACKAGE_INDEX = 9;
 130      private static final int ICON_RESOURCE_INDEX = 10;
 131      private static final int ICON_TYPE_INDEX = 11;
 132      private static final int ITEM_TYPE_INDEX = 12;
 133      private static final int SCREEN_INDEX = 13;
 134      private static final int SPANX_INDEX = 14;
 135      private static final int SPANY_INDEX = 15;
 136      private static final int TITLE_INDEX = 16;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +    private static final int PROFILE_ID_INDEX = 17;</span>
 138  
 139      private static final String[] SCREEN_PROJECTION = {
 140              WorkspaceScreens._ID,              // 0
 141              WorkspaceScreens.MODIFIED,         // 1
 142              WorkspaceScreens.SCREEN_RANK       // 2
 143      };
 144  
 145      private static final int SCREEN_RANK_INDEX = 2;
 146  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    private static IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +</span>
 149      private final Context mContext;
 150  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +    private final boolean mRestoreEnabled;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +</span>
 153      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 154  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -    private ArrayList&lt;Key&gt; mKeys;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -    public LauncherBackupHelper(Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +    private final ArrayList&lt;Key&gt; mKeys;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    public LauncherBackupHelper(Context context, boolean restoreEnabled) {</span>
 161          mContext = context;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +        mRestoreEnabled = restoreEnabled;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        mKeys = new ArrayList&lt;Key&gt;();</span>
 164      }
 165  
 166      private void dataChanged() {
 167          if (sBackupManager == null) {
 168              sBackupManager = new BackupManager(mContext);
 169          }
 170          sBackupManager.dataChanged();
 171      }
 172  
 173      /**
 174       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 175       *
 176       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 177       *
 178       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 179       *
 180       * @param oldState notes from the last backup
 181       * @param data incremental key/value pairs to persist off-device
 182       * @param newState notes for the next backup
 183       * @throws IOException
 184       */
 185      @Override
 186      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 187              ParcelFileDescriptor newState) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -        Log.v(TAG, &quot;onBackup&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +        if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);</span>
 190  
 191          Journal in = readJournal(oldState);
 192          Journal out = new Journal();
 193  
 194          long lastBackupTime = in.t;
 195          out.t = System.currentTimeMillis();
 196          out.rows = 0;
 197          out.bytes = 0;
 198  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -        Log.v(TAG, &quot;lastBackupTime=&quot; + lastBackupTime);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +        Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);</span>
 201  
 202          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -            backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -            backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -            backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -            backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -        } catch (IOException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -            Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        if (launcherIsReady()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +                backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +                backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +                backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +            } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +                Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +            out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +            out = in;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +</span>
 227          writeJournal(newState, out);
 228          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 229      }
 230  
 231      /**
 232       * Restore launcher configuration from the restored data stream.
 233       *
 234       * &lt;P&gt;Keys may arrive in any order.
 235       *
 236       * @param data the key/value pair from the server
 237       */
 238      @Override
 239      public void restoreEntity(BackupDataInputStream data) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -        Log.v(TAG, &quot;restoreEntity&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -        if (mKeys == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -            mKeys = new ArrayList&lt;Key&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +        if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);</span>
 245          byte[] buffer = new byte[512];
 246              String backupKey = data.getKey();
 247              int dataSize = data.size();
 248              if (buffer.length &lt; dataSize) {
 249                  buffer = new byte[dataSize];
 250              }
 251              Key key = null;
 252          int bytesRead = 0;
 253          try {
 254              bytesRead = data.read(buffer, 0, dataSize);
 255              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 256          } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -            Log.d(TAG, &quot;failed to read entity from restore data&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +            Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);</span>
 259          }
 260          try {
 261              key = backupKeyToKey(backupKey);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +            mKeys.add(key);</span>
 263              switch (key.type) {
 264                  case Key.FAVORITE:
 265                      restoreFavorite(key, buffer, dataSize, mKeys);
 266                      break;
 267  
 268                  case Key.SCREEN:
 269                      restoreScreen(key, buffer, dataSize, mKeys);
 270                      break;
 271  
 272                  case Key.ICON:
 273                      restoreIcon(key, buffer, dataSize, mKeys);
 274                      break;
 275  
 276                  case Key.WIDGET:
 277                      restoreWidget(key, buffer, dataSize, mKeys);
 278                      break;
 279  
 280                  default:
 281                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 282                      break;
 283              }
 284          } catch (KeyParsingException e) {
 285              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 286          }
 287  
 288      }
 289  
 290      /**
 291       * Record the restore state for the next backup.
 292       *
 293       * @param newState notes about the backup state after restore.
 294       */
 295      @Override
 296      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 297          // clear the output journal time, to force a full backup to
 298          // will catch any changes the restore process might have made
 299          Journal out = new Journal();
 300          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +        out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 303          writeJournal(newState, out);
 304          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 305          mKeys.clear();
 306      }
 307  
 308      /**
 309       * Write all modified favorites to the data stream.
 310       *
 311       *
 312       * @param in notes from last backup
 313       * @param data output stream for key/value pairs
 314       * @param out notes about this backup
 315       * @param keys keys to mark as clean in the notes for next backup
 316       * @throws IOException
 317       */
 318      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 319              ArrayList&lt;Key&gt; keys)
 320              throws IOException {
 321          // read the old ID set
 322          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 323          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 324  
 325          // persist things that have changed since the last backup
 326          ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +        // Don&#x27;t backup apps in other profiles for now.</span>
 328          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -                null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +                getUserSelectionArg(), null, null);</span>
 331          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 332          try {
 333              cursor.moveToPosition(-1);
 334              while(cursor.moveToNext()) {
 335                  final long id = cursor.getLong(ID_INDEX);
 336                  final long updateTime = cursor.getLong(ID_MODIFIED);
 337                  Key key = getKey(Key.FAVORITE, id);
 338                  keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -                currentIds.add(keyToBackupKey(key));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 340 -                if (updateTime &gt; in.t) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +                final String backupKey = keyToBackupKey(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +                currentIds.add(backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +                if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {</span>
 344                      byte[] blob = packFavorite(cursor);
 345                      writeRowToBackup(key, blob, out, data);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +                    if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);</span>
 348                  }
 349              }
 350          } finally {
 351              cursor.close();
 352          }
 353          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 354  
 355          // these IDs must have been deleted
 356          savedIds.removeAll(currentIds);
 357          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 358      }
 359  
 360      /**
 361       * Read a favorite from the stream.
 362       *
 363       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 364       *
 365       * @param key identifier for the row
 366       * @param buffer the serialized proto from the stream, may be larger than dataSize
 367       * @param dataSize the size of the proto from the stream
 368       * @param keys keys to mark as clean in the notes for next backup
 369       */
 370      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -        Log.v(TAG, &quot;unpacking favorite &quot; + key.id + &quot; (&quot; + dataSize + &quot; bytes)&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +        if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);</span>
 373          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 374                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 375  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -            Favorite favorite =  unpackFavorite(buffer, 0, dataSize);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + favorite.itemType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +        if (!mRestoreEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +            if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +            ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +            ContentValues values = unpackFavorite(buffer, 0, dataSize);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +            cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);</span>
 388          } catch (InvalidProtocolBufferNanoException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -            Log.w(TAG, &quot;failed to decode proto&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +            Log.e(TAG, &quot;failed to decode favorite&quot;, e);</span>
 391          }
 392      }
 393  
 394      /**
 395       * Write all modified screens to the data stream.
 396       *
 397       *
 398       * @param in notes from last backup
 399       * @param data output stream for key/value pairs
 400       * @param out notes about this backup
 401       * @param keys keys to mark as clean in the notes for next backup
 402       * @throws IOException
 403       */
 404      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 405              ArrayList&lt;Key&gt; keys)
 406              throws IOException {
 407          // read the old ID set
 408          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 409          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 410  
 411          // persist things that have changed since the last backup
 412          ContentResolver cr = mContext.getContentResolver();
 413          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 414                  null, null, null);
 415          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 416          try {
 417              cursor.moveToPosition(-1);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +            if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);</span>
 419              while(cursor.moveToNext()) {
 420                  final long id = cursor.getLong(ID_INDEX);
 421                  final long updateTime = cursor.getLong(ID_MODIFIED);
 422                  Key key = getKey(Key.SCREEN, id);
 423                  keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -                currentIds.add(keyToBackupKey(key));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -                if (updateTime &gt; in.t) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 426 +                final String backupKey = keyToBackupKey(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 427 +                currentIds.add(backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +                if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {</span>
 429                      byte[] blob = packScreen(cursor);
 430                      writeRowToBackup(key, blob, out, data);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +                    if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);</span>
 433                  }
 434              }
 435          } finally {
 436              cursor.close();
 437          }
 438          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 439  
 440          // these IDs must have been deleted
 441          savedIds.removeAll(currentIds);
 442          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 443      }
 444  
 445      /**
 446       * Read a screen from the stream.
 447       *
 448       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 449       *
 450       * @param key identifier for the row
 451       * @param buffer the serialized proto from the stream, may be larger than dataSize
 452       * @param dataSize the size of the proto from the stream
 453       * @param keys keys to mark as clean in the notes for next backup
 454       */
 455      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -        Log.v(TAG, &quot;unpacking screen &quot; + key.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 457 +        if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);</span>
 458          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 459                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -            Screen screen = unpackScreen(buffer, 0, dataSize);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + screen.rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 464 +        if (!mRestoreEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +            if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +            ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +            ContentValues values = unpackScreen(buffer, 0, dataSize);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +            cr.insert(WorkspaceScreens.CONTENT_URI, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +</span>
 474          } catch (InvalidProtocolBufferNanoException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -            Log.w(TAG, &quot;failed to decode proto&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 476 +            Log.e(TAG, &quot;failed to decode screen&quot;, e);</span>
 477          }
 478      }
 479  
 480      /**
 481       * Write all the static icon resources we need to render placeholders
 482       * for a package that is not installed.
 483       *
 484       * @param in notes from last backup
 485       * @param data output stream for key/value pairs
 486       * @param out notes about this backup
 487       * @param keys keys to mark as clean in the notes for next backup
 488       * @throws IOException
 489       */
 490      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 491              ArrayList&lt;Key&gt; keys) throws IOException {
 492          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +        if (!initializeIconCache()) {</span>
 496              dataChanged(); // try again later
 497              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 498              return;
 499          }
 500          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -        final IconCache iconCache = appState.getIconCache();</span>
 502          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +        final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();</span>
 504  
 505          // read the old ID set
 506          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 507          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 508  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 509 +        // Don&#x27;t backup apps in other profiles for now.</span>
 510          int startRows = out.rows;
 511          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 513 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 514 +        String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 515 +                Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 516 +                getUserSelectionArg();</span>
 517          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 518                  where, null, null);
 519          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 520          try {
 521              cursor.moveToPosition(-1);
 522              while(cursor.moveToNext()) {
 523                  final long id = cursor.getLong(ID_INDEX);
 524                  final String intentDescription = cursor.getString(INTENT_INDEX);
 525                  try {
 526                      Intent intent = Intent.parseUri(intentDescription, 0);
 527                      ComponentName cn = intent.getComponent();
 528                      Key key = null;
 529                      String backupKey = null;
 530                      if (cn != null) {
 531                          key = getKey(Key.ICON, cn.flattenToShortString());
 532                          backupKey = keyToBackupKey(key);
 533                          currentIds.add(backupKey);
 534                      } else {
 535                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 536                      }
 537                      if (savedIds.contains(backupKey)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -                        if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 539 +                        if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);</span>
 540  
 541                          // remember that we already backed this up previously
 542                          keys.add(key);
 543                      } else if (backupKey != null) {
 544                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 545                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -                            if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -                            Bitmap icon = iconCache.getIcon(intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +                            if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                            Bitmap icon = mIconCache.getIcon(intent, myUserHandle);</span>
 550                              keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -                            if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +                            if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {</span>
 553                                  byte[] blob = packIcon(dpi, icon);
 554                                  writeRowToBackup(key, blob, out, data);
 555                              }
 556                          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -                            if (DEBUG) Log.d(TAG, &quot;scheduling another run for icon &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +                            if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);</span>
 559                              // too many icons for this pass, request another.
 560                              dataChanged();
 561                          }
 562                      }
 563                  } catch (URISyntaxException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                    Log.w(TAG, &quot;invalid URI on application favorite: &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 565 +                    Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);</span>
 566                  } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -                    Log.w(TAG, &quot;unable to save application icon for favorite: &quot; + id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 568 +                    Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);</span>
 569                  }
 570  
 571              }
 572          } finally {
 573              cursor.close();
 574          }
 575          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 576  
 577          // these IDs must have been deleted
 578          savedIds.removeAll(currentIds);
 579          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 580      }
 581  
 582      /**
 583       * Read an icon from the stream.
 584       *
 585       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 586       *
 587       * @param key identifier for the row
 588       * @param buffer the serialized proto from the stream, may be larger than dataSize
 589       * @param dataSize the size of the proto from the stream
 590       * @param keys keys to mark as clean in the notes for next backup
 591       */
 592      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -        Log.v(TAG, &quot;unpacking icon &quot; + key.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +        if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);</span>
 595          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 596                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +</span>
 598          try {
 599              Resource res = unpackIcon(buffer, 0, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -            if (DEBUG) Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -                    Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -                            Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +            if (DEBUG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +                Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +            if (DEBUG_PAYLOAD) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +                Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +                        Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +                                Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +            }</span>
 612              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 613              if (icon == null) {
 614                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 615              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -            Log.w(TAG, &quot;failed to decode proto&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +            if (!mRestoreEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +                if (VERBOSE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 621 +                    Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 622 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 623 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 624 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +                if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 626 +                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 627 +                        icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 628 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +        } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +            Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);</span>
 631          }
 632      }
 633  
 634      /**
 635       * Write all the static widget resources we need to render placeholders
 636       * for a package that is not installed.
 637       *
 638       * @param in notes from last backup
 639       * @param data output stream for key/value pairs
 640       * @param out notes about this backup
 641       * @param keys keys to mark as clean in the notes for next backup
 642       * @throws IOException
 643       */
 644      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 645              ArrayList&lt;Key&gt; keys) throws IOException {
 646          // persist static widget info that hasn&#x27;t been persisted yet
 647          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -            dataChanged(); // try again later</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
 653              return;
 654          }
 655          final ContentResolver cr = mContext.getContentResolver();
 656          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 657          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -        final IconCache iconCache = appState.getIconCache();</span>
 659          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 660          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 661          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 662  
 663          // read the old ID set
 664          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 665          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 666  
 667          int startRows = out.rows;
 668          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                + getUserSelectionArg();</span>
 672          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 673                  where, null, null);
 674          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 675          try {
 676              cursor.moveToPosition(-1);
 677              while(cursor.moveToNext()) {
 678                  final long id = cursor.getLong(ID_INDEX);
 679                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 680                  final int spanX = cursor.getInt(SPANX_INDEX);
 681                  final int spanY = cursor.getInt(SPANY_INDEX);
 682                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 683                  Key key = null;
 684                  String backupKey = null;
 685                  if (provider != null) {
 686                      key = getKey(Key.WIDGET, providerName);
 687                      backupKey = keyToBackupKey(key);
 688                      currentIds.add(backupKey);
 689                  } else {
 690                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 691                  }
 692                  if (savedIds.contains(backupKey)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 693 -                    if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 694 +                    if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);</span>
 695  
 696                      // remember that we already backed this up previously
 697                      keys.add(key);
 698                  } else if (backupKey != null) {
 699                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 700                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -                        if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 702 +                        if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);</span>
 703                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 704                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 705 -                        byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 706 +                        byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);</span>
 707                          keys.add(key);
 708                          writeRowToBackup(key, blob, out, data);
 709  
 710                      } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 711 -                        if (DEBUG) Log.d(TAG, &quot;scheduling another run for widget &quot; + backupKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 712 +                        if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);</span>
 713                          // too many widgets for this pass, request another.
 714                          dataChanged();
 715                      }
 716                  }
 717              }
 718          } finally {
 719              cursor.close();
 720          }
 721          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 722  
 723          // these IDs must have been deleted
 724          savedIds.removeAll(currentIds);
 725          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 726      }
 727  
 728      /**
 729       * Read a widget from the stream.
 730       *
 731       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 732       *
 733       * @param key identifier for the row
 734       * @param buffer the serialized proto from the stream, may be larger than dataSize
 735       * @param dataSize the size of the proto from the stream
 736       * @param keys keys to mark as clean in the notes for next backup
 737       */
 738      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 739 -        Log.v(TAG, &quot;unpacking widget &quot; + key.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 740 +        if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);</span>
 741          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 742                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 743          try {
 744              Widget widget = unpackWidget(buffer, 0, dataSize);
 745              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 746              if (widget.icon.data != null)  {
 747                  Bitmap icon = BitmapFactory
 748                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 749                  if (icon == null) {
 750                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 751 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 752 +                    IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 753 +                            icon, widget.icon.dpi);</span>
 754                  }
 755              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +            if (!mRestoreEnabled) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 758 +                if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 759 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 760 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 761 +                // future site of widget table mutation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 762 +            }</span>
 763          } catch (InvalidProtocolBufferNanoException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 764 -            Log.w(TAG, &quot;failed to decode proto&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 765 +            Log.e(TAG, &quot;failed to decode widget&quot;, e);</span>
 766          }
 767      }
 768  
 769      /** create a new key, with an integer ID.
 770       *
 771       * &lt;P&gt; Keys contain their own checksum instead of using
 772       * the heavy-weight CheckedMessage wrapper.
 773       */
 774      private Key getKey(int type, long id) {
 775          Key key = new Key();
 776          key.type = type;
 777          key.id = id;
 778          key.checksum = checkKey(key);
 779          return key;
 780      }
 781  
 782      /** create a new key for a named object.
 783       *
 784       * &lt;P&gt; Keys contain their own checksum instead of using
 785       * the heavy-weight CheckedMessage wrapper.
 786       */
 787      private Key getKey(int type, String name) {
 788          Key key = new Key();
 789          key.type = type;
 790          key.name = name;
 791          key.checksum = checkKey(key);
 792          return key;
 793      }
 794  
 795      /** keys need to be strings, serialize and encode. */
 796      private String keyToBackupKey(Key key) {
 797          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 798      }
 799  
 800      /** keys need to be strings, decode and parse. */
 801      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 802          try {
 803              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 804              if (key.checksum != checkKey(key)) {
 805                  key = null;
 806                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 807              }
 808              return key;
 809          } catch (InvalidProtocolBufferNanoException e) {
 810              throw new KeyParsingException(e);
 811          } catch (IllegalArgumentException e) {
 812              throw new KeyParsingException(e);
 813          }
 814      }
 815  
 816      private String getKeyName(Key key) {
 817          if (TextUtils.isEmpty(key.name)) {
 818              return Long.toString(key.id);
 819          } else {
 820              return key.name;
 821          }
 822  
 823      }
 824  
 825      private String geKeyType(Key key) {
 826          switch (key.type) {
 827              case Key.FAVORITE:
 828                  return &quot;favorite&quot;;
 829              case Key.SCREEN:
 830                  return &quot;screen&quot;;
 831              case Key.ICON:
 832                  return &quot;icon&quot;;
 833              case Key.WIDGET:
 834                  return &quot;widget&quot;;
 835              default:
 836                  return &quot;anonymous&quot;;
 837          }
 838      }
 839  
 840      /** Compute the checksum over the important bits of a key. */
 841      private long checkKey(Key key) {
 842          CRC32 checksum = new CRC32();
 843          checksum.update(key.type);
 844          checksum.update((int) (key.id &amp; 0xffff));
 845          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 846          if (!TextUtils.isEmpty(key.name)) {
 847              checksum.update(key.name.getBytes());
 848          }
 849          return checksum.getValue();
 850      }
 851  
 852      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 853      private byte[] packFavorite(Cursor c) {
 854          Favorite favorite = new Favorite();
 855          favorite.id = c.getLong(ID_INDEX);
 856          favorite.screen = c.getInt(SCREEN_INDEX);
 857          favorite.container = c.getInt(CONTAINER_INDEX);
 858          favorite.cellX = c.getInt(CELLX_INDEX);
 859          favorite.cellY = c.getInt(CELLY_INDEX);
 860          favorite.spanX = c.getInt(SPANX_INDEX);
 861          favorite.spanY = c.getInt(SPANY_INDEX);
 862          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 863          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 864              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 865              if (!TextUtils.isEmpty(iconPackage)) {
 866                  favorite.iconPackage = iconPackage;
 867              }
 868              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 869              if (!TextUtils.isEmpty(iconResource)) {
 870                  favorite.iconResource = iconResource;
 871              }
 872          }
 873          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 874              byte[] blob = c.getBlob(ICON_INDEX);
 875              if (blob != null &amp;&amp; blob.length &gt; 0) {
 876                  favorite.icon = blob;
 877              }
 878          }
 879          String title = c.getString(TITLE_INDEX);
 880          if (!TextUtils.isEmpty(title)) {
 881              favorite.title = title;
 882          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 883 -        String intent = c.getString(INTENT_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 884 -        if (!TextUtils.isEmpty(intent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 885 -            favorite.intent = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +        String intentDescription = c.getString(INTENT_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +        if (!TextUtils.isEmpty(intentDescription)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 889 +                Intent intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 890 +                intent.removeExtra(ItemInfo.EXTRA_PROFILE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +                favorite.intent = intent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +            } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +                Log.e(TAG, &quot;Invalid intent&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +           }</span>
 895          }
 896          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 897          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 898              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 899              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 900              if (!TextUtils.isEmpty(appWidgetProvider)) {
 901                  favorite.appWidgetProvider = appWidgetProvider;
 902              }
 903          }
 904  
 905          return writeCheckedBytes(favorite);
 906      }
 907  
 908      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 909 -    private Favorite unpackFavorite(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +    private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)</span>
 911              throws InvalidProtocolBufferNanoException {
 912          Favorite favorite = new Favorite();
 913          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 914 -        return favorite;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +        if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +        ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +        values.put(Favorites._ID, favorite.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +        values.put(Favorites.SCREEN, favorite.screen);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +        values.put(Favorites.CONTAINER, favorite.container);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +        values.put(Favorites.CELLX, favorite.cellX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +        values.put(Favorites.CELLY, favorite.cellY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +        values.put(Favorites.SPANX, favorite.spanX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +        values.put(Favorites.SPANY, favorite.spanY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +        values.put(Favorites.ICON_TYPE, favorite.iconType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +        if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +            values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +            values.put(Favorites.ICON_RESOURCE, favorite.iconResource);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +        if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 931 +            values.put(Favorites.ICON, favorite.icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 932 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 933 +        if (!TextUtils.isEmpty(favorite.title)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 934 +            values.put(Favorites.TITLE, favorite.title);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 935 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 936 +            values.put(Favorites.TITLE, &quot;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 937 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 938 +        if (!TextUtils.isEmpty(favorite.intent)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +            values.put(Favorites.INTENT, favorite.intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +        values.put(Favorites.ITEM_TYPE, favorite.itemType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +        UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +        long userSerialNumber =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +                UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +        values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +        if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 949 +            if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +                values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +            values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +            values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +                    LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +                    LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 956 +                    LauncherAppWidgetInfo.FLAG_UI_NOT_READY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 957 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 958 +            // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 959 +            values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +        return values;</span>
 963      }
 964  
 965      /** Serialize a Screen for persistence, including a checksum wrapper. */
 966      private byte[] packScreen(Cursor c) {
 967          Screen screen = new Screen();
 968          screen.id = c.getLong(ID_INDEX);
 969          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 970  
 971          return writeCheckedBytes(screen);
 972      }
 973  
 974      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 975 -    private Screen unpackScreen(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +    private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)</span>
 977              throws InvalidProtocolBufferNanoException {
 978          Screen screen = new Screen();
 979          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 980 -        return screen;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +        if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +        ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +        values.put(WorkspaceScreens._ID, screen.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +        values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +        return values;</span>
 986      }
 987  
 988      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 989      private byte[] packIcon(int dpi, Bitmap icon) {
 990          Resource res = new Resource();
 991          res.dpi = dpi;
 992          ByteArrayOutputStream os = new ByteArrayOutputStream();
 993          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 994              res.data = os.toByteArray();
 995          }
 996          return writeCheckedBytes(res);
 997      }
 998  
 999      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1000 -    private Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +    private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
1002              throws InvalidProtocolBufferNanoException {
1003          Resource res = new Resource();
1004          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1005 +        if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);</span>
1006          return res;
1007      }
1008  
1009      /** Serialize a widget for persistence, including a checksum wrapper. */
1010      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
1011              ComponentName provider) {
1012          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
1013          Widget widget = new Widget();
1014          widget.provider = provider.flattenToShortString();
1015          widget.label = info.label;
1016          widget.configure = info.configure != null;
1017          if (info.icon != 0) {
1018              widget.icon = new Resource();
1019              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
1020              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
1021              ByteArrayOutputStream os = new ByteArrayOutputStream();
1022              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1023                  widget.icon.data = os.toByteArray();
1024                  widget.icon.dpi = dpi;
1025              }
1026          }
1027          if (info.previewImage != 0) {
1028              widget.preview = new Resource();
1029              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
1030              ByteArrayOutputStream os = new ByteArrayOutputStream();
1031              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1032                  widget.preview.data = os.toByteArray();
1033                  widget.preview.dpi = dpi;
1034              }
1035          }
1036          return writeCheckedBytes(widget);
1037      }
1038  
1039      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
1040      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
1041              throws InvalidProtocolBufferNanoException {
1042          Widget widget = new Widget();
1043          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1044 +        if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);</span>
1045          return widget;
1046      }
1047  
1048      /**
1049       * Read the old journal from the input file.
1050       *
1051       * In the event of any error, just pretend we didn&#x27;t have a journal,
1052       * in that case, do a full backup.
1053       *
1054       * @param oldState the read-0only file descriptor pointing to the old journal
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1055 -     * @return a Journal protocol bugffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1056 +     * @return a Journal protocol buffer</span>
1057       */
1058      private Journal readJournal(ParcelFileDescriptor oldState) {
1059          Journal journal = new Journal();
1060          if (oldState == null) {
1061              return journal;
1062          }
1063          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1064          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1065 -            int remaining = inStream.available();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1066 -            if (DEBUG) Log.d(TAG, &quot;available &quot; + remaining);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1067 -            if (remaining &lt; MAX_JOURNAL_SIZE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1068 -                byte[] buffer = new byte[remaining];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1069 +            int availableBytes = inStream.available();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1070 +            if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1071 +            if (availableBytes &lt; MAX_JOURNAL_SIZE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1072 +                byte[] buffer = new byte[availableBytes];</span>
1073                  int bytesRead = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1074 -                while (remaining &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1075 +                boolean valid = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1076 +                InvalidProtocolBufferNanoException lastProtoException = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1077 +                while (availableBytes &gt; 0) {</span>
1078                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1079 -                        int result = inStream.read(buffer, bytesRead, remaining);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1080 +                        // OMG what are you doing? This is crazy inefficient!</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1081 +                        // If we read a byte that is not ours, we will cause trouble: b/12491813</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1082 +                        // However, we don&#x27;t know how many bytes to expect (oops).</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1083 +                        // So we have to step through *slowly*, watching for the end.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1084 +                        int result = inStream.read(buffer, bytesRead, 1);</span>
1085                          if (result &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1086 -                            if (DEBUG) Log.d(TAG, &quot;read some bytes: &quot; + result);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1087 -                            remaining -= result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1088 +                            availableBytes -= result;</span>
1089                              bytesRead += result;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1090 +                            if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1091 +                                Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1092 +                            }</span>
1093                          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1094 -                            // stop reading ands see what there is to parse</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1095 -                            Log.w(TAG, &quot;read error: &quot; + result);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1096 -                            remaining = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1097 +                            Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1098 +                            // stop reading and see what there is to parse</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1099 +                            availableBytes = 0;</span>
1100                          }
1101                      } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1102 -                        Log.w(TAG, &quot;failed to read the journal&quot;, e);</span>
1103                          buffer = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1104 -                        remaining = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1105 +                        availableBytes = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1106 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1107 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1108 +                    // check the buffer to see if we have a valid journal</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1109 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1110 +                        MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1111 +                        // if we are here, then we have read a valid, checksum-verified journal</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1112 +                        valid = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1113 +                        availableBytes = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1114 +                        if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1115 +                    } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1116 +                        // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1117 +                        lastProtoException = e;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1118 +                        journal.clear();</span>
1119                      }
1120                  }
1121                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1122 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1123 -                if (buffer != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1124 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1125 -                        MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1126 -                    } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1127 -                        Log.d(TAG, &quot;failed to read the journal&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1128 -                        journal.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1129 -                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1130 +                if (!valid) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +                    Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);</span>
1132                  }
1133              }
1134          } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1135 -            Log.d(TAG, &quot;failed to close the journal&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +            Log.w(TAG, &quot;failed to close the journal&quot;, e);</span>
1137          } finally {
1138              try {
1139                  inStream.close();
1140              } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1141 -                Log.d(TAG, &quot;failed to close the journal&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1142 +                Log.w(TAG, &quot;failed to close the journal&quot;, e);</span>
1143              }
1144          }
1145          return journal;
1146      }
1147  
1148      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1149              BackupDataOutput data) throws IOException {
1150          String backupKey = keyToBackupKey(key);
1151          data.writeEntityHeader(backupKey, blob.length);
1152          data.writeEntityData(blob, blob.length);
1153          out.rows++;
1154          out.bytes += blob.length;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1155 -        Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1156 +        if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +</span>
1157                  getKeyName(key) + &quot;/&quot; + blob.length);
1158          if(DEBUG_PAYLOAD) {
1159              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1160              final int chunkSize = 1024;
1161              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1162                  int end = offset + chunkSize;
1163                  end = Math.min(end, encoded.length());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1164 -                Log.d(TAG, &quot;wrote &quot; + encoded.substring(offset, end));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1165 +                Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));</span>
1166              }
1167          }
1168      }
1169  
1170      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1171          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1172          for(int i = 0; i &lt; in.key.length; i++) {
1173              Key key = in.key[i];
1174              if (key.type == type) {
1175                  savedIds.add(keyToBackupKey(key));
1176              }
1177          }
1178          return savedIds;
1179      }
1180  
1181      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1182              throws IOException {
1183          int rows = 0;
1184          for(String deleted: deletedIds) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1185 -            Log.v(TAG, &quot;dropping icon &quot; + deleted);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1186 +            if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);</span>
1187              data.writeEntityHeader(deleted, -1);
1188              rows++;
1189          }
1190          return rows;
1191      }
1192  
1193      /**
1194       * Write the new journal to the output file.
1195       *
1196       * In the event of any error, just pretend we didn&#x27;t have a journal,
1197       * in that case, do a full backup.
1198  
1199       * @param newState the write-only file descriptor pointing to the new journal
1200       * @param journal a Journal protocol buffer
1201       */
1202      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1203          FileOutputStream outStream = null;
1204          try {
1205              outStream = new FileOutputStream(newState.getFileDescriptor());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1206 -            outStream.write(writeCheckedBytes(journal));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1207 +            final byte[] journalBytes = writeCheckedBytes(journal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1208 +            outStream.write(journalBytes);</span>
1209              outStream.close();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1210 +            if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);</span>
1211          } catch (IOException e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1212 -            Log.d(TAG, &quot;failed to write backup journal&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1213 +            Log.w(TAG, &quot;failed to write backup journal&quot;, e);</span>
1214          }
1215      }
1216  
1217      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1218      private byte[] writeCheckedBytes(MessageNano proto) {
1219          CheckedMessage wrapper = new CheckedMessage();
1220          wrapper.payload = MessageNano.toByteArray(proto);
1221          CRC32 checksum = new CRC32();
1222          checksum.update(wrapper.payload);
1223          wrapper.checksum = checksum.getValue();
1224          return MessageNano.toByteArray(wrapper);
1225      }
1226  
1227      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1228 -    private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1229 +    private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
1230              throws InvalidProtocolBufferNanoException {
1231          CheckedMessage wrapper = new CheckedMessage();
1232          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1233          CRC32 checksum = new CRC32();
1234          checksum.update(wrapper.payload);
1235          if (wrapper.checksum != checksum.getValue()) {
1236              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1237          }
1238          return wrapper.payload;
1239      }
1240  
1241      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1242          if (mWidgetMap == null) {
1243              List&lt;AppWidgetProviderInfo&gt; widgets =
1244                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1245              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1246              for (AppWidgetProviderInfo info : widgets) {
1247                  mWidgetMap.put(info.provider, info);
1248              }
1249          }
1250          return mWidgetMap.get(component);
1251      }
1252  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1253 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1254 +    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1255 +        if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1256 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1257 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1258 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1259 +        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1260 +        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1261 +            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1262 +            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1263 +            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1264 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1265 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1266 +        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1267 +        return mIconCache != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1268 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1269 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1270 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1271 +   // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1272 +    private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1273 +        ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1274 +        Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1275 +        if (cursor == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1276 +            // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1277 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1278 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1279 +        cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1280 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1281 +        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1282 +            // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1283 +            dataChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1284 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1285 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1286 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1287 +        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1288 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1289 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1290 +    private String getUserSelectionArg() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1291 +        return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1292 +                .getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1293 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1294 +</span>
1295      private class KeyParsingException extends Throwable {
1296          private KeyParsingException(Throwable cause) {
1297              super(cause);
1298          }
1299  
1300          public KeyParsingException(String reason) {
1301              super(reason);
1302          }
1303      }
1304  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  20  import com.google.protobuf.nano.MessageNano;
  21  
  22  import com.android.launcher3.LauncherSettings.Favorites;
  23  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  24  import com.android.launcher3.backup.BackupProtos;
  25  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  26  import com.android.launcher3.backup.BackupProtos.Favorite;
  27  import com.android.launcher3.backup.BackupProtos.Journal;
  28  import com.android.launcher3.backup.BackupProtos.Key;
  29  import com.android.launcher3.backup.BackupProtos.Resource;
  30  import com.android.launcher3.backup.BackupProtos.Screen;
  31  import com.android.launcher3.backup.BackupProtos.Widget;


  32  
  33  import android.app.backup.BackupDataInputStream;

  34  import android.app.backup.BackupHelper;
  35  import android.app.backup.BackupDataInput;
  36  import android.app.backup.BackupDataOutput;
  37  import android.app.backup.BackupManager;
  38  import android.appwidget.AppWidgetManager;
  39  import android.appwidget.AppWidgetProviderInfo;
  40  import android.content.ComponentName;
  41  import android.content.ContentResolver;

  42  import android.content.Context;
  43  import android.content.Intent;
  44  import android.database.Cursor;
  45  import android.graphics.Bitmap;
  46  import android.graphics.BitmapFactory;
  47  import android.graphics.drawable.Drawable;
  48  import android.os.ParcelFileDescriptor;
  49  import android.text.TextUtils;
  50  import android.util.Base64;
  51  import android.util.Log;
  52  
  53  import java.io.ByteArrayOutputStream;
  54  import java.io.FileInputStream;
  55  import java.io.FileOutputStream;
  56  import java.io.IOException;
  57  import java.net.URISyntaxException;
  58  import java.util.ArrayList;
  59  import java.util.HashMap;
  60  import java.util.HashSet;
  61  import java.util.List;
  62  import java.util.Set;
  63  import java.util.zip.CRC32;
  64  
  65  /**
  66   * Persist the launcher home state across calamities.
  67   */
  68  public class LauncherBackupHelper implements BackupHelper {
  69  
  70      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  71      private static final boolean DEBUG = false;


  72      private static final boolean DEBUG_PAYLOAD = false;
  73  
  74      private static final int MAX_JOURNAL_SIZE = 1000000;
  75  
  76      /** icons are large, dribble them out */
  77      private static final int MAX_ICONS_PER_PASS = 10;
  78  
  79      /** widgets contain previews, which are very large, dribble them out */
  80      private static final int MAX_WIDGETS_PER_PASS = 5;
  81  
  82      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  83  
  84      public static final String LAUNCHER_PREFIX = &quot;L&quot;;


  85  
  86      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  87              android.graphics.Bitmap.CompressFormat.PNG;
  88  
  89      private static BackupManager sBackupManager;
  90  
  91      private static final String[] FAVORITE_PROJECTION = {
  92              Favorites._ID,                     // 0
  93              Favorites.MODIFIED,                // 1
  94              Favorites.INTENT,                  // 2
  95              Favorites.APPWIDGET_PROVIDER,      // 3
  96              Favorites.APPWIDGET_ID,            // 4
  97              Favorites.CELLX,                   // 5
  98              Favorites.CELLY,                   // 6
  99              Favorites.CONTAINER,               // 7
 100              Favorites.ICON,                    // 8
 101              Favorites.ICON_PACKAGE,            // 9
 102              Favorites.ICON_RESOURCE,           // 10
 103              Favorites.ICON_TYPE,               // 11
 104              Favorites.ITEM_TYPE,               // 12
 105              Favorites.SCREEN,                  // 13
 106              Favorites.SPANX,                   // 14
 107              Favorites.SPANY,                   // 15
 108              Favorites.TITLE,                   // 16

 109      };
 110  
 111      private static final int ID_INDEX = 0;
 112      private static final int ID_MODIFIED = 1;
 113      private static final int INTENT_INDEX = 2;
 114      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 115      private static final int APPWIDGET_ID_INDEX = 4;
 116      private static final int CELLX_INDEX = 5;
 117      private static final int CELLY_INDEX = 6;
 118      private static final int CONTAINER_INDEX = 7;
 119      private static final int ICON_INDEX = 8;
 120      private static final int ICON_PACKAGE_INDEX = 9;
 121      private static final int ICON_RESOURCE_INDEX = 10;
 122      private static final int ICON_TYPE_INDEX = 11;
 123      private static final int ITEM_TYPE_INDEX = 12;
 124      private static final int SCREEN_INDEX = 13;
 125      private static final int SPANX_INDEX = 14;
 126      private static final int SPANY_INDEX = 15;
 127      private static final int TITLE_INDEX = 16;

 128  
 129      private static final String[] SCREEN_PROJECTION = {
 130              WorkspaceScreens._ID,              // 0
 131              WorkspaceScreens.MODIFIED,         // 1
 132              WorkspaceScreens.SCREEN_RANK       // 2
 133      };
 134  
 135      private static final int SCREEN_RANK_INDEX = 2;
 136  


 137      private final Context mContext;
 138  


 139      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 140  
 141      private ArrayList&lt;Key&gt; mKeys;
 142  
 143      public LauncherBackupHelper(Context context) {



 144          mContext = context;


 145      }
 146  
 147      private void dataChanged() {
 148          if (sBackupManager == null) {
 149              sBackupManager = new BackupManager(mContext);
 150          }
 151          sBackupManager.dataChanged();
 152      }
 153  
 154      /**
 155       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 156       *
 157       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 158       *
 159       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 160       *
 161       * @param oldState notes from the last backup
 162       * @param data incremental key/value pairs to persist off-device
 163       * @param newState notes for the next backup
 164       * @throws IOException
 165       */
 166      @Override
 167      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 168              ParcelFileDescriptor newState) {
 169          Log.v(TAG, &quot;onBackup&quot;);

 170  
 171          Journal in = readJournal(oldState);
 172          Journal out = new Journal();
 173  
 174          long lastBackupTime = in.t;
 175          out.t = System.currentTimeMillis();
 176          out.rows = 0;
 177          out.bytes = 0;
 178  
 179          Log.v(TAG, &quot;lastBackupTime=&quot; + lastBackupTime);

 180  
 181          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 182          try {
 183              backupFavorites(in, data, out, keys);
 184              backupScreens(in, data, out, keys);
 185              backupIcons(in, data, out, keys);
 186              backupWidgets(in, data, out, keys);
 187          } catch (IOException e) {
 188              Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 189          }
 190  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -        out.key = keys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +        out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>













 193          writeJournal(newState, out);
 194          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 195      }
 196  
 197      /**
 198       * Restore launcher configuration from the restored data stream.
 199       *
 200       * &lt;P&gt;Keys may arrive in any order.
 201       *
 202       * @param data the key/value pair from the server
 203       */
 204      @Override
 205      public void restoreEntity(BackupDataInputStream data) {
 206          Log.v(TAG, &quot;restoreEntity&quot;);
 207          if (mKeys == null) {
 208              mKeys = new ArrayList&lt;Key&gt;();
 209          }

 210          byte[] buffer = new byte[512];
 211              String backupKey = data.getKey();
 212              int dataSize = data.size();
 213              if (buffer.length &lt; dataSize) {
 214                  buffer = new byte[dataSize];
 215              }
 216              Key key = null;
 217          int bytesRead = 0;
 218          try {
 219              bytesRead = data.read(buffer, 0, dataSize);
 220              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 221          } catch (IOException e) {
 222              Log.d(TAG, &quot;failed to read entity from restore data&quot;, e);

 223          }
 224          try {
 225              key = backupKeyToKey(backupKey);

 226              switch (key.type) {
 227                  case Key.FAVORITE:
 228                      restoreFavorite(key, buffer, dataSize, mKeys);
 229                      break;
 230  
 231                  case Key.SCREEN:
 232                      restoreScreen(key, buffer, dataSize, mKeys);
 233                      break;
 234  
 235                  case Key.ICON:
 236                      restoreIcon(key, buffer, dataSize, mKeys);
 237                      break;
 238  
 239                  case Key.WIDGET:
 240                      restoreWidget(key, buffer, dataSize, mKeys);
 241                      break;
 242  
 243                  default:
 244                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 245                      break;
 246              }
 247          } catch (KeyParsingException e) {
 248              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 249          }
 250  
 251      }
 252  
 253      /**
 254       * Record the restore state for the next backup.
 255       *
 256       * @param newState notes about the backup state after restore.
 257       */
 258      @Override
 259      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 260          // clear the output journal time, to force a full backup to
 261          // will catch any changes the restore process might have made
 262          Journal out = new Journal();
 263          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -        out.key = mKeys.toArray(BackupProtos.Key.EMPTY_ARRAY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +        out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
 266          writeJournal(newState, out);
 267          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 268          mKeys.clear();
 269      }
 270  
 271      /**
 272       * Write all modified favorites to the data stream.
 273       *
 274       *
 275       * @param in notes from last backup
 276       * @param data output stream for key/value pairs
 277       * @param out notes about this backup
 278       * @param keys keys to mark as clean in the notes for next backup
 279       * @throws IOException
 280       */
 281      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 282              ArrayList&lt;Key&gt; keys)
 283              throws IOException {
 284          // read the old ID set
 285          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 286          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 287  
 288          // persist things that have changed since the last backup
 289          ContentResolver cr = mContext.getContentResolver();

 290          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 291                  null, null, null);

 292          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 293          try {
 294              cursor.moveToPosition(-1);
 295              while(cursor.moveToNext()) {
 296                  final long id = cursor.getLong(ID_INDEX);
 297                  final long updateTime = cursor.getLong(ID_MODIFIED);
 298                  Key key = getKey(Key.FAVORITE, id);
 299                  keys.add(key);
 300                  currentIds.add(keyToBackupKey(key));
 301                  if (updateTime &gt; in.t) {



 302                      byte[] blob = packFavorite(cursor);
 303                      writeRowToBackup(key, blob, out, data);


 304                  }
 305              }
 306          } finally {
 307              cursor.close();
 308          }
 309          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 310  
 311          // these IDs must have been deleted
 312          savedIds.removeAll(currentIds);
 313          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 314      }
 315  
 316      /**
 317       * Read a favorite from the stream.
 318       *
 319       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 320       *
 321       * @param key identifier for the row
 322       * @param buffer the serialized proto from the stream, may be larger than dataSize
 323       * @param dataSize the size of the proto from the stream
 324       * @param keys keys to mark as clean in the notes for next backup
 325       */
 326      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 327          Log.v(TAG, &quot;unpacking favorite &quot; + key.id + &quot; (&quot; + dataSize + &quot; bytes)&quot;);

 328          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 329                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 330  
 331          try {
 332              Favorite favorite =  unpackFavorite(buffer, 0, dataSize);
 333              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + favorite.itemType);









 334          } catch (InvalidProtocolBufferNanoException e) {
 335              Log.w(TAG, &quot;failed to decode proto&quot;, e);

 336          }
 337      }
 338  
 339      /**
 340       * Write all modified screens to the data stream.
 341       *
 342       *
 343       * @param in notes from last backup
 344       * @param data output stream for key/value pairs
 345       * @param out notes about this backup
 346       * @param keys keys to mark as clean in the notes for next backup
 347       * @throws IOException
 348       */
 349      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 350              ArrayList&lt;Key&gt; keys)
 351              throws IOException {
 352          // read the old ID set
 353          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 354          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 355  
 356          // persist things that have changed since the last backup
 357          ContentResolver cr = mContext.getContentResolver();
 358          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 359                  null, null, null);
 360          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 361          try {
 362              cursor.moveToPosition(-1);

 363              while(cursor.moveToNext()) {
 364                  final long id = cursor.getLong(ID_INDEX);
 365                  final long updateTime = cursor.getLong(ID_MODIFIED);
 366                  Key key = getKey(Key.SCREEN, id);
 367                  keys.add(key);
 368                  currentIds.add(keyToBackupKey(key));
 369                  if (updateTime &gt; in.t) {



 370                      byte[] blob = packScreen(cursor);
 371                      writeRowToBackup(key, blob, out, data);


 372                  }
 373              }
 374          } finally {
 375              cursor.close();
 376          }
 377          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 378  
 379          // these IDs must have been deleted
 380          savedIds.removeAll(currentIds);
 381          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 382      }
 383  
 384      /**
 385       * Read a screen from the stream.
 386       *
 387       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 388       *
 389       * @param key identifier for the row
 390       * @param buffer the serialized proto from the stream, may be larger than dataSize
 391       * @param dataSize the size of the proto from the stream
 392       * @param keys keys to mark as clean in the notes for next backup
 393       */
 394      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 395          Log.v(TAG, &quot;unpacking screen &quot; + key.id);

 396          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 397                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 398          try {
 399              Screen screen = unpackScreen(buffer, 0, dataSize);
 400              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + screen.rank);











 401          } catch (InvalidProtocolBufferNanoException e) {
 402              Log.w(TAG, &quot;failed to decode proto&quot;, e);

 403          }
 404      }
 405  
 406      /**
 407       * Write all the static icon resources we need to render placeholders
 408       * for a package that is not installed.
 409       *
 410       * @param in notes from last backup
 411       * @param data output stream for key/value pairs
 412       * @param out notes about this backup
 413       * @param keys keys to mark as clean in the notes for next backup
 414       * @throws IOException
 415       */
 416      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 417              ArrayList&lt;Key&gt; keys) throws IOException {
 418          // persist icons that haven&#x27;t been persisted yet
 419          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 420          if (appState == null) {

 421              dataChanged(); // try again later
 422              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 423              return;
 424          }
 425          final ContentResolver cr = mContext.getContentResolver();
 426          final IconCache iconCache = appState.getIconCache();
 427          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;

 428  
 429          // read the old ID set
 430          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 431          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 432  

 433          int startRows = out.rows;
 434          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 435          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;




 436          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 437                  where, null, null);
 438          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 439          try {
 440              cursor.moveToPosition(-1);
 441              while(cursor.moveToNext()) {
 442                  final long id = cursor.getLong(ID_INDEX);
 443                  final String intentDescription = cursor.getString(INTENT_INDEX);
 444                  try {
 445                      Intent intent = Intent.parseUri(intentDescription, 0);
 446                      ComponentName cn = intent.getComponent();
 447                      Key key = null;
 448                      String backupKey = null;
 449                      if (cn != null) {
 450                          key = getKey(Key.ICON, cn.flattenToShortString());
 451                          backupKey = keyToBackupKey(key);
 452                          currentIds.add(backupKey);
 453                      } else {
 454                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 455                      }
 456                      if (savedIds.contains(backupKey)) {
 457                          if (DEBUG) Log.d(TAG, &quot;already saved icon &quot; + backupKey);

 458  
 459                          // remember that we already backed this up previously
 460                          keys.add(key);
 461                      } else if (backupKey != null) {
 462                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 463                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 464                              if (DEBUG) Log.d(TAG, &quot;saving icon &quot; + backupKey);
 465                              Bitmap icon = iconCache.getIcon(intent);


 466                              keys.add(key);
 467                              if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {

 468                                  byte[] blob = packIcon(dpi, icon);
 469                                  writeRowToBackup(key, blob, out, data);
 470                              }
 471                          } else {
 472                              if (DEBUG) Log.d(TAG, &quot;scheduling another run for icon &quot; + backupKey);

 473                              // too many icons for this pass, request another.
 474                              dataChanged();
 475                          }
 476                      }
 477                  } catch (URISyntaxException e) {
 478                      Log.w(TAG, &quot;invalid URI on application favorite: &quot; + id);

 479                  } catch (IOException e) {
 480                      Log.w(TAG, &quot;unable to save application icon for favorite: &quot; + id);

 481                  }
 482  
 483              }
 484          } finally {
 485              cursor.close();
 486          }
 487          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 488  
 489          // these IDs must have been deleted
 490          savedIds.removeAll(currentIds);
 491          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 492      }
 493  
 494      /**
 495       * Read an icon from the stream.
 496       *
 497       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 498       *
 499       * @param key identifier for the row
 500       * @param buffer the serialized proto from the stream, may be larger than dataSize
 501       * @param dataSize the size of the proto from the stream
 502       * @param keys keys to mark as clean in the notes for next backup
 503       */
 504      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 505          Log.v(TAG, &quot;unpacking icon &quot; + key.id);

 506          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 507                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));

 508          try {
 509              Resource res = unpackIcon(buffer, 0, dataSize);
 510              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi);
 511              if (DEBUG) Log.d(TAG, &quot;read &quot; +
 512                      Base64.encodeToString(res.data, 0, res.data.length,
 513                              Base64.NO_WRAP));








 514              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 515              if (icon == null) {
 516                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 517              }
 518          } catch (InvalidProtocolBufferNanoException e) {
 519              Log.w(TAG, &quot;failed to decode proto&quot;, e);













 520          }
 521      }
 522  
 523      /**
 524       * Write all the static widget resources we need to render placeholders
 525       * for a package that is not installed.
 526       *
 527       * @param in notes from last backup
 528       * @param data output stream for key/value pairs
 529       * @param out notes about this backup
 530       * @param keys keys to mark as clean in the notes for next backup
 531       * @throws IOException
 532       */
 533      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 534              ArrayList&lt;Key&gt; keys) throws IOException {
 535          // persist static widget info that hasn&#x27;t been persisted yet
 536          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 537          if (appState == null) {
 538              dataChanged(); // try again later
 539              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);


 540              return;
 541          }
 542          final ContentResolver cr = mContext.getContentResolver();
 543          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 544          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 545          final IconCache iconCache = appState.getIconCache();
 546          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 547          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 548          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 549  
 550          // read the old ID set
 551          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 552          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 553  
 554          int startRows = out.rows;
 555          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 556          String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;


 557          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 558                  where, null, null);
 559          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 560          try {
 561              cursor.moveToPosition(-1);
 562              while(cursor.moveToNext()) {
 563                  final long id = cursor.getLong(ID_INDEX);
 564                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 565                  final int spanX = cursor.getInt(SPANX_INDEX);
 566                  final int spanY = cursor.getInt(SPANY_INDEX);
 567                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 568                  Key key = null;
 569                  String backupKey = null;
 570                  if (provider != null) {
 571                      key = getKey(Key.WIDGET, providerName);
 572                      backupKey = keyToBackupKey(key);
 573                      currentIds.add(backupKey);
 574                  } else {
 575                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 576                  }
 577                  if (savedIds.contains(backupKey)) {
 578                      if (DEBUG) Log.d(TAG, &quot;already saved widget &quot; + backupKey);

 579  
 580                      // remember that we already backed this up previously
 581                      keys.add(key);
 582                  } else if (backupKey != null) {
 583                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 584                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 585                          if (DEBUG) Log.d(TAG, &quot;saving widget &quot; + backupKey);

 586                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 587                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
 588                          byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);

 589                          keys.add(key);
 590                          writeRowToBackup(key, blob, out, data);
 591  
 592                      } else {
 593                          if (DEBUG) Log.d(TAG, &quot;scheduling another run for widget &quot; + backupKey);

 594                          // too many widgets for this pass, request another.
 595                          dataChanged();
 596                      }
 597                  }
 598              }
 599          } finally {
 600              cursor.close();
 601          }
 602          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 603  
 604          // these IDs must have been deleted
 605          savedIds.removeAll(currentIds);
 606          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 607      }
 608  
 609      /**
 610       * Read a widget from the stream.
 611       *
 612       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 613       *
 614       * @param key identifier for the row
 615       * @param buffer the serialized proto from the stream, may be larger than dataSize
 616       * @param dataSize the size of the proto from the stream
 617       * @param keys keys to mark as clean in the notes for next backup
 618       */
 619      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 620          Log.v(TAG, &quot;unpacking widget &quot; + key.id);

 621          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 622                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 623          try {
 624              Widget widget = unpackWidget(buffer, 0, dataSize);
 625              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 626              if (widget.icon.data != null)  {
 627                  Bitmap icon = BitmapFactory
 628                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 629                  if (icon == null) {
 630                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);



 631                  }
 632              }







 633          } catch (InvalidProtocolBufferNanoException e) {
 634              Log.w(TAG, &quot;failed to decode proto&quot;, e);

 635          }
 636      }
 637  
 638      /** create a new key, with an integer ID.
 639       *
 640       * &lt;P&gt; Keys contain their own checksum instead of using
 641       * the heavy-weight CheckedMessage wrapper.
 642       */
 643      private Key getKey(int type, long id) {
 644          Key key = new Key();
 645          key.type = type;
 646          key.id = id;
 647          key.checksum = checkKey(key);
 648          return key;
 649      }
 650  
 651      /** create a new key for a named object.
 652       *
 653       * &lt;P&gt; Keys contain their own checksum instead of using
 654       * the heavy-weight CheckedMessage wrapper.
 655       */
 656      private Key getKey(int type, String name) {
 657          Key key = new Key();
 658          key.type = type;
 659          key.name = name;
 660          key.checksum = checkKey(key);
 661          return key;
 662      }
 663  
 664      /** keys need to be strings, serialize and encode. */
 665      private String keyToBackupKey(Key key) {
 666          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 667      }
 668  
 669      /** keys need to be strings, decode and parse. */
 670      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 671          try {
 672              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 673              if (key.checksum != checkKey(key)) {
 674                  key = null;
 675                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 676              }
 677              return key;
 678          } catch (InvalidProtocolBufferNanoException e) {
 679              throw new KeyParsingException(e);
 680          } catch (IllegalArgumentException e) {
 681              throw new KeyParsingException(e);
 682          }
 683      }
 684  
 685      private String getKeyName(Key key) {
 686          if (TextUtils.isEmpty(key.name)) {
 687              return Long.toString(key.id);
 688          } else {
 689              return key.name;
 690          }
 691  
 692      }
 693  
 694      private String geKeyType(Key key) {
 695          switch (key.type) {
 696              case Key.FAVORITE:
 697                  return &quot;favorite&quot;;
 698              case Key.SCREEN:
 699                  return &quot;screen&quot;;
 700              case Key.ICON:
 701                  return &quot;icon&quot;;
 702              case Key.WIDGET:
 703                  return &quot;widget&quot;;
 704              default:
 705                  return &quot;anonymous&quot;;
 706          }
 707      }
 708  
 709      /** Compute the checksum over the important bits of a key. */
 710      private long checkKey(Key key) {
 711          CRC32 checksum = new CRC32();
 712          checksum.update(key.type);
 713          checksum.update((int) (key.id &amp; 0xffff));
 714          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 715          if (!TextUtils.isEmpty(key.name)) {
 716              checksum.update(key.name.getBytes());
 717          }
 718          return checksum.getValue();
 719      }
 720  
 721      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 722      private byte[] packFavorite(Cursor c) {
 723          Favorite favorite = new Favorite();
 724          favorite.id = c.getLong(ID_INDEX);
 725          favorite.screen = c.getInt(SCREEN_INDEX);
 726          favorite.container = c.getInt(CONTAINER_INDEX);
 727          favorite.cellX = c.getInt(CELLX_INDEX);
 728          favorite.cellY = c.getInt(CELLY_INDEX);
 729          favorite.spanX = c.getInt(SPANX_INDEX);
 730          favorite.spanY = c.getInt(SPANY_INDEX);
 731          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 732          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 733              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 734              if (!TextUtils.isEmpty(iconPackage)) {
 735                  favorite.iconPackage = iconPackage;
 736              }
 737              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 738              if (!TextUtils.isEmpty(iconResource)) {
 739                  favorite.iconResource = iconResource;
 740              }
 741          }
 742          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 743              byte[] blob = c.getBlob(ICON_INDEX);
 744              if (blob != null &amp;&amp; blob.length &gt; 0) {
 745                  favorite.icon = blob;
 746              }
 747          }
 748          String title = c.getString(TITLE_INDEX);
 749          if (!TextUtils.isEmpty(title)) {
 750              favorite.title = title;
 751          }
 752          String intent = c.getString(INTENT_INDEX);
 753          if (!TextUtils.isEmpty(intent)) {
 754              favorite.intent = intent;









 755          }
 756          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 757          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 758              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 759              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 760              if (!TextUtils.isEmpty(appWidgetProvider)) {
 761                  favorite.appWidgetProvider = appWidgetProvider;
 762              }
 763          }
 764  
 765          return writeCheckedBytes(favorite);
 766      }
 767  
 768      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 769      private Favorite unpackFavorite(byte[] buffer, int offset, int dataSize)

 770              throws InvalidProtocolBufferNanoException {
 771          Favorite favorite = new Favorite();
 772          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 773          return favorite;
















































 774      }
 775  
 776      /** Serialize a Screen for persistence, including a checksum wrapper. */
 777      private byte[] packScreen(Cursor c) {
 778          Screen screen = new Screen();
 779          screen.id = c.getLong(ID_INDEX);
 780          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 781  
 782          return writeCheckedBytes(screen);
 783      }
 784  
 785      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 786      private Screen unpackScreen(byte[] buffer, int offset, int dataSize)

 787              throws InvalidProtocolBufferNanoException {
 788          Screen screen = new Screen();
 789          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 790          return screen;





 791      }
 792  
 793      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 794      private byte[] packIcon(int dpi, Bitmap icon) {
 795          Resource res = new Resource();
 796          res.dpi = dpi;
 797          ByteArrayOutputStream os = new ByteArrayOutputStream();
 798          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 799              res.data = os.toByteArray();
 800          }
 801          return writeCheckedBytes(res);
 802      }
 803  
 804      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 805      private Resource unpackIcon(byte[] buffer, int offset, int dataSize)

 806              throws InvalidProtocolBufferNanoException {
 807          Resource res = new Resource();
 808          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));

 809          return res;
 810      }
 811  
 812      /** Serialize a widget for persistence, including a checksum wrapper. */
 813      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 814              ComponentName provider) {
 815          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 816          Widget widget = new Widget();
 817          widget.provider = provider.flattenToShortString();
 818          widget.label = info.label;
 819          widget.configure = info.configure != null;
 820          if (info.icon != 0) {
 821              widget.icon = new Resource();
 822              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 823              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 824              ByteArrayOutputStream os = new ByteArrayOutputStream();
 825              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 826                  widget.icon.data = os.toByteArray();
 827                  widget.icon.dpi = dpi;
 828              }
 829          }
 830          if (info.previewImage != 0) {
 831              widget.preview = new Resource();
 832              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 833              ByteArrayOutputStream os = new ByteArrayOutputStream();
 834              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 835                  widget.preview.data = os.toByteArray();
 836                  widget.preview.dpi = dpi;
 837              }
 838          }
 839          return writeCheckedBytes(widget);
 840      }
 841  
 842      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 843      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 844              throws InvalidProtocolBufferNanoException {
 845          Widget widget = new Widget();
 846          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));

 847          return widget;
 848      }
 849  
 850      /**
 851       * Read the old journal from the input file.
 852       *
 853       * In the event of any error, just pretend we didn&#x27;t have a journal,
 854       * in that case, do a full backup.
 855       *
 856       * @param oldState the read-0only file descriptor pointing to the old journal
 857       * @return a Journal protocol bugffer

 858       */
 859      private Journal readJournal(ParcelFileDescriptor oldState) {
 860          Journal journal = new Journal();
 861          if (oldState == null) {
 862              return journal;
 863          }
 864          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 865          try {
 866              int remaining = inStream.available();
 867              if (DEBUG) Log.d(TAG, &quot;available &quot; + remaining);
 868              if (remaining &lt; MAX_JOURNAL_SIZE) {
 869                  byte[] buffer = new byte[remaining];




 870                  int bytesRead = 0;
 871                  while (remaining &gt; 0) {



 872                      try {
 873                          int result = inStream.read(buffer, bytesRead, remaining);





 874                          if (result &gt; 0) {
 875                              if (DEBUG) Log.d(TAG, &quot;read some bytes: &quot; + result);
 876                              remaining -= result;

 877                              bytesRead += result;



 878                          } else {
 879                              // stop reading ands see what there is to parse
 880                              Log.w(TAG, &quot;read error: &quot; + result);
 881                              remaining = 0;



 882                          }
 883                      } catch (IOException e) {
 884                          Log.w(TAG, &quot;failed to read the journal&quot;, e);
 885                          buffer = null;
 886                          remaining = 0;














 887                      }
 888                  }
 889                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
 890  
 891                  if (buffer != null) {
 892                      try {
 893                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
 894                      } catch (InvalidProtocolBufferNanoException e) {
 895                          Log.d(TAG, &quot;failed to read the journal&quot;, e);
 896                          journal.clear();
 897                      }


 898                  }
 899              }
 900          } catch (IOException e) {
 901              Log.d(TAG, &quot;failed to close the journal&quot;, e);

 902          } finally {
 903              try {
 904                  inStream.close();
 905              } catch (IOException e) {
 906                  Log.d(TAG, &quot;failed to close the journal&quot;, e);

 907              }
 908          }
 909          return journal;
 910      }
 911  
 912      private void writeRowToBackup(Key key, byte[] blob, Journal out,
 913              BackupDataOutput data) throws IOException {
 914          String backupKey = keyToBackupKey(key);
 915          data.writeEntityHeader(backupKey, blob.length);
 916          data.writeEntityData(blob, blob.length);
 917          out.rows++;
 918          out.bytes += blob.length;
 919          Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +

 920                  getKeyName(key) + &quot;/&quot; + blob.length);
 921          if(DEBUG_PAYLOAD) {
 922              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
 923              final int chunkSize = 1024;
 924              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
 925                  int end = offset + chunkSize;
 926                  end = Math.min(end, encoded.length());
 927                  Log.d(TAG, &quot;wrote &quot; + encoded.substring(offset, end));

 928              }
 929          }
 930      }
 931  
 932      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
 933          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
 934          for(int i = 0; i &lt; in.key.length; i++) {
 935              Key key = in.key[i];
 936              if (key.type == type) {
 937                  savedIds.add(keyToBackupKey(key));
 938              }
 939          }
 940          return savedIds;
 941      }
 942  
 943      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
 944              throws IOException {
 945          int rows = 0;
 946          for(String deleted: deletedIds) {
 947              Log.v(TAG, &quot;dropping icon &quot; + deleted);

 948              data.writeEntityHeader(deleted, -1);
 949              rows++;
 950          }
 951          return rows;
 952      }
 953  
 954      /**
 955       * Write the new journal to the output file.
 956       *
 957       * In the event of any error, just pretend we didn&#x27;t have a journal,
 958       * in that case, do a full backup.
 959  
 960       * @param newState the write-only file descriptor pointing to the new journal
 961       * @param journal a Journal protocol buffer
 962       */
 963      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
 964          FileOutputStream outStream = null;
 965          try {
 966              outStream = new FileOutputStream(newState.getFileDescriptor());
 967              outStream.write(writeCheckedBytes(journal));


 968              outStream.close();

 969          } catch (IOException e) {
 970              Log.d(TAG, &quot;failed to write backup journal&quot;, e);

 971          }
 972      }
 973  
 974      /** Wrap a proto in a CheckedMessage and compute the checksum. */
 975      private byte[] writeCheckedBytes(MessageNano proto) {
 976          CheckedMessage wrapper = new CheckedMessage();
 977          wrapper.payload = MessageNano.toByteArray(proto);
 978          CRC32 checksum = new CRC32();
 979          checksum.update(wrapper.payload);
 980          wrapper.checksum = checksum.getValue();
 981          return MessageNano.toByteArray(wrapper);
 982      }
 983  
 984      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
 985      private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)

 986              throws InvalidProtocolBufferNanoException {
 987          CheckedMessage wrapper = new CheckedMessage();
 988          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
 989          CRC32 checksum = new CRC32();
 990          checksum.update(wrapper.payload);
 991          if (wrapper.checksum != checksum.getValue()) {
 992              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
 993          }
 994          return wrapper.payload;
 995      }
 996  
 997      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
 998          if (mWidgetMap == null) {
 999              List&lt;AppWidgetProviderInfo&gt; widgets =
1000                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1001              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1002              for (AppWidgetProviderInfo info : widgets) {
1003                  mWidgetMap.put(info.provider, info);
1004              }
1005          }
1006          return mWidgetMap.get(component);
1007      }
1008  










































1009      private class KeyParsingException extends Throwable {
1010          private KeyParsingException(Throwable cause) {
1011              super(cause);
1012          }
1013  
1014          public KeyParsingException(String reason) {
1015              super(reason);
1016          }
1017      }
1018  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            