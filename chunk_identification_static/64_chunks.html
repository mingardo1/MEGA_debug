<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>64 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import java.io.*;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//import org.apache.log4j.Logger;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                         &#x27;a\n&#x27;
                         &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                         &#x27;private buffer so that most\n&#x27;
                         &#x27; * operations do not require a disk access.\n&#x27;
                         &#x27; * &lt;P&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Note: The operations on this class are &#x27;
                         &#x27;unmonitored. Also, the correct\n&#x27;
                         &#x27; * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; &#x27;
                         &#x27;methods that are not\n&#x27;
                         &#x27; * overridden here relies on the implementation of &#x27;
                         &#x27;those methods in the\n&#x27;
                         &#x27; * superclass.\n&#x27;
                         &#x27; * Author : Avinash Lakshman ( &#x27;
                         &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                         &#x27;pmalik@facebook.com )\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public final class BufferedRandomAccessFile extends &#x27;
                         &#x27;RandomAccessFile {\n&#x27;
                         &#x27;  //private static final Logger logger_ = &#x27;
                         &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                         &#x27;  static final        int  LogBuffSz_ = 16; // 64K &#x27;
                         &#x27;buffer\n&#x27;
                         &#x27;  public static final int  BuffSz_    = (1 &lt;&lt; &#x27;
                         &#x27;LogBuffSz_);\n&#x27;
                         &#x27;  static final        long BuffMask_  = ~(((long) &#x27;
                         &#x27;BuffSz_) - 1L);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /*\n&#x27;
                         &#x27;   * This implementation is based on the buffer &#x27;
                         &quot;implementation in Modula-3&#x27;s\n&quot;
                         &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                         &#x27;interfaces.\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                         &#x27;bytes exist\n&#x27;
                         &#x27;  private boolean closed_; // true iff the file is &#x27;
                         &#x27;closed\n&#x27;
                         &#x27;  private long    curr_; // current position in &#x27;
                         &#x27;file\n&#x27;
                         &#x27;  private long    lo_, hi_; // bounds on characters &#x27;
                         &#x27;in &quot;buff&quot;\n&#x27;
                         &#x27;  private byte[]  buff_; // local buffer\n&#x27;
                         &#x27;  private long    maxHi_; // this.lo + &#x27;
                         &#x27;this.buff.length\n&#x27;
                         &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                         &#x27;file block?\n&#x27;
                         &#x27;  private long    diskPos_; // disk position\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.FileNotFoundException;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.RandomAccessFile;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//import org.apache.log4j.Logger;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                           &#x27;a\n&#x27;
                           &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                           &#x27;private buffer so that most\n&#x27;
                           &#x27; * operations do not require a disk access.\n&#x27;
                           &#x27; * &lt;P&gt;\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Note: The operations on this class are &#x27;
                           &#x27;unmonitored. Also, the correct\n&#x27;
                           &#x27; * functioning of the &#x27;
                           &#x27;&lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are &#x27;
                           &#x27;not\n&#x27;
                           &#x27; * overridden here relies on the implementation of &#x27;
                           &#x27;those methods in the\n&#x27;
                           &#x27; * superclass.\n&#x27;
                           &#x27; * Author : Avinash Lakshman ( &#x27;
                           &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                           &#x27;pmalik@facebook.com )\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public final class BufferedRandomAccessFile &#x27;
                           &#x27;extends RandomAccessFile {\n&#x27;
                           &#x27;  //private static final Logger logger_ = &#x27;
                           &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                           &#x27;  static final int LogBuffSz_ = 16; // 64K buffer\n&#x27;
                           &#x27;  public static final int BuffSz_ = (1 &lt;&lt; &#x27;
                           &#x27;LogBuffSz_);\n&#x27;
                           &#x27;  static final long BuffMask_ = ~(((long) BuffSz_) &#x27;
                           &#x27;- 1L);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /*\n&#x27;
                           &#x27;   * This implementation is based on the buffer &#x27;
                           &quot;implementation in Modula-3&#x27;s\n&quot;
                           &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                           &#x27;interfaces.\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                           &#x27;bytes exist\n&#x27;
                           &#x27;  private boolean closed_; // true iff the file is &#x27;
                           &#x27;closed\n&#x27;
                           &#x27;  private long curr_; // current position in file\n&#x27;
                           &#x27;  private long lo_, hi_; // bounds on characters &#x27;
                           &#x27;in &quot;buff&quot;\n&#x27;
                           &#x27;  private byte[] buff_; // local buffer\n&#x27;
                           &#x27;  private long maxHi_; // this.lo + &#x27;
                           &#x27;this.buff.length\n&#x27;
                           &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                           &#x27;file block?\n&#x27;
                           &#x27;  private long diskPos_; // disk position\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import java.io.*;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//import org.apache.log4j.Logger;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                         &#x27;a\n&#x27;
                         &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                         &#x27;private buffer so that most\n&#x27;
                         &#x27; * operations do not require a disk access.\n&#x27;
                         &#x27; * &lt;P&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Note: The operations on this class are &#x27;
                         &#x27;unmonitored. Also, the correct\n&#x27;
                         &#x27; * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; &#x27;
                         &#x27;methods that are not\n&#x27;
                         &#x27; * overridden here relies on the implementation of &#x27;
                         &#x27;those methods in the\n&#x27;
                         &#x27; * superclass.\n&#x27;
                         &#x27; * Author : Avinash Lakshman ( &#x27;
                         &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                         &#x27;pmalik@facebook.com )\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public final class BufferedRandomAccessFile extends &#x27;
                         &#x27;RandomAccessFile {\n&#x27;
                         &#x27;  //private static final Logger logger_ = &#x27;
                         &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                         &#x27;  static final        int  LogBuffSz_ = 16; // 64K &#x27;
                         &#x27;buffer\n&#x27;
                         &#x27;  public static final int  BuffSz_    = (1 &lt;&lt; &#x27;
                         &#x27;LogBuffSz_);\n&#x27;
                         &#x27;  static final        long BuffMask_  = ~(((long) &#x27;
                         &#x27;BuffSz_) - 1L);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /*\n&#x27;
                         &#x27;   * This implementation is based on the buffer &#x27;
                         &quot;implementation in Modula-3&#x27;s\n&quot;
                         &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                         &#x27;interfaces.\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                         &#x27;bytes exist\n&#x27;
                         &#x27;  private boolean closed_; // true iff the file is &#x27;
                         &#x27;closed\n&#x27;
                         &#x27;  private long    curr_; // current position in &#x27;
                         &#x27;file\n&#x27;
                         &#x27;  private long    lo_, hi_; // bounds on characters &#x27;
                         &#x27;in &quot;buff&quot;\n&#x27;
                         &#x27;  private byte[]  buff_; // local buffer\n&#x27;
                         &#x27;  private long    maxHi_; // this.lo + &#x27;
                         &#x27;this.buff.length\n&#x27;
                         &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                         &#x27;file block?\n&#x27;
                         &#x27;  private long    diskPos_; // disk position\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.FileNotFoundException;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.RandomAccessFile;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//import org.apache.log4j.Logger;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                           &#x27;a\n&#x27;
                           &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                           &#x27;private buffer so that most\n&#x27;
                           &#x27; * operations do not require a disk access.\n&#x27;
                           &#x27; * &lt;P&gt;\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Note: The operations on this class are &#x27;
                           &#x27;unmonitored. Also, the correct\n&#x27;
                           &#x27; * functioning of the &#x27;
                           &#x27;&lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are &#x27;
                           &#x27;not\n&#x27;
                           &#x27; * overridden here relies on the implementation of &#x27;
                           &#x27;those methods in the\n&#x27;
                           &#x27; * superclass.\n&#x27;
                           &#x27; * Author : Avinash Lakshman ( &#x27;
                           &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                           &#x27;pmalik@facebook.com )\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public final class BufferedRandomAccessFile &#x27;
                           &#x27;extends RandomAccessFile {\n&#x27;
                           &#x27;  //private static final Logger logger_ = &#x27;
                           &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                           &#x27;  static final int LogBuffSz_ = 16; // 64K buffer\n&#x27;
                           &#x27;  public static final int BuffSz_ = (1 &lt;&lt; &#x27;
                           &#x27;LogBuffSz_);\n&#x27;
                           &#x27;  static final long BuffMask_ = ~(((long) BuffSz_) &#x27;
                           &#x27;- 1L);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /*\n&#x27;
                           &#x27;   * This implementation is based on the buffer &#x27;
                           &quot;implementation in Modula-3&#x27;s\n&quot;
                           &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                           &#x27;interfaces.\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                           &#x27;bytes exist\n&#x27;
                           &#x27;  private boolean closed_; // true iff the file is &#x27;
                           &#x27;closed\n&#x27;
                           &#x27;  private long curr_; // current position in file\n&#x27;
                           &#x27;  private long lo_, hi_; // bounds on characters &#x27;
                           &#x27;in &quot;buff&quot;\n&#x27;
                           &#x27;  private byte[] buff_; // local buffer\n&#x27;
                           &#x27;  private long maxHi_; // this.lo + &#x27;
                           &#x27;this.buff.length\n&#x27;
                           &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                           &#x27;file block?\n&#x27;
                           &#x27;  private long diskPos_; // disk position\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import java.io.*;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//import org.apache.log4j.Logger;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                         &#x27;a\n&#x27;
                         &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                         &#x27;private buffer so that most\n&#x27;
                         &#x27; * operations do not require a disk access.\n&#x27;
                         &#x27; * &lt;P&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Note: The operations on this class are &#x27;
                         &#x27;unmonitored. Also, the correct\n&#x27;
                         &#x27; * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; &#x27;
                         &#x27;methods that are not\n&#x27;
                         &#x27; * overridden here relies on the implementation of &#x27;
                         &#x27;those methods in the\n&#x27;
                         &#x27; * superclass.\n&#x27;
                         &#x27; * Author : Avinash Lakshman ( &#x27;
                         &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                         &#x27;pmalik@facebook.com )\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public final class BufferedRandomAccessFile extends &#x27;
                         &#x27;RandomAccessFile {\n&#x27;
                         &#x27;  //private static final Logger logger_ = &#x27;
                         &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                         &#x27;  static final        int  LogBuffSz_ = 16; // 64K &#x27;
                         &#x27;buffer\n&#x27;
                         &#x27;  public static final int  BuffSz_    = (1 &lt;&lt; &#x27;
                         &#x27;LogBuffSz_);\n&#x27;
                         &#x27;  static final        long BuffMask_  = ~(((long) &#x27;
                         &#x27;BuffSz_) - 1L);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /*\n&#x27;
                         &#x27;   * This implementation is based on the buffer &#x27;
                         &quot;implementation in Modula-3&#x27;s\n&quot;
                         &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                         &#x27;interfaces.\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                         &#x27;bytes exist\n&#x27;
                         &#x27;  private boolean closed_; // true iff the file is &#x27;
                         &#x27;closed\n&#x27;
                         &#x27;  private long    curr_; // current position in &#x27;
                         &#x27;file\n&#x27;
                         &#x27;  private long    lo_, hi_; // bounds on characters &#x27;
                         &#x27;in &quot;buff&quot;\n&#x27;
                         &#x27;  private byte[]  buff_; // local buffer\n&#x27;
                         &#x27;  private long    maxHi_; // this.lo + &#x27;
                         &#x27;this.buff.length\n&#x27;
                         &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                         &#x27;file block?\n&#x27;
                         &#x27;  private long    diskPos_; // disk position\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.FileNotFoundException;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.RandomAccessFile;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//import org.apache.log4j.Logger;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                           &#x27;a\n&#x27;
                           &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                           &#x27;private buffer so that most\n&#x27;
                           &#x27; * operations do not require a disk access.\n&#x27;
                           &#x27; * &lt;P&gt;\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Note: The operations on this class are &#x27;
                           &#x27;unmonitored. Also, the correct\n&#x27;
                           &#x27; * functioning of the &#x27;
                           &#x27;&lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are &#x27;
                           &#x27;not\n&#x27;
                           &#x27; * overridden here relies on the implementation of &#x27;
                           &#x27;those methods in the\n&#x27;
                           &#x27; * superclass.\n&#x27;
                           &#x27; * Author : Avinash Lakshman ( &#x27;
                           &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                           &#x27;pmalik@facebook.com )\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public final class BufferedRandomAccessFile &#x27;
                           &#x27;extends RandomAccessFile {\n&#x27;
                           &#x27;  //private static final Logger logger_ = &#x27;
                           &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                           &#x27;  static final int LogBuffSz_ = 16; // 64K buffer\n&#x27;
                           &#x27;  public static final int BuffSz_ = (1 &lt;&lt; &#x27;
                           &#x27;LogBuffSz_);\n&#x27;
                           &#x27;  static final long BuffMask_ = ~(((long) BuffSz_) &#x27;
                           &#x27;- 1L);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /*\n&#x27;
                           &#x27;   * This implementation is based on the buffer &#x27;
                           &quot;implementation in Modula-3&#x27;s\n&quot;
                           &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                           &#x27;interfaces.\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                           &#x27;bytes exist\n&#x27;
                           &#x27;  private boolean closed_; // true iff the file is &#x27;
                           &#x27;closed\n&#x27;
                           &#x27;  private long curr_; // current position in file\n&#x27;
                           &#x27;  private long lo_, hi_; // bounds on characters &#x27;
                           &#x27;in &quot;buff&quot;\n&#x27;
                           &#x27;  private byte[] buff_; // local buffer\n&#x27;
                           &#x27;  private long maxHi_; // this.lo + &#x27;
                           &#x27;this.buff.length\n&#x27;
                           &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                           &#x27;file block?\n&#x27;
                           &#x27;  private long diskPos_; // disk position\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;import java.io.*;\n&#x27;
                         &#x27;import java.util.Arrays;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//import org.apache.log4j.Logger;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                         &#x27;a\n&#x27;
                         &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                         &#x27;private buffer so that most\n&#x27;
                         &#x27; * operations do not require a disk access.\n&#x27;
                         &#x27; * &lt;P&gt;\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Note: The operations on this class are &#x27;
                         &#x27;unmonitored. Also, the correct\n&#x27;
                         &#x27; * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; &#x27;
                         &#x27;methods that are not\n&#x27;
                         &#x27; * overridden here relies on the implementation of &#x27;
                         &#x27;those methods in the\n&#x27;
                         &#x27; * superclass.\n&#x27;
                         &#x27; * Author : Avinash Lakshman ( &#x27;
                         &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                         &#x27;pmalik@facebook.com )\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public final class BufferedRandomAccessFile extends &#x27;
                         &#x27;RandomAccessFile {\n&#x27;
                         &#x27;  //private static final Logger logger_ = &#x27;
                         &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                         &#x27;  static final        int  LogBuffSz_ = 16; // 64K &#x27;
                         &#x27;buffer\n&#x27;
                         &#x27;  public static final int  BuffSz_    = (1 &lt;&lt; &#x27;
                         &#x27;LogBuffSz_);\n&#x27;
                         &#x27;  static final        long BuffMask_  = ~(((long) &#x27;
                         &#x27;BuffSz_) - 1L);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;  /*\n&#x27;
                         &#x27;   * This implementation is based on the buffer &#x27;
                         &quot;implementation in Modula-3&#x27;s\n&quot;
                         &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                         &#x27;interfaces.\n&#x27;
                         &#x27;   */\n&#x27;
                         &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                         &#x27;bytes exist\n&#x27;
                         &#x27;  private boolean closed_; // true iff the file is &#x27;
                         &#x27;closed\n&#x27;
                         &#x27;  private long    curr_; // current position in &#x27;
                         &#x27;file\n&#x27;
                         &#x27;  private long    lo_, hi_; // bounds on characters &#x27;
                         &#x27;in &quot;buff&quot;\n&#x27;
                         &#x27;  private byte[]  buff_; // local buffer\n&#x27;
                         &#x27;  private long    maxHi_; // this.lo + &#x27;
                         &#x27;this.buff.length\n&#x27;
                         &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                         &#x27;file block?\n&#x27;
                         &#x27;  private long    diskPos_; // disk position\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import java.io.File;\n&#x27;
                           &#x27;import java.io.FileNotFoundException;\n&#x27;
                           &#x27;import java.io.IOException;\n&#x27;
                           &#x27;import java.io.RandomAccessFile;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//import org.apache.log4j.Logger;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like &#x27;
                           &#x27;a\n&#x27;
                           &#x27; * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a &#x27;
                           &#x27;private buffer so that most\n&#x27;
                           &#x27; * operations do not require a disk access.\n&#x27;
                           &#x27; * &lt;P&gt;\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Note: The operations on this class are &#x27;
                           &#x27;unmonitored. Also, the correct\n&#x27;
                           &#x27; * functioning of the &#x27;
                           &#x27;&lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are &#x27;
                           &#x27;not\n&#x27;
                           &#x27; * overridden here relies on the implementation of &#x27;
                           &#x27;those methods in the\n&#x27;
                           &#x27; * superclass.\n&#x27;
                           &#x27; * Author : Avinash Lakshman ( &#x27;
                           &#x27;alakshman@facebook.com) Prashant Malik ( &#x27;
                           &#x27;pmalik@facebook.com )\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;public final class BufferedRandomAccessFile &#x27;
                           &#x27;extends RandomAccessFile {\n&#x27;
                           &#x27;  //private static final Logger logger_ = &#x27;
                           &#x27;Logger.getLogger(BufferedRandomAccessFile.class);\n&#x27;
                           &#x27;  static final int LogBuffSz_ = 16; // 64K buffer\n&#x27;
                           &#x27;  public static final int BuffSz_ = (1 &lt;&lt; &#x27;
                           &#x27;LogBuffSz_);\n&#x27;
                           &#x27;  static final long BuffMask_ = ~(((long) BuffSz_) &#x27;
                           &#x27;- 1L);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  /*\n&#x27;
                           &#x27;   * This implementation is based on the buffer &#x27;
                           &quot;implementation in Modula-3&#x27;s\n&quot;
                           &#x27;   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; &#x27;
                           &#x27;interfaces.\n&#x27;
                           &#x27;   */\n&#x27;
                           &#x27;  private boolean dirty_; // true iff unflushed &#x27;
                           &#x27;bytes exist\n&#x27;
                           &#x27;  private boolean closed_; // true iff the file is &#x27;
                           &#x27;closed\n&#x27;
                           &#x27;  private long curr_; // current position in file\n&#x27;
                           &#x27;  private long lo_, hi_; // bounds on characters &#x27;
                           &#x27;in &quot;buff&quot;\n&#x27;
                           &#x27;  private byte[] buff_; // local buffer\n&#x27;
                           &#x27;  private long maxHi_; // this.lo + &#x27;
                           &#x27;this.buff.length\n&#x27;
                           &#x27;  private boolean hitEOF_; // buffer contains last &#x27;
                           &#x27;file block?\n&#x27;
                           &#x27;  private long diskPos_; // disk position\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        