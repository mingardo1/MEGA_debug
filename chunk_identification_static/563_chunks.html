<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>563 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Copyright 2020, Google LLC.\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                         &#x27;(the &quot;License&quot;);\n&#x27;
                         &#x27; * you may not use this file except in compliance &#x27;
                         &#x27;with the License.\n&#x27;
                         &#x27; * You may obtain a copy of the License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package anthos.samples.financedemo.ledgerwriter;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.util.concurrent.TimeUnit;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import org.apache.logging.log4j.LogManager;\n&#x27;
                         &#x27;import org.apache.logging.log4j.Logger;\n&#x27;
                         &#x27;import  &#x27;
                         &#x27;org.springframework.web.client.HttpServerErrorException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Value;\n&#x27;
                         &#x27;import org.springframework.http.HttpEntity;\n&#x27;
                         &#x27;import org.springframework.http.HttpHeaders;\n&#x27;
                         &#x27;import org.springframework.http.HttpMethod;\n&#x27;
                         &#x27;import org.springframework.http.HttpStatus;\n&#x27;
                         &#x27;import org.springframework.http.ResponseEntity;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.transaction.CannotCreateTransactionException;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.GetMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.PostMapping;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestBody;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RequestHeader;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.ResponseStatus;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.bind.annotation.RestController;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.web.client.ResourceAccessException;\n&#x27;
                         &#x27;import org.springframework.web.client.RestTemplate;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.auth0.jwt.JWTVerifier;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.auth0.jwt.exceptions.JWTVerificationException;\n&#x27;
                         &#x27;import com.auth0.jwt.interfaces.DecodedJWT;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.google.common.cache.Cache;\n&#x27;
                         &#x27;import com.google.common.cache.CacheBuilder;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL;\n&#x27;
                         &#x27;import static &#x27;
                         &#x27;anthos.samples.financedemo.ledgerwriter.ExceptionMessages.\n&#x27;
                         &#x27;        EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;@RestController\n&#x27;
                         &#x27;public final class LedgerWriterController {\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private static final Logger LOGGER =\n&#x27;
                         &#x27;        &#x27;
                         &#x27;LogManager.getLogger(LedgerWriterController.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private TransactionRepository &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;    private TransactionValidator &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;    private JWTVerifier verifier;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private String localRoutingNum;\n&#x27;
                         &#x27;    private String balancesApiUri;\n&#x27;
                         &#x27;    private String version;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private Cache&lt;String, Long&gt; cache;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public static final String READINESS_CODE = &#x27;
                         &#x27;&quot;ok&quot;;\n&#x27;
                         &#x27;    public static final String UNAUTHORIZED_CODE = &#x27;
                         &#x27;&quot;not authorized&quot;;\n&#x27;
                         &#x27;    public static final String JWT_ACCOUNT_KEY = &#x27;
                         &#x27;&quot;acct&quot;;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;    * Constructor.\n&#x27;
                         &#x27;    *\n&#x27;
                         &#x27;    * Initializes JWT verifier.\n&#x27;
                         &#x27;    */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public LedgerWriterController(\n&#x27;
                         &#x27;            JWTVerifier verifier,\n&#x27;
                         &#x27;            TransactionRepository &#x27;
                         &#x27;transactionRepository,\n&#x27;
                         &#x27;            TransactionValidator &#x27;
                         &#x27;transactionValidator,\n&#x27;
                         &#x27;            @Value(&quot;${LOCAL_ROUTING_NUM}&quot;) String &#x27;
                         &#x27;localRoutingNum,\n&#x27;
                         &#x27;            &#x27;
                         &#x27;@Value(&quot;http://${BALANCES_API_ADDR}/balances&quot;)\n&#x27;
                         &#x27;                    String balancesApiUri,\n&#x27;
                         &#x27;            @Value(&quot;${VERSION}&quot;) String version) {\n&#x27;
                         &#x27;        this.verifier = verifier;\n&#x27;
                         &#x27;        this.transactionRepository = &#x27;
                         &#x27;transactionRepository;\n&#x27;
                         &#x27;        this.transactionValidator = &#x27;
                         &#x27;transactionValidator;\n&#x27;
                         &#x27;        this.localRoutingNum = localRoutingNum;\n&#x27;
                         &#x27;        this.balancesApiUri = balancesApiUri;\n&#x27;
                         &#x27;        this.version = version;\n&#x27;
                         &#x27;        // Initialize cache to ignore duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;        this.cache = CacheBuilder.newBuilder()\n&#x27;
                         &#x27;                            .expireAfterWrite(1, &#x27;
                         &#x27;TimeUnit.HOURS)\n&#x27;
                         &#x27;                            .build();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Version endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  service version string\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/version&quot;)\n&#x27;
                         &#x27;    public ResponseEntity version() {\n&#x27;
                         &#x27;        return new ResponseEntity&lt;String&gt;(version, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Readiness probe endpoint.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return HTTP Status 200 if server is ready to &#x27;
                         &#x27;receive requests.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @GetMapping(&quot;/ready&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;String&gt; readiness() {\n&#x27;
                         &#x27;        return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE, &#x27;
                         &#x27;HttpStatus.OK);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Submit a new transaction to the ledger.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param bearerToken  HTTP request &#x27;
                         &quot;&#x27;Authorization&#x27; header\n&quot;
                         &#x27;     * @param transaction  transaction to submit\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return  HTTP Status 200 if transaction was &#x27;
                         &#x27;successfully submitted\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @PostMapping(value = &quot;/transactions&quot;, consumes = &#x27;
                         &#x27;&quot;application/json&quot;)\n&#x27;
                         &#x27;    @ResponseStatus(HttpStatus.OK)\n&#x27;
                         &#x27;    public ResponseEntity&lt;?&gt; addTransaction(\n&#x27;
                         &#x27;            @RequestHeader(&quot;Authorization&quot;) String &#x27;
                         &#x27;bearerToken,\n&#x27;
                         &#x27;            @RequestBody Transaction transaction) {\n&#x27;
                         &#x27;        if (bearerToken != null &amp;&amp; &#x27;
                         &#x27;bearerToken.startsWith(&quot;Bearer &quot;)) {\n&#x27;
                         &#x27;            bearerToken = bearerToken.split(&quot;Bearer &#x27;
                         &#x27;&quot;)[1];\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        try {\n&#x27;
                         &#x27;            if (bearerToken == null) {\n&#x27;
                         &#x27;                LOGGER.error(&quot;Transaction submission &#x27;
                         &#x27;failed: &quot;\n&#x27;
                         &#x27;                    + &quot;Authorization header null&quot;);\n&#x27;
                         &#x27;                throw new IllegalArgumentException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_WHEN_AUTHORIZATION_HEADER_NULL);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;            final DecodedJWT jwt = &#x27;
                         &#x27;this.verifier.verify(bearerToken);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // Check against cache for duplicate &#x27;
                         &#x27;transactions\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(this.cache.asMap().containsKey(transaction.getRequestUuid())) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                throw new IllegalStateException(\n&#x27;
                         &#x27;                        &#x27;
                         &#x27;EXCEPTION_MESSAGE_DUPLICATE_TRANSACTION);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // validate transaction\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionValidator.validateTransaction(localRoutingNum,\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;jwt.getClaim(JWT_ACCOUNT_KEY).asString(), &#x27;
                         &#x27;transaction);\n&#x27;
                         &#x27;            // Ensure sender balance can cover &#x27;
                         &#x27;transaction.\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(transaction.getFromRoutingNum().equals(localRoutingNum)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                int balance = getAvailableBalance(\n&#x27;
                         &#x27;                        bearerToken, &#x27;
                         &#x27;transaction.getFromAccountNum());\n&#x27;
                         &#x27;                if (balance &lt; &#x27;
                         &#x27;transaction.getAmount()) {\n&#x27;
                         &#x27;                    LOGGER.error(&quot;Transaction &#x27;
                         &#x27;submission failed: &quot;\n&#x27;
                         &#x27;                        + &quot;Insufficient balance&quot;);\n&#x27;
                         &#x27;                    throw new &#x27;
                         &#x27;IllegalStateException(\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;EXCEPTION_MESSAGE_INSUFFICIENT_BALANCE);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;            // No exceptions thrown. Add to ledger\n&#x27;
                         &#x27;            &#x27;
                         &#x27;transactionRepository.save(transaction);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;this.cache.put(transaction.getRequestUuid(),\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;transaction.getTransactionId());\n&#x27;
                         &#x27;            LOGGER.info(&quot;Submitted transaction &#x27;
                         &#x27;successfully&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(READINESS_CODE,\n&#x27;
                         &#x27;                    HttpStatus.CREATED);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        } catch (JWTVerificationException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to submit &#x27;
                         &#x27;transaction: &quot;\n&#x27;
                         &#x27;                + &quot;not authorized&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(UNAUTHORIZED_CODE,\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.UNAUTHORIZED);\n&#x27;
                         &#x27;        } catch (IllegalArgumentException | &#x27;
                         &#x27;IllegalStateException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance: &quot;\n&#x27;
                         &#x27;                + &quot;bad request&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.BAD_REQUEST);\n&#x27;
                         &#x27;        } catch (ResourceAccessException\n&#x27;
                         &#x27;                | CannotCreateTransactionException\n&#x27;
                         &#x27;                | HttpServerErrorException e) {\n&#x27;
                         &#x27;            LOGGER.error(&quot;Failed to retrieve account &#x27;
                         &#x27;balance&quot;);\n&#x27;
                         &#x27;            return new &#x27;
                         &#x27;ResponseEntity&lt;String&gt;(e.getMessage(),\n&#x27;
                         &#x27;                                              &#x27;
                         &#x27;HttpStatus.INTERNAL_SERVER_ERROR);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &quot;     * Retrieve the balance for the transaction&#x27;s &quot;
                         &#x27;sender.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param token  the token used to authenticate &#x27;
                         &#x27;request\n&#x27;
                         &#x27;     * @param fromAcct  sender account number\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @return available balance of the sender &#x27;
                         &#x27;account\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @throws HttpServerErrorException  if balance &#x27;
                         &#x27;service returns 500\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected int getAvailableBalance(String token, &#x27;
                         &#x27;String fromAcct)\n&#x27;
                         &#x27;            throws HttpServerErrorException {\n&#x27;
                         &#x27;        LOGGER.debug(&quot;Retrieving balance for &#x27;
                         &#x27;transaction sender&quot;);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HttpHeaders headers = new HttpHeaders();\n&#x27;
                         &#x27;        headers.set(&quot;Authorization&quot;, &quot;Bearer &quot; + &#x27;
                         &#x27;token);\n&#x27;
                         &#x27;        HttpEntity entity = new &#x27;
                         &#x27;HttpEntity(headers);\n&#x27;
                         &#x27;        RestTemplate restTemplate = new &#x27;
                         &#x27;RestTemplate();\n&#x27;
                         &#x27;        String uri = balancesApiUri + &quot;/&quot; + &#x27;
                         &#x27;fromAcct;\n&#x27;
                         &#x27;        ResponseEntity&lt;Integer&gt; response = &#x27;
                         &#x27;restTemplate.exchange(\n&#x27;
                         &#x27;            uri, HttpMethod.GET, entity, &#x27;
                         &#x27;Integer.class);\n&#x27;
                         &#x27;        Integer senderBalance = response.getBody();\n&#x27;
                         &#x27;        return senderBalance.intValue();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        