<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>563 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;/*\n&#x27;
                         &#x27; * Licensed to the Apache Software Foundation (ASF) &#x27;
                         &#x27;under one\n&#x27;
                         &#x27; * or more contributor license agreements.  See the &#x27;
                         &#x27;NOTICE file\n&#x27;
                         &#x27; * distributed with this work for additional &#x27;
                         &#x27;information\n&#x27;
                         &#x27; * regarding copyright ownership.  The ASF licenses &#x27;
                         &#x27;this file\n&#x27;
                         &#x27; * to you under the Apache License, Version 2.0 &#x27;
                         &#x27;(the\n&#x27;
                         &#x27; * &quot;License&quot;); you may not use this file except in &#x27;
                         &#x27;compliance\n&#x27;
                         &#x27; * with the License.  You may obtain a copy of the &#x27;
                         &#x27;License at\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; *     http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                         &#x27; *\n&#x27;
                         &#x27; * Unless required by applicable law or agreed to in &#x27;
                         &#x27;writing, software\n&#x27;
                         &#x27; * distributed under the License is distributed on &#x27;
                         &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                         &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                         &#x27;either express or implied.\n&#x27;
                         &#x27; * See the License for the specific language &#x27;
                         &#x27;governing permissions and\n&#x27;
                         &#x27; * limitations under the License.\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;package com.dtstack.flink.sql.side;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.enums.ECacheType;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.metric.MetricConstant;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.AbsSideCache;\n&#x27;
                         &#x27;import com.dtstack.flink.sql.side.cache.CacheObj;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.side.cache.LRUSideCache;\n&#x27;
                         &#x27;import org.apache.calcite.sql.JoinType;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.configuration.Configuration;\n&#x27;
                         &#x27;import org.apache.flink.metrics.Counter;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.ResultFuture;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.streaming.api.functions.async.RichAsyncFunction;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;\n&#x27;
                         &#x27;import org.apache.flink.types.Row;\n&#x27;
                         &#x27;import org.slf4j.Logger;\n&#x27;
                         &#x27;import org.slf4j.LoggerFactory;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;import java.sql.Timestamp;\n&#x27;
                         &#x27;import java.time.LocalDateTime;\n&#x27;
                         &#x27;import java.util.Collection;\n&#x27;
                         &#x27;import java.util.Collections;\n&#x27;
                         &#x27;import java.util.concurrent.TimeoutException;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;/**\n&#x27;
                         &#x27; * All interfaces inherit naming rules: type + &#x27;
                         &#x27;&quot;AsyncReqRow&quot; such as == &quot;MysqlAsyncReqRow\n&#x27;
                         &#x27; * only support Left join / inner join(join),not &#x27;
                         &#x27;support right join\n&#x27;
                         &#x27; * Date: 2018/7/9\n&#x27;
                         &#x27; * Company: www.dtstack.com\n&#x27;
                         &#x27; * @author xuchao\n&#x27;
                         &#x27; */\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;public abstract class AsyncReqRow extends &#x27;
                         &#x27;RichAsyncFunction&lt;Row, Row&gt; implements ISideReqRow &#x27;
                         &#x27;{\n&#x27;
                         &#x27;    private static final Logger LOG = &#x27;
                         &#x27;LoggerFactory.getLogger(AsyncReqRow.class);\n&#x27;
                         &#x27;    private static final long serialVersionUID = &#x27;
                         &#x27;2098635244857937717L;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected SideInfo sideInfo;\n&#x27;
                         &#x27;    protected transient Counter parseErrorRecords;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public AsyncReqRow(SideInfo sideInfo){\n&#x27;
                         &#x27;        this.sideInfo = sideInfo;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void open(Configuration parameters) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;        super.open(parameters);\n&#x27;
                         &#x27;        initCache();\n&#x27;
                         &#x27;        initMetric();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initCache(){\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideInfo.getSideTableInfo();\n&#x27;
                         &#x27;        if(sideTableInfo.getCacheType() == null || &#x27;
                         &#x27;ECacheType.NONE.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        AbsSideCache sideCache;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.LRU.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            sideCache = new &#x27;
                         &#x27;LRUSideCache(sideTableInfo);\n&#x27;
                         &#x27;            sideInfo.setSideCache(sideCache);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;not support &#x27;
                         &#x27;side cache with type:&quot; + &#x27;
                         &#x27;sideTableInfo.getCacheType());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        sideCache.initCache();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void initMetric() {\n&#x27;
                         &#x27;        parseErrorRecords = &#x27;
                         &#x27;getRuntimeContext().getMetricGroup().counter(MetricConstant.DT_NUM_SIDE_PARSE_ERROR_RECORDS);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected Object &#x27;
                         &#x27;convertTimeIndictorTypeInfo(Integer index, Object &#x27;
                         &#x27;obj) {\n&#x27;
                         &#x27;        boolean isTimeIndicatorTypeInfo = &#x27;
                         &#x27;TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(index).getClass());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //Type information for indicating event or &#x27;
                         &#x27;processing time. However, it behaves like a regular &#x27;
                         &#x27;SQL timestamp but is serialized as Long.\n&#x27;
                         &#x27;        if (obj instanceof LocalDateTime &amp;&amp; &#x27;
                         &#x27;isTimeIndicatorTypeInfo) {\n&#x27;
                         &#x27;            obj = Timestamp.valueOf(((LocalDateTime) &#x27;
                         &#x27;obj));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return obj;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected CacheObj getFromCache(String key){\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;sideInfo.getSideCache().getFromCache(key);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void putCache(String key, CacheObj &#x27;
                         &#x27;value){\n&#x27;
                         &#x27;        sideInfo.getSideCache().putCache(key, &#x27;
                         &#x27;value);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean openCache(){\n&#x27;
                         &#x27;        return sideInfo.getSideCache() != null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealMissKey(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture){\n&#x27;
                         &#x27;        if(sideInfo.getJoinType() == &#x27;
                         &#x27;JoinType.LEFT){\n&#x27;
                         &#x27;            //Reserved left table data\n&#x27;
                         &#x27;            try {\n&#x27;
                         &#x27;                Row row = fillData(input, null);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;resultFuture.complete(Collections.singleton(row));\n&#x27;
                         &#x27;            } catch (Exception e) {\n&#x27;
                         &#x27;                dealFillDataError(resultFuture, e, &#x27;
                         &#x27;input);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            resultFuture.complete(null);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void dealCacheData(String key, &#x27;
                         &#x27;CacheObj missKeyObj) {\n&#x27;
                         &#x27;        if (openCache()) {\n&#x27;
                         &#x27;            putCache(key, missKeyObj);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//    @Override\n&#x27;
                         &#x27;//    public void timeout(Row input, &#x27;
                         &#x27;ResultFuture&lt;Row&gt; resultFuture) throws Exception {\n&#x27;
                         &#x27;//        StreamRecordQueueEntry&lt;Row&gt; future = &#x27;
                         &#x27;(StreamRecordQueueEntry&lt;Row&gt;)resultFuture;\n&#x27;
                         &#x27;//        try {\n&#x27;
                         &#x27;//            if (null == future.get()) {\n&#x27;
                         &#x27;//                &#x27;
                         &#x27;resultFuture.completeExceptionally(new &#x27;
                         &#x27;TimeoutException(&quot;Async function call has timed &#x27;
                         &#x27;out.&quot;));\n&#x27;
                         &#x27;//            }\n&#x27;
                         &#x27;//        } catch (Exception e) {\n&#x27;
                         &#x27;//            resultFuture.completeExceptionally(new &#x27;
                         &#x27;Exception(e));\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;//    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void &#x27;
                         &#x27;dealFillDataError(ResultFuture&lt;Row&gt; resultFuture, &#x27;
                         &#x27;Exception e, Object sourceData) {\n&#x27;
                         &#x27;        LOG.debug(&quot;source data {} join side table &#x27;
                         &#x27;error &quot;, sourceData);\n&#x27;
                         &#x27;        LOG.debug(&quot;async buid row error..{}&quot;, e);\n&#x27;
                         &#x27;        parseErrorRecords.inc();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;resultFuture.complete(Collections.emptyList());\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    @Override\n&#x27;
                         &#x27;    public void close() throws Exception {\n&#x27;
                         &#x27;        super.close();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;}\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        