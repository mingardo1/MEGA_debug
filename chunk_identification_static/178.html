<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>178</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    178
                    <a href="177.html">prev</a>
                    <a href="179.html">next</a>
                    <a href="178_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_c606871502e9c6e69c00e3f79d2c2871d7a26dec_src/com/android/launcher3/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c606871502e9c6e69c00e3f79d2c2871d7a26dec:src/com/android/launcher3/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c606871502e9c6e69c00e3f79d2c2871d7a26dec^1:src/com/android/launcher3/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c606871502e9c6e69c00e3f79d2c2871d7a26dec^2:src/com/android/launcher3/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;e48e570a82293d34e955b966c7821770600ec7bf:src/com/android/launcher3/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [s]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderOperation;
  24 import android.content.ContentResolver;
  25 import android.content.ContentValues;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.Intent.ShortcutIconResource;
  29 import android.content.IntentFilter;
  30 import android.content.pm.PackageManager;
  31 import android.content.pm.ProviderInfo;
  32 import android.content.pm.ResolveInfo;
  33 import android.database.Cursor;
  34 import android.graphics.Bitmap;
  35 import android.net.Uri;
  36 import android.os.Build;
  37 import android.os.Environment;
  38 import android.os.Handler;
  39 import android.os.HandlerThread;
  40 import android.os.Looper;
  41 import android.os.Parcelable;
  42 import android.os.Process;
  43 import android.os.SystemClock;
  44 import android.os.TransactionTooLargeException;
  45 import android.provider.BaseColumns;
  46 import android.text.TextUtils;
  47 import android.util.Log;
  48 import android.util.LongSparseArray;
  49 import android.util.Pair;
  50 
  51 import com.android.launcher3.compat.AppWidgetManagerCompat;
  52 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  53 import com.android.launcher3.compat.LauncherAppsCompat;
  54 import com.android.launcher3.compat.PackageInstallerCompat;
  55 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  56 import com.android.launcher3.compat.UserHandleCompat;
  57 import com.android.launcher3.compat.UserManagerCompat;
  58 import com.android.launcher3.model.WidgetsModel;
  59 import com.android.launcher3.util.ComponentKey;
  60 import com.android.launcher3.util.CursorIconInfo;
  61 import com.android.launcher3.util.LongArrayMap;
  62 import com.android.launcher3.util.ManagedProfileHeuristic;
  63 import com.android.launcher3.util.Thunk;
  64 
  65 import java.lang.ref.WeakReference;
  66 import java.net.URISyntaxException;
  67 import java.security.InvalidParameterException;
  68 import java.util.ArrayList;
  69 import java.util.Arrays;
  70 import java.util.Collection;
  71 import java.util.Collections;
  72 import java.util.Comparator;
  73 import java.util.HashMap;
  74 import java.util.HashSet;
  75 import java.util.Iterator;
  76 import java.util.List;
  77 import java.util.Map.Entry;
  78 import java.util.Set;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     public static final int LOADER_FLAG_NONE = 0;
  94     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  95     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  96 
  97     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  98     private static final long INVALID_SCREEN_ID = -1L;
  99 
 100     @Thunk final boolean mAppsCanBeOnRemoveableStorage;
 101     private final boolean mOldContentProviderExists;
 102 
 103     @Thunk final LauncherAppState mApp;
 104     @Thunk final Object mLock = new Object();
 105     @Thunk DeferredHandler mHandler = new DeferredHandler();
 106     @Thunk LoaderTask mLoaderTask;
 107     @Thunk boolean mIsLoaderTaskRunning;
 108     @Thunk boolean mHasLoaderCompletedOnce;
 109 
 110     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 111 
 112     @Thunk static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 113     static {
 114         sWorkerThread.start();
 115     }
 116     @Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 117 
 118     // We start off with everything not loaded.  After that, we assume that
 119     // our monitoring of the package manager provides all updates and we never
 120     // need to do a requery.  These are only ever touched from the loader thread.
 121     @Thunk boolean mWorkspaceLoaded;
 122     @Thunk boolean mAllAppsLoaded;
 123 
 124     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 125     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 126     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 127     // a normal load, we also clear this set of Runnables.
 128     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 129 
 130     /**
 131      * Set of runnables to be called on the background thread after the workspace binding
 132      * is complete.
 133      */
 134     static final ArrayList&lt;Runnable&gt; mBindCompleteRunnables = new ArrayList&lt;Runnable&gt;();
 135 
 136     @Thunk WeakReference&lt;Callbacks&gt; mCallbacks;
 137 
 138     // &lt; only access in worker thread &gt;
 139     AllAppsList mBgAllAppsList;
 140     // Entire list of widgets.
 141     WidgetsModel mBgWidgetsModel;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final LongArrayMap&lt;ItemInfo&gt; sBgItemsIdMap = new LongArrayMap&lt;&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final LongArrayMap&lt;FolderInfo&gt; sBgFolders = new LongArrayMap&lt;&gt;();
 164 
 165     // sBgWorkspaceScreens is the ordered set of workspace screens.
 166     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 167 
 168     // sBgWidgetProviders is the set of widget providers including custom internal widgets
 169     public static HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; sBgWidgetProviders;
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     @Thunk IconCache mIconCache;
 178 
 179     @Thunk final LauncherAppsCompat mLauncherApps;
 180     @Thunk final UserManagerCompat mUserManager;
 181 
 182     public interface Callbacks {
 183         public boolean setLoadOnResume();
 184         public int getCurrentWorkspaceScreen();
 185         public void startBinding();
 186         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 187                               boolean forceAnimateIcons);
 188         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 189         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 190         public void bindFolders(LongArrayMap&lt;FolderInfo&gt; folders);
 191         public void finishBindingItems();
 192         public void bindAppWidget(LauncherAppWidgetInfo info);
 193         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 194         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 195                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 196                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 197                                   ArrayList&lt;AppInfo&gt; addedApps);
 198         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 199         public void bindShortcutsChanged(ArrayList&lt;ShortcutInfo&gt; updated,
 200                 ArrayList&lt;ShortcutInfo&gt; removed, UserHandleCompat user);
 201         public void bindWidgetsRestored(ArrayList&lt;LauncherAppWidgetInfo&gt; widgets);
 202         public void bindRestoreItemsChange(HashSet&lt;ItemInfo&gt; updates);
 203         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 204                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 205         public void bindAllPackages(WidgetsModel model);
 206         public void bindSearchablesChanged();
 207         public boolean isAllAppsButtonRank(int rank);
 208         public void onPageBoundSynchronously(int page);
 209         public void dumpLogsToLocalData();
 210     }
 211 
 212     public interface ItemInfoFilter {
 213         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 214     }
 215 
 216     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 217         Context context = app.getContext();
 218 
 219         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 220         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 221         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 222         // resource string.
 223         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 224         ProviderInfo providerInfo =
 225                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 226         ProviderInfo redirectProvider =
 227                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 228 
 229         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 230         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 231 
 232         if (mOldContentProviderExists) {
 233             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 234         } else {
 235             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 236         }
 237 
 238         mApp = app;
 239         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 240         mBgWidgetsModel = new WidgetsModel(context, iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         mLauncherApps = LauncherAppsCompat.getInstance(context);
 244         mUserManager = UserManagerCompat.getInstance(context);
 245     }
 246 
 247     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 248      * posted on the main thread handler. */
 249     @Thunk void runOnMainThread(Runnable r) {
 250         if (sWorkerThread.getThreadId() == Process.myTid()) {
 251             // If we are on the worker thread, post onto the main handler
 252             mHandler.post(r);
 253         } else {
 254             r.run();
 255         }
 256     }
 257 
 258     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 259      * posted on the worker thread handler. */
 260     private static void runOnWorkerThread(Runnable r) {
 261         if (sWorkerThread.getThreadId() == Process.myTid()) {
 262             r.run();
 263         } else {
 264             // If we are not on the worker thread, then post to the worker handler
 265             sWorker.post(r);
 266         }
 267     }
 268 
 269     /**
 270      * Runs the specified runnable after the loader is complete
 271      */
 272     @Thunk void runAfterBindCompletes(Runnable r) {
 273         if (isLoadingWorkspace() || !mHasLoaderCompletedOnce) {
 274             synchronized (mBindCompleteRunnables) {
 275                 mBindCompleteRunnables.add(r);
 276             }
 277         } else {
 278             runOnWorkerThread(r);
 279         }
 280     }
 281 
 282     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 283         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 284     }
 285 
 286     public void setPackageState(final PackageInstallInfo installInfo) {
 287         Runnable updateRunnable = new Runnable() {
 288 
 289             @Override
 290             public void run() {
 291                 synchronized (sBgLock) {
 292                     final HashSet&lt;ItemInfo&gt; updates = new HashSet&lt;&gt;();
 293 
 294                     if (installInfo.state == PackageInstallerCompat.STATUS_INSTALLED) {
 295                         // Ignore install success events as they are handled by Package add events.
 296                         return;
 297                     }
 298 
 299                     for (ItemInfo info : sBgItemsIdMap) {
 300                         if (info instanceof ShortcutInfo) {
 301                             ShortcutInfo si = (ShortcutInfo) info;
 302                             ComponentName cn = si.getTargetComponent();
 303                             if (si.isPromise() &amp;&amp; (cn != null)
 304                                     &amp;&amp; installInfo.packageName.equals(cn.getPackageName())) {
 305                                 si.setInstallProgress(installInfo.progress);
 306 
 307                                 if (installInfo.state == PackageInstallerCompat.STATUS_FAILED) {
 308                                     // Mark this info as broken.
 309                                     si.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
 310                                 }
 311                                 updates.add(si);
 312                             }
 313                         }
 314                     }
 315 
 316                     for (LauncherAppWidgetInfo widget : sBgAppWidgets) {
 317                         if (widget.providerName.getPackageName().equals(installInfo.packageName)) {
 318                             widget.installProgress = installInfo.progress;
 319                             updates.add(widget);
 320                         }
 321                     }
 322 
 323                     if (!updates.isEmpty()) {
 324                         // Push changes to the callback.
 325                         Runnable r = new Runnable() {
 326                             public void run() {
 327                                 Callbacks callbacks = getCallback();
 328                                 if (callbacks != null) {
 329                                     callbacks.bindRestoreItemsChange(updates);
 330                                 }
 331                             }
 332                         };
 333                         mHandler.post(r);
 334                     }
 335                 }
 336             }
 337         };
 338         runOnWorkerThread(updateRunnable);
 339     }
 340 
 341     /**
 342      * Updates the icons and label of all pending icons for the provided package name.
 343      */
 344     public void updateSessionDisplayInfo(final String packageName) {
 345         Runnable updateRunnable = new Runnable() {
 346 
 347             @Override
 348             public void run() {
 349                 synchronized (sBgLock) {
 350                     final ArrayList&lt;ShortcutInfo&gt; updates = new ArrayList&lt;&gt;();
 351                     final UserHandleCompat user = UserHandleCompat.myUserHandle();
 352 
 353                     for (ItemInfo info : sBgItemsIdMap) {
 354                         if (info instanceof ShortcutInfo) {
 355                             ShortcutInfo si = (ShortcutInfo) info;
 356                             ComponentName cn = si.getTargetComponent();
 357                             if (si.isPromise() &amp;&amp; (cn != null)
 358                                     &amp;&amp; packageName.equals(cn.getPackageName())) {
 359                                 if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
 360                                     // For auto install apps update the icon as well as label.
 361                                     mIconCache.getTitleAndIcon(si,
 362                                             si.promisedIntent, user,
 363                                             si.shouldUseLowResIcon());
 364                                 } else {
 365                                     // Only update the icon for restored apps.
 366                                     si.updateIcon(mIconCache);
 367                                 }
 368                                 updates.add(si);
 369                             }
 370                         }
 371                     }
 372 
 373                     if (!updates.isEmpty()) {
 374                         // Push changes to the callback.
 375                         Runnable r = new Runnable() {
 376                             public void run() {
 377                                 Callbacks callbacks = getCallback();
 378                                 if (callbacks != null) {
 379                                     callbacks.bindShortcutsChanged(updates,
 380                                             new ArrayList&lt;ShortcutInfo&gt;(), user);
 381                                 }
 382                             }
 383                         };
 384                         mHandler.post(r);
 385                     }
 386                 }
 387             }
 388         };
 389         runOnWorkerThread(updateRunnable);
 390     }
 391 
 392     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 393         final Callbacks callbacks = getCallback();
 394 
 395         if (allAppsApps == null) {
 396             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 397         }
 398         if (allAppsApps.isEmpty()) {
 399             return;
 400         }
 401 
 402         // Process the newly added applications and add them to the database first
 403         Runnable r = new Runnable() {
 404             public void run() {
 405                 runOnMainThread(new Runnable() {
 406                     public void run() {
 407                         Callbacks cb = getCallback();
 408                         if (callbacks == cb &amp;&amp; cb != null) {
 409                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 410                         }
 411                     }
 412                 });
 413             }
 414         };
 415         runOnWorkerThread(r);
 416     }
 417 
 418     private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; occupiedPos,
 419             int[] xy, int spanX, int spanY) {
 420         LauncherAppState app = LauncherAppState.getInstance();
 421         InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
 422         final int xCount = (int) profile.numColumns;
 423         final int yCount = (int) profile.numRows;
 424         boolean[][] occupied = new boolean[xCount][yCount];
 425         if (occupiedPos != null) {
 426             for (ItemInfo r : occupiedPos) {
 427                 int right = r.cellX + r.spanX;
 428                 int bottom = r.cellY + r.spanY;
 429                 for (int x = r.cellX; 0 &lt;= x &amp;&amp; x &lt; right &amp;&amp; x &lt; xCount; x++) {
 430                     for (int y = r.cellY; 0 &lt;= y &amp;&amp; y &lt; bottom &amp;&amp; y &lt; yCount; y++) {
 431                         occupied[x][y] = true;
 432                     }
 433                 }
 434             }
 435         }
 436         return Utilities.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);
 437     }
 438 
 439     /**
 440      * Find a position on the screen for the given size or adds a new screen.
 441      * @return screenId and the coordinates for the item.
 442      */
 443     @Thunk Pair&lt;Long, int[]&gt; findSpaceForItem(
 444             Context context,
 445             ArrayList&lt;Long&gt; workspaceScreens,
 446             ArrayList&lt;Long&gt; addedWorkspaceScreensFinal,
 447             int spanX, int spanY) {
 448         LongSparseArray&lt;ArrayList&lt;ItemInfo&gt;&gt; screenItems = new LongSparseArray&lt;&gt;();
 449 
 450         // Use sBgItemsIdMap as all the items are already loaded.
 451         assertWorkspaceLoaded();
 452         synchronized (sBgLock) {
 453             for (ItemInfo info : sBgItemsIdMap) {
 454                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 455                     ArrayList&lt;ItemInfo&gt; items = screenItems.get(info.screenId);
 456                     if (items == null) {
 457                         items = new ArrayList&lt;&gt;();
 458                         screenItems.put(info.screenId, items);
 459                     }
 460                     items.add(info);
 461                 }
 462             }
 463         }
 464 
 465         // Find appropriate space for the item.
 466         long screenId = 0;
 467         int[] cordinates = new int[2];
 468         boolean found = false;
 469 
 470         int screenCount = workspaceScreens.size();
 471         // First check the preferred screen.
 472         int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;
 473         if (preferredScreenIndex &lt; screenCount) {
 474             screenId = workspaceScreens.get(preferredScreenIndex);
 475             found = findNextAvailableIconSpaceInScreen(
 476                     screenItems.get(screenId), cordinates, spanX, spanY);
 477         }
 478 
 479         if (!found) {
 480             // Search on any of the screens starting from the first screen.
 481             for (int screen = 1; screen &lt; screenCount; screen++) {
 482                 screenId = workspaceScreens.get(screen);
 483                 if (findNextAvailableIconSpaceInScreen(
 484                         screenItems.get(screenId), cordinates, spanX, spanY)) {
 485                     // We found a space for it
 486                     found = true;
 487                     break;
 488                 }
 489             }
 490         }
 491 
 492         if (!found) {
 493             // Still no position found. Add a new screen to the end.
 494             screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 495 
 496             // Save the screen id for binding in the workspace
 497             workspaceScreens.add(screenId);
 498             addedWorkspaceScreensFinal.add(screenId);
 499 
 500             // If we still can&#x27;t find an empty space, then God help us all!!!
 501             if (!findNextAvailableIconSpaceInScreen(
 502                     screenItems.get(screenId), cordinates, spanX, spanY)) {
 503                 throw new RuntimeException(&quot;Can&#x27;t find space to add the item&quot;);
 504             }
 505         }
 506         return Pair.create(screenId, cordinates);
 507     }
 508 
 509     /**
 510      * Adds the provided items to the workspace.
 511      */
 512     public void addAndBindAddedWorkspaceItems(final Context context,
 513             final ArrayList&lt;? extends ItemInfo&gt; workspaceApps) {
 514         final Callbacks callbacks = getCallback();
 515         if (workspaceApps.isEmpty()) {
 516             return;
 517         }
 518         // Process the newly added applications and add them to the database first
 519         Runnable r = new Runnable() {
 520             public void run() {
 521                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 522                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 523 
 524                 // Get the list of workspace screens.  We need to append to this list and
 525                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 526                 // called.
 527                 ArrayList&lt;Long&gt; workspaceScreens = loadWorkspaceScreensDb(context);
 528                 synchronized(sBgLock) {
 529                     for (ItemInfo item : workspaceApps) {
 530                         if (item instanceof ShortcutInfo) {
 531                             // Short-circuit this logic if the icon exists somewhere on the workspace
 532                             if (shortcutExists(context, item.getIntent(), item.user)) {
 533                                 continue;
 534                             }
 535                         }
 536 
 537                         // Find appropriate space for the item.
 538                         Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context,
 539                                 workspaceScreens, addedWorkspaceScreensFinal,
 540                                 1, 1);
 541                         long screenId = coords.first;
 542                         int[] cordinates = coords.second;
 543 
 544                         ItemInfo itemInfo;
 545                         if (item instanceof ShortcutInfo || item instanceof FolderInfo) {
 546                             itemInfo = item;
 547                         } else if (item instanceof AppInfo) {
 548                             itemInfo = ((AppInfo) item).makeShortcut();
 549                         } else {
 550                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 551                         }
 552 
 553                         // Add the shortcut to the db
 554                         addItemToDatabase(context, itemInfo,
 555                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 556                                 screenId, cordinates[0], cordinates[1]);
 557                         // Save the ShortcutInfo for binding in the workspace
 558                         addedShortcutsFinal.add(itemInfo);
 559                     }
 560                 }
 561 
 562                 // Update the workspace screens
 563                 updateWorkspaceScreenOrder(context, workspaceScreens);
 564 
 565                 if (!addedShortcutsFinal.isEmpty()) {
 566                     runOnMainThread(new Runnable() {
 567                         public void run() {
 568                             Callbacks cb = getCallback();
 569                             if (callbacks == cb &amp;&amp; cb != null) {
 570                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 571                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 572                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 573                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 573                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 574                                     long lastScreenId = info.screenId;
 575                                     for (ItemInfo i : addedShortcutsFinal) {
 576                                         if (i.screenId == lastScreenId) {
 577                                             addAnimated.add(i);
 578                                         } else {
 579                                             addNotAnimated.add(i);
 580                                         }
 581                                     }
 582                                 }
 583                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 584                                         addNotAnimated, addAnimated, null);
 585                             }
 586                         }
 587                     });
 588                 }
 589             }
 590         };
 591         runOnWorkerThread(r);
 592     }
 593 
 594     private void unbindItemInfosAndClearQueuedBindRunnables() {
 595         if (sWorkerThread.getThreadId() == Process.myTid()) {
 596             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 597                     &quot;main thread&quot;);
 598         }
 599 
 600         // Clear any deferred bind runnables
 601         synchronized (mDeferredBindRunnables) {
 602             mDeferredBindRunnables.clear();
 603         }
 604 
 605         // Remove any queued UI runnables
 606         mHandler.cancelAll();
 607         // Unbind all the workspace items
 608         unbindWorkspaceItemsOnMainThread();
 609     }
 610 
 611     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 612     void unbindWorkspaceItemsOnMainThread() {
 613         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 614         // by making a copy of workspace items first.
 615         final ArrayList&lt;ItemInfo&gt; tmpItems = new ArrayList&lt;ItemInfo&gt;();
 616         synchronized (sBgLock) {
 617             tmpItems.addAll(sBgWorkspaceItems);
 618             tmpItems.addAll(sBgAppWidgets);
 619         }
 620         Runnable r = new Runnable() {
 621                 @Override
 622                 public void run() {
 623                    for (ItemInfo item : tmpItems) {
 624                        item.unbind();
 625                    }
 626                 }
 627             };
 628         runOnMainThread(r);
 629     }
 630 
 631     /**
 632      * Adds an item to the DB if it was not created previously, or move it to a new
 633      * &lt;container, screen, cellX, cellY&gt;
 634      */
 635     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 636             long screenId, int cellX, int cellY) {
 637         if (item.container == ItemInfo.NO_ID) {
 638             // From all apps
 639             addItemToDatabase(context, item, container, screenId, cellX, cellY);
 640         } else {
 641             // From somewhere else
 642             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 643         }
 644     }
 645 
 646     static void checkItemInfoLocked(
 647             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 648         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 649         if (modelItem != null &amp;&amp; item != modelItem) {
 650             // check all the data is consistent
 651             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 652                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 653                 ShortcutInfo shortcut = (ShortcutInfo) item;
 654                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 655                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 656                         modelShortcut.id == shortcut.id &amp;&amp;
 657                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 658                         modelShortcut.container == shortcut.container &amp;&amp;
 659                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 660                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 661                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 662                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 663                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 664                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 665                         (modelShortcut.dropPos != null &amp;&amp;
 666                                 shortcut.dropPos != null &amp;&amp;
 667                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 668                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 669                     // For all intents and purposes, this is the same object
 670                     return;
 671                 }
 672             }
 673 
 674             // the modelItem needs to match up perfectly with item if our model is
 675             // to be consistent with the database-- for now, just require
 676             // modelItem == item or the equality check above
 677             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 678                     &quot;modelItem: &quot; +
 679                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 680                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 681             RuntimeException e = new RuntimeException(msg);
 682             if (stackTrace != null) {
 683                 e.setStackTrace(stackTrace);
 684             }
 685             throw e;
 686         }
 687     }
 688 
 689     static void checkItemInfo(final ItemInfo item) {
 690         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 691         final long itemId = item.id;
 692         Runnable r = new Runnable() {
 693             public void run() {
 694                 synchronized (sBgLock) {
 695                     checkItemInfoLocked(itemId, item, stackTrace);
 696                 }
 697             }
 698         };
 699         runOnWorkerThread(r);
 700     }
 701 
 702     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 703             final ItemInfo item, final String callingFunction) {
 704         final long itemId = item.id;
 705         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 706         final ContentResolver cr = context.getContentResolver();
 707 
 708         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 709         Runnable r = new Runnable() {
 710             public void run() {
 711                 cr.update(uri, values, null, null);
 712                 updateItemArrays(item, itemId, stackTrace);
 713             }
 714         };
 715         runOnWorkerThread(r);
 716     }
 717 
 718     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 719             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 720         final ContentResolver cr = context.getContentResolver();
 721 
 722         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 723         Runnable r = new Runnable() {
 724             public void run() {
 725                 ArrayList&lt;ContentProviderOperation&gt; ops =
 726                         new ArrayList&lt;ContentProviderOperation&gt;();
 727                 int count = items.size();
 728                 for (int i = 0; i &lt; count; i++) {
 729                     ItemInfo item = items.get(i);
 730                     final long itemId = item.id;
 731                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 732                     ContentValues values = valuesList.get(i);
 733 
 734                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 735                     updateItemArrays(item, itemId, stackTrace);
 736 
 737                 }
 738                 try {
 739                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 740                 } catch (Exception e) {
 741                     e.printStackTrace();
 742                 }
 743             }
 744         };
 745         runOnWorkerThread(r);
 746     }
 747 
 748     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 749         // Lock on mBgLock *after* the db operation
 750         synchronized (sBgLock) {
 751             checkItemInfoLocked(itemId, item, stackTrace);
 752 
 753             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 754                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 755                 // Item is in a folder, make sure this folder exists
 756                 if (!sBgFolders.containsKey(item.container)) {
 757                     // An items container is being set to a that of an item which is not in
 758                     // the list of Folders.
 759                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 760                             item.container + &quot;, not in the list of folders&quot;;
 761                     Log.e(TAG, msg);
 762                 }
 763             }
 764 
 765             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 766             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 767             // that are on the desktop, as appropriate
 768             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 769             if (modelItem != null &amp;&amp;
 770                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 771                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 772                 switch (modelItem.itemType) {
 773                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 774                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 775                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 776                         if (!sBgWorkspaceItems.contains(modelItem)) {
 777                             sBgWorkspaceItems.add(modelItem);
 778                         }
 779                         break;
 780                     default:
 781                         break;
 782                 }
 783             } else {
 784                 sBgWorkspaceItems.remove(modelItem);
 785             }
 786         }
 787     }
 788 
 789     /**
 790      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 791      */
 792     public static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 793             final long screenId, final int cellX, final int cellY) {
 794         item.container = container;
 795         item.cellX = cellX;
 796         item.cellY = cellY;
 797 
 798         // We store hotseat items in canonical form which is this orientation invariant position
 799         // in the hotseat
 800         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 801                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 802             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 803         } else {
 804             item.screenId = screenId;
 805         }
 806 
 807         final ContentValues values = new ContentValues();
 808         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 809         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 810         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 811         values.put(LauncherSettings.Favorites.RANK, item.rank);
 812         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 813 
 814         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 815     }
 816 
 817     /**
 818      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 819      * cellX, cellY have already been updated on the ItemInfos.
 820      */
 821     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 822             final long container, final int screen) {
 823 
 824         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 825         int count = items.size();
 826 
 827         for (int i = 0; i &lt; count; i++) {
 828             ItemInfo item = items.get(i);
 829             item.container = container;
 830 
 831             // We store hotseat items in canonical form which is this orientation invariant position
 832             // in the hotseat
 833             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 834                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 835                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 836                         item.cellY);
 837             } else {
 838                 item.screenId = screen;
 839             }
 840 
 841             final ContentValues values = new ContentValues();
 842             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 843             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 844             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 845             values.put(LauncherSettings.Favorites.RANK, item.rank);
 846             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 847 
 848             contentValues.add(values);
 849         }
 850         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 851     }
 852 
 853     /**
 854      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 855      */
 856     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 857             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 858         item.container = container;
 859         item.cellX = cellX;
 860         item.cellY = cellY;
 861         item.spanX = spanX;
 862         item.spanY = spanY;
 863 
 864         // We store hotseat items in canonical form which is this orientation invariant position
 865         // in the hotseat
 866         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 867                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 868             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 869         } else {
 870             item.screenId = screenId;
 871         }
 872 
 873         final ContentValues values = new ContentValues();
 874         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 875         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 876         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 877         values.put(LauncherSettings.Favorites.RANK, item.rank);
 878         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 879         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 880         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 881 
 882         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 883     }
 884 
 885     /**
 886      * Update an item to the database in a specified container.
 887      */
 888     public static void updateItemInDatabase(Context context, final ItemInfo item) {
 889         final ContentValues values = new ContentValues();
 890         item.onAddToDatabase(context, values);
 891         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 892     }
 893 
 894     private void assertWorkspaceLoaded() {
 895         if (LauncherAppState.isDogfoodBuild() &amp;&amp; (isLoadingWorkspace() || !mHasLoaderCompletedOnce)) {
 896             throw new RuntimeException(&quot;Trying to add shortcut while loader is running&quot;);
 897         }
 898     }
 899 
 900     /**
 901      * Returns true if the shortcuts already exists on the workspace. This must be called after
 902      * the workspace has been loaded. We identify a shortcut by its intent.
 903      */
 904     @Thunk boolean shortcutExists(Context context, Intent intent, UserHandleCompat user) {
 905         assertWorkspaceLoaded();
 906         final String intentWithPkg, intentWithoutPkg;
 907         if (intent.getComponent() != null) {
 908             // If component is not null, an intent with null package will produce
 909             // the same result and should also be a match.
 910             String packageName = intent.getComponent().getPackageName();
 911             if (intent.getPackage() != null) {
 912                 intentWithPkg = intent.toUri(0);
 913                 intentWithoutPkg = new Intent(intent).setPackage(null).toUri(0);
 914             } else {
 915                 intentWithPkg = new Intent(intent).setPackage(packageName).toUri(0);
 916                 intentWithoutPkg = intent.toUri(0);
 917             }
 918         } else {
 919             intentWithPkg = intent.toUri(0);
 920             intentWithoutPkg = intent.toUri(0);
 921         }
 922 
 923         synchronized (sBgLock) {
 924             for (ItemInfo item : sBgItemsIdMap) {
 925                 if (item instanceof ShortcutInfo) {
 926                     ShortcutInfo info = (ShortcutInfo) item;
 927                     Intent targetIntent = info.promisedIntent == null
 928                             ? info.intent : info.promisedIntent;
 929                     if (targetIntent != null &amp;&amp; info.user.equals(user)) {
 930                         String s = targetIntent.toUri(0);
 931                         if (intentWithPkg.equals(s) || intentWithoutPkg.equals(s)) {
 932                             return true;
 933                         }
 934                     }
 935                 }
 936             }
 937         }
 938         return false;
 939     }
 940 
 941     /**
 942      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 943      */
 944     FolderInfo getFolderById(Context context, LongArrayMap&lt;FolderInfo&gt; folderList, long id) {
 945         final ContentResolver cr = context.getContentResolver();
 946         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 947                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 948                 new String[] { String.valueOf(id),
 949                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 950 
 951         try {
 952             if (c.moveToFirst()) {
 953                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 954                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 955                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 956                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 957                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 958                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 959                 final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);
 960 
 961                 FolderInfo folderInfo = null;
 962                 switch (c.getInt(itemTypeIndex)) {
 963                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 964                         folderInfo = findOrMakeFolder(folderList, id);
 965                         break;
 966                 }
 967 
 968                 // Do not trim the folder label, as is was set by the user.
 969                 folderInfo.title = c.getString(titleIndex);
 970                 folderInfo.id = id;
 971                 folderInfo.container = c.getInt(containerIndex);
 972                 folderInfo.screenId = c.getInt(screenIndex);
 973                 folderInfo.cellX = c.getInt(cellXIndex);
 974                 folderInfo.cellY = c.getInt(cellYIndex);
 975                 folderInfo.options = c.getInt(optionsIndex);
 976 
 977                 return folderInfo;
 978             }
 979         } finally {
 980             c.close();
 981         }
 982 
 983         return null;
 984     }
 985 
 986     /**
 987      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 988      * cellY fields of the item. Also assigns an ID to the item.
 989      */
 990     public static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 991             final long screenId, final int cellX, final int cellY) {
 992         item.container = container;
 993         item.cellX = cellX;
 994         item.cellY = cellY;
 995         // We store hotseat items in canonical form which is this orientation invariant position
 996         // in the hotseat
 997         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 998                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 999             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1000         } else {
1001             item.screenId = screenId;
1002         }
1003 
1004         final ContentValues values = new ContentValues();
1005         final ContentResolver cr = context.getContentResolver();
1006         item.onAddToDatabase(context, values);
1007 
1008         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1009         values.put(LauncherSettings.Favorites._ID, item.id);
1010 
1011         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1012         Runnable r = new Runnable() {
1013             public void run() {
1014                 cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);
1015 
1016                 // Lock on mBgLock *after* the db operation
1017                 synchronized (sBgLock) {
1018                     checkItemInfoLocked(item.id, item, stackTrace);
1019                     sBgItemsIdMap.put(item.id, item);
1020                     switch (item.itemType) {
1021                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1022                             sBgFolders.put(item.id, (FolderInfo) item);
1023                             // Fall through
1024                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1025                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1026                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1027                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1028                                 sBgWorkspaceItems.add(item);
1029                             } else {
1030                                 if (!sBgFolders.containsKey(item.container)) {
1031                                     // Adding an item to a folder that doesn&#x27;t exist.
1032                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1033                                             &quot; doesn&#x27;t exist&quot;;
1034                                     Log.e(TAG, msg);
1035                                 }
1036                             }
1037                             break;
1038                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1039                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1040                             break;
1041                     }
1042                 }
1043             }
1044         };
1045         runOnWorkerThread(r);
1046     }
1047 
1048     /**
1049      * Creates a new unique child id, for a given cell span across all layouts.
1050      */
1051     static int getCellLayoutChildId(
1052             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1053         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1054                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1055     }
1056 
1057     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1058             final String pn, final UserHandleCompat user) {
1059         ItemInfoFilter filter  = new ItemInfoFilter() {
1060             @Override
1061             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1062                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1063             }
1064         };
1065         return filterItemInfos(sBgItemsIdMap, filter);
1066     }
1067 
1068     /**
1069      * Removes all the items from the database corresponding to the specified package.
1070      */
1071     static void deletePackageFromDatabase(Context context, final String pn,
1072             final UserHandleCompat user) {
1073         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1074     }
1075 
1076     /**
1077      * Removes the specified item from the database
1078      * @param context
1079      * @param item
1080      */
1081     public static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1082         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1083         items.add(item);
1084         deleteItemsFromDatabase(context, items);
1085     }
1086 
1087     /**
1088      * Removes the specified items from the database
1089      * @param context
1090      * @param item
1091      */
1092     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;? extends ItemInfo&gt; items) {
1093         final ContentResolver cr = context.getContentResolver();
1094         Runnable r = new Runnable() {
1095             public void run() {
1096                 for (ItemInfo item : items) {
1097                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id);
1098                     cr.delete(uri, null, null);
1099 
1100                     // Lock on mBgLock *after* the db operation
1101                     synchronized (sBgLock) {
1102                         switch (item.itemType) {
1103                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1104                                 sBgFolders.remove(item.id);
1105                                 for (ItemInfo info: sBgItemsIdMap) {
1106                                     if (info.container == item.id) {
1107                                         // We are deleting a folder which still contains items that
1108                                         // think they are contained by that folder.
1109                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1110                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1111                                         Log.e(TAG, msg);
1112                                     }
1113                                 }
1114                                 sBgWorkspaceItems.remove(item);
1115                                 break;
1116                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1117                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1118                                 sBgWorkspaceItems.remove(item);
1119                                 break;
1120                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1121                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1122                                 break;
1123                         }
1124                         sBgItemsIdMap.remove(item.id);
1125                     }
1126                 }
1127             }
1128         };
1129         runOnWorkerThread(r);
1130     }
1131 
1132     /**
1133      * Update the order of the workspace screens in the database. The array list contains
1134      * a list of screen ids in the order that they should appear.
1135      */
1136     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1137         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1138         final ContentResolver cr = context.getContentResolver();
1139         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1140 
1141         // Remove any negative screen ids -- these aren&#x27;t persisted
1142         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1143         while (iter.hasNext()) {
1144             long id = iter.next();
1145             if (id &lt; 0) {
1146                 iter.remove();
1147             }
1148         }
1149 
1150         Runnable r = new Runnable() {
1151             @Override
1152             public void run() {
1153                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1154                 // Clear the table
1155                 ops.add(ContentProviderOperation.newDelete(uri).build());
1156                 int count = screensCopy.size();
1157                 for (int i = 0; i &lt; count; i++) {
1158                     ContentValues v = new ContentValues();
1159                     long screenId = screensCopy.get(i);
1160                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1161                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1162                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1163                 }
1164 
1165                 try {
1166                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1167                 } catch (Exception ex) {
1168                     throw new RuntimeException(ex);
1169                 }
1170 
1171                 synchronized (sBgLock) {
1172                     sBgWorkspaceScreens.clear();
1173                     sBgWorkspaceScreens.addAll(screensCopy);
1174                 }
1175             }
1176         };
1177         runOnWorkerThread(r);
1178     }
1179 
1180     /**
1181      * Remove the contents of the specified folder from the database
1182      */
1183     public static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1184         final ContentResolver cr = context.getContentResolver();
1185 
1186         Runnable r = new Runnable() {
1187             public void run() {
1188                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);
1189                 // Lock on mBgLock *after* the db operation
1190                 synchronized (sBgLock) {
1191                     sBgItemsIdMap.remove(info.id);
1192                     sBgFolders.remove(info.id);
1193                     sBgWorkspaceItems.remove(info);
1194                 }
1195 
1196                 cr.delete(LauncherSettings.Favorites.CONTENT_URI,
1197                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1198                 // Lock on mBgLock *after* the db operation
1199                 synchronized (sBgLock) {
1200                     for (ItemInfo childInfo : info.contents) {
1201                         sBgItemsIdMap.remove(childInfo.id);
1202                     }
1203                 }
1204             }
1205         };
1206         runOnWorkerThread(r);
1207     }
1208 
1209     /**
1210      * Set this as the current Launcher activity object for the loader.
1211      */
1212     public void initialize(Callbacks callbacks) {
1213         synchronized (mLock) {
1214             // Disconnect any of the callbacks and drawables associated with ItemInfos on the
1215             // workspace to prevent leaking Launcher activities on orientation change.
1216             unbindItemInfosAndClearQueuedBindRunnables();
1217             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1218         }
1219     }
1220 
1221     @Override
1222     public void onPackageChanged(String packageName, UserHandleCompat user) {
1223         int op = PackageUpdatedTask.OP_UPDATE;
1224         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1225                 user));
1226     }
1227 
1228     @Override
1229     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1230         int op = PackageUpdatedTask.OP_REMOVE;
1231         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1232                 user));
1233     }
1234 
1235     @Override
1236     public void onPackageAdded(String packageName, UserHandleCompat user) {
1237         int op = PackageUpdatedTask.OP_ADD;
1238         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1239                 user));
1240     }
1241 
1242     @Override
1243     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1244             boolean replacing) {
1245         if (!replacing) {
1246             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1247                     user));
1248             if (mAppsCanBeOnRemoveableStorage) {
1249                 // Only rebind if we support removable storage. It catches the
1250                 // case where
1251                 // apps on the external sd card need to be reloaded
1252                 startLoaderFromBackground();
1253             }
1254         } else {
1255             // If we are replacing then just update the packages in the list
1256             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1257                     packageNames, user));
1258         }
1259     }
1260 
1261     @Override
1262     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1263             boolean replacing) {
1264         if (!replacing) {
1265             enqueuePackageUpdated(new PackageUpdatedTask(
1266                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1267                     user));
1268         }
1269     }
1270 
1271     /**
1272      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1273      * ACTION_PACKAGE_CHANGED.
1274      */
1275     @Override
1276     public void onReceive(Context context, Intent intent) {
1277         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1278 
1279         final String action = intent.getAction();
1280         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1281             // If we have changed locale we need to clear out the labels in all apps/workspace.
1282             forceReload();
1283         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1284                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1285             Callbacks callbacks = getCallback();
1286             if (callbacks != null) {
1287                 callbacks.bindSearchablesChanged();
1288             }
1289         } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)
1290                 || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {
1291             forceReload();
1292         }
1293     }
1294 
1295     void forceReload() {
1296         resetLoadedState(true, true);
1297 
1298         // Do this here because if the launcher activity is running it will be restarted.
1299         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1300         // to reload.
1301         startLoaderFromBackground();
1302     }
1303 
1304     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1305         synchronized (mLock) {
1306             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1307             // mWorkspaceLoaded to true later
1308             stopLoaderLocked();
1309             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1310             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1311         }
1312     }
1313 
1314     /**
1315      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1316      * configuration changes.  So whenever we trigger the loader from the background
1317      * tell the launcher that it needs to re-run the loader when it comes back instead
1318      * of doing it now.
1319      */
1320     public void startLoaderFromBackground() {
1321         boolean runLoader = false;
1322         Callbacks callbacks = getCallback();
1323         if (callbacks != null) {
1324             // Only actually run the loader if they&#x27;re not paused.
1325             if (!callbacks.setLoadOnResume()) {
1326                 runLoader = true;
1327             }
1328         }
1329         if (runLoader) {
1330             startLoader(PagedView.INVALID_RESTORE_PAGE);
1331         }
1332     }
1333 
1334     /**
1335      * If there is already a loader task running, tell it to stop.
1336      */
1337     private void stopLoaderLocked() {
1338         LoaderTask oldTask = mLoaderTask;
1339         if (oldTask != null) {
1340             oldTask.stopLocked();
1341         }
1342     }
1343 
1344     public boolean isCurrentCallbacks(Callbacks callbacks) {
1345         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1346     }
1347 
1348     public void startLoader(int synchronousBindPage) {
1349         startLoader(synchronousBindPage, LOADER_FLAG_NONE);
1350     }
1351 
1352     public void startLoader(int synchronousBindPage, int loadFlags) {
1353         // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems
1354         InstallShortcutReceiver.enableInstallQueue();
1355         synchronized (mLock) {
1356             // Clear any deferred bind-runnables from the synchronized load process
1357             // We must do this before any loading/binding is scheduled below.
1358             synchronized (mDeferredBindRunnables) {
1359                 mDeferredBindRunnables.clear();
1360             }
1361 
1362             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1363             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1364                 // If there is already one running, tell it to stop.
1365                 stopLoaderLocked();
1366                 mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags);
1367                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1368                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) {
1369                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1370                 } else {
1371                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1372                     sWorker.post(mLoaderTask);
1373                 }
1374             }
1375         }
1376     }
1377 
1378     void bindRemainingSynchronousPages() {
1379         // Post the remaining side pages to be loaded
1380         if (!mDeferredBindRunnables.isEmpty()) {
1381             Runnable[] deferredBindRunnables = null;
1382             synchronized (mDeferredBindRunnables) {
1383                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1384                         new Runnable[mDeferredBindRunnables.size()]);
1385                 mDeferredBindRunnables.clear();
1386             }
1387             for (final Runnable r : deferredBindRunnables) {
1388                 mHandler.post(r);
1389             }
1390         }
1391 
1392         // Run all the bind complete runnables after workspace is bound.
1393         if (!mBindCompleteRunnables.isEmpty()) {
1394             synchronized (mBindCompleteRunnables) {
1395                 for (final Runnable r : mBindCompleteRunnables) {
1396                     runOnWorkerThread(r);
1397                 }
1398                 mBindCompleteRunnables.clear();
1399             }
1400         }
1401     }
1402 
1403     public void stopLoader() {
1404         synchronized (mLock) {
1405             if (mLoaderTask != null) {
1406                 mLoaderTask.stopLocked();
1407             }
1408         }
1409     }
1410 
1411     /**
1412      * Loads the workspace screen ids in an ordered list.
1413      */
1414     @Thunk static ArrayList&lt;Long&gt; loadWorkspaceScreensDb(Context context) {
1415         final ContentResolver contentResolver = context.getContentResolver();
1416         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1417 
1418         // Get screens ordered by rank.
1419         final Cursor sc = contentResolver.query(screensUri, null, null, null,
1420                 LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1421         ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1422         try {
1423             final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);
1424             while (sc.moveToNext()) {
1425                 try {
1426                     screenIds.add(sc.getLong(idIndex));
1427                 } catch (Exception e) {
1428                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;
1429                             + &quot; - invalid screens: &quot; + e, true);
1430                 }
1431             }
1432         } finally {
1433             sc.close();
1434         }
1435         return screenIds;
1436     }
1437 
1438     public boolean isAllAppsLoaded() {
1439         return mAllAppsLoaded;
1440     }
1441 
1442     boolean isLoadingWorkspace() {
1443         synchronized (mLock) {
1444             if (mLoaderTask != null) {
1445                 return mLoaderTask.isLoadingWorkspace();
1446             }
1447         }
1448         return false;
1449     }
1450 
1451     /**
1452      * Runnable for the thread that loads the contents of the launcher:
1453      *   - workspace icons
1454      *   - widgets
1455      *   - all apps icons
1456      */
1457     private class LoaderTask implements Runnable {
1458         private Context mContext;
1459         @Thunk boolean mIsLoadingAndBindingWorkspace;
1460         private boolean mStopped;
1461         @Thunk boolean mLoadAndBindStepFinished;
1462         private int mFlags;
1463 
1464         LoaderTask(Context context, int flags) {
1465             mContext = context;
1466             mFlags = flags;
1467         }
1468 
1469         boolean isLoadingWorkspace() {
1470             return mIsLoadingAndBindingWorkspace;
1471         }
1472 
1473         private void loadAndBindWorkspace() {
1474             mIsLoadingAndBindingWorkspace = true;
1475 
1476             // Load the workspace
1477             if (DEBUG_LOADERS) {
1478                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1479             }
1480 
1481             if (!mWorkspaceLoaded) {
1482                 loadWorkspace();
1483                 synchronized (LoaderTask.this) {
1484                     if (mStopped) {
1485                         return;
1486                     }
1487                     mWorkspaceLoaded = true;
1488                 }
1489             }
1490 
1491             // Bind the workspace
1492             bindWorkspace(-1);
1493         }
1494 
1495         private void waitForIdle() {
1496             // Wait until the either we&#x27;re stopped or the other threads are done.
1497             // This way we don&#x27;t start loading all apps until the workspace has settled
1498             // down.
1499             synchronized (LoaderTask.this) {
1500                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1501 
1502                 mHandler.postIdle(new Runnable() {
1503                         public void run() {
1504                             synchronized (LoaderTask.this) {
1505                                 mLoadAndBindStepFinished = true;
1506                                 if (DEBUG_LOADERS) {
1507                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1508                                 }
1509                                 LoaderTask.this.notify();
1510                             }
1511                         }
1512                     });
1513 
1514                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1515                     try {
1516                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1517                         // wait no longer than 1sec at a time
1518                         this.wait(1000);
1519                     } catch (InterruptedException ex) {
1520                         // Ignore
1521                     }
1522                 }
1523                 if (DEBUG_LOADERS) {
1524                     Log.d(TAG, &quot;waited &quot;
1525                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1526                             + &quot;ms for previous step to finish binding&quot;);
1527                 }
1528             }
1529         }
1530 
1531         void runBindSynchronousPage(int synchronousBindPage) {
1532             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1533                 // Ensure that we have a valid page index to load synchronously
1534                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1535                         &quot;valid page index&quot;);
1536             }
1537             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1538                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1539                 // loaded already (we should load everything asynchronously in that case)
1540                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1541             }
1542             synchronized (mLock) {
1543                 if (mIsLoaderTaskRunning) {
1544                     // Ensure that we are never running the background loading at this point since
1545                     // we also touch the background collections
1546                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1547                 }
1548             }
1549 
1550             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1551             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1552             //      this call is synchronous, we can get away with not locking).
1553 
1554             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1555             // operations from the previous activity.  We need to ensure that all queued operations
1556             // are executed before any synchronous binding work is done.
1557             mHandler.flush();
1558 
1559             // Divide the set of loaded items into those that we are binding synchronously, and
1560             // everything else that is to be bound normally (asynchronously).
1561             bindWorkspace(synchronousBindPage);
1562             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1563             //      arise from that.
1564             onlyBindAllApps();
1565         }
1566 
1567         public void run() {
1568             synchronized (mLock) {
1569                 if (mStopped) {
1570                     return;
1571                 }
1572                 mIsLoaderTaskRunning = true;
1573             }
1574             // Optimize for end-user experience: if the Launcher is up and // running with the
1575             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1576             // workspace first (default).
1577             keep_running: {
1578                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1579                 loadAndBindWorkspace();
1580 
1581                 if (mStopped) {
1582                     break keep_running;
1583                 }
1584 
1585                 waitForIdle();
1586 
1587                 // second step
1588                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1589                 loadAndBindAllApps();
1590             }
1591 
1592             // Clear out this reference, otherwise we end up holding it until all of the
1593             // callback runnables are done.
1594             mContext = null;
1595 
1596             synchronized (mLock) {
1597                 // If we are still the last one to be scheduled, remove ourselves.
1598                 if (mLoaderTask == this) {
1599                     mLoaderTask = null;
1600                 }
1601                 mIsLoaderTaskRunning = false;
1602                 mHasLoaderCompletedOnce = true;
1603             }
1604         }
1605 
1606         public void stopLocked() {
1607             synchronized (LoaderTask.this) {
1608                 mStopped = true;
1609                 this.notify();
1610             }
1611         }
1612 
1613         /**
1614          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1615          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1616          * object that was around when the deferred message was scheduled, and if there&#x27;s
1617          * a new Callbacks object around then also return null.  This will save us from
1618          * calling onto it with data that will be ignored.
1619          */
1620         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1621             synchronized (mLock) {
1622                 if (mStopped) {
1623                     return null;
1624                 }
1625 
1626                 if (mCallbacks == null) {
1627                     return null;
1628                 }
1629 
1630                 final Callbacks callbacks = mCallbacks.get();
1631                 if (callbacks != oldCallbacks) {
1632                     return null;
1633                 }
1634                 if (callbacks == null) {
1635                     Log.w(TAG, &quot;no mCallbacks&quot;);
1636                     return null;
1637                 }
1638 
1639                 return callbacks;
1640             }
1641         }
1642 
1643         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1644         private boolean checkItemPlacement(LongArrayMap&lt;ItemInfo[][]&gt; occupied, ItemInfo item) {
1645             LauncherAppState app = LauncherAppState.getInstance();
1646             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1647             final int countX = (int) profile.numColumns;
1648             final int countY = (int) profile.numRows;
1649 
1650             long containerIndex = item.screenId;
1651             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1652                 // Return early if we detect that an item is under the hotseat button
1653                 if (mCallbacks == null ||
1654                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1655                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1656                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1657                             + item.cellY + &quot;) occupied by all apps&quot;);
1658                     return false;
1659                 }
1660 
1661                 final ItemInfo[][] hotseatItems =
1662                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1663 
1664                 if (item.screenId &gt;= profile.numHotseatIcons) {
1665                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1666                             + &quot; into hotseat position &quot; + item.screenId
1667                             + &quot;, position out of bounds: (0 to &quot; + (profile.numHotseatIcons - 1)
1668                             + &quot;)&quot;);
1669                     return false;
1670                 }
1671 
1672                 if (hotseatItems != null) {
1673                     if (hotseatItems[(int) item.screenId][0] != null) {
1674                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1675                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1676                                 + item.cellY + &quot;) occupied by &quot;
1677                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1678                                 [(int) item.screenId][0]);
1679                             return false;
1680                     } else {
1681                         hotseatItems[(int) item.screenId][0] = item;
1682                         return true;
1683                     }
1684                 } else {
1685                     final ItemInfo[][] items = new ItemInfo[(int) profile.numHotseatIcons][1];
1686                     items[(int) item.screenId][0] = item;
1687                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1688                     return true;
1689                 }
1690             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1691                 // Skip further checking if it is not the hotseat or workspace container
1692                 return true;
1693             }
1694 
1695             if (!occupied.containsKey(item.screenId)) {
1696                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1697                 occupied.put(item.screenId, items);
1698             }
1699 
1700             final ItemInfo[][] screens = occupied.get(item.screenId);
1701             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1702                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1703                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1704                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1705                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1706                         + item.cellX + &quot;,&quot; + item.cellY
1707                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1708                 return false;
1709             }
1710 
1711             // Check if any workspace icons overlap with each other
1712             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1713                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1714                     if (screens[x][y] != null) {
1715                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1716                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1717                             + x + &quot;,&quot; + y
1718                             + &quot;) occupied by &quot;
1719                             + screens[x][y]);
1720                         return false;
1721                     }
1722                 }
1723             }
1724             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1725                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1726                     screens[x][y] = item;
1727                 }
1728             }
1729 
1730             return true;
1731         }
1732 
1733         /** Clears all the sBg data structures */
1734         private void clearSBgDataStructures() {
1735             synchronized (sBgLock) {
1736                 sBgWorkspaceItems.clear();
1737                 sBgAppWidgets.clear();
1738                 sBgFolders.clear();
1739                 sBgItemsIdMap.clear();
1740                 sBgWorkspaceScreens.clear();
1741             }
1742         }
1743 
1744         private void loadWorkspace() {
1745             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1746 
1747             final Context context = mContext;
1748             final ContentResolver contentResolver = context.getContentResolver();
1749             final PackageManager manager = context.getPackageManager();
1750             final boolean isSafeMode = manager.isSafeMode();
1751             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1752             final boolean isSdCardReady = context.registerReceiver(null,
1753                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1754 
1755             LauncherAppState app = LauncherAppState.getInstance();
1756             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1757             int countX = (int) profile.numColumns;
1758             int countY = (int) profile.numRows;
1759 
1760             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1761                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1762                 LauncherAppState.getLauncherProvider().deleteDatabase();
1763             }
1764 
1765             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1766                 // append the user&#x27;s Launcher2 shortcuts
1767                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1768                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1769             } else {
1770                 // Make sure the default workspace is loaded
1771                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1772                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1773             }
1774 
1775             synchronized (sBgLock) {
1776                 clearSBgDataStructures();
1777                 final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat
1778                         .getInstance(mContext).updateAndGetActiveSessionCache();
1779 
1780                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1781                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1782                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1783                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1784                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1785 
1786                 // +1 for the hotseat (it can be larger than the workspace)
1787                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1788                 // before any earlier duplicates)
1789                 final LongArrayMap&lt;ItemInfo[][]&gt; occupied = new LongArrayMap&lt;&gt;();
1790 
1791                 try {
1792                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1793                     final int intentIndex = c.getColumnIndexOrThrow
1794                             (LauncherSettings.Favorites.INTENT);
1795                     final int titleIndex = c.getColumnIndexOrThrow
1796                             (LauncherSettings.Favorites.TITLE);
1797                     final int containerIndex = c.getColumnIndexOrThrow(
1798                             LauncherSettings.Favorites.CONTAINER);
1799                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1800                             LauncherSettings.Favorites.ITEM_TYPE);
1801                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1802                             LauncherSettings.Favorites.APPWIDGET_ID);
1803                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1804                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1805                     final int screenIndex = c.getColumnIndexOrThrow(
1806                             LauncherSettings.Favorites.SCREEN);
1807                     final int cellXIndex = c.getColumnIndexOrThrow
1808                             (LauncherSettings.Favorites.CELLX);
1809                     final int cellYIndex = c.getColumnIndexOrThrow
1810                             (LauncherSettings.Favorites.CELLY);
1811                     final int spanXIndex = c.getColumnIndexOrThrow
1812                             (LauncherSettings.Favorites.SPANX);
1813                     final int spanYIndex = c.getColumnIndexOrThrow(
1814                             LauncherSettings.Favorites.SPANY);
1815                     final int rankIndex = c.getColumnIndexOrThrow(
1816                             LauncherSettings.Favorites.RANK);
1817                     final int restoredIndex = c.getColumnIndexOrThrow(
1818                             LauncherSettings.Favorites.RESTORED);
1819                     final int profileIdIndex = c.getColumnIndexOrThrow(
1820                             LauncherSettings.Favorites.PROFILE_ID);
1821                     final int optionsIndex = c.getColumnIndexOrThrow(
1822                             LauncherSettings.Favorites.OPTIONS);
1823                     final CursorIconInfo cursorIconInfo = new CursorIconInfo(c);
1824 
1825                     final LongSparseArray&lt;UserHandleCompat&gt; allUsers = new LongSparseArray&lt;&gt;();
1826                     for (UserHandleCompat user : mUserManager.getUserProfiles()) {
1827                         allUsers.put(mUserManager.getSerialNumberForUser(user), user);
1828                     }
1829 
1830                     ShortcutInfo info;
1831                     String intentDescription;
1832                     LauncherAppWidgetInfo appWidgetInfo;
1833                     int container;
1834                     long id;
1835                     long serialNumber;
1836                     Intent intent;
1837                     UserHandleCompat user;
1838 
1839                     while (!mStopped &amp;&amp; c.moveToNext()) {
1840                         try {
1841                             int itemType = c.getInt(itemTypeIndex);
1842                             boolean restored = 0 != c.getInt(restoredIndex);
1843                             boolean allowMissingTarget = false;
1844                             container = c.getInt(containerIndex);
1845 
1846                             switch (itemType) {
1847                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1848                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1849                                 id = c.getLong(idIndex);
1850                                 intentDescription = c.getString(intentIndex);
1851                                 serialNumber = c.getInt(profileIdIndex);
1852                                 user = allUsers.get(serialNumber);
1853                                 int promiseType = c.getInt(restoredIndex);
1854                                 int disabledState = 0;
1855                                 boolean itemReplaced = false;
1856                                 if (user == null) {
1857                                     // User has been deleted remove the item.
1858                                     itemsToRemove.add(id);
1859                                     continue;
1860                                 }
1861                                 try {
1862                                     intent = Intent.parseUri(intentDescription, 0);
1863                                     ComponentName cn = intent.getComponent();
1864                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
1865                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
1866                                                 cn.getPackageName(), user);
1867                                         boolean validComponent = validPkg &amp;&amp;
1868                                                 launcherApps.isActivityEnabledForProfile(cn, user);
1869 
1870                                         if (validComponent) {
1871                                             if (restored) {
1872                                                 // no special handling necessary for this item
1873                                                 restoredRows.add(id);
1874                                                 restored = false;
1875                                             }
1876                                         } else if (validPkg) {
1877                                             intent = null;
1878                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
1879                                                 // We allow auto install apps to have their intent
1880                                                 // updated after an install.
1881                                                 intent = manager.getLaunchIntentForPackage(
1882                                                         cn.getPackageName());
1883                                                 if (intent != null) {
1884                                                     ContentValues values = new ContentValues();
1885                                                     values.put(LauncherSettings.Favorites.INTENT,
1886                                                             intent.toUri(0));
1887                                                     updateItem(id, values);
1888                                                 }
1889                                             }
1890 
1891                                             if (intent == null) {
1892                                                 // The app is installed but the component is no
1893                                                 // longer available.
1894                                                 Launcher.addDumpLog(TAG,
1895                                                         &quot;Invalid component removed: &quot; + cn, true);
1896                                                 itemsToRemove.add(id);
1897                                                 continue;
1898                                             } else {
1899                                                 // no special handling necessary for this item
1900                                                 restoredRows.add(id);
1901                                                 restored = false;
1902                                             }
1903                                         } else if (restored) {
1904                                             // Package is not yet available but might be
1905                                             // installed later.
1906                                             Launcher.addDumpLog(TAG,
1907                                                     &quot;package not yet restored: &quot; + cn, true);
1908 
1909                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
1910                                                 // Restore has started once.
1911                                             } else if (installingPkgs.containsKey(cn.getPackageName())) {
1912                                                 // App restore has started. Update the flag
1913                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
1914                                                 ContentValues values = new ContentValues();
1915                                                 values.put(LauncherSettings.Favorites.RESTORED,
1916                                                         promiseType);
1917                                                 updateItem(id, values);
<abbr title="1918                                             } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE) != 0) {">1918                                             } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE🔵</abbr>
1919                                                 // This is a common app. Try to replace this.
<abbr title="1920                                                 int appType = CommonAppTypeParser.decodeItemTypeFromFlag(promiseType);">1920                                                 int appType = CommonAppTypeParser.decodeItemTypeFromFlag(🔵</abbr>
<abbr title="1921                                                 CommonAppTypeParser parser = new CommonAppTypeParser(id, appType, context);">1921                                                 CommonAppTypeParser parser = new CommonAppTypeParser(id, 🔵</abbr>
1922                                                 if (parser.findDefaultApp()) {
1923                                                     // Default app found. Replace it.
1924                                                     intent = parser.parsedIntent;
1925                                                     cn = intent.getComponent();
1926                                                     ContentValues values = parser.parsedValues;
1927                                                     values.put(LauncherSettings.Favorites.RESTORED, 0);
1928                                                     updateItem(id, values);
1929                                                     restored = false;
1930                                                     itemReplaced = true;
1931 
1932                                                 } else if (REMOVE_UNRESTORED_ICONS) {
1933                                                     Launcher.addDumpLog(TAG,
1934                                                             &quot;Unrestored package removed: &quot; + cn, true);
1935                                                     itemsToRemove.add(id);
1936                                                     continue;
1937                                                 }
1938                                             } else if (REMOVE_UNRESTORED_ICONS) {
1939                                                 Launcher.addDumpLog(TAG,
1940                                                         &quot;Unrestored package removed: &quot; + cn, true);
1941                                                 itemsToRemove.add(id);
1942                                                 continue;
1943                                             }
1944                                         } else if (launcherApps.isAppEnabled(
1945                                                 manager, cn.getPackageName(),
1946                                                 PackageManager.GET_UNINSTALLED_PACKAGES)) {
1947                                             // Package is present but not available.
1948                                             allowMissingTarget = true;
1949                                             disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
1950                                         } else if (!isSdCardReady) {
1951                                             // SdCard is not ready yet. Package might get available,
1952                                             // once it is ready.
1953                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
1954                                                     + &quot; (check again later)&quot;, true);
1955                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
1956                                             if (pkgs == null) {
1957                                                 pkgs = new HashSet&lt;String&gt;();
1958                                                 sPendingPackages.put(user, pkgs);
1959                                             }
1960                                             pkgs.add(cn.getPackageName());
1961                                             allowMissingTarget = true;
1962                                             // Add the icon on the workspace anyway.
1963 
1964                                         } else {
1965                                             // Do not wait for external media load anymore.
1966                                             // Log the invalid package, and remove it
1967                                             Launcher.addDumpLog(TAG,
1968                                                     &quot;Invalid package removed: &quot; + cn, true);
1969                                             itemsToRemove.add(id);
1970                                             continue;
1971                                         }
1972                                     } else if (cn == null) {
1973                                         // For shortcuts with no component, keep them as they are
1974                                         restoredRows.add(id);
1975                                         restored = false;
1976                                     }
1977                                 } catch (URISyntaxException e) {
1978                                     Launcher.addDumpLog(TAG,
1979                                             &quot;Invalid uri: &quot; + intentDescription, true);
1980                                     continue;
1981                                 }
1982 
1983                                 boolean useLowResIcon = container &gt;= 0 &amp;&amp;
1984                                         c.getInt(rankIndex) &gt;= FolderIcon.NUM_ITEMS_IN_PREVIEW;
1985 
1986                                 if (itemReplaced) {
1987                                     if (user.equals(UserHandleCompat.myUserHandle())) {
1988                                         info = getAppShortcutInfo(manager, intent, user, context, null,
1989                                                 cursorIconInfo.iconIndex, titleIndex,
1990                                                 false, useLowResIcon);
1991                                     } else {
1992                                         // Don&#x27;t replace items for other profiles.
1993                                         itemsToRemove.add(id);
1994                                         continue;
1995                                     }
1996                                 } else if (restored) {
1997                                     if (user.equals(UserHandleCompat.myUserHandle())) {
1998                                         Launcher.addDumpLog(TAG,
1999                                                 &quot;constructing info for partially restored package&quot;,
2000                                                 true);
2001                                         info = getRestoredItemInfo(c, titleIndex, intent,
2002                                                 promiseType, itemType, cursorIconInfo, context);
2003                                         intent = getRestoredItemIntent(c, context, intent);
2004                                     } else {
2005                                         // Don&#x27;t restore items for other profiles.
2006                                         itemsToRemove.add(id);
2007                                         continue;
2008                                     }
2009                                 } else if (itemType ==
2010                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2011                                     info = getAppShortcutInfo(manager, intent, user, context, c,
2012                                             cursorIconInfo.iconIndex, titleIndex,
2013                                             allowMissingTarget, useLowResIcon);
2014                                 } else {
2015                                     info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);
2016 
2017                                     // App shortcuts that used to be automatically added to Launcher
2018                                     // didn&#x27;t always have the correct intent flags set, so do that
2019                                     // here
2020                                     if (intent.getAction() != null &amp;&amp;
2021                                         intent.getCategories() != null &amp;&amp;
2022                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2023                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2024                                         intent.addFlags(
2025                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2026                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2027                                     }
2028                                 }
2029 
2030                                 if (info != null) {
2031                                     info.id = id;
2032                                     info.intent = intent;
2033                                     info.container = container;
2034                                     info.screenId = c.getInt(screenIndex);
2035                                     info.cellX = c.getInt(cellXIndex);
2036                                     info.cellY = c.getInt(cellYIndex);
2037                                     info.rank = c.getInt(rankIndex);
2038                                     info.spanX = 1;
2039                                     info.spanY = 1;
2040                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2041                                     if (info.promisedIntent != null) {
<abbr title="2042                                         info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);">2042                                         info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber🔵</abbr>
2043                                     }
2044                                     info.isDisabled = disabledState;
2045                                     if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2046                                         info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2047                                     }
2048 
2049                                     // check &amp; update map of what&#x27;s occupied
2050                                     if (!checkItemPlacement(occupied, info)) {
2051                                         itemsToRemove.add(id);
2052                                         break;
2053                                     }
2054 
2055                                     if (restored) {
2056                                         ComponentName cn = info.getTargetComponent();
2057                                         if (cn != null) {
2058                                             Integer progress = installingPkgs.get(cn.getPackageName());
2059                                             if (progress != null) {
2060                                                 info.setInstallProgress(progress);
2061                                             } else {
2062                                                 info.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
2063                                             }
2064                                         }
2065                                     }
2066 
2067                                     switch (container) {
2068                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2069                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2070                                         sBgWorkspaceItems.add(info);
2071                                         break;
2072                                     default:
2073                                         // Item is in a user folder
2074                                         FolderInfo folderInfo =
2075                                                 findOrMakeFolder(sBgFolders, container);
2076                                         folderInfo.add(info);
2077                                         break;
2078                                     }
2079                                     sBgItemsIdMap.put(info.id, info);
2080                                 } else {
2081                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2082                                 }
2083                                 break;
2084 
2085                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2086                                 id = c.getLong(idIndex);
2087                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2088 
2089                                 // Do not trim the folder label, as is was set by the user.
2090                                 folderInfo.title = c.getString(titleIndex);
2091                                 folderInfo.id = id;
2092                                 folderInfo.container = container;
2093                                 folderInfo.screenId = c.getInt(screenIndex);
2094                                 folderInfo.cellX = c.getInt(cellXIndex);
2095                                 folderInfo.cellY = c.getInt(cellYIndex);
2096                                 folderInfo.spanX = 1;
2097                                 folderInfo.spanY = 1;
2098                                 folderInfo.options = c.getInt(optionsIndex);
2099 
2100                                 // check &amp; update map of what&#x27;s occupied
2101                                 if (!checkItemPlacement(occupied, folderInfo)) {
2102                                     itemsToRemove.add(id);
2103                                     break;
2104                                 }
2105 
2106                                 switch (container) {
2107                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2108                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2109                                         sBgWorkspaceItems.add(folderInfo);
2110                                         break;
2111                                 }
2112 
2113                                 if (restored) {
2114                                     // no special handling required for restored folders
2115                                     restoredRows.add(id);
2116                                 }
2117 
2118                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2119                                 sBgFolders.put(folderInfo.id, folderInfo);
2120                                 break;
2121 
2122                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2123                             case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
2124                                 // Read all Launcher-specific widget details
2125                                 boolean customWidget = itemType ==
2126                                     LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;
2127 
2128                                 id = c.getLong(idIndex);
2129                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2130                                 serialNumber = c.getLong(profileIdIndex);
2131                                 String savedProvider = c.getString(appWidgetProviderIndex);
2132                                 id = c.getLong(idIndex);
2133                                 user = allUsers.get(serialNumber);
2134                                 if (user == null) {
2135                                     itemsToRemove.add(id);
2136                                     continue;
2137                                 }
2138 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2139 </span>
2140 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2141                                     info.rank = c.getInt(rankIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2142                                     info.spanX = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2143                                     info.spanY = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2144                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2145                                     info.isDisabled = disabledState;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2146                                     if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2147                                         info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2148                                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2149 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2150                                     // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2151                                     if (!checkItemPlacement(occupied, info)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2152                                         itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2153                                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2154                                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2155 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2156                                     switch (container) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2157                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2158                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2159                                         sBgWorkspaceItems.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2160                                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2161                                     default:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2162                                         // Item is in a user folder</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2163                                         FolderInfo folderInfo =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2164                                                 findOrMakeFolder(sBgFolders, container);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2165                                         folderInfo.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2166                                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2167                                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2168                                     sBgItemsIdMap.put(info.id, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2169 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2170                                     // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2171                                     // icon in case it disappears somehow.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2172                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2173                                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2174                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2175                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2176                                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2177 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2178                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2179                                 id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2180                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2181 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2182                                 folderInfo.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2183                                 folderInfo.id = id;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2184                                 container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2185                                 folderInfo.container = container;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2186                                 folderInfo.screenId = c.getInt(screenIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2187                                 folderInfo.cellX = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2188                                 folderInfo.cellY = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2189                                 folderInfo.spanX = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2190                                 folderInfo.spanY = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2191 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2192                                 // check &amp; update map of what&#x27;s occupied</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2193                                 if (!checkItemPlacement(occupied, folderInfo)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2194                                     itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2195                                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2196                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2197 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2198                                 switch (container) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2199                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2200                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2201                                         sBgWorkspaceItems.add(folderInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2202                                         break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2203                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2204 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2205                                 if (restored) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2206                                     // no special handling required for restored folders</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2207                                     restoredRows.add(id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2208                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2209 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2210                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2211                                 sBgFolders.put(folderInfo.id, folderInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2212                                 break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2213 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2214                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2215                             case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2216                                 // Read all Launcher-specific widget details</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2217                                 boolean customWidget = itemType ==</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2218                                     LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2219 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2220                                 int appWidgetId = c.getInt(appWidgetIdIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2221                                 serialNumber= c.getLong(profileIdIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2222                                 user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2223                                 if (user == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2224                                     // User has been deleted remove the item.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2225                                     itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2226                                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2227                                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2228                                 String savedProvider = c.getString(appWidgetProviderIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2229                                 id = c.getLong(idIndex);</span>
2230 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2231                                 String savedProvider = c.getString(appWidgetProviderIndex);</span>
2232 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
2233                                 final ComponentName component =
2234                                         ComponentName.unflattenFromString(savedProvider);
2235 
2236                                 final int restoreStatus = c.getInt(restoredIndex);
2237                                 final boolean isIdValid = (restoreStatus &amp;
2238                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2239                                 final boolean wasProviderReady = (restoreStatus &amp;
2240                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2241 
2242                                 final LauncherAppWidgetProviderInfo provider =
2243                                         LauncherModel.getProviderInfo(context,
2244                                                 ComponentName.unflattenFromString(savedProvider),
2245                                                 user);
2246 
2247                                 final boolean isProviderReady = isValidProvider(provider);
2248                                 if (!isSafeMode &amp;&amp; !customWidget &amp;&amp;
2249                                         wasProviderReady &amp;&amp; !isProviderReady) {
2250                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2251                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2252 
2253                                     Log.e(TAG, log);
2254                                     Launcher.addDumpLog(TAG, log, false);
2255                                     itemsToRemove.add(id);
2256                                 } else {
2257                                     if (isProviderReady) {
2258                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2259                                                 provider.provider);
2260 
2261                                         int status = restoreStatus;
2262                                         if (!wasProviderReady) {
2263                                             // If provider was not previously ready, update the
2264                                             // status and UI flag.
2265 
<abbr title="2266                                             // Id would be valid only if the widget restore broadcast was received.">2266                                             // Id would be valid only if the widget restore broadcast was🔵</abbr>
2267                                             if (isIdValid) {
2268                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2269                                             } else {
2270                                                 status &amp;= ~LauncherAppWidgetInfo
2271                                                         .FLAG_PROVIDER_NOT_READY;
2272                                             }
2273                                         }
2274                                         appWidgetInfo.restoreStatus = status;
2275                                     } else {
2276                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2277                                                 + &quot; appWidgetId=&quot; + appWidgetId
2278                                                 + &quot; status =&quot; + restoreStatus);
2279                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2280                                                 component);
2281                                         appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2282                                         Integer installProgress = installingPkgs.get(component.getPackageName());">2282                                         Integer installProgress = installingPkgs.get(component.getPackage🔵</abbr>
2283 
<abbr title="2284                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2284                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) 🔵</abbr>
2285                                             // Restore has started once.
2286                                         } else if (installProgress != null) {
2287                                             // App restore has started. Update the flag
2288                                             appWidgetInfo.restoreStatus |=
2289                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2290                                         } else if (REMOVE_UNRESTORED_ICONS &amp;&amp; !isSafeMode) {
2291                                             Launcher.addDumpLog(TAG,
2292                                                     &quot;Unrestored widget removed: &quot; + component, true);
2293                                             itemsToRemove.add(id);
2294                                             continue;
2295                                         }
2296 
2297                                         appWidgetInfo.installProgress =
2298                                                 installProgress == null ? 0 : installProgress;
2299                                     }
2300 
2301                                     appWidgetInfo.id = id;
2302                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2303                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2304                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2305                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2306                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2307 
2308                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2309                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2310                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2311                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2312                                         continue;
2313                                     }
2314 
2315                                     appWidgetInfo.container = container;
2316                                     // check &amp; update map of what&#x27;s occupied
2317                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
2318                                         itemsToRemove.add(id);
2319                                         break;
2320                                     }
2321 
2322                                     if (!customWidget) {
2323                                         String providerName =
2324                                                 appWidgetInfo.providerName.flattenToString();
2325                                         if (!providerName.equals(savedProvider) ||
2326                                                 (appWidgetInfo.restoreStatus != restoreStatus)) {
2327                                             ContentValues values = new ContentValues();
2328                                             values.put(
2329                                                     LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2330                                                     providerName);
2331                                             values.put(LauncherSettings.Favorites.RESTORED,
2332                                                     appWidgetInfo.restoreStatus);
2333                                             updateItem(id, values);
2334                                         }
2335                                     }
2336                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2337                                     sBgAppWidgets.add(appWidgetInfo);
2338                                 }
2339                                 break;
2340                             }
2341                         } catch (Exception e) {
2342                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2343                         }
2344                     }
2345                 } finally {
2346                     if (c != null) {
2347                         c.close();
2348                     }
2349                 }
2350 
2351                 // Break early if we&#x27;ve stopped loading
2352                 if (mStopped) {
2353                     clearSBgDataStructures();
2354                     return;
2355                 }
2356 
2357                 if (itemsToRemove.size() &gt; 0) {
2358                     // Remove dead items
2359                     contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI,
2360                             Utilities.createDbSelectionQuery(
2361                                     LauncherSettings.Favorites._ID, itemsToRemove), null);
2362                     if (DEBUG_LOADERS) {
2363                         Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery(
2364                                 LauncherSettings.Favorites._ID, itemsToRemove));
2365                     }
2366 
2367                     // Remove any empty folder
2368                     for (long folderId : LauncherAppState.getLauncherProvider()
2369                             .deleteEmptyFolders()) {
2370                         sBgWorkspaceItems.remove(sBgFolders.get(folderId));
2371                         sBgFolders.remove(folderId);
2372                         sBgItemsIdMap.remove(folderId);
2373                     }
2374                 }
2375 
2376                 if (restoredRows.size() &gt; 0) {
2377                     // Update restored items that no longer require special handling
2378                     ContentValues values = new ContentValues();
2379                     values.put(LauncherSettings.Favorites.RESTORED, 0);
2380                     contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values,
2381                             Utilities.createDbSelectionQuery(
2382                                     LauncherSettings.Favorites._ID, restoredRows), null);
2383                 }
2384 
2385                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2386                     context.registerReceiver(new AppsAvailabilityCheck(),
2387                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2388                             null, sWorker);
2389                 }
2390 
2391                 sBgWorkspaceScreens.addAll(loadWorkspaceScreensDb(mContext));
2392 
2393                 // Remove any empty screens
2394                 ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2395                 for (ItemInfo item: sBgItemsIdMap) {
2396                     long screenId = item.screenId;
2397                     if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2398                             unusedScreens.contains(screenId)) {
2399                         unusedScreens.remove(screenId);
2400                     }
2401                 }
2402 
2403                 // If there are any empty screens remove them, and update.
2404                 if (unusedScreens.size() != 0) {
2405                     sBgWorkspaceScreens.removeAll(unusedScreens);
2406                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2407                 }
2408 
2409                 if (DEBUG_LOADERS) {
2410                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2411                     Log.d(TAG, &quot;workspace layout: &quot;);
2412                     int nScreens = occupied.size();
2413                     for (int y = 0; y &lt; countY; y++) {
2414                         String line = &quot;&quot;;
2415 
2416                         for (int i = 0; i &lt; nScreens; i++) {
2417                             long screenId = occupied.keyAt(i);
2418                             if (screenId &gt; 0) {
2419                                 line += &quot; | &quot;;
2420                             }
2421                             ItemInfo[][] screen = occupied.valueAt(i);
2422                             for (int x = 0; x &lt; countX; x++) {
2423                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2424                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2425                                 } else {
2426                                     line += &quot;!&quot;;
2427                                 }
2428                             }
2429                         }
2430                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2431                     }
2432                 }
2433             }
2434         }
2435 
2436         /**
2437          * Partially updates the item without any notification. Must be called on the worker thread.
2438          */
2439         private void updateItem(long itemId, ContentValues update) {
2440             mContext.getContentResolver().update(
2441                     LauncherSettings.Favorites.CONTENT_URI,
2442                     update,
2443                     BaseColumns._ID + &quot;= ?&quot;,
2444                     new String[]{Long.toString(itemId)});
2445         }
2446 
2447         /** Filters the set of items who are directly or indirectly (via another container) on the
2448          * specified screen. */
2449         private void filterCurrentWorkspaceItems(long currentScreenId,
2450                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2451                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2452                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2453             // Purge any null ItemInfos
2454             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2455             while (iter.hasNext()) {
2456                 ItemInfo i = iter.next();
2457                 if (i == null) {
2458                     iter.remove();
2459                 }
2460             }
2461 
2462             // Order the set of items by their containers first, this allows use to walk through the
2463             // list sequentially, build up a list of containers that are in the specified screen,
2464             // as well as all items in those containers.
2465             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2466             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2467                 @Override
2468                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2469                     return (int) (lhs.container - rhs.container);
2470                 }
2471             });
2472             for (ItemInfo info : allWorkspaceItems) {
2473                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2474                     if (info.screenId == currentScreenId) {
2475                         currentScreenItems.add(info);
2476                         itemsOnScreen.add(info.id);
2477                     } else {
2478                         otherScreenItems.add(info);
2479                     }
2480                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2481                     currentScreenItems.add(info);
2482                     itemsOnScreen.add(info.id);
2483                 } else {
2484                     if (itemsOnScreen.contains(info.container)) {
2485                         currentScreenItems.add(info);
2486                         itemsOnScreen.add(info.id);
2487                     } else {
2488                         otherScreenItems.add(info);
2489                     }
2490                 }
2491             }
2492         }
2493 
2494         /** Filters the set of widgets which are on the specified screen. */
2495         private void filterCurrentAppWidgets(long currentScreenId,
2496                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2497                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2498                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2499 
2500             for (LauncherAppWidgetInfo widget : appWidgets) {
2501                 if (widget == null) continue;
2502                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2503                         widget.screenId == currentScreenId) {
2504                     currentScreenWidgets.add(widget);
2505                 } else {
2506                     otherScreenWidgets.add(widget);
2507                 }
2508             }
2509         }
2510 
2511         /** Filters the set of folders which are on the specified screen. */
2512         private void filterCurrentFolders(long currentScreenId,
2513                 LongArrayMap&lt;ItemInfo&gt; itemsIdMap,
2514                 LongArrayMap&lt;FolderInfo&gt; folders,
2515                 LongArrayMap&lt;FolderInfo&gt; currentScreenFolders,
2516                 LongArrayMap&lt;FolderInfo&gt; otherScreenFolders) {
2517 
2518             int total = folders.size();
2519             for (int i = 0; i &lt; total; i++) {
2520                 long id = folders.keyAt(i);
2521                 FolderInfo folder = folders.valueAt(i);
2522 
2523                 ItemInfo info = itemsIdMap.get(id);
2524                 if (info == null || folder == null) continue;
2525                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2526                         info.screenId == currentScreenId) {
2527                     currentScreenFolders.put(id, folder);
2528                 } else {
2529                     otherScreenFolders.put(id, folder);
2530                 }
2531             }
2532         }
2533 
2534         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2535          * right) */
2536         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2537             final LauncherAppState app = LauncherAppState.getInstance();
2538             final InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
2539             // XXX: review this
2540             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2541                 @Override
2542                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2543                     int cellCountX = (int) profile.numColumns;
2544                     int cellCountY = (int) profile.numRows;
2545                     int screenOffset = cellCountX * cellCountY;
2546                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2547                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2548                             lhs.cellY * cellCountX + lhs.cellX);
2549                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2550                             rhs.cellY * cellCountX + rhs.cellX);
2551                     return (int) (lr - rr);
2552                 }
2553             });
2554         }
2555 
2556         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2557                 final ArrayList&lt;Long&gt; orderedScreens) {
2558             final Runnable r = new Runnable() {
2559                 @Override
2560                 public void run() {
2561                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2562                     if (callbacks != null) {
2563                         callbacks.bindScreens(orderedScreens);
2564                     }
2565                 }
2566             };
2567             runOnMainThread(r);
2568         }
2569 
2570         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2571                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2572                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2573                 final LongArrayMap&lt;FolderInfo&gt; folders,
2574                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2575 
2576             final boolean postOnMainThread = (deferredBindRunnables != null);
2577 
2578             // Bind the workspace items
2579             int N = workspaceItems.size();
2580             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2581                 final int start = i;
2582                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2583                 final Runnable r = new Runnable() {
2584                     @Override
2585                     public void run() {
2586                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2587                         if (callbacks != null) {
2588                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2589                                     false);
2590                         }
2591                     }
2592                 };
2593                 if (postOnMainThread) {
2594                     synchronized (deferredBindRunnables) {
2595                         deferredBindRunnables.add(r);
2596                     }
2597                 } else {
2598                     runOnMainThread(r);
2599                 }
2600             }
2601 
2602             // Bind the folders
2603             if (!folders.isEmpty()) {
2604                 final Runnable r = new Runnable() {
2605                     public void run() {
2606                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2607                         if (callbacks != null) {
2608                             callbacks.bindFolders(folders);
2609                         }
2610                     }
2611                 };
2612                 if (postOnMainThread) {
2613                     synchronized (deferredBindRunnables) {
2614                         deferredBindRunnables.add(r);
2615                     }
2616                 } else {
2617                     runOnMainThread(r);
2618                 }
2619             }
2620 
2621             // Bind the widgets, one at a time
2622             N = appWidgets.size();
2623             for (int i = 0; i &lt; N; i++) {
2624                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2625                 final Runnable r = new Runnable() {
2626                     public void run() {
2627                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2628                         if (callbacks != null) {
2629                             callbacks.bindAppWidget(widget);
2630                         }
2631                     }
2632                 };
2633                 if (postOnMainThread) {
2634                     deferredBindRunnables.add(r);
2635                 } else {
2636                     runOnMainThread(r);
2637                 }
2638             }
2639         }
2640 
2641         /**
2642          * Binds all loaded data to actual views on the main thread.
2643          */
2644         private void bindWorkspace(int synchronizeBindPage) {
2645             final long t = SystemClock.uptimeMillis();
2646             Runnable r;
2647 
2648             // Don&#x27;t use these two variables in any of the callback runnables.
2649             // Otherwise we hold a reference to them.
2650             final Callbacks oldCallbacks = mCallbacks.get();
2651             if (oldCallbacks == null) {
2652                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2653                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2654                 return;
2655             }
2656 
2657             // Save a copy of all the bg-thread collections
2658             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2659             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2660                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2661             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2662 
2663             final LongArrayMap&lt;FolderInfo&gt; folders;
2664             final LongArrayMap&lt;ItemInfo&gt; itemsIdMap;
2665 
2666             synchronized (sBgLock) {
2667                 workspaceItems.addAll(sBgWorkspaceItems);
2668                 appWidgets.addAll(sBgAppWidgets);
2669                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2670 
2671                 folders = sBgFolders.clone();
2672                 itemsIdMap = sBgItemsIdMap.clone();
2673             }
2674 
2675             final boolean isLoadingSynchronously =
2676                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2677             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2678                 oldCallbacks.getCurrentWorkspaceScreen();
2679             if (currScreen &gt;= orderedScreenIds.size()) {
2680                 // There may be no workspace screens (just hotseat items and an empty page).
2681                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2682             }
2683             final int currentScreen = currScreen;
2684             final long currentScreenId = currentScreen &lt; 0
2685                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2686 
2687             // Load all the items that are on the current page first (and in the process, unbind
2688             // all the existing workspace items before we call startBinding() below.
2689             unbindWorkspaceItemsOnMainThread();
2690 
2691             // Separate the items that are on the current screen, and all the other remaining items
2692             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2693             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2694             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2695                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2696             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2697                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2698             LongArrayMap&lt;FolderInfo&gt; currentFolders = new LongArrayMap&lt;&gt;();
2699             LongArrayMap&lt;FolderInfo&gt; otherFolders = new LongArrayMap&lt;&gt;();
2700 
2701             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2702                     otherWorkspaceItems);
2703             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2704                     otherAppWidgets);
2705             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2706                     otherFolders);
2707             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2708             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2709 
2710             // Tell the workspace that we&#x27;re about to start binding items
2711             r = new Runnable() {
2712                 public void run() {
2713                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2714                     if (callbacks != null) {
2715                         callbacks.startBinding();
2716                     }
2717                 }
2718             };
2719             runOnMainThread(r);
2720 
2721             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2722 
2723             // Load items on the current page
2724             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2725                     currentFolders, null);
2726             if (isLoadingSynchronously) {
2727                 r = new Runnable() {
2728                     public void run() {
2729                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2730                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2731                             callbacks.onPageBoundSynchronously(currentScreen);
2732                         }
2733                     }
2734                 };
2735                 runOnMainThread(r);
2736             }
2737 
2738             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2739             // work until after the first render)
2740             synchronized (mDeferredBindRunnables) {
2741                 mDeferredBindRunnables.clear();
2742             }
2743             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2744                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2745 
2746             // Tell the workspace that we&#x27;re done binding items
2747             r = new Runnable() {
2748                 public void run() {
2749                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2750                     if (callbacks != null) {
2751                         callbacks.finishBindingItems();
2752                     }
2753 
2754                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2755                     if (DEBUG_LOADERS) {
2756                         Log.d(TAG, &quot;bound workspace in &quot;
2757                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2758                     }
2759 
2760                     mIsLoadingAndBindingWorkspace = false;
2761                 }
2762             };
2763             if (isLoadingSynchronously) {
2764                 synchronized (mDeferredBindRunnables) {
2765                     mDeferredBindRunnables.add(r);
2766                 }
2767             } else {
2768                 runOnMainThread(r);
2769             }
2770         }
2771 
2772         private void loadAndBindAllApps() {
2773             if (DEBUG_LOADERS) {
2774                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2775             }
2776             if (!mAllAppsLoaded) {
2777                 loadAllApps();
2778                 synchronized (LoaderTask.this) {
2779                     if (mStopped) {
2780                         return;
2781                     }
2782                 }
2783                 updateIconCache();
2784                 synchronized (LoaderTask.this) {
2785                     if (mStopped) {
2786                         return;
2787                     }
2788                     mAllAppsLoaded = true;
2789                 }
2790             } else {
2791                 onlyBindAllApps();
2792             }
2793         }
2794 
2795         private void updateIconCache() {
2796             // Ignore packages which have a promise icon.
2797             HashSet&lt;String&gt; packagesToIgnore = new HashSet&lt;&gt;();
2798             synchronized (sBgLock) {
2799                 for (ItemInfo info : sBgItemsIdMap) {
2800                     if (info instanceof ShortcutInfo) {
2801                         ShortcutInfo si = (ShortcutInfo) info;
2802                         if (si.isPromise() &amp;&amp; si.getTargetComponent() != null) {
2803                             packagesToIgnore.add(si.getTargetComponent().getPackageName());
2804                         }
2805                     } else if (info instanceof LauncherAppWidgetInfo) {
2806                         LauncherAppWidgetInfo lawi = (LauncherAppWidgetInfo) info;
2807                         if (lawi.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {
2808                             packagesToIgnore.add(lawi.providerName.getPackageName());
2809                         }
2810                     }
2811                 }
2812             }
2813             mIconCache.updateDbIcons(packagesToIgnore);
2814         }
2815 
2816         private void onlyBindAllApps() {
2817             final Callbacks oldCallbacks = mCallbacks.get();
2818             if (oldCallbacks == null) {
2819                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2820                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2821                 return;
2822             }
2823 
2824             // shallow copy
2825             @SuppressWarnings(&quot;unchecked&quot;)
2826             final ArrayList&lt;AppInfo&gt; list
2827                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2828             final WidgetsModel widgetList = mBgWidgetsModel.clone();
2829             Runnable r = new Runnable() {
2830                 public void run() {
2831                     final long t = SystemClock.uptimeMillis();
2832                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2833                     if (callbacks != null) {
2834                         callbacks.bindAllApplications(list);
2835                         callbacks.bindAllPackages(widgetList);
2836                     }
2837                     if (DEBUG_LOADERS) {
2838                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2839                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2840                     }
2841                 }
2842             };
2843             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2844             if (isRunningOnMainThread) {
2845                 r.run();
2846             } else {
2847                 mHandler.post(r);
2848             }
2849         }
2850 
2851         private void loadAllApps() {
2852             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2853 
2854             final Callbacks oldCallbacks = mCallbacks.get();
2855             if (oldCallbacks == null) {
2856                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2857                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2858                 return;
2859             }
2860 
2861             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2862 
2863             // Clear the list of apps
2864             mBgAllAppsList.clear();
2865             for (UserHandleCompat user : profiles) {
2866                 // Query for the set of apps
2867                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2868                 final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2869                 if (DEBUG_LOADERS) {
2870                     Log.d(TAG, &quot;getActivityList took &quot;
2871                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2872                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2873                 }
2874                 // Fail if we don&#x27;t have any apps
2875                 // TODO: Fix this. Only fail for the current user.
2876                 if (apps == null || apps.isEmpty()) {
2877                     return;
2878                 }
2879 
2880                 // Create the ApplicationInfos
2881                 for (int i = 0; i &lt; apps.size(); i++) {
2882                     LauncherActivityInfoCompat app = apps.get(i);
2883                     // This builds the icon bitmaps.
2884                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache));
2885                 }
2886 
2887                 final ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(mContext, user);
2888                 if (heuristic != null) {
2889                     runAfterBindCompletes(new Runnable() {
2890 
2891                         @Override
2892                         public void run() {
2893                             heuristic.processUserApps(apps);
2894                         }
2895                     });
2896                 }
2897             }
2898             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2899             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2900             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2901 
2902             // Post callback on main thread
2903             mHandler.post(new Runnable() {
2904                 public void run() {
2905 
2906                     final long bindTime = SystemClock.uptimeMillis();
2907                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2908                     if (callbacks != null) {
2909                         callbacks.bindAllApplications(added);
2910                         if (DEBUG_LOADERS) {
2911                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2912                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2913                         }
2914                     } else {
2915                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2916                     }
2917                 }
2918             });
2919             // Cleanup any data stored for a deleted user.
2920             ManagedProfileHeuristic.processAllUsers(profiles, mContext);
2921 
2922             loadAndBindWidgetsAndShortcuts(mApp.getContext(), tryGetCallbacks(oldCallbacks),
2923                     true /* refresh */);
2924             if (DEBUG_LOADERS) {
2925                 Log.d(TAG, &quot;Icons processed in &quot;
2926                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2927             }
2928         }
2929 
2930         public void dumpState() {
2931             synchronized (sBgLock) {
2932                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2933                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2934                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2935                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2936             }
2937         }
2938     }
2939 
2940     /**
2941      * Called when the icons for packages have been updated in the icon cache.
2942      */
2943     public void onPackageIconsUpdated(HashSet&lt;String&gt; updatedPackages, UserHandleCompat user) {
2944         final Callbacks callbacks = getCallback();
2945         final ArrayList&lt;AppInfo&gt; updatedApps = new ArrayList&lt;&gt;();
2946         final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;&gt;();
2947 
2948         // If any package icon has changed (app was updated while launcher was dead),
2949         // update the corresponding shortcuts.
2950         synchronized (sBgLock) {
2951             for (ItemInfo info : sBgItemsIdMap) {
2952                 if (info instanceof ShortcutInfo &amp;&amp; user.equals(info.user)
2953                         &amp;&amp; info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2954                     ShortcutInfo si = (ShortcutInfo) info;
2955                     ComponentName cn = si.getTargetComponent();
2956                     if (cn != null &amp;&amp; updatedPackages.contains(cn.getPackageName())) {
2957                         si.updateIcon(mIconCache);
2958                         updatedShortcuts.add(si);
2959                     }
2960                 }
2961             }
2962             mBgAllAppsList.updateIconsAndLabels(updatedPackages, user, updatedApps);
2963         }
2964 
2965         if (!updatedShortcuts.isEmpty()) {
2966             final UserHandleCompat userFinal = user;
2967             mHandler.post(new Runnable() {
2968 
2969                 public void run() {
2970                     Callbacks cb = getCallback();
2971                     if (cb != null &amp;&amp; callbacks == cb) {
2972                         cb.bindShortcutsChanged(updatedShortcuts,
2973                                 new ArrayList&lt;ShortcutInfo&gt;(), userFinal);
2974                     }
2975                 }
2976             });
2977         }
2978 
2979         if (!updatedApps.isEmpty()) {
2980             mHandler.post(new Runnable() {
2981 
2982                 public void run() {
2983                     Callbacks cb = getCallback();
2984                     if (cb != null &amp;&amp; callbacks == cb) {
2985                         cb.bindAppsUpdated(updatedApps);
2986                     }
2987                 }
2988             });
2989         }
2990 
2991         // Reload widget list. No need to refresh, as we only want to update the icons and labels.
2992         loadAndBindWidgetsAndShortcuts(mApp.getContext(), callbacks, false);
2993     }
2994 
2995     void enqueuePackageUpdated(PackageUpdatedTask task) {
2996         sWorker.post(task);
2997     }
2998 
2999     @Thunk class AppsAvailabilityCheck extends BroadcastReceiver {
3000 
3001         @Override
3002         public void onReceive(Context context, Intent intent) {
3003             synchronized (sBgLock) {
3004                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
3005                         .getInstance(mApp.getContext());
3006                 final PackageManager manager = context.getPackageManager();
3007                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
3008                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
3009                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
3010                     UserHandleCompat user = entry.getKey();
3011                     packagesRemoved.clear();
3012                     packagesUnavailable.clear();
3013                     for (String pkg : entry.getValue()) {
3014                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
3015                             boolean packageOnSdcard = launcherApps.isAppEnabled(
3016                                     manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
3017                             if (packageOnSdcard) {
3018                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
3019                                 packagesUnavailable.add(pkg);
3020                             } else {
3021                                 Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
3022                                 packagesRemoved.add(pkg);
3023                             }
3024                         }
3025                     }
3026                     if (!packagesRemoved.isEmpty()) {
3027                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
3028                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
3029                     }
3030                     if (!packagesUnavailable.isEmpty()) {
3031                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
<abbr title="3032                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">3032                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user🔵</abbr>
3033                     }
3034                 }
3035                 sPendingPackages.clear();
3036             }
3037         }
3038     }
3039 
3040     private class PackageUpdatedTask implements Runnable {
3041         int mOp;
3042         String[] mPackages;
3043         UserHandleCompat mUser;
3044 
3045         public static final int OP_NONE = 0;
3046         public static final int OP_ADD = 1;
3047         public static final int OP_UPDATE = 2;
3048         public static final int OP_REMOVE = 3; // uninstlled
3049         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3050 
3051 
3052         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3053             mOp = op;
3054             mPackages = packages;
3055             mUser = user;
3056         }
3057 
3058         public void run() {
3059             if (!mHasLoaderCompletedOnce) {
3060                 // Loader has not yet run.
3061                 return;
3062             }
3063             final Context context = mApp.getContext();
3064 
3065             final String[] packages = mPackages;
3066             final int N = packages.length;
3067             switch (mOp) {
3068                 case OP_ADD: {
3069                     for (int i=0; i&lt;N; i++) {
3070                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3071                         mIconCache.updateIconsForPkg(packages[i], mUser);
3072                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3073                     }
3074 
3075                     ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
3076                     if (heuristic != null) {
3077                         heuristic.processPackageAdd(mPackages);
3078                     }
3079                     break;
3080                 }
3081                 case OP_UPDATE:
3082                     for (int i=0; i&lt;N; i++) {
3083                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3084                         mIconCache.updateIconsForPkg(packages[i], mUser);
3085                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3086                         mApp.getWidgetCache().removePackage(packages[i], mUser);
3087                     }
3088                     break;
3089                 case OP_REMOVE: {
3090                     ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
3091                     if (heuristic != null) {
3092                         heuristic.processPackageRemoved(mPackages);
3093                     }
3094                     for (int i=0; i&lt;N; i++) {
3095                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3096                         mIconCache.removeIconsForPkg(packages[i], mUser);
3097                     }
3098                     // Fall through
3099                 }
3100                 case OP_UNAVAILABLE:
3101                     for (int i=0; i&lt;N; i++) {
3102                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3103                         mBgAllAppsList.removePackage(packages[i], mUser);
3104                         mApp.getWidgetCache().removePackage(packages[i], mUser);
3105                     }
3106                     break;
3107             }
3108 
3109             ArrayList&lt;AppInfo&gt; added = null;
3110             ArrayList&lt;AppInfo&gt; modified = null;
3111             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3112 
3113             if (mBgAllAppsList.added.size() &gt; 0) {
3114                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3115                 mBgAllAppsList.added.clear();
3116             }
3117             if (mBgAllAppsList.modified.size() &gt; 0) {
3118                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3119                 mBgAllAppsList.modified.clear();
3120             }
3121             if (mBgAllAppsList.removed.size() &gt; 0) {
3122                 removedApps.addAll(mBgAllAppsList.removed);
3123                 mBgAllAppsList.removed.clear();
3124             }
3125 
3126             final Callbacks callbacks = getCallback();
3127             if (callbacks == null) {
3128                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3129                 return;
3130             }
3131 
3132             final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps =
3133                     new HashMap&lt;ComponentName, AppInfo&gt;();
3134 
3135             if (added != null) {
3136                 addAppsToAllApps(context, added);
3137                 for (AppInfo ai : added) {
3138                     addedOrUpdatedApps.put(ai.componentName, ai);
3139                 }
3140             }
3141 
3142             if (modified != null) {
3143                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3144                 for (AppInfo ai : modified) {
3145                     addedOrUpdatedApps.put(ai.componentName, ai);
3146                 }
3147 
3148                 mHandler.post(new Runnable() {
3149                     public void run() {
3150                         Callbacks cb = getCallback();
3151                         if (callbacks == cb &amp;&amp; cb != null) {
3152                             callbacks.bindAppsUpdated(modifiedFinal);
3153                         }
3154                     }
3155                 });
3156             }
3157 
3158             // Update shortcut infos
3159             if (mOp == OP_ADD || mOp == OP_UPDATE) {
3160                 final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3161                 final ArrayList&lt;ShortcutInfo&gt; removedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3162                 final ArrayList&lt;LauncherAppWidgetInfo&gt; widgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
3163 
3164                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3165                 synchronized (sBgLock) {
3166                     for (ItemInfo info : sBgItemsIdMap) {
3167                         if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3168                             ShortcutInfo si = (ShortcutInfo) info;
3169                             boolean infoUpdated = false;
3170                             boolean shortcutUpdated = false;
3171 
3172                             // Update shortcuts which use iconResource.
3173                             if ((si.iconResource != null)
3174                                     &amp;&amp; packageSet.contains(si.iconResource.packageName)) {
3175                                 Bitmap icon = Utilities.createIconBitmap(
3176                                         si.iconResource.packageName,
3177                                         si.iconResource.resourceName, context);
3178                                 if (icon != null) {
3179                                     si.setIcon(icon);
3180                                     si.usingFallbackIcon = false;
3181                                     infoUpdated = true;
3182                                 }
3183                             }
3184 
3185                             ComponentName cn = si.getTargetComponent();
3186                             if (cn != null &amp;&amp; packageSet.contains(cn.getPackageName())) {
3187                                 AppInfo appInfo = addedOrUpdatedApps.get(cn);
3188 
3189                                 if (si.isPromise()) {
3190                                     if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
3191                                         // Auto install icon
3192                                         PackageManager pm = context.getPackageManager();
3193                                         ResolveInfo matched = pm.resolveActivity(
3194                                                 new Intent(Intent.ACTION_MAIN)
3195                                                 .setComponent(cn).addCategory(Intent.CATEGORY_LAUNCHER),
3196                                                 PackageManager.MATCH_DEFAULT_ONLY);
3197                                         if (matched == null) {
3198                                             // Try to find the best match activity.
3199                                             Intent intent = pm.getLaunchIntentForPackage(
3200                                                     cn.getPackageName());
3201                                             if (intent != null) {
3202                                                 cn = intent.getComponent();
3203                                                 appInfo = addedOrUpdatedApps.get(cn);
3204                                             }
3205 
3206                                             if ((intent == null) || (appInfo == null)) {
3207                                                 removedShortcuts.add(si);
3208                                                 continue;
3209                                             }
3210                                             si.promisedIntent = intent;
3211                                         }
3212                                     }
3213 
3214                                     // Restore the shortcut.
3215                                     if (appInfo != null) {
3216                                         si.flags = appInfo.flags;
3217                                     }
3218 
3219                                     si.intent = si.promisedIntent;
3220                                     si.promisedIntent = null;
3221                                     si.status = ShortcutInfo.DEFAULT;
3222                                     infoUpdated = true;
3223                                     si.updateIcon(mIconCache);
3224                                 }
3225 
3226                                 if (appInfo != null &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction())
<abbr title="3227                                         &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">3227                                         &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATIO🔵</abbr>
3228                                     si.updateIcon(mIconCache);
3229                                     si.title = Utilities.trim(appInfo.title);
3230                                     si.contentDescription = appInfo.contentDescription;
3231                                     infoUpdated = true;
3232                                 }
3233 
3234                                 if ((si.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE) != 0) {
3235                                     // Since package was just updated, the target must be available now.
3236                                     si.isDisabled &amp;= ~ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3237                                     shortcutUpdated = true;
3238                                 }
3239                             }
3240 
3241                             if (infoUpdated || shortcutUpdated) {
3242                                 updatedShortcuts.add(si);
3243                             }
3244                             if (infoUpdated) {
3245                                 updateItemInDatabase(context, si);
3246                             }
3247                         } else if (info instanceof LauncherAppWidgetInfo) {
3248                             LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) info;
3249                             if (mUser.equals(widgetInfo.user)
<abbr title="3250                                     &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)">3250                                     &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_🔵</abbr>
3251                                     &amp;&amp; packageSet.contains(widgetInfo.providerName.getPackageName())) {
<abbr title="3252                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">3252                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READ🔵</abbr>
3253                                 widgets.add(widgetInfo);
3254                                 updateItemInDatabase(context, widgetInfo);
3255                             }
3256                         }
3257                     }
3258                 }
3259 
3260                 if (!updatedShortcuts.isEmpty() || !removedShortcuts.isEmpty()) {
3261                     mHandler.post(new Runnable() {
3262 
3263                         public void run() {
3264                             Callbacks cb = getCallback();
3265                             if (callbacks == cb &amp;&amp; cb != null) {
3266                                 callbacks.bindShortcutsChanged(
3267                                         updatedShortcuts, removedShortcuts, mUser);
3268                             }
3269                         }
3270                     });
3271                     if (!removedShortcuts.isEmpty()) {
3272                         deleteItemsFromDatabase(context, removedShortcuts);
3273                     }
3274                 }
3275                 if (!widgets.isEmpty()) {
3276                     mHandler.post(new Runnable() {
3277                         public void run() {
3278                             Callbacks cb = getCallback();
3279                             if (callbacks == cb &amp;&amp; cb != null) {
3280                                 callbacks.bindWidgetsRestored(widgets);
3281                             }
3282                         }
3283                     });
3284                 }
3285             }
3286 
3287             final ArrayList&lt;String&gt; removedPackageNames =
3288                     new ArrayList&lt;String&gt;();
3289             if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3290                 // Mark all packages in the broadcast to be removed
3291                 removedPackageNames.addAll(Arrays.asList(packages));
3292             } else if (mOp == OP_UPDATE) {
3293                 // Mark disabled packages in the broadcast to be removed
3294                 for (int i=0; i&lt;N; i++) {
3295                     if (isPackageDisabled(context, packages[i], mUser)) {
3296                         removedPackageNames.add(packages[i]);
3297                     }
3298                 }
3299             }
3300 
3301             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3302                 final int removeReason;
3303                 if (mOp == OP_UNAVAILABLE) {
3304                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3305                 } else {
3306                     // Remove all the components associated with this package
3307                     for (String pn : removedPackageNames) {
3308                         deletePackageFromDatabase(context, pn, mUser);
3309                     }
3310                     // Remove all the specific components
3311                     for (AppInfo a : removedApps) {
3312                         ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3313                         deleteItemsFromDatabase(context, infos);
3314                     }
3315                     removeReason = 0;
3316                 }
3317 
3318                 // Remove any queued items from the install queue
3319                 InstallShortcutReceiver.removeFromInstallQueue(context, removedPackageNames, mUser);
3320                 // Call the components-removed callback
3321                 mHandler.post(new Runnable() {
3322                     public void run() {
3323                         Callbacks cb = getCallback();
3324                         if (callbacks == cb &amp;&amp; cb != null) {
3325                             callbacks.bindComponentsRemoved(
3326                                     removedPackageNames, removedApps, mUser, removeReason);
3327                         }
3328                     }
3329                 });
3330             }
3331 
3332             // onProvidersChanged method (API &gt;= 17) already refreshed the widget list
3333             loadAndBindWidgetsAndShortcuts(context, callbacks, Build.VERSION.SDK_INT &lt; 17);
3334 
3335             // Write all the logs to disk
3336             mHandler.post(new Runnable() {
3337                 public void run() {
3338                     Callbacks cb = getCallback();
3339                     if (callbacks == cb &amp;&amp; cb != null) {
3340                         callbacks.dumpLogsToLocalData();
3341                     }
3342                 }
3343             });
3344         }
3345     }
3346 
3347     public static List&lt;LauncherAppWidgetProviderInfo&gt; getWidgetProviders(Context context,
3348             boolean refresh) {
3349         ArrayList&lt;LauncherAppWidgetProviderInfo&gt; results =
3350                 new ArrayList&lt;LauncherAppWidgetProviderInfo&gt;();
3351         try {
3352             synchronized (sBgLock) {
3353                 if (sBgWidgetProviders == null || refresh) {
3354                     HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; tmpWidgetProviders
3355                             = new HashMap&lt;&gt;();
3356                     AppWidgetManagerCompat wm = AppWidgetManagerCompat.getInstance(context);
3357                     LauncherAppWidgetProviderInfo info;
3358 
3359                     List&lt;AppWidgetProviderInfo&gt; widgets = wm.getAllProviders();
3360                     for (AppWidgetProviderInfo pInfo : widgets) {
3361                         info = LauncherAppWidgetProviderInfo.fromProviderInfo(context, pInfo);
3362                         UserHandleCompat user = wm.getUser(info);
3363                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3364                     }
3365 
3366                     Collection&lt;CustomAppWidget&gt; customWidgets = Launcher.getCustomAppWidgets().values();
3367                     for (CustomAppWidget widget : customWidgets) {
3368                         info = new LauncherAppWidgetProviderInfo(context, widget);
3369                         UserHandleCompat user = wm.getUser(info);
3370                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3371                     }
3372                     // Replace the global list at the very end, so that if there is an exception,
3373                     // previously loaded provider list is used.
3374                     sBgWidgetProviders = tmpWidgetProviders;
3375                 }
3376                 results.addAll(sBgWidgetProviders.values());
3377                 return results;
3378             }
3379         } catch (Exception e) {
3380             if (e.getCause() instanceof TransactionTooLargeException) {
3381                 // the returned value may be incomplete and will not be refreshed until the next
3382                 // time Launcher starts.
3383                 // TODO: after figuring out a repro step, introduce a dirty bit to check when
3384                 // onResume is called to refresh the widget provider list.
3385                 synchronized (sBgLock) {
3386                     if (sBgWidgetProviders != null) {
3387                         results.addAll(sBgWidgetProviders.values());
3388                     }
3389                     return results;
3390                 }
3391             } else {
3392                 throw e;
3393             }
3394         }
3395     }
3396 
3397     public static LauncherAppWidgetProviderInfo getProviderInfo(Context ctx, ComponentName name,
3398             UserHandleCompat user) {
3399         synchronized (sBgLock) {
3400             if (sBgWidgetProviders == null) {
3401                 getWidgetProviders(ctx, false /* refresh */);
3402             }
3403             return sBgWidgetProviders.get(new ComponentKey(name, user));
3404         }
3405     }
3406 
3407     public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks,
3408             final boolean refresh) {
3409 
3410         runOnWorkerThread(new Runnable() {
3411             @Override
3412             public void run() {
3413                 updateWidgetsModel(context, refresh);
3414                 final WidgetsModel model = mBgWidgetsModel.clone();
3415 
3416                 mHandler.post(new Runnable() {
3417                     @Override
3418                     public void run() {
3419                         Callbacks cb = getCallback();
3420                         if (callbacks == cb &amp;&amp; cb != null) {
3421                             callbacks.bindAllPackages(model);
3422                         }
3423                     }
3424                 });
3425                 // update the Widget entries inside DB on the worker thread.
3426                 LauncherAppState.getInstance().getWidgetCache().removeObsoletePreviews(
3427                         model.getRawList());
3428             }
3429         });
3430     }
3431 
3432     /**
3433      * Returns a list of ResolveInfos/AppWidgetInfos.
3434      *
3435      * @see #loadAndBindWidgetsAndShortcuts
3436      */
3437     @Thunk void updateWidgetsModel(Context context, boolean refresh) {
3438         PackageManager packageManager = context.getPackageManager();
3439         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3440         widgetsAndShortcuts.addAll(getWidgetProviders(context, refresh));
3441         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3442         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3443         mBgWidgetsModel.setWidgetsAndShortcuts(widgetsAndShortcuts);
3444     }
3445 
3446     @Thunk static boolean isPackageDisabled(Context context, String packageName,
3447             UserHandleCompat user) {
3448         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3449         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3450     }
3451 
3452     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3453             UserHandleCompat user) {
3454         if (cn == null) {
3455             return false;
3456         }
3457         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3458         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3459             return false;
3460         }
3461         return launcherApps.isActivityEnabledForProfile(cn, user);
3462     }
3463 
3464     public static boolean isValidPackage(Context context, String packageName,
3465             UserHandleCompat user) {
3466         if (packageName == null) {
3467             return false;
3468         }
3469         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3470         return launcherApps.isPackageEnabledForProfile(packageName, user);
3471     }
3472 
3473     /**
3474      * Make an ShortcutInfo object for a restored application or shortcut item that points
3475      * to a package that is not yet installed on the system.
3476      */
3477     public ShortcutInfo getRestoredItemInfo(Cursor c, int titleIndex, Intent intent,
3478             int promiseType, int itemType, CursorIconInfo iconInfo, Context context) {
3479         final ShortcutInfo info = new ShortcutInfo();
3480         info.user = UserHandleCompat.myUserHandle();
3481 
3482         Bitmap icon = iconInfo.loadIcon(c, info, context);
3483         // the fallback icon
3484         if (icon == null) {
3485             mIconCache.getTitleAndIcon(info, intent, info.user, false /* useLowResIcon */);
3486         } else {
3487             info.setIcon(icon);
3488         }
3489 
3490         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3491             String title = (c != null) ? c.getString(titleIndex) : null;
3492             if (!TextUtils.isEmpty(title)) {
3493                 info.title = Utilities.trim(title);
3494             }
3495         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3496             if (TextUtils.isEmpty(info.title)) {
3497                 info.title = (c != null) ? Utilities.trim(c.getString(titleIndex)) : &quot;&quot;;
3498             }
3499         } else {
3500             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3501         }
3502 
3503         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3504         info.itemType = itemType;
3505         info.promisedIntent = intent;
3506         info.status = promiseType;
3507         return info;
3508     }
3509 
3510     /**
3511      * Make an Intent object for a restored application or shortcut item that points
3512      * to the market page for the item.
3513      */
3514     @Thunk Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3515         ComponentName componentName = intent.getComponent();
3516         return getMarketIntent(componentName.getPackageName());
3517     }
3518 
3519     static Intent getMarketIntent(String packageName) {
3520         return new Intent(Intent.ACTION_VIEW)
3521             .setData(new Uri.Builder()
3522                 .scheme(&quot;market&quot;)
3523                 .authority(&quot;details&quot;)
3524                 .appendQueryParameter(&quot;id&quot;, packageName)
3525                 .build());
3526     }
3527 
3528     /**
3529      * Make an ShortcutInfo object for a shortcut that is an application.
3530      *
3531      * If c is not null, then it will be used to fill in missing data like the title and icon.
3532      */
3533     public ShortcutInfo getAppShortcutInfo(PackageManager manager, Intent intent,
3534             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3535             boolean allowMissingTarget, boolean useLowResIcon) {
3536         if (user == null) {
3537             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3538             return null;
3539         }
3540 
3541         ComponentName componentName = intent.getComponent();
3542         if (componentName == null) {
3543             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3544             return null;
3545         }
3546 
3547         Intent newIntent = new Intent(intent.getAction(), null);
3548         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3549         newIntent.setComponent(componentName);
3550         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3551         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3552             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3553             return null;
3554         }
3555 
3556         final ShortcutInfo info = new ShortcutInfo();
3557         mIconCache.getTitleAndIcon(info, componentName, lai, user, false, useLowResIcon);
3558         if (mIconCache.isDefaultIcon(info.getIcon(mIconCache), user) &amp;&amp; c != null) {
3559             Bitmap icon = Utilities.createIconBitmap(c, iconIndex, context);
3560             info.setIcon(icon == null ? mIconCache.getDefaultIcon(user) : icon);
3561         }
3562 
3563         // from the db
3564         if (TextUtils.isEmpty(info.title) &amp;&amp; c != null) {
3565             info.title =  Utilities.trim(c.getString(titleIndex));
3566         }
3567 
3568         // fall back to the class name of the activity
3569         if (info.title == null) {
3570             info.title = componentName.getClassName();
3571         }
3572 
3573         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3574         info.user = user;
3575         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3576         if (lai != null) {
3577             info.flags = AppInfo.initFlags(lai);
3578         }
3579         return info;
3580     }
3581 
3582     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Iterable&lt;ItemInfo&gt; infos,
3583             ItemInfoFilter f) {
3584         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3585         for (ItemInfo i : infos) {
3586             if (i instanceof ShortcutInfo) {
3587                 ShortcutInfo info = (ShortcutInfo) i;
3588                 ComponentName cn = info.getTargetComponent();
3589                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3590                     filtered.add(info);
3591                 }
3592             } else if (i instanceof FolderInfo) {
3593                 FolderInfo info = (FolderInfo) i;
3594                 for (ShortcutInfo s : info.contents) {
3595                     ComponentName cn = s.getTargetComponent();
3596                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3597                         filtered.add(s);
3598                     }
3599                 }
3600             } else if (i instanceof LauncherAppWidgetInfo) {
3601                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3602                 ComponentName cn = info.providerName;
3603                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3604                     filtered.add(info);
3605                 }
3606             }
3607         }
3608         return new ArrayList&lt;ItemInfo&gt;(filtered);
3609     }
3610 
3611     @Thunk ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3612             final UserHandleCompat user) {
3613         ItemInfoFilter filter  = new ItemInfoFilter() {
3614             @Override
3615             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3616                 if (info.user == null) {
3617                     return cn.equals(cname);
3618                 } else {
3619                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3620                 }
3621             }
3622         };
3623         return filterItemInfos(sBgItemsIdMap, filter);
3624     }
3625 
3626     /**
3627      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3628      */
3629     @Thunk ShortcutInfo getShortcutInfo(Cursor c, Context context,
3630             int titleIndex, CursorIconInfo iconInfo) {
3631         final ShortcutInfo info = new ShortcutInfo();
3632         // Non-app shortcuts are only supported for current user.
3633         info.user = UserHandleCompat.myUserHandle();
3634         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3635 
3636         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3637 
3638         info.title = Utilities.trim(c.getString(titleIndex));
3639 
3640         Bitmap icon = iconInfo.loadIcon(c, info, context);
3641         // the fallback icon
3642         if (icon == null) {
3643             icon = mIconCache.getDefaultIcon(info.user);
3644             info.usingFallbackIcon = true;
3645         }
3646         info.setIcon(icon);
3647         return info;
3648     }
3649 
3650     ShortcutInfo infoFromShortcutIntent(Context context, Intent data) {
3651         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3652         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3653         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3654 
3655         if (intent == null) {
3656             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3657             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3658             return null;
3659         }
3660 
3661         Bitmap icon = null;
3662         boolean customIcon = false;
3663         ShortcutIconResource iconResource = null;
3664 
3665         if (bitmap instanceof Bitmap) {
3666             icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
3667             customIcon = true;
3668         } else {
3669             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3670             if (extra instanceof ShortcutIconResource) {
3671                 iconResource = (ShortcutIconResource) extra;
3672                 icon = Utilities.createIconBitmap(iconResource.packageName,
3673                         iconResource.resourceName, context);
3674             }
3675         }
3676 
3677         final ShortcutInfo info = new ShortcutInfo();
3678 
3679         // Only support intents for current user for now. Intents sent from other
3680         // users wouldn&#x27;t get here without intent forwarding anyway.
3681         info.user = UserHandleCompat.myUserHandle();
3682         if (icon == null) {
3683             icon = mIconCache.getDefaultIcon(info.user);
3684             info.usingFallbackIcon = true;
3685         }
3686         info.setIcon(icon);
3687 
3688         info.title = Utilities.trim(name);
3689         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3690         info.intent = intent;
3691         info.customIcon = customIcon;
3692         info.iconResource = iconResource;
3693 
3694         return info;
3695     }
3696 
3697     /**
3698      * Return an existing FolderInfo object if we have encountered this ID previously,
3699      * or make a new one.
3700      */
3701     @Thunk static FolderInfo findOrMakeFolder(LongArrayMap&lt;FolderInfo&gt; folders, long id) {
3702         // See if a placeholder was created for us already
3703         FolderInfo folderInfo = folders.get(id);
3704         if (folderInfo == null) {
3705             // No placeholder -- create a new instance
3706             folderInfo = new FolderInfo();
3707             folders.put(id, folderInfo);
3708         }
3709         return folderInfo;
3710     }
3711 
3712 
3713     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3714         return (provider != null) &amp;&amp; (provider.provider != null)
3715                 &amp;&amp; (provider.provider.getPackageName() != null);
3716     }
3717 
3718     public void dumpState() {
3719         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3720         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3721         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3722         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3723         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3724         if (mLoaderTask != null) {
3725             mLoaderTask.dumpState();
3726         } else {
3727             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3728         }
3729     }
3730 
3731     public Callbacks getCallback() {
3732         return mCallbacks != null ? mCallbacks.get() : null;
3733     }
3734 
3735     /**
3736      * @return {@link FolderInfo} if its already loaded.
3737      */
3738     public FolderInfo findFolderById(Long folderId) {
3739         synchronized (sBgLock) {
3740             return sBgFolders.get(folderId);
3741         }
3742     }
3743 
3744     /**
3745      * @return the looper for the worker thread which can be used to start background tasks.
3746      */
3747     public static Looper getWorkerLooper() {
3748         return sWorkerThread.getLooper();
3749     }
3750 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderOperation;
  24 import android.content.ContentResolver;
  25 import android.content.ContentValues;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.Intent.ShortcutIconResource;
  29 import android.content.IntentFilter;
  30 import android.content.pm.PackageManager;
  31 import android.content.pm.ProviderInfo;
  32 import android.content.pm.ResolveInfo;
  33 import android.database.Cursor;
  34 import android.graphics.Bitmap;
  35 import android.net.Uri;
  36 import android.os.Build;
  37 import android.os.Environment;
  38 import android.os.Handler;
  39 import android.os.HandlerThread;
  40 import android.os.Looper;
  41 import android.os.Parcelable;
  42 import android.os.Process;
  43 import android.os.SystemClock;
  44 import android.os.TransactionTooLargeException;
  45 import android.provider.BaseColumns;
  46 import android.text.TextUtils;
  47 import android.util.Log;
  48 import android.util.LongSparseArray;
  49 import android.util.Pair;
  50 
  51 import com.android.launcher3.compat.AppWidgetManagerCompat;
  52 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  53 import com.android.launcher3.compat.LauncherAppsCompat;
  54 import com.android.launcher3.compat.PackageInstallerCompat;
  55 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  56 import com.android.launcher3.compat.UserHandleCompat;
  57 import com.android.launcher3.compat.UserManagerCompat;
  58 import com.android.launcher3.model.WidgetsModel;
  59 import com.android.launcher3.util.ComponentKey;
  60 import com.android.launcher3.util.CursorIconInfo;
  61 import com.android.launcher3.util.LongArrayMap;
  62 import com.android.launcher3.util.ManagedProfileHeuristic;
  63 import com.android.launcher3.util.Thunk;
  64 
  65 import java.lang.ref.WeakReference;
  66 import java.net.URISyntaxException;
  67 import java.security.InvalidParameterException;
  68 import java.util.ArrayList;
  69 import java.util.Arrays;
  70 import java.util.Collection;
  71 import java.util.Collections;
  72 import java.util.Comparator;
  73 import java.util.HashMap;
  74 import java.util.HashSet;
  75 import java.util.Iterator;
  76 import java.util.List;
  77 import java.util.Map.Entry;
  78 import java.util.Set;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     public static final int LOADER_FLAG_NONE = 0;
  94     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  95     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  96 
  97     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
  98     private static final long INVALID_SCREEN_ID = -1L;
  99 
 100     @Thunk final boolean mAppsCanBeOnRemoveableStorage;
 101     private final boolean mOldContentProviderExists;
 102 
 103     @Thunk final LauncherAppState mApp;
 104     @Thunk final Object mLock = new Object();
 105     @Thunk DeferredHandler mHandler = new DeferredHandler();
 106     @Thunk LoaderTask mLoaderTask;
 107     @Thunk boolean mIsLoaderTaskRunning;
 108     @Thunk boolean mHasLoaderCompletedOnce;
 109 
 110     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 111 
 112     @Thunk static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 113     static {
 114         sWorkerThread.start();
 115     }
 116     @Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 117 
 118     // We start off with everything not loaded.  After that, we assume that
 119     // our monitoring of the package manager provides all updates and we never
 120     // need to do a requery.  These are only ever touched from the loader thread.
 121     @Thunk boolean mWorkspaceLoaded;
 122     @Thunk boolean mAllAppsLoaded;
 123 
 124     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 125     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 126     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 127     // a normal load, we also clear this set of Runnables.
 128     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 129 
 130     /**
 131      * Set of runnables to be called on the background thread after the workspace binding
 132      * is complete.
 133      */
 134     static final ArrayList&lt;Runnable&gt; mBindCompleteRunnables = new ArrayList&lt;Runnable&gt;();
 135 
 136     @Thunk WeakReference&lt;Callbacks&gt; mCallbacks;
 137 
 138     // &lt; only access in worker thread &gt;
 139     AllAppsList mBgAllAppsList;
 140     // Entire list of widgets.
 141     WidgetsModel mBgWidgetsModel;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final LongArrayMap&lt;ItemInfo&gt; sBgItemsIdMap = new LongArrayMap&lt;&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final LongArrayMap&lt;FolderInfo&gt; sBgFolders = new LongArrayMap&lt;&gt;();
 164 
 165     // sBgWorkspaceScreens is the ordered set of workspace screens.
 166     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 167 
 168     // sBgWidgetProviders is the set of widget providers including custom internal widgets
 169     public static HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; sBgWidgetProviders;
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     @Thunk IconCache mIconCache;
 178 
 179     @Thunk final LauncherAppsCompat mLauncherApps;
 180     @Thunk final UserManagerCompat mUserManager;
 181 
 182     public interface Callbacks {
 183         public boolean setLoadOnResume();
 184         public int getCurrentWorkspaceScreen();
 185         public void startBinding();
 186         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 187                               boolean forceAnimateIcons);
 188         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 189         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 190         public void bindFolders(LongArrayMap&lt;FolderInfo&gt; folders);
 191         public void finishBindingItems();
 192         public void bindAppWidget(LauncherAppWidgetInfo info);
 193         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 194         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 195                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 196                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 197                                   ArrayList&lt;AppInfo&gt; addedApps);
 198         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 199         public void bindShortcutsChanged(ArrayList&lt;ShortcutInfo&gt; updated,
 200                 ArrayList&lt;ShortcutInfo&gt; removed, UserHandleCompat user);
 201         public void bindWidgetsRestored(ArrayList&lt;LauncherAppWidgetInfo&gt; widgets);
 202         public void bindRestoreItemsChange(HashSet&lt;ItemInfo&gt; updates);
 203         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 204                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 205         public void bindAllPackages(WidgetsModel model);
 206         public void bindSearchablesChanged();
 207         public boolean isAllAppsButtonRank(int rank);
 208         public void onPageBoundSynchronously(int page);
 209         public void dumpLogsToLocalData();
 210     }
 211 
 212     public interface ItemInfoFilter {
 213         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 214     }
 215 
 216     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 217         Context context = app.getContext();
 218 
 219         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 220         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 221         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 222         // resource string.
 223         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 224         ProviderInfo providerInfo =
 225                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 226         ProviderInfo redirectProvider =
 227                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 228 
 229         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 230         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 231 
 232         if (mOldContentProviderExists) {
 233             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 234         } else {
 235             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 236         }
 237 
 238         mApp = app;
 239         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 240         mBgWidgetsModel = new WidgetsModel(context, iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         mLauncherApps = LauncherAppsCompat.getInstance(context);
 244         mUserManager = UserManagerCompat.getInstance(context);
 245     }
 246 
 247     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 248      * posted on the main thread handler. */
 249     @Thunk void runOnMainThread(Runnable r) {
 250         if (sWorkerThread.getThreadId() == Process.myTid()) {
 251             // If we are on the worker thread, post onto the main handler
 252             mHandler.post(r);
 253         } else {
 254             r.run();
 255         }
 256     }
 257 
 258     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 259      * posted on the worker thread handler. */
 260     private static void runOnWorkerThread(Runnable r) {
 261         if (sWorkerThread.getThreadId() == Process.myTid()) {
 262             r.run();
 263         } else {
 264             // If we are not on the worker thread, then post to the worker handler
 265             sWorker.post(r);
 266         }
 267     }
 268 
 269     /**
 270      * Runs the specified runnable after the loader is complete
 271      */
 272     @Thunk void runAfterBindCompletes(Runnable r) {
 273         if (isLoadingWorkspace() || !mHasLoaderCompletedOnce) {
 274             synchronized (mBindCompleteRunnables) {
 275                 mBindCompleteRunnables.add(r);
 276             }
 277         } else {
 278             runOnWorkerThread(r);
 279         }
 280     }
 281 
 282     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 283         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 284     }
 285 
 286     public void setPackageState(final PackageInstallInfo installInfo) {
 287         Runnable updateRunnable = new Runnable() {
 288 
 289             @Override
 290             public void run() {
 291                 synchronized (sBgLock) {
 292                     final HashSet&lt;ItemInfo&gt; updates = new HashSet&lt;&gt;();
 293 
 294                     if (installInfo.state == PackageInstallerCompat.STATUS_INSTALLED) {
 295                         // Ignore install success events as they are handled by Package add events.
 296                         return;
 297                     }
 298 
 299                     for (ItemInfo info : sBgItemsIdMap) {
 300                         if (info instanceof ShortcutInfo) {
 301                             ShortcutInfo si = (ShortcutInfo) info;
 302                             ComponentName cn = si.getTargetComponent();
 303                             if (si.isPromise() &amp;&amp; (cn != null)
 304                                     &amp;&amp; installInfo.packageName.equals(cn.getPackageName())) {
 305                                 si.setInstallProgress(installInfo.progress);
 306 
 307                                 if (installInfo.state == PackageInstallerCompat.STATUS_FAILED) {
 308                                     // Mark this info as broken.
 309                                     si.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
 310                                 }
 311                                 updates.add(si);
 312                             }
 313                         }
 314                     }
 315 
 316                     for (LauncherAppWidgetInfo widget : sBgAppWidgets) {
 317                         if (widget.providerName.getPackageName().equals(installInfo.packageName)) {
 318                             widget.installProgress = installInfo.progress;
 319                             updates.add(widget);
 320                         }
 321                     }
 322 
 323                     if (!updates.isEmpty()) {
 324                         // Push changes to the callback.
 325                         Runnable r = new Runnable() {
 326                             public void run() {
 327                                 Callbacks callbacks = getCallback();
 328                                 if (callbacks != null) {
 329                                     callbacks.bindRestoreItemsChange(updates);
 330                                 }
 331                             }
 332                         };
 333                         mHandler.post(r);
 334                     }
 335                 }
 336             }
 337         };
 338         runOnWorkerThread(updateRunnable);
 339     }
 340 
 341     /**
 342      * Updates the icons and label of all pending icons for the provided package name.
 343      */
 344     public void updateSessionDisplayInfo(final String packageName) {
 345         Runnable updateRunnable = new Runnable() {
 346 
 347             @Override
 348             public void run() {
 349                 synchronized (sBgLock) {
 350                     final ArrayList&lt;ShortcutInfo&gt; updates = new ArrayList&lt;&gt;();
 351                     final UserHandleCompat user = UserHandleCompat.myUserHandle();
 352 
 353                     for (ItemInfo info : sBgItemsIdMap) {
 354                         if (info instanceof ShortcutInfo) {
 355                             ShortcutInfo si = (ShortcutInfo) info;
 356                             ComponentName cn = si.getTargetComponent();
 357                             if (si.isPromise() &amp;&amp; (cn != null)
 358                                     &amp;&amp; packageName.equals(cn.getPackageName())) {
 359                                 if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
 360                                     // For auto install apps update the icon as well as label.
 361                                     mIconCache.getTitleAndIcon(si,
 362                                             si.promisedIntent, user,
 363                                             si.shouldUseLowResIcon());
 364                                 } else {
 365                                     // Only update the icon for restored apps.
 366                                     si.updateIcon(mIconCache);
 367                                 }
 368                                 updates.add(si);
 369                             }
 370                         }
 371                     }
 372 
 373                     if (!updates.isEmpty()) {
 374                         // Push changes to the callback.
 375                         Runnable r = new Runnable() {
 376                             public void run() {
 377                                 Callbacks callbacks = getCallback();
 378                                 if (callbacks != null) {
 379                                     callbacks.bindShortcutsChanged(updates,
 380                                             new ArrayList&lt;ShortcutInfo&gt;(), user);
 381                                 }
 382                             }
 383                         };
 384                         mHandler.post(r);
 385                     }
 386                 }
 387             }
 388         };
 389         runOnWorkerThread(updateRunnable);
 390     }
 391 
 392     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 393         final Callbacks callbacks = getCallback();
 394 
 395         if (allAppsApps == null) {
 396             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 397         }
 398         if (allAppsApps.isEmpty()) {
 399             return;
 400         }
 401 
 402         // Process the newly added applications and add them to the database first
 403         Runnable r = new Runnable() {
 404             public void run() {
 405                 runOnMainThread(new Runnable() {
 406                     public void run() {
 407                         Callbacks cb = getCallback();
 408                         if (callbacks == cb &amp;&amp; cb != null) {
 409                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 410                         }
 411                     }
 412                 });
 413             }
 414         };
 415         runOnWorkerThread(r);
 416     }
 417 
 418     private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; occupiedPos,
 419             int[] xy, int spanX, int spanY) {
 420         LauncherAppState app = LauncherAppState.getInstance();
 421         InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
 422         final int xCount = (int) profile.numColumns;
 423         final int yCount = (int) profile.numRows;
 424         boolean[][] occupied = new boolean[xCount][yCount];
 425         if (occupiedPos != null) {
 426             for (ItemInfo r : occupiedPos) {
 427                 int right = r.cellX + r.spanX;
 428                 int bottom = r.cellY + r.spanY;
 429                 for (int x = r.cellX; 0 &lt;= x &amp;&amp; x &lt; right &amp;&amp; x &lt; xCount; x++) {
 430                     for (int y = r.cellY; 0 &lt;= y &amp;&amp; y &lt; bottom &amp;&amp; y &lt; yCount; y++) {
 431                         occupied[x][y] = true;
 432                     }
 433                 }
 434             }
 435         }
 436         return Utilities.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);
 437     }
 438 
 439     /**
 440      * Find a position on the screen for the given size or adds a new screen.
 441      * @return screenId and the coordinates for the item.
 442      */
 443     @Thunk Pair&lt;Long, int[]&gt; findSpaceForItem(
 444             Context context,
 445             ArrayList&lt;Long&gt; workspaceScreens,
 446             ArrayList&lt;Long&gt; addedWorkspaceScreensFinal,
 447             int spanX, int spanY) {
 448         LongSparseArray&lt;ArrayList&lt;ItemInfo&gt;&gt; screenItems = new LongSparseArray&lt;&gt;();
 449 
 450         // Use sBgItemsIdMap as all the items are already loaded.
 451         assertWorkspaceLoaded();
 452         synchronized (sBgLock) {
 453             for (ItemInfo info : sBgItemsIdMap) {
 454                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 455                     ArrayList&lt;ItemInfo&gt; items = screenItems.get(info.screenId);
 456                     if (items == null) {
 457                         items = new ArrayList&lt;&gt;();
 458                         screenItems.put(info.screenId, items);
 459                     }
 460                     items.add(info);
 461                 }
 462             }
 463         }
 464 
 465         // Find appropriate space for the item.
 466         long screenId = 0;
 467         int[] cordinates = new int[2];
 468         boolean found = false;
 469 
 470         int screenCount = workspaceScreens.size();
 471         // First check the preferred screen.
 472         int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;
 473         if (preferredScreenIndex &lt; screenCount) {
 474             screenId = workspaceScreens.get(preferredScreenIndex);
 475             found = findNextAvailableIconSpaceInScreen(
 476                     screenItems.get(screenId), cordinates, spanX, spanY);
 477         }
 478 
 479         if (!found) {
 480             // Search on any of the screens starting from the first screen.
 481             for (int screen = 1; screen &lt; screenCount; screen++) {
 482                 screenId = workspaceScreens.get(screen);
 483                 if (findNextAvailableIconSpaceInScreen(
 484                         screenItems.get(screenId), cordinates, spanX, spanY)) {
 485                     // We found a space for it
 486                     found = true;
 487                     break;
 488                 }
 489             }
 490         }
 491 
 492         if (!found) {
 493             // Still no position found. Add a new screen to the end.
 494             screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 495 
 496             // Save the screen id for binding in the workspace
 497             workspaceScreens.add(screenId);
 498             addedWorkspaceScreensFinal.add(screenId);
 499 
 500             // If we still can&#x27;t find an empty space, then God help us all!!!
 501             if (!findNextAvailableIconSpaceInScreen(
 502                     screenItems.get(screenId), cordinates, spanX, spanY)) {
 503                 throw new RuntimeException(&quot;Can&#x27;t find space to add the item&quot;);
 504             }
 505         }
 506         return Pair.create(screenId, cordinates);
 507     }
 508 
 509     /**
 510      * Adds the provided items to the workspace.
 511      */
 512     public void addAndBindAddedWorkspaceItems(final Context context,
 513             final ArrayList&lt;? extends ItemInfo&gt; workspaceApps) {
 514         final Callbacks callbacks = getCallback();
 515         if (workspaceApps.isEmpty()) {
 516             return;
 517         }
 518         // Process the newly added applications and add them to the database first
 519         Runnable r = new Runnable() {
 520             public void run() {
 521                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 522                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 523 
 524                 // Get the list of workspace screens.  We need to append to this list and
 525                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 526                 // called.
 527                 ArrayList&lt;Long&gt; workspaceScreens = loadWorkspaceScreensDb(context);
 528                 synchronized(sBgLock) {
 529                     for (ItemInfo item : workspaceApps) {
 530                         if (item instanceof ShortcutInfo) {
 531                             // Short-circuit this logic if the icon exists somewhere on the workspace
 532                             if (shortcutExists(context, item.getIntent(), item.user)) {
 533                                 continue;
 534                             }
 535                         }
 536 
 537                         // Find appropriate space for the item.
 538                         Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context,
 539                                 workspaceScreens, addedWorkspaceScreensFinal,
 540                                 1, 1);
 541                         long screenId = coords.first;
 542                         int[] cordinates = coords.second;
 543 
 544                         ItemInfo itemInfo;
 545                         if (item instanceof ShortcutInfo || item instanceof FolderInfo) {
 546                             itemInfo = item;
 547                         } else if (item instanceof AppInfo) {
 548                             itemInfo = ((AppInfo) item).makeShortcut();
 549                         } else {
 550                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 551                         }
 552 
 553                         // Add the shortcut to the db
 554                         addItemToDatabase(context, itemInfo,
 555                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 556                                 screenId, cordinates[0], cordinates[1]);
 557                         // Save the ShortcutInfo for binding in the workspace
 558                         addedShortcutsFinal.add(itemInfo);
 559                     }
 560                 }
 561 
 562                 // Update the workspace screens
 563                 updateWorkspaceScreenOrder(context, workspaceScreens);
 564 
 565                 if (!addedShortcutsFinal.isEmpty()) {
 566                     runOnMainThread(new Runnable() {
 567                         public void run() {
 568                             Callbacks cb = getCallback();
 569                             if (callbacks == cb &amp;&amp; cb != null) {
 570                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 571                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 572                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 573                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 573                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 574                                     long lastScreenId = info.screenId;
 575                                     for (ItemInfo i : addedShortcutsFinal) {
 576                                         if (i.screenId == lastScreenId) {
 577                                             addAnimated.add(i);
 578                                         } else {
 579                                             addNotAnimated.add(i);
 580                                         }
 581                                     }
 582                                 }
 583                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 584                                         addNotAnimated, addAnimated, null);
 585                             }
 586                         }
 587                     });
 588                 }
 589             }
 590         };
 591         runOnWorkerThread(r);
 592     }
 593 
 594     private void unbindItemInfosAndClearQueuedBindRunnables() {
 595         if (sWorkerThread.getThreadId() == Process.myTid()) {
 596             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 597                     &quot;main thread&quot;);
 598         }
 599 
 600         // Clear any deferred bind runnables
 601         synchronized (mDeferredBindRunnables) {
 602             mDeferredBindRunnables.clear();
 603         }
 604 
 605         // Remove any queued UI runnables
 606         mHandler.cancelAll();
 607         // Unbind all the workspace items
 608         unbindWorkspaceItemsOnMainThread();
 609     }
 610 
 611     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 612     void unbindWorkspaceItemsOnMainThread() {
 613         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 614         // by making a copy of workspace items first.
 615         final ArrayList&lt;ItemInfo&gt; tmpItems = new ArrayList&lt;ItemInfo&gt;();
 616         synchronized (sBgLock) {
 617             tmpItems.addAll(sBgWorkspaceItems);
 618             tmpItems.addAll(sBgAppWidgets);
 619         }
 620         Runnable r = new Runnable() {
 621                 @Override
 622                 public void run() {
 623                    for (ItemInfo item : tmpItems) {
 624                        item.unbind();
 625                    }
 626                 }
 627             };
 628         runOnMainThread(r);
 629     }
 630 
 631     /**
 632      * Adds an item to the DB if it was not created previously, or move it to a new
 633      * &lt;container, screen, cellX, cellY&gt;
 634      */
 635     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 636             long screenId, int cellX, int cellY) {
 637         if (item.container == ItemInfo.NO_ID) {
 638             // From all apps
 639             addItemToDatabase(context, item, container, screenId, cellX, cellY);
 640         } else {
 641             // From somewhere else
 642             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 643         }
 644     }
 645 
 646     static void checkItemInfoLocked(
 647             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 648         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 649         if (modelItem != null &amp;&amp; item != modelItem) {
 650             // check all the data is consistent
 651             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 652                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 653                 ShortcutInfo shortcut = (ShortcutInfo) item;
 654                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 655                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 656                         modelShortcut.id == shortcut.id &amp;&amp;
 657                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 658                         modelShortcut.container == shortcut.container &amp;&amp;
 659                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 660                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 661                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 662                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 663                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 664                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 665                         (modelShortcut.dropPos != null &amp;&amp;
 666                                 shortcut.dropPos != null &amp;&amp;
 667                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 668                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 669                     // For all intents and purposes, this is the same object
 670                     return;
 671                 }
 672             }
 673 
 674             // the modelItem needs to match up perfectly with item if our model is
 675             // to be consistent with the database-- for now, just require
 676             // modelItem == item or the equality check above
 677             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 678                     &quot;modelItem: &quot; +
 679                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 680                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 681             RuntimeException e = new RuntimeException(msg);
 682             if (stackTrace != null) {
 683                 e.setStackTrace(stackTrace);
 684             }
 685             throw e;
 686         }
 687     }
 688 
 689     static void checkItemInfo(final ItemInfo item) {
 690         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 691         final long itemId = item.id;
 692         Runnable r = new Runnable() {
 693             public void run() {
 694                 synchronized (sBgLock) {
 695                     checkItemInfoLocked(itemId, item, stackTrace);
 696                 }
 697             }
 698         };
 699         runOnWorkerThread(r);
 700     }
 701 
 702     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 703             final ItemInfo item, final String callingFunction) {
 704         final long itemId = item.id;
 705         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 706         final ContentResolver cr = context.getContentResolver();
 707 
 708         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 709         Runnable r = new Runnable() {
 710             public void run() {
 711                 cr.update(uri, values, null, null);
 712                 updateItemArrays(item, itemId, stackTrace);
 713             }
 714         };
 715         runOnWorkerThread(r);
 716     }
 717 
 718     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 719             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 720         final ContentResolver cr = context.getContentResolver();
 721 
 722         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 723         Runnable r = new Runnable() {
 724             public void run() {
 725                 ArrayList&lt;ContentProviderOperation&gt; ops =
 726                         new ArrayList&lt;ContentProviderOperation&gt;();
 727                 int count = items.size();
 728                 for (int i = 0; i &lt; count; i++) {
 729                     ItemInfo item = items.get(i);
 730                     final long itemId = item.id;
 731                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 732                     ContentValues values = valuesList.get(i);
 733 
 734                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 735                     updateItemArrays(item, itemId, stackTrace);
 736 
 737                 }
 738                 try {
 739                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 740                 } catch (Exception e) {
 741                     e.printStackTrace();
 742                 }
 743             }
 744         };
 745         runOnWorkerThread(r);
 746     }
 747 
 748     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 749         // Lock on mBgLock *after* the db operation
 750         synchronized (sBgLock) {
 751             checkItemInfoLocked(itemId, item, stackTrace);
 752 
 753             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 754                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 755                 // Item is in a folder, make sure this folder exists
 756                 if (!sBgFolders.containsKey(item.container)) {
 757                     // An items container is being set to a that of an item which is not in
 758                     // the list of Folders.
 759                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 760                             item.container + &quot;, not in the list of folders&quot;;
 761                     Log.e(TAG, msg);
 762                 }
 763             }
 764 
 765             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 766             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 767             // that are on the desktop, as appropriate
 768             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 769             if (modelItem != null &amp;&amp;
 770                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 771                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 772                 switch (modelItem.itemType) {
 773                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 774                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 775                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 776                         if (!sBgWorkspaceItems.contains(modelItem)) {
 777                             sBgWorkspaceItems.add(modelItem);
 778                         }
 779                         break;
 780                     default:
 781                         break;
 782                 }
 783             } else {
 784                 sBgWorkspaceItems.remove(modelItem);
 785             }
 786         }
 787     }
 788 
 789     /**
 790      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 791      */
 792     public static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 793             final long screenId, final int cellX, final int cellY) {
 794         item.container = container;
 795         item.cellX = cellX;
 796         item.cellY = cellY;
 797 
 798         // We store hotseat items in canonical form which is this orientation invariant position
 799         // in the hotseat
 800         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 801                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 802             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 803         } else {
 804             item.screenId = screenId;
 805         }
 806 
 807         final ContentValues values = new ContentValues();
 808         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 809         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 810         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 811         values.put(LauncherSettings.Favorites.RANK, item.rank);
 812         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 813 
 814         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 815     }
 816 
 817     /**
 818      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 819      * cellX, cellY have already been updated on the ItemInfos.
 820      */
 821     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 822             final long container, final int screen) {
 823 
 824         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 825         int count = items.size();
 826 
 827         for (int i = 0; i &lt; count; i++) {
 828             ItemInfo item = items.get(i);
 829             item.container = container;
 830 
 831             // We store hotseat items in canonical form which is this orientation invariant position
 832             // in the hotseat
 833             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 834                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 835                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 836                         item.cellY);
 837             } else {
 838                 item.screenId = screen;
 839             }
 840 
 841             final ContentValues values = new ContentValues();
 842             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 843             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 844             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 845             values.put(LauncherSettings.Favorites.RANK, item.rank);
 846             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 847 
 848             contentValues.add(values);
 849         }
 850         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 851     }
 852 
 853     /**
 854      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 855      */
 856     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 857             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 858         item.container = container;
 859         item.cellX = cellX;
 860         item.cellY = cellY;
 861         item.spanX = spanX;
 862         item.spanY = spanY;
 863 
 864         // We store hotseat items in canonical form which is this orientation invariant position
 865         // in the hotseat
 866         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 867                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 868             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 869         } else {
 870             item.screenId = screenId;
 871         }
 872 
 873         final ContentValues values = new ContentValues();
 874         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 875         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 876         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 877         values.put(LauncherSettings.Favorites.RANK, item.rank);
 878         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 879         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 880         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 881 
 882         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 883     }
 884 
 885     /**
 886      * Update an item to the database in a specified container.
 887      */
 888     public static void updateItemInDatabase(Context context, final ItemInfo item) {
 889         final ContentValues values = new ContentValues();
 890         item.onAddToDatabase(context, values);
 891         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 892     }
 893 
 894     private void assertWorkspaceLoaded() {
 895         if (LauncherAppState.isDogfoodBuild() &amp;&amp; (isLoadingWorkspace() || !mHasLoaderCompletedOnce)) {
 896             throw new RuntimeException(&quot;Trying to add shortcut while loader is running&quot;);
 897         }
 898     }
 899 
 900     /**
 901      * Returns true if the shortcuts already exists on the workspace. This must be called after
 902      * the workspace has been loaded. We identify a shortcut by its intent.
 903      */
 904     @Thunk boolean shortcutExists(Context context, Intent intent, UserHandleCompat user) {
 905         assertWorkspaceLoaded();
 906         final String intentWithPkg, intentWithoutPkg;
 907         if (intent.getComponent() != null) {
 908             // If component is not null, an intent with null package will produce
 909             // the same result and should also be a match.
 910             String packageName = intent.getComponent().getPackageName();
 911             if (intent.getPackage() != null) {
 912                 intentWithPkg = intent.toUri(0);
 913                 intentWithoutPkg = new Intent(intent).setPackage(null).toUri(0);
 914             } else {
 915                 intentWithPkg = new Intent(intent).setPackage(packageName).toUri(0);
 916                 intentWithoutPkg = intent.toUri(0);
 917             }
 918         } else {
 919             intentWithPkg = intent.toUri(0);
 920             intentWithoutPkg = intent.toUri(0);
 921         }
 922 
 923         synchronized (sBgLock) {
 924             for (ItemInfo item : sBgItemsIdMap) {
 925                 if (item instanceof ShortcutInfo) {
 926                     ShortcutInfo info = (ShortcutInfo) item;
 927                     Intent targetIntent = info.promisedIntent == null
 928                             ? info.intent : info.promisedIntent;
 929                     if (targetIntent != null &amp;&amp; info.user.equals(user)) {
 930                         String s = targetIntent.toUri(0);
 931                         if (intentWithPkg.equals(s) || intentWithoutPkg.equals(s)) {
 932                             return true;
 933                         }
 934                     }
 935                 }
 936             }
 937         }
 938         return false;
 939     }
 940 
 941     /**
 942      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 943      */
 944     FolderInfo getFolderById(Context context, LongArrayMap&lt;FolderInfo&gt; folderList, long id) {
 945         final ContentResolver cr = context.getContentResolver();
 946         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 947                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 948                 new String[] { String.valueOf(id),
 949                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 950 
 951         try {
 952             if (c.moveToFirst()) {
 953                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 954                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 955                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 956                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 957                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 958                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 959                 final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);
 960 
 961                 FolderInfo folderInfo = null;
 962                 switch (c.getInt(itemTypeIndex)) {
 963                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 964                         folderInfo = findOrMakeFolder(folderList, id);
 965                         break;
 966                 }
 967 
 968                 // Do not trim the folder label, as is was set by the user.
 969                 folderInfo.title = c.getString(titleIndex);
 970                 folderInfo.id = id;
 971                 folderInfo.container = c.getInt(containerIndex);
 972                 folderInfo.screenId = c.getInt(screenIndex);
 973                 folderInfo.cellX = c.getInt(cellXIndex);
 974                 folderInfo.cellY = c.getInt(cellYIndex);
 975                 folderInfo.options = c.getInt(optionsIndex);
 976 
 977                 return folderInfo;
 978             }
 979         } finally {
 980             c.close();
 981         }
 982 
 983         return null;
 984     }
 985 
 986     /**
 987      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 988      * cellY fields of the item. Also assigns an ID to the item.
 989      */
 990     public static void addItemToDatabase(Context context, final ItemInfo item, final long container,
 991             final long screenId, final int cellX, final int cellY) {
 992         item.container = container;
 993         item.cellX = cellX;
 994         item.cellY = cellY;
 995         // We store hotseat items in canonical form which is this orientation invariant position
 996         // in the hotseat
 997         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 998                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 999             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1000         } else {
1001             item.screenId = screenId;
1002         }
1003 
1004         final ContentValues values = new ContentValues();
1005         final ContentResolver cr = context.getContentResolver();
1006         item.onAddToDatabase(context, values);
1007 
1008         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1009         values.put(LauncherSettings.Favorites._ID, item.id);
1010 
1011         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1012         Runnable r = new Runnable() {
1013             public void run() {
1014                 cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);
1015 
1016                 // Lock on mBgLock *after* the db operation
1017                 synchronized (sBgLock) {
1018                     checkItemInfoLocked(item.id, item, stackTrace);
1019                     sBgItemsIdMap.put(item.id, item);
1020                     switch (item.itemType) {
1021                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1022                             sBgFolders.put(item.id, (FolderInfo) item);
1023                             // Fall through
1024                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1025                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1026                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1027                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1028                                 sBgWorkspaceItems.add(item);
1029                             } else {
1030                                 if (!sBgFolders.containsKey(item.container)) {
1031                                     // Adding an item to a folder that doesn&#x27;t exist.
1032                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1033                                             &quot; doesn&#x27;t exist&quot;;
1034                                     Log.e(TAG, msg);
1035                                 }
1036                             }
1037                             break;
1038                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1039                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1040                             break;
1041                     }
1042                 }
1043             }
1044         };
1045         runOnWorkerThread(r);
1046     }
1047 
1048     /**
1049      * Creates a new unique child id, for a given cell span across all layouts.
1050      */
1051     static int getCellLayoutChildId(
1052             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1053         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1054                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1055     }
1056 
1057     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1058             final String pn, final UserHandleCompat user) {
1059         ItemInfoFilter filter  = new ItemInfoFilter() {
1060             @Override
1061             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1062                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1063             }
1064         };
1065         return filterItemInfos(sBgItemsIdMap, filter);
1066     }
1067 
1068     /**
1069      * Removes all the items from the database corresponding to the specified package.
1070      */
1071     static void deletePackageFromDatabase(Context context, final String pn,
1072             final UserHandleCompat user) {
1073         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1074     }
1075 
1076     /**
1077      * Removes the specified item from the database
1078      * @param context
1079      * @param item
1080      */
1081     public static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1082         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1083         items.add(item);
1084         deleteItemsFromDatabase(context, items);
1085     }
1086 
1087     /**
1088      * Removes the specified items from the database
1089      * @param context
1090      * @param item
1091      */
1092     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;? extends ItemInfo&gt; items) {
1093         final ContentResolver cr = context.getContentResolver();
1094         Runnable r = new Runnable() {
1095             public void run() {
1096                 for (ItemInfo item : items) {
1097                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id);
1098                     cr.delete(uri, null, null);
1099 
1100                     // Lock on mBgLock *after* the db operation
1101                     synchronized (sBgLock) {
1102                         switch (item.itemType) {
1103                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1104                                 sBgFolders.remove(item.id);
1105                                 for (ItemInfo info: sBgItemsIdMap) {
1106                                     if (info.container == item.id) {
1107                                         // We are deleting a folder which still contains items that
1108                                         // think they are contained by that folder.
1109                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1110                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1111                                         Log.e(TAG, msg);
1112                                     }
1113                                 }
1114                                 sBgWorkspaceItems.remove(item);
1115                                 break;
1116                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1117                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1118                                 sBgWorkspaceItems.remove(item);
1119                                 break;
1120                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1121                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1122                                 break;
1123                         }
1124                         sBgItemsIdMap.remove(item.id);
1125                     }
1126                 }
1127             }
1128         };
1129         runOnWorkerThread(r);
1130     }
1131 
1132     /**
1133      * Update the order of the workspace screens in the database. The array list contains
1134      * a list of screen ids in the order that they should appear.
1135      */
1136     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1137         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1138         final ContentResolver cr = context.getContentResolver();
1139         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1140 
1141         // Remove any negative screen ids -- these aren&#x27;t persisted
1142         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1143         while (iter.hasNext()) {
1144             long id = iter.next();
1145             if (id &lt; 0) {
1146                 iter.remove();
1147             }
1148         }
1149 
1150         Runnable r = new Runnable() {
1151             @Override
1152             public void run() {
1153                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1154                 // Clear the table
1155                 ops.add(ContentProviderOperation.newDelete(uri).build());
1156                 int count = screensCopy.size();
1157                 for (int i = 0; i &lt; count; i++) {
1158                     ContentValues v = new ContentValues();
1159                     long screenId = screensCopy.get(i);
1160                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1161                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1162                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1163                 }
1164 
1165                 try {
1166                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1167                 } catch (Exception ex) {
1168                     throw new RuntimeException(ex);
1169                 }
1170 
1171                 synchronized (sBgLock) {
1172                     sBgWorkspaceScreens.clear();
1173                     sBgWorkspaceScreens.addAll(screensCopy);
1174                 }
1175             }
1176         };
1177         runOnWorkerThread(r);
1178     }
1179 
1180     /**
1181      * Remove the contents of the specified folder from the database
1182      */
1183     public static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1184         final ContentResolver cr = context.getContentResolver();
1185 
1186         Runnable r = new Runnable() {
1187             public void run() {
1188                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);
1189                 // Lock on mBgLock *after* the db operation
1190                 synchronized (sBgLock) {
1191                     sBgItemsIdMap.remove(info.id);
1192                     sBgFolders.remove(info.id);
1193                     sBgWorkspaceItems.remove(info);
1194                 }
1195 
1196                 cr.delete(LauncherSettings.Favorites.CONTENT_URI,
1197                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1198                 // Lock on mBgLock *after* the db operation
1199                 synchronized (sBgLock) {
1200                     for (ItemInfo childInfo : info.contents) {
1201                         sBgItemsIdMap.remove(childInfo.id);
1202                     }
1203                 }
1204             }
1205         };
1206         runOnWorkerThread(r);
1207     }
1208 
1209     /**
1210      * Set this as the current Launcher activity object for the loader.
1211      */
1212     public void initialize(Callbacks callbacks) {
1213         synchronized (mLock) {
1214             // Disconnect any of the callbacks and drawables associated with ItemInfos on the
1215             // workspace to prevent leaking Launcher activities on orientation change.
1216             unbindItemInfosAndClearQueuedBindRunnables();
1217             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1218         }
1219     }
1220 
1221     @Override
1222     public void onPackageChanged(String packageName, UserHandleCompat user) {
1223         int op = PackageUpdatedTask.OP_UPDATE;
1224         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1225                 user));
1226     }
1227 
1228     @Override
1229     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1230         int op = PackageUpdatedTask.OP_REMOVE;
1231         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1232                 user));
1233     }
1234 
1235     @Override
1236     public void onPackageAdded(String packageName, UserHandleCompat user) {
1237         int op = PackageUpdatedTask.OP_ADD;
1238         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1239                 user));
1240     }
1241 
1242     @Override
1243     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1244             boolean replacing) {
1245         if (!replacing) {
1246             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1247                     user));
1248             if (mAppsCanBeOnRemoveableStorage) {
1249                 // Only rebind if we support removable storage. It catches the
1250                 // case where
1251                 // apps on the external sd card need to be reloaded
1252                 startLoaderFromBackground();
1253             }
1254         } else {
1255             // If we are replacing then just update the packages in the list
1256             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1257                     packageNames, user));
1258         }
1259     }
1260 
1261     @Override
1262     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1263             boolean replacing) {
1264         if (!replacing) {
1265             enqueuePackageUpdated(new PackageUpdatedTask(
1266                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1267                     user));
1268         }
1269     }
1270 
1271     /**
1272      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1273      * ACTION_PACKAGE_CHANGED.
1274      */
1275     @Override
1276     public void onReceive(Context context, Intent intent) {
1277         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1278 
1279         final String action = intent.getAction();
1280         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1281             // If we have changed locale we need to clear out the labels in all apps/workspace.
1282             forceReload();
1283         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1284                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1285             Callbacks callbacks = getCallback();
1286             if (callbacks != null) {
1287                 callbacks.bindSearchablesChanged();
1288             }
1289         } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)
1290                 || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {
1291             forceReload();
1292         }
1293     }
1294 
1295     void forceReload() {
1296         resetLoadedState(true, true);
1297 
1298         // Do this here because if the launcher activity is running it will be restarted.
1299         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1300         // to reload.
1301         startLoaderFromBackground();
1302     }
1303 
1304     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1305         synchronized (mLock) {
1306             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1307             // mWorkspaceLoaded to true later
1308             stopLoaderLocked();
1309             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1310             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1311         }
1312     }
1313 
1314     /**
1315      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1316      * configuration changes.  So whenever we trigger the loader from the background
1317      * tell the launcher that it needs to re-run the loader when it comes back instead
1318      * of doing it now.
1319      */
1320     public void startLoaderFromBackground() {
1321         boolean runLoader = false;
1322         Callbacks callbacks = getCallback();
1323         if (callbacks != null) {
1324             // Only actually run the loader if they&#x27;re not paused.
1325             if (!callbacks.setLoadOnResume()) {
1326                 runLoader = true;
1327             }
1328         }
1329         if (runLoader) {
1330             startLoader(PagedView.INVALID_RESTORE_PAGE);
1331         }
1332     }
1333 
1334     /**
1335      * If there is already a loader task running, tell it to stop.
1336      */
1337     private void stopLoaderLocked() {
1338         LoaderTask oldTask = mLoaderTask;
1339         if (oldTask != null) {
1340             oldTask.stopLocked();
1341         }
1342     }
1343 
1344     public boolean isCurrentCallbacks(Callbacks callbacks) {
1345         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1346     }
1347 
1348     public void startLoader(int synchronousBindPage) {
1349         startLoader(synchronousBindPage, LOADER_FLAG_NONE);
1350     }
1351 
1352     public void startLoader(int synchronousBindPage, int loadFlags) {
1353         // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems
1354         InstallShortcutReceiver.enableInstallQueue();
1355         synchronized (mLock) {
1356             // Clear any deferred bind-runnables from the synchronized load process
1357             // We must do this before any loading/binding is scheduled below.
1358             synchronized (mDeferredBindRunnables) {
1359                 mDeferredBindRunnables.clear();
1360             }
1361 
1362             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1363             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1364                 // If there is already one running, tell it to stop.
1365                 stopLoaderLocked();
1366                 mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags);
1367                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1368                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) {
1369                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1370                 } else {
1371                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1372                     sWorker.post(mLoaderTask);
1373                 }
1374             }
1375         }
1376     }
1377 
1378     void bindRemainingSynchronousPages() {
1379         // Post the remaining side pages to be loaded
1380         if (!mDeferredBindRunnables.isEmpty()) {
1381             Runnable[] deferredBindRunnables = null;
1382             synchronized (mDeferredBindRunnables) {
1383                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1384                         new Runnable[mDeferredBindRunnables.size()]);
1385                 mDeferredBindRunnables.clear();
1386             }
1387             for (final Runnable r : deferredBindRunnables) {
1388                 mHandler.post(r);
1389             }
1390         }
1391 
1392         // Run all the bind complete runnables after workspace is bound.
1393         if (!mBindCompleteRunnables.isEmpty()) {
1394             synchronized (mBindCompleteRunnables) {
1395                 for (final Runnable r : mBindCompleteRunnables) {
1396                     runOnWorkerThread(r);
1397                 }
1398                 mBindCompleteRunnables.clear();
1399             }
1400         }
1401     }
1402 
1403     public void stopLoader() {
1404         synchronized (mLock) {
1405             if (mLoaderTask != null) {
1406                 mLoaderTask.stopLocked();
1407             }
1408         }
1409     }
1410 
1411     /**
1412      * Loads the workspace screen ids in an ordered list.
1413      */
1414     @Thunk static ArrayList&lt;Long&gt; loadWorkspaceScreensDb(Context context) {
1415         final ContentResolver contentResolver = context.getContentResolver();
1416         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1417 
1418         // Get screens ordered by rank.
1419         final Cursor sc = contentResolver.query(screensUri, null, null, null,
1420                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1421         ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1422         try {
1423             final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);
1424             while (sc.moveToNext()) {
1425                 try {
1426                     screenIds.add(sc.getLong(idIndex));
1427                 } catch (Exception e) {
1428                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;
1429                             + &quot; - invalid screens: &quot; + e, true);
1430                 }
1431             }
1432         } finally {
1433             sc.close();
1434         }
1435         return screenIds;
1436     }
1437 
1438     public boolean isAllAppsLoaded() {
1439         return mAllAppsLoaded;
1440     }
1441 
1442     boolean isLoadingWorkspace() {
1443         synchronized (mLock) {
1444             if (mLoaderTask != null) {
1445                 return mLoaderTask.isLoadingWorkspace();
1446             }
1447         }
1448         return false;
1449     }
1450 
1451     /**
1452      * Runnable for the thread that loads the contents of the launcher:
1453      *   - workspace icons
1454      *   - widgets
1455      *   - all apps icons
1456      */
1457     private class LoaderTask implements Runnable {
1458         private Context mContext;
1459         @Thunk boolean mIsLoadingAndBindingWorkspace;
1460         private boolean mStopped;
1461         @Thunk boolean mLoadAndBindStepFinished;
1462         private int mFlags;
1463 
1464         LoaderTask(Context context, int flags) {
1465             mContext = context;
1466             mFlags = flags;
1467         }
1468 
1469         boolean isLoadingWorkspace() {
1470             return mIsLoadingAndBindingWorkspace;
1471         }
1472 
1473         private void loadAndBindWorkspace() {
1474             mIsLoadingAndBindingWorkspace = true;
1475 
1476             // Load the workspace
1477             if (DEBUG_LOADERS) {
1478                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1479             }
1480 
1481             if (!mWorkspaceLoaded) {
1482                 loadWorkspace();
1483                 synchronized (LoaderTask.this) {
1484                     if (mStopped) {
1485                         return;
1486                     }
1487                     mWorkspaceLoaded = true;
1488                 }
1489             }
1490 
1491             // Bind the workspace
1492             bindWorkspace(-1);
1493         }
1494 
1495         private void waitForIdle() {
1496             // Wait until the either we&#x27;re stopped or the other threads are done.
1497             // This way we don&#x27;t start loading all apps until the workspace has settled
1498             // down.
1499             synchronized (LoaderTask.this) {
1500                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1501 
1502                 mHandler.postIdle(new Runnable() {
1503                         public void run() {
1504                             synchronized (LoaderTask.this) {
1505                                 mLoadAndBindStepFinished = true;
1506                                 if (DEBUG_LOADERS) {
1507                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1508                                 }
1509                                 LoaderTask.this.notify();
1510                             }
1511                         }
1512                     });
1513 
1514                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1515                     try {
1516                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1517                         // wait no longer than 1sec at a time
1518                         this.wait(1000);
1519                     } catch (InterruptedException ex) {
1520                         // Ignore
1521                     }
1522                 }
1523                 if (DEBUG_LOADERS) {
1524                     Log.d(TAG, &quot;waited &quot;
1525                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1526                             + &quot;ms for previous step to finish binding&quot;);
1527                 }
1528             }
1529         }
1530 
1531         void runBindSynchronousPage(int synchronousBindPage) {
1532             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1533                 // Ensure that we have a valid page index to load synchronously
1534                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1535                         &quot;valid page index&quot;);
1536             }
1537             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1538                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1539                 // loaded already (we should load everything asynchronously in that case)
1540                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1541             }
1542             synchronized (mLock) {
1543                 if (mIsLoaderTaskRunning) {
1544                     // Ensure that we are never running the background loading at this point since
1545                     // we also touch the background collections
1546                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1547                 }
1548             }
1549 
1550             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1551             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1552             //      this call is synchronous, we can get away with not locking).
1553 
1554             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1555             // operations from the previous activity.  We need to ensure that all queued operations
1556             // are executed before any synchronous binding work is done.
1557             mHandler.flush();
1558 
1559             // Divide the set of loaded items into those that we are binding synchronously, and
1560             // everything else that is to be bound normally (asynchronously).
1561             bindWorkspace(synchronousBindPage);
1562             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1563             //      arise from that.
1564             onlyBindAllApps();
1565         }
1566 
1567         public void run() {
1568             synchronized (mLock) {
1569                 if (mStopped) {
1570                     return;
1571                 }
1572                 mIsLoaderTaskRunning = true;
1573             }
1574             // Optimize for end-user experience: if the Launcher is up and // running with the
1575             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1576             // workspace first (default).
1577             keep_running: {
1578                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1579                 loadAndBindWorkspace();
1580 
1581                 if (mStopped) {
1582                     break keep_running;
1583                 }
1584 
1585                 waitForIdle();
1586 
1587                 // second step
1588                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1589                 loadAndBindAllApps();
1590             }
1591 
1592             // Clear out this reference, otherwise we end up holding it until all of the
1593             // callback runnables are done.
1594             mContext = null;
1595 
1596             synchronized (mLock) {
1597                 // If we are still the last one to be scheduled, remove ourselves.
1598                 if (mLoaderTask == this) {
1599                     mLoaderTask = null;
1600                 }
1601                 mIsLoaderTaskRunning = false;
1602                 mHasLoaderCompletedOnce = true;
1603             }
1604         }
1605 
1606         public void stopLocked() {
1607             synchronized (LoaderTask.this) {
1608                 mStopped = true;
1609                 this.notify();
1610             }
1611         }
1612 
1613         /**
1614          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1615          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1616          * object that was around when the deferred message was scheduled, and if there&#x27;s
1617          * a new Callbacks object around then also return null.  This will save us from
1618          * calling onto it with data that will be ignored.
1619          */
1620         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1621             synchronized (mLock) {
1622                 if (mStopped) {
1623                     return null;
1624                 }
1625 
1626                 if (mCallbacks == null) {
1627                     return null;
1628                 }
1629 
1630                 final Callbacks callbacks = mCallbacks.get();
1631                 if (callbacks != oldCallbacks) {
1632                     return null;
1633                 }
1634                 if (callbacks == null) {
1635                     Log.w(TAG, &quot;no mCallbacks&quot;);
1636                     return null;
1637                 }
1638 
1639                 return callbacks;
1640             }
1641         }
1642 
1643         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1644         private boolean checkItemPlacement(LongArrayMap&lt;ItemInfo[][]&gt; occupied, ItemInfo item) {
1645             LauncherAppState app = LauncherAppState.getInstance();
1646             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1647             final int countX = (int) profile.numColumns;
1648             final int countY = (int) profile.numRows;
1649 
1650             long containerIndex = item.screenId;
1651             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1652                 // Return early if we detect that an item is under the hotseat button
1653                 if (mCallbacks == null ||
1654                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1655                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1656                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1657                             + item.cellY + &quot;) occupied by all apps&quot;);
1658                     return false;
1659                 }
1660 
1661                 final ItemInfo[][] hotseatItems =
1662                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1663 
1664                 if (item.screenId &gt;= profile.numHotseatIcons) {
1665                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1666                             + &quot; into hotseat position &quot; + item.screenId
1667                             + &quot;, position out of bounds: (0 to &quot; + (profile.numHotseatIcons - 1)
1668                             + &quot;)&quot;);
1669                     return false;
1670                 }
1671 
1672                 if (hotseatItems != null) {
1673                     if (hotseatItems[(int) item.screenId][0] != null) {
1674                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1675                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1676                                 + item.cellY + &quot;) occupied by &quot;
1677                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1678                                 [(int) item.screenId][0]);
1679                             return false;
1680                     } else {
1681                         hotseatItems[(int) item.screenId][0] = item;
1682                         return true;
1683                     }
1684                 } else {
1685                     final ItemInfo[][] items = new ItemInfo[(int) profile.numHotseatIcons][1];
1686                     items[(int) item.screenId][0] = item;
1687                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1688                     return true;
1689                 }
1690             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1691                 // Skip further checking if it is not the hotseat or workspace container
1692                 return true;
1693             }
1694 
1695             if (!occupied.containsKey(item.screenId)) {
1696                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1697                 occupied.put(item.screenId, items);
1698             }
1699 
1700             final ItemInfo[][] screens = occupied.get(item.screenId);
1701             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1702                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1703                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1704                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1705                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1706                         + item.cellX + &quot;,&quot; + item.cellY
1707                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1708                 return false;
1709             }
1710 
1711             // Check if any workspace icons overlap with each other
1712             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1713                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1714                     if (screens[x][y] != null) {
1715                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1716                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1717                             + x + &quot;,&quot; + y
1718                             + &quot;) occupied by &quot;
1719                             + screens[x][y]);
1720                         return false;
1721                     }
1722                 }
1723             }
1724             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1725                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1726                     screens[x][y] = item;
1727                 }
1728             }
1729 
1730             return true;
1731         }
1732 
1733         /** Clears all the sBg data structures */
1734         private void clearSBgDataStructures() {
1735             synchronized (sBgLock) {
1736                 sBgWorkspaceItems.clear();
1737                 sBgAppWidgets.clear();
1738                 sBgFolders.clear();
1739                 sBgItemsIdMap.clear();
1740                 sBgWorkspaceScreens.clear();
1741             }
1742         }
1743 
1744         private void loadWorkspace() {
1745             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1746 
1747             final Context context = mContext;
1748             final ContentResolver contentResolver = context.getContentResolver();
1749             final PackageManager manager = context.getPackageManager();
1750             final boolean isSafeMode = manager.isSafeMode();
1751             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1752             final boolean isSdCardReady = context.registerReceiver(null,
1753                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1754 
1755             LauncherAppState app = LauncherAppState.getInstance();
1756             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1757             int countX = (int) profile.numColumns;
1758             int countY = (int) profile.numRows;
1759 
1760             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1761                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1762                 LauncherAppState.getLauncherProvider().deleteDatabase();
1763             }
1764 
1765             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1766                 // append the user&#x27;s Launcher2 shortcuts
1767                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1768                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1769             } else {
1770                 // Make sure the default workspace is loaded
1771                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1772                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1773             }
1774 
1775             synchronized (sBgLock) {
1776                 clearSBgDataStructures();
1777                 final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat
1778                         .getInstance(mContext).updateAndGetActiveSessionCache();
1779 
1780                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1781                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1782                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1783                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1784                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1785 
1786                 // +1 for the hotseat (it can be larger than the workspace)
1787                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1788                 // before any earlier duplicates)
1789                 final LongArrayMap&lt;ItemInfo[][]&gt; occupied = new LongArrayMap&lt;&gt;();
1790 
1791                 try {
1792                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1793                     final int intentIndex = c.getColumnIndexOrThrow
1794                             (LauncherSettings.Favorites.INTENT);
1795                     final int titleIndex = c.getColumnIndexOrThrow
1796                             (LauncherSettings.Favorites.TITLE);
1797                     final int containerIndex = c.getColumnIndexOrThrow(
1798                             LauncherSettings.Favorites.CONTAINER);
1799                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1800                             LauncherSettings.Favorites.ITEM_TYPE);
1801                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1802                             LauncherSettings.Favorites.APPWIDGET_ID);
1803                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1804                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1805                     final int screenIndex = c.getColumnIndexOrThrow(
1806                             LauncherSettings.Favorites.SCREEN);
1807                     final int cellXIndex = c.getColumnIndexOrThrow
1808                             (LauncherSettings.Favorites.CELLX);
1809                     final int cellYIndex = c.getColumnIndexOrThrow
1810                             (LauncherSettings.Favorites.CELLY);
1811                     final int spanXIndex = c.getColumnIndexOrThrow
1812                             (LauncherSettings.Favorites.SPANX);
1813                     final int spanYIndex = c.getColumnIndexOrThrow(
1814                             LauncherSettings.Favorites.SPANY);
1815                     final int rankIndex = c.getColumnIndexOrThrow(
1816                             LauncherSettings.Favorites.RANK);
1817                     final int restoredIndex = c.getColumnIndexOrThrow(
1818                             LauncherSettings.Favorites.RESTORED);
1819                     final int profileIdIndex = c.getColumnIndexOrThrow(
1820                             LauncherSettings.Favorites.PROFILE_ID);
1821                     final int optionsIndex = c.getColumnIndexOrThrow(
1822                             LauncherSettings.Favorites.OPTIONS);
1823                     final CursorIconInfo cursorIconInfo = new CursorIconInfo(c);
1824 
1825                     final LongSparseArray&lt;UserHandleCompat&gt; allUsers = new LongSparseArray&lt;&gt;();
1826                     for (UserHandleCompat user : mUserManager.getUserProfiles()) {
1827                         allUsers.put(mUserManager.getSerialNumberForUser(user), user);
1828                     }
1829 
1830                     ShortcutInfo info;
1831                     String intentDescription;
1832                     LauncherAppWidgetInfo appWidgetInfo;
1833                     int container;
1834                     long id;
1835                     long serialNumber;
1836                     Intent intent;
1837                     UserHandleCompat user;
1838 
1839                     while (!mStopped &amp;&amp; c.moveToNext()) {
1840                         try {
1841                             int itemType = c.getInt(itemTypeIndex);
1842                             boolean restored = 0 != c.getInt(restoredIndex);
1843                             boolean allowMissingTarget = false;
1844                             container = c.getInt(containerIndex);
1845 
1846                             switch (itemType) {
1847                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1848                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1849                                 id = c.getLong(idIndex);
1850                                 intentDescription = c.getString(intentIndex);
1851                                 serialNumber = c.getInt(profileIdIndex);
1852                                 user = allUsers.get(serialNumber);
1853                                 int promiseType = c.getInt(restoredIndex);
1854                                 int disabledState = 0;
1855                                 boolean itemReplaced = false;
1856                                 if (user == null) {
1857                                     // User has been deleted remove the item.
1858                                     itemsToRemove.add(id);
1859                                     continue;
1860                                 }
1861                                 try {
1862                                     intent = Intent.parseUri(intentDescription, 0);
1863                                     ComponentName cn = intent.getComponent();
1864                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
1865                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
1866                                                 cn.getPackageName(), user);
1867                                         boolean validComponent = validPkg &amp;&amp;
1868                                                 launcherApps.isActivityEnabledForProfile(cn, user);
1869 
1870                                         if (validComponent) {
1871                                             if (restored) {
1872                                                 // no special handling necessary for this item
1873                                                 restoredRows.add(id);
1874                                                 restored = false;
1875                                             }
1876                                         } else if (validPkg) {
1877                                             intent = null;
1878                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
1879                                                 // We allow auto install apps to have their intent
1880                                                 // updated after an install.
1881                                                 intent = manager.getLaunchIntentForPackage(
1882                                                         cn.getPackageName());
1883                                                 if (intent != null) {
1884                                                     ContentValues values = new ContentValues();
1885                                                     values.put(LauncherSettings.Favorites.INTENT,
1886                                                             intent.toUri(0));
1887                                                     updateItem(id, values);
1888                                                 }
1889                                             }
1890 
1891                                             if (intent == null) {
1892                                                 // The app is installed but the component is no
1893                                                 // longer available.
1894                                                 Launcher.addDumpLog(TAG,
1895                                                         &quot;Invalid component removed: &quot; + cn, true);
1896                                                 itemsToRemove.add(id);
1897                                                 continue;
1898                                             } else {
1899                                                 // no special handling necessary for this item
1900                                                 restoredRows.add(id);
1901                                                 restored = false;
1902                                             }
1903                                         } else if (restored) {
1904                                             // Package is not yet available but might be
1905                                             // installed later.
1906                                             Launcher.addDumpLog(TAG,
1907                                                     &quot;package not yet restored: &quot; + cn, true);
1908 
1909                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
1910                                                 // Restore has started once.
1911                                             } else if (installingPkgs.containsKey(cn.getPackageName())) {
1912                                                 // App restore has started. Update the flag
1913                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
1914                                                 ContentValues values = new ContentValues();
1915                                                 values.put(LauncherSettings.Favorites.RESTORED,
1916                                                         promiseType);
1917                                                 updateItem(id, values);
<abbr title="1918                                             } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE) != 0) {">1918                                             } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE🔵</abbr>
1919                                                 // This is a common app. Try to replace this.
<abbr title="1920                                                 int appType = CommonAppTypeParser.decodeItemTypeFromFlag(promiseType);">1920                                                 int appType = CommonAppTypeParser.decodeItemTypeFromFlag(🔵</abbr>
<abbr title="1921                                                 CommonAppTypeParser parser = new CommonAppTypeParser(id, appType, context);">1921                                                 CommonAppTypeParser parser = new CommonAppTypeParser(id, 🔵</abbr>
1922                                                 if (parser.findDefaultApp()) {
1923                                                     // Default app found. Replace it.
1924                                                     intent = parser.parsedIntent;
1925                                                     cn = intent.getComponent();
1926                                                     ContentValues values = parser.parsedValues;
1927                                                     values.put(LauncherSettings.Favorites.RESTORED, 0);
1928                                                     updateItem(id, values);
1929                                                     restored = false;
1930                                                     itemReplaced = true;
1931 
1932                                             } else if (REMOVE_UNRESTORED_ICONS) {
1933                                                 Launcher.addDumpLog(TAG,
1934                                                         &quot;Unrestored package removed: &quot; + cn, true);
1935                                                 itemsToRemove.add(id);
1936                                                 continue;
1937                                             }
1938                                             } else if (REMOVE_UNRESTORED_ICONS) {
1939                                                 Launcher.addDumpLog(TAG,
1940                                                         &quot;Unrestored package removed: &quot; + cn, true);
1941                                                 itemsToRemove.add(id);
1942                                                 continue;
1943                                             }
1944                                         } else if (launcherApps.isAppEnabled(
1945                                                 manager, cn.getPackageName(),
1946                                                 PackageManager.GET_UNINSTALLED_PACKAGES)) {
1947                                             // Package is present but not available.
1948                                             allowMissingTarget = true;
1949                                             disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
1950                                         } else if (!isSdCardReady) {
1951                                             // SdCard is not ready yet. Package might get available,
1952                                             // once it is ready.
1953                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
1954                                                     + &quot; (check again later)&quot;, true);
1955                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
1956                                             if (pkgs == null) {
1957                                                 pkgs = new HashSet&lt;String&gt;();
1958                                                 sPendingPackages.put(user, pkgs);
1959                                             }
1960                                             pkgs.add(cn.getPackageName());
1961                                             allowMissingTarget = true;
1962                                             // Add the icon on the workspace anyway.
1963 
1964                                         } else {
1965                                             // Do not wait for external media load anymore.
1966                                             // Log the invalid package, and remove it
1967                                             Launcher.addDumpLog(TAG,
1968                                                     &quot;Invalid package removed: &quot; + cn, true);
1969                                             itemsToRemove.add(id);
1970                                             continue;
1971                                         }
1972                                     } else if (cn == null) {
1973                                         // For shortcuts with no component, keep them as they are
1974                                         restoredRows.add(id);
1975                                         restored = false;
1976                                     }
1977                                 } catch (URISyntaxException e) {
1978                                     Launcher.addDumpLog(TAG,
1979                                             &quot;Invalid uri: &quot; + intentDescription, true);
1980                                     continue;
1981                                 }
1982 
1983                                 boolean useLowResIcon = container &gt;= 0 &amp;&amp;
1984                                         c.getInt(rankIndex) &gt;= FolderIcon.NUM_ITEMS_IN_PREVIEW;
1985 
1986                                 if (itemReplaced) {
1987                                     if (user.equals(UserHandleCompat.myUserHandle())) {
1988                                         info = getAppShortcutInfo(manager, intent, user, context, null,
1989                                                 cursorIconInfo.iconIndex, titleIndex,
1990                                                 false, useLowResIcon);
1991                                     } else {
1992                                         // Don&#x27;t replace items for other profiles.
1993                                         itemsToRemove.add(id);
1994                                         continue;
1995                                     }
1996                                 } else if (restored) {
1997                                     if (user.equals(UserHandleCompat.myUserHandle())) {
1998                                         Launcher.addDumpLog(TAG,
1999                                                 &quot;constructing info for partially restored package&quot;,
2000                                                 true);
2001                                         info = getRestoredItemInfo(c, titleIndex, intent,
2002                                                 promiseType, itemType, cursorIconInfo, context);
2003                                         intent = getRestoredItemIntent(c, context, intent);
2004                                     } else {
2005                                         // Don&#x27;t restore items for other profiles.
2006                                         itemsToRemove.add(id);
2007                                         continue;
2008                                     }
2009                                 } else if (itemType ==
2010                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2011                                     info = getAppShortcutInfo(manager, intent, user, context, c,
2012                                             cursorIconInfo.iconIndex, titleIndex,
2013                                             allowMissingTarget, useLowResIcon);
2014                                 } else {
2015                                     info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);
2016 
2017                                     // App shortcuts that used to be automatically added to Launcher
2018                                     // didn&#x27;t always have the correct intent flags set, so do that
2019                                     // here
2020                                     if (intent.getAction() != null &amp;&amp;
2021                                         intent.getCategories() != null &amp;&amp;
2022                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2023                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2024                                         intent.addFlags(
2025                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2026                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2027                                     }
2028                                 }
2029 
2030                                 if (info != null) {
2031                                     info.id = id;
2032                                     info.intent = intent;
2033                                     info.container = container;
2034                                     info.screenId = c.getInt(screenIndex);
2035                                     info.cellX = c.getInt(cellXIndex);
2036                                     info.cellY = c.getInt(cellYIndex);
2037                                     info.rank = c.getInt(rankIndex);
2038                                     info.spanX = 1;
2039                                     info.spanY = 1;
2040                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2041                                     if (info.promisedIntent != null) {
<abbr title="2042                                         info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);">2042                                         info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber🔵</abbr>
2043                                     }
2044                                     info.isDisabled = disabledState;
2045                                     if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2046                                         info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2047                                     }
2048 
2049                                     // check &amp; update map of what&#x27;s occupied
2050                                     if (!checkItemPlacement(occupied, info)) {
2051                                         itemsToRemove.add(id);
2052                                         break;
2053                                     }
2054 
2055                                     if (restored) {
2056                                         ComponentName cn = info.getTargetComponent();
2057                                         if (cn != null) {
2058                                             Integer progress = installingPkgs.get(cn.getPackageName());
2059                                             if (progress != null) {
2060                                                 info.setInstallProgress(progress);
2061                                             } else {
2062                                                 info.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
2063                                             }
2064                                         }
2065                                     }
2066 
2067                                     switch (container) {
2068                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2069                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2070                                         sBgWorkspaceItems.add(info);
2071                                         break;
2072                                     default:
2073                                         // Item is in a user folder
2074                                         FolderInfo folderInfo =
2075                                                 findOrMakeFolder(sBgFolders, container);
2076                                         folderInfo.add(info);
2077                                         break;
2078                                     }
2079                                     sBgItemsIdMap.put(info.id, info);
2080                                 } else {
2081                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2082                                 }
2083                                 break;
2084 
2085                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2086                                 id = c.getLong(idIndex);
2087                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2088 
2089                                 // Do not trim the folder label, as is was set by the user.
2090                                 folderInfo.title = c.getString(titleIndex);
2091                                 folderInfo.id = id;
2092                                 folderInfo.container = container;
2093                                 folderInfo.screenId = c.getInt(screenIndex);
2094                                 folderInfo.cellX = c.getInt(cellXIndex);
2095                                 folderInfo.cellY = c.getInt(cellYIndex);
2096                                 folderInfo.spanX = 1;
2097                                 folderInfo.spanY = 1;
2098                                 folderInfo.options = c.getInt(optionsIndex);
2099 
2100                                 // check &amp; update map of what&#x27;s occupied
2101                                 if (!checkItemPlacement(occupied, folderInfo)) {
2102                                     itemsToRemove.add(id);
2103                                     break;
2104                                 }
2105 
2106                                 switch (container) {
2107                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2108                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2109                                         sBgWorkspaceItems.add(folderInfo);
2110                                         break;
2111                                 }
2112 
2113                                 if (restored) {
2114                                     // no special handling required for restored folders
2115                                     restoredRows.add(id);
2116                                 }
2117 
2118                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2119                                 sBgFolders.put(folderInfo.id, folderInfo);
2120                                 break;
2121 
2122                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2123                             case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
2124                                 // Read all Launcher-specific widget details
2125                                 boolean customWidget = itemType ==
2126                                     LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;
2127 
2128                                 id = c.getLong(idIndex);
2129                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2130                                 serialNumber= c.getLong(profileIdIndex);
2131                                 String savedProvider = c.getString(appWidgetProviderIndex);
2132                                 id = c.getLong(idIndex);
2133                                 user = allUsers.get(serialNumber);
2134                                 if (user == null) {
2135                                     itemsToRemove.add(id);
2136                                     continue;
2137                                 }
2138 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2139 </span>
2140 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2141                                 id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2142                                 final ComponentName component =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2143                                         ComponentName.unflattenFromString(savedProvider);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2144 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2145                                 final int restoreStatus = c.getInt(restoredIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2146                                 final boolean isIdValid = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2147                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2148 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2149                                 final boolean wasProviderReady = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2150                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2151 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2152                                 final LauncherAppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2153                                         LauncherModel.getProviderInfo(context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2154                                                 ComponentName.unflattenFromString(savedProvider),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2155                                                 user);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2156 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2157                                 final boolean isProviderReady = isValidProvider(provider);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2158                                 if (!isSafeMode &amp;&amp; !customWidget &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2159                                         wasProviderReady &amp;&amp; !isProviderReady) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2160                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2161                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2162 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2163                                     Log.e(TAG, log);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2164                                     Launcher.addDumpLog(TAG, log, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2165                                     itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2166                                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2167                                     if (isProviderReady) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2168                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2169                                                 provider.provider);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2170 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2171                                         if (!customWidget) {</span>
2172 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2173                                 String savedProvider = c.getString(appWidgetProviderIndex);</span>
2174 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
2175                                 final ComponentName component =
2176                                         ComponentName.unflattenFromString(savedProvider);
2177 
2178                                 final int restoreStatus = c.getInt(restoredIndex);
2179                                 final boolean isIdValid = (restoreStatus &amp;
2180                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2181                                 final boolean wasProviderReady = (restoreStatus &amp;
2182                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2183 
2184                                 final LauncherAppWidgetProviderInfo provider =
2185                                         LauncherModel.getProviderInfo(context,
2186                                                 ComponentName.unflattenFromString(savedProvider),
2187                                                 user);
2188 
2189                                 final boolean isProviderReady = isValidProvider(provider);
2190                                 if (!isSafeMode &amp;&amp; !customWidget &amp;&amp;
2191                                         wasProviderReady &amp;&amp; !isProviderReady) {
2192                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2193                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2194 
2195                                     Log.e(TAG, log);
2196                                     Launcher.addDumpLog(TAG, log, false);
2197                                     itemsToRemove.add(id);
2198                                 } else {
2199                                     if (isProviderReady) {
2200                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2201                                                 provider.provider);
2202 
2203                                         int status = restoreStatus;
2204                                         if (!wasProviderReady) {
2205                                             // If provider was not previously ready, update the
2206                                             // status and UI flag.
2207 
<abbr title="2208                                             // Id would be valid only if the widget restore broadcast was received.">2208                                             // Id would be valid only if the widget restore broadcast was🔵</abbr>
2209                                             if (isIdValid) {
2210                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2211                                             } else {
2212                                                 status &amp;= ~LauncherAppWidgetInfo
2213                                                         .FLAG_PROVIDER_NOT_READY;
2214                                             }
2215                                         }
2216                                         appWidgetInfo.restoreStatus = status;
2217                                     } else {
2218                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2219                                                 + &quot; appWidgetId=&quot; + appWidgetId
2220                                                 + &quot; status =&quot; + restoreStatus);
2221                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2222                                                 component);
2223                                         appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2224                                         Integer installProgress = installingPkgs.get(component.getPackageName());">2224                                         Integer installProgress = installingPkgs.get(component.getPackage🔵</abbr>
2225 
<abbr title="2226                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2226                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) 🔵</abbr>
2227                                             // Restore has started once.
2228                                         } else if (installProgress != null) {
2229                                             // App restore has started. Update the flag
2230                                             appWidgetInfo.restoreStatus |=
2231                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2232                                         } else if (REMOVE_UNRESTORED_ICONS &amp;&amp; !isSafeMode) {
2233                                             Launcher.addDumpLog(TAG,
2234                                                     &quot;Unrestored widget removed: &quot; + component, true);
2235                                             itemsToRemove.add(id);
2236                                             continue;
2237                                         }
2238 
2239                                         appWidgetInfo.installProgress =
2240                                                 installProgress == null ? 0 : installProgress;
2241                                     }
2242 
2243                                     appWidgetInfo.id = id;
2244                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2245                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2246                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2247                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2248                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2249 
2250                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2251                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2252                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2253                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2254                                         continue;
2255                                     }
2256 
2257                                     appWidgetInfo.container = container;
2258                                     // check &amp; update map of what&#x27;s occupied
2259                                     if (!checkItemPlacement(occupied, appWidgetInfo)) {
2260                                         itemsToRemove.add(id);
2261                                         break;
2262                                     }
2263 
2264                                     if (!customWidget) {
2265                                         String providerName =
2266                                                 appWidgetInfo.providerName.flattenToString();
2267                                         if (!providerName.equals(savedProvider) ||
2268                                                 (appWidgetInfo.restoreStatus != restoreStatus)) {
2269                                             ContentValues values = new ContentValues();
2270                                             values.put(
2271                                                     LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2272                                                     providerName);
2273                                             values.put(LauncherSettings.Favorites.RESTORED,
2274                                                     appWidgetInfo.restoreStatus);
2275                                             updateItem(id, values);
2276                                         }
2277                                     }
2278                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2279                                     sBgAppWidgets.add(appWidgetInfo);
2280                                 }
2281                                 break;
2282                             }
2283                         } catch (Exception e) {
2284                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2285                         }
2286                     }
2287                 } finally {
2288                     if (c != null) {
2289                         c.close();
2290                     }
2291                 }
2292 
2293                 // Break early if we&#x27;ve stopped loading
2294                 if (mStopped) {
2295                     clearSBgDataStructures();
2296                     return;
2297                 }
2298 
2299                 if (itemsToRemove.size() &gt; 0) {
2300                     // Remove dead items
2301                     contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI,
2302                             Utilities.createDbSelectionQuery(
2303                                     LauncherSettings.Favorites._ID, itemsToRemove), null);
2304                         if (DEBUG_LOADERS) {
2305                         Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery(
2306                                 LauncherSettings.Favorites._ID, itemsToRemove));
2307                         }
2308 
2309                     // Remove any empty folder
2310                     for (long folderId : LauncherAppState.getLauncherProvider()
2311                             .deleteEmptyFolders()) {
2312                         sBgWorkspaceItems.remove(sBgFolders.get(folderId));
2313                         sBgFolders.remove(folderId);
2314                         sBgItemsIdMap.remove(folderId);
2315                     }
2316                 }
2317 
2318                 if (restoredRows.size() &gt; 0) {
2319                     // Update restored items that no longer require special handling
2320                         ContentValues values = new ContentValues();
2321                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2322                     contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values,
2323                             Utilities.createDbSelectionQuery(
2324                                     LauncherSettings.Favorites._ID, restoredRows), null);
2325                 }
2326 
2327                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2328                     context.registerReceiver(new AppsAvailabilityCheck(),
2329                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2330                             null, sWorker);
2331                 }
2332 
2333                 sBgWorkspaceScreens.addAll(loadWorkspaceScreensDb(mContext));
2334 
2335                     // Remove any empty screens
2336                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2337                 for (ItemInfo item: sBgItemsIdMap) {
2338                         long screenId = item.screenId;
2339                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2340                                 unusedScreens.contains(screenId)) {
2341                             unusedScreens.remove(screenId);
2342                         }
2343                     }
2344 
2345                     // If there are any empty screens remove them, and update.
2346                     if (unusedScreens.size() != 0) {
2347                         sBgWorkspaceScreens.removeAll(unusedScreens);
2348                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2349                     }
2350 
2351                 if (DEBUG_LOADERS) {
2352                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2353                     Log.d(TAG, &quot;workspace layout: &quot;);
2354                     int nScreens = occupied.size();
2355                     for (int y = 0; y &lt; countY; y++) {
2356                         String line = &quot;&quot;;
2357 
2358                         for (int i = 0; i &lt; nScreens; i++) {
2359                             long screenId = occupied.keyAt(i);
2360                             if (screenId &gt; 0) {
2361                                 line += &quot; | &quot;;
2362                             }
2363                             ItemInfo[][] screen = occupied.valueAt(i);
2364                             for (int x = 0; x &lt; countX; x++) {
2365                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2366                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2367                                 } else {
2368                                     line += &quot;!&quot;;
2369                                 }
2370                             }
2371                         }
2372                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2373                     }
2374                 }
2375             }
2376         }
2377 
2378         /**
2379          * Partially updates the item without any notification. Must be called on the worker thread.
2380          */
2381         private void updateItem(long itemId, ContentValues update) {
2382             mContext.getContentResolver().update(
2383                     LauncherSettings.Favorites.CONTENT_URI,
2384                     update,
2385                     BaseColumns._ID + &quot;= ?&quot;,
2386                     new String[]{Long.toString(itemId)});
2387         }
2388 
2389         /** Filters the set of items who are directly or indirectly (via another container) on the
2390          * specified screen. */
2391         private void filterCurrentWorkspaceItems(long currentScreenId,
2392                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2393                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2394                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2395             // Purge any null ItemInfos
2396             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2397             while (iter.hasNext()) {
2398                 ItemInfo i = iter.next();
2399                 if (i == null) {
2400                     iter.remove();
2401                 }
2402             }
2403 
2404             // Order the set of items by their containers first, this allows use to walk through the
2405             // list sequentially, build up a list of containers that are in the specified screen,
2406             // as well as all items in those containers.
2407             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2408             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2409                 @Override
2410                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2411                     return (int) (lhs.container - rhs.container);
2412                 }
2413             });
2414             for (ItemInfo info : allWorkspaceItems) {
2415                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2416                     if (info.screenId == currentScreenId) {
2417                         currentScreenItems.add(info);
2418                         itemsOnScreen.add(info.id);
2419                     } else {
2420                         otherScreenItems.add(info);
2421                     }
2422                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2423                     currentScreenItems.add(info);
2424                     itemsOnScreen.add(info.id);
2425                 } else {
2426                     if (itemsOnScreen.contains(info.container)) {
2427                         currentScreenItems.add(info);
2428                         itemsOnScreen.add(info.id);
2429                     } else {
2430                         otherScreenItems.add(info);
2431                     }
2432                 }
2433             }
2434         }
2435 
2436         /** Filters the set of widgets which are on the specified screen. */
2437         private void filterCurrentAppWidgets(long currentScreenId,
2438                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2439                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2440                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2441 
2442             for (LauncherAppWidgetInfo widget : appWidgets) {
2443                 if (widget == null) continue;
2444                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2445                         widget.screenId == currentScreenId) {
2446                     currentScreenWidgets.add(widget);
2447                 } else {
2448                     otherScreenWidgets.add(widget);
2449                 }
2450             }
2451         }
2452 
2453         /** Filters the set of folders which are on the specified screen. */
2454         private void filterCurrentFolders(long currentScreenId,
2455                 LongArrayMap&lt;ItemInfo&gt; itemsIdMap,
2456                 LongArrayMap&lt;FolderInfo&gt; folders,
2457                 LongArrayMap&lt;FolderInfo&gt; currentScreenFolders,
2458                 LongArrayMap&lt;FolderInfo&gt; otherScreenFolders) {
2459 
2460             int total = folders.size();
2461             for (int i = 0; i &lt; total; i++) {
2462                 long id = folders.keyAt(i);
2463                 FolderInfo folder = folders.valueAt(i);
2464 
2465                 ItemInfo info = itemsIdMap.get(id);
2466                 if (info == null || folder == null) continue;
2467                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2468                         info.screenId == currentScreenId) {
2469                     currentScreenFolders.put(id, folder);
2470                 } else {
2471                     otherScreenFolders.put(id, folder);
2472                 }
2473             }
2474         }
2475 
2476         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2477          * right) */
2478         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2479             final LauncherAppState app = LauncherAppState.getInstance();
2480             final InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
2481             // XXX: review this
2482             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2483                 @Override
2484                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2485                     int cellCountX = (int) profile.numColumns;
2486                     int cellCountY = (int) profile.numRows;
2487                     int screenOffset = cellCountX * cellCountY;
2488                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2489                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2490                             lhs.cellY * cellCountX + lhs.cellX);
2491                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2492                             rhs.cellY * cellCountX + rhs.cellX);
2493                     return (int) (lr - rr);
2494                 }
2495             });
2496         }
2497 
2498         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2499                 final ArrayList&lt;Long&gt; orderedScreens) {
2500             final Runnable r = new Runnable() {
2501                 @Override
2502                 public void run() {
2503                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2504                     if (callbacks != null) {
2505                         callbacks.bindScreens(orderedScreens);
2506                     }
2507                 }
2508             };
2509             runOnMainThread(r);
2510         }
2511 
2512         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2513                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2514                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2515                 final LongArrayMap&lt;FolderInfo&gt; folders,
2516                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2517 
2518             final boolean postOnMainThread = (deferredBindRunnables != null);
2519 
2520             // Bind the workspace items
2521             int N = workspaceItems.size();
2522             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2523                 final int start = i;
2524                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2525                 final Runnable r = new Runnable() {
2526                     @Override
2527                     public void run() {
2528                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2529                         if (callbacks != null) {
2530                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2531                                     false);
2532                         }
2533                     }
2534                 };
2535                 if (postOnMainThread) {
2536                     synchronized (deferredBindRunnables) {
2537                         deferredBindRunnables.add(r);
2538                     }
2539                 } else {
2540                     runOnMainThread(r);
2541                 }
2542             }
2543 
2544             // Bind the folders
2545             if (!folders.isEmpty()) {
2546                 final Runnable r = new Runnable() {
2547                     public void run() {
2548                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2549                         if (callbacks != null) {
2550                             callbacks.bindFolders(folders);
2551                         }
2552                     }
2553                 };
2554                 if (postOnMainThread) {
2555                     synchronized (deferredBindRunnables) {
2556                         deferredBindRunnables.add(r);
2557                     }
2558                 } else {
2559                     runOnMainThread(r);
2560                 }
2561             }
2562 
2563             // Bind the widgets, one at a time
2564             N = appWidgets.size();
2565             for (int i = 0; i &lt; N; i++) {
2566                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2567                 final Runnable r = new Runnable() {
2568                     public void run() {
2569                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2570                         if (callbacks != null) {
2571                             callbacks.bindAppWidget(widget);
2572                         }
2573                     }
2574                 };
2575                 if (postOnMainThread) {
2576                     deferredBindRunnables.add(r);
2577                 } else {
2578                     runOnMainThread(r);
2579                 }
2580             }
2581         }
2582 
2583         /**
2584          * Binds all loaded data to actual views on the main thread.
2585          */
2586         private void bindWorkspace(int synchronizeBindPage) {
2587             final long t = SystemClock.uptimeMillis();
2588             Runnable r;
2589 
2590             // Don&#x27;t use these two variables in any of the callback runnables.
2591             // Otherwise we hold a reference to them.
2592             final Callbacks oldCallbacks = mCallbacks.get();
2593             if (oldCallbacks == null) {
2594                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2595                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2596                 return;
2597             }
2598 
2599             // Save a copy of all the bg-thread collections
2600             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2601             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2602                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2603             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2604 
2605             final LongArrayMap&lt;FolderInfo&gt; folders;
2606             final LongArrayMap&lt;ItemInfo&gt; itemsIdMap;
2607 
2608             synchronized (sBgLock) {
2609                 workspaceItems.addAll(sBgWorkspaceItems);
2610                 appWidgets.addAll(sBgAppWidgets);
2611                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2612 
2613                 folders = sBgFolders.clone();
2614                 itemsIdMap = sBgItemsIdMap.clone();
2615             }
2616 
2617             final boolean isLoadingSynchronously =
2618                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2619             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2620                 oldCallbacks.getCurrentWorkspaceScreen();
2621             if (currScreen &gt;= orderedScreenIds.size()) {
2622                 // There may be no workspace screens (just hotseat items and an empty page).
2623                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2624             }
2625             final int currentScreen = currScreen;
2626             final long currentScreenId = currentScreen &lt; 0
2627                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2628 
2629             // Load all the items that are on the current page first (and in the process, unbind
2630             // all the existing workspace items before we call startBinding() below.
2631             unbindWorkspaceItemsOnMainThread();
2632 
2633             // Separate the items that are on the current screen, and all the other remaining items
2634             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2635             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2636             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2637                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2638             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2639                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2640             LongArrayMap&lt;FolderInfo&gt; currentFolders = new LongArrayMap&lt;&gt;();
2641             LongArrayMap&lt;FolderInfo&gt; otherFolders = new LongArrayMap&lt;&gt;();
2642 
2643             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2644                     otherWorkspaceItems);
2645             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2646                     otherAppWidgets);
2647             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2648                     otherFolders);
2649             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2650             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2651 
2652             // Tell the workspace that we&#x27;re about to start binding items
2653             r = new Runnable() {
2654                 public void run() {
2655                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2656                     if (callbacks != null) {
2657                         callbacks.startBinding();
2658                     }
2659                 }
2660             };
2661             runOnMainThread(r);
2662 
2663             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2664 
2665             // Load items on the current page
2666             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2667                     currentFolders, null);
2668             if (isLoadingSynchronously) {
2669                 r = new Runnable() {
2670                     public void run() {
2671                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2672                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2673                             callbacks.onPageBoundSynchronously(currentScreen);
2674                         }
2675                     }
2676                 };
2677                 runOnMainThread(r);
2678             }
2679 
2680             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2681             // work until after the first render)
2682             synchronized (mDeferredBindRunnables) {
2683                 mDeferredBindRunnables.clear();
2684             }
2685             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2686                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2687 
2688             // Tell the workspace that we&#x27;re done binding items
2689             r = new Runnable() {
2690                 public void run() {
2691                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2692                     if (callbacks != null) {
2693                         callbacks.finishBindingItems();
2694                     }
2695 
2696                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2697                     if (DEBUG_LOADERS) {
2698                         Log.d(TAG, &quot;bound workspace in &quot;
2699                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2700                     }
2701 
2702                     mIsLoadingAndBindingWorkspace = false;
2703                 }
2704             };
2705             if (isLoadingSynchronously) {
2706                 synchronized (mDeferredBindRunnables) {
2707                     mDeferredBindRunnables.add(r);
2708                 }
2709             } else {
2710                 runOnMainThread(r);
2711             }
2712         }
2713 
2714         private void loadAndBindAllApps() {
2715             if (DEBUG_LOADERS) {
2716                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2717             }
2718             if (!mAllAppsLoaded) {
2719                 loadAllApps();
2720                 synchronized (LoaderTask.this) {
2721                     if (mStopped) {
2722                         return;
2723                     }
2724                 }
2725                 updateIconCache();
2726                 synchronized (LoaderTask.this) {
2727                     if (mStopped) {
2728                         return;
2729                     }
2730                     mAllAppsLoaded = true;
2731                 }
2732             } else {
2733                 onlyBindAllApps();
2734             }
2735         }
2736 
2737         private void updateIconCache() {
2738             // Ignore packages which have a promise icon.
2739             HashSet&lt;String&gt; packagesToIgnore = new HashSet&lt;&gt;();
2740             synchronized (sBgLock) {
2741                 for (ItemInfo info : sBgItemsIdMap) {
2742                     if (info instanceof ShortcutInfo) {
2743                         ShortcutInfo si = (ShortcutInfo) info;
2744                         if (si.isPromise() &amp;&amp; si.getTargetComponent() != null) {
2745                             packagesToIgnore.add(si.getTargetComponent().getPackageName());
2746                         }
2747                     } else if (info instanceof LauncherAppWidgetInfo) {
2748                         LauncherAppWidgetInfo lawi = (LauncherAppWidgetInfo) info;
2749                         if (lawi.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {
2750                             packagesToIgnore.add(lawi.providerName.getPackageName());
2751                         }
2752                     }
2753                 }
2754             }
2755             mIconCache.updateDbIcons(packagesToIgnore);
2756         }
2757 
2758         private void onlyBindAllApps() {
2759             final Callbacks oldCallbacks = mCallbacks.get();
2760             if (oldCallbacks == null) {
2761                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2762                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2763                 return;
2764             }
2765 
2766             // shallow copy
2767             @SuppressWarnings(&quot;unchecked&quot;)
2768             final ArrayList&lt;AppInfo&gt; list
2769                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2770             final WidgetsModel widgetList = mBgWidgetsModel.clone();
2771             Runnable r = new Runnable() {
2772                 public void run() {
2773                     final long t = SystemClock.uptimeMillis();
2774                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2775                     if (callbacks != null) {
2776                         callbacks.bindAllApplications(list);
2777                         callbacks.bindAllPackages(widgetList);
2778                     }
2779                     if (DEBUG_LOADERS) {
2780                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2781                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2782                     }
2783                 }
2784             };
2785             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2786             if (isRunningOnMainThread) {
2787                 r.run();
2788             } else {
2789                 mHandler.post(r);
2790             }
2791         }
2792 
2793         private void loadAllApps() {
2794             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2795 
2796             final Callbacks oldCallbacks = mCallbacks.get();
2797             if (oldCallbacks == null) {
2798                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2799                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2800                 return;
2801             }
2802 
2803             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2804 
2805             // Clear the list of apps
2806             mBgAllAppsList.clear();
2807             for (UserHandleCompat user : profiles) {
2808                 // Query for the set of apps
2809                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2810                 final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2811                 if (DEBUG_LOADERS) {
2812                     Log.d(TAG, &quot;getActivityList took &quot;
2813                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2814                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2815                 }
2816                 // Fail if we don&#x27;t have any apps
2817                 // TODO: Fix this. Only fail for the current user.
2818                 if (apps == null || apps.isEmpty()) {
2819                     return;
2820                 }
2821 
2822                 // Create the ApplicationInfos
2823                 for (int i = 0; i &lt; apps.size(); i++) {
2824                     LauncherActivityInfoCompat app = apps.get(i);
2825                     // This builds the icon bitmaps.
2826                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache));
2827                 }
2828 
2829                 final ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(mContext, user);
2830                 if (heuristic != null) {
2831                     runAfterBindCompletes(new Runnable() {
2832 
2833                         @Override
2834                         public void run() {
2835                             heuristic.processUserApps(apps);
2836                         }
2837                     });
2838                 }
2839             }
2840             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2841             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2842             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2843 
2844             // Post callback on main thread
2845             mHandler.post(new Runnable() {
2846                 public void run() {
2847 
2848                     final long bindTime = SystemClock.uptimeMillis();
2849                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2850                     if (callbacks != null) {
2851                         callbacks.bindAllApplications(added);
2852                         if (DEBUG_LOADERS) {
2853                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2854                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2855                         }
2856                     } else {
2857                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2858                     }
2859                 }
2860             });
2861             // Cleanup any data stored for a deleted user.
2862             ManagedProfileHeuristic.processAllUsers(profiles, mContext);
2863 
2864             loadAndBindWidgetsAndShortcuts(mApp.getContext(), tryGetCallbacks(oldCallbacks),
2865                     true /* refresh */);
2866             if (DEBUG_LOADERS) {
2867                 Log.d(TAG, &quot;Icons processed in &quot;
2868                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2869             }
2870         }
2871 
2872         public void dumpState() {
2873             synchronized (sBgLock) {
2874                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2875                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2876                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2877                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2878             }
2879         }
2880     }
2881 
2882     /**
2883      * Called when the icons for packages have been updated in the icon cache.
2884      */
2885     public void onPackageIconsUpdated(HashSet&lt;String&gt; updatedPackages, UserHandleCompat user) {
2886         final Callbacks callbacks = getCallback();
2887         final ArrayList&lt;AppInfo&gt; updatedApps = new ArrayList&lt;&gt;();
2888         final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;&gt;();
2889 
2890         // If any package icon has changed (app was updated while launcher was dead),
2891         // update the corresponding shortcuts.
2892         synchronized (sBgLock) {
2893             for (ItemInfo info : sBgItemsIdMap) {
2894                 if (info instanceof ShortcutInfo &amp;&amp; user.equals(info.user)
2895                         &amp;&amp; info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2896                     ShortcutInfo si = (ShortcutInfo) info;
2897                     ComponentName cn = si.getTargetComponent();
2898                     if (cn != null &amp;&amp; updatedPackages.contains(cn.getPackageName())) {
2899                         si.updateIcon(mIconCache);
2900                         updatedShortcuts.add(si);
2901                     }
2902                 }
2903             }
2904             mBgAllAppsList.updateIconsAndLabels(updatedPackages, user, updatedApps);
2905         }
2906 
2907         if (!updatedShortcuts.isEmpty()) {
2908             final UserHandleCompat userFinal = user;
2909             mHandler.post(new Runnable() {
2910 
2911                 public void run() {
2912                     Callbacks cb = getCallback();
2913                     if (cb != null &amp;&amp; callbacks == cb) {
2914                         cb.bindShortcutsChanged(updatedShortcuts,
2915                                 new ArrayList&lt;ShortcutInfo&gt;(), userFinal);
2916                     }
2917                 }
2918             });
2919         }
2920 
2921         if (!updatedApps.isEmpty()) {
2922             mHandler.post(new Runnable() {
2923 
2924                 public void run() {
2925                     Callbacks cb = getCallback();
2926                     if (cb != null &amp;&amp; callbacks == cb) {
2927                         cb.bindAppsUpdated(updatedApps);
2928                     }
2929                 }
2930             });
2931         }
2932 
2933         // Reload widget list. No need to refresh, as we only want to update the icons and labels.
2934         loadAndBindWidgetsAndShortcuts(mApp.getContext(), callbacks, false);
2935     }
2936 
2937     void enqueuePackageUpdated(PackageUpdatedTask task) {
2938         sWorker.post(task);
2939     }
2940 
2941     @Thunk class AppsAvailabilityCheck extends BroadcastReceiver {
2942 
2943         @Override
2944         public void onReceive(Context context, Intent intent) {
2945             synchronized (sBgLock) {
2946                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2947                         .getInstance(mApp.getContext());
2948                 final PackageManager manager = context.getPackageManager();
2949                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2950                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2951                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2952                     UserHandleCompat user = entry.getKey();
2953                     packagesRemoved.clear();
2954                     packagesUnavailable.clear();
2955                     for (String pkg : entry.getValue()) {
2956                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2957                             boolean packageOnSdcard = launcherApps.isAppEnabled(
2958                                     manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
2959                             if (packageOnSdcard) {
2960                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2961                                 packagesUnavailable.add(pkg);
2962                             } else {
2963                                 Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2964                                 packagesRemoved.add(pkg);
2965                             }
2966                         }
2967                     }
2968                     if (!packagesRemoved.isEmpty()) {
2969                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2970                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2971                     }
2972                     if (!packagesUnavailable.isEmpty()) {
2973                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
<abbr title="2974                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">2974                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user🔵</abbr>
2975                     }
2976                 }
2977                 sPendingPackages.clear();
2978             }
2979         }
2980     }
2981 
2982     private class PackageUpdatedTask implements Runnable {
2983         int mOp;
2984         String[] mPackages;
2985         UserHandleCompat mUser;
2986 
2987         public static final int OP_NONE = 0;
2988         public static final int OP_ADD = 1;
2989         public static final int OP_UPDATE = 2;
2990         public static final int OP_REMOVE = 3; // uninstlled
2991         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2992 
2993 
2994         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
2995             mOp = op;
2996             mPackages = packages;
2997             mUser = user;
2998         }
2999 
3000         public void run() {
3001             if (!mHasLoaderCompletedOnce) {
3002                 // Loader has not yet run.
3003                 return;
3004             }
3005             final Context context = mApp.getContext();
3006 
3007             final String[] packages = mPackages;
3008             final int N = packages.length;
3009             switch (mOp) {
3010                 case OP_ADD: {
3011                     for (int i=0; i&lt;N; i++) {
3012                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3013                         mIconCache.updateIconsForPkg(packages[i], mUser);
3014                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3015                     }
3016 
3017                     ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
3018                     if (heuristic != null) {
3019                         heuristic.processPackageAdd(mPackages);
3020                     }
3021                     break;
3022                 }
3023                 case OP_UPDATE:
3024                     for (int i=0; i&lt;N; i++) {
3025                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3026                         mIconCache.updateIconsForPkg(packages[i], mUser);
3027                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3028                         mApp.getWidgetCache().removePackage(packages[i], mUser);
3029                     }
3030                     break;
3031                 case OP_REMOVE: {
3032                     ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
3033                     if (heuristic != null) {
3034                         heuristic.processPackageRemoved(mPackages);
3035                     }
3036                     for (int i=0; i&lt;N; i++) {
3037                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3038                         mIconCache.removeIconsForPkg(packages[i], mUser);
3039                     }
3040                     // Fall through
3041                 }
3042                 case OP_UNAVAILABLE:
3043                     for (int i=0; i&lt;N; i++) {
3044                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3045                         mBgAllAppsList.removePackage(packages[i], mUser);
3046                         mApp.getWidgetCache().removePackage(packages[i], mUser);
3047                     }
3048                     break;
3049             }
3050 
3051             ArrayList&lt;AppInfo&gt; added = null;
3052             ArrayList&lt;AppInfo&gt; modified = null;
3053             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3054 
3055             if (mBgAllAppsList.added.size() &gt; 0) {
3056                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3057                 mBgAllAppsList.added.clear();
3058             }
3059             if (mBgAllAppsList.modified.size() &gt; 0) {
3060                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3061                 mBgAllAppsList.modified.clear();
3062             }
3063             if (mBgAllAppsList.removed.size() &gt; 0) {
3064                 removedApps.addAll(mBgAllAppsList.removed);
3065                 mBgAllAppsList.removed.clear();
3066             }
3067 
3068             final Callbacks callbacks = getCallback();
3069             if (callbacks == null) {
3070                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3071                 return;
3072             }
3073 
3074             final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps =
3075                     new HashMap&lt;ComponentName, AppInfo&gt;();
3076 
3077             if (added != null) {
3078                     addAppsToAllApps(context, added);
3079                 for (AppInfo ai : added) {
3080                     addedOrUpdatedApps.put(ai.componentName, ai);
3081                 }
3082             }
3083 
3084             if (modified != null) {
3085                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3086                 for (AppInfo ai : modified) {
3087                     addedOrUpdatedApps.put(ai.componentName, ai);
3088                 }
3089 
3090                 mHandler.post(new Runnable() {
3091                     public void run() {
3092                         Callbacks cb = getCallback();
3093                         if (callbacks == cb &amp;&amp; cb != null) {
3094                             callbacks.bindAppsUpdated(modifiedFinal);
3095                         }
3096                     }
3097                 });
3098             }
3099 
3100             // Update shortcut infos
3101             if (mOp == OP_ADD || mOp == OP_UPDATE) {
3102                 final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3103                 final ArrayList&lt;ShortcutInfo&gt; removedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3104                 final ArrayList&lt;LauncherAppWidgetInfo&gt; widgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
3105 
3106                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3107                 synchronized (sBgLock) {
3108                     for (ItemInfo info : sBgItemsIdMap) {
3109                         if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3110                             ShortcutInfo si = (ShortcutInfo) info;
3111                             boolean infoUpdated = false;
3112                             boolean shortcutUpdated = false;
3113 
3114                             // Update shortcuts which use iconResource.
3115                             if ((si.iconResource != null)
3116                                     &amp;&amp; packageSet.contains(si.iconResource.packageName)) {
3117                                 Bitmap icon = Utilities.createIconBitmap(
3118                                         si.iconResource.packageName,
3119                                         si.iconResource.resourceName, context);
3120                                 if (icon != null) {
3121                                     si.setIcon(icon);
3122                                     si.usingFallbackIcon = false;
3123                                     infoUpdated = true;
3124                                 }
3125                             }
3126 
3127                             ComponentName cn = si.getTargetComponent();
3128                             if (cn != null &amp;&amp; packageSet.contains(cn.getPackageName())) {
3129                                 AppInfo appInfo = addedOrUpdatedApps.get(cn);
3130 
3131                                 if (si.isPromise()) {
3132                                     if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
3133                                         // Auto install icon
3134                                         PackageManager pm = context.getPackageManager();
3135                                         ResolveInfo matched = pm.resolveActivity(
3136                                                 new Intent(Intent.ACTION_MAIN)
3137                                                 .setComponent(cn).addCategory(Intent.CATEGORY_LAUNCHER),
3138                                                 PackageManager.MATCH_DEFAULT_ONLY);
3139                                         if (matched == null) {
3140                                             // Try to find the best match activity.
3141                                             Intent intent = pm.getLaunchIntentForPackage(
3142                                                     cn.getPackageName());
3143                                             if (intent != null) {
3144                                                 cn = intent.getComponent();
3145                                                 appInfo = addedOrUpdatedApps.get(cn);
3146                                             }
3147 
3148                                             if ((intent == null) || (appInfo == null)) {
3149                                                 removedShortcuts.add(si);
3150                                                 continue;
3151                                             }
3152                                             si.promisedIntent = intent;
3153                                         }
3154                                     }
3155 
3156                                     // Restore the shortcut.
3157                                     if (appInfo != null) {
3158                                         si.flags = appInfo.flags;
3159                                     }
3160 
3161                                     si.intent = si.promisedIntent;
3162                                     si.promisedIntent = null;
3163                                     si.status = ShortcutInfo.DEFAULT;
3164                                     infoUpdated = true;
3165                                     si.updateIcon(mIconCache);
3166                                 }
3167 
3168                                 if (appInfo != null &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction())
<abbr title="3169                                         &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">3169                                         &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATIO🔵</abbr>
3170                                     si.updateIcon(mIconCache);
3171                                     si.title = Utilities.trim(appInfo.title);
3172                                     si.contentDescription = appInfo.contentDescription;
3173                                     infoUpdated = true;
3174                                 }
3175 
3176                                 if ((si.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE) != 0) {
3177                                     // Since package was just updated, the target must be available now.
3178                                     si.isDisabled &amp;= ~ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3179                                     shortcutUpdated = true;
3180                                 }
3181                             }
3182 
3183                             if (infoUpdated || shortcutUpdated) {
3184                                 updatedShortcuts.add(si);
3185                             }
3186                             if (infoUpdated) {
3187                                 updateItemInDatabase(context, si);
3188                             }
3189                         } else if (info instanceof LauncherAppWidgetInfo) {
3190                             LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) info;
3191                             if (mUser.equals(widgetInfo.user)
<abbr title="3192                                     &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)">3192                                     &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_🔵</abbr>
3193                                     &amp;&amp; packageSet.contains(widgetInfo.providerName.getPackageName())) {
<abbr title="3194                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">3194                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READ🔵</abbr>
3195                                 widgets.add(widgetInfo);
3196                                 updateItemInDatabase(context, widgetInfo);
3197                             }
3198                         }
3199                     }
3200                 }
3201 
3202                 if (!updatedShortcuts.isEmpty() || !removedShortcuts.isEmpty()) {
3203                     mHandler.post(new Runnable() {
3204 
3205                         public void run() {
3206                             Callbacks cb = getCallback();
3207                             if (callbacks == cb &amp;&amp; cb != null) {
3208                                 callbacks.bindShortcutsChanged(
3209                                         updatedShortcuts, removedShortcuts, mUser);
3210                             }
3211                         }
3212                     });
3213                     if (!removedShortcuts.isEmpty()) {
3214                         deleteItemsFromDatabase(context, removedShortcuts);
3215                     }
3216                 }
3217                 if (!widgets.isEmpty()) {
3218                     mHandler.post(new Runnable() {
3219                         public void run() {
3220                             Callbacks cb = getCallback();
3221                             if (callbacks == cb &amp;&amp; cb != null) {
3222                                 callbacks.bindWidgetsRestored(widgets);
3223                             }
3224                         }
3225                     });
3226                 }
3227             }
3228 
3229             final ArrayList&lt;String&gt; removedPackageNames =
3230                     new ArrayList&lt;String&gt;();
3231             if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3232                 // Mark all packages in the broadcast to be removed
3233                 removedPackageNames.addAll(Arrays.asList(packages));
3234             } else if (mOp == OP_UPDATE) {
3235                 // Mark disabled packages in the broadcast to be removed
3236                 for (int i=0; i&lt;N; i++) {
3237                     if (isPackageDisabled(context, packages[i], mUser)) {
3238                         removedPackageNames.add(packages[i]);
3239                     }
3240                 }
3241             }
3242 
3243             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3244                 final int removeReason;
3245                 if (mOp == OP_UNAVAILABLE) {
3246                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3247                 } else {
3248                     // Remove all the components associated with this package
3249                     for (String pn : removedPackageNames) {
3250                         deletePackageFromDatabase(context, pn, mUser);
3251                     }
3252                     // Remove all the specific components
3253                     for (AppInfo a : removedApps) {
3254                         ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3255                         deleteItemsFromDatabase(context, infos);
3256                     }
3257                     removeReason = 0;
3258                 }
3259 
3260                 // Remove any queued items from the install queue
3261                 InstallShortcutReceiver.removeFromInstallQueue(context, removedPackageNames, mUser);
3262                 // Call the components-removed callback
3263                 mHandler.post(new Runnable() {
3264                     public void run() {
3265                         Callbacks cb = getCallback();
3266                         if (callbacks == cb &amp;&amp; cb != null) {
3267                             callbacks.bindComponentsRemoved(
3268                                     removedPackageNames, removedApps, mUser, removeReason);
3269                         }
3270                     }
3271                 });
3272             }
3273 
3274             // onProvidersChanged method (API &gt;= 17) already refreshed the widget list
3275             loadAndBindWidgetsAndShortcuts(context, callbacks, Build.VERSION.SDK_INT &lt; 17);
3276 
3277             // Write all the logs to disk
3278             mHandler.post(new Runnable() {
3279                 public void run() {
3280                     Callbacks cb = getCallback();
3281                     if (callbacks == cb &amp;&amp; cb != null) {
3282                         callbacks.dumpLogsToLocalData();
3283                     }
3284                 }
3285             });
3286         }
3287     }
3288 
3289     public static List&lt;LauncherAppWidgetProviderInfo&gt; getWidgetProviders(Context context,
3290             boolean refresh) {
3291         ArrayList&lt;LauncherAppWidgetProviderInfo&gt; results =
3292                 new ArrayList&lt;LauncherAppWidgetProviderInfo&gt;();
3293         try {
3294             synchronized (sBgLock) {
3295                 if (sBgWidgetProviders == null || refresh) {
3296                     HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; tmpWidgetProviders
3297                             = new HashMap&lt;&gt;();
3298                     AppWidgetManagerCompat wm = AppWidgetManagerCompat.getInstance(context);
3299                     LauncherAppWidgetProviderInfo info;
3300 
3301                     List&lt;AppWidgetProviderInfo&gt; widgets = wm.getAllProviders();
3302                     for (AppWidgetProviderInfo pInfo : widgets) {
3303                         info = LauncherAppWidgetProviderInfo.fromProviderInfo(context, pInfo);
3304                         UserHandleCompat user = wm.getUser(info);
3305                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3306                     }
3307 
3308                     Collection&lt;CustomAppWidget&gt; customWidgets = Launcher.getCustomAppWidgets().values();
3309                     for (CustomAppWidget widget : customWidgets) {
3310                         info = new LauncherAppWidgetProviderInfo(context, widget);
3311                         UserHandleCompat user = wm.getUser(info);
3312                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3313                     }
3314                     // Replace the global list at the very end, so that if there is an exception,
3315                     // previously loaded provider list is used.
3316                     sBgWidgetProviders = tmpWidgetProviders;
3317                 }
3318                 results.addAll(sBgWidgetProviders.values());
3319                 return results;
3320             }
3321         } catch (Exception e) {
3322             if (e.getCause() instanceof TransactionTooLargeException) {
3323                 // the returned value may be incomplete and will not be refreshed until the next
3324                 // time Launcher starts.
3325                 // TODO: after figuring out a repro step, introduce a dirty bit to check when
3326                 // onResume is called to refresh the widget provider list.
3327                 synchronized (sBgLock) {
3328                     if (sBgWidgetProviders != null) {
3329                         results.addAll(sBgWidgetProviders.values());
3330                     }
3331                     return results;
3332                 }
3333             } else {
3334                 throw e;
3335             }
3336         }
3337     }
3338 
3339     public static LauncherAppWidgetProviderInfo getProviderInfo(Context ctx, ComponentName name,
3340             UserHandleCompat user) {
3341         synchronized (sBgLock) {
3342             if (sBgWidgetProviders == null) {
3343                 getWidgetProviders(ctx, false /* refresh */);
3344             }
3345             return sBgWidgetProviders.get(new ComponentKey(name, user));
3346         }
3347     }
3348 
3349     public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks,
3350             final boolean refresh) {
3351 
3352         runOnWorkerThread(new Runnable() {
3353             @Override
3354             public void run() {
3355                 updateWidgetsModel(context, refresh);
3356                 final WidgetsModel model = mBgWidgetsModel.clone();
3357 
3358                 mHandler.post(new Runnable() {
3359                     @Override
3360                     public void run() {
3361                         Callbacks cb = getCallback();
3362                         if (callbacks == cb &amp;&amp; cb != null) {
3363                             callbacks.bindAllPackages(model);
3364                         }
3365                     }
3366                 });
3367                 // update the Widget entries inside DB on the worker thread.
3368                 LauncherAppState.getInstance().getWidgetCache().removeObsoletePreviews(
3369                         model.getRawList());
3370             }
3371         });
3372     }
3373 
3374     /**
3375      * Returns a list of ResolveInfos/AppWidgetInfos.
3376      *
3377      * @see #loadAndBindWidgetsAndShortcuts
3378      */
3379     @Thunk void updateWidgetsModel(Context context, boolean refresh) {
3380         PackageManager packageManager = context.getPackageManager();
3381         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3382         widgetsAndShortcuts.addAll(getWidgetProviders(context, refresh));
3383         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3384         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3385         mBgWidgetsModel.setWidgetsAndShortcuts(widgetsAndShortcuts);
3386     }
3387 
3388     @Thunk static boolean isPackageDisabled(Context context, String packageName,
3389             UserHandleCompat user) {
3390         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3391         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3392     }
3393 
3394     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3395             UserHandleCompat user) {
3396         if (cn == null) {
3397             return false;
3398         }
3399         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3400         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3401             return false;
3402         }
3403         return launcherApps.isActivityEnabledForProfile(cn, user);
3404     }
3405 
3406     public static boolean isValidPackage(Context context, String packageName,
3407             UserHandleCompat user) {
3408         if (packageName == null) {
3409             return false;
3410         }
3411         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3412         return launcherApps.isPackageEnabledForProfile(packageName, user);
3413     }
3414 
3415     /**
3416      * Make an ShortcutInfo object for a restored application or shortcut item that points
3417      * to a package that is not yet installed on the system.
3418      */
3419     public ShortcutInfo getRestoredItemInfo(Cursor c, int titleIndex, Intent intent,
3420             int promiseType, int itemType, CursorIconInfo iconInfo, Context context) {
3421         final ShortcutInfo info = new ShortcutInfo();
3422         info.user = UserHandleCompat.myUserHandle();
3423 
3424         Bitmap icon = iconInfo.loadIcon(c, info, context);
3425         // the fallback icon
3426         if (icon == null) {
3427             mIconCache.getTitleAndIcon(info, intent, info.user, false /* useLowResIcon */);
3428         } else {
3429             info.setIcon(icon);
3430         }
3431 
3432         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3433             String title = (c != null) ? c.getString(titleIndex) : null;
3434             if (!TextUtils.isEmpty(title)) {
3435                 info.title = Utilities.trim(title);
3436             }
3437         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3438             if (TextUtils.isEmpty(info.title)) {
3439                 info.title = (c != null) ? Utilities.trim(c.getString(titleIndex)) : &quot;&quot;;
3440             }
3441         } else {
3442             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3443         }
3444 
3445         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3446         info.itemType = itemType;
3447         info.promisedIntent = intent;
3448         info.status = promiseType;
3449         return info;
3450     }
3451 
3452     /**
3453      * Make an Intent object for a restored application or shortcut item that points
3454      * to the market page for the item.
3455      */
3456     @Thunk Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3457         ComponentName componentName = intent.getComponent();
3458         return getMarketIntent(componentName.getPackageName());
3459     }
3460 
3461     static Intent getMarketIntent(String packageName) {
3462         return new Intent(Intent.ACTION_VIEW)
3463             .setData(new Uri.Builder()
3464                 .scheme(&quot;market&quot;)
3465                 .authority(&quot;details&quot;)
3466                 .appendQueryParameter(&quot;id&quot;, packageName)
3467                 .build());
3468     }
3469 
3470     /**
3471      * Make an ShortcutInfo object for a shortcut that is an application.
3472      *
3473      * If c is not null, then it will be used to fill in missing data like the title and icon.
3474      */
3475     public ShortcutInfo getAppShortcutInfo(PackageManager manager, Intent intent,
3476             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3477             boolean allowMissingTarget, boolean useLowResIcon) {
3478         if (user == null) {
3479             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3480             return null;
3481         }
3482 
3483         ComponentName componentName = intent.getComponent();
3484         if (componentName == null) {
3485             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3486             return null;
3487         }
3488 
3489         Intent newIntent = new Intent(intent.getAction(), null);
3490         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3491         newIntent.setComponent(componentName);
3492         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3493         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3494             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3495             return null;
3496         }
3497 
3498         final ShortcutInfo info = new ShortcutInfo();
3499         mIconCache.getTitleAndIcon(info, componentName, lai, user, false, useLowResIcon);
3500         if (mIconCache.isDefaultIcon(info.getIcon(mIconCache), user) &amp;&amp; c != null) {
3501             Bitmap icon = Utilities.createIconBitmap(c, iconIndex, context);
3502             info.setIcon(icon == null ? mIconCache.getDefaultIcon(user) : icon);
3503         }
3504 
3505         // from the db
3506         if (TextUtils.isEmpty(info.title) &amp;&amp; c != null) {
3507             info.title =  Utilities.trim(c.getString(titleIndex));
3508         }
3509 
3510         // fall back to the class name of the activity
3511         if (info.title == null) {
3512             info.title = componentName.getClassName();
3513         }
3514 
3515         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3516         info.user = user;
3517         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3518         if (lai != null) {
3519             info.flags = AppInfo.initFlags(lai);
3520         }
3521         return info;
3522     }
3523 
3524     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Iterable&lt;ItemInfo&gt; infos,
3525             ItemInfoFilter f) {
3526         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3527         for (ItemInfo i : infos) {
3528             if (i instanceof ShortcutInfo) {
3529                 ShortcutInfo info = (ShortcutInfo) i;
3530                 ComponentName cn = info.getTargetComponent();
3531                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3532                     filtered.add(info);
3533                 }
3534             } else if (i instanceof FolderInfo) {
3535                 FolderInfo info = (FolderInfo) i;
3536                 for (ShortcutInfo s : info.contents) {
3537                     ComponentName cn = s.getTargetComponent();
3538                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3539                         filtered.add(s);
3540                     }
3541                 }
3542             } else if (i instanceof LauncherAppWidgetInfo) {
3543                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3544                 ComponentName cn = info.providerName;
3545                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3546                     filtered.add(info);
3547                 }
3548             }
3549         }
3550         return new ArrayList&lt;ItemInfo&gt;(filtered);
3551     }
3552 
3553     @Thunk ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3554             final UserHandleCompat user) {
3555         ItemInfoFilter filter  = new ItemInfoFilter() {
3556             @Override
3557             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3558                 if (info.user == null) {
3559                     return cn.equals(cname);
3560                 } else {
3561                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3562                 }
3563             }
3564         };
3565         return filterItemInfos(sBgItemsIdMap, filter);
3566     }
3567 
3568     /**
3569      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3570      */
3571     @Thunk ShortcutInfo getShortcutInfo(Cursor c, Context context,
3572             int titleIndex, CursorIconInfo iconInfo) {
3573         final ShortcutInfo info = new ShortcutInfo();
3574         // Non-app shortcuts are only supported for current user.
3575         info.user = UserHandleCompat.myUserHandle();
3576         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3577 
3578         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3579 
3580         info.title = Utilities.trim(c.getString(titleIndex));
3581 
3582         Bitmap icon = iconInfo.loadIcon(c, info, context);
3583         // the fallback icon
3584         if (icon == null) {
3585             icon = mIconCache.getDefaultIcon(info.user);
3586             info.usingFallbackIcon = true;
3587         }
3588         info.setIcon(icon);
3589         return info;
3590     }
3591 
3592     ShortcutInfo infoFromShortcutIntent(Context context, Intent data) {
3593         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3594         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3595         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3596 
3597         if (intent == null) {
3598             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3599             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3600             return null;
3601         }
3602 
3603         Bitmap icon = null;
3604         boolean customIcon = false;
3605         ShortcutIconResource iconResource = null;
3606 
3607         if (bitmap instanceof Bitmap) {
3608             icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
3609             customIcon = true;
3610         } else {
3611             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3612             if (extra instanceof ShortcutIconResource) {
3613                 iconResource = (ShortcutIconResource) extra;
3614                 icon = Utilities.createIconBitmap(iconResource.packageName,
3615                         iconResource.resourceName, context);
3616             }
3617         }
3618 
3619         final ShortcutInfo info = new ShortcutInfo();
3620 
3621         // Only support intents for current user for now. Intents sent from other
3622         // users wouldn&#x27;t get here without intent forwarding anyway.
3623         info.user = UserHandleCompat.myUserHandle();
3624         if (icon == null) {
3625             icon = mIconCache.getDefaultIcon(info.user);
3626             info.usingFallbackIcon = true;
3627         }
3628         info.setIcon(icon);
3629 
3630         info.title = Utilities.trim(name);
3631         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3632         info.intent = intent;
3633         info.customIcon = customIcon;
3634         info.iconResource = iconResource;
3635 
3636         return info;
3637     }
3638 
3639     /**
3640      * Return an existing FolderInfo object if we have encountered this ID previously,
3641      * or make a new one.
3642      */
3643     @Thunk static FolderInfo findOrMakeFolder(LongArrayMap&lt;FolderInfo&gt; folders, long id) {
3644         // See if a placeholder was created for us already
3645         FolderInfo folderInfo = folders.get(id);
3646         if (folderInfo == null) {
3647             // No placeholder -- create a new instance
3648             folderInfo = new FolderInfo();
3649             folders.put(id, folderInfo);
3650         }
3651         return folderInfo;
3652     }
3653 
3654 
3655     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3656         return (provider != null) &amp;&amp; (provider.provider != null)
3657                 &amp;&amp; (provider.provider.getPackageName() != null);
3658     }
3659 
3660     public void dumpState() {
3661         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3662         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3663         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3664         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3665         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3666         if (mLoaderTask != null) {
3667             mLoaderTask.dumpState();
3668         } else {
3669             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3670         }
3671     }
3672 
3673     public Callbacks getCallback() {
3674         return mCallbacks != null ? mCallbacks.get() : null;
3675     }
3676 
3677     /**
3678      * @return {@link FolderInfo} if its already loaded.
3679      */
3680     public FolderInfo findFolderById(Long folderId) {
3681         synchronized (sBgLock) {
3682             return sBgFolders.get(folderId);
3683         }
3684     }
3685 
3686     /**
3687      * @return the looper for the worker thread which can be used to start background tasks.
3688      */
3689     public static Looper getWorkerLooper() {
3690         return sWorkerThread.getLooper();
3691     }
3692 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetProviderInfo;
  20 import android.content.BroadcastReceiver;
  21 import android.content.ComponentName;
  22 import android.content.ContentProviderOperation;
  23 import android.content.ContentResolver;
  24 import android.content.ContentValues;
  25 import android.content.Context;
  26 import android.content.Intent.ShortcutIconResource;
  27 import android.content.Intent;
  28 import android.content.IntentFilter;
  29 import android.content.pm.PackageManager;
  30 import android.content.pm.ProviderInfo;
  31 import android.content.pm.ResolveInfo;
  32 import android.database.Cursor;
  33 import android.graphics.Bitmap;
  34 import android.net.Uri;
  35 import android.os.Build;
  36 import android.os.Environment;
  37 import android.os.Handler;
  38 import android.os.HandlerThread;
  39 import android.os.Looper;
  40 import android.os.Parcelable;
  41 import android.os.Process;
  42 import android.os.SystemClock;
  43 import android.os.TransactionTooLargeException;
  44 import android.provider.BaseColumns;
  45 import android.text.TextUtils;
  46 import android.util.Log;
  47 import android.util.LongSparseArray;
  48 import android.util.Pair;
  49 import com.android.launcher3.compat.AppWidgetManagerCompat;
  50 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  51 import com.android.launcher3.compat.LauncherAppsCompat;
  52 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  53 import com.android.launcher3.compat.PackageInstallerCompat;
  54 import com.android.launcher3.compat.UserHandleCompat;
  55 import com.android.launcher3.compat.UserManagerCompat;
  56 import com.android.launcher3.model.WidgetsModel;
  57 import com.android.launcher3.util.ComponentKey;
  58 import com.android.launcher3.util.CursorIconInfo;
  59 import com.android.launcher3.util.LongArrayMap;
  60 import com.android.launcher3.util.ManagedProfileHeuristic;
  61 import com.android.launcher3.util.Thunk;
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.util.ArrayList;
  66 import java.util.Arrays;
  67 import java.util.Collection;
  68 import java.util.Collections;
  69 import java.util.Comparator;
  70 import java.util.HashMap;
  71 import java.util.HashSet;
  72 import java.util.Iterator;
  73 import java.util.List;
  74 import java.util.Map.Entry;
  75 import java.util.Set;
  76 
  77 
  78 /**
  79  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  80  * LauncherModel object held in a static. Also provide APIs for updating the database state
  81  * for the Launcher.
  82  */
<abbr title="  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackCompat {">  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackC🔵</abbr>
  84     static final boolean DEBUG_LOADERS = false;
  85 
  86     private static final boolean DEBUG_RECEIVER = false;
  87 
  88     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  89 
  90     static final String TAG = &quot;Launcher.Model&quot;;
  91 
  92     public static final int LOADER_FLAG_NONE = 0;
  93 
  94     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  95 
  96     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  97 
  98     // batch size for the workspace icons
  99     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 100 
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     @Thunk
 104     final boolean mAppsCanBeOnRemoveableStorage;
 105 
 106     private final boolean mOldContentProviderExists;
 107 
 108     @Thunk
 109     final LauncherAppState mApp;
 110 
 111     @Thunk
 112     final Object mLock = new Object();
 113 
 114     @Thunk
 115     DeferredHandler mHandler = new DeferredHandler();
 116 
 117     @Thunk
 118     LoaderTask mLoaderTask;
 119 
 120     @Thunk
 121     boolean mIsLoaderTaskRunning;
 122 
 123     @Thunk
 124     boolean mHasLoaderCompletedOnce;
 125 
 126     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 127 
 128     @Thunk
 129     static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 130 
 131     static {
 132         sWorkerThread.start();
 133     }
 134 
 135     @Thunk
 136     static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 137 
 138     // We start off with everything not loaded.  After that, we assume that
 139     // our monitoring of the package manager provides all updates and we never
 140     // need to do a requery.  These are only ever touched from the loader thread.
 141     @Thunk
 142     boolean mWorkspaceLoaded;
 143 
 144     @Thunk
 145     boolean mAllAppsLoaded;
 146 
 147     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 148     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 149     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 150     // a normal load, we also clear this set of Runnables.
 151     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 152 
 153     /**
 154      * Set of runnables to be called on the background thread after the workspace binding
 155      * is complete.
 156      */
 157     static final ArrayList&lt;Runnable&gt; mBindCompleteRunnables = new ArrayList&lt;Runnable&gt;();
 158 
 159     @Thunk
 160     WeakReference&lt;Callbacks&gt; mCallbacks;
 161 
 162     // &lt; only access in worker thread &gt;
 163     // &lt; only access in worker thread &gt;
 164     AllAppsList mBgAllAppsList;
 165 
 166     // Entire list of widgets.
 167     // Entire list of widgets.
 168     WidgetsModel mBgWidgetsModel;
 169 
 170     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 171     // other locks, this one can generally be held long-term because we never expect any of these
 172     // static data structures to be referenced outside of the worker thread except on the first
 173     // load after configuration change.
 174     static final Object sBgLock = new Object();
 175 
 176     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 177     // LauncherModel to their ids
 178     static final LongArrayMap&lt;ItemInfo&gt; sBgItemsIdMap = new LongArrayMap&lt;&gt;();
 179 
 180     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 181     // created by LauncherModel that are directly on the home screen (however, no widgets or
 182     // shortcuts within folders).
 183     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 184 
 185     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 186     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 187     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 188         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 189 
 190     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 191     static final LongArrayMap&lt;FolderInfo&gt; sBgFolders = new LongArrayMap&lt;&gt;();
 192 
 193     // sBgWorkspaceScreens is the ordered set of workspace screens.
 194     // sBgWorkspaceScreens is the ordered set of workspace screens.
 195     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 196 
 197     // sBgWidgetProviders is the set of widget providers including custom internal widgets
 198     public static HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; sBgWidgetProviders;
 199 
 200     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
<abbr title=" 201     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();"> 201     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleComp🔵</abbr>
 202 
 203     // &lt;/ only access in worker thread &gt;
 204     @Thunk
 205     IconCache mIconCache;
 206 
 207     @Thunk
 208     final LauncherAppsCompat mLauncherApps;
 209 
 210     @Thunk
 211     final UserManagerCompat mUserManager;
 212 
 213     public interface Callbacks {
 214         public boolean setLoadOnResume();
 215 
 216         public int getCurrentWorkspaceScreen();
 217 
 218         public void startBinding();
 219 
 220         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 221                               boolean forceAnimateIcons);
 222 
 223         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 224 
 225         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 226 
 227         public abstract void bindFolders(LongArrayMap&lt;FolderInfo&gt; folders);
 228 
 229         public abstract void finishBindingItems();
 230 
 231         public void bindAppWidget(LauncherAppWidgetInfo info);
 232 
 233         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 234 
 235         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 236                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 237                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 238                                   ArrayList&lt;AppInfo&gt; addedApps);
 239 
 240         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 241 
 242         public void bindShortcutsChanged(ArrayList&lt;ShortcutInfo&gt; updated,
 243                 ArrayList&lt;ShortcutInfo&gt; removed, UserHandleCompat user);
 244 
 245         public void bindWidgetsRestored(ArrayList&lt;LauncherAppWidgetInfo&gt; widgets);
 246 
 247         public abstract void bindRestoreItemsChange(HashSet&lt;ItemInfo&gt; updates);
 248 
 249         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 250                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 251 
 252         public abstract void bindAllPackages(WidgetsModel model);
 253 
 254         public void bindSearchablesChanged();
 255 
 256         public boolean isAllAppsButtonRank(int rank);
 257 
 258         public void onPageBoundSynchronously(int page);
 259 
 260         public void dumpLogsToLocalData();
 261     }
 262 
 263     public interface ItemInfoFilter {
 264         public abstract boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 265     }
 266 
 267     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 268         Context context = app.getContext();
 269         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 270         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 271         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 272         // resource string.
 273         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
<abbr title=" 274         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);"> 274         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY,🔵</abbr>
<abbr title=" 275         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthority, 0);"> 275         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthor🔵</abbr>
 276         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 277         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 278         if (mOldContentProviderExists) {
 279             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 280         } else {
 281             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 282         }
 283         mApp = app;
 284         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 285         mBgWidgetsModel = new WidgetsModel(context, iconCache, appFilter);
 286         mIconCache = iconCache;
 287         mLauncherApps = LauncherAppsCompat.getInstance(context);
 288         mUserManager = UserManagerCompat.getInstance(context);
 289     }
 290 
 291     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 292      * posted on the main thread handler. */
 293     @Thunk
 294     void runOnMainThread(Runnable r) {
 295         if (sWorkerThread.getThreadId() == Process.myTid()) {
 296             // If we are on the worker thread, post onto the main handler
 297             mHandler.post(r);
 298         } else {
 299             r.run();
 300         }
 301     }
 302 
 303     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 304      * posted on the worker thread handler. */
 305     private static void runOnWorkerThread(Runnable r) {
 306         if (sWorkerThread.getThreadId() == Process.myTid()) {
 307             r.run();
 308         } else {
 309             // If we are not on the worker thread, then post to the worker handler
 310             sWorker.post(r);
 311         }
 312     }
 313 
 314     /**
 315      * Runs the specified runnable after the loader is complete
 316      */
 317     @Thunk
 318     void runAfterBindCompletes(Runnable r) {
 319         if (isLoadingWorkspace() || (!mHasLoaderCompletedOnce)) {
 320             synchronized(mBindCompleteRunnables) {
 321                 mBindCompleteRunnables.add(r);
 322             }
 323         } else {
 324             runOnWorkerThread(r);
 325         }
 326     }
 327 
 328     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 329         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 330     }
 331 
 332     public void setPackageState(final PackageInstallInfo installInfo) {
 333         Runnable updateRunnable = new Runnable() {
 334             @Override
 335             public void run() {
 336                 synchronized(sBgLock) {
 337                     final HashSet&lt;ItemInfo&gt; updates = new HashSet&lt;&gt;();
 338                     if (installInfo.state == PackageInstallerCompat.STATUS_INSTALLED) {
 339                         // Ignore install success events as they are handled by Package add events.
 340                         return;
 341                     }
 342                     for (ItemInfo info : sBgItemsIdMap) {
 343                         if (info instanceof ShortcutInfo) {
 344                             ShortcutInfo si = ((ShortcutInfo) (info));
 345                             ComponentName cn = si.getTargetComponent();
<abbr title=" 346                             if ((si.isPromise() &amp;&amp; (cn != null)) &amp;&amp; installInfo.packageName.equals(cn.getPackageName())) {"> 346                             if ((si.isPromise() &amp;&amp; (cn != null)) &amp;&amp; installInfo.packageName.equals(cn.get🔵</abbr>
 347                                 si.setInstallProgress(installInfo.progress);
 348                                 if (installInfo.state == PackageInstallerCompat.STATUS_FAILED) {
 349                                     // Mark this info as broken.
 350                                     si.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
 351                                 }
 352                                 updates.add(si);
 353                             }
 354                         }
 355                     }
 356                     for (LauncherAppWidgetInfo widget : sBgAppWidgets) {
 357                         if (widget.providerName.getPackageName().equals(installInfo.packageName)) {
 358                             widget.installProgress = installInfo.progress;
 359                             updates.add(widget);
 360                         }
 361                     }
 362                     if (!updates.isEmpty()) {
 363                         // Push changes to the callback.
 364                         Runnable r = new Runnable() {
 365                             public void run() {
 366                                 Callbacks callbacks = getCallback();
 367                                 if (callbacks != null) {
 368                                     callbacks.bindRestoreItemsChange(updates);
 369                                 }
 370                             }
 371                         };
 372                         mHandler.post(r);
 373                     }
 374                 }
 375             }
 376         };
 377         runOnWorkerThread(updateRunnable);
 378     }
 379 
 380     /**
 381      * Updates the icons and label of all pending icons for the provided package name.
 382      */
 383     public void updateSessionDisplayInfo(final String packageName) {
 384         Runnable updateRunnable = new Runnable() {
 385             @Override
 386             public void run() {
 387                 synchronized(sBgLock) {
 388                     final ArrayList&lt;ShortcutInfo&gt; updates = new ArrayList&lt;&gt;();
 389                     final UserHandleCompat user = UserHandleCompat.myUserHandle();
 390                     for (ItemInfo info : sBgItemsIdMap) {
 391                         if (info instanceof ShortcutInfo) {
 392                             ShortcutInfo si = ((ShortcutInfo) (info));
 393                             ComponentName cn = si.getTargetComponent();
<abbr title=" 394                             if ((si.isPromise() &amp;&amp; (cn != null)) &amp;&amp; packageName.equals(cn.getPackageName())) {"> 394                             if ((si.isPromise() &amp;&amp; (cn != null)) &amp;&amp; packageName.equals(cn.getPackageName(🔵</abbr>
 395                                 if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
 396                                     // For auto install apps update the icon as well as label.
<abbr title=" 397                                     mIconCache.getTitleAndIcon(si, si.promisedIntent, user, si.shouldUseLowResIcon());"> 397                                     mIconCache.getTitleAndIcon(si, si.promisedIntent, user, si.shouldUseL🔵</abbr>
 398                                 } else {
 399                                     // Only update the icon for restored apps.
 400                                     si.updateIcon(mIconCache);
 401                                 }
 402                                 updates.add(si);
 403                             }
 404                         }
 405                     }
 406                     if (!updates.isEmpty()) {
 407                         // Push changes to the callback.
 408                         Runnable r = new Runnable() {
 409                             public void run() {
 410                                 Callbacks callbacks = getCallback();
 411                                 if (callbacks != null) {
<abbr title=" 412                                     callbacks.bindShortcutsChanged(updates, new ArrayList&lt;ShortcutInfo&gt;(), user);"> 412                                     callbacks.bindShortcutsChanged(updates, new ArrayList&lt;ShortcutInfo&gt;()🔵</abbr>
 413                                 }
 414                             }
 415                         };
 416                         mHandler.post(r);
 417                     }
 418                 }
 419             }
 420         };
 421         runOnWorkerThread(updateRunnable);
 422     }
 423 
 424     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 425         final Callbacks callbacks = getCallback();
 426         if (allAppsApps == null) {
 427             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 428         }
 429         if (allAppsApps.isEmpty()) {
 430             return;
 431         }
 432         // Process the newly added applications and add them to the database first
 433         Runnable r = new Runnable() {
 434             public void run() {
 435                 runOnMainThread(new Runnable() {
 436                     public void run() {
 437                         Callbacks cb = getCallback();
 438                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
 439                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 440                         }
 441                     }
 442                 });
 443             }
 444         };
 445         runOnWorkerThread(r);
 446     }
 447 
<abbr title=" 448     private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; occupiedPos, int[] xy, int spanX, int spanY) {"> 448     private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; occupiedPos, int[] xy, 🔵</abbr>
 449         LauncherAppState app = LauncherAppState.getInstance();
 450         InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
 451         final int xCount = ((int) (profile.numColumns));
 452         final int yCount = ((int) (profile.numRows));
 453         boolean[][] occupied = new boolean[xCount][yCount];
 454         if (occupiedPos != null) {
 455             for (ItemInfo r : occupiedPos) {
 456                 int right = r.cellX + r.spanX;
 457                 int bottom = r.cellY + r.spanY;
 458                 for (int x = r.cellX; ((0 &lt;= x) &amp;&amp; (x &lt; right)) &amp;&amp; (x &lt; xCount); x++) {
 459                     for (int y = r.cellY; ((0 &lt;= y) &amp;&amp; (y &lt; bottom)) &amp;&amp; (y &lt; yCount); y++) {
 460                         occupied[x][y] = true;
 461                     }
 462                 }
 463             }
 464         }
 465         return Utilities.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);
 466     }
 467 
 468     /**
 469      * Find a position on the screen for the given size or adds a new screen.
 470      * @return screenId and the coordinates for the item.
 471      */
 472     @Thunk
<abbr title=" 473     Pair&lt;Long, int[]&gt; findSpaceForItem(Context context, ArrayList&lt;Long&gt; workspaceScreens, ArrayList&lt;Long&gt; addedWorkspaceScreensFinal, int spanX, int spanY) {"> 473     Pair&lt;Long, int[]&gt; findSpaceForItem(Context context, ArrayList&lt;Long&gt; workspaceScreens, ArrayList&lt;Long&gt;🔵</abbr>
 474         LongSparseArray&lt;ArrayList&lt;ItemInfo&gt;&gt; screenItems = new LongSparseArray&lt;&gt;();
 475         // Use sBgItemsIdMap as all the items are already loaded.
 476         assertWorkspaceLoaded();
 477         synchronized(sBgLock) {
 478             for (ItemInfo info : sBgItemsIdMap) {
 479                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 480                     ArrayList&lt;ItemInfo&gt; items = screenItems.get(info.screenId);
 481                     if (items == null) {
 482                         items = new ArrayList&lt;&gt;();
 483                         screenItems.put(info.screenId, items);
 484                     }
 485                     items.add(info);
 486                 }
 487             }
 488         }
 489         // Find appropriate space for the item.
 490         long screenId = 0;
 491         int[] cordinates = new int[2];
 492         boolean found = false;
 493         int screenCount = workspaceScreens.size();
 494         // First check the preferred screen.
 495         int preferredScreenIndex = (workspaceScreens.isEmpty()) ? 0 : 1;
 496         if (preferredScreenIndex &lt; screenCount) {
 497             screenId = workspaceScreens.get(preferredScreenIndex);
<abbr title=" 498             found = findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY);"> 498             found = findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, span🔵</abbr>
 499         }
 500         if (!found) {
 501             // Search on any of the screens starting from the first screen.
 502             for (int screen = 1; screen &lt; screenCount; screen++) {
 503                 screenId = workspaceScreens.get(screen);
<abbr title=" 504                 if (findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY)) {"> 504                 if (findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, span🔵</abbr>
 505                     // We found a space for it
 506                     found = true;
 507                     break;
 508                 }
 509             }
 510         }
 511         if (!found) {
 512             // Still no position found. Add a new screen to the end.
 513             screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 514             // Save the screen id for binding in the workspace
 515             workspaceScreens.add(screenId);
 516             addedWorkspaceScreensFinal.add(screenId);
 517             // If we still can&#x27;t find an empty space, then God help us all!!!
<abbr title=" 518             if (!findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY)) {"> 518             if (!findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY))🔵</abbr>
 519                 throw new RuntimeException(&quot;Can&#x27;t find space to add the item&quot;);
 520             }
 521         }
 522         return Pair.create(screenId, cordinates);
 523     }
 524 
 525     /**
 526      * Adds the provided items to the workspace.
 527      */
<abbr title=" 528     public void addAndBindAddedWorkspaceItems(final Context context, final ArrayList&lt;? extends ItemInfo&gt; workspaceApps) {"> 528     public void addAndBindAddedWorkspaceItems(final Context context, final ArrayList&lt;? extends ItemInfo&gt; 🔵</abbr>
 529         final Callbacks callbacks = getCallback();
 530         if (workspaceApps.isEmpty()) {
 531             return;
 532         }
 533         // Process the newly added applications and add them to the database first
 534         Runnable r = new Runnable() {
 535             public void run() {
 536                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 537                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 538                 // Get the list of workspace screens.  We need to append to this list and
 539                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 540                 // called.
 541                 ArrayList&lt;Long&gt; workspaceScreens = loadWorkspaceScreensDb(context);
 542                 synchronized(sBgLock) {
 543                     for (ItemInfo item : workspaceApps) {
 544                         if (item instanceof ShortcutInfo) {
 545                             // Short-circuit this logic if the icon exists somewhere on the workspace
 546                             if (shortcutExists(context, item.getIntent(), item.user)) {
 547                                 continue;
 548                             }
 549                         }
 550                         // Find appropriate space for the item.
<abbr title=" 551                         Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, workspaceScreens, addedWorkspaceScreensFinal, 1, 1);"> 551                         Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, workspaceScreens, addedWorks🔵</abbr>
 552                         long screenId = coords.first;
 553                         int[] cordinates = coords.second;
 554                         ItemInfo itemInfo;
 555                         if ((item instanceof ShortcutInfo) || (item instanceof FolderInfo)) {
 556                             itemInfo = item;
 557                         } else if (item instanceof AppInfo) {
 558                             itemInfo = ((AppInfo) (item)).makeShortcut();
 559                         } else {
 560                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 561                         }
 562                         // Add the shortcut to the db
<abbr title=" 563                         addItemToDatabase(context, itemInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP, screenId, cordinates[0], cordinates[1]);"> 563                         addItemToDatabase(context, itemInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP🔵</abbr>
 564                         // Save the ShortcutInfo for binding in the workspace
 565                         addedShortcutsFinal.add(itemInfo);
 566                     }
 567                 }
 568                 // Update the workspace screens
 569                 updateWorkspaceScreenOrder(context, workspaceScreens);
 570                 if (!addedShortcutsFinal.isEmpty()) {
 571                     runOnMainThread(new Runnable() {
 572                         public void run() {
 573                             Callbacks cb = getCallback();
 574                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
 575                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 576                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 577                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 578                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 578                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 579                                     long lastScreenId = info.screenId;
 580                                     for (ItemInfo i : addedShortcutsFinal) {
 581                                         if (i.screenId == lastScreenId) {
 582                                             addAnimated.add(i);
 583                                         } else {
 584                                             addNotAnimated.add(i);
 585                                         }
 586                                     }
 587                                 }
<abbr title=" 588                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAnimated, null);"> 588                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAn🔵</abbr>
 589                             }
 590                         }
 591                     });
 592                 }
 593             }
 594         };
 595         runOnWorkerThread(r);
 596     }
 597 
 598     private void unbindItemInfosAndClearQueuedBindRunnables() {
 599         if (sWorkerThread.getThreadId() == Process.myTid()) {
<abbr title=" 600             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;main thread&quot;);"> 600             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;mai🔵</abbr>
 601         }
 602         // Clear any deferred bind runnables
 603         synchronized(mDeferredBindRunnables) {
 604             mDeferredBindRunnables.clear();
 605         }
 606         // Remove any queued UI runnables
 607         mHandler.cancelAll();
 608         // Unbind all the workspace items
 609         unbindWorkspaceItemsOnMainThread();
 610     }
 611 
 612     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 613     void unbindWorkspaceItemsOnMainThread() {
 614         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 615         // by making a copy of workspace items first.
 616         final ArrayList&lt;ItemInfo&gt; tmpItems = new ArrayList&lt;ItemInfo&gt;();
 617         synchronized(sBgLock) {
 618             tmpItems.addAll(sBgWorkspaceItems);
 619             tmpItems.addAll(sBgAppWidgets);
 620         }
 621         Runnable r = new Runnable() {
 622             @Override
 623             public void run() {
 624                 for (ItemInfo item : tmpItems) {
 625                     item.unbind();
 626                 }
 627             }
 628         };
 629         runOnMainThread(r);
 630     }
 631 
 632     /**
 633      * Adds an item to the DB if it was not created previously, or move it to a new
 634      * &lt;container, screen, cellX, cellY&gt;
 635      */
<abbr title=" 636     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, int cellX, int cellY) {"> 636     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, in🔵</abbr>
 637         if (item.container == ItemInfo.NO_ID) {
 638             // From all apps
 639             addItemToDatabase(context, item, container, screenId, cellX, cellY);
 640         } else {
 641             // From somewhere else
 642             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 643         }
 644     }
 645 
<abbr title=" 646     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {"> 646     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrac🔵</abbr>
 647         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 648         if ((modelItem != null) &amp;&amp; (item != modelItem)) {
 649             // check all the data is consistent
 650             if ((modelItem instanceof ShortcutInfo) &amp;&amp; (item instanceof ShortcutInfo)) {
 651                 ShortcutInfo modelShortcut = ((ShortcutInfo) (modelItem));
 652                 ShortcutInfo shortcut = ((ShortcutInfo) (item));
<abbr title=" 653                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelShortcut.intent.filterEquals(shortcut.intent)) &amp;&amp; (modelShortcut.id == shortcut.id)) &amp;&amp; (modelShortcut.itemType == shortcut.itemType)) &amp;&amp; (modelShortcut.container == shortcut.container)) &amp;&amp; (modelShortcut.screenId == shortcut.screenId)) &amp;&amp; (modelShortcut.cellX == shortcut.cellX)) &amp;&amp; (modelShortcut.cellY == shortcut.cellY)) &amp;&amp; (modelShortcut.spanX == shortcut.spanX)) &amp;&amp; (modelShortcut.spanY == shortcut.spanY)) &amp;&amp; (((modelShortcut.dropPos == null) &amp;&amp; (shortcut.dropPos == null)) || ((((modelShortcut.dropPos != null) &amp;&amp; (shortcut.dropPos != null)) &amp;&amp; (modelShortcut.dropPos[0] == shortcut.dropPos[0])) &amp;&amp; (modelShortcut.dropPos[1] == shortcut.dropPos[1])))) {"> 653                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelSho🔵</abbr>
 654                     // For all intents and purposes, this is the same object
 655                     return;
 656                 }
 657             }
 658             // the modelItem needs to match up perfectly with item if our model is
 659             // to be consistent with the database-- for now, just require
 660             // modelItem == item or the equality check above
<abbr title=" 661             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (modelItem != null ? modelItem.toString() : &quot;null&quot;)) + &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;"> 661             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (mod🔵</abbr>
 662             RuntimeException e = new RuntimeException(msg);
 663             if (stackTrace != null) {
 664                 e.setStackTrace(stackTrace);
 665             }
 666             throw e;
 667         }
 668     }
 669 
 670     static void checkItemInfo(final ItemInfo item) {
 671         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 672         final long itemId = item.id;
 673         Runnable r = new Runnable() {
 674             public void run() {
 675                 synchronized (sBgLock) {
 676                     checkItemInfoLocked(itemId, item, stackTrace);
 677                 }
 678             }
 679         };
 680         runOnWorkerThread(r);
 681     }
 682 
<abbr title=" 683     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo item, final String callingFunction) {"> 683     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo it🔵</abbr>
 684         final long itemId = item.id;
 685         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 686         final ContentResolver cr = context.getContentResolver();
 687         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 688         Runnable r = new Runnable() {
 689             public void run() {
 690                 cr.update(uri, values, null, null);
 691                 updateItemArrays(item, itemId, stackTrace);
 692             }
 693         };
 694         runOnWorkerThread(r);
 695     }
 696 
<abbr title=" 697     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {"> 697     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, f🔵</abbr>
 698         final ContentResolver cr = context.getContentResolver();
 699         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 700         Runnable r = new Runnable() {
 701             public void run() {
 702                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
 703                 int count = items.size();
 704                 for (int i = 0; i &lt; count; i++) {
 705                     ItemInfo item = items.get(i);
 706                     final long itemId = item.id;
 707                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);
 708                     ContentValues values = valuesList.get(i);
 709                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 710                     updateItemArrays(item, itemId, stackTrace);
 711                 }
 712                 try {
 713                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 714                 } catch (java.lang.Exception e) {
 715                     e.printStackTrace();
 716                 }
 717             }
 718         };
 719         runOnWorkerThread(r);
 720     }
 721 
 722     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 723         // Lock on mBgLock *after* the db operation
 724         synchronized(sBgLock) {
 725             checkItemInfoLocked(itemId, item, stackTrace);
<abbr title=" 726             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 726             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != La🔵</abbr>
 727                 // Item is in a folder, make sure this folder exists
 728                 if (!sBgFolders.containsKey(item.container)) {
 729                     // An items container is being set to a that of an item which is not in
 730                     // the list of Folders.
<abbr title=" 731                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;, not in the list of folders&quot;;"> 731                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;🔵</abbr>
 732                     Log.e(TAG, msg);
 733                 }
 734             }
 735             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 736             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 737             // that are on the desktop, as appropriate
 738             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
<abbr title=" 739             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT))) {"> 739             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESK🔵</abbr>
 740                 switch (modelItem.itemType) {
 741                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 742                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
 743                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 744                         if (!sBgWorkspaceItems.contains(modelItem)) {
 745                             sBgWorkspaceItems.add(modelItem);
 746                         }
 747                         break;
 748                     default :
 749                         break;
 750                 }
 751             } else {
 752                 sBgWorkspaceItems.remove(modelItem);
 753             }
 754         }
 755     }
 756 
 757     /**
 758      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 759      */
<abbr title=" 760     public static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY) {"> 760     public static void moveItemInDatabase(Context context, final ItemInfo item, final long container, fin🔵</abbr>
 761         item.container = container;
 762         item.cellX = cellX;
 763         item.cellY = cellY;
 764         // We store hotseat items in canonical form which is this orientation invariant position
 765         // in the hotseat
<abbr title=" 766         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 766         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites🔵</abbr>
 767             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 768         } else {
 769             item.screenId = screenId;
 770         }
 771         final ContentValues values = new ContentValues();
 772         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 773         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 774         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 775         values.put(LauncherSettings.Favorites.RANK, item.rank);
 776         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 777         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 778     }
 779 
 780     /**
 781      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 782      * cellX, cellY have already been updated on the ItemInfos.
 783      */
 784     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 785             final long container, final int screen) {
 786 
 787         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 788         int count = items.size();
 789 
 790         for (int i = 0; i &lt; count; i++) {
 791             ItemInfo item = items.get(i);
 792             item.container = container;
 793 
 794             // We store hotseat items in canonical form which is this orientation invariant position
 795             // in the hotseat
 796             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 797                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 798                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 799                         item.cellY);
 800             } else {
 801                 item.screenId = screen;
 802             }
 803 
 804             final ContentValues values = new ContentValues();
 805             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 806             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 807             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 808             values.put(LauncherSettings.Favorites.RANK, item.rank);
 809             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 810 
 811             contentValues.add(values);
 812         }
 813         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 814     }
 815 
 816     /**
 817      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 818      */
 819     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 820             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 821         item.container = container;
 822         item.cellX = cellX;
 823         item.cellY = cellY;
 824         item.spanX = spanX;
 825         item.spanY = spanY;
 826 
 827         // We store hotseat items in canonical form which is this orientation invariant position
 828         // in the hotseat
 829         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 830                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 831             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 832         } else {
 833             item.screenId = screenId;
 834         }
 835 
 836         final ContentValues values = new ContentValues();
 837         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 838         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 839         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 840         values.put(LauncherSettings.Favorites.RANK, item.rank);
 841         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 842         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 843         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 844 
 845         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 846     }
 847 
 848     /**
 849      * Update an item to the database in a specified container.
 850      */
 851     public static void updateItemInDatabase(Context context, final ItemInfo item) {
 852         final ContentValues values = new ContentValues();
 853         item.onAddToDatabase(context, values);
 854         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 855     }
 856 
 857     private void assertWorkspaceLoaded() {
 858         if (LauncherAppState.isDogfoodBuild() &amp;&amp; (isLoadingWorkspace() || !mHasLoaderCompletedOnce)) {
 859             throw new RuntimeException(&quot;Trying to add shortcut while loader is running&quot;);
 860         }
 861     }
 862 
 863     /**
 864      * Returns true if the shortcuts already exists on the workspace. This must be called after
 865      * the workspace has been loaded. We identify a shortcut by its intent.
 866      */
 867     @Thunk
 868     boolean shortcutExists(Context context, Intent intent, UserHandleCompat user) {
 869         assertWorkspaceLoaded();
 870         final String intentWithPkg;
 871         final String intentWithoutPkg;
 872         if (intent.getComponent() != null) {
 873             // If component is not null, an intent with null package will produce
 874             // the same result and should also be a match.
 875             String packageName = intent.getComponent().getPackageName();
 876             if (intent.getPackage() != null) {
 877                 intentWithPkg = intent.toUri(0);
 878                 intentWithoutPkg = new Intent(intent).setPackage(null).toUri(0);
 879             } else {
 880                 intentWithPkg = new Intent(intent).setPackage(packageName).toUri(0);
 881                 intentWithoutPkg = intent.toUri(0);
 882             }
 883         } else {
 884             intentWithPkg = intent.toUri(0);
 885             intentWithoutPkg = intent.toUri(0);
 886         }
 887         synchronized(sBgLock) {
 888             for (ItemInfo item : sBgItemsIdMap) {
 889                 if (item instanceof ShortcutInfo) {
 890                     ShortcutInfo info = ((ShortcutInfo) (item));
<abbr title=" 891                     Intent targetIntent = (info.promisedIntent == null) ? info.intent : info.promisedIntent;"> 891                     Intent targetIntent = (info.promisedIntent == null) ? info.intent : info.promisedInte🔵</abbr>
 892                     if ((targetIntent != null) &amp;&amp; info.user.equals(user)) {
 893                         String s = targetIntent.toUri(0);
 894                         if (intentWithPkg.equals(s) || intentWithoutPkg.equals(s)) {
 895                             return true;
 896                         }
 897                     }
 898                 }
 899             }
 900         }
 901         return false;
 902     }
 903 
 904     /**
 905      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 906      */
 907     FolderInfo getFolderById(Context context, LongArrayMap&lt;FolderInfo&gt; folderList, long id) {
 908         final ContentResolver cr = context.getContentResolver();
<abbr title=" 909         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemType=?)&quot;, new String[]{ String.valueOf(id), String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER) }, null);"> 909         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemT🔵</abbr>
 910         try {
 911             if (c.moveToFirst()) {
 912                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 913                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 914                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 915                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 916                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 917                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 918                 final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);
 919                 FolderInfo folderInfo = null;
 920                 switch (c.getInt(itemTypeIndex)) {
 921                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 922                         folderInfo = findOrMakeFolder(folderList, id);
 923                         break;
 924                 }
 925                 // Do not trim the folder label, as is was set by the user.
 926                 folderInfo.title = c.getString(titleIndex);
 927                 folderInfo.id = id;
 928                 folderInfo.container = c.getInt(containerIndex);
 929                 folderInfo.screenId = c.getInt(screenIndex);
 930                 folderInfo.cellX = c.getInt(cellXIndex);
 931                 folderInfo.cellY = c.getInt(cellYIndex);
 932                 folderInfo.options = c.getInt(optionsIndex);
 933                 return folderInfo;
 934             }
 935         } finally {
 936             c.close();
 937         }
 938         return null;
 939     }
 940 
 941     /**
 942      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 943      * cellY fields of the item. Also assigns an ID to the item.
 944      */
<abbr title=" 945     public static void addItemToDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY) {"> 945     public static void addItemToDatabase(Context context, final ItemInfo item, final long container, fina🔵</abbr>
 946         item.container = container;
 947         item.cellX = cellX;
 948         item.cellY = cellY;
 949         // We store hotseat items in canonical form which is this orientation invariant position
 950         // in the hotseat
<abbr title=" 951         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 951         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites🔵</abbr>
 952             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 953         } else {
 954             item.screenId = screenId;
 955         }
 956         final ContentValues values = new ContentValues();
 957         final ContentResolver cr = context.getContentResolver();
 958         item.onAddToDatabase(context, values);
 959         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 960         values.put(LauncherSettings.Favorites._ID, item.id);
 961         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 962         Runnable r = new Runnable() {
 963             public void run() {
 964                 cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);
 965                 // Lock on mBgLock *after* the db operation
 966                 synchronized(sBgLock) {
 967                     checkItemInfoLocked(item.id, item, stackTrace);
 968                     sBgItemsIdMap.put(item.id, item);
 969                     switch (item.itemType) {
 970                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 971                             sBgFolders.put(item.id, ((FolderInfo) (item)));
 972                             // Fall through
 973                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 974                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
<abbr title=" 975                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 975                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item🔵</abbr>
 976                                 sBgWorkspaceItems.add(item);
 977                             } else if (!sBgFolders.containsKey(item.container)) {
 978                                 // Adding an item to a folder that doesn&#x27;t exist.
<abbr title=" 979                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;t exist&quot;;"> 979                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;🔵</abbr>
 980                                 Log.e(TAG, msg);
 981                             }
 982                             break;
 983                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
 984                             sBgAppWidgets.add(((LauncherAppWidgetInfo) (item)));
 985                             break;
 986                     }
 987                 }
 988             }
 989         };
 990         runOnWorkerThread(r);
 991     }
 992 
 993     /**
 994      * Creates a new unique child id, for a given cell span across all layouts.
 995      */
 996     static int getCellLayoutChildId(
 997             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
 998         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 999                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1000     }
1001 
<abbr title="1002     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user) {">1002     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user🔵</abbr>
1003         ItemInfoFilter filter = new ItemInfoFilter() {
1004             @Override
1005             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1006                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1007             }
1008         };
1009         return filterItemInfos(sBgItemsIdMap, filter);
1010     }
1011 
1012     /**
1013      * Removes all the items from the database corresponding to the specified package.
1014      */
1015     static void deletePackageFromDatabase(Context context, final String pn,
1016             final UserHandleCompat user) {
1017         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1018     }
1019 
1020     /**
1021      * Removes the specified item from the database
1022      * @param context
1023      * @param item
1024      */
1025     public static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1026         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1027         items.add(item);
1028         deleteItemsFromDatabase(context, items);
1029     }
1030 
1031     /**
1032      * Removes the specified items from the database
1033      * @param context
1034      * @param item
1035      */
1036     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;? extends ItemInfo&gt; items) {
1037         final ContentResolver cr = context.getContentResolver();
1038         Runnable r = new Runnable() {
1039             public void run() {
1040                 for (ItemInfo item : items) {
1041                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id);
1042                     cr.delete(uri, null, null);
1043                     // Lock on mBgLock *after* the db operation
1044                     synchronized(sBgLock) {
1045                         switch (item.itemType) {
1046                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1047                                 sBgFolders.remove(item.id);
1048                                 for (ItemInfo info : sBgItemsIdMap) {
1049                                     if (info.container == item.id) {
1050                                         // We are deleting a folder which still contains items that
1051                                         // think they are contained by that folder.
<abbr title="1052                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;) + &quot;contains items (&quot;) + info) + &quot;)&quot;;">1052                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;🔵</abbr>
1053                                         Log.e(TAG, msg);
1054                                     }
1055                                 }
1056                                 sBgWorkspaceItems.remove(item);
1057                                 break;
1058                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1059                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1060                                 sBgWorkspaceItems.remove(item);
1061                                 break;
1062                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1063                                 sBgAppWidgets.remove(((LauncherAppWidgetInfo) (item)));
1064                                 break;
1065                         }
1066                         sBgItemsIdMap.remove(item.id);
1067                     }
1068                 }
1069             }
1070         };
1071         runOnWorkerThread(r);
1072     }
1073 
1074     /**
1075      * Update the order of the workspace screens in the database. The array list contains
1076      * a list of screen ids in the order that they should appear.
1077      */
1078     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1079         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1080         final ContentResolver cr = context.getContentResolver();
1081         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1082         // Remove any negative screen ids -- these aren&#x27;t persisted
1083         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1084         while (iter.hasNext()) {
1085             long id = iter.next();
1086             if (id &lt; 0) {
1087                 iter.remove();
1088             }
1089         }
1090         Runnable r = new Runnable() {
1091             @Override
1092             public void run() {
1093                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1094                 // Clear the table
1095                 ops.add(ContentProviderOperation.newDelete(uri).build());
1096                 int count = screensCopy.size();
1097                 for (int i = 0; i &lt; count; i++) {
1098                     ContentValues v = new ContentValues();
1099                     long screenId = screensCopy.get(i);
1100                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1101                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1102                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1103                 }
1104                 try {
1105                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1106                 } catch (java.lang.Exception ex) {
1107                     throw new RuntimeException(ex);
1108                 }
1109                 synchronized(sBgLock) {
1110                     sBgWorkspaceScreens.clear();
1111                     sBgWorkspaceScreens.addAll(screensCopy);
1112                 }
1113             }
1114         };
1115         runOnWorkerThread(r);
1116     }
1117 
1118     /**
1119      * Remove the contents of the specified folder from the database
1120      */
1121     public static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1122         final ContentResolver cr = context.getContentResolver();
1123         Runnable r = new Runnable() {
1124             public void run() {
1125                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);
1126                 // Lock on mBgLock *after* the db operation
1127                 synchronized(sBgLock) {
1128                     sBgItemsIdMap.remove(info.id);
1129                     sBgFolders.remove(info.id);
1130                     sBgWorkspaceItems.remove(info);
1131                 }
<abbr title="1132                 cr.delete(LauncherSettings.Favorites.CONTENT_URI, (LauncherSettings.Favorites.CONTAINER + &quot;=&quot;) + info.id, null);">1132                 cr.delete(LauncherSettings.Favorites.CONTENT_URI, (LauncherSettings.Favorites.CONTAINER +🔵</abbr>
1133                 // Lock on mBgLock *after* the db operation
1134                 synchronized(sBgLock) {
1135                     for (ItemInfo childInfo : info.contents) {
1136                         sBgItemsIdMap.remove(childInfo.id);
1137                     }
1138                 }
1139             }
1140         };
1141         runOnWorkerThread(r);
1142     }
1143 
1144     /**
1145      * Set this as the current Launcher activity object for the loader.
1146      */
1147     public void initialize(Callbacks callbacks) {
1148         synchronized(mLock) {
1149             // Disconnect any of the callbacks and drawables associated with ItemInfos on the
1150             // workspace to prevent leaking Launcher activities on orientation change.
1151             unbindItemInfosAndClearQueuedBindRunnables();
1152             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1153         }
1154     }
1155 
1156     @Override
1157     public void onPackageChanged(String packageName, UserHandleCompat user) {
1158         int op = PackageUpdatedTask.OP_UPDATE;
1159         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1160                 user));
1161     }
1162 
1163     @Override
1164     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1165         int op = PackageUpdatedTask.OP_REMOVE;
1166         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1167                 user));
1168     }
1169 
1170     @Override
1171     public void onPackageAdded(String packageName, UserHandleCompat user) {
1172         int op = PackageUpdatedTask.OP_ADD;
1173         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1174                 user));
1175     }
1176 
1177     @Override
1178     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1179             boolean replacing) {
1180         if (!replacing) {
1181             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1182                     user));
1183             if (mAppsCanBeOnRemoveableStorage) {
1184                 // Only rebind if we support removable storage. It catches the
1185                 // case where
1186                 // apps on the external sd card need to be reloaded
1187                 startLoaderFromBackground();
1188             }
1189         } else {
1190             // If we are replacing then just update the packages in the list
1191             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1192                     packageNames, user));
1193         }
1194     }
1195 
1196     @Override
1197     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1198             boolean replacing) {
1199         if (!replacing) {
1200             enqueuePackageUpdated(new PackageUpdatedTask(
1201                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1202                     user));
1203         }
1204     }
1205 
1206     /**
1207      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1208      * ACTION_PACKAGE_CHANGED.
1209      */
1210     @Override
1211     public void onReceive(Context context, Intent intent) {
1212         if (DEBUG_RECEIVER) {
1213             Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1214         }
1215         final String action = intent.getAction();
1216         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1217             // If we have changed locale we need to clear out the labels in all apps/workspace.
1218             forceReload();
<abbr title="1219         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {">1219         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.IN🔵</abbr>
1220             Callbacks callbacks = getCallback();
1221             if (callbacks != null) {
1222                 callbacks.bindSearchablesChanged();
1223             }
<abbr title="1224         } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action) || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {">1224         } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action) || LauncherAppsCompat.A🔵</abbr>
1225             forceReload();
1226         }
1227     }
1228 
1229     void forceReload() {
1230         resetLoadedState(true, true);
1231 
1232         // Do this here because if the launcher activity is running it will be restarted.
1233         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1234         // to reload.
1235         startLoaderFromBackground();
1236     }
1237 
1238     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1239         synchronized(mLock) {
1240             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1241             // mWorkspaceLoaded to true later
1242             stopLoaderLocked();
1243             if (resetAllAppsLoaded) {
1244                 mAllAppsLoaded = false;
1245             }
1246             if (resetWorkspaceLoaded) {
1247                 mWorkspaceLoaded = false;
1248             }
1249         }
1250     }
1251 
1252     /**
1253      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1254      * configuration changes.  So whenever we trigger the loader from the background
1255      * tell the launcher that it needs to re-run the loader when it comes back instead
1256      * of doing it now.
1257      */
1258     public void startLoaderFromBackground() {
1259         boolean runLoader = false;
1260         Callbacks callbacks = getCallback();
1261         if (callbacks != null) {
1262             // Only actually run the loader if they&#x27;re not paused.
1263             if (!callbacks.setLoadOnResume()) {
1264                 runLoader = true;
1265             }
1266         }
1267         if (runLoader) {
1268             startLoader(PagedView.INVALID_RESTORE_PAGE);
1269         }
1270     }
1271 
1272     /**
1273      * If there is already a loader task running, tell it to stop.
1274      */
1275     private void stopLoaderLocked() {
1276         LoaderTask oldTask = mLoaderTask;
1277         if (oldTask != null) {
1278             oldTask.stopLocked();
1279         }
1280     }
1281 
1282     public boolean isCurrentCallbacks(Callbacks callbacks) {
1283         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1284     }
1285 
1286     public void startLoader(int synchronousBindPage) {
1287         startLoader(synchronousBindPage, LOADER_FLAG_NONE);
1288     }
1289 
1290     public void startLoader(int synchronousBindPage, int loadFlags) {
1291         // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems
1292         InstallShortcutReceiver.enableInstallQueue();
1293         synchronized(mLock) {
1294             // Clear any deferred bind-runnables from the synchronized load process
1295             // We must do this before any loading/binding is scheduled below.
1296             synchronized(mDeferredBindRunnables) {
1297                 mDeferredBindRunnables.clear();
1298             }
1299             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1300             if ((mCallbacks != null) &amp;&amp; (mCallbacks.get() != null)) {
1301                 // If there is already one running, tell it to stop.
1302                 stopLoaderLocked();
1303                 mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags);
<abbr title="1304                 if ((((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWorkspaceLoaded) &amp;&amp; (!mIsLoaderTaskRunning)) {">1304                 if ((((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWork🔵</abbr>
1305                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1306                 } else {
1307                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1308                     sWorker.post(mLoaderTask);
1309                 }
1310             }
1311         }
1312     }
1313 
1314     void bindRemainingSynchronousPages() {
1315         // Post the remaining side pages to be loaded
1316         if (!mDeferredBindRunnables.isEmpty()) {
1317             Runnable[] deferredBindRunnables = null;
1318             synchronized(mDeferredBindRunnables) {
<abbr title="1319                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnables.size()]);">1319                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnable🔵</abbr>
1320                 mDeferredBindRunnables.clear();
1321             }
1322             for (final Runnable r : deferredBindRunnables) {
1323                 mHandler.post(r);
1324             }
1325         }
1326         // Run all the bind complete runnables after workspace is bound.
1327         if (!mBindCompleteRunnables.isEmpty()) {
1328             synchronized(mBindCompleteRunnables) {
1329                 for (final Runnable r : mBindCompleteRunnables) {
1330                     runOnWorkerThread(r);
1331                 }
1332                 mBindCompleteRunnables.clear();
1333             }
1334         }
1335     }
1336 
1337     public void stopLoader() {
1338         synchronized (mLock) {
1339             if (mLoaderTask != null) {
1340                 mLoaderTask.stopLocked();
1341             }
1342         }
1343     }
1344 
1345     /**
1346      * Loads the workspace screen ids in an ordered list.
1347      */
1348     @Thunk
1349     static ArrayList&lt;Long&gt; loadWorkspaceScreensDb(Context context) {
1350         final ContentResolver contentResolver = context.getContentResolver();
1351         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1352         // Get screens ordered by rank.
<abbr title="1353         final Cursor sc = contentResolver.query(screensUri, null, null, null, LauncherSettings.WorkspaceScreens.SCREEN_RANK);">1353         final Cursor sc = contentResolver.query(screensUri, null, null, null, LauncherSettings.WorkspaceS🔵</abbr>
1354         ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1355         try {
1356             final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);
1357             while (sc.moveToNext()) {
1358                 try {
1359                     screenIds.add(sc.getLong(idIndex));
1360                 } catch (java.lang.Exception e) {
<abbr title="1361                     Launcher.addDumpLog(TAG, (&quot;Desktop items loading interrupted&quot; + &quot; - invalid screens: &quot;) + e, true);">1361                     Launcher.addDumpLog(TAG, (&quot;Desktop items loading interrupted&quot; + &quot; - invalid screens: 🔵</abbr>
1362                 }
1363             }
1364         } finally {
1365             sc.close();
1366         }
1367         return screenIds;
1368     }
1369 
1370     public boolean isAllAppsLoaded() {
1371         return mAllAppsLoaded;
1372     }
1373 
1374     boolean isLoadingWorkspace() {
1375         synchronized (mLock) {
1376             if (mLoaderTask != null) {
1377                 return mLoaderTask.isLoadingWorkspace();
1378             }
1379         }
1380         return false;
1381     }
1382 
1383     /**
1384      * Runnable for the thread that loads the contents of the launcher:
1385      *   - workspace icons
1386      *   - widgets
1387      *   - all apps icons
1388      */
1389     private class LoaderTask implements Runnable {
1390         private Context mContext;
1391 
1392         @Thunk
1393         boolean mIsLoadingAndBindingWorkspace;
1394 
1395         private boolean mStopped;
1396 
1397         @Thunk
1398         boolean mLoadAndBindStepFinished;
1399 
1400         private int mFlags;
1401 
1402         LoaderTask(Context context, int flags) {
1403             mContext = context;
1404             mFlags = flags;
1405         }
1406 
1407         boolean isLoadingWorkspace() {
1408             return mIsLoadingAndBindingWorkspace;
1409         }
1410 
1411         private void loadAndBindWorkspace() {
1412             mIsLoadingAndBindingWorkspace = true;
1413             // Load the workspace
1414             if (DEBUG_LOADERS) {
1415                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1416             }
1417             if (!mWorkspaceLoaded) {
1418                 loadWorkspace();
1419                 synchronized(this) {
1420                     if (mStopped) {
1421                         return;
1422                     }
1423                     mWorkspaceLoaded = true;
1424                 }
1425             }
1426             // Bind the workspace
1427             bindWorkspace(-1);
1428         }
1429 
1430         private void waitForIdle() {
1431             // Wait until the either we&#x27;re stopped or the other threads are done.
1432             // This way we don&#x27;t start loading all apps until the workspace has settled
1433             // down.
1434             synchronized (LoaderTask.this) {
1435                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1436 
1437                 mHandler.postIdle(new Runnable() {
1438                         public void run() {
1439                             synchronized (LoaderTask.this) {
1440                                 mLoadAndBindStepFinished = true;
1441                                 if (DEBUG_LOADERS) {
1442                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1443                                 }
1444                                 LoaderTask.this.notify();
1445                             }
1446                         }
1447                     });
1448 
1449                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1450                     try {
1451                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1452                         // wait no longer than 1sec at a time
1453                         this.wait(1000);
1454                     } catch (InterruptedException ex) {
1455                         // Ignore
1456                     }
1457                 }
1458                 if (DEBUG_LOADERS) {
1459                     Log.d(TAG, &quot;waited &quot;
1460                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1461                             + &quot;ms for previous step to finish binding&quot;);
1462                 }
1463             }
1464         }
1465 
1466         void runBindSynchronousPage(int synchronousBindPage) {
1467             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1468                 // Ensure that we have a valid page index to load synchronously
<abbr title="1469                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; + &quot;valid page index&quot;);">1469                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; + &quot;valid p🔵</abbr>
1470             }
1471             if ((!mAllAppsLoaded) || (!mWorkspaceLoaded)) {
1472                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1473                 // loaded already (we should load everything asynchronously in that case)
1474                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1475             }
1476             synchronized(mLock) {
1477                 if (mIsLoaderTaskRunning) {
1478                     // Ensure that we are never running the background loading at this point since
1479                     // we also touch the background collections
1480                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1481                 }
1482             }
1483             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1484             // data structures, we can&#x27;t allow any other thread to touch that data, but because
1485             // this call is synchronous, we can get away with not locking).
1486             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1487             // operations from the previous activity.  We need to ensure that all queued operations
1488             // are executed before any synchronous binding work is done.
1489             mHandler.flush();
1490             // Divide the set of loaded items into those that we are binding synchronously, and
1491             // everything else that is to be bound normally (asynchronously).
1492             bindWorkspace(synchronousBindPage);
1493             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1494             // arise from that.
1495             onlyBindAllApps();
1496         }
1497 
1498         public void run() {
1499             synchronized(mLock) {
1500                 if (mStopped) {
1501                     return;
1502                 }
1503                 mIsLoaderTaskRunning = true;
1504             }
1505             // Optimize for end-user experience: if the Launcher is up and // running with the
1506             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1507             // workspace first (default).
1508             keep_running : {
1509                 if (DEBUG_LOADERS) {
1510                     Log.d(TAG, &quot;step 1: loading workspace&quot;);
1511                 }
1512                 loadAndBindWorkspace();
1513                 if (mStopped) {
1514                     break keep_running;
1515                 }
1516                 waitForIdle();
1517                 // second step
1518                 if (DEBUG_LOADERS) {
1519                     Log.d(TAG, &quot;step 2: loading all apps&quot;);
1520                 }
1521                 loadAndBindAllApps();
1522             }
1523             // Clear out this reference, otherwise we end up holding it until all of the
1524             // callback runnables are done.
1525             mContext = null;
1526             synchronized(mLock) {
1527                 // If we are still the last one to be scheduled, remove ourselves.
1528                 if (mLoaderTask == this) {
1529                     mLoaderTask = null;
1530                 }
1531                 mIsLoaderTaskRunning = false;
1532                 mHasLoaderCompletedOnce = true;
1533             }
1534         }
1535 
1536         public void stopLocked() {
1537             synchronized (LoaderTask.this) {
1538                 mStopped = true;
1539                 this.notify();
1540             }
1541         }
1542 
1543         /**
1544          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1545          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1546          * object that was around when the deferred message was scheduled, and if there&#x27;s
1547          * a new Callbacks object around then also return null.  This will save us from
1548          * calling onto it with data that will be ignored.
1549          */
1550         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1551             synchronized (mLock) {
1552                 if (mStopped) {
1553                     return null;
1554                 }
1555 
1556                 if (mCallbacks == null) {
1557                     return null;
1558                 }
1559 
1560                 final Callbacks callbacks = mCallbacks.get();
1561                 if (callbacks != oldCallbacks) {
1562                     return null;
1563                 }
1564                 if (callbacks == null) {
1565                     Log.w(TAG, &quot;no mCallbacks&quot;);
1566                     return null;
1567                 }
1568 
1569                 return callbacks;
1570             }
1571         }
1572 
1573         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1574         private boolean checkItemPlacement(LongArrayMap&lt;ItemInfo[][]&gt; occupied, ItemInfo item) {
1575             LauncherAppState app = LauncherAppState.getInstance();
1576             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1577             final int countX = ((int) (profile.numColumns));
1578             final int countY = ((int) (profile.numRows));
1579             long containerIndex = item.screenId;
1580             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1581                 // Return early if we detect that an item is under the hotseat button
<abbr title="1582                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))) {">1582                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))🔵</abbr>
<abbr title="1583                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by all apps&quot;);">1583                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;🔵</abbr>
1584                     return false;
1585                 }
<abbr title="1586                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)));">1586                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAI🔵</abbr>
1587                 if (item.screenId &gt;= profile.numHotseatIcons) {
<abbr title="1588                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item.screenId) + &quot;, position out of bounds: (0 to &quot;) + (profile.numHotseatIcons - 1)) + &quot;)&quot;);">1588                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item🔵</abbr>
1589                     return false;
1590                 }
1591                 if (hotseatItems != null) {
1592                     if (hotseatItems[((int) (item.screenId))][0] != null) {
<abbr title="1593                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by &quot;) + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)[((int) (item.screenId))][0]);">1593                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into positi🔵</abbr>
1594                         return false;
1595                     } else {
1596                         hotseatItems[((int) (item.screenId))][0] = item;
1597                         return true;
1598                     }
1599                 } else {
1600                     final ItemInfo[][] items = new ItemInfo[((int) (profile.numHotseatIcons))][1];
1601                     items[((int) (item.screenId))][0] = item;
1602                     occupied.put(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)), items);
1603                     return true;
1604                 }
1605             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1606                 // Skip further checking if it is not the hotseat or workspace container
1607                 return true;
1608             }
1609             if (!occupied.containsKey(item.screenId)) {
1610                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1611                 occupied.put(item.screenId, items);
1612             }
1613             final ItemInfo[][] screens = occupied.get(item.screenId);
<abbr title="1614             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) || (item.cellY &lt; 0)) || ((item.cellX + item.spanX) &gt; countX)) || ((item.cellY + item.spanY) &gt; countY)) {">1614             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) 🔵</abbr>
<abbr title="1615                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) out of screen bounds ( &quot;) + countX) + &quot;x&quot;) + countY) + &quot;)&quot;);">1615                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIn🔵</abbr>
1616                 return false;
1617             }
1618             // Check if any workspace icons overlap with each other
1619             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1620                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1621                     if (screens[x][y] != null) {
<abbr title="1622                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + x) + &quot;,&quot;) + y) + &quot;) occupied by &quot;) + screens[x][y]);">1622                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + contai🔵</abbr>
1623                         return false;
1624                     }
1625                 }
1626             }
1627             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1628                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1629                     screens[x][y] = item;
1630                 }
1631             }
1632             return true;
1633         }
1634 
1635         /** Clears all the sBg data structures */
1636         private void clearSBgDataStructures() {
1637             synchronized(sBgLock) {
1638                 sBgWorkspaceItems.clear();
1639                 sBgAppWidgets.clear();
1640                 sBgFolders.clear();
1641                 sBgItemsIdMap.clear();
1642                 sBgWorkspaceScreens.clear();
1643             }
1644         }
1645 
1646         private void loadWorkspace() {
1647             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1648             final Context context = mContext;
1649             final ContentResolver contentResolver = context.getContentResolver();
1650             final PackageManager manager = context.getPackageManager();
1651             final boolean isSafeMode = manager.isSafeMode();
1652             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
<abbr title="1653             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;">1653             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver🔵</abbr>
1654             LauncherAppState app = LauncherAppState.getInstance();
1655             InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
1656             int countX = ((int) (profile.numColumns));
1657             int countY = ((int) (profile.numRows));
1658             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1659                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1660                 LauncherAppState.getLauncherProvider().deleteDatabase();
1661             }
1662             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1663                 // append the user&#x27;s Launcher2 shortcuts
1664                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1665                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1666             } else {
1667                 // Make sure the default workspace is loaded
1668                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1669                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1670             }
1671             synchronized(sBgLock) {
1672                 clearSBgDataStructures();
<abbr title="1673                 final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updateAndGetActiveSessionCache();">1673                 final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat.getInstance(mConte🔵</abbr>
1674                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1675                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1676                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;
1677                 if (DEBUG_LOADERS) {
1678                     Log.d(TAG, &quot;loading model from &quot; + contentUri);
1679                 }
1680                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1681                 // +1 for the hotseat (it can be larger than the workspace)
1682                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1683                 // before any earlier duplicates)
1684                 final LongArrayMap&lt;ItemInfo[][]&gt; occupied = new LongArrayMap&lt;&gt;();
1685                 try {
1686                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1687                     final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1688                     final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1689                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1689                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAIN🔵</abbr>
<abbr title="1690                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1690                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYP🔵</abbr>
<abbr title="1691                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_ID);">1691                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWI🔵</abbr>
<abbr title="1692                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_PROVIDER);">1692                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites🔵</abbr>
1693                     final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1694                     final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1695                     final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1696                     final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1697                     final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
1698                     final int rankIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RANK);
<abbr title="1699                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED);">1699                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED🔵</abbr>
<abbr title="1700                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);">1700                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE🔵</abbr>
1701                     final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);
1702                     final CursorIconInfo cursorIconInfo = new CursorIconInfo(c);
1703                     final LongSparseArray&lt;UserHandleCompat&gt; allUsers = new LongSparseArray&lt;&gt;();
1704                     for (UserHandleCompat user : mUserManager.getUserProfiles()) {
1705                         allUsers.put(mUserManager.getSerialNumberForUser(user), user);
1706                     }
1707                     ShortcutInfo info;
1708                     String intentDescription;
1709                     LauncherAppWidgetInfo appWidgetInfo;
1710                     int container;
1711                     long id;
1712                     long serialNumber;
1713                     Intent intent;
1714                     UserHandleCompat user;
1715                     while ((!mStopped) &amp;&amp; c.moveToNext()) {
1716                         try {
1717                             int itemType = c.getInt(itemTypeIndex);
1718                             boolean restored = 0 != c.getInt(restoredIndex);
1719                             boolean allowMissingTarget = false;
1720                             container = c.getInt(containerIndex);
1721                             switch (itemType) {
1722                                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1723                                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1724                                     id = c.getLong(idIndex);
1725                                     intentDescription = c.getString(intentIndex);
1726                                     serialNumber = c.getInt(profileIdIndex);
1727                                     user = allUsers.get(serialNumber);
1728                                     int promiseType = c.getInt(restoredIndex);
1729                                     int disabledState = 0;
1730                                     boolean itemReplaced = false;
1731                                     if (user == null) {
1732                                         // User has been deleted remove the item.
1733                                         itemsToRemove.add(id);
1734                                         continue;
1735                                     }
1736                                     try {
1737                                         intent = Intent.parseUri(intentDescription, 0);
1738                                         ComponentName cn = intent.getComponent();
1739                                         if ((cn != null) &amp;&amp; (cn.getPackageName() != null)) {
<abbr title="1740                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user);">1740                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn🔵</abbr>
<abbr title="1741                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityEnabledForProfile(cn, user);">1741                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityE🔵</abbr>
1742                                             if (validComponent) {
1743                                                 if (restored) {
1744                                                     // no special handling necessary for this item
1745                                                     restoredRows.add(id);
1746                                                     restored = false;
1747                                                 }
1748                                             } else if (validPkg) {
1749                                                 intent = null;
<abbr title="1750                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {">1750                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 🔵</abbr>
1751                                                     // We allow auto install apps to have their intent
1752                                                     // updated after an install.
<abbr title="1753                                                     intent = manager.getLaunchIntentForPackage(cn.getPackageName());">1753                                                     intent = manager.getLaunchIntentForPackage(cn.getPack🔵</abbr>
1754                                                     if (intent != null) {
1755                                                         ContentValues values = new ContentValues();
<abbr title="1756                                                         values.put(LauncherSettings.Favorites.INTENT, intent.toUri(0));">1756                                                         values.put(LauncherSettings.Favorites.INTENT, int🔵</abbr>
1757                                                         updateItem(id, values);
1758                                                     }
1759                                                 }
1760                                                 if (intent == null) {
1761                                                     // The app is installed but the component is no
1762                                                     // longer available.
<abbr title="1763                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: &quot; + cn, true);">1763                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: 🔵</abbr>
1764                                                     itemsToRemove.add(id);
1765                                                     continue;
1766                                                 } else {
1767                                                     // no special handling necessary for this item
1768                                                     restoredRows.add(id);
1769                                                     restored = false;
1770                                                 }
1771                                             } else if (restored) {
1772                                                 // Package is not yet available but might be
1773                                                 // installed later.
<abbr title="1774                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cn, true);">1774                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + c🔵</abbr>
<abbr title="1775                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {">1775                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 🔵</abbr>
1776                                                     // Restore has started once.
<abbr title="1777                                                 } else if (installingPkgs.containsKey(cn.getPackageName())) {">1777                                                 } else if (installingPkgs.containsKey(cn.getPackageName()🔵</abbr>
1778                                                     // App restore has started. Update the flag
1779                                                     promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
1780                                                     ContentValues values = new ContentValues();
<abbr title="1781                                                     values.put(LauncherSettings.Favorites.RESTORED, promiseType);">1781                                                     values.put(LauncherSettings.Favorites.RESTORED, promi🔵</abbr>
1782                                                     updateItem(id, values);
<abbr title="1783                                                 } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE) != 0) {">1783                                                 } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_🔵</abbr>
1784                                                 // This is a common app. Try to replace this.
<abbr title="1785                                                     int appType = CommonAppTypeParser.decodeItemTypeFromFlag(promiseType);">1785                                                     int appType = CommonAppTypeParser.decodeItemTypeFromF🔵</abbr>
<abbr title="1786                                                     CommonAppTypeParser parser = new CommonAppTypeParser(id, appType, context);">1786                                                     CommonAppTypeParser parser = new CommonAppTypeParser(🔵</abbr>
1787                                                     if (parser.findDefaultApp()) {
1788                                                         // Default app found. Replace it.
1789                                                         intent = parser.parsedIntent;
1790                                                         cn = intent.getComponent();
1791                                                         ContentValues values = parser.parsedValues;
<abbr title="1792                                                         values.put(LauncherSettings.Favorites.RESTORED, 0);">1792                                                         values.put(LauncherSettings.Favorites.RESTORED, 0🔵</abbr>
1793                                                         updateItem(id, values);
1794                                                         restored = false;
1795                                                         itemReplaced = true;
1796                                                     } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="1797                                                         Launcher.addDumpLog(TAG, &quot;Unrestored package removed: &quot; + cn, true);">1797                                                         Launcher.addDumpLog(TAG, &quot;Unrestored package remo🔵</abbr>
1798                                                         itemsToRemove.add(id);
1799                                                         continue;
1800                                                     }
1801                                                 } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="1802                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed: &quot; + cn, true);">1802                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed:🔵</abbr>
1803                                                     itemsToRemove.add(id);
1804                                                     continue;
1805                                                 }
<abbr title="1806                                             } else if (launcherApps.isAppEnabled(manager, cn.getPackageName(), PackageManager.GET_UNINSTALLED_PACKAGES)) {">1806                                             } else if (launcherApps.isAppEnabled(manager, cn.getPackageNa🔵</abbr>
1807                                                 // Package is present but not available.
1808                                                 allowMissingTarget = true;
1809                                                 disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
1810                                             } else if (!isSdCardReady) {
1811                                                 // SdCard is not ready yet. Package might get available,
1812                                                 // once it is ready.
<abbr title="1813                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (check again later)&quot;, true);">1813                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (🔵</abbr>
1814                                                 HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
1815                                                 if (pkgs == null) {
1816                                                     pkgs = new HashSet&lt;String&gt;();
1817                                                     sPendingPackages.put(user, pkgs);
1818                                                 }
1819                                                 pkgs.add(cn.getPackageName());
1820                                                 allowMissingTarget = true;
1821                                                 // Add the icon on the workspace anyway.
1822                                             } else {
1823                                                 // Do not wait for external media load anymore.
1824                                                 // Log the invalid package, and remove it
<abbr title="1825                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn, true);">1825                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn🔵</abbr>
1826                                                 itemsToRemove.add(id);
1827                                                 continue;
1828                                             }
1829                                         } else if (cn == null) {
1830                                             // For shortcuts with no component, keep them as they are
1831                                             restoredRows.add(id);
1832                                             restored = false;
1833                                         }
1834                                     } catch (URISyntaxException e) {
<abbr title="1835                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, true);">1835                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, tru🔵</abbr>
1836                                         continue;
1837                                     }
<abbr title="1838                                     boolean useLowResIcon = (container &gt;= 0) &amp;&amp; (c.getInt(rankIndex) &gt;= FolderIcon.NUM_ITEMS_IN_PREVIEW);">1838                                     boolean useLowResIcon = (container &gt;= 0) &amp;&amp; (c.getInt(rankIndex) &gt;= F🔵</abbr>
1839                                     if (itemReplaced) {
1840                                         if (user.equals(UserHandleCompat.myUserHandle())) {
<abbr title="1841                                             info = getAppShortcutInfo(manager, intent, user, context, null, cursorIconInfo.iconIndex, titleIndex, false, useLowResIcon);">1841                                             info = getAppShortcutInfo(manager, intent, user, context, nul🔵</abbr>
1842                                         } else {
1843                                             // Don&#x27;t replace items for other profiles.
1844                                             itemsToRemove.add(id);
1845                                             continue;
1846                                         }
1847                                     } else if (restored) {
1848                                         if (user.equals(UserHandleCompat.myUserHandle())) {
<abbr title="1849                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially restored package&quot;, true);">1849                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially res🔵</abbr>
<abbr title="1850                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType, itemType, cursorIconInfo, context);">1850                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType🔵</abbr>
1851                                             intent = getRestoredItemIntent(c, context, intent);
1852                                         } else {
1853                                             // Don&#x27;t restore items for other profiles.
1854                                             itemsToRemove.add(id);
1855                                             continue;
1856                                         }
<abbr title="1857                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">1857                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATI🔵</abbr>
<abbr title="1858                                         info = getAppShortcutInfo(manager, intent, user, context, c, cursorIconInfo.iconIndex, titleIndex, allowMissingTarget, useLowResIcon);">1858                                         info = getAppShortcutInfo(manager, intent, user, context, c, curs🔵</abbr>
1859                                     } else {
1860                                         info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);
1861                                         // App shortcuts that used to be automatically added to Launcher
1862                                         // didn&#x27;t always have the correct intent flags set, so do that
1863                                         // here
<abbr title="1864                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != null)) &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN)) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {">1864                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != 🔵</abbr>
<abbr title="1865                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">1865                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_A🔵</abbr>
1866                                         }
1867                                     }
1868                                     if (info != null) {
1869                                         info.id = id;
1870                                         info.intent = intent;
1871                                         info.container = container;
1872                                         info.screenId = c.getInt(screenIndex);
1873                                         info.cellX = c.getInt(cellXIndex);
1874                                         info.cellY = c.getInt(cellYIndex);
1875                                         info.rank = c.getInt(rankIndex);
1876                                         info.spanX = 1;
1877                                         info.spanY = 1;
1878                                         info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
1879                                         if (info.promisedIntent != null) {
<abbr title="1880                                             info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);">1880                                             info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNu🔵</abbr>
1881                                         }
1882                                         info.isDisabled = disabledState;
1883                                         if (isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, intent))) {
1884                                             info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
1885                                         }
1886                                     // check &amp; update map of what&#x27;s occupied
1887                                         if (!checkItemPlacement(occupied, info)) {
1888                                             itemsToRemove.add(id);
1889                                             break;
1890                                         }
1891                                         if (restored) {
1892                                             ComponentName cn = info.getTargetComponent();
1893                                             if (cn != null) {
<abbr title="1894                                                 Integer progress = installingPkgs.get(cn.getPackageName());">1894                                                 Integer progress = installingPkgs.get(cn.getPackageName()🔵</abbr>
1895                                                 if (progress != null) {
1896                                                     info.setInstallProgress(progress);
1897                                                 } else {
<abbr title="1898                                                     info.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;">1898                                                     info.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACT🔵</abbr>
1899                                                 }
1900                                             }
1901                                         }
1902                                         switch (container) {
1903                                             case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1904                                             case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1905                                                 sBgWorkspaceItems.add(info);
1906                                                 break;
1907                                             default :
1908                                         // Item is in a user folder
<abbr title="1909                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, container);">1909                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, cont🔵</abbr>
1910                                                 folderInfo.add(info);
1911                                                 break;
1912                                         }
1913                                         sBgItemsIdMap.put(info.id, info);
1914                                     } else {
1915                                         throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1916                                     }
1917                                     break;
1918                                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1919                                     id = c.getLong(idIndex);
1920                                     FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1921                                 // Do not trim the folder label, as is was set by the user.
1922                                     folderInfo.title = c.getString(titleIndex);
1923                                     folderInfo.id = id;
1924                                     folderInfo.container = container;
1925                                     folderInfo.screenId = c.getInt(screenIndex);
1926                                     folderInfo.cellX = c.getInt(cellXIndex);
1927                                     folderInfo.cellY = c.getInt(cellYIndex);
1928                                     folderInfo.spanX = 1;
1929                                     folderInfo.spanY = 1;
1930                                     folderInfo.options = c.getInt(optionsIndex);
1931                                 // check &amp; update map of what&#x27;s occupied
1932                                     if (!checkItemPlacement(occupied, folderInfo)) {
1933                                         itemsToRemove.add(id);
1934                                         break;
1935                                     }
1936                                     switch (container) {
1937                                         case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1938                                         case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1939                                             sBgWorkspaceItems.add(folderInfo);
1940                                             break;
1941                                     }
1942                                     if (restored) {
1943                                         // no special handling required for restored folders
1944                                         restoredRows.add(id);
1945                                     }
1946                                     sBgItemsIdMap.put(folderInfo.id, folderInfo);
1947                                     sBgFolders.put(folderInfo.id, folderInfo);
1948                                     break;
1949                                 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1950                                 case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET :
1951                                     // Read all Launcher-specific widget details
<abbr title="1952                                     boolean customWidget = itemType == LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;">1952                                     boolean customWidget = itemType == LauncherSettings.Favorites.ITEM_TY🔵</abbr>
1953                                     id = c.getLong(idIndex);
1954 
1955 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1956                                 user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1957                                 if (user == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1958                                     // User has been deleted remove the item.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1959                                     itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1960                                     continue;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1961                                 }</span>
1962 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="1963 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">1963 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
1964 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1965 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1966                                 int appWidgetId = c.getInt(appWidgetIdIndex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1967                                 serialNumber= c.getLong(profileIdIndex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1968                                 user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1969                                 if (user == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1970                                     // User has been deleted remove the item.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1971                                     itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1972                                     continue;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1973                                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1974                                 String savedProvider = c.getString(appWidgetProviderIndex);</span>
1975 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
1976 
<abbr title="1977                                     final ComponentName component = ComponentName.unflattenFromString(savedProvider);">1977                                     final ComponentName component = ComponentName.unflattenFromString(sav🔵</abbr>
1978                                     final int restoreStatus = c.getInt(restoredIndex);
<abbr title="1979                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;">1979                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG🔵</abbr>
<abbr title="1980                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;">1980                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetIn🔵</abbr>
<abbr title="1981                                     final LauncherAppWidgetProviderInfo provider = LauncherModel.getProviderInfo(context, ComponentName.unflattenFromString(savedProvider), user);">1981                                     final LauncherAppWidgetProviderInfo provider = LauncherModel.getProvi🔵</abbr>
1982                                     final boolean isProviderReady = isValidProvider(provider);
<abbr title="1983                                     if ((((!isSafeMode) &amp;&amp; (!customWidget)) &amp;&amp; wasProviderReady) &amp;&amp; (!isProviderReady)) {">1983                                     if ((((!isSafeMode) &amp;&amp; (!customWidget)) &amp;&amp; wasProviderReady) &amp;&amp; (!isP🔵</abbr>
<abbr title="1984                                         String log = (((&quot;Deleting widget that isn&#x27;t installed anymore: &quot; + &quot;id=&quot;) + id) + &quot; appWidgetId=&quot;) + appWidgetId;">1984                                         String log = (((&quot;Deleting widget that isn&#x27;t installed anymore: &quot; 🔵</abbr>
1985                                         Log.e(TAG, log);
1986                                         Launcher.addDumpLog(TAG, log, false);
1987                                         itemsToRemove.add(id);
1988                                     } else {
1989                                         if (isProviderReady) {
<abbr title="1990                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider);">1990                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provid🔵</abbr>
1991                                             int status = restoreStatus;
1992                                             if (!wasProviderReady) {
1993                                                 // If provider was not previously ready, update the
1994                                                 // status and UI flag.
<abbr title="1995                                                 // Id would be valid only if the widget restore broadcast was received.">1995                                                 // Id would be valid only if the widget restore broadcast🔵</abbr>
1996                                                 if (isIdValid) {
1997                                                     status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
1998                                                 } else {
<abbr title="1999                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">1999                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_RE🔵</abbr>
2000                                                 }
2001                                             }
2002                                             appWidgetInfo.restoreStatus = status;
2003                                         } else {
<abbr title="2004                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidgetId=&quot;) + appWidgetId) + &quot; status =&quot;) + restoreStatus);">2004                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidg🔵</abbr>
<abbr title="2005                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, component);">2005                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, compon🔵</abbr>
2006                                             appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2007                                             Integer installProgress = installingPkgs.get(component.getPackageName());">2007                                             Integer installProgress = installingPkgs.get(component.getPac🔵</abbr>
<abbr title="2008                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2008                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_START🔵</abbr>
2009                                                 // Restore has started once.
2010                                             } else if (installProgress != null) {
2011                                                 // App restore has started. Update the flag
<abbr title="2012                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;">2012                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG🔵</abbr>
2013                                             } else if (REMOVE_UNRESTORED_ICONS &amp;&amp; (!isSafeMode)) {
<abbr title="2014                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + component, true);">2014                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + 🔵</abbr>
2015                                                 itemsToRemove.add(id);
2016                                                 continue;
2017                                             }
<abbr title="2018                                             appWidgetInfo.installProgress = (installProgress == null) ? 0 : installProgress;">2018                                             appWidgetInfo.installProgress = (installProgress == null) ? 0🔵</abbr>
2019                                         }
2020                                         appWidgetInfo.id = id;
2021                                         appWidgetInfo.screenId = c.getInt(screenIndex);
2022                                         appWidgetInfo.cellX = c.getInt(cellXIndex);
2023                                         appWidgetInfo.cellY = c.getInt(cellYIndex);
2024                                         appWidgetInfo.spanX = c.getInt(spanXIndex);
2025                                         appWidgetInfo.spanY = c.getInt(spanYIndex);
<abbr title="2026                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {">2026                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;🔵</abbr>
<abbr title="2027                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);">2027                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DE🔵</abbr>
2028                                             continue;
2029                                         }
2030                                         appWidgetInfo.container = container;
2031                                     // check &amp; update map of what&#x27;s occupied
2032                                         if (!checkItemPlacement(occupied, appWidgetInfo)) {
2033                                             itemsToRemove.add(id);
2034                                             break;
2035                                         }
2036                                         if (!customWidget) {
<abbr title="2037                                             String providerName = appWidgetInfo.providerName.flattenToString();">2037                                             String providerName = appWidgetInfo.providerName.flattenToStr🔵</abbr>
<abbr title="2038                                             if ((!providerName.equals(savedProvider)) || (appWidgetInfo.restoreStatus != restoreStatus)) {">2038                                             if ((!providerName.equals(savedProvider)) || (appWidgetInfo.r🔵</abbr>
2039                                                 ContentValues values = new ContentValues();
<abbr title="2040                                                 values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, providerName);">2040                                                 values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,🔵</abbr>
<abbr title="2041                                                 values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo.restoreStatus);">2041                                                 values.put(LauncherSettings.Favorites.RESTORED, appWidget🔵</abbr>
2042                                                 updateItem(id, values);
2043                                             }
2044                                         }
2045                                         sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2046                                         sBgAppWidgets.add(appWidgetInfo);
2047                                     }
2048                                     break;
2049                             }
2050                         } catch (java.lang.Exception e) {
2051                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2052                         }
2053                     }
2054                 } finally {
2055                     if (c != null) {
2056                         c.close();
2057                     }
2058                 }
2059                 // Break early if we&#x27;ve stopped loading
2060                 if (mStopped) {
2061                     clearSBgDataStructures();
2062                     return;
2063                 }
2064                 if (itemsToRemove.size() &gt; 0) {
2065                     // Remove dead items
<abbr title="2066                     contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI, Utilities.createDbSelectionQuery(LauncherSettings.Favorites._ID, itemsToRemove), null);">2066                     contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI, Utilities.createDbSele🔵</abbr>
2067                     if (DEBUG_LOADERS) {
<abbr title="2068                         Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery(LauncherSettings.Favorites._ID, itemsToRemove));">2068                         Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery(LauncherSettings.Favor🔵</abbr>
2069                     }
2070                     // Remove any empty folder
2071                     for (long folderId : LauncherAppState.getLauncherProvider().deleteEmptyFolders()) {
2072                         sBgWorkspaceItems.remove(sBgFolders.get(folderId));
2073                         sBgFolders.remove(folderId);
2074                         sBgItemsIdMap.remove(folderId);
2075                     }
2076                 }
2077                 if (restoredRows.size() &gt; 0) {
2078                     // Update restored items that no longer require special handling
2079                     ContentValues values = new ContentValues();
2080                     values.put(LauncherSettings.Favorites.RESTORED, 0);
<abbr title="2081                     contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values, Utilities.createDbSelectionQuery(LauncherSettings.Favorites._ID, restoredRows), null);">2081                     contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values, Utilities.crea🔵</abbr>
2082                 }
2083                 if ((!isSdCardReady) &amp;&amp; (!sPendingPackages.isEmpty())) {
<abbr title="2084                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiver.SYSTEM_READY), null, sWorker);">2084                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceive🔵</abbr>
2085                 }
2086                 sBgWorkspaceScreens.addAll(loadWorkspaceScreensDb(mContext));
2087                 // Remove any empty screens
2088                 ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2089                 for (ItemInfo item : sBgItemsIdMap) {
2090                     long screenId = item.screenId;
<abbr title="2091                     if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens.contains(screenId)) {">2091                     if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens🔵</abbr>
2092                         unusedScreens.remove(screenId);
2093                     }
2094                 }
2095                     // If there are any empty screens remove them, and update.
2096                 if (unusedScreens.size() != 0) {
2097                     sBgWorkspaceScreens.removeAll(unusedScreens);
2098                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2099                 }
2100                 if (DEBUG_LOADERS) {
2101                     Log.d(TAG, (&quot;loaded workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2102                     Log.d(TAG, &quot;workspace layout: &quot;);
2103                     int nScreens = occupied.size();
2104                     for (int y = 0; y &lt; countY; y++) {
2105                         String line = &quot;&quot;;
2106                         for (int i = 0; i &lt; nScreens; i++) {
2107                             long screenId = occupied.keyAt(i);
2108                             if (screenId &gt; 0) {
2109                                 line += &quot; | &quot;;
2110                             }
2111                             ItemInfo[][] screen = occupied.valueAt(i);
2112                             for (int x = 0; x &lt; countX; x++) {
2113                                 if ((x &lt; screen.length) &amp;&amp; (y &lt; screen[x].length)) {
2114                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2115                                 } else {
2116                                     line += &quot;!&quot;;
2117                                 }
2118                             }
2119                         }
2120                         Log.d(TAG, (&quot;[ &quot; + line) + &quot; ]&quot;);
2121                     }
2122                 }
2123             }
2124         }
2125 
2126         /**
2127          * Partially updates the item without any notification. Must be called on the worker thread.
2128          */
2129         private void updateItem(long itemId, ContentValues update) {
<abbr title="2130             mContext.getContentResolver().update(LauncherSettings.Favorites.CONTENT_URI, update, BaseColumns._ID + &quot;= ?&quot;, new String[]{ Long.toString(itemId) });">2130             mContext.getContentResolver().update(LauncherSettings.Favorites.CONTENT_URI, update, BaseColu🔵</abbr>
2131         }
2132 
2133         /** Filters the set of items who are directly or indirectly (via another container) on the
2134          * specified screen. */
2135         private void filterCurrentWorkspaceItems(long currentScreenId,
2136                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2137                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2138                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2139             // Purge any null ItemInfos
2140             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2141             while (iter.hasNext()) {
2142                 ItemInfo i = iter.next();
2143                 if (i == null) {
2144                     iter.remove();
2145                 }
2146             }
2147 
2148             // Order the set of items by their containers first, this allows use to walk through the
2149             // list sequentially, build up a list of containers that are in the specified screen,
2150             // as well as all items in those containers.
2151             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2152             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2153                 @Override
2154                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2155                     return (int) (lhs.container - rhs.container);
2156                 }
2157             });
2158             for (ItemInfo info : allWorkspaceItems) {
2159                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2160                     if (info.screenId == currentScreenId) {
2161                         currentScreenItems.add(info);
2162                         itemsOnScreen.add(info.id);
2163                     } else {
2164                         otherScreenItems.add(info);
2165                     }
2166                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2167                     currentScreenItems.add(info);
2168                     itemsOnScreen.add(info.id);
2169                 } else {
2170                     if (itemsOnScreen.contains(info.container)) {
2171                         currentScreenItems.add(info);
2172                         itemsOnScreen.add(info.id);
2173                     } else {
2174                         otherScreenItems.add(info);
2175                     }
2176                 }
2177             }
2178         }
2179 
2180         /** Filters the set of widgets which are on the specified screen. */
2181         private void filterCurrentAppWidgets(long currentScreenId,
2182                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2183                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2184                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2185 
2186             for (LauncherAppWidgetInfo widget : appWidgets) {
2187                 if (widget == null) continue;
2188                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2189                         widget.screenId == currentScreenId) {
2190                     currentScreenWidgets.add(widget);
2191                 } else {
2192                     otherScreenWidgets.add(widget);
2193                 }
2194             }
2195         }
2196 
2197         /** Filters the set of folders which are on the specified screen. */
<abbr title="2198         private void filterCurrentFolders(long currentScreenId, LongArrayMap&lt;ItemInfo&gt; itemsIdMap, LongArrayMap&lt;FolderInfo&gt; folders, LongArrayMap&lt;FolderInfo&gt; currentScreenFolders, LongArrayMap&lt;FolderInfo&gt; otherScreenFolders) {">2198         private void filterCurrentFolders(long currentScreenId, LongArrayMap&lt;ItemInfo&gt; itemsIdMap, LongAr🔵</abbr>
2199             int total = folders.size();
2200             for (int i = 0; i &lt; total; i++) {
2201                 long id = folders.keyAt(i);
2202                 FolderInfo folder = folders.valueAt(i);
2203                 ItemInfo info = itemsIdMap.get(id);
2204                 if ((info == null) || (folder == null)) {
2205                     continue;
2206                 }
<abbr title="2207                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId == currentScreenId)) {">2207                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId ==🔵</abbr>
2208                     currentScreenFolders.put(id, folder);
2209                 } else {
2210                     otherScreenFolders.put(id, folder);
2211                 }
2212             }
2213         }
2214 
2215         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2216          * right) */
2217         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2218             final LauncherAppState app = LauncherAppState.getInstance();
2219             final InvariantDeviceProfile profile = app.getInvariantDeviceProfile();
2220             // XXX: review this
2221             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2222                 @Override
2223                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2224                     int cellCountX = ((int) (profile.numColumns));
2225                     int cellCountY = ((int) (profile.numRows));
2226                     int screenOffset = cellCountX * cellCountY;
2227                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1);// +1 hotseat
2228 
<abbr title="2229                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs.cellY * cellCountX)) + lhs.cellX;">2229                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs🔵</abbr>
<abbr title="2230                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs.cellY * cellCountX)) + rhs.cellX;">2230                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs🔵</abbr>
2231                     return ((int) (lr - rr));
2232                 }
2233             });
2234         }
2235 
<abbr title="2236         private void bindWorkspaceScreens(final Callbacks oldCallbacks, final ArrayList&lt;Long&gt; orderedScreens) {">2236         private void bindWorkspaceScreens(final Callbacks oldCallbacks, final ArrayList&lt;Long&gt; orderedScre🔵</abbr>
2237             final Runnable r = new Runnable() {
2238                 @Override
2239                 public void run() {
2240                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2241                     if (callbacks != null) {
2242                         callbacks.bindScreens(orderedScreens);
2243                     }
2244                 }
2245             };
2246             runOnMainThread(r);
2247         }
2248 
<abbr title="2249         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspaceItems, final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets, final LongArrayMap&lt;FolderInfo&gt; folders, ArrayList&lt;Runnable&gt; deferredBindRunnables) {">2249         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspace🔵</abbr>
2250             final boolean postOnMainThread = deferredBindRunnables != null;
2251             // Bind the workspace items
2252             int N = workspaceItems.size();
2253             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2254                 final int start = i;
2255                 final int chunkSize = ((i + ITEMS_CHUNK) &lt;= N) ? ITEMS_CHUNK : N - i;
2256                 final Runnable r = new Runnable() {
2257                     @Override
2258                     public void run() {
2259                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2260                         if (callbacks != null) {
2261                             callbacks.bindItems(workspaceItems, start, start + chunkSize, false);
2262                         }
2263                     }
2264                 };
2265                 if (postOnMainThread) {
2266                     synchronized(deferredBindRunnables) {
2267                         deferredBindRunnables.add(r);
2268                     }
2269                 } else {
2270                     runOnMainThread(r);
2271                 }
2272             }
2273             // Bind the folders
2274             if (!folders.isEmpty()) {
2275                 final Runnable r = new Runnable() {
2276                     public void run() {
2277                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2278                         if (callbacks != null) {
2279                             callbacks.bindFolders(folders);
2280                         }
2281                     }
2282                 };
2283                 if (postOnMainThread) {
2284                     synchronized(deferredBindRunnables) {
2285                         deferredBindRunnables.add(r);
2286                     }
2287                 } else {
2288                     runOnMainThread(r);
2289                 }
2290             }
2291             // Bind the widgets, one at a time
2292             N = appWidgets.size();
2293             for (int i = 0; i &lt; N; i++) {
2294                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2295                 final Runnable r = new Runnable() {
2296                     public void run() {
2297                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2298                         if (callbacks != null) {
2299                             callbacks.bindAppWidget(widget);
2300                         }
2301                     }
2302                 };
2303                 if (postOnMainThread) {
2304                     deferredBindRunnables.add(r);
2305                 } else {
2306                     runOnMainThread(r);
2307                 }
2308             }
2309         }
2310 
2311         /**
2312          * Binds all loaded data to actual views on the main thread.
2313          */
2314         private void bindWorkspace(int synchronizeBindPage) {
2315             final long t = SystemClock.uptimeMillis();
2316             Runnable r;
2317             // Don&#x27;t use these two variables in any of the callback runnables.
2318             // Otherwise we hold a reference to them.
2319             final Callbacks oldCallbacks = mCallbacks.get();
2320             if (oldCallbacks == null) {
2321                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2322                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2323                 return;
2324             }
2325             // Save a copy of all the bg-thread collections
2326             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2327             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2328             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2329             final LongArrayMap&lt;FolderInfo&gt; folders;
2330             final LongArrayMap&lt;ItemInfo&gt; itemsIdMap;
2331             synchronized(sBgLock) {
2332                 workspaceItems.addAll(sBgWorkspaceItems);
2333                 appWidgets.addAll(sBgAppWidgets);
2334                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2335                 folders = sBgFolders.clone();
2336                 itemsIdMap = sBgItemsIdMap.clone();
2337             }
2338             final boolean isLoadingSynchronously = synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
<abbr title="2339             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWorkspaceScreen();">2339             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWork🔵</abbr>
2340             if (currScreen &gt;= orderedScreenIds.size()) {
2341                 // There may be no workspace screens (just hotseat items and an empty page).
2342                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2343             }
2344             final int currentScreen = currScreen;
<abbr title="2345             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);">2345             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(c🔵</abbr>
2346             // Load all the items that are on the current page first (and in the process, unbind
2347             // all the existing workspace items before we call startBinding() below.
2348             unbindWorkspaceItemsOnMainThread();
2349             // Separate the items that are on the current screen, and all the other remaining items
2350             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2351             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2352             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2353             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2354             LongArrayMap&lt;FolderInfo&gt; currentFolders = new LongArrayMap&lt;&gt;();
2355             LongArrayMap&lt;FolderInfo&gt; otherFolders = new LongArrayMap&lt;&gt;();
<abbr title="2356             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWorkspaceItems);">2356             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWork🔵</abbr>
2357             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets, otherAppWidgets);
2358             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders, otherFolders);
2359             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2360             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2361             // Tell the workspace that we&#x27;re about to start binding items
2362             r = new Runnable() {
2363                 public void run() {
2364                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2365                     if (callbacks != null) {
2366                         callbacks.startBinding();
2367                     }
2368                 }
2369             };
2370             runOnMainThread(r);
2371             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2372             // Load items on the current page
<abbr title="2373             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, null);">2373             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, nu🔵</abbr>
2374             if (isLoadingSynchronously) {
2375                 r = new Runnable() {
2376                     public void run() {
2377                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2378                         if ((callbacks != null) &amp;&amp; (currentScreen != PagedView.INVALID_RESTORE_PAGE)) {
2379                             callbacks.onPageBoundSynchronously(currentScreen);
2380                         }
2381                     }
2382                 };
2383                 runOnMainThread(r);
2384             }
2385             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2386             // work until after the first render)
2387             synchronized(mDeferredBindRunnables) {
2388                 mDeferredBindRunnables.clear();
2389             }
<abbr title="2390             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadingSynchronously ? mDeferredBindRunnables : null);">2390             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadin🔵</abbr>
2391             // Tell the workspace that we&#x27;re done binding items
2392             r = new Runnable() {
2393                 public void run() {
2394                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2395                     if (callbacks != null) {
2396                         callbacks.finishBindingItems();
2397                     }
2398                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2399                     if (DEBUG_LOADERS) {
2400                         Log.d(TAG, (&quot;bound workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2401                     }
2402                     mIsLoadingAndBindingWorkspace = false;
2403                 }
2404             };
2405             if (isLoadingSynchronously) {
2406                 synchronized(mDeferredBindRunnables) {
2407                     mDeferredBindRunnables.add(r);
2408                 }
2409             } else {
2410                 runOnMainThread(r);
2411             }
2412         }
2413 
2414         private void loadAndBindAllApps() {
2415             if (DEBUG_LOADERS) {
2416                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2417             }
2418             if (!mAllAppsLoaded) {
2419                 loadAllApps();
2420                 synchronized(this) {
2421                     if (mStopped) {
2422                         return;
2423                     }
2424                 }
2425                 updateIconCache();
2426                 synchronized(this) {
2427                     if (mStopped) {
2428                         return;
2429                     }
2430                     mAllAppsLoaded = true;
2431                 }
2432             } else {
2433                 onlyBindAllApps();
2434             }
2435         }
2436 
2437         private void updateIconCache() {
2438             // Ignore packages which have a promise icon.
2439             HashSet&lt;String&gt; packagesToIgnore = new HashSet&lt;&gt;();
2440             synchronized(sBgLock) {
2441                 for (ItemInfo info : sBgItemsIdMap) {
2442                     if (info instanceof ShortcutInfo) {
2443                         ShortcutInfo si = ((ShortcutInfo) (info));
2444                         if (si.isPromise() &amp;&amp; (si.getTargetComponent() != null)) {
2445                             packagesToIgnore.add(si.getTargetComponent().getPackageName());
2446                         }
2447                     } else if (info instanceof LauncherAppWidgetInfo) {
2448                         LauncherAppWidgetInfo lawi = ((LauncherAppWidgetInfo) (info));
2449                         if (lawi.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {
2450                             packagesToIgnore.add(lawi.providerName.getPackageName());
2451                         }
2452                     }
2453                 }
2454             }
2455             mIconCache.updateDbIcons(packagesToIgnore);
2456         }
2457 
2458         private void onlyBindAllApps() {
2459             final Callbacks oldCallbacks = mCallbacks.get();
2460             if (oldCallbacks == null) {
2461                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2462                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2463                 return;
2464             }
2465             // shallow copy
2466             @SuppressWarnings(&quot;unchecked&quot;)
2467             final ArrayList&lt;AppInfo&gt; list = ((ArrayList&lt;AppInfo&gt;) (mBgAllAppsList.data.clone()));
2468             final WidgetsModel widgetList = mBgWidgetsModel.clone();
2469             Runnable r = new Runnable() {
2470                 public void run() {
2471                     final long t = SystemClock.uptimeMillis();
2472                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2473                     if (callbacks != null) {
2474                         callbacks.bindAllApplications(list);
2475                         callbacks.bindAllPackages(widgetList);
2476                     }
2477                     if (DEBUG_LOADERS) {
<abbr title="2478                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);">2478                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemCloc🔵</abbr>
2479                     }
2480                 }
2481             };
2482             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2483             if (isRunningOnMainThread) {
2484                 r.run();
2485             } else {
2486                 mHandler.post(r);
2487             }
2488         }
2489 
2490         private void loadAllApps() {
2491             final long loadTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2492             final Callbacks oldCallbacks = mCallbacks.get();
2493             if (oldCallbacks == null) {
2494                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2495                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2496                 return;
2497             }
2498             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2499             // Clear the list of apps
2500             mBgAllAppsList.clear();
2501             for (UserHandleCompat user : profiles) {
2502                 // Query for the set of apps
2503                 final long qiaTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2504                 final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2505                 if (DEBUG_LOADERS) {
<abbr title="2506                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms for user &quot;) + user);">2506                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms 🔵</abbr>
2507                     Log.d(TAG, ((&quot;getActivityList got &quot; + apps.size()) + &quot; apps for user &quot;) + user);
2508                 }
2509                 // Fail if we don&#x27;t have any apps
2510                 // TODO: Fix this. Only fail for the current user.
2511                 if ((apps == null) || apps.isEmpty()) {
2512                     return;
2513                 }
2514                 // Create the ApplicationInfos
2515                 for (int i = 0; i &lt; apps.size(); i++) {
2516                     LauncherActivityInfoCompat app = apps.get(i);
2517                     // This builds the icon bitmaps.
2518                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache));
2519                 }
2520                 final ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(mContext, user);
2521                 if (heuristic != null) {
2522                     runAfterBindCompletes(new Runnable() {
2523                         @Override
2524                         public void run() {
2525                             heuristic.processUserApps(apps);
2526                         }
2527                     });
2528                 }
2529             }
2530             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2531             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2532             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2533             // Post callback on main thread
2534             mHandler.post(new Runnable() {
2535                 public void run() {
2536                     final long bindTime = SystemClock.uptimeMillis();
2537                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2538                     if (callbacks != null) {
2539                         callbacks.bindAllApplications(added);
2540                         if (DEBUG_LOADERS) {
<abbr title="2541                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - bindTime)) + &quot;ms&quot;);">2541                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMi🔵</abbr>
2542                         }
2543                     } else {
2544                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2545                     }
2546                 }
2547             });
2548             // Cleanup any data stored for a deleted user.
2549             ManagedProfileHeuristic.processAllUsers(profiles, mContext);
2550                     /* refresh */
2551             loadAndBindWidgetsAndShortcuts(mApp.getContext(), tryGetCallbacks(oldCallbacks), true);
2552             if (DEBUG_LOADERS) {
2553                 Log.d(TAG, (&quot;Icons processed in &quot; + (SystemClock.uptimeMillis() - loadTime)) + &quot;ms&quot;);
2554             }
2555         }
2556 
2557         public void dumpState() {
2558             synchronized(sBgLock) {
2559                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2560                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2561                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2562                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2563             }
2564         }
2565     }
2566 
2567     /**
2568      * Called when the icons for packages have been updated in the icon cache.
2569      */
2570     public void onPackageIconsUpdated(HashSet&lt;String&gt; updatedPackages, UserHandleCompat user) {
2571         final Callbacks callbacks = getCallback();
2572         final ArrayList&lt;AppInfo&gt; updatedApps = new ArrayList&lt;&gt;();
2573         final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;&gt;();
2574         // If any package icon has changed (app was updated while launcher was dead),
2575         // update the corresponding shortcuts.
2576         synchronized(sBgLock) {
2577             for (ItemInfo info : sBgItemsIdMap) {
<abbr title="2578                 if (((info instanceof ShortcutInfo) &amp;&amp; user.equals(info.user)) &amp;&amp; (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION)) {">2578                 if (((info instanceof ShortcutInfo) &amp;&amp; user.equals(info.user)) &amp;&amp; (info.itemType == Launc🔵</abbr>
2579                     ShortcutInfo si = ((ShortcutInfo) (info));
2580                     ComponentName cn = si.getTargetComponent();
2581                     if ((cn != null) &amp;&amp; updatedPackages.contains(cn.getPackageName())) {
2582                         si.updateIcon(mIconCache);
2583                         updatedShortcuts.add(si);
2584                     }
2585                 }
2586             }
2587             mBgAllAppsList.updateIconsAndLabels(updatedPackages, user, updatedApps);
2588         }
2589         if (!updatedShortcuts.isEmpty()) {
2590             final UserHandleCompat userFinal = user;
2591             mHandler.post(new Runnable() {
2592                 public void run() {
2593                     Callbacks cb = getCallback();
2594                     if ((cb != null) &amp;&amp; (callbacks == cb)) {
<abbr title="2595                         cb.bindShortcutsChanged(updatedShortcuts, new ArrayList&lt;ShortcutInfo&gt;(), userFinal);">2595                         cb.bindShortcutsChanged(updatedShortcuts, new ArrayList&lt;ShortcutInfo&gt;(), userFina🔵</abbr>
2596                     }
2597                 }
2598             });
2599         }
2600         if (!updatedApps.isEmpty()) {
2601             mHandler.post(new Runnable() {
2602                 public void run() {
2603                     Callbacks cb = getCallback();
2604                     if ((cb != null) &amp;&amp; (callbacks == cb)) {
2605                         cb.bindAppsUpdated(updatedApps);
2606                     }
2607                 }
2608             });
2609         }
2610         // Reload widget list. No need to refresh, as we only want to update the icons and labels.
2611         loadAndBindWidgetsAndShortcuts(mApp.getContext(), callbacks, false);
2612     }
2613 
2614     void enqueuePackageUpdated(PackageUpdatedTask task) {
2615         sWorker.post(task);
2616     }
2617 
2618     @Thunk
2619     class AppsAvailabilityCheck extends BroadcastReceiver {
2620         @Override
2621         public void onReceive(Context context, Intent intent) {
2622             synchronized (sBgLock) {
2623                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2624                         .getInstance(mApp.getContext());
2625                 final PackageManager manager = context.getPackageManager();
2626                 final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2627                 final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2628                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2629                     UserHandleCompat user = entry.getKey();
2630                     packagesRemoved.clear();
2631                     packagesUnavailable.clear();
2632                     for (String pkg : entry.getValue()) {
2633                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2634                             boolean packageOnSdcard = launcherApps.isAppEnabled(
2635                                     manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
2636                             if (packageOnSdcard) {
2637                                 Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2638                                 packagesUnavailable.add(pkg);
2639                             } else {
2640                                 Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2641                                 packagesRemoved.add(pkg);
2642                             }
2643                         }
2644                     }
2645                     if (!packagesRemoved.isEmpty()) {
2646                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2647                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2648                     }
2649                     if (!packagesUnavailable.isEmpty()) {
2650                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
<abbr title="2651                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));">2651                                 packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user🔵</abbr>
2652                     }
2653                 }
2654                 sPendingPackages.clear();
2655             }
2656         }
2657     }
2658 
2659     private class PackageUpdatedTask implements Runnable {
2660         int mOp;
2661 
2662         String[] mPackages;
2663 
2664         UserHandleCompat mUser;
2665 
2666         public static final int OP_NONE = 0;
2667 
2668         public static final int OP_ADD = 1;
2669 
2670         public static final int OP_UPDATE = 2;
2671 
2672         // uninstlled
2673         public static final int OP_REMOVE = 3; // uninstlled
2674 
2675         // external media unmounted
2676         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2677 
2678         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
2679             mOp = op;
2680             mPackages = packages;
2681             mUser = user;
2682         }
2683 
2684         public void run() {
2685             if (!mHasLoaderCompletedOnce) {
2686                 // Loader has not yet run.
2687                 return;
2688             }
2689             final Context context = mApp.getContext();
2690             final String[] packages = mPackages;
2691             final int N = packages.length;
2692             switch (mOp) {
2693                 case OP_ADD :
2694                     {
2695                         for (int i = 0; i &lt; N; i++) {
2696                             if (DEBUG_LOADERS) {
2697                                 Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2698                             }
2699                             mIconCache.updateIconsForPkg(packages[i], mUser);
2700                             mBgAllAppsList.addPackage(context, packages[i], mUser);
2701                         }
2702                         ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
2703                         if (heuristic != null) {
2704                             heuristic.processPackageAdd(mPackages);
2705                         }
2706                         break;
2707                     }
2708                 case OP_UPDATE :
2709                     for (int i = 0; i &lt; N; i++) {
2710                         if (DEBUG_LOADERS) {
2711                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2712                         }
2713                         mIconCache.updateIconsForPkg(packages[i], mUser);
2714                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
2715                         mApp.getWidgetCache().removePackage(packages[i], mUser);
2716                     }
2717                     break;
2718                 case OP_REMOVE :
2719                     {
2720                         ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);
2721                         if (heuristic != null) {
2722                             heuristic.processPackageRemoved(mPackages);
2723                         }
2724                         for (int i = 0; i &lt; N; i++) {
2725                             if (DEBUG_LOADERS) {
2726                                 Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2727                             }
2728                             mIconCache.removeIconsForPkg(packages[i], mUser);
2729                         }
2730                     // Fall through
2731                     }
2732                 case OP_UNAVAILABLE :
2733                     for (int i = 0; i &lt; N; i++) {
2734                         if (DEBUG_LOADERS) {
2735                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2736                         }
2737                         mBgAllAppsList.removePackage(packages[i], mUser);
2738                         mApp.getWidgetCache().removePackage(packages[i], mUser);
2739                     }
2740                     break;
2741             }
2742             ArrayList&lt;AppInfo&gt; added = null;
2743             ArrayList&lt;AppInfo&gt; modified = null;
2744             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2745             if (mBgAllAppsList.added.size() &gt; 0) {
2746                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2747                 mBgAllAppsList.added.clear();
2748             }
2749             if (mBgAllAppsList.modified.size() &gt; 0) {
2750                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2751                 mBgAllAppsList.modified.clear();
2752             }
2753             if (mBgAllAppsList.removed.size() &gt; 0) {
2754                 removedApps.addAll(mBgAllAppsList.removed);
2755                 mBgAllAppsList.removed.clear();
2756             }
2757             final Callbacks callbacks = getCallback();
2758             if (callbacks == null) {
2759                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2760                 return;
2761             }
<abbr title="2762             final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps = new HashMap&lt;ComponentName, AppInfo&gt;();">2762             final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps = new HashMap&lt;ComponentName, AppInfo🔵</abbr>
2763             if (added != null) {
2764                 addAppsToAllApps(context, added);
2765                 for (AppInfo ai : added) {
2766                     addedOrUpdatedApps.put(ai.componentName, ai);
2767                 }
2768             }
2769             if (modified != null) {
2770                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2771                 for (AppInfo ai : modified) {
2772                     addedOrUpdatedApps.put(ai.componentName, ai);
2773                 }
2774                 mHandler.post(new Runnable() {
2775                     public void run() {
2776                         Callbacks cb = getCallback();
2777                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2778                             callbacks.bindAppsUpdated(modifiedFinal);
2779                         }
2780                     }
2781                 });
2782             }
2783             // Update shortcut infos
2784             if ((mOp == OP_ADD) || (mOp == OP_UPDATE)) {
2785                 final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
2786                 final ArrayList&lt;ShortcutInfo&gt; removedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
2787                 final ArrayList&lt;LauncherAppWidgetInfo&gt; widgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2788                 HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
2789                 synchronized(sBgLock) {
2790                     for (ItemInfo info : sBgItemsIdMap) {
2791                         if ((info instanceof ShortcutInfo) &amp;&amp; mUser.equals(info.user)) {
2792                             ShortcutInfo si = ((ShortcutInfo) (info));
2793                             boolean infoUpdated = false;
2794                             boolean shortcutUpdated = false;
2795                             // Update shortcuts which use iconResource.
<abbr title="2796                             if ((si.iconResource != null) &amp;&amp; packageSet.contains(si.iconResource.packageName)) {">2796                             if ((si.iconResource != null) &amp;&amp; packageSet.contains(si.iconResource.packageN🔵</abbr>
<abbr title="2797                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName, si.iconResource.resourceName, context);">2797                                 Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName, si.🔵</abbr>
2798                                 if (icon != null) {
2799                                     si.setIcon(icon);
2800                                     si.usingFallbackIcon = false;
2801                                     infoUpdated = true;
2802                                 }
2803                             }
2804                             ComponentName cn = si.getTargetComponent();
2805                             if ((cn != null) &amp;&amp; packageSet.contains(cn.getPackageName())) {
2806                                 AppInfo appInfo = addedOrUpdatedApps.get(cn);
2807                                 if (si.isPromise()) {
2808                                     if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
2809                                         // Auto install icon
2810                                         PackageManager pm = context.getPackageManager();
<abbr title="2811                                         ResolveInfo matched = pm.resolveActivity(new Intent(Intent.ACTION_MAIN).setComponent(cn).addCategory(Intent.CATEGORY_LAUNCHER), PackageManager.MATCH_DEFAULT_ONLY);">2811                                         ResolveInfo matched = pm.resolveActivity(new Intent(Intent.ACTION🔵</abbr>
2812                                         if (matched == null) {
2813                                             // Try to find the best match activity.
<abbr title="2814                                             Intent intent = pm.getLaunchIntentForPackage(cn.getPackageName());">2814                                             Intent intent = pm.getLaunchIntentForPackage(cn.getPackageNam🔵</abbr>
2815                                             if (intent != null) {
2816                                                 cn = intent.getComponent();
2817                                                 appInfo = addedOrUpdatedApps.get(cn);
2818                                             }
2819                                             if ((intent == null) || (appInfo == null)) {
2820                                                 removedShortcuts.add(si);
2821                                                 continue;
2822                                             }
2823                                             si.promisedIntent = intent;
2824                                         }
2825                                     }
2826                                     // Restore the shortcut.
2827                                     if (appInfo != null) {
2828                                         si.flags = appInfo.flags;
2829                                     }
2830                                     si.intent = si.promisedIntent;
2831                                     si.promisedIntent = null;
2832                                     si.status = ShortcutInfo.DEFAULT;
2833                                     infoUpdated = true;
2834                                     si.updateIcon(mIconCache);
2835                                 }
<abbr title="2836                                 if (((appInfo != null) &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction())) &amp;&amp; (si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION)) {">2836                                 if (((appInfo != null) &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction()🔵</abbr>
2837                                     si.updateIcon(mIconCache);
2838                                     si.title = Utilities.trim(appInfo.title);
2839                                     si.contentDescription = appInfo.contentDescription;
2840                                     infoUpdated = true;
2841                                 }
2842                                 if ((si.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE) != 0) {
2843                                     // Since package was just updated, the target must be available now.
2844                                     si.isDisabled &amp;= ~ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2845                                     shortcutUpdated = true;
2846                                 }
2847                             }
2848                             if (infoUpdated || shortcutUpdated) {
2849                                 updatedShortcuts.add(si);
2850                             }
2851                             if (infoUpdated) {
2852                                 updateItemInDatabase(context, si);
2853                             }
2854                         } else if (info instanceof LauncherAppWidgetInfo) {
2855                             LauncherAppWidgetInfo widgetInfo = ((LauncherAppWidgetInfo) (info));
<abbr title="2856                             if ((mUser.equals(widgetInfo.user) &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) &amp;&amp; packageSet.contains(widgetInfo.providerName.getPackageName())) {">2856                             if ((mUser.equals(widgetInfo.user) &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWi🔵</abbr>
<abbr title="2857                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">2857                                 widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READ🔵</abbr>
2858                                 widgets.add(widgetInfo);
2859                                 updateItemInDatabase(context, widgetInfo);
2860                             }
2861                         }
2862                     }
2863                 }
2864                 if ((!updatedShortcuts.isEmpty()) || (!removedShortcuts.isEmpty())) {
2865                     mHandler.post(new Runnable() {
2866                         public void run() {
2867                             Callbacks cb = getCallback();
2868                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
<abbr title="2869                                 callbacks.bindShortcutsChanged(updatedShortcuts, removedShortcuts, mUser);">2869                                 callbacks.bindShortcutsChanged(updatedShortcuts, removedShortcuts, mUser)🔵</abbr>
2870                             }
2871                         }
2872                     });
2873                     if (!removedShortcuts.isEmpty()) {
2874                         deleteItemsFromDatabase(context, removedShortcuts);
2875                     }
2876                 }
2877                 if (!widgets.isEmpty()) {
2878                     mHandler.post(new Runnable() {
2879                         public void run() {
2880                             Callbacks cb = getCallback();
2881                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
2882                                 callbacks.bindWidgetsRestored(widgets);
2883                             }
2884                         }
2885                     });
2886                 }
2887             }
2888             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2889             if ((mOp == OP_REMOVE) || (mOp == OP_UNAVAILABLE)) {
2890                 // Mark all packages in the broadcast to be removed
2891                 removedPackageNames.addAll(Arrays.asList(packages));
2892             } else if (mOp == OP_UPDATE) {
2893                 // Mark disabled packages in the broadcast to be removed
2894                 for (int i = 0; i &lt; N; i++) {
2895                     if (isPackageDisabled(context, packages[i], mUser)) {
2896                         removedPackageNames.add(packages[i]);
2897                     }
2898                 }
2899             }
2900             if ((!removedPackageNames.isEmpty()) || (!removedApps.isEmpty())) {
2901                 final int removeReason;
2902                 if (mOp == OP_UNAVAILABLE) {
2903                     removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2904                 } else {
2905                     // Remove all the components associated with this package
2906                     for (String pn : removedPackageNames) {
2907                         deletePackageFromDatabase(context, pn, mUser);
2908                     }
2909                     // Remove all the specific components
2910                     for (AppInfo a : removedApps) {
2911                         ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
2912                         deleteItemsFromDatabase(context, infos);
2913                     }
2914                     removeReason = 0;
2915                 }
2916                 // Remove any queued items from the install queue
2917                 InstallShortcutReceiver.removeFromInstallQueue(context, removedPackageNames, mUser);
2918                 // Call the components-removed callback
2919                 mHandler.post(new Runnable() {
2920                     public void run() {
2921                         Callbacks cb = getCallback();
2922                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
<abbr title="2923                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser, removeReason);">2923                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser, remo🔵</abbr>
2924                         }
2925                     }
2926                 });
2927             }
2928             // onProvidersChanged method (API &gt;= 17) already refreshed the widget list
2929             loadAndBindWidgetsAndShortcuts(context, callbacks, Build.VERSION.SDK_INT &lt; 17);
2930             // Write all the logs to disk
2931             mHandler.post(new Runnable() {
2932                 public void run() {
2933                     Callbacks cb = getCallback();
2934                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2935                         callbacks.dumpLogsToLocalData();
2936                     }
2937                 }
2938             });
2939         }
2940     }
2941 
2942     public static List&lt;LauncherAppWidgetProviderInfo&gt; getWidgetProviders(Context context,
2943             boolean refresh) {
2944         ArrayList&lt;LauncherAppWidgetProviderInfo&gt; results =
2945                 new ArrayList&lt;LauncherAppWidgetProviderInfo&gt;();
2946         try {
2947             synchronized (sBgLock) {
2948                 if (sBgWidgetProviders == null || refresh) {
2949                     HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; tmpWidgetProviders
2950                             = new HashMap&lt;&gt;();
2951                     AppWidgetManagerCompat wm = AppWidgetManagerCompat.getInstance(context);
2952                     LauncherAppWidgetProviderInfo info;
2953 
2954                     List&lt;AppWidgetProviderInfo&gt; widgets = wm.getAllProviders();
2955                     for (AppWidgetProviderInfo pInfo : widgets) {
2956                         info = LauncherAppWidgetProviderInfo.fromProviderInfo(context, pInfo);
2957                         UserHandleCompat user = wm.getUser(info);
2958                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
2959                     }
2960 
2961                     Collection&lt;CustomAppWidget&gt; customWidgets = Launcher.getCustomAppWidgets().values();
2962                     for (CustomAppWidget widget : customWidgets) {
2963                         info = new LauncherAppWidgetProviderInfo(context, widget);
2964                         UserHandleCompat user = wm.getUser(info);
2965                         tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
2966                     }
2967                     // Replace the global list at the very end, so that if there is an exception,
2968                     // previously loaded provider list is used.
2969                     sBgWidgetProviders = tmpWidgetProviders;
2970                 }
2971                 results.addAll(sBgWidgetProviders.values());
2972                 return results;
2973             }
2974         } catch (Exception e) {
2975             if (e.getCause() instanceof TransactionTooLargeException) {
2976                 // the returned value may be incomplete and will not be refreshed until the next
2977                 // time Launcher starts.
2978                 // TODO: after figuring out a repro step, introduce a dirty bit to check when
2979                 // onResume is called to refresh the widget provider list.
2980                 synchronized (sBgLock) {
2981                     if (sBgWidgetProviders != null) {
2982                         results.addAll(sBgWidgetProviders.values());
2983                     }
2984                     return results;
2985                 }
2986             } else {
2987                 throw e;
2988             }
2989         }
2990     }
2991 
2992     public static LauncherAppWidgetProviderInfo getProviderInfo(Context ctx, ComponentName name,
2993             UserHandleCompat user) {
2994         synchronized (sBgLock) {
2995             if (sBgWidgetProviders == null) {
2996                 getWidgetProviders(ctx, false /* refresh */);
2997             }
2998             return sBgWidgetProviders.get(new ComponentKey(name, user));
2999         }
3000     }
3001 
<abbr title="3002     public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks, final boolean refresh) {">3002     public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks, final bo🔵</abbr>
3003         runOnWorkerThread(new Runnable() {
3004             @Override
3005             public void run() {
3006                 updateWidgetsModel(context, refresh);
3007                 final WidgetsModel model = mBgWidgetsModel.clone();
3008                 mHandler.post(new Runnable() {
3009                     @Override
3010                     public void run() {
3011                         Callbacks cb = getCallback();
3012                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
3013                             callbacks.bindAllPackages(model);
3014                         }
3015                     }
3016                 });
3017                 // update the Widget entries inside DB on the worker thread.
<abbr title="3018                 LauncherAppState.getInstance().getWidgetCache().removeObsoletePreviews(model.getRawList());">3018                 LauncherAppState.getInstance().getWidgetCache().removeObsoletePreviews(model.getRawList()🔵</abbr>
3019             }
3020         });
3021     }
3022 
3023     /**
3024      * Returns a list of ResolveInfos/AppWidgetInfos.
3025      *
3026      * @see #loadAndBindWidgetsAndShortcuts
3027      */
3028     @Thunk
3029     void updateWidgetsModel(Context context, boolean refresh) {
3030         PackageManager packageManager = context.getPackageManager();
3031         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3032         widgetsAndShortcuts.addAll(getWidgetProviders(context, refresh));
3033         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3034         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3035         mBgWidgetsModel.setWidgetsAndShortcuts(widgetsAndShortcuts);
3036     }
3037 
3038     @Thunk
3039     static boolean isPackageDisabled(Context context, String packageName, UserHandleCompat user) {
3040         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3041         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3042     }
3043 
3044     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3045             UserHandleCompat user) {
3046         if (cn == null) {
3047             return false;
3048         }
3049         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3050         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3051             return false;
3052         }
3053         return launcherApps.isActivityEnabledForProfile(cn, user);
3054     }
3055 
3056     public static boolean isValidPackage(Context context, String packageName,
3057             UserHandleCompat user) {
3058         if (packageName == null) {
3059             return false;
3060         }
3061         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3062         return launcherApps.isPackageEnabledForProfile(packageName, user);
3063     }
3064 
3065     /**
3066      * Make an ShortcutInfo object for a restored application or shortcut item that points
3067      * to a package that is not yet installed on the system.
3068      */
<abbr title="3069     public ShortcutInfo getRestoredItemInfo(Cursor c, int titleIndex, Intent intent, int promiseType, int itemType, CursorIconInfo iconInfo, Context context) {">3069     public ShortcutInfo getRestoredItemInfo(Cursor c, int titleIndex, Intent intent, int promiseType, int🔵</abbr>
3070         final ShortcutInfo info = new ShortcutInfo();
3071         info.user = UserHandleCompat.myUserHandle();
3072         Bitmap icon = iconInfo.loadIcon(c, info, context);
3073         // the fallback icon
3074         if (icon == null) {
3075             /* useLowResIcon */
3076             mIconCache.getTitleAndIcon(info, intent, info.user, false);
3077         } else {
3078             info.setIcon(icon);
3079         }
3080         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3081             String title = (c != null) ? c.getString(titleIndex) : null;
3082             if (!TextUtils.isEmpty(title)) {
3083                 info.title = Utilities.trim(title);
3084             }
3085         } else if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3086             if (TextUtils.isEmpty(info.title)) {
3087                 info.title = (c != null) ? Utilities.trim(c.getString(titleIndex)) : &quot;&quot;;
3088             }
3089         } else {
3090             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3091         }
3092         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3093         info.itemType = itemType;
3094         info.promisedIntent = intent;
3095         info.status = promiseType;
3096         return info;
3097     }
3098 
3099     /**
3100      * Make an Intent object for a restored application or shortcut item that points
3101      * to the market page for the item.
3102      */
3103     @Thunk
3104     Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3105         ComponentName componentName = intent.getComponent();
3106         return getMarketIntent(componentName.getPackageName());
3107     }
3108 
3109     static Intent getMarketIntent(String packageName) {
3110         return new Intent(Intent.ACTION_VIEW)
3111             .setData(new Uri.Builder()
3112                 .scheme(&quot;market&quot;)
3113                 .authority(&quot;details&quot;)
3114                 .appendQueryParameter(&quot;id&quot;, packageName)
3115                 .build());
3116     }
3117 
3118     /**
3119      * Make an ShortcutInfo object for a shortcut that is an application.
3120      *
3121      * If c is not null, then it will be used to fill in missing data like the title and icon.
3122      */
<abbr title="3123     public ShortcutInfo getAppShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex, boolean allowMissingTarget, boolean useLowResIcon) {">3123     public ShortcutInfo getAppShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, 🔵</abbr>
3124         if (user == null) {
3125             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3126             return null;
3127         }
3128         ComponentName componentName = intent.getComponent();
3129         if (componentName == null) {
3130             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3131             return null;
3132         }
3133         Intent newIntent = new Intent(intent.getAction(), null);
3134         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3135         newIntent.setComponent(componentName);
3136         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3137         if ((lai == null) &amp;&amp; (!allowMissingTarget)) {
3138             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3139             return null;
3140         }
3141         final ShortcutInfo info = new ShortcutInfo();
3142         mIconCache.getTitleAndIcon(info, componentName, lai, user, false, useLowResIcon);
3143         if (mIconCache.isDefaultIcon(info.getIcon(mIconCache), user) &amp;&amp; (c != null)) {
3144             Bitmap icon = Utilities.createIconBitmap(c, iconIndex, context);
3145             info.setIcon(icon == null ? mIconCache.getDefaultIcon(user) : icon);
3146         }
3147         // from the db
3148         if (TextUtils.isEmpty(info.title) &amp;&amp; (c != null)) {
3149             info.title = Utilities.trim(c.getString(titleIndex));
3150         }
3151         // fall back to the class name of the activity
3152         if (info.title == null) {
3153             info.title = componentName.getClassName();
3154         }
3155         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3156         info.user = user;
3157         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3158         if (lai != null) {
3159             info.flags = AppInfo.initFlags(lai);
3160         }
3161         return info;
3162     }
3163 
3164     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Iterable&lt;ItemInfo&gt; infos, ItemInfoFilter f) {
3165         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3166         for (ItemInfo i : infos) {
3167             if (i instanceof ShortcutInfo) {
3168                 ShortcutInfo info = ((ShortcutInfo) (i));
3169                 ComponentName cn = info.getTargetComponent();
3170                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
3171                     filtered.add(info);
3172                 }
3173             } else if (i instanceof FolderInfo) {
3174                 FolderInfo info = ((FolderInfo) (i));
3175                 for (ShortcutInfo s : info.contents) {
3176                     ComponentName cn = s.getTargetComponent();
3177                     if ((cn != null) &amp;&amp; f.filterItem(info, s, cn)) {
3178                         filtered.add(s);
3179                     }
3180                 }
3181             } else if (i instanceof LauncherAppWidgetInfo) {
3182                 LauncherAppWidgetInfo info = ((LauncherAppWidgetInfo) (i));
3183                 ComponentName cn = info.providerName;
3184                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
3185                     filtered.add(info);
3186                 }
3187             }
3188         }
3189         return new ArrayList&lt;ItemInfo&gt;(filtered);
3190     }
3191 
3192     @Thunk
<abbr title="3193     ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCompat user) {">3193     ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCompat use🔵</abbr>
3194         ItemInfoFilter filter = new ItemInfoFilter() {
3195             @Override
3196             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3197                 if (info.user == null) {
3198                     return cn.equals(cname);
3199                 } else {
3200                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3201                 }
3202             }
3203         };
3204         return filterItemInfos(sBgItemsIdMap, filter);
3205     }
3206 
3207     /**
3208      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3209      */
3210     @Thunk
3211     ShortcutInfo getShortcutInfo(Cursor c, Context context, int titleIndex, CursorIconInfo iconInfo) {
3212         final ShortcutInfo info = new ShortcutInfo();
3213         // Non-app shortcuts are only supported for current user.
3214         info.user = UserHandleCompat.myUserHandle();
3215         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3216         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3217         info.title = Utilities.trim(c.getString(titleIndex));
3218         Bitmap icon = iconInfo.loadIcon(c, info, context);
3219         // the fallback icon
3220         if (icon == null) {
3221             icon = mIconCache.getDefaultIcon(info.user);
3222             info.usingFallbackIcon = true;
3223         }
3224         info.setIcon(icon);
3225         return info;
3226     }
3227 
3228     ShortcutInfo infoFromShortcutIntent(Context context, Intent data) {
3229         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3230         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3231         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3232         if (intent == null) {
3233             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3234             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3235             return null;
3236         }
3237         Bitmap icon = null;
3238         boolean customIcon = false;
3239         ShortcutIconResource iconResource = null;
3240         if (bitmap instanceof Bitmap) {
3241             icon = Utilities.createIconBitmap(((Bitmap) (bitmap)), context);
3242             customIcon = true;
3243         } else {
3244             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3245             if (extra instanceof ShortcutIconResource) {
3246                 iconResource = ((ShortcutIconResource) (extra));
<abbr title="3247                 icon = Utilities.createIconBitmap(iconResource.packageName, iconResource.resourceName, context);">3247                 icon = Utilities.createIconBitmap(iconResource.packageName, iconResource.resourceName, co🔵</abbr>
3248             }
3249         }
3250         final ShortcutInfo info = new ShortcutInfo();
3251         // Only support intents for current user for now. Intents sent from other
3252         // users wouldn&#x27;t get here without intent forwarding anyway.
3253         info.user = UserHandleCompat.myUserHandle();
3254         if (icon == null) {
3255             icon = mIconCache.getDefaultIcon(info.user);
3256             info.usingFallbackIcon = true;
3257         }
3258         info.setIcon(icon);
3259         info.title = Utilities.trim(name);
3260         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);
3261         info.intent = intent;
3262         info.customIcon = customIcon;
3263         info.iconResource = iconResource;
3264         return info;
3265     }
3266 
3267     /**
3268      * Return an existing FolderInfo object if we have encountered this ID previously,
3269      * or make a new one.
3270      */
3271     @Thunk
3272     static FolderInfo findOrMakeFolder(LongArrayMap&lt;FolderInfo&gt; folders, long id) {
3273         // See if a placeholder was created for us already
3274         FolderInfo folderInfo = folders.get(id);
3275         if (folderInfo == null) {
3276             // No placeholder -- create a new instance
3277             folderInfo = new FolderInfo();
3278             folders.put(id, folderInfo);
3279         }
3280         return folderInfo;
3281     }
3282 
3283     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3284         return (provider != null) &amp;&amp; (provider.provider != null)
3285                 &amp;&amp; (provider.provider.getPackageName() != null);
3286     }
3287 
3288     public void dumpState() {
3289         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3290         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3291         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3292         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3293         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3294         if (mLoaderTask != null) {
3295             mLoaderTask.dumpState();
3296         } else {
3297             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3298         }
3299     }
3300 
3301     public Callbacks getCallback() {
3302         return mCallbacks != null ? mCallbacks.get() : null;
3303     }
3304 
3305     /**
3306      * @return {@link FolderInfo} if its already loaded.
3307      */
3308     public FolderInfo findFolderById(Long folderId) {
3309         synchronized(sBgLock) {
3310             return sBgFolders.get(folderId);
3311         }
3312     }
3313 
3314     /**
3315      * @return the looper for the worker thread which can be used to start background tasks.
3316      */
3317     public static Looper getWorkerLooper() {
3318         return sWorkerThread.getLooper();
3319     }
3320 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetProviderInfo;
  21  import android.content.BroadcastReceiver;
  22  import android.content.ComponentName;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import android.content.ContentProviderClient;</span>
  24  import android.content.ContentProviderOperation;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.IntentFilter;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import android.content.SharedPreferences;</span>
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.ProviderInfo;
  34  import android.content.pm.ResolveInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import android.content.res.Configuration;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  36 -import android.content.res.Resources;</span>
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  39 -import android.graphics.BitmapFactory;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import android.graphics.Rect;</span>
  41  import android.net.Uri;
  42  import android.os.Build;
  43  import android.os.Environment;
  44  import android.os.Handler;
  45  import android.os.HandlerThread;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import android.os.Looper;</span>
  47  import android.os.Parcelable;
  48  import android.os.Process;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import android.os.RemoteException;</span>
  50  import android.os.SystemClock;
  51  import android.os.TransactionTooLargeException;
  52  import android.provider.BaseColumns;
  53  import android.text.TextUtils;
  54  import android.util.Log;
  55  import android.util.LongSparseArray;
  56  import android.util.Pair;
  57  
  58  import com.android.launcher3.compat.AppWidgetManagerCompat;
  59  import com.android.launcher3.compat.LauncherActivityInfoCompat;
  60  import com.android.launcher3.compat.LauncherAppsCompat;
  61  import com.android.launcher3.compat.PackageInstallerCompat;
  62  import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  63  import com.android.launcher3.compat.UserHandleCompat;
  64  import com.android.launcher3.compat.UserManagerCompat;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import com.android.launcher3.model.WidgetsModel;</span>
  66  import com.android.launcher3.util.ComponentKey;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +import com.android.launcher3.util.CursorIconInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +import com.android.launcher3.util.LongArrayMap;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import com.android.launcher3.util.ManagedProfileHeuristic;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +import com.android.launcher3.util.Thunk;</span>
  71  
  72  import java.lang.ref.WeakReference;
  73  import java.net.URISyntaxException;
  74  import java.security.InvalidParameterException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -import java.text.Collator;</span>
  76  import java.util.ArrayList;
  77  import java.util.Arrays;
  78  import java.util.Collection;
  79  import java.util.Collections;
  80  import java.util.Comparator;
  81  import java.util.HashMap;
  82  import java.util.HashSet;
  83  import java.util.Iterator;
  84  import java.util.List;
  85  import java.util.Map.Entry;
  86  import java.util.Set;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -import java.util.TreeMap;</span>
  88  
  89  /**
  90   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  91   * LauncherModel object held in a static. Also provide APIs for updating the database state
  92   * for the Launcher.
  93   */
  94  public class LauncherModel extends BroadcastReceiver
  95          implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  96      static final boolean DEBUG_LOADERS = false;
  97      private static final boolean DEBUG_RECEIVER = false;
  98      private static final boolean REMOVE_UNRESTORED_ICONS = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -    private static final boolean ADD_MANAGED_PROFILE_SHORTCUTS = false;</span>
 100  
 101      static final String TAG = &quot;Launcher.Model&quot;;
 102  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -    // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -    // false = strew non-workspace apps across the workspace on upgrade</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -    public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;</span>
 106      public static final int LOADER_FLAG_NONE = 0;
 107      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 108      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 109  
 110      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 111      private static final long INVALID_SCREEN_ID = -1L;
 112  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -    private final boolean mAppsCanBeOnRemoveableStorage;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +    @Thunk final boolean mAppsCanBeOnRemoveableStorage;</span>
 115      private final boolean mOldContentProviderExists;
 116  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -    private final LauncherAppState mApp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -    private final Object mLock = new Object();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -    private DeferredHandler mHandler = new DeferredHandler();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -    private LoaderTask mLoaderTask;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -    private boolean mIsLoaderTaskRunning;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -     * Maintain a set of packages per user, for which we added a shortcut on the workspace.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -    private static final String INSTALLED_SHORTCUTS_SET_PREFIX = &quot;installed_shortcuts_set_for_user_&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -    // Specific runnable types that are run on the main thread deferred handler, this allows us to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -    // clear all queued binding runnables when the Launcher activity is destroyed.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -    private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -    private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +    @Thunk final LauncherAppState mApp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    @Thunk final Object mLock = new Object();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    @Thunk DeferredHandler mHandler = new DeferredHandler();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    @Thunk LoaderTask mLoaderTask;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +    @Thunk boolean mIsLoaderTaskRunning;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +    @Thunk boolean mHasLoaderCompletedOnce;</span>
 138  
 139      private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 140  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -    private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +    @Thunk static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);</span>
 143      static {
 144          sWorkerThread.start();
 145      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -    private static final Handler sWorker = new Handler(sWorkerThread.getLooper());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    @Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper());</span>
 148  
 149      // We start off with everything not loaded.  After that, we assume that
 150      // our monitoring of the package manager provides all updates and we never
 151      // need to do a requery.  These are only ever touched from the loader thread.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -    private boolean mWorkspaceLoaded;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -    private boolean mAllAppsLoaded;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    @Thunk boolean mWorkspaceLoaded;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +    @Thunk boolean mAllAppsLoaded;</span>
 156  
 157      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 158      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 159      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 160      // a normal load, we also clear this set of Runnables.
 161      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 162  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -    private WeakReference&lt;Callbacks&gt; mCallbacks;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +     * Set of runnables to be called on the background thread after the workspace binding</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +     * is complete.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +    static final ArrayList&lt;Runnable&gt; mBindCompleteRunnables = new ArrayList&lt;Runnable&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +    @Thunk WeakReference&lt;Callbacks&gt; mCallbacks;</span>
 171  
 172      // &lt; only access in worker thread &gt;
 173      AllAppsList mBgAllAppsList;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +    // Entire list of widgets.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +    WidgetsModel mBgWidgetsModel;</span>
 176  
 177      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 178      // other locks, this one can generally be held long-term because we never expect any of these
 179      // static data structures to be referenced outside of the worker thread except on the first
 180      // load after configuration change.
 181      static final Object sBgLock = new Object();
 182  
 183      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 184      // LauncherModel to their ids
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -    static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +    static final LongArrayMap&lt;ItemInfo&gt; sBgItemsIdMap = new LongArrayMap&lt;&gt;();</span>
 187  
 188      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 189      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 190      //       shortcuts within folders).
 191      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 192  
 193      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 194      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 195          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 196  
 197      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -    static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -    // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -    static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +    static final LongArrayMap&lt;FolderInfo&gt; sBgFolders = new LongArrayMap&lt;&gt;();</span>
 203  
 204      // sBgWorkspaceScreens is the ordered set of workspace screens.
 205      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 206  
 207      // sBgWidgetProviders is the set of widget providers including custom internal widgets
 208      public static HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; sBgWidgetProviders;
 209  
 210      // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 211      static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 212              new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 213  
 214      // &lt;/ only access in worker thread &gt;
 215  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 216 -    private IconCache mIconCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -    protected int mPreviousConfigMcc;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -    private final LauncherAppsCompat mLauncherApps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -    private final UserManagerCompat mUserManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +    @Thunk IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +    @Thunk final LauncherAppsCompat mLauncherApps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +    @Thunk final UserManagerCompat mUserManager;</span>
 226  
 227      public interface Callbacks {
 228          public boolean setLoadOnResume();
 229          public int getCurrentWorkspaceScreen();
 230          public void startBinding();
 231          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 232                                boolean forceAnimateIcons);
 233          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 234          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -        public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -        public void finishBindingItems(boolean upgradePath);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +        public void bindFolders(LongArrayMap&lt;FolderInfo&gt; folders);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +        public void finishBindingItems();</span>
 239          public void bindAppWidget(LauncherAppWidgetInfo info);
 240          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 241          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 242                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 243                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 244                                    ArrayList&lt;AppInfo&gt; addedApps);
 245          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 246          public void bindShortcutsChanged(ArrayList&lt;ShortcutInfo&gt; updated,
 247                  ArrayList&lt;ShortcutInfo&gt; removed, UserHandleCompat user);
 248          public void bindWidgetsRestored(ArrayList&lt;LauncherAppWidgetInfo&gt; widgets);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -        public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -        public void updatePackageBadge(String packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +        public void bindRestoreItemsChange(HashSet&lt;ItemInfo&gt; updates);</span>
 252          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 253                          ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -        public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +        public void bindAllPackages(WidgetsModel model);</span>
 256          public void bindSearchablesChanged();
 257          public boolean isAllAppsButtonRank(int rank);
 258          public void onPageBoundSynchronously(int page);
 259          public void dumpLogsToLocalData();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -        public void bindAddPendingItem(PendingAddItemInfo info, long container, long screenId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -                int[] cell, int spanX, int spanY);</span>
 262      }
 263  
 264      public interface ItemInfoFilter {
 265          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -    public interface ScreenPosProvider {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -        int getScreenIndex(ArrayList&lt;Long&gt; screenIDs);</span>
 270      }
 271  
 272      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 273          Context context = app.getContext();
 274  
 275          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 276          String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 277          // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 278          // resource string.
 279          String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 280          ProviderInfo providerInfo =
 281                  context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 282          ProviderInfo redirectProvider =
 283                  context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 284  
 285          Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 286          mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 287  
 288          if (mOldContentProviderExists) {
 289              Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 290          } else {
 291              Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 292          }
 293  
 294          mApp = app;
 295          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +        mBgWidgetsModel = new WidgetsModel(context, iconCache, appFilter);</span>
 297          mIconCache = iconCache;
 298  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 299 -        final Resources res = context.getResources();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 300 -        Configuration config = res.getConfiguration();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -        mPreviousConfigMcc = config.mcc;</span>
 302          mLauncherApps = LauncherAppsCompat.getInstance(context);
 303          mUserManager = UserManagerCompat.getInstance(context);
 304      }
 305  
 306      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 307       * posted on the main thread handler. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -    private void runOnMainThread(Runnable r) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 309 -        runOnMainThread(r, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 310 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 311 -    private void runOnMainThread(Runnable r, int type) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +    @Thunk void runOnMainThread(Runnable r) {</span>
 313          if (sWorkerThread.getThreadId() == Process.myTid()) {
 314              // If we are on the worker thread, post onto the main handler
 315              mHandler.post(r);
 316          } else {
 317              r.run();
 318          }
 319      }
 320  
 321      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 322       * posted on the worker thread handler. */
 323      private static void runOnWorkerThread(Runnable r) {
 324          if (sWorkerThread.getThreadId() == Process.myTid()) {
 325              r.run();
 326          } else {
 327              // If we are not on the worker thread, then post to the worker handler
 328              sWorker.post(r);
 329          }
 330      }
 331  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +     * Runs the specified runnable after the loader is complete</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +    @Thunk void runAfterBindCompletes(Runnable r) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +        if (isLoadingWorkspace() || !mHasLoaderCompletedOnce) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +            synchronized (mBindCompleteRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +                mBindCompleteRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +            runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +</span>
 345      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 346          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 347      }
 348  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 349 -    public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 350 -        // Process the updated package state</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 351 -        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +    public void setPackageState(final PackageInstallInfo installInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +        Runnable updateRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +            @Override</span>
 356              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -                Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -                if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -                    callbacks.updatePackageState(installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +                    final HashSet&lt;ItemInfo&gt; updates = new HashSet&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +                    if (installInfo.state == PackageInstallerCompat.STATUS_INSTALLED) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +                        // Ignore install success events as they are handled by Package add events.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +                        return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +                    for (ItemInfo info : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +                        if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +                            ComponentName cn = si.getTargetComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +                            if (si.isPromise() &amp;&amp; (cn != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +                                    &amp;&amp; installInfo.packageName.equals(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +                                si.setInstallProgress(installInfo.progress);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +                                if (installInfo.state == PackageInstallerCompat.STATUS_FAILED) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +                                    // Mark this info as broken.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +                                    si.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +                                updates.add(si);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +                    for (LauncherAppWidgetInfo widget : sBgAppWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +                        if (widget.providerName.getPackageName().equals(installInfo.packageName)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +                            widget.installProgress = installInfo.progress;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +                            updates.add(widget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 391 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +                    if (!updates.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 393 +                        // Push changes to the callback.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 394 +                        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +                            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 396 +                                Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 397 +                                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 398 +                                    callbacks.bindRestoreItemsChange(updates);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +                        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +                        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +                    }</span>
 404                  }
 405              }
 406          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -        mHandler.post(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -    public void updatePackageBadge(final String packageName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -        // Process the updated package badge</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +        runOnWorkerThread(updateRunnable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +     * Updates the icons and label of all pending icons for the provided package name.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +    public void updateSessionDisplayInfo(final String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +        Runnable updateRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +            @Override</span>
 423              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -                Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -                if (callbacks != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -                    callbacks.updatePackageBadge(packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 427 +                synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +                    final ArrayList&lt;ShortcutInfo&gt; updates = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 429 +                    final UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +                    for (ItemInfo info : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +                        if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 433 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 434 +                            ComponentName cn = si.getTargetComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +                            if (si.isPromise() &amp;&amp; (cn != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 436 +                                    &amp;&amp; packageName.equals(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +                                if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 438 +                                    // For auto install apps update the icon as well as label.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +                                    mIconCache.getTitleAndIcon(si,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 440 +                                            si.promisedIntent, user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +                                            si.shouldUseLowResIcon());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +                                    // Only update the icon for restored apps.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +                                    si.updateIcon(mIconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 446 +                                updates.add(si);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 448 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 449 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 450 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +                    if (!updates.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +                        // Push changes to the callback.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 453 +                        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 454 +                            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 455 +                                Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 456 +                                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 457 +                                    callbacks.bindShortcutsChanged(updates,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 458 +                                            new ArrayList&lt;ShortcutInfo&gt;(), user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 459 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 460 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 461 +                        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +                        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +                    }</span>
 464                  }
 465              }
 466          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 467 -        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +        runOnWorkerThread(updateRunnable);</span>
 469      }
 470  
 471      public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 472          final Callbacks callbacks = getCallback();
 473  
 474          if (allAppsApps == null) {
 475              throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 476          }
 477          if (allAppsApps.isEmpty()) {
 478              return;
 479          }
 480  
 481          // Process the newly added applications and add them to the database first
 482          Runnable r = new Runnable() {
 483              public void run() {
 484                  runOnMainThread(new Runnable() {
 485                      public void run() {
 486                          Callbacks cb = getCallback();
 487                          if (callbacks == cb &amp;&amp; cb != null) {
 488                              callbacks.bindAppsAdded(null, null, null, allAppsApps);
 489                          }
 490                      }
 491                  });
 492              }
 493          };
 494          runOnWorkerThread(r);
 495      }
 496  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -    public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -            final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -        addAndBindAddedWorkspaceApps(context, workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -                new ScreenPosProvider() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -                    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -                    public int getScreenIndex(ArrayList&lt;Long&gt; screenIDs) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -                        return screenIDs.isEmpty() ? 0 : 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -                }, 1, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -    private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;Rect&gt; occupiedPos,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 510 +    private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; occupiedPos,</span>
 511              int[] xy, int spanX, int spanY) {
 512          LauncherAppState app = LauncherAppState.getInstance();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -        final int xCount = (int) grid.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -        final int yCount = (int) grid.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 516 +        InvariantDeviceProfile profile = app.getInvariantDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 517 +        final int xCount = (int) profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 518 +        final int yCount = (int) profile.numRows;</span>
 519          boolean[][] occupied = new boolean[xCount][yCount];
 520          if (occupiedPos != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -            for (Rect r : occupiedPos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -                for (int x = r.left; 0 &lt;= x &amp;&amp; x &lt; r.right &amp;&amp; x &lt; xCount; x++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                    for (int y = r.top; 0 &lt;= y &amp;&amp; y &lt; r.bottom &amp;&amp; y &lt; yCount; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 524 +            for (ItemInfo r : occupiedPos) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 525 +                int right = r.cellX + r.spanX;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +                int bottom = r.cellY + r.spanY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +                for (int x = r.cellX; 0 &lt;= x &amp;&amp; x &lt; right &amp;&amp; x &lt; xCount; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 528 +                    for (int y = r.cellY; 0 &lt;= y &amp;&amp; y &lt; bottom &amp;&amp; y &lt; yCount; y++) {</span>
 529                          occupied[x][y] = true;
 530                      }
 531                  }
 532              }
 533          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 534 -        return CellLayout.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 535 +        return Utilities.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);</span>
 536      }
 537  
 538      /**
 539       * Find a position on the screen for the given size or adds a new screen.
 540       * @return screenId and the coordinates for the item.
 541       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -    private static Pair&lt;Long, int[]&gt; findSpaceForItem(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 543 +    @Thunk Pair&lt;Long, int[]&gt; findSpaceForItem(</span>
 544              Context context,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -            ScreenPosProvider preferredScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -            int fallbackStartScreen,</span>
 547              ArrayList&lt;Long&gt; workspaceScreens,
 548              ArrayList&lt;Long&gt; addedWorkspaceScreensFinal,
 549              int spanX, int spanY) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -        // Load position of items which are on the desktop. We can&#x27;t use sBgItemsIdMap because</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -        // loadWorkspace() may not have been called.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -        final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 553 -        Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -                new String[] {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -                    LauncherSettings.Favorites.SCREEN,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -                    LauncherSettings.Favorites.CELLX,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -                    LauncherSettings.Favorites.CELLY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                    LauncherSettings.Favorites.SPANX,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -                    LauncherSettings.Favorites.SPANY,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -                    LauncherSettings.Favorites.CONTAINER</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -                 },</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -                 &quot;container=?&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                 new String[] { Integer.toString(LauncherSettings.Favorites.CONTAINER_DESKTOP) },</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                 null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -        final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -        final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -        final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -        final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -        final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -        LongSparseArray&lt;ArrayList&lt;Rect&gt;&gt; screenItems = new LongSparseArray&lt;ArrayList&lt;Rect&gt;&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -            while (c.moveToNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -                Rect rect = new Rect();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -                rect.left = c.getInt(cellXIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -                rect.top = c.getInt(cellYIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -                rect.right = rect.left + Math.max(1, c.getInt(spanXIndex));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -                rect.bottom = rect.top + Math.max(1, c.getInt(spanYIndex));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -                long screenId = c.getInt(screenIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -                ArrayList&lt;Rect&gt; items = screenItems.get(screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -                if (items == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -                    items = new ArrayList&lt;Rect&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -                    screenItems.put(screenId, items);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -                items.add(rect);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -            screenItems.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -        } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -            c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +        LongSparseArray&lt;ArrayList&lt;ItemInfo&gt;&gt; screenItems = new LongSparseArray&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +        // Use sBgItemsIdMap as all the items are already loaded.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +        assertWorkspaceLoaded();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +            for (ItemInfo info : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +                if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +                    ArrayList&lt;ItemInfo&gt; items = screenItems.get(info.screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +                    if (items == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +                        items = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +                        screenItems.put(info.screenId, items);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +                    items.add(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +            }</span>
 607          }
 608  
 609          // Find appropriate space for the item.
 610          long screenId = 0;
 611          int[] cordinates = new int[2];
 612          boolean found = false;
 613  
 614          int screenCount = workspaceScreens.size();
 615          // First check the preferred screen.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -        int preferredScreenIndex = preferredScreen.getScreenIndex(workspaceScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +        int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;</span>
 618          if (preferredScreenIndex &lt; screenCount) {
 619              screenId = workspaceScreens.get(preferredScreenIndex);
 620              found = findNextAvailableIconSpaceInScreen(
 621                      screenItems.get(screenId), cordinates, spanX, spanY);
 622          }
 623  
 624          if (!found) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -            // Search on any of the screens.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -            for (int screen = fallbackStartScreen; screen &lt; screenCount; screen++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 627 +            // Search on any of the screens starting from the first screen.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 628 +            for (int screen = 1; screen &lt; screenCount; screen++) {</span>
 629                  screenId = workspaceScreens.get(screen);
 630                  if (findNextAvailableIconSpaceInScreen(
 631                          screenItems.get(screenId), cordinates, spanX, spanY)) {
 632                      // We found a space for it
 633                      found = true;
 634                      break;
 635                  }
 636              }
 637          }
 638  
 639          if (!found) {
 640              // Still no position found. Add a new screen to the end.
 641              screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 642  
 643              // Save the screen id for binding in the workspace
 644              workspaceScreens.add(screenId);
 645              addedWorkspaceScreensFinal.add(screenId);
 646  
 647              // If we still can&#x27;t find an empty space, then God help us all!!!
 648              if (!findNextAvailableIconSpaceInScreen(
 649                      screenItems.get(screenId), cordinates, spanX, spanY)) {
 650                  throw new RuntimeException(&quot;Can&#x27;t find space to add the item&quot;);
 651              }
 652          }
 653          return Pair.create(screenId, cordinates);
 654      }
 655  
 656      /**
 657       * Adds the provided items to the workspace.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -     * @param preferredScreen the screen where we should try to add the app first</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -     * @param fallbackStartScreen the screen to start search for empty space if</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -     * preferredScreen is not available.</span>
 661       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -    public void addAndBindPendingItem(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -            final Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -            final PendingAddItemInfo addInfo,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -            final ScreenPosProvider preferredScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -            final int fallbackStartScreen) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -        final Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -        // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -            public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -                final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -                ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -                TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -                for (Integer i : orderedScreens.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -                    long screenId = orderedScreens.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -                    workspaceScreens.add(screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -                // Find appropriate space for the item.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -                Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, preferredScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -                        fallbackStartScreen, workspaceScreens, addedWorkspaceScreensFinal,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -                        addInfo.spanX,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -                        addInfo.spanY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -                final long screenId = coords.first;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 686 -                final int[] cordinates = coords.second;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 687 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 688 -                // Update the workspace screens</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 689 -                updateWorkspaceScreenOrder(context, workspaceScreens);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 690 -                runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 691 -                    public void run() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 692 -                        Callbacks cb = getCallback();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 693 -                        if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 694 -                            cb.bindAddScreens(addedWorkspaceScreensFinal);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 695 -                            cb.bindAddPendingItem(addInfo,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 696 -                                    LauncherSettings.Favorites.CONTAINER_DESKTOP,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 697 -                                    screenId, cordinates, addInfo.spanX, addInfo.spanY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 698 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 699 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 700 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 701 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 702 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 703 -        runOnWorkerThread(r);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 704 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 705 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 706 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 707 -     * Adds the provided items to the workspace.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 708 -     * @param preferredScreen the screen where we should try to add the app first</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 709 -     * @param fallbackStartScreen the screen to start search for empty space if</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 710 -     * preferredScreen is not available.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 711 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 712 -    public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 713 -            final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 714 -            final ScreenPosProvider preferredScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 715 -            final int fallbackStartScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 716 -            final boolean allowDuplicate) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 717 +    public void addAndBindAddedWorkspaceItems(final Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 718 +            final ArrayList&lt;? extends ItemInfo&gt; workspaceApps) {</span>
 719          final Callbacks callbacks = getCallback();
 720          if (workspaceApps.isEmpty()) {
 721              return;
 722          }
 723          // Process the newly added applications and add them to the database first
 724          Runnable r = new Runnable() {
 725              public void run() {
 726                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 727                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 728  
 729                  // Get the list of workspace screens.  We need to append to this list and
 730                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 731                  // called.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 732 -                ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 733 -                TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 734 -                for (Integer i : orderedScreens.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 735 -                    long screenId = orderedScreens.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 736 -                    workspaceScreens.add(screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 737 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 738 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 739 +                ArrayList&lt;Long&gt; workspaceScreens = loadWorkspaceScreensDb(context);</span>
 740                  synchronized(sBgLock) {
 741                      for (ItemInfo item : workspaceApps) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 742 -                        if (!allowDuplicate) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 743 +                        if (item instanceof ShortcutInfo) {</span>
 744                              // Short-circuit this logic if the icon exists somewhere on the workspace
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 745 -                            if (shortcutExists(context, item.title.toString(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -                                    item.getIntent(), item.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 747 +                            if (shortcutExists(context, item.getIntent(), item.user)) {</span>
 748                                  continue;
 749                              }
 750                          }
 751  
 752                          // Find appropriate space for the item.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 753 -                        Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, preferredScreen,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 754 -                                fallbackStartScreen, workspaceScreens, addedWorkspaceScreensFinal,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +                        Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +                                workspaceScreens, addedWorkspaceScreensFinal,</span>
 757                                  1, 1);
 758                          long screenId = coords.first;
 759                          int[] cordinates = coords.second;
 760  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 761 -                        ShortcutInfo shortcutInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 762 -                        if (item instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 763 -                            shortcutInfo = (ShortcutInfo) item;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 764 +                        ItemInfo itemInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 765 +                        if (item instanceof ShortcutInfo || item instanceof FolderInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 766 +                            itemInfo = item;</span>
 767                          } else if (item instanceof AppInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 768 -                            shortcutInfo = ((AppInfo) item).makeShortcut();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 769 +                            itemInfo = ((AppInfo) item).makeShortcut();</span>
 770                          } else {
 771                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 772                          }
 773  
 774                          // Add the shortcut to the db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 775 -                        addItemToDatabase(context, shortcutInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 776 +                        addItemToDatabase(context, itemInfo,</span>
 777                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -                                screenId, cordinates[0], cordinates[1], false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +                                screenId, cordinates[0], cordinates[1]);</span>
 780                          // Save the ShortcutInfo for binding in the workspace
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -                        addedShortcutsFinal.add(shortcutInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +                        addedShortcutsFinal.add(itemInfo);</span>
 783                      }
 784                  }
 785  
 786                  // Update the workspace screens
 787                  updateWorkspaceScreenOrder(context, workspaceScreens);
 788  
 789                  if (!addedShortcutsFinal.isEmpty()) {
 790                      runOnMainThread(new Runnable() {
 791                          public void run() {
 792                              Callbacks cb = getCallback();
 793                              if (callbacks == cb &amp;&amp; cb != null) {
 794                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 795                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 796                                  if (!addedShortcutsFinal.isEmpty()) {
 797                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 798                                      long lastScreenId = info.screenId;
 799                                      for (ItemInfo i : addedShortcutsFinal) {
 800                                          if (i.screenId == lastScreenId) {
 801                                              addAnimated.add(i);
 802                                          } else {
 803                                              addNotAnimated.add(i);
 804                                          }
 805                                      }
 806                                  }
 807                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 808                                          addNotAnimated, addAnimated, null);
 809                              }
 810                          }
 811                      });
 812                  }
 813              }
 814          };
 815          runOnWorkerThread(r);
 816      }
 817  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 818 -    public void unbindItemInfosAndClearQueuedBindRunnables() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 819 +    private void unbindItemInfosAndClearQueuedBindRunnables() {</span>
 820          if (sWorkerThread.getThreadId() == Process.myTid()) {
 821              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 822                      &quot;main thread&quot;);
 823          }
 824  
 825          // Clear any deferred bind runnables
 826          synchronized (mDeferredBindRunnables) {
 827              mDeferredBindRunnables.clear();
 828          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 829 -        // Remove any queued bind runnables</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 830 -        mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 832 +        // Remove any queued UI runnables</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +        mHandler.cancelAll();</span>
 834          // Unbind all the workspace items
 835          unbindWorkspaceItemsOnMainThread();
 836      }
 837  
 838      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 839      void unbindWorkspaceItemsOnMainThread() {
 840          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 841          // by making a copy of workspace items first.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -        final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -        final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 844 +        final ArrayList&lt;ItemInfo&gt; tmpItems = new ArrayList&lt;ItemInfo&gt;();</span>
 845          synchronized (sBgLock) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 846 -            tmpWorkspaceItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 847 -            tmpAppWidgets.addAll(sBgAppWidgets);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 848 +            tmpItems.addAll(sBgWorkspaceItems);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +            tmpItems.addAll(sBgAppWidgets);</span>
 850          }
 851          Runnable r = new Runnable() {
 852                  @Override
 853                  public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 854 -                   for (ItemInfo item : tmpWorkspaceItems) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 855 -                       item.unbind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 856 -                   }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 857 -                   for (ItemInfo item : tmpAppWidgets) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +                   for (ItemInfo item : tmpItems) {</span>
 859                         item.unbind();
 860                     }
 861                  }
 862              };
 863          runOnMainThread(r);
 864      }
 865  
 866      /**
 867       * Adds an item to the DB if it was not created previously, or move it to a new
 868       * &lt;container, screen, cellX, cellY&gt;
 869       */
 870      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 871              long screenId, int cellX, int cellY) {
 872          if (item.container == ItemInfo.NO_ID) {
 873              // From all apps
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 874 -            addItemToDatabase(context, item, container, screenId, cellX, cellY, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 875 +            addItemToDatabase(context, item, container, screenId, cellX, cellY);</span>
 876          } else {
 877              // From somewhere else
 878              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 879          }
 880      }
 881  
 882      static void checkItemInfoLocked(
 883              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 884          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 885          if (modelItem != null &amp;&amp; item != modelItem) {
 886              // check all the data is consistent
 887              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 888                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 889                  ShortcutInfo shortcut = (ShortcutInfo) item;
 890                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 891                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 892                          modelShortcut.id == shortcut.id &amp;&amp;
 893                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 894                          modelShortcut.container == shortcut.container &amp;&amp;
 895                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 896                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 897                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 898                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 899                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 900                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 901                          (modelShortcut.dropPos != null &amp;&amp;
 902                                  shortcut.dropPos != null &amp;&amp;
 903                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 904                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 905                      // For all intents and purposes, this is the same object
 906                      return;
 907                  }
 908              }
 909  
 910              // the modelItem needs to match up perfectly with item if our model is
 911              // to be consistent with the database-- for now, just require
 912              // modelItem == item or the equality check above
 913              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 914                      &quot;modelItem: &quot; +
 915                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 916                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 917              RuntimeException e = new RuntimeException(msg);
 918              if (stackTrace != null) {
 919                  e.setStackTrace(stackTrace);
 920              }
 921              throw e;
 922          }
 923      }
 924  
 925      static void checkItemInfo(final ItemInfo item) {
 926          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 927          final long itemId = item.id;
 928          Runnable r = new Runnable() {
 929              public void run() {
 930                  synchronized (sBgLock) {
 931                      checkItemInfoLocked(itemId, item, stackTrace);
 932                  }
 933              }
 934          };
 935          runOnWorkerThread(r);
 936      }
 937  
 938      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 939              final ItemInfo item, final String callingFunction) {
 940          final long itemId = item.id;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 941 -        final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +        final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);</span>
 943          final ContentResolver cr = context.getContentResolver();
 944  
 945          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 946          Runnable r = new Runnable() {
 947              public void run() {
 948                  cr.update(uri, values, null, null);
 949                  updateItemArrays(item, itemId, stackTrace);
 950              }
 951          };
 952          runOnWorkerThread(r);
 953      }
 954  
 955      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 956              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 957          final ContentResolver cr = context.getContentResolver();
 958  
 959          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 960          Runnable r = new Runnable() {
 961              public void run() {
 962                  ArrayList&lt;ContentProviderOperation&gt; ops =
 963                          new ArrayList&lt;ContentProviderOperation&gt;();
 964                  int count = items.size();
 965                  for (int i = 0; i &lt; count; i++) {
 966                      ItemInfo item = items.get(i);
 967                      final long itemId = item.id;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 968 -                    final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +                    final Uri uri = LauncherSettings.Favorites.getContentUri(itemId);</span>
 970                      ContentValues values = valuesList.get(i);
 971  
 972                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 973                      updateItemArrays(item, itemId, stackTrace);
 974  
 975                  }
 976                  try {
 977                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 978                  } catch (Exception e) {
 979                      e.printStackTrace();
 980                  }
 981              }
 982          };
 983          runOnWorkerThread(r);
 984      }
 985  
 986      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 987          // Lock on mBgLock *after* the db operation
 988          synchronized (sBgLock) {
 989              checkItemInfoLocked(itemId, item, stackTrace);
 990  
 991              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 992                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 993                  // Item is in a folder, make sure this folder exists
 994                  if (!sBgFolders.containsKey(item.container)) {
 995                      // An items container is being set to a that of an item which is not in
 996                      // the list of Folders.
 997                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 998                              item.container + &quot;, not in the list of folders&quot;;
 999                      Log.e(TAG, msg);
1000                  }
1001              }
1002  
1003              // Items are added/removed from the corresponding FolderInfo elsewhere, such
1004              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
1005              // that are on the desktop, as appropriate
1006              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
1007              if (modelItem != null &amp;&amp;
1008                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1009                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
1010                  switch (modelItem.itemType) {
1011                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1012                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1013                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1014                          if (!sBgWorkspaceItems.contains(modelItem)) {
1015                              sBgWorkspaceItems.add(modelItem);
1016                          }
1017                          break;
1018                      default:
1019                          break;
1020                  }
1021              } else {
1022                  sBgWorkspaceItems.remove(modelItem);
1023              }
1024          }
1025      }
1026  
1027      /**
1028       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
1029       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1030 -    static void moveItemInDatabase(Context context, final ItemInfo item, final long container,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1031 +    public static void moveItemInDatabase(Context context, final ItemInfo item, final long container,</span>
1032              final long screenId, final int cellX, final int cellY) {
1033          item.container = container;
1034          item.cellX = cellX;
1035          item.cellY = cellY;
1036  
1037          // We store hotseat items in canonical form which is this orientation invariant position
1038          // in the hotseat
1039          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1040                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1041              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1042          } else {
1043              item.screenId = screenId;
1044          }
1045  
1046          final ContentValues values = new ContentValues();
1047          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1048          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1049          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1050          values.put(LauncherSettings.Favorites.RANK, item.rank);
1051          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1052  
1053          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
1054      }
1055  
1056      /**
1057       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
1058       * cellX, cellY have already been updated on the ItemInfos.
1059       */
1060      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
1061              final long container, final int screen) {
1062  
1063          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
1064          int count = items.size();
1065  
1066          for (int i = 0; i &lt; count; i++) {
1067              ItemInfo item = items.get(i);
1068              item.container = container;
1069  
1070              // We store hotseat items in canonical form which is this orientation invariant position
1071              // in the hotseat
1072              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
1073                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1074                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
1075                          item.cellY);
1076              } else {
1077                  item.screenId = screen;
1078              }
1079  
1080              final ContentValues values = new ContentValues();
1081              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1082              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1083              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1084              values.put(LauncherSettings.Favorites.RANK, item.rank);
1085              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1086  
1087              contentValues.add(values);
1088          }
1089          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
1090      }
1091  
1092      /**
1093       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
1094       */
1095      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
1096              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
1097          item.container = container;
1098          item.cellX = cellX;
1099          item.cellY = cellY;
1100          item.spanX = spanX;
1101          item.spanY = spanY;
1102  
1103          // We store hotseat items in canonical form which is this orientation invariant position
1104          // in the hotseat
1105          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1106                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1107              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1108          } else {
1109              item.screenId = screenId;
1110          }
1111  
1112          final ContentValues values = new ContentValues();
1113          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
1114          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
1115          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
1116          values.put(LauncherSettings.Favorites.RANK, item.rank);
1117          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
1118          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
1119          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
1120  
1121          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
1122      }
1123  
1124      /**
1125       * Update an item to the database in a specified container.
1126       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1127 -    static void updateItemInDatabase(Context context, final ItemInfo item) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1128 +    public static void updateItemInDatabase(Context context, final ItemInfo item) {</span>
1129          final ContentValues values = new ContentValues();
1130          item.onAddToDatabase(context, values);
1131          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
1132      }
1133  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1134 +    private void assertWorkspaceLoaded() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1135 +        if (LauncherAppState.isDogfoodBuild() &amp;&amp; (isLoadingWorkspace() || !mHasLoaderCompletedOnce)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +            throw new RuntimeException(&quot;Trying to add shortcut while loader is running&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1137 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1138 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1139 +</span>
1140      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1141 -     * Returns true if the shortcuts already exists in the database.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1142 -     * we identify a shortcut by its title and intent.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1143 +     * Returns true if the shortcuts already exists on the workspace. This must be called after</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1144 +     * the workspace has been loaded. We identify a shortcut by its intent.</span>
1145       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1146 -    static boolean shortcutExists(Context context, String title, Intent intent,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1147 -            UserHandleCompat user) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1148 -        final ContentResolver cr = context.getContentResolver();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1149 -        final Intent intentWithPkg, intentWithoutPkg;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1150 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +    @Thunk boolean shortcutExists(Context context, Intent intent, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +        assertWorkspaceLoaded();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +        final String intentWithPkg, intentWithoutPkg;</span>
1154          if (intent.getComponent() != null) {
1155              // If component is not null, an intent with null package will produce
1156              // the same result and should also be a match.
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +            String packageName = intent.getComponent().getPackageName();</span>
1158              if (intent.getPackage() != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1159 -                intentWithPkg = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1160 -                intentWithoutPkg = new Intent(intent).setPackage(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1161 +                intentWithPkg = intent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1162 +                intentWithoutPkg = new Intent(intent).setPackage(null).toUri(0);</span>
1163              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1164 -                intentWithPkg = new Intent(intent).setPackage(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1165 -                        intent.getComponent().getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1166 -                intentWithoutPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1167 +                intentWithPkg = new Intent(intent).setPackage(packageName).toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1168 +                intentWithoutPkg = intent.toUri(0);</span>
1169              }
1170          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1171 -            intentWithPkg = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1172 -            intentWithoutPkg = intent;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1173 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1174 -        String userSerial = Long.toString(UserManagerCompat.getInstance(context)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1175 -                .getSerialNumberForUser(user));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1176 -        Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1177 -            new String[] { &quot;title&quot;, &quot;intent&quot;, &quot;profileId&quot; },</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1178 -            &quot;title=? and (intent=? or intent=?) and profileId=?&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1179 -            new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0), userSerial },</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1180 -            null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1181 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1182 -            return c.moveToFirst();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1183 -        } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1184 -            c.close();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1185 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1186 +            intentWithPkg = intent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1187 +            intentWithoutPkg = intent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1188 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1189 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1190 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1191 +            for (ItemInfo item : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1192 +                if (item instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1193 +                    ShortcutInfo info = (ShortcutInfo) item;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1194 +                    Intent targetIntent = info.promisedIntent == null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1195 +                            ? info.intent : info.promisedIntent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1196 +                    if (targetIntent != null &amp;&amp; info.user.equals(user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1197 +                        String s = targetIntent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1198 +                        if (intentWithPkg.equals(s) || intentWithoutPkg.equals(s)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1199 +                            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1200 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1201 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1202 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1203 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1204 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1205 +        return false;</span>
1206      }
1207  
1208      /**
1209       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1210       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1211 -    FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1212 +    FolderInfo getFolderById(Context context, LongArrayMap&lt;FolderInfo&gt; folderList, long id) {</span>
1213          final ContentResolver cr = context.getContentResolver();
1214          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1215                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
1216                  new String[] { String.valueOf(id),
1217                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1218  
1219          try {
1220              if (c.moveToFirst()) {
1221                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1222                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1223                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1224                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1225                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1226                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1227 +                final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);</span>
1228  
1229                  FolderInfo folderInfo = null;
1230                  switch (c.getInt(itemTypeIndex)) {
1231                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1232                          folderInfo = findOrMakeFolder(folderList, id);
1233                          break;
1234                  }
1235  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1236 +                // Do not trim the folder label, as is was set by the user.</span>
1237                  folderInfo.title = c.getString(titleIndex);
1238                  folderInfo.id = id;
1239                  folderInfo.container = c.getInt(containerIndex);
1240                  folderInfo.screenId = c.getInt(screenIndex);
1241                  folderInfo.cellX = c.getInt(cellXIndex);
1242                  folderInfo.cellY = c.getInt(cellYIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1243 +                folderInfo.options = c.getInt(optionsIndex);</span>
1244  
1245                  return folderInfo;
1246              }
1247          } finally {
1248              c.close();
1249          }
1250  
1251          return null;
1252      }
1253  
1254      /**
1255       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1256       * cellY fields of the item. Also assigns an ID to the item.
1257       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1258 -    static void addItemToDatabase(Context context, final ItemInfo item, final long container,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1259 -            final long screenId, final int cellX, final int cellY, final boolean notify) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1260 +    public static void addItemToDatabase(Context context, final ItemInfo item, final long container,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1261 +            final long screenId, final int cellX, final int cellY) {</span>
1262          item.container = container;
1263          item.cellX = cellX;
1264          item.cellY = cellY;
1265          // We store hotseat items in canonical form which is this orientation invariant position
1266          // in the hotseat
1267          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1268                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1269              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1270          } else {
1271              item.screenId = screenId;
1272          }
1273  
1274          final ContentValues values = new ContentValues();
1275          final ContentResolver cr = context.getContentResolver();
1276          item.onAddToDatabase(context, values);
1277  
1278          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1279          values.put(LauncherSettings.Favorites._ID, item.id);
1280  
1281          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1282          Runnable r = new Runnable() {
1283              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1284 -                cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1285 -                        LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1286 +                cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);</span>
1287  
1288                  // Lock on mBgLock *after* the db operation
1289                  synchronized (sBgLock) {
1290                      checkItemInfoLocked(item.id, item, stackTrace);
1291                      sBgItemsIdMap.put(item.id, item);
1292                      switch (item.itemType) {
1293                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1294                              sBgFolders.put(item.id, (FolderInfo) item);
1295                              // Fall through
1296                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1297                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1298                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1299                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1300                                  sBgWorkspaceItems.add(item);
1301                              } else {
1302                                  if (!sBgFolders.containsKey(item.container)) {
1303                                      // Adding an item to a folder that doesn&#x27;t exist.
1304                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1305                                              &quot; doesn&#x27;t exist&quot;;
1306                                      Log.e(TAG, msg);
1307                                  }
1308                              }
1309                              break;
1310                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1311                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1312                              break;
1313                      }
1314                  }
1315              }
1316          };
1317          runOnWorkerThread(r);
1318      }
1319  
1320      /**
1321       * Creates a new unique child id, for a given cell span across all layouts.
1322       */
1323      static int getCellLayoutChildId(
1324              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1325          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1326                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1327      }
1328  
1329      private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1330              final String pn, final UserHandleCompat user) {
1331          ItemInfoFilter filter  = new ItemInfoFilter() {
1332              @Override
1333              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1334                  return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1335              }
1336          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1337 -        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +        return filterItemInfos(sBgItemsIdMap, filter);</span>
1339      }
1340  
1341      /**
1342       * Removes all the items from the database corresponding to the specified package.
1343       */
1344      static void deletePackageFromDatabase(Context context, final String pn,
1345              final UserHandleCompat user) {
1346          deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1347      }
1348  
1349      /**
1350       * Removes the specified item from the database
1351       * @param context
1352       * @param item
1353       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1354 -    static void deleteItemFromDatabase(Context context, final ItemInfo item) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +    public static void deleteItemFromDatabase(Context context, final ItemInfo item) {</span>
1356          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1357          items.add(item);
1358          deleteItemsFromDatabase(context, items);
1359      }
1360  
1361      /**
1362       * Removes the specified items from the database
1363       * @param context
1364       * @param item
1365       */
1366      static void deleteItemsFromDatabase(Context context, final ArrayList&lt;? extends ItemInfo&gt; items) {
1367          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1368 -</span>
1369          Runnable r = new Runnable() {
1370              public void run() {
1371                  for (ItemInfo item : items) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1372 -                    final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1373 +                    final Uri uri = LauncherSettings.Favorites.getContentUri(item.id);</span>
1374                      cr.delete(uri, null, null);
1375  
1376                      // Lock on mBgLock *after* the db operation
1377                      synchronized (sBgLock) {
1378                          switch (item.itemType) {
1379                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1380                                  sBgFolders.remove(item.id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1381 -                                for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1382 +                                for (ItemInfo info: sBgItemsIdMap) {</span>
1383                                      if (info.container == item.id) {
1384                                          // We are deleting a folder which still contains items that
1385                                          // think they are contained by that folder.
1386                                          String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1387                                                  &quot;contains items (&quot; + info + &quot;)&quot;;
1388                                          Log.e(TAG, msg);
1389                                      }
1390                                  }
1391                                  sBgWorkspaceItems.remove(item);
1392                                  break;
1393                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1394                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1395                                  sBgWorkspaceItems.remove(item);
1396                                  break;
1397                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1398                                  sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1399                                  break;
1400                          }
1401                          sBgItemsIdMap.remove(item.id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -                        sBgDbIconCache.remove(item);</span>
1403                      }
1404                  }
1405              }
1406          };
1407          runOnWorkerThread(r);
1408      }
1409  
1410      /**
1411       * Update the order of the workspace screens in the database. The array list contains
1412       * a list of screen ids in the order that they should appear.
1413       */
1414      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1415 -        // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1416 -        Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1417 -        Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1418 -</span>
1419          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1420          final ContentResolver cr = context.getContentResolver();
1421          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1422  
1423          // Remove any negative screen ids -- these aren&#x27;t persisted
1424          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1425          while (iter.hasNext()) {
1426              long id = iter.next();
1427              if (id &lt; 0) {
1428                  iter.remove();
1429              }
1430          }
1431  
1432          Runnable r = new Runnable() {
1433              @Override
1434              public void run() {
1435                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1436                  // Clear the table
1437                  ops.add(ContentProviderOperation.newDelete(uri).build());
1438                  int count = screensCopy.size();
1439                  for (int i = 0; i &lt; count; i++) {
1440                      ContentValues v = new ContentValues();
1441                      long screenId = screensCopy.get(i);
1442                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1443                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1444                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1445                  }
1446  
1447                  try {
1448                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1449                  } catch (Exception ex) {
1450                      throw new RuntimeException(ex);
1451                  }
1452  
1453                  synchronized (sBgLock) {
1454                      sBgWorkspaceScreens.clear();
1455                      sBgWorkspaceScreens.addAll(screensCopy);
1456                  }
1457              }
1458          };
1459          runOnWorkerThread(r);
1460      }
1461  
1462      /**
1463       * Remove the contents of the specified folder from the database
1464       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1465 -    static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1466 +    public static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {</span>
1467          final ContentResolver cr = context.getContentResolver();
1468  
1469          Runnable r = new Runnable() {
1470              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1471 -                cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1472 +                cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);</span>
1473                  // Lock on mBgLock *after* the db operation
1474                  synchronized (sBgLock) {
1475                      sBgItemsIdMap.remove(info.id);
1476                      sBgFolders.remove(info.id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1477 -                    sBgDbIconCache.remove(info);</span>
1478                      sBgWorkspaceItems.remove(info);
1479                  }
1480  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1481 -                cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1482 +                cr.delete(LauncherSettings.Favorites.CONTENT_URI,</span>
1483                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1484                  // Lock on mBgLock *after* the db operation
1485                  synchronized (sBgLock) {
1486                      for (ItemInfo childInfo : info.contents) {
1487                          sBgItemsIdMap.remove(childInfo.id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1488 -                        sBgDbIconCache.remove(childInfo);</span>
1489                      }
1490                  }
1491              }
1492          };
1493          runOnWorkerThread(r);
1494      }
1495  
1496      /**
1497       * Set this as the current Launcher activity object for the loader.
1498       */
1499      public void initialize(Callbacks callbacks) {
1500          synchronized (mLock) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1501 +            // Disconnect any of the callbacks and drawables associated with ItemInfos on the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1502 +            // workspace to prevent leaking Launcher activities on orientation change.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1503 +            unbindItemInfosAndClearQueuedBindRunnables();</span>
1504              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1505          }
1506      }
1507  
1508      @Override
1509      public void onPackageChanged(String packageName, UserHandleCompat user) {
1510          int op = PackageUpdatedTask.OP_UPDATE;
1511          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1512                  user));
1513      }
1514  
1515      @Override
1516      public void onPackageRemoved(String packageName, UserHandleCompat user) {
1517          int op = PackageUpdatedTask.OP_REMOVE;
1518          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1519                  user));
1520      }
1521  
1522      @Override
1523      public void onPackageAdded(String packageName, UserHandleCompat user) {
1524          int op = PackageUpdatedTask.OP_ADD;
1525          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1526                  user));
1527      }
1528  
1529      @Override
1530      public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1531              boolean replacing) {
1532          if (!replacing) {
1533              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1534                      user));
1535              if (mAppsCanBeOnRemoveableStorage) {
1536                  // Only rebind if we support removable storage. It catches the
1537                  // case where
1538                  // apps on the external sd card need to be reloaded
1539                  startLoaderFromBackground();
1540              }
1541          } else {
1542              // If we are replacing then just update the packages in the list
1543              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1544                      packageNames, user));
1545          }
1546      }
1547  
1548      @Override
1549      public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1550              boolean replacing) {
1551          if (!replacing) {
1552              enqueuePackageUpdated(new PackageUpdatedTask(
1553                      PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1554                      user));
1555          }
1556      }
1557  
1558      /**
1559       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1560       * ACTION_PACKAGE_CHANGED.
1561       */
1562      @Override
1563      public void onReceive(Context context, Intent intent) {
1564          if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1565  
1566          final String action = intent.getAction();
1567          if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1568              // If we have changed locale we need to clear out the labels in all apps/workspace.
1569              forceReload();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1570 -        } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1571 -             // Check if configuration change was an mcc/mnc change which would affect app resources</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1572 -             // and we would need to clear out the labels in all apps/workspace. Same handling as</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1573 -             // above for ACTION_LOCALE_CHANGED</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1574 -             Configuration currentConfig = context.getResources().getConfiguration();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1575 -             if (mPreviousConfigMcc != currentConfig.mcc) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1576 -                   Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1577 -                       + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1578 -                   forceReload();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1579 -             }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1580 -             // Update previousConfig</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1581 -             mPreviousConfigMcc = currentConfig.mcc;</span>
1582          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1583                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1584              Callbacks callbacks = getCallback();
1585              if (callbacks != null) {
1586                  callbacks.bindSearchablesChanged();
1587              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1588 +        } else if (LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1589 +                || LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1590 +            forceReload();</span>
1591          }
1592      }
1593  
1594      void forceReload() {
1595          resetLoadedState(true, true);
1596  
1597          // Do this here because if the launcher activity is running it will be restarted.
1598          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1599          // to reload.
1600          startLoaderFromBackground();
1601      }
1602  
1603      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1604          synchronized (mLock) {
1605              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1606              // mWorkspaceLoaded to true later
1607              stopLoaderLocked();
1608              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1609              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1610          }
1611      }
1612  
1613      /**
1614       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1615       * configuration changes.  So whenever we trigger the loader from the background
1616       * tell the launcher that it needs to re-run the loader when it comes back instead
1617       * of doing it now.
1618       */
1619      public void startLoaderFromBackground() {
1620          boolean runLoader = false;
1621          Callbacks callbacks = getCallback();
1622          if (callbacks != null) {
1623              // Only actually run the loader if they&#x27;re not paused.
1624              if (!callbacks.setLoadOnResume()) {
1625                  runLoader = true;
1626              }
1627          }
1628          if (runLoader) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1629 -            startLoader(false, PagedView.INVALID_RESTORE_PAGE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1630 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1631 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1632 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1633 -    // If there is already a loader task running, tell it to stop.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1634 -    // returns true if isLaunching() was true on the old task</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1635 -    private boolean stopLoaderLocked() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1636 -        boolean isLaunching = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1637 +            startLoader(PagedView.INVALID_RESTORE_PAGE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1638 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1639 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1640 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1641 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1642 +     * If there is already a loader task running, tell it to stop.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1643 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1644 +    private void stopLoaderLocked() {</span>
1645          LoaderTask oldTask = mLoaderTask;
1646          if (oldTask != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1647 -            if (oldTask.isLaunching()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1648 -                isLaunching = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1649 -            }</span>
1650              oldTask.stopLocked();
1651          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1652 -        return isLaunching;</span>
1653      }
1654  
1655      public boolean isCurrentCallbacks(Callbacks callbacks) {
1656          return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1657      }
1658  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1659 -    public void startLoader(boolean isLaunching, int synchronousBindPage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1660 -        startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1661 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1662 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1663 -    public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1664 +    public void startLoader(int synchronousBindPage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1665 +        startLoader(synchronousBindPage, LOADER_FLAG_NONE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1666 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1667 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1668 +    public void startLoader(int synchronousBindPage, int loadFlags) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1669 +        // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1670 +        InstallShortcutReceiver.enableInstallQueue();</span>
1671          synchronized (mLock) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1672 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1673 -                Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1674 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1675 -</span>
1676              // Clear any deferred bind-runnables from the synchronized load process
1677              // We must do this before any loading/binding is scheduled below.
1678              synchronized (mDeferredBindRunnables) {
1679                  mDeferredBindRunnables.clear();
1680              }
1681  
1682              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1683              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1684                  // If there is already one running, tell it to stop.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1685 -                // also, don&#x27;t downgrade isLaunching if we&#x27;re already running</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1686 -                isLaunching = isLaunching || stopLoaderLocked();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1687 -                mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1688 +                stopLoaderLocked();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1689 +                mLoaderTask = new LoaderTask(mApp.getContext(), loadFlags);</span>
1690                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1691 -                        &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1692 +                        &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded &amp;&amp; !mIsLoaderTaskRunning) {</span>
1693                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1694                  } else {
1695                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1696                      sWorker.post(mLoaderTask);
1697                  }
1698              }
1699          }
1700      }
1701  
1702      void bindRemainingSynchronousPages() {
1703          // Post the remaining side pages to be loaded
1704          if (!mDeferredBindRunnables.isEmpty()) {
1705              Runnable[] deferredBindRunnables = null;
1706              synchronized (mDeferredBindRunnables) {
1707                  deferredBindRunnables = mDeferredBindRunnables.toArray(
1708                          new Runnable[mDeferredBindRunnables.size()]);
1709                  mDeferredBindRunnables.clear();
1710              }
1711              for (final Runnable r : deferredBindRunnables) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -                mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1713 +                mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1714 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1715 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1716 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1717 +        // Run all the bind complete runnables after workspace is bound.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1718 +        if (!mBindCompleteRunnables.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1719 +            synchronized (mBindCompleteRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1720 +                for (final Runnable r : mBindCompleteRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1721 +                    runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1722 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1723 +                mBindCompleteRunnables.clear();</span>
1724              }
1725          }
1726      }
1727  
1728      public void stopLoader() {
1729          synchronized (mLock) {
1730              if (mLoaderTask != null) {
1731                  mLoaderTask.stopLocked();
1732              }
1733          }
1734      }
1735  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1736 -    /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1737 -    private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1738 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1739 +     * Loads the workspace screen ids in an ordered list.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1740 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1741 +    @Thunk static ArrayList&lt;Long&gt; loadWorkspaceScreensDb(Context context) {</span>
1742          final ContentResolver contentResolver = context.getContentResolver();
1743          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1744 -        final Cursor sc = contentResolver.query(screensUri, null, null, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1745 -        TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1746 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1747 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1748 +        // Get screens ordered by rank.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1749 +        final Cursor sc = contentResolver.query(screensUri, null, null, null,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1750 +                LauncherSettings.WorkspaceScreens.SCREEN_RANK);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1751 +        ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();</span>
1752          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1753 -            final int idIndex = sc.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1754 -                    LauncherSettings.WorkspaceScreens._ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1755 -            final int rankIndex = sc.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1756 -                    LauncherSettings.WorkspaceScreens.SCREEN_RANK);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1757 +            final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);</span>
1758              while (sc.moveToNext()) {
1759                  try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1760 -                    long screenId = sc.getLong(idIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1761 -                    int rank = sc.getInt(rankIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1762 -                    orderedScreens.put(rank, screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1763 +                    screenIds.add(sc.getLong(idIndex));</span>
1764                  } catch (Exception e) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1765 -                    Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1766 +                    Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1767 +                            + &quot; - invalid screens: &quot; + e, true);</span>
1768                  }
1769              }
1770          } finally {
1771              sc.close();
1772          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1773 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1774 -        // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1775 -        Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1776 -        ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1777 -        for (Integer i : orderedScreens.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1778 -            orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1779 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1780 -        Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1781 -                TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1782 -        return orderedScreens;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1783 +        return screenIds;</span>
1784      }
1785  
1786      public boolean isAllAppsLoaded() {
1787          return mAllAppsLoaded;
1788      }
1789  
1790      boolean isLoadingWorkspace() {
1791          synchronized (mLock) {
1792              if (mLoaderTask != null) {
1793                  return mLoaderTask.isLoadingWorkspace();
1794              }
1795          }
1796          return false;
1797      }
1798  
1799      /**
1800       * Runnable for the thread that loads the contents of the launcher:
1801       *   - workspace icons
1802       *   - widgets
1803       *   - all apps icons
1804       */
1805      private class LoaderTask implements Runnable {
1806          private Context mContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1807 -        private boolean mIsLaunching;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1808 -        private boolean mIsLoadingAndBindingWorkspace;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1809 +        @Thunk boolean mIsLoadingAndBindingWorkspace;</span>
1810          private boolean mStopped;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1811 -        private boolean mLoadAndBindStepFinished;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1812 +        @Thunk boolean mLoadAndBindStepFinished;</span>
1813          private int mFlags;
1814  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1815 -        private HashMap&lt;Object, CharSequence&gt; mLabelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1816 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1817 -        LoaderTask(Context context, boolean isLaunching, int flags) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1818 +        LoaderTask(Context context, int flags) {</span>
1819              mContext = context;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1820 -            mIsLaunching = isLaunching;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1821 -            mLabelCache = new HashMap&lt;Object, CharSequence&gt;();</span>
1822              mFlags = flags;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1823 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1824 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1825 -        boolean isLaunching() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1826 -            return mIsLaunching;</span>
1827          }
1828  
1829          boolean isLoadingWorkspace() {
1830              return mIsLoadingAndBindingWorkspace;
1831          }
1832  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1833 -        /** Returns whether this is an upgrade path */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1834 -        private boolean loadAndBindWorkspace() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1835 +        private void loadAndBindWorkspace() {</span>
1836              mIsLoadingAndBindingWorkspace = true;
1837  
1838              // Load the workspace
1839              if (DEBUG_LOADERS) {
1840                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1841              }
1842  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1843 -            boolean isUpgradePath = false;</span>
1844              if (!mWorkspaceLoaded) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1845 -                isUpgradePath = loadWorkspace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1846 +                loadWorkspace();</span>
1847                  synchronized (LoaderTask.this) {
1848                      if (mStopped) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1849 -                        return isUpgradePath;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1850 +                        return;</span>
1851                      }
1852                      mWorkspaceLoaded = true;
1853                  }
1854              }
1855  
1856              // Bind the workspace
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1857 -            bindWorkspace(-1, isUpgradePath);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1858 -            return isUpgradePath;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1859 +            bindWorkspace(-1);</span>
1860          }
1861  
1862          private void waitForIdle() {
1863              // Wait until the either we&#x27;re stopped or the other threads are done.
1864              // This way we don&#x27;t start loading all apps until the workspace has settled
1865              // down.
1866              synchronized (LoaderTask.this) {
1867                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1868  
1869                  mHandler.postIdle(new Runnable() {
1870                          public void run() {
1871                              synchronized (LoaderTask.this) {
1872                                  mLoadAndBindStepFinished = true;
1873                                  if (DEBUG_LOADERS) {
1874                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1875                                  }
1876                                  LoaderTask.this.notify();
1877                              }
1878                          }
1879                      });
1880  
1881                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1882                      try {
1883                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1884                          // wait no longer than 1sec at a time
1885                          this.wait(1000);
1886                      } catch (InterruptedException ex) {
1887                          // Ignore
1888                      }
1889                  }
1890                  if (DEBUG_LOADERS) {
1891                      Log.d(TAG, &quot;waited &quot;
1892                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1893                              + &quot;ms for previous step to finish binding&quot;);
1894                  }
1895              }
1896          }
1897  
1898          void runBindSynchronousPage(int synchronousBindPage) {
1899              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1900                  // Ensure that we have a valid page index to load synchronously
1901                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1902                          &quot;valid page index&quot;);
1903              }
1904              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1905                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1906                  // loaded already (we should load everything asynchronously in that case)
1907                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1908              }
1909              synchronized (mLock) {
1910                  if (mIsLoaderTaskRunning) {
1911                      // Ensure that we are never running the background loading at this point since
1912                      // we also touch the background collections
1913                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1914                  }
1915              }
1916  
1917              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1918              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1919              //      this call is synchronous, we can get away with not locking).
1920  
1921              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1922              // operations from the previous activity.  We need to ensure that all queued operations
1923              // are executed before any synchronous binding work is done.
1924              mHandler.flush();
1925  
1926              // Divide the set of loaded items into those that we are binding synchronously, and
1927              // everything else that is to be bound normally (asynchronously).
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1928 -            bindWorkspace(synchronousBindPage, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1929 +            bindWorkspace(synchronousBindPage);</span>
1930              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1931              //      arise from that.
1932              onlyBindAllApps();
1933          }
1934  
1935          public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1936 -            boolean isUpgrade = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1937 -</span>
1938              synchronized (mLock) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1939 +                if (mStopped) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1940 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1941 +                }</span>
1942                  mIsLoaderTaskRunning = true;
1943              }
1944              // Optimize for end-user experience: if the Launcher is up and // running with the
1945              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1946              // workspace first (default).
1947              keep_running: {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1948 -                // Elevate priority when Home launches for the first time to avoid</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1949 -                // starving at boot time. Staring at a blank home is not cool.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1950 -                synchronized (mLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1951 -                    if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1952 -                            (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1953 -                    android.os.Process.setThreadPriority(mIsLaunching</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1954 -                            ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1955 -                }</span>
1956                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1957 -                isUpgrade = loadAndBindWorkspace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1958 +                loadAndBindWorkspace();</span>
1959  
1960                  if (mStopped) {
1961                      break keep_running;
1962                  }
1963  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1964 -                // Whew! Hard work done.  Slow us down, and wait until the UI thread has</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1965 -                // settled down.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1966 -                synchronized (mLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1967 -                    if (mIsLaunching) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1968 -                        if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1969 -                        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1970 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1971 -                }</span>
1972                  waitForIdle();
1973  
1974                  // second step
1975                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1976                  loadAndBindAllApps();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1977 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1978 -                // Restore the default thread priority after we are done loading items</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1979 -                synchronized (mLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1980 -                    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1981 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1982 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1983 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1984 -            // Update the saved icons if necessary</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1985 -            if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1986 -            synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1987 -                for (Object key : sBgDbIconCache.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1988 -                    updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1989 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1990 -                sBgDbIconCache.clear();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1991 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1992 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1993 -            if (LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1994 -                // Ensure that all the applications that are in the system are</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1995 -                // represented on the home screen.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1996 -                if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1997 -                    verifyApplications();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1998 -                }</span>
1999              }
2000  
2001              // Clear out this reference, otherwise we end up holding it until all of the
2002              // callback runnables are done.
2003              mContext = null;
2004  
2005              synchronized (mLock) {
2006                  // If we are still the last one to be scheduled, remove ourselves.
2007                  if (mLoaderTask == this) {
2008                      mLoaderTask = null;
2009                  }
2010                  mIsLoaderTaskRunning = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2011 +                mHasLoaderCompletedOnce = true;</span>
2012              }
2013          }
2014  
2015          public void stopLocked() {
2016              synchronized (LoaderTask.this) {
2017                  mStopped = true;
2018                  this.notify();
2019              }
2020          }
2021  
2022          /**
2023           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
2024           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
2025           * object that was around when the deferred message was scheduled, and if there&#x27;s
2026           * a new Callbacks object around then also return null.  This will save us from
2027           * calling onto it with data that will be ignored.
2028           */
2029          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
2030              synchronized (mLock) {
2031                  if (mStopped) {
2032                      return null;
2033                  }
2034  
2035                  if (mCallbacks == null) {
2036                      return null;
2037                  }
2038  
2039                  final Callbacks callbacks = mCallbacks.get();
2040                  if (callbacks != oldCallbacks) {
2041                      return null;
2042                  }
2043                  if (callbacks == null) {
2044                      Log.w(TAG, &quot;no mCallbacks&quot;);
2045                      return null;
2046                  }
2047  
2048                  return callbacks;
2049              }
2050          }
2051  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2052 -        private void verifyApplications() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2053 -            final Context context = mApp.getContext();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2054 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2055 -            // Cross reference all the applications in our apps list with items in the workspace</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2056 -            ArrayList&lt;ItemInfo&gt; tmpInfos;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2057 -            ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2058 -            synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2059 -                for (AppInfo app : mBgAllAppsList.data) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2060 -                    tmpInfos = getItemInfoForComponentName(app.componentName, app.user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2061 -                    if (tmpInfos.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2062 -                        // We are missing an application icon, so add this to the workspace</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2063 -                        added.add(app);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2064 -                        // This is a rare event, so lets log it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2065 -                        Log.e(TAG, &quot;Missing Application on load: &quot; + app);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2066 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2067 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2068 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2069 -            if (!added.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2070 -                addAndBindAddedWorkspaceApps(context, added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2071 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2072 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2073 -</span>
2074          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2075 -        private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2076 +        private boolean checkItemPlacement(LongArrayMap&lt;ItemInfo[][]&gt; occupied, ItemInfo item) {</span>
2077              LauncherAppState app = LauncherAppState.getInstance();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2078 -            DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2079 -            final int countX = (int) grid.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2080 -            final int countY = (int) grid.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2081 +            InvariantDeviceProfile profile = app.getInvariantDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2082 +            final int countX = (int) profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2083 +            final int countY = (int) profile.numRows;</span>
2084  
2085              long containerIndex = item.screenId;
2086              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2087                  // Return early if we detect that an item is under the hotseat button
2088                  if (mCallbacks == null ||
2089                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
2090                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
2091                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
2092                              + item.cellY + &quot;) occupied by all apps&quot;);
2093                      return false;
2094                  }
2095  
2096                  final ItemInfo[][] hotseatItems =
2097                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
2098  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2099 -                if (item.screenId &gt;= grid.numHotseatIcons) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2100 +                if (item.screenId &gt;= profile.numHotseatIcons) {</span>
2101                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
2102                              + &quot; into hotseat position &quot; + item.screenId
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2103 -                            + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2104 +                            + &quot;, position out of bounds: (0 to &quot; + (profile.numHotseatIcons - 1)</span>
2105                              + &quot;)&quot;);
2106                      return false;
2107                  }
2108  
2109                  if (hotseatItems != null) {
2110                      if (hotseatItems[(int) item.screenId][0] != null) {
2111                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
2112                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
2113                                  + item.cellY + &quot;) occupied by &quot;
2114                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
2115                                  [(int) item.screenId][0]);
2116                              return false;
2117                      } else {
2118                          hotseatItems[(int) item.screenId][0] = item;
2119                          return true;
2120                      }
2121                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2122 -                    final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2123 +                    final ItemInfo[][] items = new ItemInfo[(int) profile.numHotseatIcons][1];</span>
2124                      items[(int) item.screenId][0] = item;
2125                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
2126                      return true;
2127                  }
2128              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2129                  // Skip further checking if it is not the hotseat or workspace container
2130                  return true;
2131              }
2132  
2133              if (!occupied.containsKey(item.screenId)) {
2134                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
2135                  occupied.put(item.screenId, items);
2136              }
2137  
2138              final ItemInfo[][] screens = occupied.get(item.screenId);
2139              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2140                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
2141                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
2142                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
2143                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
2144                          + item.cellX + &quot;,&quot; + item.cellY
2145                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
2146                  return false;
2147              }
2148  
2149              // Check if any workspace icons overlap with each other
2150              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
2151                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
2152                      if (screens[x][y] != null) {
2153                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
2154                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
2155                              + x + &quot;,&quot; + y
2156                              + &quot;) occupied by &quot;
2157                              + screens[x][y]);
2158                          return false;
2159                      }
2160                  }
2161              }
2162              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
2163                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
2164                      screens[x][y] = item;
2165                  }
2166              }
2167  
2168              return true;
2169          }
2170  
2171          /** Clears all the sBg data structures */
2172          private void clearSBgDataStructures() {
2173              synchronized (sBgLock) {
2174                  sBgWorkspaceItems.clear();
2175                  sBgAppWidgets.clear();
2176                  sBgFolders.clear();
2177                  sBgItemsIdMap.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2178 -                sBgDbIconCache.clear();</span>
2179                  sBgWorkspaceScreens.clear();
2180              }
2181          }
2182  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2183 -        /** Returns whether this is an upgrade path */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2184 -        private boolean loadWorkspace() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2185 -            // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2186 -            Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2187 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2188 +        private void loadWorkspace() {</span>
2189              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2190  
2191              final Context context = mContext;
2192              final ContentResolver contentResolver = context.getContentResolver();
2193              final PackageManager manager = context.getPackageManager();
2194              final boolean isSafeMode = manager.isSafeMode();
2195              final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2196              final boolean isSdCardReady = context.registerReceiver(null,
2197                      new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
2198  
2199              LauncherAppState app = LauncherAppState.getInstance();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2200 -            DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2201 -            int countX = (int) grid.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2202 -            int countY = (int) grid.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2203 +            InvariantDeviceProfile profile = app.getInvariantDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2204 +            int countX = (int) profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2205 +            int countY = (int) profile.numRows;</span>
2206  
2207              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
2208                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
2209                  LauncherAppState.getLauncherProvider().deleteDatabase();
2210              }
2211  
2212              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
2213                  // append the user&#x27;s Launcher2 shortcuts
2214                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
2215                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
2216              } else {
2217                  // Make sure the default workspace is loaded
2218                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
2219                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
2220              }
2221  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2222 -            // This code path is for our old migration code and should no longer be exercised</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2223 -            boolean loadedOldDb = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2224 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2225 -            // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2226 -            Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2227 -</span>
2228              synchronized (sBgLock) {
2229                  clearSBgDataStructures();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2230 -                final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2231 +                final HashMap&lt;String, Integer&gt; installingPkgs = PackageInstallerCompat</span>
2232                          .getInstance(mContext).updateAndGetActiveSessionCache();
2233  
2234                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
2235                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2236 -                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2237 +                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;</span>
2238                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
2239                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
2240  
2241                  // +1 for the hotseat (it can be larger than the workspace)
2242                  // Load workspace in reverse order to ensure that latest items are loaded first (and
2243                  // before any earlier duplicates)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2244 -                final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2245 +                final LongArrayMap&lt;ItemInfo[][]&gt; occupied = new LongArrayMap&lt;&gt;();</span>
2246  
2247                  try {
2248                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2249                      final int intentIndex = c.getColumnIndexOrThrow
2250                              (LauncherSettings.Favorites.INTENT);
2251                      final int titleIndex = c.getColumnIndexOrThrow
2252                              (LauncherSettings.Favorites.TITLE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2253 -                    final int iconTypeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2254 -                            LauncherSettings.Favorites.ICON_TYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2255 -                    final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2256 -                    final int iconPackageIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2257 -                            LauncherSettings.Favorites.ICON_PACKAGE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2258 -                    final int iconResourceIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2259 -                            LauncherSettings.Favorites.ICON_RESOURCE);</span>
2260                      final int containerIndex = c.getColumnIndexOrThrow(
2261                              LauncherSettings.Favorites.CONTAINER);
2262                      final int itemTypeIndex = c.getColumnIndexOrThrow(
2263                              LauncherSettings.Favorites.ITEM_TYPE);
2264                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
2265                              LauncherSettings.Favorites.APPWIDGET_ID);
2266                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
2267                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
2268                      final int screenIndex = c.getColumnIndexOrThrow(
2269                              LauncherSettings.Favorites.SCREEN);
2270                      final int cellXIndex = c.getColumnIndexOrThrow
2271                              (LauncherSettings.Favorites.CELLX);
2272                      final int cellYIndex = c.getColumnIndexOrThrow
2273                              (LauncherSettings.Favorites.CELLY);
2274                      final int spanXIndex = c.getColumnIndexOrThrow
2275                              (LauncherSettings.Favorites.SPANX);
2276                      final int spanYIndex = c.getColumnIndexOrThrow(
2277                              LauncherSettings.Favorites.SPANY);
2278                      final int rankIndex = c.getColumnIndexOrThrow(
2279                              LauncherSettings.Favorites.RANK);
2280                      final int restoredIndex = c.getColumnIndexOrThrow(
2281                              LauncherSettings.Favorites.RESTORED);
2282                      final int profileIdIndex = c.getColumnIndexOrThrow(
2283                              LauncherSettings.Favorites.PROFILE_ID);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2284 -                    //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2285 -                    //final int displayModeIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2286 -                    //        LauncherSettings.Favorites.DISPLAY_MODE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2287 +                    final int optionsIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2288 +                            LauncherSettings.Favorites.OPTIONS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2289 +                    final CursorIconInfo cursorIconInfo = new CursorIconInfo(c);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2290 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2291 +                    final LongSparseArray&lt;UserHandleCompat&gt; allUsers = new LongSparseArray&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2292 +                    for (UserHandleCompat user : mUserManager.getUserProfiles()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2293 +                        allUsers.put(mUserManager.getSerialNumberForUser(user), user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2294 +                    }</span>
2295  
2296                      ShortcutInfo info;
2297                      String intentDescription;
2298                      LauncherAppWidgetInfo appWidgetInfo;
2299                      int container;
2300                      long id;
2301                      long serialNumber;
2302                      Intent intent;
2303                      UserHandleCompat user;
2304  
2305                      while (!mStopped &amp;&amp; c.moveToNext()) {
2306                          try {
2307                              int itemType = c.getInt(itemTypeIndex);
2308                              boolean restored = 0 != c.getInt(restoredIndex);
2309                              boolean allowMissingTarget = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2310 +                            container = c.getInt(containerIndex);</span>
2311  
2312                              switch (itemType) {
2313                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
2314                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2315                                  id = c.getLong(idIndex);
2316                                  intentDescription = c.getString(intentIndex);
2317                                  serialNumber = c.getInt(profileIdIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2318 -                                user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2319 +                                user = allUsers.get(serialNumber);</span>
2320                                  int promiseType = c.getInt(restoredIndex);
2321                                  int disabledState = 0;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2322 +                                boolean itemReplaced = false;</span>
2323                                  if (user == null) {
2324                                      // User has been deleted remove the item.
2325                                      itemsToRemove.add(id);
2326                                      continue;
2327                                  }
2328                                  try {
2329                                      intent = Intent.parseUri(intentDescription, 0);
2330                                      ComponentName cn = intent.getComponent();
2331                                      if (cn != null &amp;&amp; cn.getPackageName() != null) {
2332                                          boolean validPkg = launcherApps.isPackageEnabledForProfile(
2333                                                  cn.getPackageName(), user);
2334                                          boolean validComponent = validPkg &amp;&amp;
2335                                                  launcherApps.isActivityEnabledForProfile(cn, user);
2336  
2337                                          if (validComponent) {
2338                                              if (restored) {
2339                                                  // no special handling necessary for this item
2340                                                  restoredRows.add(id);
2341                                                  restored = false;
2342                                              }
2343                                          } else if (validPkg) {
2344                                              intent = null;
2345                                              if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2346                                                  // We allow auto install apps to have their intent
2347                                                  // updated after an install.
2348                                                  intent = manager.getLaunchIntentForPackage(
2349                                                          cn.getPackageName());
2350                                                  if (intent != null) {
2351                                                      ContentValues values = new ContentValues();
2352                                                      values.put(LauncherSettings.Favorites.INTENT,
2353                                                              intent.toUri(0));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2354 -                                                    String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2355 -                                                    String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2356 -                                                    contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2357 +                                                    updateItem(id, values);</span>
2358                                                  }
2359                                              }
2360  
2361                                              if (intent == null) {
2362                                                  // The app is installed but the component is no
2363                                                  // longer available.
2364                                                  Launcher.addDumpLog(TAG,
2365                                                          &quot;Invalid component removed: &quot; + cn, true);
2366                                                  itemsToRemove.add(id);
2367                                                  continue;
2368                                              } else {
2369                                                  // no special handling necessary for this item
2370                                                  restoredRows.add(id);
2371                                                  restored = false;
2372                                              }
2373                                          } else if (restored) {
2374                                              // Package is not yet available but might be
2375                                              // installed later.
2376                                              Launcher.addDumpLog(TAG,
2377                                                      &quot;package not yet restored: &quot; + cn, true);
2378  
2379                                              if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2380                                                  // Restore has started once.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2381 -                                            } else if (installingPkgs.contains(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2382 +                                            } else if (installingPkgs.containsKey(cn.getPackageName())) {</span>
2383                                                  // App restore has started. Update the flag
2384                                                  promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2385                                                  ContentValues values = new ContentValues();
2386                                                  values.put(LauncherSettings.Favorites.RESTORED,
2387                                                          promiseType);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2388 -                                                String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2389 -                                                String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2390 -                                                contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2391 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2392 +                                                updateItem(id, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2393 +                                            } else if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_APP_TYPE) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2394 +                                                // This is a common app. Try to replace this.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="2395 +                                                int appType = CommonAppTypeParser.decodeItemTypeFromFlag(promiseType);">2395 +                                                int appType = CommonAppTypeParser.decodeItemTypeFromFlag(promiseTy🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="2396 +                                                CommonAppTypeParser parser = new CommonAppTypeParser(id, appType, context);">2396 +                                                CommonAppTypeParser parser = new CommonAppTypeParser(id, appType, 🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2397 +                                                if (parser.findDefaultApp()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2398 +                                                    // Default app found. Replace it.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2399 +                                                    intent = parser.parsedIntent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2400 +                                                    cn = intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2401 +                                                    ContentValues values = parser.parsedValues;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2402 +                                                    values.put(LauncherSettings.Favorites.RESTORED, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2403 +                                                    updateItem(id, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2404 +                                                    restored = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2405 +                                                    itemReplaced = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2406 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2407 +                                                } else if (REMOVE_UNRESTORED_ICONS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2408 +                                                    Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2409 +                                                            &quot;Unrestored package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2410 +                                                    itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2411 +                                                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2412 +                                                }</span>
2413                                              } else if (REMOVE_UNRESTORED_ICONS) {
2414                                                  Launcher.addDumpLog(TAG,
2415                                                          &quot;Unrestored package removed: &quot; + cn, true);
2416                                                  itemsToRemove.add(id);
2417                                                  continue;
2418                                              }
2419                                          } else if (launcherApps.isAppEnabled(
2420                                                  manager, cn.getPackageName(),
2421                                                  PackageManager.GET_UNINSTALLED_PACKAGES)) {
2422                                              // Package is present but not available.
2423                                              allowMissingTarget = true;
2424                                              disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2425                                          } else if (!isSdCardReady) {
2426                                              // SdCard is not ready yet. Package might get available,
2427                                              // once it is ready.
2428                                              Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2429                                                      + &quot; (check again later)&quot;, true);
2430                                              HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2431                                              if (pkgs == null) {
2432                                                  pkgs = new HashSet&lt;String&gt;();
2433                                                  sPendingPackages.put(user, pkgs);
2434                                              }
2435                                              pkgs.add(cn.getPackageName());
2436                                              allowMissingTarget = true;
2437                                              // Add the icon on the workspace anyway.
2438  
2439                                          } else {
2440                                              // Do not wait for external media load anymore.
2441                                              // Log the invalid package, and remove it
2442                                              Launcher.addDumpLog(TAG,
2443                                                      &quot;Invalid package removed: &quot; + cn, true);
2444                                              itemsToRemove.add(id);
2445                                              continue;
2446                                          }
2447                                      } else if (cn == null) {
2448                                          // For shortcuts with no component, keep them as they are
2449                                          restoredRows.add(id);
2450                                          restored = false;
2451                                      }
2452                                  } catch (URISyntaxException e) {
2453                                      Launcher.addDumpLog(TAG,
2454                                              &quot;Invalid uri: &quot; + intentDescription, true);
2455                                      continue;
2456                                  }
2457  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2458 -                                if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2459 +                                boolean useLowResIcon = container &gt;= 0 &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2460 +                                        c.getInt(rankIndex) &gt;= FolderIcon.NUM_ITEMS_IN_PREVIEW;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2461 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2462 +                                if (itemReplaced) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2463 +                                    if (user.equals(UserHandleCompat.myUserHandle())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2464 +                                        info = getAppShortcutInfo(manager, intent, user, context, null,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2465 +                                                cursorIconInfo.iconIndex, titleIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2466 +                                                false, useLowResIcon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2467 +                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2468 +                                        // Don&#x27;t replace items for other profiles.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2469 +                                        itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2470 +                                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2471 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2472 +                                } else if (restored) {</span>
2473                                      if (user.equals(UserHandleCompat.myUserHandle())) {
2474                                          Launcher.addDumpLog(TAG,
2475                                                  &quot;constructing info for partially restored package&quot;,
2476                                                  true);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2477 -                                        info = getRestoredItemInfo(c, titleIndex, intent, promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2478 +                                        info = getRestoredItemInfo(c, titleIndex, intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2479 +                                                promiseType, itemType, cursorIconInfo, context);</span>
2480                                          intent = getRestoredItemIntent(c, context, intent);
2481                                      } else {
2482                                          // Don&#x27;t restore items for other profiles.
2483                                          itemsToRemove.add(id);
2484                                          continue;
2485                                      }
2486                                  } else if (itemType ==
2487                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2488 -                                    info = getShortcutInfo(manager, intent, user, context, c,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2489 -                                            iconIndex, titleIndex, mLabelCache, allowMissingTarget);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2490 +                                    info = getAppShortcutInfo(manager, intent, user, context, c,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2491 +                                            cursorIconInfo.iconIndex, titleIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2492 +                                            allowMissingTarget, useLowResIcon);</span>
2493                                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2494 -                                    info = getShortcutInfo(c, context, iconTypeIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2495 -                                            iconPackageIndex, iconResourceIndex, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2496 -                                            titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2497 +                                    info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);</span>
2498  
2499                                      // App shortcuts that used to be automatically added to Launcher
2500                                      // didn&#x27;t always have the correct intent flags set, so do that
2501                                      // here
2502                                      if (intent.getAction() != null &amp;&amp;
2503                                          intent.getCategories() != null &amp;&amp;
2504                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2505                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2506                                          intent.addFlags(
2507                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2508                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2509                                      }
2510                                  }
2511  
2512                                  if (info != null) {
2513                                      info.id = id;
2514                                      info.intent = intent;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2515 -                                    container = c.getInt(containerIndex);</span>
2516                                      info.container = container;
2517                                      info.screenId = c.getInt(screenIndex);
2518                                      info.cellX = c.getInt(cellXIndex);
2519                                      info.cellY = c.getInt(cellYIndex);
2520                                      info.rank = c.getInt(rankIndex);
2521                                      info.spanX = 1;
2522                                      info.spanY = 1;
2523                                      info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2524 +                                    if (info.promisedIntent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2525 +                                        info.promisedIntent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2526 +                                    }</span>
2527                                      info.isDisabled = disabledState;
2528                                      if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2529                                          info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2530                                      }
2531  
2532                                      // check &amp; update map of what&#x27;s occupied
2533                                      if (!checkItemPlacement(occupied, info)) {
2534                                          itemsToRemove.add(id);
2535                                          break;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2536 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2537 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2538 +                                    if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2539 +                                        ComponentName cn = info.getTargetComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2540 +                                        if (cn != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2541 +                                            Integer progress = installingPkgs.get(cn.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2542 +                                            if (progress != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2543 +                                                info.setInstallProgress(progress);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2544 +                                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2545 +                                                info.status &amp;= ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2546 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2547 +                                        }</span>
2548                                      }
2549  
2550                                      switch (container) {
2551                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2552                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2553                                          sBgWorkspaceItems.add(info);
2554                                          break;
2555                                      default:
2556                                          // Item is in a user folder
2557                                          FolderInfo folderInfo =
2558                                                  findOrMakeFolder(sBgFolders, container);
2559                                          folderInfo.add(info);
2560                                          break;
2561                                      }
2562                                      sBgItemsIdMap.put(info.id, info);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2563 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2564 -                                    // now that we&#x27;ve loaded everthing re-save it with the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2565 -                                    // icon in case it disappears somehow.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2566 -                                    queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);</span>
2567                                  } else {
2568                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2569                                  }
2570                                  break;
2571  
2572                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2573                                  id = c.getLong(idIndex);
2574                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2575  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2576 +                                // Do not trim the folder label, as is was set by the user.</span>
2577                                  folderInfo.title = c.getString(titleIndex);
2578                                  folderInfo.id = id;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2579 -                                container = c.getInt(containerIndex);</span>
2580                                  folderInfo.container = container;
2581                                  folderInfo.screenId = c.getInt(screenIndex);
2582                                  folderInfo.cellX = c.getInt(cellXIndex);
2583                                  folderInfo.cellY = c.getInt(cellYIndex);
2584                                  folderInfo.spanX = 1;
2585                                  folderInfo.spanY = 1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2586 +                                folderInfo.options = c.getInt(optionsIndex);</span>
2587  
2588                                  // check &amp; update map of what&#x27;s occupied
2589                                  if (!checkItemPlacement(occupied, folderInfo)) {
2590                                      itemsToRemove.add(id);
2591                                      break;
2592                                  }
2593  
2594                                  switch (container) {
2595                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2596                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2597                                          sBgWorkspaceItems.add(folderInfo);
2598                                          break;
2599                                  }
2600  
2601                                  if (restored) {
2602                                      // no special handling required for restored folders
2603                                      restoredRows.add(id);
2604                                  }
2605  
2606                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2607                                  sBgFolders.put(folderInfo.id, folderInfo);
2608                                  break;
2609  
2610                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2611                              case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
2612                                  // Read all Launcher-specific widget details
2613                                  boolean customWidget = itemType ==
2614                                      LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;
2615  

2616                                  int appWidgetId = c.getInt(appWidgetIdIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2617 -                                serialNumber= c.getLong(profileIdIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2618 -                                user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2619 +                                serialNumber = c.getLong(profileIdIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2620 +                                String savedProvider = c.getString(appWidgetProviderIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2621 +                                id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2622 +                                user = allUsers.get(serialNumber);</span>
2623                                  if (user == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2624 -                                    // User has been deleted remove the item.</span>
2625                                      itemsToRemove.add(id);
2626                                      continue;
2627                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2628 -                                String savedProvider = c.getString(appWidgetProviderIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2629 -                                id = c.getLong(idIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2630 +</span>
2631                                  final ComponentName component =
2632                                          ComponentName.unflattenFromString(savedProvider);
2633  
2634                                  final int restoreStatus = c.getInt(restoredIndex);
2635                                  final boolean isIdValid = (restoreStatus &amp;
2636                                          LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2637 -</span>
2638                                  final boolean wasProviderReady = (restoreStatus &amp;
2639                                          LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2640  
2641                                  final LauncherAppWidgetProviderInfo provider =
2642                                          LauncherModel.getProviderInfo(context,
2643                                                  ComponentName.unflattenFromString(savedProvider),
2644                                                  user);
2645  
2646                                  final boolean isProviderReady = isValidProvider(provider);
2647                                  if (!isSafeMode &amp;&amp; !customWidget &amp;&amp;
2648                                          wasProviderReady &amp;&amp; !isProviderReady) {
2649                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2650                                              + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2651  
2652                                      Log.e(TAG, log);
2653                                      Launcher.addDumpLog(TAG, log, false);
2654                                      itemsToRemove.add(id);
2655                                  } else {
2656                                      if (isProviderReady) {
2657                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2658                                                  provider.provider);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2659 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2660 -                                        if (!customWidget) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2661 -                                            int[] minSpan =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2662 -                                                    Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2663 -                                            appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2664 -                                            appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2665 -                                        }</span>
2666  
2667                                          int status = restoreStatus;
2668                                          if (!wasProviderReady) {
2669                                              // If provider was not previously ready, update the
2670                                              // status and UI flag.
2671  
<abbr title="2672                                              // Id would be valid only if the widget restore broadcast was received.">2672                                              // Id would be valid only if the widget restore broadcast was received🔵</abbr>
2673                                              if (isIdValid) {
2674                                                  status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2675                                              } else {
2676                                                  status &amp;= ~LauncherAppWidgetInfo
2677                                                          .FLAG_PROVIDER_NOT_READY;
2678                                              }
2679                                          }
2680                                          appWidgetInfo.restoreStatus = status;
2681                                      } else {
2682                                          Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2683                                                  + &quot; appWidgetId=&quot; + appWidgetId
2684                                                  + &quot; status =&quot; + restoreStatus);
2685                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2686                                                  component);
2687                                          appWidgetInfo.restoreStatus = restoreStatus;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2688 +                                        Integer installProgress = installingPkgs.get(component.getPackageName());</span>
2689  
2690                                          if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {
2691                                              // Restore has started once.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2692 -                                        } else if (installingPkgs.contains(component.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2693 +                                        } else if (installProgress != null) {</span>
2694                                              // App restore has started. Update the flag
2695                                              appWidgetInfo.restoreStatus |=
2696                                                      LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2697                                          } else if (REMOVE_UNRESTORED_ICONS &amp;&amp; !isSafeMode) {
2698                                              Launcher.addDumpLog(TAG,
2699                                                      &quot;Unrestored widget removed: &quot; + component, true);
2700                                              itemsToRemove.add(id);
2701                                              continue;
2702                                          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2703 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2704 +                                        appWidgetInfo.installProgress =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2705 +                                                installProgress == null ? 0 : installProgress;</span>
2706                                      }
2707  
2708                                      appWidgetInfo.id = id;
2709                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2710                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2711                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2712                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2713                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2714 -                                    appWidgetInfo.user = user;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2715 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2716 -                                    if (!customWidget) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2717 -                                        int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2718 -                                        appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2719 -                                        appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2720 -                                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2721 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2722 -                                    container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2723 +</span>
2724                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2725                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2726                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2727                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2728                                          continue;
2729                                      }
2730  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2731 -                                    appWidgetInfo.container = c.getInt(containerIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2732 +                                    appWidgetInfo.container = container;</span>
2733                                      // check &amp; update map of what&#x27;s occupied
2734                                      if (!checkItemPlacement(occupied, appWidgetInfo)) {
2735                                          itemsToRemove.add(id);
2736                                          break;
2737                                      }
2738  
2739                                      if (!customWidget) {
2740                                          String providerName =
2741                                                  appWidgetInfo.providerName.flattenToString();
2742                                          if (!providerName.equals(savedProvider) ||
2743                                                  (appWidgetInfo.restoreStatus != restoreStatus)) {
2744                                              ContentValues values = new ContentValues();
2745                                              values.put(
2746                                                      LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2747                                                      providerName);
2748                                              values.put(LauncherSettings.Favorites.RESTORED,
2749                                                      appWidgetInfo.restoreStatus);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2750 -                                            String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2751 -                                            String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2752 -                                            contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2753 +                                            updateItem(id, values);</span>
2754                                          }
2755                                      }
2756                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2757                                      sBgAppWidgets.add(appWidgetInfo);
2758                                  }
2759                                  break;
2760                              }
2761                          } catch (Exception e) {
2762                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2763                          }
2764                      }
2765                  } finally {
2766                      if (c != null) {
2767                          c.close();
2768                      }
2769                  }
2770  
2771                  // Break early if we&#x27;ve stopped loading
2772                  if (mStopped) {
2773                      clearSBgDataStructures();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2774 -                    return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2775 +                    return;</span>
2776                  }
2777  
2778                  if (itemsToRemove.size() &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2779 -                    ContentProviderClient client = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2780 -                            contentUri);</span>
2781                      // Remove dead items
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2782 -                    for (long id : itemsToRemove) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2783 -                        if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2784 -                            Log.d(TAG, &quot;Removed id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2785 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2786 -                        // Don&#x27;t notify content observers</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2787 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2788 -                            client.delete(LauncherSettings.Favorites.getContentUri(id, false),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2789 -                                    null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2790 -                        } catch (RemoteException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2791 -                            Log.w(TAG, &quot;Could not remove id = &quot; + id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2792 -                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2793 +                    contentResolver.delete(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2794 +                            Utilities.createDbSelectionQuery(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2795 +                                    LauncherSettings.Favorites._ID, itemsToRemove), null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2796 +                    if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2797 +                        Log.d(TAG, &quot;Removed = &quot; + Utilities.createDbSelectionQuery(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2798 +                                LauncherSettings.Favorites._ID, itemsToRemove));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2799 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2800 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2801 +                    // Remove any empty folder</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2802 +                    for (long folderId : LauncherAppState.getLauncherProvider()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2803 +                            .deleteEmptyFolders()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2804 +                        sBgWorkspaceItems.remove(sBgFolders.get(folderId));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2805 +                        sBgFolders.remove(folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2806 +                        sBgItemsIdMap.remove(folderId);</span>
2807                      }
2808                  }
2809  
2810                  if (restoredRows.size() &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2811 -                    ContentProviderClient updater = contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2812 -                            contentUri);</span>
2813                      // Update restored items that no longer require special handling
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2814 -                    try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2815 -                        StringBuilder selectionBuilder = new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2816 -                        selectionBuilder.append(LauncherSettings.Favorites._ID);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2817 -                        selectionBuilder.append(&quot; IN (&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2818 -                        selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2819 -                        selectionBuilder.append(&quot;)&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2820 -                        ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2821 -                        values.put(LauncherSettings.Favorites.RESTORED, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2822 -                        updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2823 -                                values, selectionBuilder.toString(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2824 -                    } catch (RemoteException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2825 -                        Log.w(TAG, &quot;Could not update restored rows&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2826 -                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2827 +                    ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2828 +                    values.put(LauncherSettings.Favorites.RESTORED, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2829 +                    contentResolver.update(LauncherSettings.Favorites.CONTENT_URI, values,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2830 +                            Utilities.createDbSelectionQuery(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2831 +                                    LauncherSettings.Favorites._ID, restoredRows), null);</span>
2832                  }
2833  
2834                  if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2835                      context.registerReceiver(new AppsAvailabilityCheck(),
2836                              new IntentFilter(StartupReceiver.SYSTEM_READY),
2837                              null, sWorker);
2838                  }
2839  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2840 -                if (loadedOldDb) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2841 -                    long maxScreenId = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2842 -                    // If we&#x27;re importing we use the old screen order.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2843 -                    for (ItemInfo item: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2844 -                        long screenId = item.screenId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2845 -                        if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2846 -                                !sBgWorkspaceScreens.contains(screenId)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2847 -                            sBgWorkspaceScreens.add(screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2848 -                            if (screenId &gt; maxScreenId) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2849 -                                maxScreenId = screenId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2850 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2851 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2852 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2853 -                    Collections.sort(sBgWorkspaceScreens);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2854 -                    // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2855 -                    Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2856 -                    Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2857 -                            TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2858 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2859 -                    LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2860 +                sBgWorkspaceScreens.addAll(loadWorkspaceScreensDb(mContext));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2861 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2862 +                // Remove any empty screens</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2863 +                ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2864 +                for (ItemInfo item: sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2865 +                    long screenId = item.screenId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2866 +                    if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2867 +                            unusedScreens.contains(screenId)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2868 +                        unusedScreens.remove(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2869 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2870 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2871 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2872 +                // If there are any empty screens remove them, and update.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2873 +                if (unusedScreens.size() != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2874 +                    sBgWorkspaceScreens.removeAll(unusedScreens);</span>
2875                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2876 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2877 -                    // Update the max item id after we load an old db</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2878 -                    long maxItemId = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2879 -                    // If we&#x27;re importing we use the old screen order.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2880 -                    for (ItemInfo item: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2881 -                        maxItemId = Math.max(maxItemId, item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2882 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2883 -                    LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2884 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2885 -                    TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2886 -                    for (Integer i : orderedScreens.keySet()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2887 -                        sBgWorkspaceScreens.add(orderedScreens.get(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2888 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2889 -                    // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2890 -                    Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2891 -                            TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2892 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2893 -                    // Remove any empty screens</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2894 -                    ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2895 -                    for (ItemInfo item: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2896 -                        long screenId = item.screenId;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2897 -                        if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2898 -                                unusedScreens.contains(screenId)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2899 -                            unusedScreens.remove(screenId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2900 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2901 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2902 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2903 -                    // If there are any empty screens remove them, and update.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2904 -                    if (unusedScreens.size() != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2905 -                        // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2906 -                        Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2907 -                                TextUtils.join(&quot;, &quot;, unusedScreens), true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2908 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2909 -                        sBgWorkspaceScreens.removeAll(unusedScreens);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2910 -                        updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2911 -                    }</span>
2912                  }
2913  
2914                  if (DEBUG_LOADERS) {
2915                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2916                      Log.d(TAG, &quot;workspace layout: &quot;);
2917                      int nScreens = occupied.size();
2918                      for (int y = 0; y &lt; countY; y++) {
2919                          String line = &quot;&quot;;
2920  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2921 -                        Iterator&lt;Long&gt; iter = occupied.keySet().iterator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2922 -                        while (iter.hasNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2923 -                            long screenId = iter.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2924 +                        for (int i = 0; i &lt; nScreens; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2925 +                            long screenId = occupied.keyAt(i);</span>
2926                              if (screenId &gt; 0) {
2927                                  line += &quot; | &quot;;
2928                              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2929 +                            ItemInfo[][] screen = occupied.valueAt(i);</span>
2930                              for (int x = 0; x &lt; countX; x++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2931 -                                ItemInfo[][] screen = occupied.get(screenId);</span>
2932                                  if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2933                                      line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2934                                  } else {
2935                                      line += &quot;!&quot;;
2936                                  }
2937                              }
2938                          }
2939                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2940                      }
2941                  }
2942              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2943 -            return loadedOldDb;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2944 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2945 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2946 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2947 +         * Partially updates the item without any notification. Must be called on the worker thread.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2948 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2949 +        private void updateItem(long itemId, ContentValues update) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2950 +            mContext.getContentResolver().update(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2951 +                    LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2952 +                    update,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2953 +                    BaseColumns._ID + &quot;= ?&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2954 +                    new String[]{Long.toString(itemId)});</span>
2955          }
2956  
2957          /** Filters the set of items who are directly or indirectly (via another container) on the
2958           * specified screen. */
2959          private void filterCurrentWorkspaceItems(long currentScreenId,
2960                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2961                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2962                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2963              // Purge any null ItemInfos
2964              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2965              while (iter.hasNext()) {
2966                  ItemInfo i = iter.next();
2967                  if (i == null) {
2968                      iter.remove();
2969                  }
2970              }
2971  
2972              // Order the set of items by their containers first, this allows use to walk through the
2973              // list sequentially, build up a list of containers that are in the specified screen,
2974              // as well as all items in those containers.
2975              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2976              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2977                  @Override
2978                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2979                      return (int) (lhs.container - rhs.container);
2980                  }
2981              });
2982              for (ItemInfo info : allWorkspaceItems) {
2983                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2984                      if (info.screenId == currentScreenId) {
2985                          currentScreenItems.add(info);
2986                          itemsOnScreen.add(info.id);
2987                      } else {
2988                          otherScreenItems.add(info);
2989                      }
2990                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2991                      currentScreenItems.add(info);
2992                      itemsOnScreen.add(info.id);
2993                  } else {
2994                      if (itemsOnScreen.contains(info.container)) {
2995                          currentScreenItems.add(info);
2996                          itemsOnScreen.add(info.id);
2997                      } else {
2998                          otherScreenItems.add(info);
2999                      }
3000                  }
3001              }
3002          }
3003  
3004          /** Filters the set of widgets which are on the specified screen. */
3005          private void filterCurrentAppWidgets(long currentScreenId,
3006                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
3007                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
3008                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
3009  
3010              for (LauncherAppWidgetInfo widget : appWidgets) {
3011                  if (widget == null) continue;
3012                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
3013                          widget.screenId == currentScreenId) {
3014                      currentScreenWidgets.add(widget);
3015                  } else {
3016                      otherScreenWidgets.add(widget);
3017                  }
3018              }
3019          }
3020  
3021          /** Filters the set of folders which are on the specified screen. */
3022          private void filterCurrentFolders(long currentScreenId,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3023 -                HashMap&lt;Long, ItemInfo&gt; itemsIdMap,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3024 -                HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3025 -                HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3026 -                HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3027 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3028 -            for (long id : folders.keySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3029 +                LongArrayMap&lt;ItemInfo&gt; itemsIdMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3030 +                LongArrayMap&lt;FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3031 +                LongArrayMap&lt;FolderInfo&gt; currentScreenFolders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3032 +                LongArrayMap&lt;FolderInfo&gt; otherScreenFolders) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3033 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3034 +            int total = folders.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3035 +            for (int i = 0; i &lt; total; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3036 +                long id = folders.keyAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3037 +                FolderInfo folder = folders.valueAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3038 +</span>
3039                  ItemInfo info = itemsIdMap.get(id);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3040 -                FolderInfo folder = folders.get(id);</span>
3041                  if (info == null || folder == null) continue;
3042                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
3043                          info.screenId == currentScreenId) {
3044                      currentScreenFolders.put(id, folder);
3045                  } else {
3046                      otherScreenFolders.put(id, folder);
3047                  }
3048              }
3049          }
3050  
3051          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
3052           * right) */
3053          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
3054              final LauncherAppState app = LauncherAppState.getInstance();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3055 -            final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3056 +            final InvariantDeviceProfile profile = app.getInvariantDeviceProfile();</span>
3057              // XXX: review this
3058              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
3059                  @Override
3060                  public int compare(ItemInfo lhs, ItemInfo rhs) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3061 -                    int cellCountX = (int) grid.numColumns;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3062 -                    int cellCountY = (int) grid.numRows;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3063 +                    int cellCountX = (int) profile.numColumns;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3064 +                    int cellCountY = (int) profile.numRows;</span>
3065                      int screenOffset = cellCountX * cellCountY;
3066                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
3067                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
3068                              lhs.cellY * cellCountX + lhs.cellX);
3069                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
3070                              rhs.cellY * cellCountX + rhs.cellX);
3071                      return (int) (lr - rr);
3072                  }
3073              });
3074          }
3075  
3076          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
3077                  final ArrayList&lt;Long&gt; orderedScreens) {
3078              final Runnable r = new Runnable() {
3079                  @Override
3080                  public void run() {
3081                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3082                      if (callbacks != null) {
3083                          callbacks.bindScreens(orderedScreens);
3084                      }
3085                  }
3086              };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3087 -            runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3088 +            runOnMainThread(r);</span>
3089          }
3090  
3091          private void bindWorkspaceItems(final Callbacks oldCallbacks,
3092                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
3093                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3094 -                final HashMap&lt;Long, FolderInfo&gt; folders,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3095 +                final LongArrayMap&lt;FolderInfo&gt; folders,</span>
3096                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
3097  
3098              final boolean postOnMainThread = (deferredBindRunnables != null);
3099  
3100              // Bind the workspace items
3101              int N = workspaceItems.size();
3102              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
3103                  final int start = i;
3104                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
3105                  final Runnable r = new Runnable() {
3106                      @Override
3107                      public void run() {
3108                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3109                          if (callbacks != null) {
3110                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
3111                                      false);
3112                          }
3113                      }
3114                  };
3115                  if (postOnMainThread) {
3116                      synchronized (deferredBindRunnables) {
3117                          deferredBindRunnables.add(r);
3118                      }
3119                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3120 -                    runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3121 +                    runOnMainThread(r);</span>
3122                  }
3123              }
3124  
3125              // Bind the folders
3126              if (!folders.isEmpty()) {
3127                  final Runnable r = new Runnable() {
3128                      public void run() {
3129                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3130                          if (callbacks != null) {
3131                              callbacks.bindFolders(folders);
3132                          }
3133                      }
3134                  };
3135                  if (postOnMainThread) {
3136                      synchronized (deferredBindRunnables) {
3137                          deferredBindRunnables.add(r);
3138                      }
3139                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3140 -                    runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3141 +                    runOnMainThread(r);</span>
3142                  }
3143              }
3144  
3145              // Bind the widgets, one at a time
3146              N = appWidgets.size();
3147              for (int i = 0; i &lt; N; i++) {
3148                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
3149                  final Runnable r = new Runnable() {
3150                      public void run() {
3151                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3152                          if (callbacks != null) {
3153                              callbacks.bindAppWidget(widget);
3154                          }
3155                      }
3156                  };
3157                  if (postOnMainThread) {
3158                      deferredBindRunnables.add(r);
3159                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3160 -                    runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3161 +                    runOnMainThread(r);</span>
3162                  }
3163              }
3164          }
3165  
3166          /**
3167           * Binds all loaded data to actual views on the main thread.
3168           */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3169 -        private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3170 +        private void bindWorkspace(int synchronizeBindPage) {</span>
3171              final long t = SystemClock.uptimeMillis();
3172              Runnable r;
3173  
3174              // Don&#x27;t use these two variables in any of the callback runnables.
3175              // Otherwise we hold a reference to them.
3176              final Callbacks oldCallbacks = mCallbacks.get();
3177              if (oldCallbacks == null) {
3178                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3179                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
3180                  return;
3181              }
3182  
3183              // Save a copy of all the bg-thread collections
3184              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
3185              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
3186                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3187 -            HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3188 -            HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();</span>
3189              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3190 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3191 +            final LongArrayMap&lt;FolderInfo&gt; folders;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3192 +            final LongArrayMap&lt;ItemInfo&gt; itemsIdMap;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3193 +</span>
3194              synchronized (sBgLock) {
3195                  workspaceItems.addAll(sBgWorkspaceItems);
3196                  appWidgets.addAll(sBgAppWidgets);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3197 -                folders.putAll(sBgFolders);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3198 -                itemsIdMap.putAll(sBgItemsIdMap);</span>
3199                  orderedScreenIds.addAll(sBgWorkspaceScreens);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3200 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3201 +                folders = sBgFolders.clone();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3202 +                itemsIdMap = sBgItemsIdMap.clone();</span>
3203              }
3204  
3205              final boolean isLoadingSynchronously =
3206                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
3207              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
3208                  oldCallbacks.getCurrentWorkspaceScreen();
3209              if (currScreen &gt;= orderedScreenIds.size()) {
3210                  // There may be no workspace screens (just hotseat items and an empty page).
3211                  currScreen = PagedView.INVALID_RESTORE_PAGE;
3212              }
3213              final int currentScreen = currScreen;
3214              final long currentScreenId = currentScreen &lt; 0
3215                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
3216  
3217              // Load all the items that are on the current page first (and in the process, unbind
3218              // all the existing workspace items before we call startBinding() below.
3219              unbindWorkspaceItemsOnMainThread();
3220  
3221              // Separate the items that are on the current screen, and all the other remaining items
3222              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
3223              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
3224              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
3225                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
3226              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
3227                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3228 -            HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3229 -            HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3230 +            LongArrayMap&lt;FolderInfo&gt; currentFolders = new LongArrayMap&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3231 +            LongArrayMap&lt;FolderInfo&gt; otherFolders = new LongArrayMap&lt;&gt;();</span>
3232  
3233              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
3234                      otherWorkspaceItems);
3235              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
3236                      otherAppWidgets);
3237              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
3238                      otherFolders);
3239              sortWorkspaceItemsSpatially(currentWorkspaceItems);
3240              sortWorkspaceItemsSpatially(otherWorkspaceItems);
3241  
3242              // Tell the workspace that we&#x27;re about to start binding items
3243              r = new Runnable() {
3244                  public void run() {
3245                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3246                      if (callbacks != null) {
3247                          callbacks.startBinding();
3248                      }
3249                  }
3250              };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3251 -            runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3252 +            runOnMainThread(r);</span>
3253  
3254              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
3255  
3256              // Load items on the current page
3257              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
3258                      currentFolders, null);
3259              if (isLoadingSynchronously) {
3260                  r = new Runnable() {
3261                      public void run() {
3262                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3263                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
3264                              callbacks.onPageBoundSynchronously(currentScreen);
3265                          }
3266                      }
3267                  };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3268 -                runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3269 +                runOnMainThread(r);</span>
3270              }
3271  
3272              // Load all the remaining pages (if we are loading synchronously, we want to defer this
3273              // work until after the first render)
3274              synchronized (mDeferredBindRunnables) {
3275                  mDeferredBindRunnables.clear();
3276              }
3277              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
3278                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
3279  
3280              // Tell the workspace that we&#x27;re done binding items
3281              r = new Runnable() {
3282                  public void run() {
3283                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3284                      if (callbacks != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3285 -                        callbacks.finishBindingItems(isUpgradePath);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3286 +                        callbacks.finishBindingItems();</span>
3287                      }
3288  
3289                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
3290                      if (DEBUG_LOADERS) {
3291                          Log.d(TAG, &quot;bound workspace in &quot;
3292                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3293                      }
3294  
3295                      mIsLoadingAndBindingWorkspace = false;
3296                  }
3297              };
3298              if (isLoadingSynchronously) {
3299                  synchronized (mDeferredBindRunnables) {
3300                      mDeferredBindRunnables.add(r);
3301                  }
3302              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3303 -                runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3304 +                runOnMainThread(r);</span>
3305              }
3306          }
3307  
3308          private void loadAndBindAllApps() {
3309              if (DEBUG_LOADERS) {
3310                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
3311              }
3312              if (!mAllAppsLoaded) {
3313                  loadAllApps();
3314                  synchronized (LoaderTask.this) {
3315                      if (mStopped) {
3316                          return;
3317                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3318 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3319 +                updateIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3320 +                synchronized (LoaderTask.this) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3321 +                    if (mStopped) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3322 +                        return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3323 +                    }</span>
3324                      mAllAppsLoaded = true;
3325                  }
3326              } else {
3327                  onlyBindAllApps();
3328              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3329 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3330 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3331 +        private void updateIconCache() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3332 +            // Ignore packages which have a promise icon.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3333 +            HashSet&lt;String&gt; packagesToIgnore = new HashSet&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3334 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3335 +                for (ItemInfo info : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3336 +                    if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3337 +                        ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3338 +                        if (si.isPromise() &amp;&amp; si.getTargetComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3339 +                            packagesToIgnore.add(si.getTargetComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3340 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3341 +                    } else if (info instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3342 +                        LauncherAppWidgetInfo lawi = (LauncherAppWidgetInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3343 +                        if (lawi.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3344 +                            packagesToIgnore.add(lawi.providerName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3345 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3346 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3347 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3348 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3349 +            mIconCache.updateDbIcons(packagesToIgnore);</span>
3350          }
3351  
3352          private void onlyBindAllApps() {
3353              final Callbacks oldCallbacks = mCallbacks.get();
3354              if (oldCallbacks == null) {
3355                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3356                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
3357                  return;
3358              }
3359  
3360              // shallow copy
3361              @SuppressWarnings(&quot;unchecked&quot;)
3362              final ArrayList&lt;AppInfo&gt; list
3363                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3364 +            final WidgetsModel widgetList = mBgWidgetsModel.clone();</span>
3365              Runnable r = new Runnable() {
3366                  public void run() {
3367                      final long t = SystemClock.uptimeMillis();
3368                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3369                      if (callbacks != null) {
3370                          callbacks.bindAllApplications(list);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3371 +                        callbacks.bindAllPackages(widgetList);</span>
3372                      }
3373                      if (DEBUG_LOADERS) {
3374                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
3375                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3376                      }
3377                  }
3378              };
3379              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
3380              if (isRunningOnMainThread) {
3381                  r.run();
3382              } else {
3383                  mHandler.post(r);
3384              }
3385          }
3386  
3387          private void loadAllApps() {
3388              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3389  
3390              final Callbacks oldCallbacks = mCallbacks.get();
3391              if (oldCallbacks == null) {
3392                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3393                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
3394                  return;
3395              }
3396  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3397 -            final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3398 -            mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3399 -</span>
3400              final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
3401  
3402              // Clear the list of apps
3403              mBgAllAppsList.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3404 -            SharedPreferences prefs = mContext.getSharedPreferences(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3405 -                    LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);</span>
3406              for (UserHandleCompat user : profiles) {
3407                  // Query for the set of apps
3408                  final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3409 -                List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3410 +                final List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);</span>
3411                  if (DEBUG_LOADERS) {
3412                      Log.d(TAG, &quot;getActivityList took &quot;
3413                              + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
3414                      Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
3415                  }
3416                  // Fail if we don&#x27;t have any apps
3417                  // TODO: Fix this. Only fail for the current user.
3418                  if (apps == null || apps.isEmpty()) {
3419                      return;
3420                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3421 -                // Sort the applications by name</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3422 -                final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3423 -                Collections.sort(apps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3424 -                        new LauncherModel.ShortcutNameComparator(mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3425 -                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3426 -                    Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3427 -                            + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3428 -                }</span>
3429  
3430                  // Create the ApplicationInfos
3431                  for (int i = 0; i &lt; apps.size(); i++) {
3432                      LauncherActivityInfoCompat app = apps.get(i);
3433                      // This builds the icon bitmaps.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3434 -                    mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3435 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3436 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3437 -                if (ADD_MANAGED_PROFILE_SHORTCUTS &amp;&amp; !user.equals(UserHandleCompat.myUserHandle())) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3438 -                    // Add shortcuts for packages which were installed while launcher was dead.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3439 -                    String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3440 -                            + mUserManager.getSerialNumberForUser(user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3441 -                    Set&lt;String&gt; packagesAdded = prefs.getStringSet(shortcutsSetKey, Collections.EMPTY_SET);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3442 -                    HashSet&lt;String&gt; newPackageSet = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3443 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3444 -                    for (LauncherActivityInfoCompat info : apps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3445 -                        String packageName = info.getComponentName().getPackageName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3446 -                        if (!packagesAdded.contains(packageName)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3447 -                                &amp;&amp; !newPackageSet.contains(packageName)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3448 -                            InstallShortcutReceiver.queueInstallShortcut(info, mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3449 +                    mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3450 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3451 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3452 +                final ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(mContext, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3453 +                if (heuristic != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3454 +                    runAfterBindCompletes(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3455 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3456 +                        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3457 +                        public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3458 +                            heuristic.processUserApps(apps);</span>
3459                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3460 -                        newPackageSet.add(packageName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3461 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3462 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3463 -                    prefs.edit().putStringSet(shortcutsSetKey, newPackageSet).commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3464 +                    });</span>
3465                  }
3466              }
3467              // Huh? Shouldn&#x27;t this be inside the Runnable below?
3468              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
3469              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
3470  
3471              // Post callback on main thread
3472              mHandler.post(new Runnable() {
3473                  public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3474 +</span>
3475                      final long bindTime = SystemClock.uptimeMillis();
3476                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3477                      if (callbacks != null) {
3478                          callbacks.bindAllApplications(added);
3479                          if (DEBUG_LOADERS) {
3480                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
3481                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
3482                          }
3483                      } else {
3484                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
3485                      }
3486                  }
3487              });
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3488 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3489 +            // Cleanup any data stored for a deleted user.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3490 +            ManagedProfileHeuristic.processAllUsers(profiles, mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3491 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3492 +            loadAndBindWidgetsAndShortcuts(mApp.getContext(), tryGetCallbacks(oldCallbacks),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3493 +                    true /* refresh */);</span>
3494              if (DEBUG_LOADERS) {
3495                  Log.d(TAG, &quot;Icons processed in &quot;
3496                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
3497              }
3498          }
3499  
3500          public void dumpState() {
3501              synchronized (sBgLock) {
3502                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3503 -                Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
3504                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
3505                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
3506                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
3507              }
3508          }
3509      }
3510  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3511 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3512 +     * Called when the icons for packages have been updated in the icon cache.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3513 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3514 +    public void onPackageIconsUpdated(HashSet&lt;String&gt; updatedPackages, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3515 +        final Callbacks callbacks = getCallback();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3516 +        final ArrayList&lt;AppInfo&gt; updatedApps = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3517 +        final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3518 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3519 +        // If any package icon has changed (app was updated while launcher was dead),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3520 +        // update the corresponding shortcuts.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3521 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3522 +            for (ItemInfo info : sBgItemsIdMap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3523 +                if (info instanceof ShortcutInfo &amp;&amp; user.equals(info.user)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3524 +                        &amp;&amp; info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3525 +                    ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3526 +                    ComponentName cn = si.getTargetComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3527 +                    if (cn != null &amp;&amp; updatedPackages.contains(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3528 +                        si.updateIcon(mIconCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3529 +                        updatedShortcuts.add(si);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3530 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3531 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3532 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3533 +            mBgAllAppsList.updateIconsAndLabels(updatedPackages, user, updatedApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3534 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3535 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3536 +        if (!updatedShortcuts.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3537 +            final UserHandleCompat userFinal = user;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3538 +            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3539 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3540 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3541 +                    Callbacks cb = getCallback();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3542 +                    if (cb != null &amp;&amp; callbacks == cb) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3543 +                        cb.bindShortcutsChanged(updatedShortcuts,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3544 +                                new ArrayList&lt;ShortcutInfo&gt;(), userFinal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3545 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3546 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3547 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3548 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3549 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3550 +        if (!updatedApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3551 +            mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3552 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3553 +                public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3554 +                    Callbacks cb = getCallback();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3555 +                    if (cb != null &amp;&amp; callbacks == cb) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3556 +                        cb.bindAppsUpdated(updatedApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3557 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3558 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3559 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3560 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3561 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3562 +        // Reload widget list. No need to refresh, as we only want to update the icons and labels.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3563 +        loadAndBindWidgetsAndShortcuts(mApp.getContext(), callbacks, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3564 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3565 +</span>
3566      void enqueuePackageUpdated(PackageUpdatedTask task) {
3567          sWorker.post(task);
3568      }
3569  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3570 -    private class AppsAvailabilityCheck extends BroadcastReceiver {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3571 +    @Thunk class AppsAvailabilityCheck extends BroadcastReceiver {</span>
3572  
3573          @Override
3574          public void onReceive(Context context, Intent intent) {
3575              synchronized (sBgLock) {
3576                  final LauncherAppsCompat launcherApps = LauncherAppsCompat
3577                          .getInstance(mApp.getContext());
3578                  final PackageManager manager = context.getPackageManager();
3579                  final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
3580                  final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
3581                  for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
3582                      UserHandleCompat user = entry.getKey();
3583                      packagesRemoved.clear();
3584                      packagesUnavailable.clear();
3585                      for (String pkg : entry.getValue()) {
3586                          if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
3587                              boolean packageOnSdcard = launcherApps.isAppEnabled(
3588                                      manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
3589                              if (packageOnSdcard) {
3590                                  Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
3591                                  packagesUnavailable.add(pkg);
3592                              } else {
3593                                  Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
3594                                  packagesRemoved.add(pkg);
3595                              }
3596                          }
3597                      }
3598                      if (!packagesRemoved.isEmpty()) {
3599                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
3600                                  packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
3601                      }
3602                      if (!packagesUnavailable.isEmpty()) {
3603                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
3604                                  packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));
3605                      }
3606                  }
3607                  sPendingPackages.clear();
3608              }
3609          }
3610      }
3611  
3612      private class PackageUpdatedTask implements Runnable {
3613          int mOp;
3614          String[] mPackages;
3615          UserHandleCompat mUser;
3616  
3617          public static final int OP_NONE = 0;
3618          public static final int OP_ADD = 1;
3619          public static final int OP_UPDATE = 2;
3620          public static final int OP_REMOVE = 3; // uninstlled
3621          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3622  
3623  
3624          public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3625              mOp = op;
3626              mPackages = packages;
3627              mUser = user;
3628          }
3629  
3630          public void run() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3631 +            if (!mHasLoaderCompletedOnce) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3632 +                // Loader has not yet run.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3633 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3634 +            }</span>
3635              final Context context = mApp.getContext();
3636  
3637              final String[] packages = mPackages;
3638              final int N = packages.length;
3639              switch (mOp) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3640 -                case OP_ADD:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3641 +                case OP_ADD: {</span>
3642                      for (int i=0; i&lt;N; i++) {
3643                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3644 -                        mIconCache.remove(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3645 +                        mIconCache.updateIconsForPkg(packages[i], mUser);</span>
3646                          mBgAllAppsList.addPackage(context, packages[i], mUser);
3647                      }
3648  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3649 -                    // Auto add shortcuts for added packages.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3650 -                    if (ADD_MANAGED_PROFILE_SHORTCUTS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3651 -                            &amp;&amp; !UserHandleCompat.myUserHandle().equals(mUser)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3652 -                        SharedPreferences prefs = context.getSharedPreferences(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3653 -                                LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3654 -                        String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3655 -                                + mUserManager.getSerialNumberForUser(mUser);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3656 -                        Set&lt;String&gt; shortcutSet = new HashSet&lt;String&gt;(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3657 -                                prefs.getStringSet(shortcutsSetKey,Collections.EMPTY_SET));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3658 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3659 -                        for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3660 -                            if (!shortcutSet.contains(packages[i])) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3661 -                                shortcutSet.add(packages[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3662 -                                List&lt;LauncherActivityInfoCompat&gt; activities =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3663 -                                        mLauncherApps.getActivityList(packages[i], mUser);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3664 -                                if (activities != null &amp;&amp; !activities.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3665 -                                    InstallShortcutReceiver.queueInstallShortcut(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3666 -                                            activities.get(0), context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3667 -                                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3668 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3669 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3670 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3671 -                        prefs.edit().putStringSet(shortcutsSetKey, shortcutSet).commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3672 +                    ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3673 +                    if (heuristic != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3674 +                        heuristic.processPackageAdd(mPackages);</span>
3675                      }
3676                      break;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3677 +                }</span>
3678                  case OP_UPDATE:
3679                      for (int i=0; i&lt;N; i++) {
3680                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3681 +                        mIconCache.updateIconsForPkg(packages[i], mUser);</span>
3682                          mBgAllAppsList.updatePackage(context, packages[i], mUser);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3683 -                        WidgetPreviewLoader.removePackageFromDb(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3684 -                                mApp.getWidgetPreviewCacheDb(), packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3685 +                        mApp.getWidgetCache().removePackage(packages[i], mUser);</span>
3686                      }
3687                      break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3688 -                case OP_REMOVE:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3689 -                    // Remove the packageName for the set of auto-installed shortcuts. This</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3690 -                    // will ensure that the shortcut when the app is installed again.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3691 -                    if (ADD_MANAGED_PROFILE_SHORTCUTS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3692 -                            &amp;&amp; !UserHandleCompat.myUserHandle().equals(mUser)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3693 -                        SharedPreferences prefs = context.getSharedPreferences(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3694 -                                LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3695 -                        String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3696 -                                + mUserManager.getSerialNumberForUser(mUser);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3697 -                        HashSet&lt;String&gt; shortcutSet = new HashSet&lt;String&gt;(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3698 -                                prefs.getStringSet(shortcutsSetKey, Collections.EMPTY_SET));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3699 -                        shortcutSet.removeAll(Arrays.asList(mPackages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3700 -                        prefs.edit().putStringSet(shortcutsSetKey, shortcutSet).commit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3701 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3702 -                    // Fall through</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3703 -                case OP_UNAVAILABLE:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3704 -                    boolean clearCache = mOp == OP_REMOVE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3705 +                case OP_REMOVE: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3706 +                    ManagedProfileHeuristic heuristic = ManagedProfileHeuristic.get(context, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3707 +                    if (heuristic != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3708 +                        heuristic.processPackageRemoved(mPackages);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3709 +                    }</span>
3710                      for (int i=0; i&lt;N; i++) {
3711                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3712 -                        mBgAllAppsList.removePackage(packages[i], mUser, clearCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3713 -                        WidgetPreviewLoader.removePackageFromDb(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3714 -                                mApp.getWidgetPreviewCacheDb(), packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3715 +                        mIconCache.removeIconsForPkg(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3716 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3717 +                    // Fall through</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3718 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3719 +                case OP_UNAVAILABLE:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3720 +                    for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3721 +                        if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3722 +                        mBgAllAppsList.removePackage(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3723 +                        mApp.getWidgetCache().removePackage(packages[i], mUser);</span>
3724                      }
3725                      break;
3726              }
3727  
3728              ArrayList&lt;AppInfo&gt; added = null;
3729              ArrayList&lt;AppInfo&gt; modified = null;
3730              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3731  
3732              if (mBgAllAppsList.added.size() &gt; 0) {
3733                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3734                  mBgAllAppsList.added.clear();
3735              }
3736              if (mBgAllAppsList.modified.size() &gt; 0) {
3737                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3738                  mBgAllAppsList.modified.clear();
3739              }
3740              if (mBgAllAppsList.removed.size() &gt; 0) {
3741                  removedApps.addAll(mBgAllAppsList.removed);
3742                  mBgAllAppsList.removed.clear();
3743              }
3744  
3745              final Callbacks callbacks = getCallback();
3746              if (callbacks == null) {
3747                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3748                  return;
3749              }
3750  
3751              final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps =
3752                      new HashMap&lt;ComponentName, AppInfo&gt;();
3753  
3754              if (added != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3755 -                // Ensure that we add all the workspace applications to the db</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3756 -                if (LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3757 -                    final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3758 -                    addAndBindAddedWorkspaceApps(context, addedInfos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3759 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3760 -                    addAppsToAllApps(context, added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3761 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3762 +                addAppsToAllApps(context, added);</span>
3763                  for (AppInfo ai : added) {
3764                      addedOrUpdatedApps.put(ai.componentName, ai);
3765                  }
3766              }
3767  
3768              if (modified != null) {
3769                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3770                  for (AppInfo ai : modified) {
3771                      addedOrUpdatedApps.put(ai.componentName, ai);
3772                  }
3773  
3774                  mHandler.post(new Runnable() {
3775                      public void run() {
3776                          Callbacks cb = getCallback();
3777                          if (callbacks == cb &amp;&amp; cb != null) {
3778                              callbacks.bindAppsUpdated(modifiedFinal);
3779                          }
3780                      }
3781                  });
3782              }
3783  
3784              // Update shortcut infos
3785              if (mOp == OP_ADD || mOp == OP_UPDATE) {
3786                  final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3787                  final ArrayList&lt;ShortcutInfo&gt; removedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3788                  final ArrayList&lt;LauncherAppWidgetInfo&gt; widgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
3789  
3790                  HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3791                  synchronized (sBgLock) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3792 -                    for (ItemInfo info : sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3793 +                    for (ItemInfo info : sBgItemsIdMap) {</span>
3794                          if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3795                              ShortcutInfo si = (ShortcutInfo) info;
3796                              boolean infoUpdated = false;
3797                              boolean shortcutUpdated = false;
3798  
3799                              // Update shortcuts which use iconResource.
3800                              if ((si.iconResource != null)
3801                                      &amp;&amp; packageSet.contains(si.iconResource.packageName)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3802 -                                Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3803 -                                        si.iconResource.resourceName, mIconCache, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3804 +                                Bitmap icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3805 +                                        si.iconResource.packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3806 +                                        si.iconResource.resourceName, context);</span>
3807                                  if (icon != null) {
3808                                      si.setIcon(icon);
3809                                      si.usingFallbackIcon = false;
3810                                      infoUpdated = true;
3811                                  }
3812                              }
3813  
3814                              ComponentName cn = si.getTargetComponent();
3815                              if (cn != null &amp;&amp; packageSet.contains(cn.getPackageName())) {
3816                                  AppInfo appInfo = addedOrUpdatedApps.get(cn);
3817  
3818                                  if (si.isPromise()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3819 -                                    mIconCache.deletePreloadedIcon(cn, mUser);</span>
3820                                      if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
3821                                          // Auto install icon
3822                                          PackageManager pm = context.getPackageManager();
3823                                          ResolveInfo matched = pm.resolveActivity(
3824                                                  new Intent(Intent.ACTION_MAIN)
3825                                                  .setComponent(cn).addCategory(Intent.CATEGORY_LAUNCHER),
3826                                                  PackageManager.MATCH_DEFAULT_ONLY);
3827                                          if (matched == null) {
3828                                              // Try to find the best match activity.
3829                                              Intent intent = pm.getLaunchIntentForPackage(
3830                                                      cn.getPackageName());
3831                                              if (intent != null) {
3832                                                  cn = intent.getComponent();
3833                                                  appInfo = addedOrUpdatedApps.get(cn);
3834                                              }
3835  
3836                                              if ((intent == null) || (appInfo == null)) {
3837                                                  removedShortcuts.add(si);
3838                                                  continue;
3839                                              }
3840                                              si.promisedIntent = intent;
3841                                          }
3842                                      }
3843  
3844                                      // Restore the shortcut.
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3845 +                                    if (appInfo != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3846 +                                        si.flags = appInfo.flags;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3847 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3848 +</span>
3849                                      si.intent = si.promisedIntent;
3850                                      si.promisedIntent = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3851 -                                    si.status &amp;= ~ShortcutInfo.FLAG_RESTORED_ICON</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3852 -                                            &amp; ~ShortcutInfo.FLAG_AUTOINTALL_ICON</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3853 -                                            &amp; ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3854 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3855 +                                    si.status = ShortcutInfo.DEFAULT;</span>
3856                                      infoUpdated = true;
3857                                      si.updateIcon(mIconCache);
3858                                  }
3859  
3860                                  if (appInfo != null &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction())
3861                                          &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
3862                                      si.updateIcon(mIconCache);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3863 -                                    si.title = appInfo.title.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3864 +                                    si.title = Utilities.trim(appInfo.title);</span>
3865                                      si.contentDescription = appInfo.contentDescription;
3866                                      infoUpdated = true;
3867                                  }
3868  
3869                                  if ((si.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE) != 0) {
3870                                      // Since package was just updated, the target must be available now.
3871                                      si.isDisabled &amp;= ~ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3872                                      shortcutUpdated = true;
3873                                  }
3874                              }
3875  
3876                              if (infoUpdated || shortcutUpdated) {
3877                                  updatedShortcuts.add(si);
3878                              }
3879                              if (infoUpdated) {
3880                                  updateItemInDatabase(context, si);
3881                              }
3882                          } else if (info instanceof LauncherAppWidgetInfo) {
3883                              LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) info;
3884                              if (mUser.equals(widgetInfo.user)
3885                                      &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3886                                      &amp;&amp; packageSet.contains(widgetInfo.providerName.getPackageName())) {
3887                                  widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;
3888                                  widgets.add(widgetInfo);
3889                                  updateItemInDatabase(context, widgetInfo);
3890                              }
3891                          }
3892                      }
3893                  }
3894  
3895                  if (!updatedShortcuts.isEmpty() || !removedShortcuts.isEmpty()) {
3896                      mHandler.post(new Runnable() {
3897  
3898                          public void run() {
3899                              Callbacks cb = getCallback();
3900                              if (callbacks == cb &amp;&amp; cb != null) {
3901                                  callbacks.bindShortcutsChanged(
3902                                          updatedShortcuts, removedShortcuts, mUser);
3903                              }
3904                          }
3905                      });
3906                      if (!removedShortcuts.isEmpty()) {
3907                          deleteItemsFromDatabase(context, removedShortcuts);
3908                      }
3909                  }
3910                  if (!widgets.isEmpty()) {
3911                      mHandler.post(new Runnable() {
3912                          public void run() {
3913                              Callbacks cb = getCallback();
3914                              if (callbacks == cb &amp;&amp; cb != null) {
3915                                  callbacks.bindWidgetsRestored(widgets);
3916                              }
3917                          }
3918                      });
3919                  }
3920              }
3921  
3922              final ArrayList&lt;String&gt; removedPackageNames =
3923                      new ArrayList&lt;String&gt;();
3924              if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3925                  // Mark all packages in the broadcast to be removed
3926                  removedPackageNames.addAll(Arrays.asList(packages));
3927              } else if (mOp == OP_UPDATE) {
3928                  // Mark disabled packages in the broadcast to be removed
3929                  for (int i=0; i&lt;N; i++) {
3930                      if (isPackageDisabled(context, packages[i], mUser)) {
3931                          removedPackageNames.add(packages[i]);
3932                      }
3933                  }
3934              }
3935  
3936              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3937                  final int removeReason;
3938                  if (mOp == OP_UNAVAILABLE) {
3939                      removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3940                  } else {
3941                      // Remove all the components associated with this package
3942                      for (String pn : removedPackageNames) {
3943                          deletePackageFromDatabase(context, pn, mUser);
3944                      }
3945                      // Remove all the specific components
3946                      for (AppInfo a : removedApps) {
3947                          ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3948                          deleteItemsFromDatabase(context, infos);
3949                      }
3950                      removeReason = 0;
3951                  }
3952  
3953                  // Remove any queued items from the install queue
3954                  InstallShortcutReceiver.removeFromInstallQueue(context, removedPackageNames, mUser);
3955                  // Call the components-removed callback
3956                  mHandler.post(new Runnable() {
3957                      public void run() {
3958                          Callbacks cb = getCallback();
3959                          if (callbacks == cb &amp;&amp; cb != null) {
3960                              callbacks.bindComponentsRemoved(
3961                                      removedPackageNames, removedApps, mUser, removeReason);
3962                          }
3963                      }
3964                  });
3965              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3966 -            if (Build.VERSION.SDK_INT &lt; 17) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3967 -                loadAndBindWidgetsAndShortcuts(context, callbacks);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3968 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3969 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3970 +            // onProvidersChanged method (API &gt;= 17) already refreshed the widget list</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3971 +            loadAndBindWidgetsAndShortcuts(context, callbacks, Build.VERSION.SDK_INT &lt; 17);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3972 +</span>
3973              // Write all the logs to disk
3974              mHandler.post(new Runnable() {
3975                  public void run() {
3976                      Callbacks cb = getCallback();
3977                      if (callbacks == cb &amp;&amp; cb != null) {
3978                          callbacks.dumpLogsToLocalData();
3979                      }
3980                  }
3981              });
3982          }
3983      }
3984  
3985      public static List&lt;LauncherAppWidgetProviderInfo&gt; getWidgetProviders(Context context,
3986              boolean refresh) {
3987          ArrayList&lt;LauncherAppWidgetProviderInfo&gt; results =
3988                  new ArrayList&lt;LauncherAppWidgetProviderInfo&gt;();
3989          try {
3990              synchronized (sBgLock) {
3991                  if (sBgWidgetProviders == null || refresh) {
3992                      HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; tmpWidgetProviders
3993                              = new HashMap&lt;&gt;();
3994                      AppWidgetManagerCompat wm = AppWidgetManagerCompat.getInstance(context);
3995                      LauncherAppWidgetProviderInfo info;
3996  
3997                      List&lt;AppWidgetProviderInfo&gt; widgets = wm.getAllProviders();
3998                      for (AppWidgetProviderInfo pInfo : widgets) {
3999                          info = LauncherAppWidgetProviderInfo.fromProviderInfo(context, pInfo);
4000                          UserHandleCompat user = wm.getUser(info);
4001                          tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
4002                      }
4003  
4004                      Collection&lt;CustomAppWidget&gt; customWidgets = Launcher.getCustomAppWidgets().values();
4005                      for (CustomAppWidget widget : customWidgets) {
4006                          info = new LauncherAppWidgetProviderInfo(context, widget);
4007                          UserHandleCompat user = wm.getUser(info);
4008                          tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
4009                      }
4010                      // Replace the global list at the very end, so that if there is an exception,
4011                      // previously loaded provider list is used.
4012                      sBgWidgetProviders = tmpWidgetProviders;
4013                  }
4014                  results.addAll(sBgWidgetProviders.values());
4015                  return results;
4016              }
4017          } catch (Exception e) {
4018              if (e.getCause() instanceof TransactionTooLargeException) {
4019                  // the returned value may be incomplete and will not be refreshed until the next
4020                  // time Launcher starts.
4021                  // TODO: after figuring out a repro step, introduce a dirty bit to check when
4022                  // onResume is called to refresh the widget provider list.
4023                  synchronized (sBgLock) {
4024                      if (sBgWidgetProviders != null) {
4025                          results.addAll(sBgWidgetProviders.values());
4026                      }
4027                      return results;
4028                  }
4029              } else {
4030                  throw e;
4031              }
4032          }
4033      }
4034  
4035      public static LauncherAppWidgetProviderInfo getProviderInfo(Context ctx, ComponentName name,
4036              UserHandleCompat user) {
4037          synchronized (sBgLock) {
4038              if (sBgWidgetProviders == null) {
4039                  getWidgetProviders(ctx, false /* refresh */);
4040              }
4041              return sBgWidgetProviders.get(new ComponentKey(name, user));
4042          }
4043      }
4044  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4045 -    public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4046 -        runOnWorkerThread(new Runnable(){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4047 +    public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4048 +            final boolean refresh) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4049 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4050 +        runOnWorkerThread(new Runnable() {</span>
4051              @Override
4052              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4053 -                final ArrayList&lt;Object&gt; list =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4054 -                        getSortedWidgetsAndShortcuts(context, true /* refresh */);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4055 +                updateWidgetsModel(context, refresh);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4056 +                final WidgetsModel model = mBgWidgetsModel.clone();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4057 +</span>
4058                  mHandler.post(new Runnable() {
4059                      @Override
4060                      public void run() {
4061                          Callbacks cb = getCallback();
4062                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4063 -                            callbacks.bindPackagesUpdated(list);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4064 +                            callbacks.bindAllPackages(model);</span>
4065                          }
4066                      }
4067                  });
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4068 +                // update the Widget entries inside DB on the worker thread.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4069 +                LauncherAppState.getInstance().getWidgetCache().removeObsoletePreviews(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4070 +                        model.getRawList());</span>
4071              }
4072          });
4073      }
4074  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4075 -    // Returns a list of ResolveInfos/AppWidgetInfos in sorted order</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4076 -    public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context, boolean refresh) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4077 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4078 +     * Returns a list of ResolveInfos/AppWidgetInfos.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4079 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4080 +     * @see #loadAndBindWidgetsAndShortcuts</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4081 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4082 +    @Thunk void updateWidgetsModel(Context context, boolean refresh) {</span>
4083          PackageManager packageManager = context.getPackageManager();
4084          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
4085          widgetsAndShortcuts.addAll(getWidgetProviders(context, refresh));
4086          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
4087          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4088 -        Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4089 -        return widgetsAndShortcuts;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4090 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4091 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4092 -    private static boolean isPackageDisabled(Context context, String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4093 +        mBgWidgetsModel.setWidgetsAndShortcuts(widgetsAndShortcuts);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4094 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4095 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4096 +    @Thunk static boolean isPackageDisabled(Context context, String packageName,</span>
4097              UserHandleCompat user) {
4098          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
4099          return !launcherApps.isPackageEnabledForProfile(packageName, user);
4100      }
4101  
4102      public static boolean isValidPackageActivity(Context context, ComponentName cn,
4103              UserHandleCompat user) {
4104          if (cn == null) {
4105              return false;
4106          }
4107          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
4108          if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
4109              return false;
4110          }
4111          return launcherApps.isActivityEnabledForProfile(cn, user);
4112      }
4113  
4114      public static boolean isValidPackage(Context context, String packageName,
4115              UserHandleCompat user) {
4116          if (packageName == null) {
4117              return false;
4118          }
4119          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
4120          return launcherApps.isPackageEnabledForProfile(packageName, user);
4121      }
4122  
4123      /**
4124       * Make an ShortcutInfo object for a restored application or shortcut item that points
4125       * to a package that is not yet installed on the system.
4126       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4127 -    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4128 -            int promiseType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4129 +    public ShortcutInfo getRestoredItemInfo(Cursor c, int titleIndex, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4130 +            int promiseType, int itemType, CursorIconInfo iconInfo, Context context) {</span>
4131          final ShortcutInfo info = new ShortcutInfo();
4132          info.user = UserHandleCompat.myUserHandle();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4133 -        mIconCache.getTitleAndIcon(info, intent, info.user, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4134 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4135 +        Bitmap icon = iconInfo.loadIcon(c, info, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4136 +        // the fallback icon</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4137 +        if (icon == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4138 +            mIconCache.getTitleAndIcon(info, intent, info.user, false /* useLowResIcon */);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4139 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4140 +            info.setIcon(icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4141 +        }</span>
4142  
4143          if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4144 -            String title = (cursor != null) ? cursor.getString(titleIndex) : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4145 +            String title = (c != null) ? c.getString(titleIndex) : null;</span>
4146              if (!TextUtils.isEmpty(title)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4147 -                info.title = title;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4148 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4149 -            info.status = ShortcutInfo.FLAG_RESTORED_ICON;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4150 +                info.title = Utilities.trim(title);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4151 +            }</span>
4152          } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
4153              if (TextUtils.isEmpty(info.title)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4154 -                info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4155 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4156 -            info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4157 +                info.title = (c != null) ? Utilities.trim(c.getString(titleIndex)) : &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4158 +            }</span>
4159          } else {
4160              throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
4161          }
4162  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4163 -        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4164 -                info.title.toString(), info.user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4165 -        info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4166 +        info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4167 +        info.itemType = itemType;</span>
4168          info.promisedIntent = intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4169 +        info.status = promiseType;</span>
4170          return info;
4171      }
4172  
4173      /**
4174       * Make an Intent object for a restored application or shortcut item that points
4175       * to the market page for the item.
4176       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4177 -    private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4178 +    @Thunk Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {</span>
4179          ComponentName componentName = intent.getComponent();
4180          return getMarketIntent(componentName.getPackageName());
4181      }
4182  
4183      static Intent getMarketIntent(String packageName) {
4184          return new Intent(Intent.ACTION_VIEW)
4185              .setData(new Uri.Builder()
4186                  .scheme(&quot;market&quot;)
4187                  .authority(&quot;details&quot;)
4188                  .appendQueryParameter(&quot;id&quot;, packageName)
4189                  .build());
4190      }
4191  
4192      /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4193 -     * This is called from the code that adds shortcuts from the intent receiver.  This</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4194 -     * doesn&#x27;t have a Cursor, but</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4195 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4196 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4197 -            UserHandleCompat user, Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4198 -        return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4199 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4200 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4201 -    /**</span>
4202       * Make an ShortcutInfo object for a shortcut that is an application.
4203       *
4204       * If c is not null, then it will be used to fill in missing data like the title and icon.
4205       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4206 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4207 +    public ShortcutInfo getAppShortcutInfo(PackageManager manager, Intent intent,</span>
4208              UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4209 -            HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4210 +            boolean allowMissingTarget, boolean useLowResIcon) {</span>
4211          if (user == null) {
4212              Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
4213              return null;
4214          }
4215  
4216          ComponentName componentName = intent.getComponent();
4217          if (componentName == null) {
4218              Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
4219              return null;
4220          }
4221  
4222          Intent newIntent = new Intent(intent.getAction(), null);
4223          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
4224          newIntent.setComponent(componentName);
4225          LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
4226          if ((lai == null) &amp;&amp; !allowMissingTarget) {
4227              Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
4228              return null;
4229          }
4230  
4231          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4232 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4233 -        // the resource -- This may implicitly give us back the fallback icon,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4234 -        // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4235 -        // to avoid saving lots of copies of that in the database, and most apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4236 -        // have icons anyway.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4237 -        Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4238 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4239 -        // the db</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4240 -        if (icon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4241 -            if (c != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4242 -                icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4243 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4244 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4245 -        // the fallback icon</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4246 -        if (icon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4247 -            icon = mIconCache.getDefaultIcon(user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4248 -            info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4249 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4250 -        info.setIcon(icon);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4251 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4252 -        // From the cache.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4253 -        if (labelCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4254 -            info.title = labelCache.get(componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4255 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4256 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4257 -        // from the resource</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4258 -        if (info.title == null &amp;&amp; lai != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4259 -            info.title = lai.getLabel();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4260 -            if (labelCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4261 -                labelCache.put(componentName, info.title);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4262 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4263 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4264 +        mIconCache.getTitleAndIcon(info, componentName, lai, user, false, useLowResIcon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4265 +        if (mIconCache.isDefaultIcon(info.getIcon(mIconCache), user) &amp;&amp; c != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4266 +            Bitmap icon = Utilities.createIconBitmap(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4267 +            info.setIcon(icon == null ? mIconCache.getDefaultIcon(user) : icon);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4268 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4269 +</span>
4270          // from the db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4271 -        if (info.title == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4272 -            if (c != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4273 -                info.title =  c.getString(titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4274 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4275 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4276 +        if (TextUtils.isEmpty(info.title) &amp;&amp; c != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4277 +            info.title =  Utilities.trim(c.getString(titleIndex));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4278 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4279 +</span>
4280          // fall back to the class name of the activity
4281          if (info.title == null) {
4282              info.title = componentName.getClassName();
4283          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4284 +</span>
4285          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
4286          info.user = user;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4287 -        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4288 -                info.title.toString(), info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4289 +        info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4290 +        if (lai != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4291 +            info.flags = AppInfo.initFlags(lai);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4292 +        }</span>
4293          return info;
4294      }
4295  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4296 -    static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4297 +    static ArrayList&lt;ItemInfo&gt; filterItemInfos(Iterable&lt;ItemInfo&gt; infos,</span>
4298              ItemInfoFilter f) {
4299          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
4300          for (ItemInfo i : infos) {
4301              if (i instanceof ShortcutInfo) {
4302                  ShortcutInfo info = (ShortcutInfo) i;
4303                  ComponentName cn = info.getTargetComponent();
4304                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
4305                      filtered.add(info);
4306                  }
4307              } else if (i instanceof FolderInfo) {
4308                  FolderInfo info = (FolderInfo) i;
4309                  for (ShortcutInfo s : info.contents) {
4310                      ComponentName cn = s.getTargetComponent();
4311                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
4312                          filtered.add(s);
4313                      }
4314                  }
4315              } else if (i instanceof LauncherAppWidgetInfo) {
4316                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
4317                  ComponentName cn = info.providerName;
4318                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
4319                      filtered.add(info);
4320                  }
4321              }
4322          }
4323          return new ArrayList&lt;ItemInfo&gt;(filtered);
4324      }
4325  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4326 -    private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4327 +    @Thunk ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,</span>
4328              final UserHandleCompat user) {
4329          ItemInfoFilter filter  = new ItemInfoFilter() {
4330              @Override
4331              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
4332                  if (info.user == null) {
4333                      return cn.equals(cname);
4334                  } else {
4335                      return cn.equals(cname) &amp;&amp; info.user.equals(user);
4336                  }
4337              }
4338          };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4339 -        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4340 +        return filterItemInfos(sBgItemsIdMap, filter);</span>
4341      }
4342  
4343      /**
4344       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
4345       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4346 -    private ShortcutInfo getShortcutInfo(Cursor c, Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4347 -            int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4348 -            int titleIndex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4349 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4350 -        Bitmap icon = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4351 +    @Thunk ShortcutInfo getShortcutInfo(Cursor c, Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4352 +            int titleIndex, CursorIconInfo iconInfo) {</span>
4353          final ShortcutInfo info = new ShortcutInfo();
4354          // Non-app shortcuts are only supported for current user.
4355          info.user = UserHandleCompat.myUserHandle();
4356          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
4357  
4358          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
4359  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4360 -        info.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4361 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4362 -        int iconType = c.getInt(iconTypeIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4363 -        switch (iconType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4364 -        case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4365 -            String packageName = c.getString(iconPackageIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4366 -            String resourceName = c.getString(iconResourceIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4367 -            info.customIcon = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4368 -            // the resource</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4369 -            icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4370 -            // the db</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4371 -            if (icon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4372 -                icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4373 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4374 -            // the fallback icon</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4375 -            if (icon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4376 -                icon = mIconCache.getDefaultIcon(info.user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4377 -                info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4378 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4379 -            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4380 -        case LauncherSettings.Favorites.ICON_TYPE_BITMAP:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4381 -            icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4382 -            if (icon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4383 -                icon = mIconCache.getDefaultIcon(info.user);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4384 -                info.customIcon = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4385 -                info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4386 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4387 -                info.customIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4388 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4389 -            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4390 -        default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4391 +        info.title = Utilities.trim(c.getString(titleIndex));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4392 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4393 +        Bitmap icon = iconInfo.loadIcon(c, info, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4394 +        // the fallback icon</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4395 +        if (icon == null) {</span>
4396              icon = mIconCache.getDefaultIcon(info.user);
4397              info.usingFallbackIcon = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4398 -            info.customIcon = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4399 -            break;</span>
4400          }
4401          info.setIcon(icon);
4402          return info;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4403 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4404 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4405 -    Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4406 -        @SuppressWarnings(&quot;all&quot;) // suppress dead code warning</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4407 -        final boolean debug = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4408 -        if (debug) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4409 -            Log.d(TAG, &quot;getIconFromCursor app=&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4410 -                    + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4411 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4412 -        byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4413 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4414 -            return Utilities.createIconBitmap(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4415 -                    BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4416 -        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4417 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4418 -        }</span>
4419      }
4420  
4421      ShortcutInfo infoFromShortcutIntent(Context context, Intent data) {
4422          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
4423          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
4424          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
4425  
4426          if (intent == null) {
4427              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
4428              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
4429              return null;
4430          }
4431  
4432          Bitmap icon = null;
4433          boolean customIcon = false;
4434          ShortcutIconResource iconResource = null;
4435  
4436          if (bitmap instanceof Bitmap) {
4437              icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
4438              customIcon = true;
4439          } else {
4440              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
4441              if (extra instanceof ShortcutIconResource) {
4442                  iconResource = (ShortcutIconResource) extra;
4443                  icon = Utilities.createIconBitmap(iconResource.packageName,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4444 -                        iconResource.resourceName, mIconCache, context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4445 +                        iconResource.resourceName, context);</span>
4446              }
4447          }
4448  
4449          final ShortcutInfo info = new ShortcutInfo();
4450  
4451          // Only support intents for current user for now. Intents sent from other
4452          // users wouldn&#x27;t get here without intent forwarding anyway.
4453          info.user = UserHandleCompat.myUserHandle();
4454          if (icon == null) {
4455              icon = mIconCache.getDefaultIcon(info.user);
4456              info.usingFallbackIcon = true;
4457          }
4458          info.setIcon(icon);
4459  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4460 -        info.title = name;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4461 -        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4462 -                info.title.toString(), info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4463 +        info.title = Utilities.trim(name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4464 +        info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);</span>
4465          info.intent = intent;
4466          info.customIcon = customIcon;
4467          info.iconResource = iconResource;
4468  
4469          return info;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4470 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4471 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4472 -    boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4473 -            int iconIndex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4474 -        // If apps can&#x27;t be on SD, don&#x27;t even bother.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4475 -        if (!mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4476 -            return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4477 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4478 -        // If this icon doesn&#x27;t have a custom icon, check to see</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4479 -        // what&#x27;s stored in the DB, and if it doesn&#x27;t match what</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4480 -        // we&#x27;re going to show, store what we are going to show back</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4481 -        // into the DB.  We do this so when we&#x27;re loading, if the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4482 -        // package manager can&#x27;t find an icon (for example because</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4483 -        // the app is on SD) then we can use that instead.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4484 -        if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4485 -            cache.put(info, c.getBlob(iconIndex));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4486 -            return true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4487 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4488 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4489 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4490 -    void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4491 -        boolean needSave = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4492 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4493 -            if (data != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4494 -                Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4495 -                Bitmap loaded = info.getIcon(mIconCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4496 -                needSave = !saved.sameAs(loaded);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4497 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4498 -                needSave = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4499 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4500 -        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4501 -            needSave = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4502 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4503 -        if (needSave) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4504 -            Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4505 -            // This is slower than is ideal, but this only happens once</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4506 -            // or when the app is updated with a new icon.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4507 -            updateItemInDatabase(context, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4508 -        }</span>
4509      }
4510  
4511      /**
4512       * Return an existing FolderInfo object if we have encountered this ID previously,
4513       * or make a new one.
4514       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4515 -    private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4516 +    @Thunk static FolderInfo findOrMakeFolder(LongArrayMap&lt;FolderInfo&gt; folders, long id) {</span>
4517          // See if a placeholder was created for us already
4518          FolderInfo folderInfo = folders.get(id);
4519          if (folderInfo == null) {
4520              // No placeholder -- create a new instance
4521              folderInfo = new FolderInfo();
4522              folders.put(id, folderInfo);
4523          }
4524          return folderInfo;
4525      }
4526  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4527 -    public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4528 -        final Collator collator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4529 -        return new Comparator&lt;AppInfo&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4530 -            public final int compare(AppInfo a, AppInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4531 -                if (a.user.equals(b.user)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4532 -                    int result = collator.compare(a.title.toString().trim(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4533 -                            b.title.toString().trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4534 -                    if (result == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4535 -                        result = a.componentName.compareTo(b.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4536 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4537 -                    return result;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4538 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4539 -                    // TODO Need to figure out rules for sorting</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4540 -                    // profiles, this puts work second.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4541 -                    return a.user.toString().compareTo(b.user.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4542 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4543 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4544 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4545 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4546 -    public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4547 -            = new Comparator&lt;AppInfo&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4548 -        public final int compare(AppInfo a, AppInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4549 -            if (a.firstInstallTime &lt; b.firstInstallTime) return 1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4550 -            if (a.firstInstallTime &gt; b.firstInstallTime) return -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4551 -            return 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4552 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4553 -    };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4554 -    static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4555 -        if (info.activityInfo != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4556 -            return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4557 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4558 -            return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4559 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4560 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4561 -    public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4562 -        private Collator mCollator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4563 -        private HashMap&lt;Object, CharSequence&gt; mLabelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4564 -        ShortcutNameComparator(PackageManager pm) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4565 -            mLabelCache = new HashMap&lt;Object, CharSequence&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4566 -            mCollator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4567 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4568 -        ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4569 -            mLabelCache = labelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4570 -            mCollator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4571 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4572 -        public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4573 -            String labelA, labelB;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4574 -            ComponentName keyA = a.getComponentName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4575 -            ComponentName keyB = b.getComponentName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4576 -            if (mLabelCache.containsKey(keyA)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4577 -                labelA = mLabelCache.get(keyA).toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4578 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4579 -                labelA = a.getLabel().toString().trim();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4580 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4581 -                mLabelCache.put(keyA, labelA);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4582 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4583 -            if (mLabelCache.containsKey(keyB)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4584 -                labelB = mLabelCache.get(keyB).toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4585 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4586 -                labelB = b.getLabel().toString().trim();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4587 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4588 -                mLabelCache.put(keyB, labelB);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4589 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4590 -            return mCollator.compare(labelA, labelB);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4591 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4592 -    };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4593 -    public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4594 -        private final AppWidgetManagerCompat mManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4595 -        private final PackageManager mPackageManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4596 -        private final HashMap&lt;Object, String&gt; mLabelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4597 -        private final Collator mCollator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4598 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4599 -        WidgetAndShortcutNameComparator(Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4600 -            mManager = AppWidgetManagerCompat.getInstance(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4601 -            mPackageManager = context.getPackageManager();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4602 -            mLabelCache = new HashMap&lt;Object, String&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4603 -            mCollator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4604 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4605 -        public final int compare(Object a, Object b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4606 -            String labelA, labelB;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4607 -            if (mLabelCache.containsKey(a)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4608 -                labelA = mLabelCache.get(a);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4609 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4610 -                labelA = (a instanceof LauncherAppWidgetProviderInfo)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4611 -                        ? mManager.loadLabel((LauncherAppWidgetProviderInfo) a)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4612 -                        : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4613 -                mLabelCache.put(a, labelA);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4614 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4615 -            if (mLabelCache.containsKey(b)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4616 -                labelB = mLabelCache.get(b);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4617 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4618 -                labelB = (b instanceof LauncherAppWidgetProviderInfo)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4619 -                        ? mManager.loadLabel((LauncherAppWidgetProviderInfo) b)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4620 -                        : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4621 -                mLabelCache.put(b, labelB);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4622 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4623 -            return mCollator.compare(labelA, labelB);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4624 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4625 -    };</span>
4626  
4627      static boolean isValidProvider(AppWidgetProviderInfo provider) {
4628          return (provider != null) &amp;&amp; (provider.provider != null)
4629                  &amp;&amp; (provider.provider.getPackageName() != null);
4630      }
4631  
4632      public void dumpState() {
4633          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
4634          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
4635          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
4636          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
4637          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
4638          if (mLoaderTask != null) {
4639              mLoaderTask.dumpState();
4640          } else {
4641              Log.d(TAG, &quot;mLoaderTask=null&quot;);
4642          }
4643      }
4644  
4645      public Callbacks getCallback() {
4646          return mCallbacks != null ? mCallbacks.get() : null;
4647      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4648 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4649 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4650 +     * @return {@link FolderInfo} if its already loaded.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4651 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4652 +    public FolderInfo findFolderById(Long folderId) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4653 +        synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4654 +            return sBgFolders.get(folderId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4655 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4656 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4657 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4658 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4659 +     * @return the looper for the worker thread which can be used to start background tasks.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4660 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4661 +    public static Looper getWorkerLooper() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4662 +        return sWorkerThread.getLooper();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4663 +    }</span>
4664  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetProviderInfo;
  21  import android.content.BroadcastReceiver;
  22  import android.content.ComponentName;
  23  import android.content.ContentProviderClient;
  24  import android.content.ContentProviderOperation;
  25  import android.content.ContentResolver;
  26  import android.content.ContentValues;
  27  import android.content.Context;
  28  import android.content.Intent;
  29  import android.content.Intent.ShortcutIconResource;
  30  import android.content.IntentFilter;
  31  import android.content.SharedPreferences;
  32  import android.content.pm.PackageManager;
  33  import android.content.pm.ProviderInfo;
  34  import android.content.pm.ResolveInfo;
  35  import android.content.res.Configuration;
  36  import android.content.res.Resources;
  37  import android.database.Cursor;
  38  import android.graphics.Bitmap;
  39  import android.graphics.BitmapFactory;
  40  import android.graphics.Rect;
  41  import android.net.Uri;
  42  import android.os.Build;
  43  import android.os.Environment;
  44  import android.os.Handler;
  45  import android.os.HandlerThread;

  46  import android.os.Parcelable;
  47  import android.os.Process;
  48  import android.os.RemoteException;
  49  import android.os.SystemClock;
  50  import android.os.TransactionTooLargeException;
  51  import android.provider.BaseColumns;
  52  import android.text.TextUtils;
  53  import android.util.Log;
  54  import android.util.LongSparseArray;
  55  import android.util.Pair;
  56  
  57  import com.android.launcher3.compat.AppWidgetManagerCompat;
  58  import com.android.launcher3.compat.LauncherActivityInfoCompat;
  59  import com.android.launcher3.compat.LauncherAppsCompat;
  60  import com.android.launcher3.compat.PackageInstallerCompat;
  61  import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  62  import com.android.launcher3.compat.UserHandleCompat;
  63  import com.android.launcher3.compat.UserManagerCompat;

  64  import com.android.launcher3.util.ComponentKey;




  65  
  66  import java.lang.ref.WeakReference;
  67  import java.net.URISyntaxException;
  68  import java.security.InvalidParameterException;
  69  import java.text.Collator;
  70  import java.util.ArrayList;
  71  import java.util.Arrays;
  72  import java.util.Collection;
  73  import java.util.Collections;
  74  import java.util.Comparator;
  75  import java.util.HashMap;
  76  import java.util.HashSet;
  77  import java.util.Iterator;
  78  import java.util.List;
  79  import java.util.Map.Entry;
  80  import java.util.Set;
  81  import java.util.TreeMap;
  82  
  83  /**
  84   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  85   * LauncherModel object held in a static. Also provide APIs for updating the database state
  86   * for the Launcher.
  87   */
  88  public class LauncherModel extends BroadcastReceiver
  89          implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  90      static final boolean DEBUG_LOADERS = false;
  91      private static final boolean DEBUG_RECEIVER = false;
  92      private static final boolean REMOVE_UNRESTORED_ICONS = true;
  93      private static final boolean ADD_MANAGED_PROFILE_SHORTCUTS = false;
  94  
  95      static final String TAG = &quot;Launcher.Model&quot;;
  96  
  97      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  98      // false = strew non-workspace apps across the workspace on upgrade
  99      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
 100      public static final int LOADER_FLAG_NONE = 0;
 101      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 102      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 103  
 104      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 105      private static final long INVALID_SCREEN_ID = -1L;
 106  
 107      private final boolean mAppsCanBeOnRemoveableStorage;

 108      private final boolean mOldContentProviderExists;
 109  
 110      private final LauncherAppState mApp;
 111      private final Object mLock = new Object();
 112      private DeferredHandler mHandler = new DeferredHandler();
 113      private LoaderTask mLoaderTask;
 114      private boolean mIsLoaderTaskRunning;
 115  
 116      /**
 117       * Maintain a set of packages per user, for which we added a shortcut on the workspace.
 118       */
 119      private static final String INSTALLED_SHORTCUTS_SET_PREFIX = &quot;installed_shortcuts_set_for_user_&quot;;
 120  
 121      // Specific runnable types that are run on the main thread deferred handler, this allows us to
 122      // clear all queued binding runnables when the Launcher activity is destroyed.
 123      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 124      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;






 125  
 126      private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 127  
 128      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);

 129      static {
 130          sWorkerThread.start();
 131      }
 132      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());

 133  
 134      // We start off with everything not loaded.  After that, we assume that
 135      // our monitoring of the package manager provides all updates and we never
 136      // need to do a requery.  These are only ever touched from the loader thread.
 137      private boolean mWorkspaceLoaded;
 138      private boolean mAllAppsLoaded;


 139  
 140      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 141      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 142      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 143      // a normal load, we also clear this set of Runnables.
 144      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 145  
 146      private WeakReference&lt;Callbacks&gt; mCallbacks;







 147  
 148      // &lt; only access in worker thread &gt;
 149      AllAppsList mBgAllAppsList;


 150  
 151      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 152      // other locks, this one can generally be held long-term because we never expect any of these
 153      // static data structures to be referenced outside of the worker thread except on the first
 154      // load after configuration change.
 155      static final Object sBgLock = new Object();
 156  
 157      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 158      // LauncherModel to their ids
 159      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();

 160  
 161      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 162      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 163      //       shortcuts within folders).
 164      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 165  
 166      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 167      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 168          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 169  
 170      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 171      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 172  
 173      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 174      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();

 175  
 176      // sBgWorkspaceScreens is the ordered set of workspace screens.
 177      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 178  
 179      // sBgWidgetProviders is the set of widget providers including custom internal widgets
 180      public static HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; sBgWidgetProviders;
 181  
 182      // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 183      static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 184              new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 185  
 186      // &lt;/ only access in worker thread &gt;
 187  
 188      private IconCache mIconCache;
 189  
 190      protected int mPreviousConfigMcc;
 191  
 192      private final LauncherAppsCompat mLauncherApps;
 193      private final UserManagerCompat mUserManager;




 194  
 195      public interface Callbacks {
 196          public boolean setLoadOnResume();
 197          public int getCurrentWorkspaceScreen();
 198          public void startBinding();
 199          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 200                                boolean forceAnimateIcons);
 201          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 202          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 203          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 204          public void finishBindingItems(boolean upgradePath);


 205          public void bindAppWidget(LauncherAppWidgetInfo info);
 206          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 207          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 208                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 209                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 210                                    ArrayList&lt;AppInfo&gt; addedApps);
 211          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 212          public void bindShortcutsChanged(ArrayList&lt;ShortcutInfo&gt; updated,
 213                  ArrayList&lt;ShortcutInfo&gt; removed, UserHandleCompat user);
 214          public void bindWidgetsRestored(ArrayList&lt;LauncherAppWidgetInfo&gt; widgets);
 215          public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 216          public void updatePackageBadge(String packageName);

 217          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 218                          ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user, int reason);
 219          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);

 220          public void bindSearchablesChanged();
 221          public boolean isAllAppsButtonRank(int rank);
 222          public void onPageBoundSynchronously(int page);
 223          public void dumpLogsToLocalData();
 224          public void bindAddPendingItem(PendingAddItemInfo info, long container, long screenId,
 225                  int[] cell, int spanX, int spanY);
 226      }
 227  
 228      public interface ItemInfoFilter {
 229          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 230      }
 231  
 232      public interface ScreenPosProvider {
 233          int getScreenIndex(ArrayList&lt;Long&gt; screenIDs);
 234      }
 235  
 236      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 237          Context context = app.getContext();
 238  
 239          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 240          String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 241          // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 242          // resource string.
 243          String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 244          ProviderInfo providerInfo =
 245                  context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 246          ProviderInfo redirectProvider =
 247                  context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 248  
 249          Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 250          mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 251  
 252          if (mOldContentProviderExists) {
 253              Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 254          } else {
 255              Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 256          }
 257  
 258          mApp = app;
 259          mBgAllAppsList = new AllAppsList(iconCache, appFilter);

 260          mIconCache = iconCache;
 261  
 262          final Resources res = context.getResources();
 263          Configuration config = res.getConfiguration();
 264          mPreviousConfigMcc = config.mcc;
 265          mLauncherApps = LauncherAppsCompat.getInstance(context);
 266          mUserManager = UserManagerCompat.getInstance(context);
 267      }
 268  
 269      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 270       * posted on the main thread handler. */
 271      private void runOnMainThread(Runnable r) {
 272          runOnMainThread(r, 0);
 273      }
 274      private void runOnMainThread(Runnable r, int type) {

 275          if (sWorkerThread.getThreadId() == Process.myTid()) {
 276              // If we are on the worker thread, post onto the main handler
 277              mHandler.post(r);
 278          } else {
 279              r.run();
 280          }
 281      }
 282  
 283      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 284       * posted on the worker thread handler. */
 285      private static void runOnWorkerThread(Runnable r) {
 286          if (sWorkerThread.getThreadId() == Process.myTid()) {
 287              r.run();
 288          } else {
 289              // If we are not on the worker thread, then post to the worker handler
 290              sWorker.post(r);
 291          }
 292      }
 293  













 294      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 295          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 296      }
 297  
 298      public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 299          // Process the updated package state
 300          Runnable r = new Runnable() {




 301              public void run() {
 302                  Callbacks callbacks = getCallback();
 303                  if (callbacks != null) {
 304                      callbacks.updatePackageState(installInfo);












































 305                  }
 306              }
 307          };
 308          mHandler.post(r);
 309      }
 310  
 311      public void updatePackageBadge(final String packageName) {
 312          // Process the updated package badge
 313          Runnable r = new Runnable() {










 314              public void run() {
 315                  Callbacks callbacks = getCallback();
 316                  if (callbacks != null) {
 317                      callbacks.updatePackageBadge(packageName);





































 318                  }
 319              }
 320          };
 321          mHandler.post(r);

 322      }
 323  
 324      public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 325          final Callbacks callbacks = getCallback();
 326  
 327          if (allAppsApps == null) {
 328              throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 329          }
 330          if (allAppsApps.isEmpty()) {
 331              return;
 332          }
 333  
 334          // Process the newly added applications and add them to the database first
 335          Runnable r = new Runnable() {
 336              public void run() {
 337                  runOnMainThread(new Runnable() {
 338                      public void run() {
 339                          Callbacks cb = getCallback();
 340                          if (callbacks == cb &amp;&amp; cb != null) {
 341                              callbacks.bindAppsAdded(null, null, null, allAppsApps);
 342                          }
 343                      }
 344                  });
 345              }
 346          };
 347          runOnWorkerThread(r);
 348      }
 349  
 350      public void addAndBindAddedWorkspaceApps(final Context context,
 351              final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 352          addAndBindAddedWorkspaceApps(context, workspaceApps,
 353                  new ScreenPosProvider() {
 354  
 355                      @Override
 356                      public int getScreenIndex(ArrayList&lt;Long&gt; screenIDs) {
 357                          return screenIDs.isEmpty() ? 0 : 1;
 358                      }
 359                  }, 1, false);
 360      }
 361  
 362      private static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;Rect&gt; occupiedPos,

 363              int[] xy, int spanX, int spanY) {
 364          LauncherAppState app = LauncherAppState.getInstance();
 365          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 366          final int xCount = (int) grid.numColumns;
 367          final int yCount = (int) grid.numRows;



 368          boolean[][] occupied = new boolean[xCount][yCount];
 369          if (occupiedPos != null) {
 370              for (Rect r : occupiedPos) {
 371                  for (int x = r.left; 0 &lt;= x &amp;&amp; x &lt; r.right &amp;&amp; x &lt; xCount; x++) {
 372                      for (int y = r.top; 0 &lt;= y &amp;&amp; y &lt; r.bottom &amp;&amp; y &lt; yCount; y++) {





 373                          occupied[x][y] = true;
 374                      }
 375                  }
 376              }
 377          }
 378          return CellLayout.findVacantCell(xy, spanX, spanY, xCount, yCount, occupied);

 379      }
 380  
 381      /**
 382       * Find a position on the screen for the given size or adds a new screen.
 383       * @return screenId and the coordinates for the item.
 384       */
 385      private static Pair&lt;Long, int[]&gt; findSpaceForItem(

 386              Context context,
 387              ScreenPosProvider preferredScreen,
 388              int fallbackStartScreen,
 389              ArrayList&lt;Long&gt; workspaceScreens,
 390              ArrayList&lt;Long&gt; addedWorkspaceScreensFinal,
 391              int spanX, int spanY) {
 392          // Load position of items which are on the desktop. We can&#x27;t use sBgItemsIdMap because
 393          // loadWorkspace() may not have been called.
 394          final ContentResolver cr = context.getContentResolver();
 395          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 396                  new String[] {
 397                      LauncherSettings.Favorites.SCREEN,
 398                      LauncherSettings.Favorites.CELLX,
 399                      LauncherSettings.Favorites.CELLY,
 400                      LauncherSettings.Favorites.SPANX,
 401                      LauncherSettings.Favorites.SPANY,
 402                      LauncherSettings.Favorites.CONTAINER
 403                   },
 404                   &quot;container=?&quot;,
 405                   new String[] { Integer.toString(LauncherSettings.Favorites.CONTAINER_DESKTOP) },
 406                   null);
 407  
 408          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 409          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 410          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 411          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 412          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 413          LongSparseArray&lt;ArrayList&lt;Rect&gt;&gt; screenItems = new LongSparseArray&lt;ArrayList&lt;Rect&gt;&gt;();
 414          try {
 415              while (c.moveToNext()) {
 416                  Rect rect = new Rect();
 417                  rect.left = c.getInt(cellXIndex);
 418                  rect.top = c.getInt(cellYIndex);
 419                  rect.right = rect.left + Math.max(1, c.getInt(spanXIndex));
 420                  rect.bottom = rect.top + Math.max(1, c.getInt(spanYIndex));
 421  
 422                  long screenId = c.getInt(screenIndex);
 423                  ArrayList&lt;Rect&gt; items = screenItems.get(screenId);
 424                  if (items == null) {
 425                      items = new ArrayList&lt;Rect&gt;();
 426                      screenItems.put(screenId, items);
 427                  }
 428                  items.add(rect);
 429              }
 430          } catch (Exception e) {
 431              screenItems.clear();
 432          } finally {
 433              c.close();















 434          }
 435  
 436          // Find appropriate space for the item.
 437          long screenId = 0;
 438          int[] cordinates = new int[2];
 439          boolean found = false;
 440  
 441          int screenCount = workspaceScreens.size();
 442          // First check the preferred screen.
 443          int preferredScreenIndex = preferredScreen.getScreenIndex(workspaceScreens);

 444          if (preferredScreenIndex &lt; screenCount) {
 445              screenId = workspaceScreens.get(preferredScreenIndex);
 446              found = findNextAvailableIconSpaceInScreen(
 447                      screenItems.get(screenId), cordinates, spanX, spanY);
 448          }
 449  
 450          if (!found) {
 451              // Search on any of the screens.
 452              for (int screen = fallbackStartScreen; screen &lt; screenCount; screen++) {


 453                  screenId = workspaceScreens.get(screen);
 454                  if (findNextAvailableIconSpaceInScreen(
 455                          screenItems.get(screenId), cordinates, spanX, spanY)) {
 456                      // We found a space for it
 457                      found = true;
 458                      break;
 459                  }
 460              }
 461          }
 462  
 463          if (!found) {
 464              // Still no position found. Add a new screen to the end.
 465              screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 466  
 467              // Save the screen id for binding in the workspace
 468              workspaceScreens.add(screenId);
 469              addedWorkspaceScreensFinal.add(screenId);
 470  
 471              // If we still can&#x27;t find an empty space, then God help us all!!!
 472              if (!findNextAvailableIconSpaceInScreen(
 473                      screenItems.get(screenId), cordinates, spanX, spanY)) {
 474                  throw new RuntimeException(&quot;Can&#x27;t find space to add the item&quot;);
 475              }
 476          }
 477          return Pair.create(screenId, cordinates);
 478      }
 479  
 480      /**
 481       * Adds the provided items to the workspace.
 482       * @param preferredScreen the screen where we should try to add the app first
 483       * @param fallbackStartScreen the screen to start search for empty space if
 484       * preferredScreen is not available.
 485       */
 486      public void addAndBindPendingItem(
 487              final Context context,
 488              final PendingAddItemInfo addInfo,
 489              final ScreenPosProvider preferredScreen,
 490              final int fallbackStartScreen) {
 491          final Callbacks callbacks = getCallback();
 492          // Process the newly added applications and add them to the database first
 493          Runnable r = new Runnable() {
 494              public void run() {
 495                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 496  
 497                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 498                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 499                  for (Integer i : orderedScreens.keySet()) {
 500                      long screenId = orderedScreens.get(i);
 501                      workspaceScreens.add(screenId);
 502                  }
 503  
 504                  // Find appropriate space for the item.
 505                  Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, preferredScreen,
 506                          fallbackStartScreen, workspaceScreens, addedWorkspaceScreensFinal,
 507                          addInfo.spanX,
 508                          addInfo.spanY);
 509                  final long screenId = coords.first;
 510                  final int[] cordinates = coords.second;
 511  
 512                  // Update the workspace screens
 513                  updateWorkspaceScreenOrder(context, workspaceScreens);
 514                  runOnMainThread(new Runnable() {
 515                      public void run() {
 516                          Callbacks cb = getCallback();
 517                          if (callbacks == cb &amp;&amp; cb != null) {
 518                              cb.bindAddScreens(addedWorkspaceScreensFinal);
 519                              cb.bindAddPendingItem(addInfo,
 520                                      LauncherSettings.Favorites.CONTAINER_DESKTOP,
 521                                      screenId, cordinates, addInfo.spanX, addInfo.spanY);
 522                          }
 523                      }
 524                  });
 525              }
 526          };
 527          runOnWorkerThread(r);
 528      }
 529  
 530      /**
 531       * Adds the provided items to the workspace.
 532       * @param preferredScreen the screen where we should try to add the app first
 533       * @param fallbackStartScreen the screen to start search for empty space if
 534       * preferredScreen is not available.
 535       */
 536      public void addAndBindAddedWorkspaceApps(final Context context,
 537              final ArrayList&lt;ItemInfo&gt; workspaceApps,
 538              final ScreenPosProvider preferredScreen,
 539              final int fallbackStartScreen,
 540              final boolean allowDuplicate) {


 541          final Callbacks callbacks = getCallback();
 542          if (workspaceApps.isEmpty()) {
 543              return;
 544          }
 545          // Process the newly added applications and add them to the database first
 546          Runnable r = new Runnable() {
 547              public void run() {
 548                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 549                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 550  
 551                  // Get the list of workspace screens.  We need to append to this list and
 552                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 553                  // called.
 554                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 555                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 556                  for (Integer i : orderedScreens.keySet()) {
 557                      long screenId = orderedScreens.get(i);
 558                      workspaceScreens.add(screenId);
 559                  }
 560  

 561                  synchronized(sBgLock) {
 562                      for (ItemInfo item : workspaceApps) {
 563                          if (!allowDuplicate) {

 564                              // Short-circuit this logic if the icon exists somewhere on the workspace
 565                              if (shortcutExists(context, item.title.toString(),
 566                                      item.getIntent(), item.user)) {

 567                                  continue;
 568                              }
 569                          }
 570  
 571                          // Find appropriate space for the item.
 572                          Pair&lt;Long, int[]&gt; coords = findSpaceForItem(context, preferredScreen,
 573                                  fallbackStartScreen, workspaceScreens, addedWorkspaceScreensFinal,


 574                                  1, 1);
 575                          long screenId = coords.first;
 576                          int[] cordinates = coords.second;
 577  
 578                          ShortcutInfo shortcutInfo;
 579                          if (item instanceof ShortcutInfo) {
 580                              shortcutInfo = (ShortcutInfo) item;



 581                          } else if (item instanceof AppInfo) {
 582                              shortcutInfo = ((AppInfo) item).makeShortcut();

 583                          } else {
 584                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 585                          }
 586  
 587                          // Add the shortcut to the db
 588                          addItemToDatabase(context, shortcutInfo,

 589                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 590                                  screenId, cordinates[0], cordinates[1], false);

 591                          // Save the ShortcutInfo for binding in the workspace
 592                          addedShortcutsFinal.add(shortcutInfo);

 593                      }
 594                  }
 595  
 596                  // Update the workspace screens
 597                  updateWorkspaceScreenOrder(context, workspaceScreens);
 598  
 599                  if (!addedShortcutsFinal.isEmpty()) {
 600                      runOnMainThread(new Runnable() {
 601                          public void run() {
 602                              Callbacks cb = getCallback();
 603                              if (callbacks == cb &amp;&amp; cb != null) {
 604                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 605                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 606                                  if (!addedShortcutsFinal.isEmpty()) {
 607                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 608                                      long lastScreenId = info.screenId;
 609                                      for (ItemInfo i : addedShortcutsFinal) {
 610                                          if (i.screenId == lastScreenId) {
 611                                              addAnimated.add(i);
 612                                          } else {
 613                                              addNotAnimated.add(i);
 614                                          }
 615                                      }
 616                                  }
 617                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 618                                          addNotAnimated, addAnimated, null);
 619                              }
 620                          }
 621                      });
 622                  }
 623              }
 624          };
 625          runOnWorkerThread(r);
 626      }
 627  
 628      public void unbindItemInfosAndClearQueuedBindRunnables() {

 629          if (sWorkerThread.getThreadId() == Process.myTid()) {
 630              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 631                      &quot;main thread&quot;);
 632          }
 633  
 634          // Clear any deferred bind runnables
 635          synchronized (mDeferredBindRunnables) {
 636              mDeferredBindRunnables.clear();
 637          }
 638          // Remove any queued bind runnables
 639          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);



 640          // Unbind all the workspace items
 641          unbindWorkspaceItemsOnMainThread();
 642      }
 643  
 644      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 645      void unbindWorkspaceItemsOnMainThread() {
 646          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 647          // by making a copy of workspace items first.
 648          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 649          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();

 650          synchronized (sBgLock) {
 651              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 652              tmpAppWidgets.addAll(sBgAppWidgets);


 653          }
 654          Runnable r = new Runnable() {
 655                  @Override
 656                  public void run() {
 657                     for (ItemInfo item : tmpWorkspaceItems) {
 658                         item.unbind();
 659                     }
 660                     for (ItemInfo item : tmpAppWidgets) {

 661                         item.unbind();
 662                     }
 663                  }
 664              };
 665          runOnMainThread(r);
 666      }
 667  
 668      /**
 669       * Adds an item to the DB if it was not created previously, or move it to a new
 670       * &lt;container, screen, cellX, cellY&gt;
 671       */
 672      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 673              long screenId, int cellX, int cellY) {
 674          if (item.container == ItemInfo.NO_ID) {
 675              // From all apps
 676              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);

 677          } else {
 678              // From somewhere else
 679              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 680          }
 681      }
 682  
 683      static void checkItemInfoLocked(
 684              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 685          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 686          if (modelItem != null &amp;&amp; item != modelItem) {
 687              // check all the data is consistent
 688              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 689                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 690                  ShortcutInfo shortcut = (ShortcutInfo) item;
 691                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 692                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 693                          modelShortcut.id == shortcut.id &amp;&amp;
 694                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 695                          modelShortcut.container == shortcut.container &amp;&amp;
 696                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 697                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 698                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 699                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 700                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 701                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 702                          (modelShortcut.dropPos != null &amp;&amp;
 703                                  shortcut.dropPos != null &amp;&amp;
 704                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 705                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 706                      // For all intents and purposes, this is the same object
 707                      return;
 708                  }
 709              }
 710  
 711              // the modelItem needs to match up perfectly with item if our model is
 712              // to be consistent with the database-- for now, just require
 713              // modelItem == item or the equality check above
 714              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 715                      &quot;modelItem: &quot; +
 716                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 717                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 718              RuntimeException e = new RuntimeException(msg);
 719              if (stackTrace != null) {
 720                  e.setStackTrace(stackTrace);
 721              }
 722              throw e;
 723          }
 724      }
 725  
 726      static void checkItemInfo(final ItemInfo item) {
 727          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 728          final long itemId = item.id;
 729          Runnable r = new Runnable() {
 730              public void run() {
 731                  synchronized (sBgLock) {
 732                      checkItemInfoLocked(itemId, item, stackTrace);
 733                  }
 734              }
 735          };
 736          runOnWorkerThread(r);
 737      }
 738  
 739      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 740              final ItemInfo item, final String callingFunction) {
 741          final long itemId = item.id;
 742          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);

 743          final ContentResolver cr = context.getContentResolver();
 744  
 745          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 746          Runnable r = new Runnable() {
 747              public void run() {
 748                  cr.update(uri, values, null, null);
 749                  updateItemArrays(item, itemId, stackTrace);
 750              }
 751          };
 752          runOnWorkerThread(r);
 753      }
 754  
 755      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 756              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 757          final ContentResolver cr = context.getContentResolver();
 758  
 759          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 760          Runnable r = new Runnable() {
 761              public void run() {
 762                  ArrayList&lt;ContentProviderOperation&gt; ops =
 763                          new ArrayList&lt;ContentProviderOperation&gt;();
 764                  int count = items.size();
 765                  for (int i = 0; i &lt; count; i++) {
 766                      ItemInfo item = items.get(i);
 767                      final long itemId = item.id;
 768                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);

 769                      ContentValues values = valuesList.get(i);
 770  
 771                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 772                      updateItemArrays(item, itemId, stackTrace);
 773  
 774                  }
 775                  try {
 776                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 777                  } catch (Exception e) {
 778                      e.printStackTrace();
 779                  }
 780              }
 781          };
 782          runOnWorkerThread(r);
 783      }
 784  
 785      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 786          // Lock on mBgLock *after* the db operation
 787          synchronized (sBgLock) {
 788              checkItemInfoLocked(itemId, item, stackTrace);
 789  
 790              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 791                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 792                  // Item is in a folder, make sure this folder exists
 793                  if (!sBgFolders.containsKey(item.container)) {
 794                      // An items container is being set to a that of an item which is not in
 795                      // the list of Folders.
 796                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 797                              item.container + &quot;, not in the list of folders&quot;;
 798                      Log.e(TAG, msg);
 799                  }
 800              }
 801  
 802              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 803              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 804              // that are on the desktop, as appropriate
 805              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 806              if (modelItem != null &amp;&amp;
 807                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 808                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 809                  switch (modelItem.itemType) {
 810                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 811                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 812                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 813                          if (!sBgWorkspaceItems.contains(modelItem)) {
 814                              sBgWorkspaceItems.add(modelItem);
 815                          }
 816                          break;
 817                      default:
 818                          break;
 819                  }
 820              } else {
 821                  sBgWorkspaceItems.remove(modelItem);
 822              }
 823          }
 824      }
 825  
 826      /**
 827       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 828       */
 829      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,

 830              final long screenId, final int cellX, final int cellY) {
 831          item.container = container;
 832          item.cellX = cellX;
 833          item.cellY = cellY;
 834  
 835          // We store hotseat items in canonical form which is this orientation invariant position
 836          // in the hotseat
 837          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 838                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 839              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 840          } else {
 841              item.screenId = screenId;
 842          }
 843  
 844          final ContentValues values = new ContentValues();
 845          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 846          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 847          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 848          values.put(LauncherSettings.Favorites.RANK, item.rank);
 849          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 850  
 851          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 852      }
 853  
 854      /**
 855       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 856       * cellX, cellY have already been updated on the ItemInfos.
 857       */
 858      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 859              final long container, final int screen) {
 860  
 861          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 862          int count = items.size();
 863  
 864          for (int i = 0; i &lt; count; i++) {
 865              ItemInfo item = items.get(i);
 866              item.container = container;
 867  
 868              // We store hotseat items in canonical form which is this orientation invariant position
 869              // in the hotseat
 870              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 871                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 872                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 873                          item.cellY);
 874              } else {
 875                  item.screenId = screen;
 876              }
 877  
 878              final ContentValues values = new ContentValues();
 879              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 880              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 881              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 882              values.put(LauncherSettings.Favorites.RANK, item.rank);
 883              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 884  
 885              contentValues.add(values);
 886          }
 887          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 888      }
 889  
 890      /**
 891       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 892       */
 893      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 894              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 895          item.container = container;
 896          item.cellX = cellX;
 897          item.cellY = cellY;
 898          item.spanX = spanX;
 899          item.spanY = spanY;
 900  
 901          // We store hotseat items in canonical form which is this orientation invariant position
 902          // in the hotseat
 903          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 904                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 905              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 906          } else {
 907              item.screenId = screenId;
 908          }
 909  
 910          final ContentValues values = new ContentValues();
 911          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 912          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 913          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 914          values.put(LauncherSettings.Favorites.RANK, item.rank);
 915          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 916          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 917          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 918  
 919          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 920      }
 921  
 922      /**
 923       * Update an item to the database in a specified container.
 924       */
 925      static void updateItemInDatabase(Context context, final ItemInfo item) {

 926          final ContentValues values = new ContentValues();
 927          item.onAddToDatabase(context, values);
 928          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 929      }
 930  






 931      /**
 932       * Returns true if the shortcuts already exists in the database.
 933       * we identify a shortcut by its title and intent.


 934       */
 935      static boolean shortcutExists(Context context, String title, Intent intent,
 936              UserHandleCompat user) {
 937          final ContentResolver cr = context.getContentResolver();
 938          final Intent intentWithPkg, intentWithoutPkg;
 939  



 940          if (intent.getComponent() != null) {
 941              // If component is not null, an intent with null package will produce
 942              // the same result and should also be a match.

 943              if (intent.getPackage() != null) {
 944                  intentWithPkg = intent;
 945                  intentWithoutPkg = new Intent(intent).setPackage(null);


 946              } else {
 947                  intentWithPkg = new Intent(intent).setPackage(
 948                          intent.getComponent().getPackageName());
 949                  intentWithoutPkg = intent;


 950              }
 951          } else {
 952              intentWithPkg = intent;
 953              intentWithoutPkg = intent;
 954          }
 955          String userSerial = Long.toString(UserManagerCompat.getInstance(context)
 956                  .getSerialNumberForUser(user));
 957          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 958              new String[] { &quot;title&quot;, &quot;intent&quot;, &quot;profileId&quot; },
 959              &quot;title=? and (intent=? or intent=?) and profileId=?&quot;,
 960              new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0), userSerial },
 961              null);
 962          try {
 963              return c.moveToFirst();
 964          } finally {
 965              c.close();
 966          }




















 967      }
 968  
 969      /**
 970       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 971       */
 972      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {

 973          final ContentResolver cr = context.getContentResolver();
 974          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 975                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
 976                  new String[] { String.valueOf(id),
 977                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 978  
 979          try {
 980              if (c.moveToFirst()) {
 981                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 982                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 983                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 984                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 985                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 986                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);

 987  
 988                  FolderInfo folderInfo = null;
 989                  switch (c.getInt(itemTypeIndex)) {
 990                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 991                          folderInfo = findOrMakeFolder(folderList, id);
 992                          break;
 993                  }
 994  

 995                  folderInfo.title = c.getString(titleIndex);
 996                  folderInfo.id = id;
 997                  folderInfo.container = c.getInt(containerIndex);
 998                  folderInfo.screenId = c.getInt(screenIndex);
 999                  folderInfo.cellX = c.getInt(cellXIndex);
1000                  folderInfo.cellY = c.getInt(cellYIndex);

1001  
1002                  return folderInfo;
1003              }
1004          } finally {
1005              c.close();
1006          }
1007  
1008          return null;
1009      }
1010  
1011      /**
1012       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1013       * cellY fields of the item. Also assigns an ID to the item.
1014       */
1015      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1016              final long screenId, final int cellX, final int cellY, final boolean notify) {


1017          item.container = container;
1018          item.cellX = cellX;
1019          item.cellY = cellY;
1020          // We store hotseat items in canonical form which is this orientation invariant position
1021          // in the hotseat
1022          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1023                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1024              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1025          } else {
1026              item.screenId = screenId;
1027          }
1028  
1029          final ContentValues values = new ContentValues();
1030          final ContentResolver cr = context.getContentResolver();
1031          item.onAddToDatabase(context, values);
1032  
1033          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1034          values.put(LauncherSettings.Favorites._ID, item.id);
1035  
1036          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1037          Runnable r = new Runnable() {
1038              public void run() {
1039                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1040                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);

1041  
1042                  // Lock on mBgLock *after* the db operation
1043                  synchronized (sBgLock) {
1044                      checkItemInfoLocked(item.id, item, stackTrace);
1045                      sBgItemsIdMap.put(item.id, item);
1046                      switch (item.itemType) {
1047                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1048                              sBgFolders.put(item.id, (FolderInfo) item);
1049                              // Fall through
1050                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1051                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1052                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1053                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1054                                  sBgWorkspaceItems.add(item);
1055                              } else {
1056                                  if (!sBgFolders.containsKey(item.container)) {
1057                                      // Adding an item to a folder that doesn&#x27;t exist.
1058                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1059                                              &quot; doesn&#x27;t exist&quot;;
1060                                      Log.e(TAG, msg);
1061                                  }
1062                              }
1063                              break;
1064                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1065                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1066                              break;
1067                      }
1068                  }
1069              }
1070          };
1071          runOnWorkerThread(r);
1072      }
1073  
1074      /**
1075       * Creates a new unique child id, for a given cell span across all layouts.
1076       */
1077      static int getCellLayoutChildId(
1078              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1079          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1080                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1081      }
1082  
1083      private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1084              final String pn, final UserHandleCompat user) {
1085          ItemInfoFilter filter  = new ItemInfoFilter() {
1086              @Override
1087              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1088                  return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1089              }
1090          };
1091          return filterItemInfos(sBgItemsIdMap.values(), filter);

1092      }
1093  
1094      /**
1095       * Removes all the items from the database corresponding to the specified package.
1096       */
1097      static void deletePackageFromDatabase(Context context, final String pn,
1098              final UserHandleCompat user) {
1099          deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1100      }
1101  
1102      /**
1103       * Removes the specified item from the database
1104       * @param context
1105       * @param item
1106       */
1107      static void deleteItemFromDatabase(Context context, final ItemInfo item) {

1108          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1109          items.add(item);
1110          deleteItemsFromDatabase(context, items);
1111      }
1112  
1113      /**
1114       * Removes the specified items from the database
1115       * @param context
1116       * @param item
1117       */
1118      static void deleteItemsFromDatabase(Context context, final ArrayList&lt;? extends ItemInfo&gt; items) {
1119          final ContentResolver cr = context.getContentResolver();
1120  
1121          Runnable r = new Runnable() {
1122              public void run() {
1123                  for (ItemInfo item : items) {
1124                      final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);

1125                      cr.delete(uri, null, null);
1126  
1127                      // Lock on mBgLock *after* the db operation
1128                      synchronized (sBgLock) {
1129                          switch (item.itemType) {
1130                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1131                                  sBgFolders.remove(item.id);
1132                                  for (ItemInfo info: sBgItemsIdMap.values()) {

1133                                      if (info.container == item.id) {
1134                                          // We are deleting a folder which still contains items that
1135                                          // think they are contained by that folder.
1136                                          String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1137                                                  &quot;contains items (&quot; + info + &quot;)&quot;;
1138                                          Log.e(TAG, msg);
1139                                      }
1140                                  }
1141                                  sBgWorkspaceItems.remove(item);
1142                                  break;
1143                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1144                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1145                                  sBgWorkspaceItems.remove(item);
1146                                  break;
1147                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1148                                  sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1149                                  break;
1150                          }
1151                          sBgItemsIdMap.remove(item.id);
1152                          sBgDbIconCache.remove(item);
1153                      }
1154                  }
1155              }
1156          };
1157          runOnWorkerThread(r);
1158      }
1159  
1160      /**
1161       * Update the order of the workspace screens in the database. The array list contains
1162       * a list of screen ids in the order that they should appear.
1163       */
1164      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1165          // Log to disk
1166          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1167          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1168  
1169          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1170          final ContentResolver cr = context.getContentResolver();
1171          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1172  
1173          // Remove any negative screen ids -- these aren&#x27;t persisted
1174          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1175          while (iter.hasNext()) {
1176              long id = iter.next();
1177              if (id &lt; 0) {
1178                  iter.remove();
1179              }
1180          }
1181  
1182          Runnable r = new Runnable() {
1183              @Override
1184              public void run() {
1185                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1186                  // Clear the table
1187                  ops.add(ContentProviderOperation.newDelete(uri).build());
1188                  int count = screensCopy.size();
1189                  for (int i = 0; i &lt; count; i++) {
1190                      ContentValues v = new ContentValues();
1191                      long screenId = screensCopy.get(i);
1192                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1193                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1194                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1195                  }
1196  
1197                  try {
1198                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1199                  } catch (Exception ex) {
1200                      throw new RuntimeException(ex);
1201                  }
1202  
1203                  synchronized (sBgLock) {
1204                      sBgWorkspaceScreens.clear();
1205                      sBgWorkspaceScreens.addAll(screensCopy);
1206                  }
1207              }
1208          };
1209          runOnWorkerThread(r);
1210      }
1211  
1212      /**
1213       * Remove the contents of the specified folder from the database
1214       */
1215      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {

1216          final ContentResolver cr = context.getContentResolver();
1217  
1218          Runnable r = new Runnable() {
1219              public void run() {
1220                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);

1221                  // Lock on mBgLock *after* the db operation
1222                  synchronized (sBgLock) {
1223                      sBgItemsIdMap.remove(info.id);
1224                      sBgFolders.remove(info.id);
1225                      sBgDbIconCache.remove(info);
1226                      sBgWorkspaceItems.remove(info);
1227                  }
1228  
1229                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,

1230                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1231                  // Lock on mBgLock *after* the db operation
1232                  synchronized (sBgLock) {
1233                      for (ItemInfo childInfo : info.contents) {
1234                          sBgItemsIdMap.remove(childInfo.id);
1235                          sBgDbIconCache.remove(childInfo);
1236                      }
1237                  }
1238              }
1239          };
1240          runOnWorkerThread(r);
1241      }
1242  
1243      /**
1244       * Set this as the current Launcher activity object for the loader.
1245       */
1246      public void initialize(Callbacks callbacks) {
1247          synchronized (mLock) {



1248              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1249          }
1250      }
1251  
1252      @Override
1253      public void onPackageChanged(String packageName, UserHandleCompat user) {
1254          int op = PackageUpdatedTask.OP_UPDATE;
1255          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1256                  user));
1257      }
1258  
1259      @Override
1260      public void onPackageRemoved(String packageName, UserHandleCompat user) {
1261          int op = PackageUpdatedTask.OP_REMOVE;
1262          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1263                  user));
1264      }
1265  
1266      @Override
1267      public void onPackageAdded(String packageName, UserHandleCompat user) {
1268          int op = PackageUpdatedTask.OP_ADD;
1269          enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1270                  user));
1271      }
1272  
1273      @Override
1274      public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1275              boolean replacing) {
1276          if (!replacing) {
1277              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1278                      user));
1279              if (mAppsCanBeOnRemoveableStorage) {
1280                  // Only rebind if we support removable storage. It catches the
1281                  // case where
1282                  // apps on the external sd card need to be reloaded
1283                  startLoaderFromBackground();
1284              }
1285          } else {
1286              // If we are replacing then just update the packages in the list
1287              enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1288                      packageNames, user));
1289          }
1290      }
1291  
1292      @Override
1293      public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1294              boolean replacing) {
1295          if (!replacing) {
1296              enqueuePackageUpdated(new PackageUpdatedTask(
1297                      PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1298                      user));
1299          }
1300      }
1301  
1302      /**
1303       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1304       * ACTION_PACKAGE_CHANGED.
1305       */
1306      @Override
1307      public void onReceive(Context context, Intent intent) {
1308          if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1309  
1310          final String action = intent.getAction();
1311          if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1312              // If we have changed locale we need to clear out the labels in all apps/workspace.
1313              forceReload();
1314          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1315               // Check if configuration change was an mcc/mnc change which would affect app resources
1316               // and we would need to clear out the labels in all apps/workspace. Same handling as
1317               // above for ACTION_LOCALE_CHANGED
1318               Configuration currentConfig = context.getResources().getConfiguration();
1319               if (mPreviousConfigMcc != currentConfig.mcc) {
1320                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1321                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1322                     forceReload();
1323               }
1324               // Update previousConfig
1325               mPreviousConfigMcc = currentConfig.mcc;
1326          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1327                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1328              Callbacks callbacks = getCallback();
1329              if (callbacks != null) {
1330                  callbacks.bindSearchablesChanged();
1331              }



1332          }
1333      }
1334  
1335      void forceReload() {
1336          resetLoadedState(true, true);
1337  
1338          // Do this here because if the launcher activity is running it will be restarted.
1339          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1340          // to reload.
1341          startLoaderFromBackground();
1342      }
1343  
1344      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1345          synchronized (mLock) {
1346              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1347              // mWorkspaceLoaded to true later
1348              stopLoaderLocked();
1349              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1350              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1351          }
1352      }
1353  
1354      /**
1355       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1356       * configuration changes.  So whenever we trigger the loader from the background
1357       * tell the launcher that it needs to re-run the loader when it comes back instead
1358       * of doing it now.
1359       */
1360      public void startLoaderFromBackground() {
1361          boolean runLoader = false;
1362          Callbacks callbacks = getCallback();
1363          if (callbacks != null) {
1364              // Only actually run the loader if they&#x27;re not paused.
1365              if (!callbacks.setLoadOnResume()) {
1366                  runLoader = true;
1367              }
1368          }
1369          if (runLoader) {
1370              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1371          }
1372      }
1373  
1374      // If there is already a loader task running, tell it to stop.
1375      // returns true if isLaunching() was true on the old task
1376      private boolean stopLoaderLocked() {
1377          boolean isLaunching = false;








1378          LoaderTask oldTask = mLoaderTask;
1379          if (oldTask != null) {
1380              if (oldTask.isLaunching()) {
1381                  isLaunching = true;
1382              }
1383              oldTask.stopLocked();
1384          }
1385          return isLaunching;
1386      }
1387  
1388      public boolean isCurrentCallbacks(Callbacks callbacks) {
1389          return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1390      }
1391  
1392      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1393          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1394      }
1395  
1396      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {







1397          synchronized (mLock) {
1398              if (DEBUG_LOADERS) {
1399                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1400              }
1401  
1402              // Clear any deferred bind-runnables from the synchronized load process
1403              // We must do this before any loading/binding is scheduled below.
1404              synchronized (mDeferredBindRunnables) {
1405                  mDeferredBindRunnables.clear();
1406              }
1407  
1408              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1409              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1410                  // If there is already one running, tell it to stop.
1411                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1412                  isLaunching = isLaunching || stopLoaderLocked();
1413                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);


1414                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1415                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {

1416                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1417                  } else {
1418                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1419                      sWorker.post(mLoaderTask);
1420                  }
1421              }
1422          }
1423      }
1424  
1425      void bindRemainingSynchronousPages() {
1426          // Post the remaining side pages to be loaded
1427          if (!mDeferredBindRunnables.isEmpty()) {
1428              Runnable[] deferredBindRunnables = null;
1429              synchronized (mDeferredBindRunnables) {
1430                  deferredBindRunnables = mDeferredBindRunnables.toArray(
1431                          new Runnable[mDeferredBindRunnables.size()]);
1432                  mDeferredBindRunnables.clear();
1433              }
1434              for (final Runnable r : deferredBindRunnables) {
1435                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);











1436              }
1437          }
1438      }
1439  
1440      public void stopLoader() {
1441          synchronized (mLock) {
1442              if (mLoaderTask != null) {
1443                  mLoaderTask.stopLocked();
1444              }
1445          }
1446      }
1447  
1448      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1449      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {




1450          final ContentResolver contentResolver = context.getContentResolver();
1451          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1452          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1453          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1454  





1455          try {
1456              final int idIndex = sc.getColumnIndexOrThrow(
1457                      LauncherSettings.WorkspaceScreens._ID);
1458              final int rankIndex = sc.getColumnIndexOrThrow(
1459                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);

1460              while (sc.moveToNext()) {
1461                  try {
1462                      long screenId = sc.getLong(idIndex);
1463                      int rank = sc.getInt(rankIndex);
1464                      orderedScreens.put(rank, screenId);

1465                  } catch (Exception e) {
1466                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);


1467                  }
1468              }
1469          } finally {
1470              sc.close();
1471          }
1472  
1473          // Log to disk
1474          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1475          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1476          for (Integer i : orderedScreens.keySet()) {
1477              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1478          }
1479          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1480                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1481          return orderedScreens;

1482      }
1483  
1484      public boolean isAllAppsLoaded() {
1485          return mAllAppsLoaded;
1486      }
1487  
1488      boolean isLoadingWorkspace() {
1489          synchronized (mLock) {
1490              if (mLoaderTask != null) {
1491                  return mLoaderTask.isLoadingWorkspace();
1492              }
1493          }
1494          return false;
1495      }
1496  
1497      /**
1498       * Runnable for the thread that loads the contents of the launcher:
1499       *   - workspace icons
1500       *   - widgets
1501       *   - all apps icons
1502       */
1503      private class LoaderTask implements Runnable {
1504          private Context mContext;
1505          private boolean mIsLaunching;
1506          private boolean mIsLoadingAndBindingWorkspace;

1507          private boolean mStopped;
1508          private boolean mLoadAndBindStepFinished;

1509          private int mFlags;
1510  
1511          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1512  
1513          LoaderTask(Context context, boolean isLaunching, int flags) {

1514              mContext = context;
1515              mIsLaunching = isLaunching;
1516              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1517              mFlags = flags;
1518          }
1519  
1520          boolean isLaunching() {
1521              return mIsLaunching;
1522          }
1523  
1524          boolean isLoadingWorkspace() {
1525              return mIsLoadingAndBindingWorkspace;
1526          }
1527  
1528          /** Returns whether this is an upgrade path */
1529          private boolean loadAndBindWorkspace() {

1530              mIsLoadingAndBindingWorkspace = true;
1531  
1532              // Load the workspace
1533              if (DEBUG_LOADERS) {
1534                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1535              }
1536  
1537              boolean isUpgradePath = false;
1538              if (!mWorkspaceLoaded) {
1539                  isUpgradePath = loadWorkspace();

1540                  synchronized (LoaderTask.this) {
1541                      if (mStopped) {
1542                          return isUpgradePath;

1543                      }
1544                      mWorkspaceLoaded = true;
1545                  }
1546              }
1547  
1548              // Bind the workspace
1549              bindWorkspace(-1, isUpgradePath);
1550              return isUpgradePath;

1551          }
1552  
1553          private void waitForIdle() {
1554              // Wait until the either we&#x27;re stopped or the other threads are done.
1555              // This way we don&#x27;t start loading all apps until the workspace has settled
1556              // down.
1557              synchronized (LoaderTask.this) {
1558                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1559  
1560                  mHandler.postIdle(new Runnable() {
1561                          public void run() {
1562                              synchronized (LoaderTask.this) {
1563                                  mLoadAndBindStepFinished = true;
1564                                  if (DEBUG_LOADERS) {
1565                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1566                                  }
1567                                  LoaderTask.this.notify();
1568                              }
1569                          }
1570                      });
1571  
1572                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished) {
1573                      try {
1574                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1575                          // wait no longer than 1sec at a time
1576                          this.wait(1000);
1577                      } catch (InterruptedException ex) {
1578                          // Ignore
1579                      }
1580                  }
1581                  if (DEBUG_LOADERS) {
1582                      Log.d(TAG, &quot;waited &quot;
1583                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1584                              + &quot;ms for previous step to finish binding&quot;);
1585                  }
1586              }
1587          }
1588  
1589          void runBindSynchronousPage(int synchronousBindPage) {
1590              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1591                  // Ensure that we have a valid page index to load synchronously
1592                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1593                          &quot;valid page index&quot;);
1594              }
1595              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1596                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1597                  // loaded already (we should load everything asynchronously in that case)
1598                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1599              }
1600              synchronized (mLock) {
1601                  if (mIsLoaderTaskRunning) {
1602                      // Ensure that we are never running the background loading at this point since
1603                      // we also touch the background collections
1604                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1605                  }
1606              }
1607  
1608              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1609              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1610              //      this call is synchronous, we can get away with not locking).
1611  
1612              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1613              // operations from the previous activity.  We need to ensure that all queued operations
1614              // are executed before any synchronous binding work is done.
1615              mHandler.flush();
1616  
1617              // Divide the set of loaded items into those that we are binding synchronously, and
1618              // everything else that is to be bound normally (asynchronously).
1619              bindWorkspace(synchronousBindPage, false);

1620              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1621              //      arise from that.
1622              onlyBindAllApps();
1623          }
1624  
1625          public void run() {
1626              boolean isUpgrade = false;
1627  
1628              synchronized (mLock) {



1629                  mIsLoaderTaskRunning = true;
1630              }
1631              // Optimize for end-user experience: if the Launcher is up and // running with the
1632              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1633              // workspace first (default).
1634              keep_running: {
1635                  // Elevate priority when Home launches for the first time to avoid
1636                  // starving at boot time. Staring at a blank home is not cool.
1637                  synchronized (mLock) {
1638                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1639                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1640                      android.os.Process.setThreadPriority(mIsLaunching
1641                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1642                  }
1643                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1644                  isUpgrade = loadAndBindWorkspace();

1645  
1646                  if (mStopped) {
1647                      break keep_running;
1648                  }
1649  
1650                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1651                  // settled down.
1652                  synchronized (mLock) {
1653                      if (mIsLaunching) {
1654                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1655                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1656                      }
1657                  }
1658                  waitForIdle();
1659  
1660                  // second step
1661                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1662                  loadAndBindAllApps();
1663  
1664                  // Restore the default thread priority after we are done loading items
1665                  synchronized (mLock) {
1666                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1667                  }
1668              }
1669  
1670              // Update the saved icons if necessary
1671              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1672              synchronized (sBgLock) {
1673                  for (Object key : sBgDbIconCache.keySet()) {
1674                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1675                  }
1676                  sBgDbIconCache.clear();
1677              }
1678  
1679              if (LauncherAppState.isDisableAllApps()) {
1680                  // Ensure that all the applications that are in the system are
1681                  // represented on the home screen.
1682                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1683                      verifyApplications();
1684                  }
1685              }
1686  
1687              // Clear out this reference, otherwise we end up holding it until all of the
1688              // callback runnables are done.
1689              mContext = null;
1690  
1691              synchronized (mLock) {
1692                  // If we are still the last one to be scheduled, remove ourselves.
1693                  if (mLoaderTask == this) {
1694                      mLoaderTask = null;
1695                  }
1696                  mIsLoaderTaskRunning = false;

1697              }
1698          }
1699  
1700          public void stopLocked() {
1701              synchronized (LoaderTask.this) {
1702                  mStopped = true;
1703                  this.notify();
1704              }
1705          }
1706  
1707          /**
1708           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1709           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1710           * object that was around when the deferred message was scheduled, and if there&#x27;s
1711           * a new Callbacks object around then also return null.  This will save us from
1712           * calling onto it with data that will be ignored.
1713           */
1714          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1715              synchronized (mLock) {
1716                  if (mStopped) {
1717                      return null;
1718                  }
1719  
1720                  if (mCallbacks == null) {
1721                      return null;
1722                  }
1723  
1724                  final Callbacks callbacks = mCallbacks.get();
1725                  if (callbacks != oldCallbacks) {
1726                      return null;
1727                  }
1728                  if (callbacks == null) {
1729                      Log.w(TAG, &quot;no mCallbacks&quot;);
1730                      return null;
1731                  }
1732  
1733                  return callbacks;
1734              }
1735          }
1736  
1737          private void verifyApplications() {
1738              final Context context = mApp.getContext();
1739  
1740              // Cross reference all the applications in our apps list with items in the workspace
1741              ArrayList&lt;ItemInfo&gt; tmpInfos;
1742              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1743              synchronized (sBgLock) {
1744                  for (AppInfo app : mBgAllAppsList.data) {
1745                      tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1746                      if (tmpInfos.isEmpty()) {
1747                          // We are missing an application icon, so add this to the workspace
1748                          added.add(app);
1749                          // This is a rare event, so lets log it
1750                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1751                      }
1752                  }
1753              }
1754              if (!added.isEmpty()) {
1755                  addAndBindAddedWorkspaceApps(context, added);
1756              }
1757          }
1758  
1759          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1760          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item) {

1761              LauncherAppState app = LauncherAppState.getInstance();
1762              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1763              final int countX = (int) grid.numColumns;
1764              final int countY = (int) grid.numRows;



1765  
1766              long containerIndex = item.screenId;
1767              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1768                  // Return early if we detect that an item is under the hotseat button
1769                  if (mCallbacks == null ||
1770                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1771                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1772                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1773                              + item.cellY + &quot;) occupied by all apps&quot;);
1774                      return false;
1775                  }
1776  
1777                  final ItemInfo[][] hotseatItems =
1778                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1779  
1780                  if (item.screenId &gt;= grid.numHotseatIcons) {

1781                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1782                              + &quot; into hotseat position &quot; + item.screenId
1783                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)

1784                              + &quot;)&quot;);
1785                      return false;
1786                  }
1787  
1788                  if (hotseatItems != null) {
1789                      if (hotseatItems[(int) item.screenId][0] != null) {
1790                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1791                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1792                                  + item.cellY + &quot;) occupied by &quot;
1793                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1794                                  [(int) item.screenId][0]);
1795                              return false;
1796                      } else {
1797                          hotseatItems[(int) item.screenId][0] = item;
1798                          return true;
1799                      }
1800                  } else {
1801                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];

1802                      items[(int) item.screenId][0] = item;
1803                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1804                      return true;
1805                  }
1806              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1807                  // Skip further checking if it is not the hotseat or workspace container
1808                  return true;
1809              }
1810  
1811              if (!occupied.containsKey(item.screenId)) {
1812                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1813                  occupied.put(item.screenId, items);
1814              }
1815  
1816              final ItemInfo[][] screens = occupied.get(item.screenId);
1817              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1818                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1819                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1820                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1821                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1822                          + item.cellX + &quot;,&quot; + item.cellY
1823                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1824                  return false;
1825              }
1826  
1827              // Check if any workspace icons overlap with each other
1828              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1829                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1830                      if (screens[x][y] != null) {
1831                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1832                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1833                              + x + &quot;,&quot; + y
1834                              + &quot;) occupied by &quot;
1835                              + screens[x][y]);
1836                          return false;
1837                      }
1838                  }
1839              }
1840              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1841                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1842                      screens[x][y] = item;
1843                  }
1844              }
1845  
1846              return true;
1847          }
1848  
1849          /** Clears all the sBg data structures */
1850          private void clearSBgDataStructures() {
1851              synchronized (sBgLock) {
1852                  sBgWorkspaceItems.clear();
1853                  sBgAppWidgets.clear();
1854                  sBgFolders.clear();
1855                  sBgItemsIdMap.clear();
1856                  sBgDbIconCache.clear();
1857                  sBgWorkspaceScreens.clear();
1858              }
1859          }
1860  
1861          /** Returns whether this is an upgrade path */
1862          private boolean loadWorkspace() {
1863              // Log to disk
1864              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1865  

1866              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1867  
1868              final Context context = mContext;
1869              final ContentResolver contentResolver = context.getContentResolver();
1870              final PackageManager manager = context.getPackageManager();
1871              final boolean isSafeMode = manager.isSafeMode();
1872              final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1873              final boolean isSdCardReady = context.registerReceiver(null,
1874                      new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1875  
1876              LauncherAppState app = LauncherAppState.getInstance();
1877              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1878              int countX = (int) grid.numColumns;
1879              int countY = (int) grid.numRows;



1880  
1881              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1882                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1883                  LauncherAppState.getLauncherProvider().deleteDatabase();
1884              }
1885  
1886              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1887                  // append the user&#x27;s Launcher2 shortcuts
1888                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1889                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1890              } else {
1891                  // Make sure the default workspace is loaded
1892                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1893                  LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1894              }
1895  
1896              // This code path is for our old migration code and should no longer be exercised
1897              boolean loadedOldDb = false;
1898  
1899              // Log to disk
1900              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1901  
1902              synchronized (sBgLock) {
1903                  clearSBgDataStructures();
1904                  final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat

1905                          .getInstance(mContext).updateAndGetActiveSessionCache();
1906  
1907                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1908                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1909                  final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;

1910                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1911                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1912  
1913                  // +1 for the hotseat (it can be larger than the workspace)
1914                  // Load workspace in reverse order to ensure that latest items are loaded first (and
1915                  // before any earlier duplicates)
1916                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();

1917  
1918                  try {
1919                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1920                      final int intentIndex = c.getColumnIndexOrThrow
1921                              (LauncherSettings.Favorites.INTENT);
1922                      final int titleIndex = c.getColumnIndexOrThrow
1923                              (LauncherSettings.Favorites.TITLE);
1924                      final int iconTypeIndex = c.getColumnIndexOrThrow(
1925                              LauncherSettings.Favorites.ICON_TYPE);
1926                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1927                      final int iconPackageIndex = c.getColumnIndexOrThrow(
1928                              LauncherSettings.Favorites.ICON_PACKAGE);
1929                      final int iconResourceIndex = c.getColumnIndexOrThrow(
1930                              LauncherSettings.Favorites.ICON_RESOURCE);
1931                      final int containerIndex = c.getColumnIndexOrThrow(
1932                              LauncherSettings.Favorites.CONTAINER);
1933                      final int itemTypeIndex = c.getColumnIndexOrThrow(
1934                              LauncherSettings.Favorites.ITEM_TYPE);
1935                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1936                              LauncherSettings.Favorites.APPWIDGET_ID);
1937                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1938                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1939                      final int screenIndex = c.getColumnIndexOrThrow(
1940                              LauncherSettings.Favorites.SCREEN);
1941                      final int cellXIndex = c.getColumnIndexOrThrow
1942                              (LauncherSettings.Favorites.CELLX);
1943                      final int cellYIndex = c.getColumnIndexOrThrow
1944                              (LauncherSettings.Favorites.CELLY);
1945                      final int spanXIndex = c.getColumnIndexOrThrow
1946                              (LauncherSettings.Favorites.SPANX);
1947                      final int spanYIndex = c.getColumnIndexOrThrow(
1948                              LauncherSettings.Favorites.SPANY);
1949                      final int rankIndex = c.getColumnIndexOrThrow(
1950                              LauncherSettings.Favorites.RANK);
1951                      final int restoredIndex = c.getColumnIndexOrThrow(
1952                              LauncherSettings.Favorites.RESTORED);
1953                      final int profileIdIndex = c.getColumnIndexOrThrow(
1954                              LauncherSettings.Favorites.PROFILE_ID);
1955                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1956                      //final int displayModeIndex = c.getColumnIndexOrThrow(
1957                      //        LauncherSettings.Favorites.DISPLAY_MODE);








1958  
1959                      ShortcutInfo info;
1960                      String intentDescription;
1961                      LauncherAppWidgetInfo appWidgetInfo;
1962                      int container;
1963                      long id;
1964                      long serialNumber;
1965                      Intent intent;
1966                      UserHandleCompat user;
1967  
1968                      while (!mStopped &amp;&amp; c.moveToNext()) {
1969                          try {
1970                              int itemType = c.getInt(itemTypeIndex);
1971                              boolean restored = 0 != c.getInt(restoredIndex);
1972                              boolean allowMissingTarget = false;

1973  
1974                              switch (itemType) {
1975                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1976                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1977                                  id = c.getLong(idIndex);
1978                                  intentDescription = c.getString(intentIndex);
1979                                  serialNumber = c.getInt(profileIdIndex);
1980                                  user = mUserManager.getUserForSerialNumber(serialNumber);

1981                                  int promiseType = c.getInt(restoredIndex);
1982                                  int disabledState = 0;

1983                                  if (user == null) {
1984                                      // User has been deleted remove the item.
1985                                      itemsToRemove.add(id);
1986                                      continue;
1987                                  }
1988                                  try {
1989                                      intent = Intent.parseUri(intentDescription, 0);
1990                                      ComponentName cn = intent.getComponent();
1991                                      if (cn != null &amp;&amp; cn.getPackageName() != null) {
1992                                          boolean validPkg = launcherApps.isPackageEnabledForProfile(
1993                                                  cn.getPackageName(), user);
1994                                          boolean validComponent = validPkg &amp;&amp;
1995                                                  launcherApps.isActivityEnabledForProfile(cn, user);
1996  
1997                                          if (validComponent) {
1998                                              if (restored) {
1999                                                  // no special handling necessary for this item
2000                                                  restoredRows.add(id);
2001                                                  restored = false;
2002                                              }
2003                                          } else if (validPkg) {
2004                                              intent = null;
2005                                              if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2006                                                  // We allow auto install apps to have their intent
2007                                                  // updated after an install.
2008                                                  intent = manager.getLaunchIntentForPackage(
2009                                                          cn.getPackageName());
2010                                                  if (intent != null) {
2011                                                      ContentValues values = new ContentValues();
2012                                                      values.put(LauncherSettings.Favorites.INTENT,
2013                                                              intent.toUri(0));
2014                                                      String where = BaseColumns._ID + &quot;= ?&quot;;
2015                                                      String[] args = {Long.toString(id)};
2016                                                      contentResolver.update(contentUri, values, where, args);

2017                                                  }
2018                                              }
2019  
2020                                              if (intent == null) {
2021                                                  // The app is installed but the component is no
2022                                                  // longer available.
2023                                                  Launcher.addDumpLog(TAG,
2024                                                          &quot;Invalid component removed: &quot; + cn, true);
2025                                                  itemsToRemove.add(id);
2026                                                  continue;
2027                                              } else {
2028                                                  // no special handling necessary for this item
2029                                                  restoredRows.add(id);
2030                                                  restored = false;
2031                                              }
2032                                          } else if (restored) {
2033                                              // Package is not yet available but might be
2034                                              // installed later.
2035                                              Launcher.addDumpLog(TAG,
2036                                                      &quot;package not yet restored: &quot; + cn, true);
2037  
2038                                              if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2039                                                  // Restore has started once.
2040                                              } else if (installingPkgs.contains(cn.getPackageName())) {

2041                                                  // App restore has started. Update the flag
2042                                                  promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2043                                                  ContentValues values = new ContentValues();
2044                                                  values.put(LauncherSettings.Favorites.RESTORED,
2045                                                          promiseType);
2046                                                  String where = BaseColumns._ID + &quot;= ?&quot;;
2047                                                  String[] args = {Long.toString(id)};
2048                                                  contentResolver.update(contentUri, values, where, args);
2049  





















2050                                              } else if (REMOVE_UNRESTORED_ICONS) {
2051                                                  Launcher.addDumpLog(TAG,
2052                                                          &quot;Unrestored package removed: &quot; + cn, true);
2053                                                  itemsToRemove.add(id);
2054                                                  continue;
2055                                              }
2056                                          } else if (launcherApps.isAppEnabled(
2057                                                  manager, cn.getPackageName(),
2058                                                  PackageManager.GET_UNINSTALLED_PACKAGES)) {
2059                                              // Package is present but not available.
2060                                              allowMissingTarget = true;
2061                                              disabledState = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
2062                                          } else if (!isSdCardReady) {
2063                                              // SdCard is not ready yet. Package might get available,
2064                                              // once it is ready.
2065                                              Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2066                                                      + &quot; (check again later)&quot;, true);
2067                                              HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2068                                              if (pkgs == null) {
2069                                                  pkgs = new HashSet&lt;String&gt;();
2070                                                  sPendingPackages.put(user, pkgs);
2071                                              }
2072                                              pkgs.add(cn.getPackageName());
2073                                              allowMissingTarget = true;
2074                                              // Add the icon on the workspace anyway.
2075  
2076                                          } else {
2077                                              // Do not wait for external media load anymore.
2078                                              // Log the invalid package, and remove it
2079                                              Launcher.addDumpLog(TAG,
2080                                                      &quot;Invalid package removed: &quot; + cn, true);
2081                                              itemsToRemove.add(id);
2082                                              continue;
2083                                          }
2084                                      } else if (cn == null) {
2085                                          // For shortcuts with no component, keep them as they are
2086                                          restoredRows.add(id);
2087                                          restored = false;
2088                                      }
2089                                  } catch (URISyntaxException e) {
2090                                      Launcher.addDumpLog(TAG,
2091                                              &quot;Invalid uri: &quot; + intentDescription, true);
2092                                      continue;
2093                                  }
2094  
2095                                  if (restored) {














2096                                      if (user.equals(UserHandleCompat.myUserHandle())) {
2097                                          Launcher.addDumpLog(TAG,
2098                                                  &quot;constructing info for partially restored package&quot;,
2099                                                  true);
2100                                          info = getRestoredItemInfo(c, titleIndex, intent, promiseType);


2101                                          intent = getRestoredItemIntent(c, context, intent);
2102                                      } else {
2103                                          // Don&#x27;t restore items for other profiles.
2104                                          itemsToRemove.add(id);
2105                                          continue;
2106                                      }
2107                                  } else if (itemType ==
2108                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2109                                      info = getShortcutInfo(manager, intent, user, context, c,
2110                                              iconIndex, titleIndex, mLabelCache, allowMissingTarget);



2111                                  } else {
2112                                      info = getShortcutInfo(c, context, iconTypeIndex,
2113                                              iconPackageIndex, iconResourceIndex, iconIndex,
2114                                              titleIndex);

2115  
2116                                      // App shortcuts that used to be automatically added to Launcher
2117                                      // didn&#x27;t always have the correct intent flags set, so do that
2118                                      // here
2119                                      if (intent.getAction() != null &amp;&amp;
2120                                          intent.getCategories() != null &amp;&amp;
2121                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2122                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2123                                          intent.addFlags(
2124                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2125                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2126                                      }
2127                                  }
2128  
2129                                  if (info != null) {
2130                                      info.id = id;
2131                                      info.intent = intent;
2132                                      container = c.getInt(containerIndex);
2133                                      info.container = container;
2134                                      info.screenId = c.getInt(screenIndex);
2135                                      info.cellX = c.getInt(cellXIndex);
2136                                      info.cellY = c.getInt(cellYIndex);
2137                                      info.rank = c.getInt(rankIndex);
2138                                      info.spanX = 1;
2139                                      info.spanY = 1;
2140                                      info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);



2141                                      info.isDisabled = disabledState;
2142                                      if (isSafeMode &amp;&amp; !Utilities.isSystemApp(context, intent)) {
2143                                          info.isDisabled |= ShortcutInfo.FLAG_DISABLED_SAFEMODE;
2144                                      }
2145  
2146                                      // check &amp; update map of what&#x27;s occupied
2147                                      if (!checkItemPlacement(occupied, info)) {
2148                                          itemsToRemove.add(id);
2149                                          break;












2150                                      }
2151  
2152                                      switch (container) {
2153                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2154                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2155                                          sBgWorkspaceItems.add(info);
2156                                          break;
2157                                      default:
2158                                          // Item is in a user folder
2159                                          FolderInfo folderInfo =
2160                                                  findOrMakeFolder(sBgFolders, container);
2161                                          folderInfo.add(info);
2162                                          break;
2163                                      }
2164                                      sBgItemsIdMap.put(info.id, info);
2165  
2166                                      // now that we&#x27;ve loaded everthing re-save it with the
2167                                      // icon in case it disappears somehow.
2168                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2169                                  } else {
2170                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2171                                  }
2172                                  break;
2173  
2174                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2175                                  id = c.getLong(idIndex);
2176                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2177  

2178                                  folderInfo.title = c.getString(titleIndex);
2179                                  folderInfo.id = id;
2180                                  container = c.getInt(containerIndex);
2181                                  folderInfo.container = container;
2182                                  folderInfo.screenId = c.getInt(screenIndex);
2183                                  folderInfo.cellX = c.getInt(cellXIndex);
2184                                  folderInfo.cellY = c.getInt(cellYIndex);
2185                                  folderInfo.spanX = 1;
2186                                  folderInfo.spanY = 1;

2187  
2188                                  // check &amp; update map of what&#x27;s occupied
2189                                  if (!checkItemPlacement(occupied, folderInfo)) {
2190                                      itemsToRemove.add(id);
2191                                      break;
2192                                  }
2193  
2194                                  switch (container) {
2195                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2196                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2197                                          sBgWorkspaceItems.add(folderInfo);
2198                                          break;
2199                                  }
2200  
2201                                  if (restored) {
2202                                      // no special handling required for restored folders
2203                                      restoredRows.add(id);
2204                                  }
2205  
2206                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2207                                  sBgFolders.put(folderInfo.id, folderInfo);
2208                                  break;
2209  
2210                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2211                              case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
2212                                  // Read all Launcher-specific widget details
2213                                  boolean customWidget = itemType ==
2214                                      LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;
2215  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2216 +                                id = c.getLong(idIndex);</span>
2217                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2218                                  serialNumber= c.getLong(profileIdIndex);
2219                                  user = mUserManager.getUserForSerialNumber(serialNumber);




2220                                  if (user == null) {
2221                                      // User has been deleted remove the item.
2222                                      itemsToRemove.add(id);
2223                                      continue;
2224                                  }
2225                                  String savedProvider = c.getString(appWidgetProviderIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2226 -                                id = c.getLong(idIndex);</span>

2227                                  final ComponentName component =
2228                                          ComponentName.unflattenFromString(savedProvider);
2229  
2230                                  final int restoreStatus = c.getInt(restoredIndex);
2231                                  final boolean isIdValid = (restoreStatus &amp;
2232                                          LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2233  
2234                                  final boolean wasProviderReady = (restoreStatus &amp;
2235                                          LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2236  
2237                                  final LauncherAppWidgetProviderInfo provider =
2238                                          LauncherModel.getProviderInfo(context,
2239                                                  ComponentName.unflattenFromString(savedProvider),
2240                                                  user);
2241  
2242                                  final boolean isProviderReady = isValidProvider(provider);
2243                                  if (!isSafeMode &amp;&amp; !customWidget &amp;&amp;
2244                                          wasProviderReady &amp;&amp; !isProviderReady) {
2245                                      String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2246                                              + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2247  
2248                                      Log.e(TAG, log);
2249                                      Launcher.addDumpLog(TAG, log, false);
2250                                      itemsToRemove.add(id);
2251                                  } else {
2252                                      if (isProviderReady) {
2253                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2254                                                  provider.provider);
2255  
2256                                          if (!customWidget) {
2257                                              int[] minSpan =
2258                                                      Launcher.getMinSpanForWidget(context, provider);
2259                                              appWidgetInfo.minSpanX = minSpan[0];
2260                                              appWidgetInfo.minSpanY = minSpan[1];
2261                                          }
2262  
2263                                          int status = restoreStatus;
2264                                          if (!wasProviderReady) {
2265                                              // If provider was not previously ready, update the
2266                                              // status and UI flag.
2267  
<abbr title="2268                                              // Id would be valid only if the widget restore broadcast was received.">2268                                              // Id would be valid only if the widget restore broadcast was received🔵</abbr>
2269                                              if (isIdValid) {
2270                                                  status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2271                                              } else {
2272                                                  status &amp;= ~LauncherAppWidgetInfo
2273                                                          .FLAG_PROVIDER_NOT_READY;
2274                                              }
2275                                          }
2276                                          appWidgetInfo.restoreStatus = status;
2277                                      } else {
2278                                          Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2279                                                  + &quot; appWidgetId=&quot; + appWidgetId
2280                                                  + &quot; status =&quot; + restoreStatus);
2281                                          appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2282                                                  component);
2283                                          appWidgetInfo.restoreStatus = restoreStatus;

2284  
2285                                          if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {
2286                                              // Restore has started once.
2287                                          } else if (installingPkgs.contains(component.getPackageName())) {

2288                                              // App restore has started. Update the flag
2289                                              appWidgetInfo.restoreStatus |=
2290                                                      LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2291                                          } else if (REMOVE_UNRESTORED_ICONS &amp;&amp; !isSafeMode) {
2292                                              Launcher.addDumpLog(TAG,
2293                                                      &quot;Unrestored widget removed: &quot; + component, true);
2294                                              itemsToRemove.add(id);
2295                                              continue;
2296                                          }



2297                                      }
2298  
2299                                      appWidgetInfo.id = id;
2300                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2301                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2302                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2303                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2304                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
2305                                      appWidgetInfo.user = user;
2306  
2307                                      if (!customWidget) {
2308                                          int[] minSpan = Launcher.getMinSpanForWidget(context, provider);
2309                                          appWidgetInfo.minSpanX = minSpan[0];
2310                                          appWidgetInfo.minSpanY = minSpan[1];
2311                                      }
2312  
2313                                      container = c.getInt(containerIndex);

2314                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2315                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2316                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2317                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2318                                          continue;
2319                                      }
2320  
2321                                      appWidgetInfo.container = c.getInt(containerIndex);

2322                                      // check &amp; update map of what&#x27;s occupied
2323                                      if (!checkItemPlacement(occupied, appWidgetInfo)) {
2324                                          itemsToRemove.add(id);
2325                                          break;
2326                                      }
2327  
2328                                      if (!customWidget) {
2329                                          String providerName =
2330                                                  appWidgetInfo.providerName.flattenToString();
2331                                          if (!providerName.equals(savedProvider) ||
2332                                                  (appWidgetInfo.restoreStatus != restoreStatus)) {
2333                                              ContentValues values = new ContentValues();
2334                                              values.put(
2335                                                      LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2336                                                      providerName);
2337                                              values.put(LauncherSettings.Favorites.RESTORED,
2338                                                      appWidgetInfo.restoreStatus);
2339                                              String where = BaseColumns._ID + &quot;= ?&quot;;
2340                                              String[] args = {Long.toString(id)};
2341                                              contentResolver.update(contentUri, values, where, args);

2342                                          }
2343                                      }
2344                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2345                                      sBgAppWidgets.add(appWidgetInfo);
2346                                  }
2347                                  break;
2348                              }
2349                          } catch (Exception e) {
2350                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2351                          }
2352                      }
2353                  } finally {
2354                      if (c != null) {
2355                          c.close();
2356                      }
2357                  }
2358  
2359                  // Break early if we&#x27;ve stopped loading
2360                  if (mStopped) {
2361                      clearSBgDataStructures();
2362                      return false;

2363                  }
2364  
2365                  if (itemsToRemove.size() &gt; 0) {
2366                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
2367                              contentUri);
2368                      // Remove dead items
2369                      for (long id : itemsToRemove) {
2370                          if (DEBUG_LOADERS) {
2371                              Log.d(TAG, &quot;Removed id = &quot; + id);
2372                          }
2373                          // Don&#x27;t notify content observers
2374                          try {
2375                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2376                                      null, null);
2377                          } catch (RemoteException e) {
2378                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2379                          }














2380                      }
2381                  }
2382  
2383                  if (restoredRows.size() &gt; 0) {
2384                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2385                              contentUri);
2386                      // Update restored items that no longer require special handling
2387                      try {
2388                          StringBuilder selectionBuilder = new StringBuilder();
2389                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2390                          selectionBuilder.append(&quot; IN (&quot;);
2391                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2392                          selectionBuilder.append(&quot;)&quot;);
2393                          ContentValues values = new ContentValues();
2394                          values.put(LauncherSettings.Favorites.RESTORED, 0);
2395                          updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2396                                  values, selectionBuilder.toString(), null);
2397                      } catch (RemoteException e) {
2398                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2399                      }





2400                  }
2401  
2402                  if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2403                      context.registerReceiver(new AppsAvailabilityCheck(),
2404                              new IntentFilter(StartupReceiver.SYSTEM_READY),
2405                              null, sWorker);
2406                  }
2407  
2408                  if (loadedOldDb) {
2409                      long maxScreenId = 0;
2410                      // If we&#x27;re importing we use the old screen order.
2411                      for (ItemInfo item: sBgItemsIdMap.values()) {
2412                          long screenId = item.screenId;
2413                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2414                                  !sBgWorkspaceScreens.contains(screenId)) {
2415                              sBgWorkspaceScreens.add(screenId);
2416                              if (screenId &gt; maxScreenId) {
2417                                  maxScreenId = screenId;
2418                              }
2419                          }
2420                      }
2421                      Collections.sort(sBgWorkspaceScreens);
2422                      // Log to disk
2423                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2424                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2425                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2426  
2427                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);















2428                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2429  
2430                      // Update the max item id after we load an old db
2431                      long maxItemId = 0;
2432                      // If we&#x27;re importing we use the old screen order.
2433                      for (ItemInfo item: sBgItemsIdMap.values()) {
2434                          maxItemId = Math.max(maxItemId, item.id);
2435                      }
2436                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2437                  } else {
2438                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2439                      for (Integer i : orderedScreens.keySet()) {
2440                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2441                      }
2442                      // Log to disk
2443                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2444                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2445  
2446                      // Remove any empty screens
2447                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2448                      for (ItemInfo item: sBgItemsIdMap.values()) {
2449                          long screenId = item.screenId;
2450                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2451                                  unusedScreens.contains(screenId)) {
2452                              unusedScreens.remove(screenId);
2453                          }
2454                      }
2455  
2456                      // If there are any empty screens remove them, and update.
2457                      if (unusedScreens.size() != 0) {
2458                          // Log to disk
2459                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2460                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2461  
2462                          sBgWorkspaceScreens.removeAll(unusedScreens);
2463                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2464                      }
2465                  }
2466  
2467                  if (DEBUG_LOADERS) {
2468                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2469                      Log.d(TAG, &quot;workspace layout: &quot;);
2470                      int nScreens = occupied.size();
2471                      for (int y = 0; y &lt; countY; y++) {
2472                          String line = &quot;&quot;;
2473  
2474                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2475                          while (iter.hasNext()) {
2476                              long screenId = iter.next();


2477                              if (screenId &gt; 0) {
2478                                  line += &quot; | &quot;;
2479                              }

2480                              for (int x = 0; x &lt; countX; x++) {
2481                                  ItemInfo[][] screen = occupied.get(screenId);
2482                                  if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2483                                      line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2484                                  } else {
2485                                      line += &quot;!&quot;;
2486                                  }
2487                              }
2488                          }
2489                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2490                      }
2491                  }
2492              }
2493              return loadedOldDb;











2494          }
2495  
2496          /** Filters the set of items who are directly or indirectly (via another container) on the
2497           * specified screen. */
2498          private void filterCurrentWorkspaceItems(long currentScreenId,
2499                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2500                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2501                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2502              // Purge any null ItemInfos
2503              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2504              while (iter.hasNext()) {
2505                  ItemInfo i = iter.next();
2506                  if (i == null) {
2507                      iter.remove();
2508                  }
2509              }
2510  
2511              // Order the set of items by their containers first, this allows use to walk through the
2512              // list sequentially, build up a list of containers that are in the specified screen,
2513              // as well as all items in those containers.
2514              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2515              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2516                  @Override
2517                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2518                      return (int) (lhs.container - rhs.container);
2519                  }
2520              });
2521              for (ItemInfo info : allWorkspaceItems) {
2522                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2523                      if (info.screenId == currentScreenId) {
2524                          currentScreenItems.add(info);
2525                          itemsOnScreen.add(info.id);
2526                      } else {
2527                          otherScreenItems.add(info);
2528                      }
2529                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2530                      currentScreenItems.add(info);
2531                      itemsOnScreen.add(info.id);
2532                  } else {
2533                      if (itemsOnScreen.contains(info.container)) {
2534                          currentScreenItems.add(info);
2535                          itemsOnScreen.add(info.id);
2536                      } else {
2537                          otherScreenItems.add(info);
2538                      }
2539                  }
2540              }
2541          }
2542  
2543          /** Filters the set of widgets which are on the specified screen. */
2544          private void filterCurrentAppWidgets(long currentScreenId,
2545                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2546                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2547                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2548  
2549              for (LauncherAppWidgetInfo widget : appWidgets) {
2550                  if (widget == null) continue;
2551                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2552                          widget.screenId == currentScreenId) {
2553                      currentScreenWidgets.add(widget);
2554                  } else {
2555                      otherScreenWidgets.add(widget);
2556                  }
2557              }
2558          }
2559  
2560          /** Filters the set of folders which are on the specified screen. */
2561          private void filterCurrentFolders(long currentScreenId,
2562                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2563                  HashMap&lt;Long, FolderInfo&gt; folders,
2564                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2565                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2566  
2567              for (long id : folders.keySet()) {










2568                  ItemInfo info = itemsIdMap.get(id);
2569                  FolderInfo folder = folders.get(id);
2570                  if (info == null || folder == null) continue;
2571                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2572                          info.screenId == currentScreenId) {
2573                      currentScreenFolders.put(id, folder);
2574                  } else {
2575                      otherScreenFolders.put(id, folder);
2576                  }
2577              }
2578          }
2579  
2580          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2581           * right) */
2582          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2583              final LauncherAppState app = LauncherAppState.getInstance();
2584              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();

2585              // XXX: review this
2586              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2587                  @Override
2588                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2589                      int cellCountX = (int) grid.numColumns;
2590                      int cellCountY = (int) grid.numRows;


2591                      int screenOffset = cellCountX * cellCountY;
2592                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2593                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2594                              lhs.cellY * cellCountX + lhs.cellX);
2595                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2596                              rhs.cellY * cellCountX + rhs.cellX);
2597                      return (int) (lr - rr);
2598                  }
2599              });
2600          }
2601  
2602          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2603                  final ArrayList&lt;Long&gt; orderedScreens) {
2604              final Runnable r = new Runnable() {
2605                  @Override
2606                  public void run() {
2607                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2608                      if (callbacks != null) {
2609                          callbacks.bindScreens(orderedScreens);
2610                      }
2611                  }
2612              };
2613              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2614          }
2615  
2616          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2617                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2618                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2619                  final HashMap&lt;Long, FolderInfo&gt; folders,

2620                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2621  
2622              final boolean postOnMainThread = (deferredBindRunnables != null);
2623  
2624              // Bind the workspace items
2625              int N = workspaceItems.size();
2626              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2627                  final int start = i;
2628                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2629                  final Runnable r = new Runnable() {
2630                      @Override
2631                      public void run() {
2632                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2633                          if (callbacks != null) {
2634                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2635                                      false);
2636                          }
2637                      }
2638                  };
2639                  if (postOnMainThread) {
2640                      synchronized (deferredBindRunnables) {
2641                          deferredBindRunnables.add(r);
2642                      }
2643                  } else {
2644                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2645                  }
2646              }
2647  
2648              // Bind the folders
2649              if (!folders.isEmpty()) {
2650                  final Runnable r = new Runnable() {
2651                      public void run() {
2652                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2653                          if (callbacks != null) {
2654                              callbacks.bindFolders(folders);
2655                          }
2656                      }
2657                  };
2658                  if (postOnMainThread) {
2659                      synchronized (deferredBindRunnables) {
2660                          deferredBindRunnables.add(r);
2661                      }
2662                  } else {
2663                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2664                  }
2665              }
2666  
2667              // Bind the widgets, one at a time
2668              N = appWidgets.size();
2669              for (int i = 0; i &lt; N; i++) {
2670                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2671                  final Runnable r = new Runnable() {
2672                      public void run() {
2673                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2674                          if (callbacks != null) {
2675                              callbacks.bindAppWidget(widget);
2676                          }
2677                      }
2678                  };
2679                  if (postOnMainThread) {
2680                      deferredBindRunnables.add(r);
2681                  } else {
2682                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2683                  }
2684              }
2685          }
2686  
2687          /**
2688           * Binds all loaded data to actual views on the main thread.
2689           */
2690          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {

2691              final long t = SystemClock.uptimeMillis();
2692              Runnable r;
2693  
2694              // Don&#x27;t use these two variables in any of the callback runnables.
2695              // Otherwise we hold a reference to them.
2696              final Callbacks oldCallbacks = mCallbacks.get();
2697              if (oldCallbacks == null) {
2698                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2699                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2700                  return;
2701              }
2702  
2703              // Save a copy of all the bg-thread collections
2704              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2705              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2706                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2707              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2708              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2709              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();




2710              synchronized (sBgLock) {
2711                  workspaceItems.addAll(sBgWorkspaceItems);
2712                  appWidgets.addAll(sBgAppWidgets);
2713                  folders.putAll(sBgFolders);
2714                  itemsIdMap.putAll(sBgItemsIdMap);
2715                  orderedScreenIds.addAll(sBgWorkspaceScreens);



2716              }
2717  
2718              final boolean isLoadingSynchronously =
2719                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2720              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2721                  oldCallbacks.getCurrentWorkspaceScreen();
2722              if (currScreen &gt;= orderedScreenIds.size()) {
2723                  // There may be no workspace screens (just hotseat items and an empty page).
2724                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2725              }
2726              final int currentScreen = currScreen;
2727              final long currentScreenId = currentScreen &lt; 0
2728                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2729  
2730              // Load all the items that are on the current page first (and in the process, unbind
2731              // all the existing workspace items before we call startBinding() below.
2732              unbindWorkspaceItemsOnMainThread();
2733  
2734              // Separate the items that are on the current screen, and all the other remaining items
2735              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2736              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2737              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2738                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2739              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2740                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2741              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2742              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();


2743  
2744              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2745                      otherWorkspaceItems);
2746              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2747                      otherAppWidgets);
2748              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2749                      otherFolders);
2750              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2751              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2752  
2753              // Tell the workspace that we&#x27;re about to start binding items
2754              r = new Runnable() {
2755                  public void run() {
2756                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2757                      if (callbacks != null) {
2758                          callbacks.startBinding();
2759                      }
2760                  }
2761              };
2762              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2763  
2764              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2765  
2766              // Load items on the current page
2767              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2768                      currentFolders, null);
2769              if (isLoadingSynchronously) {
2770                  r = new Runnable() {
2771                      public void run() {
2772                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2773                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2774                              callbacks.onPageBoundSynchronously(currentScreen);
2775                          }
2776                      }
2777                  };
2778                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2779              }
2780  
2781              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2782              // work until after the first render)
2783              synchronized (mDeferredBindRunnables) {
2784                  mDeferredBindRunnables.clear();
2785              }
2786              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2787                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2788  
2789              // Tell the workspace that we&#x27;re done binding items
2790              r = new Runnable() {
2791                  public void run() {
2792                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2793                      if (callbacks != null) {
2794                          callbacks.finishBindingItems(isUpgradePath);

2795                      }
2796  
2797                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2798                      if (DEBUG_LOADERS) {
2799                          Log.d(TAG, &quot;bound workspace in &quot;
2800                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2801                      }
2802  
2803                      mIsLoadingAndBindingWorkspace = false;
2804                  }
2805              };
2806              if (isLoadingSynchronously) {
2807                  synchronized (mDeferredBindRunnables) {
2808                      mDeferredBindRunnables.add(r);
2809                  }
2810              } else {
2811                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);

2812              }
2813          }
2814  
2815          private void loadAndBindAllApps() {
2816              if (DEBUG_LOADERS) {
2817                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2818              }
2819              if (!mAllAppsLoaded) {
2820                  loadAllApps();
2821                  synchronized (LoaderTask.this) {
2822                      if (mStopped) {
2823                          return;
2824                      }






2825                      mAllAppsLoaded = true;
2826                  }
2827              } else {
2828                  onlyBindAllApps();
2829              }





















2830          }
2831  
2832          private void onlyBindAllApps() {
2833              final Callbacks oldCallbacks = mCallbacks.get();
2834              if (oldCallbacks == null) {
2835                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2836                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2837                  return;
2838              }
2839  
2840              // shallow copy
2841              @SuppressWarnings(&quot;unchecked&quot;)
2842              final ArrayList&lt;AppInfo&gt; list
2843                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();

2844              Runnable r = new Runnable() {
2845                  public void run() {
2846                      final long t = SystemClock.uptimeMillis();
2847                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2848                      if (callbacks != null) {
2849                          callbacks.bindAllApplications(list);

2850                      }
2851                      if (DEBUG_LOADERS) {
2852                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2853                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2854                      }
2855                  }
2856              };
2857              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2858              if (isRunningOnMainThread) {
2859                  r.run();
2860              } else {
2861                  mHandler.post(r);
2862              }
2863          }
2864  
2865          private void loadAllApps() {
2866              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2867  
2868              final Callbacks oldCallbacks = mCallbacks.get();
2869              if (oldCallbacks == null) {
2870                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2871                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2872                  return;
2873              }
2874  
2875              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2876              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2877  
2878              final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2879  
2880              // Clear the list of apps
2881              mBgAllAppsList.clear();
2882              SharedPreferences prefs = mContext.getSharedPreferences(
2883                      LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
2884              for (UserHandleCompat user : profiles) {
2885                  // Query for the set of apps
2886                  final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2887                  List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);

2888                  if (DEBUG_LOADERS) {
2889                      Log.d(TAG, &quot;getActivityList took &quot;
2890                              + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2891                      Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2892                  }
2893                  // Fail if we don&#x27;t have any apps
2894                  // TODO: Fix this. Only fail for the current user.
2895                  if (apps == null || apps.isEmpty()) {
2896                      return;
2897                  }
2898                  // Sort the applications by name
2899                  final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2900                  Collections.sort(apps,
2901                          new LauncherModel.ShortcutNameComparator(mLabelCache));
2902                  if (DEBUG_LOADERS) {
2903                      Log.d(TAG, &quot;sort took &quot;
2904                              + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2905                  }
2906  
2907                  // Create the ApplicationInfos
2908                  for (int i = 0; i &lt; apps.size(); i++) {
2909                      LauncherActivityInfoCompat app = apps.get(i);
2910                      // This builds the icon bitmaps.
2911                      mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2912                  }
2913  
2914                  if (ADD_MANAGED_PROFILE_SHORTCUTS &amp;&amp; !user.equals(UserHandleCompat.myUserHandle())) {
2915                      // Add shortcuts for packages which were installed while launcher was dead.
2916                      String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX
2917                              + mUserManager.getSerialNumberForUser(user);
2918                      Set&lt;String&gt; packagesAdded = prefs.getStringSet(shortcutsSetKey, Collections.EMPTY_SET);
2919                      HashSet&lt;String&gt; newPackageSet = new HashSet&lt;String&gt;();
2920  
2921                      for (LauncherActivityInfoCompat info : apps) {
2922                          String packageName = info.getComponentName().getPackageName();
2923                          if (!packagesAdded.contains(packageName)
2924                                  &amp;&amp; !newPackageSet.contains(packageName)) {
2925                              InstallShortcutReceiver.queueInstallShortcut(info, mContext);










2926                          }
2927                          newPackageSet.add(packageName);
2928                      }
2929  
2930                      prefs.edit().putStringSet(shortcutsSetKey, newPackageSet).commit();

2931                  }
2932              }
2933              // Huh? Shouldn&#x27;t this be inside the Runnable below?
2934              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2935              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2936  
2937              // Post callback on main thread
2938              mHandler.post(new Runnable() {
2939                  public void run() {

2940                      final long bindTime = SystemClock.uptimeMillis();
2941                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2942                      if (callbacks != null) {
2943                          callbacks.bindAllApplications(added);
2944                          if (DEBUG_LOADERS) {
2945                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2946                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2947                          }
2948                      } else {
2949                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2950                      }
2951                  }
2952              });
2953  





2954              if (DEBUG_LOADERS) {
2955                  Log.d(TAG, &quot;Icons processed in &quot;
2956                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2957              }
2958          }
2959  
2960          public void dumpState() {
2961              synchronized (sBgLock) {
2962                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2963                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2964                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2965                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2966                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2967              }
2968          }
2969      }
2970  























































2971      void enqueuePackageUpdated(PackageUpdatedTask task) {
2972          sWorker.post(task);
2973      }
2974  
2975      private class AppsAvailabilityCheck extends BroadcastReceiver {

2976  
2977          @Override
2978          public void onReceive(Context context, Intent intent) {
2979              synchronized (sBgLock) {
2980                  final LauncherAppsCompat launcherApps = LauncherAppsCompat
2981                          .getInstance(mApp.getContext());
2982                  final PackageManager manager = context.getPackageManager();
2983                  final ArrayList&lt;String&gt; packagesRemoved = new ArrayList&lt;String&gt;();
2984                  final ArrayList&lt;String&gt; packagesUnavailable = new ArrayList&lt;String&gt;();
2985                  for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2986                      UserHandleCompat user = entry.getKey();
2987                      packagesRemoved.clear();
2988                      packagesUnavailable.clear();
2989                      for (String pkg : entry.getValue()) {
2990                          if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2991                              boolean packageOnSdcard = launcherApps.isAppEnabled(
2992                                      manager, pkg, PackageManager.GET_UNINSTALLED_PACKAGES);
2993                              if (packageOnSdcard) {
2994                                  Launcher.addDumpLog(TAG, &quot;Package found on sd-card: &quot; + pkg, true);
2995                                  packagesUnavailable.add(pkg);
2996                              } else {
2997                                  Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2998                                  packagesRemoved.add(pkg);
2999                              }
3000                          }
3001                      }
3002                      if (!packagesRemoved.isEmpty()) {
3003                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
3004                                  packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
3005                      }
3006                      if (!packagesUnavailable.isEmpty()) {
3007                          enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE,
3008                                  packagesUnavailable.toArray(new String[packagesUnavailable.size()]), user));
3009                      }
3010                  }
3011                  sPendingPackages.clear();
3012              }
3013          }
3014      }
3015  
3016      private class PackageUpdatedTask implements Runnable {
3017          int mOp;
3018          String[] mPackages;
3019          UserHandleCompat mUser;
3020  
3021          public static final int OP_NONE = 0;
3022          public static final int OP_ADD = 1;
3023          public static final int OP_UPDATE = 2;
3024          public static final int OP_REMOVE = 3; // uninstlled
3025          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3026  
3027  
3028          public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3029              mOp = op;
3030              mPackages = packages;
3031              mUser = user;
3032          }
3033  
3034          public void run() {




3035              final Context context = mApp.getContext();
3036  
3037              final String[] packages = mPackages;
3038              final int N = packages.length;
3039              switch (mOp) {
3040                  case OP_ADD:

3041                      for (int i=0; i&lt;N; i++) {
3042                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3043                          mIconCache.remove(packages[i], mUser);

3044                          mBgAllAppsList.addPackage(context, packages[i], mUser);
3045                      }
3046  
3047                      // Auto add shortcuts for added packages.
3048                      if (ADD_MANAGED_PROFILE_SHORTCUTS
3049                              &amp;&amp; !UserHandleCompat.myUserHandle().equals(mUser)) {
3050                          SharedPreferences prefs = context.getSharedPreferences(
3051                                  LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
3052                          String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX
3053                                  + mUserManager.getSerialNumberForUser(mUser);
3054                          Set&lt;String&gt; shortcutSet = new HashSet&lt;String&gt;(
3055                                  prefs.getStringSet(shortcutsSetKey,Collections.EMPTY_SET));
3056  
3057                          for (int i=0; i&lt;N; i++) {
3058                              if (!shortcutSet.contains(packages[i])) {
3059                                  shortcutSet.add(packages[i]);
3060                                  List&lt;LauncherActivityInfoCompat&gt; activities =
3061                                          mLauncherApps.getActivityList(packages[i], mUser);
3062                                  if (activities != null &amp;&amp; !activities.isEmpty()) {
3063                                      InstallShortcutReceiver.queueInstallShortcut(
3064                                              activities.get(0), context);
3065                                  }
3066                              }
3067                          }
3068  
3069                          prefs.edit().putStringSet(shortcutsSetKey, shortcutSet).commit();



3070                      }
3071                      break;

3072                  case OP_UPDATE:
3073                      for (int i=0; i&lt;N; i++) {
3074                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);

3075                          mBgAllAppsList.updatePackage(context, packages[i], mUser);
3076                          WidgetPreviewLoader.removePackageFromDb(
3077                                  mApp.getWidgetPreviewCacheDb(), packages[i]);

3078                      }
3079                      break;
3080                  case OP_REMOVE:
3081                      // Remove the packageName for the set of auto-installed shortcuts. This
3082                      // will ensure that the shortcut when the app is installed again.
3083                      if (ADD_MANAGED_PROFILE_SHORTCUTS
3084                              &amp;&amp; !UserHandleCompat.myUserHandle().equals(mUser)) {
3085                          SharedPreferences prefs = context.getSharedPreferences(
3086                                  LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
3087                          String shortcutsSetKey = INSTALLED_SHORTCUTS_SET_PREFIX
3088                                  + mUserManager.getSerialNumberForUser(mUser);
3089                          HashSet&lt;String&gt; shortcutSet = new HashSet&lt;String&gt;(
3090                                  prefs.getStringSet(shortcutsSetKey, Collections.EMPTY_SET));
3091                          shortcutSet.removeAll(Arrays.asList(mPackages));
3092                          prefs.edit().putStringSet(shortcutsSetKey, shortcutSet).commit();
3093                      }
3094                      // Fall through
3095                  case OP_UNAVAILABLE:
3096                      boolean clearCache = mOp == OP_REMOVE;





3097                      for (int i=0; i&lt;N; i++) {
3098                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3099                          mBgAllAppsList.removePackage(packages[i], mUser, clearCache);
3100                          WidgetPreviewLoader.removePackageFromDb(
3101                                  mApp.getWidgetPreviewCacheDb(), packages[i]);









3102                      }
3103                      break;
3104              }
3105  
3106              ArrayList&lt;AppInfo&gt; added = null;
3107              ArrayList&lt;AppInfo&gt; modified = null;
3108              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3109  
3110              if (mBgAllAppsList.added.size() &gt; 0) {
3111                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3112                  mBgAllAppsList.added.clear();
3113              }
3114              if (mBgAllAppsList.modified.size() &gt; 0) {
3115                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3116                  mBgAllAppsList.modified.clear();
3117              }
3118              if (mBgAllAppsList.removed.size() &gt; 0) {
3119                  removedApps.addAll(mBgAllAppsList.removed);
3120                  mBgAllAppsList.removed.clear();
3121              }
3122  
3123              final Callbacks callbacks = getCallback();
3124              if (callbacks == null) {
3125                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3126                  return;
3127              }
3128  
3129              final HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps =
3130                      new HashMap&lt;ComponentName, AppInfo&gt;();
3131  
3132              if (added != null) {
3133                  // Ensure that we add all the workspace applications to the db
3134                  if (LauncherAppState.isDisableAllApps()) {
3135                      final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3136                      addAndBindAddedWorkspaceApps(context, addedInfos);
3137                  } else {
3138                      addAppsToAllApps(context, added);
3139                  }

3140                  for (AppInfo ai : added) {
3141                      addedOrUpdatedApps.put(ai.componentName, ai);
3142                  }
3143              }
3144  
3145              if (modified != null) {
3146                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3147                  for (AppInfo ai : modified) {
3148                      addedOrUpdatedApps.put(ai.componentName, ai);
3149                  }
3150  
3151                  mHandler.post(new Runnable() {
3152                      public void run() {
3153                          Callbacks cb = getCallback();
3154                          if (callbacks == cb &amp;&amp; cb != null) {
3155                              callbacks.bindAppsUpdated(modifiedFinal);
3156                          }
3157                      }
3158                  });
3159              }
3160  
3161              // Update shortcut infos
3162              if (mOp == OP_ADD || mOp == OP_UPDATE) {
3163                  final ArrayList&lt;ShortcutInfo&gt; updatedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3164                  final ArrayList&lt;ShortcutInfo&gt; removedShortcuts = new ArrayList&lt;ShortcutInfo&gt;();
3165                  final ArrayList&lt;LauncherAppWidgetInfo&gt; widgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
3166  
3167                  HashSet&lt;String&gt; packageSet = new HashSet&lt;String&gt;(Arrays.asList(packages));
3168                  synchronized (sBgLock) {
3169                      for (ItemInfo info : sBgItemsIdMap.values()) {

3170                          if (info instanceof ShortcutInfo &amp;&amp; mUser.equals(info.user)) {
3171                              ShortcutInfo si = (ShortcutInfo) info;
3172                              boolean infoUpdated = false;
3173                              boolean shortcutUpdated = false;
3174  
3175                              // Update shortcuts which use iconResource.
3176                              if ((si.iconResource != null)
3177                                      &amp;&amp; packageSet.contains(si.iconResource.packageName)) {
3178                                  Bitmap icon = Utilities.createIconBitmap(si.iconResource.packageName,
3179                                          si.iconResource.resourceName, mIconCache, context);



3180                                  if (icon != null) {
3181                                      si.setIcon(icon);
3182                                      si.usingFallbackIcon = false;
3183                                      infoUpdated = true;
3184                                  }
3185                              }
3186  
3187                              ComponentName cn = si.getTargetComponent();
3188                              if (cn != null &amp;&amp; packageSet.contains(cn.getPackageName())) {
3189                                  AppInfo appInfo = addedOrUpdatedApps.get(cn);
3190  
3191                                  if (si.isPromise()) {
3192                                      mIconCache.deletePreloadedIcon(cn, mUser);
3193                                      if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {
3194                                          // Auto install icon
3195                                          PackageManager pm = context.getPackageManager();
3196                                          ResolveInfo matched = pm.resolveActivity(
3197                                                  new Intent(Intent.ACTION_MAIN)
3198                                                  .setComponent(cn).addCategory(Intent.CATEGORY_LAUNCHER),
3199                                                  PackageManager.MATCH_DEFAULT_ONLY);
3200                                          if (matched == null) {
3201                                              // Try to find the best match activity.
3202                                              Intent intent = pm.getLaunchIntentForPackage(
3203                                                      cn.getPackageName());
3204                                              if (intent != null) {
3205                                                  cn = intent.getComponent();
3206                                                  appInfo = addedOrUpdatedApps.get(cn);
3207                                              }
3208  
3209                                              if ((intent == null) || (appInfo == null)) {
3210                                                  removedShortcuts.add(si);
3211                                                  continue;
3212                                              }
3213                                              si.promisedIntent = intent;
3214                                          }
3215                                      }
3216  
3217                                      // Restore the shortcut.




3218                                      si.intent = si.promisedIntent;
3219                                      si.promisedIntent = null;
3220                                      si.status &amp;= ~ShortcutInfo.FLAG_RESTORED_ICON
3221                                              &amp; ~ShortcutInfo.FLAG_AUTOINTALL_ICON
3222                                              &amp; ~ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE;
3223  

3224                                      infoUpdated = true;
3225                                      si.updateIcon(mIconCache);
3226                                  }
3227  
3228                                  if (appInfo != null &amp;&amp; Intent.ACTION_MAIN.equals(si.intent.getAction())
3229                                          &amp;&amp; si.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
3230                                      si.updateIcon(mIconCache);
3231                                      si.title = appInfo.title.toString();

3232                                      si.contentDescription = appInfo.contentDescription;
3233                                      infoUpdated = true;
3234                                  }
3235  
3236                                  if ((si.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE) != 0) {
3237                                      // Since package was just updated, the target must be available now.
3238                                      si.isDisabled &amp;= ~ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3239                                      shortcutUpdated = true;
3240                                  }
3241                              }
3242  
3243                              if (infoUpdated || shortcutUpdated) {
3244                                  updatedShortcuts.add(si);
3245                              }
3246                              if (infoUpdated) {
3247                                  updateItemInDatabase(context, si);
3248                              }
3249                          } else if (info instanceof LauncherAppWidgetInfo) {
3250                              LauncherAppWidgetInfo widgetInfo = (LauncherAppWidgetInfo) info;
3251                              if (mUser.equals(widgetInfo.user)
3252                                      &amp;&amp; widgetInfo.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3253                                      &amp;&amp; packageSet.contains(widgetInfo.providerName.getPackageName())) {
3254                                  widgetInfo.restoreStatus &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;
3255                                  widgets.add(widgetInfo);
3256                                  updateItemInDatabase(context, widgetInfo);
3257                              }
3258                          }
3259                      }
3260                  }
3261  
3262                  if (!updatedShortcuts.isEmpty() || !removedShortcuts.isEmpty()) {
3263                      mHandler.post(new Runnable() {
3264  
3265                          public void run() {
3266                              Callbacks cb = getCallback();
3267                              if (callbacks == cb &amp;&amp; cb != null) {
3268                                  callbacks.bindShortcutsChanged(
3269                                          updatedShortcuts, removedShortcuts, mUser);
3270                              }
3271                          }
3272                      });
3273                      if (!removedShortcuts.isEmpty()) {
3274                          deleteItemsFromDatabase(context, removedShortcuts);
3275                      }
3276                  }
3277                  if (!widgets.isEmpty()) {
3278                      mHandler.post(new Runnable() {
3279                          public void run() {
3280                              Callbacks cb = getCallback();
3281                              if (callbacks == cb &amp;&amp; cb != null) {
3282                                  callbacks.bindWidgetsRestored(widgets);
3283                              }
3284                          }
3285                      });
3286                  }
3287              }
3288  
3289              final ArrayList&lt;String&gt; removedPackageNames =
3290                      new ArrayList&lt;String&gt;();
3291              if (mOp == OP_REMOVE || mOp == OP_UNAVAILABLE) {
3292                  // Mark all packages in the broadcast to be removed
3293                  removedPackageNames.addAll(Arrays.asList(packages));
3294              } else if (mOp == OP_UPDATE) {
3295                  // Mark disabled packages in the broadcast to be removed
3296                  for (int i=0; i&lt;N; i++) {
3297                      if (isPackageDisabled(context, packages[i], mUser)) {
3298                          removedPackageNames.add(packages[i]);
3299                      }
3300                  }
3301              }
3302  
3303              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3304                  final int removeReason;
3305                  if (mOp == OP_UNAVAILABLE) {
3306                      removeReason = ShortcutInfo.FLAG_DISABLED_NOT_AVAILABLE;
3307                  } else {
3308                      // Remove all the components associated with this package
3309                      for (String pn : removedPackageNames) {
3310                          deletePackageFromDatabase(context, pn, mUser);
3311                      }
3312                      // Remove all the specific components
3313                      for (AppInfo a : removedApps) {
3314                          ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3315                          deleteItemsFromDatabase(context, infos);
3316                      }
3317                      removeReason = 0;
3318                  }
3319  
3320                  // Remove any queued items from the install queue
3321                  InstallShortcutReceiver.removeFromInstallQueue(context, removedPackageNames, mUser);
3322                  // Call the components-removed callback
3323                  mHandler.post(new Runnable() {
3324                      public void run() {
3325                          Callbacks cb = getCallback();
3326                          if (callbacks == cb &amp;&amp; cb != null) {
3327                              callbacks.bindComponentsRemoved(
3328                                      removedPackageNames, removedApps, mUser, removeReason);
3329                          }
3330                      }
3331                  });
3332              }
3333              if (Build.VERSION.SDK_INT &lt; 17) {
3334                  loadAndBindWidgetsAndShortcuts(context, callbacks);
3335              }




3336              // Write all the logs to disk
3337              mHandler.post(new Runnable() {
3338                  public void run() {
3339                      Callbacks cb = getCallback();
3340                      if (callbacks == cb &amp;&amp; cb != null) {
3341                          callbacks.dumpLogsToLocalData();
3342                      }
3343                  }
3344              });
3345          }
3346      }
3347  
3348      public static List&lt;LauncherAppWidgetProviderInfo&gt; getWidgetProviders(Context context,
3349              boolean refresh) {
3350          ArrayList&lt;LauncherAppWidgetProviderInfo&gt; results =
3351                  new ArrayList&lt;LauncherAppWidgetProviderInfo&gt;();
3352          try {
3353              synchronized (sBgLock) {
3354                  if (sBgWidgetProviders == null || refresh) {
3355                      HashMap&lt;ComponentKey, LauncherAppWidgetProviderInfo&gt; tmpWidgetProviders
3356                              = new HashMap&lt;&gt;();
3357                      AppWidgetManagerCompat wm = AppWidgetManagerCompat.getInstance(context);
3358                      LauncherAppWidgetProviderInfo info;
3359  
3360                      List&lt;AppWidgetProviderInfo&gt; widgets = wm.getAllProviders();
3361                      for (AppWidgetProviderInfo pInfo : widgets) {
3362                          info = LauncherAppWidgetProviderInfo.fromProviderInfo(context, pInfo);
3363                          UserHandleCompat user = wm.getUser(info);
3364                          tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3365                      }
3366  
3367                      Collection&lt;CustomAppWidget&gt; customWidgets = Launcher.getCustomAppWidgets().values();
3368                      for (CustomAppWidget widget : customWidgets) {
3369                          info = new LauncherAppWidgetProviderInfo(context, widget);
3370                          UserHandleCompat user = wm.getUser(info);
3371                          tmpWidgetProviders.put(new ComponentKey(info.provider, user), info);
3372                      }
3373                      // Replace the global list at the very end, so that if there is an exception,
3374                      // previously loaded provider list is used.
3375                      sBgWidgetProviders = tmpWidgetProviders;
3376                  }
3377                  results.addAll(sBgWidgetProviders.values());
3378                  return results;
3379              }
3380          } catch (Exception e) {
3381              if (e.getCause() instanceof TransactionTooLargeException) {
3382                  // the returned value may be incomplete and will not be refreshed until the next
3383                  // time Launcher starts.
3384                  // TODO: after figuring out a repro step, introduce a dirty bit to check when
3385                  // onResume is called to refresh the widget provider list.
3386                  synchronized (sBgLock) {
3387                      if (sBgWidgetProviders != null) {
3388                          results.addAll(sBgWidgetProviders.values());
3389                      }
3390                      return results;
3391                  }
3392              } else {
3393                  throw e;
3394              }
3395          }
3396      }
3397  
3398      public static LauncherAppWidgetProviderInfo getProviderInfo(Context ctx, ComponentName name,
3399              UserHandleCompat user) {
3400          synchronized (sBgLock) {
3401              if (sBgWidgetProviders == null) {
3402                  getWidgetProviders(ctx, false /* refresh */);
3403              }
3404              return sBgWidgetProviders.get(new ComponentKey(name, user));
3405          }
3406      }
3407  
3408      public void loadAndBindWidgetsAndShortcuts(final Context context, final Callbacks callbacks) {
3409          runOnWorkerThread(new Runnable(){




3410              @Override
3411              public void run() {
3412                  final ArrayList&lt;Object&gt; list =
3413                          getSortedWidgetsAndShortcuts(context, true /* refresh */);



3414                  mHandler.post(new Runnable() {
3415                      @Override
3416                      public void run() {
3417                          Callbacks cb = getCallback();
3418                          if (callbacks == cb &amp;&amp; cb != null) {
3419                              callbacks.bindPackagesUpdated(list);

3420                          }
3421                      }
3422                  });



3423              }
3424          });
3425      }
3426  
3427      // Returns a list of ResolveInfos/AppWidgetInfos in sorted order
3428      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context, boolean refresh) {






3429          PackageManager packageManager = context.getPackageManager();
3430          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3431          widgetsAndShortcuts.addAll(getWidgetProviders(context, refresh));
3432          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3433          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3434          Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3435          return widgetsAndShortcuts;
3436      }
3437  
3438      private static boolean isPackageDisabled(Context context, String packageName,




3439              UserHandleCompat user) {
3440          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3441          return !launcherApps.isPackageEnabledForProfile(packageName, user);
3442      }
3443  
3444      public static boolean isValidPackageActivity(Context context, ComponentName cn,
3445              UserHandleCompat user) {
3446          if (cn == null) {
3447              return false;
3448          }
3449          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3450          if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3451              return false;
3452          }
3453          return launcherApps.isActivityEnabledForProfile(cn, user);
3454      }
3455  
3456      public static boolean isValidPackage(Context context, String packageName,
3457              UserHandleCompat user) {
3458          if (packageName == null) {
3459              return false;
3460          }
3461          final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3462          return launcherApps.isPackageEnabledForProfile(packageName, user);
3463      }
3464  
3465      /**
3466       * Make an ShortcutInfo object for a restored application or shortcut item that points
3467       * to a package that is not yet installed on the system.
3468       */
3469      public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3470              int promiseType) {


3471          final ShortcutInfo info = new ShortcutInfo();
3472          info.user = UserHandleCompat.myUserHandle();
3473          mIconCache.getTitleAndIcon(info, intent, info.user, true);








3474  
3475          if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3476              String title = (cursor != null) ? cursor.getString(titleIndex) : null;

3477              if (!TextUtils.isEmpty(title)) {
3478                  info.title = title;
3479              }
3480              info.status = ShortcutInfo.FLAG_RESTORED_ICON;


3481          } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3482              if (TextUtils.isEmpty(info.title)) {
3483                  info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3484              }
3485              info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;


3486          } else {
3487              throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3488          }
3489  
3490          info.contentDescription = mUserManager.getBadgedLabelForUser(
3491                  info.title.toString(), info.user);
3492          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;


3493          info.promisedIntent = intent;

3494          return info;
3495      }
3496  
3497      /**
3498       * Make an Intent object for a restored application or shortcut item that points
3499       * to the market page for the item.
3500       */
3501      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {

3502          ComponentName componentName = intent.getComponent();
3503          return getMarketIntent(componentName.getPackageName());
3504      }
3505  
3506      static Intent getMarketIntent(String packageName) {
3507          return new Intent(Intent.ACTION_VIEW)
3508              .setData(new Uri.Builder()
3509                  .scheme(&quot;market&quot;)
3510                  .authority(&quot;details&quot;)
3511                  .appendQueryParameter(&quot;id&quot;, packageName)
3512                  .build());
3513      }
3514  
3515      /**
3516       * This is called from the code that adds shortcuts from the intent receiver.  This
3517       * doesn&#x27;t have a Cursor, but
3518       */
3519      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3520              UserHandleCompat user, Context context) {
3521          return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3522      }
3523  
3524      /**
3525       * Make an ShortcutInfo object for a shortcut that is an application.
3526       *
3527       * If c is not null, then it will be used to fill in missing data like the title and icon.
3528       */
3529      public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,

3530              UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3531              HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {

3532          if (user == null) {
3533              Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3534              return null;
3535          }
3536  
3537          ComponentName componentName = intent.getComponent();
3538          if (componentName == null) {
3539              Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3540              return null;
3541          }
3542  
3543          Intent newIntent = new Intent(intent.getAction(), null);
3544          newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3545          newIntent.setComponent(componentName);
3546          LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3547          if ((lai == null) &amp;&amp; !allowMissingTarget) {
3548              Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3549              return null;
3550          }
3551  
3552          final ShortcutInfo info = new ShortcutInfo();
3553  
3554          // the resource -- This may implicitly give us back the fallback icon,
3555          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3556          // to avoid saving lots of copies of that in the database, and most apps
3557          // have icons anyway.
3558          Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3559  
3560          // the db
3561          if (icon == null) {
3562              if (c != null) {
3563                  icon = getIconFromCursor(c, iconIndex, context);
3564              }
3565          }
3566          // the fallback icon
3567          if (icon == null) {
3568              icon = mIconCache.getDefaultIcon(user);
3569              info.usingFallbackIcon = true;
3570          }
3571          info.setIcon(icon);
3572  
3573          // From the cache.
3574          if (labelCache != null) {
3575              info.title = labelCache.get(componentName);
3576          }
3577  
3578          // from the resource
3579          if (info.title == null &amp;&amp; lai != null) {
3580              info.title = lai.getLabel();
3581              if (labelCache != null) {
3582                  labelCache.put(componentName, info.title);
3583              }
3584          }






3585          // from the db
3586          if (info.title == null) {
3587              if (c != null) {
3588                  info.title =  c.getString(titleIndex);
3589              }
3590          }




3591          // fall back to the class name of the activity
3592          if (info.title == null) {
3593              info.title = componentName.getClassName();
3594          }

3595          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3596          info.user = user;
3597          info.contentDescription = mUserManager.getBadgedLabelForUser(
3598                  info.title.toString(), info.user);




3599          return info;
3600      }
3601  
3602      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,

3603              ItemInfoFilter f) {
3604          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3605          for (ItemInfo i : infos) {
3606              if (i instanceof ShortcutInfo) {
3607                  ShortcutInfo info = (ShortcutInfo) i;
3608                  ComponentName cn = info.getTargetComponent();
3609                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3610                      filtered.add(info);
3611                  }
3612              } else if (i instanceof FolderInfo) {
3613                  FolderInfo info = (FolderInfo) i;
3614                  for (ShortcutInfo s : info.contents) {
3615                      ComponentName cn = s.getTargetComponent();
3616                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3617                          filtered.add(s);
3618                      }
3619                  }
3620              } else if (i instanceof LauncherAppWidgetInfo) {
3621                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3622                  ComponentName cn = info.providerName;
3623                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3624                      filtered.add(info);
3625                  }
3626              }
3627          }
3628          return new ArrayList&lt;ItemInfo&gt;(filtered);
3629      }
3630  
3631      private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,

3632              final UserHandleCompat user) {
3633          ItemInfoFilter filter  = new ItemInfoFilter() {
3634              @Override
3635              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3636                  if (info.user == null) {
3637                      return cn.equals(cname);
3638                  } else {
3639                      return cn.equals(cname) &amp;&amp; info.user.equals(user);
3640                  }
3641              }
3642          };
3643          return filterItemInfos(sBgItemsIdMap.values(), filter);

3644      }
3645  
3646      /**
3647       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3648       */
3649      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3650              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3651              int titleIndex) {
3652  
3653          Bitmap icon = null;


3654          final ShortcutInfo info = new ShortcutInfo();
3655          // Non-app shortcuts are only supported for current user.
3656          info.user = UserHandleCompat.myUserHandle();
3657          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3658  
3659          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3660  
3661          info.title = c.getString(titleIndex);
3662  
3663          int iconType = c.getInt(iconTypeIndex);
3664          switch (iconType) {
3665          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3666              String packageName = c.getString(iconPackageIndex);
3667              String resourceName = c.getString(iconResourceIndex);
3668              info.customIcon = false;
3669              // the resource
3670              icon = Utilities.createIconBitmap(packageName, resourceName, mIconCache, context);
3671              // the db
3672              if (icon == null) {
3673                  icon = getIconFromCursor(c, iconIndex, context);
3674              }
3675              // the fallback icon
3676              if (icon == null) {
3677                  icon = mIconCache.getDefaultIcon(info.user);
3678                  info.usingFallbackIcon = true;
3679              }
3680              break;
3681          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3682              icon = getIconFromCursor(c, iconIndex, context);
3683              if (icon == null) {
3684                  icon = mIconCache.getDefaultIcon(info.user);
3685                  info.customIcon = false;
3686                  info.usingFallbackIcon = true;
3687              } else {
3688                  info.customIcon = true;
3689              }
3690              break;
3691          default:





3692              icon = mIconCache.getDefaultIcon(info.user);
3693              info.usingFallbackIcon = true;
3694              info.customIcon = false;
3695              break;
3696          }
3697          info.setIcon(icon);
3698          return info;
3699      }
3700  
3701      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3702          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3703          final boolean debug = false;
3704          if (debug) {
3705              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3706                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3707          }
3708          byte[] data = c.getBlob(iconIndex);
3709          try {
3710              return Utilities.createIconBitmap(
3711                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3712          } catch (Exception e) {
3713              return null;
3714          }
3715      }
3716  
3717      ShortcutInfo infoFromShortcutIntent(Context context, Intent data) {
3718          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3719          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3720          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3721  
3722          if (intent == null) {
3723              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3724              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3725              return null;
3726          }
3727  
3728          Bitmap icon = null;
3729          boolean customIcon = false;
3730          ShortcutIconResource iconResource = null;
3731  
3732          if (bitmap instanceof Bitmap) {
3733              icon = Utilities.createIconBitmap((Bitmap) bitmap, context);
3734              customIcon = true;
3735          } else {
3736              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3737              if (extra instanceof ShortcutIconResource) {
3738                  iconResource = (ShortcutIconResource) extra;
3739                  icon = Utilities.createIconBitmap(iconResource.packageName,
3740                          iconResource.resourceName, mIconCache, context);

3741              }
3742          }
3743  
3744          final ShortcutInfo info = new ShortcutInfo();
3745  
3746          // Only support intents for current user for now. Intents sent from other
3747          // users wouldn&#x27;t get here without intent forwarding anyway.
3748          info.user = UserHandleCompat.myUserHandle();
3749          if (icon == null) {
3750              icon = mIconCache.getDefaultIcon(info.user);
3751              info.usingFallbackIcon = true;
3752          }
3753          info.setIcon(icon);
3754  
3755          info.title = name;
3756          info.contentDescription = mUserManager.getBadgedLabelForUser(
3757                  info.title.toString(), info.user);


3758          info.intent = intent;
3759          info.customIcon = customIcon;
3760          info.iconResource = iconResource;
3761  
3762          return info;
3763      }
3764  
3765      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3766              int iconIndex) {
3767          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3768          if (!mAppsCanBeOnRemoveableStorage) {
3769              return false;
3770          }
3771          // If this icon doesn&#x27;t have a custom icon, check to see
3772          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3773          // we&#x27;re going to show, store what we are going to show back
3774          // into the DB.  We do this so when we&#x27;re loading, if the
3775          // package manager can&#x27;t find an icon (for example because
3776          // the app is on SD) then we can use that instead.
3777          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3778              cache.put(info, c.getBlob(iconIndex));
3779              return true;
3780          }
3781          return false;
3782      }
3783      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3784          boolean needSave = false;
3785          try {
3786              if (data != null) {
3787                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3788                  Bitmap loaded = info.getIcon(mIconCache);
3789                  needSave = !saved.sameAs(loaded);
3790              } else {
3791                  needSave = true;
3792              }
3793          } catch (Exception e) {
3794              needSave = true;
3795          }
3796          if (needSave) {
3797              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3798              // This is slower than is ideal, but this only happens once
3799              // or when the app is updated with a new icon.
3800              updateItemInDatabase(context, info);
3801          }
3802      }
3803  
3804      /**
3805       * Return an existing FolderInfo object if we have encountered this ID previously,
3806       * or make a new one.
3807       */
3808      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {

3809          // See if a placeholder was created for us already
3810          FolderInfo folderInfo = folders.get(id);
3811          if (folderInfo == null) {
3812              // No placeholder -- create a new instance
3813              folderInfo = new FolderInfo();
3814              folders.put(id, folderInfo);
3815          }
3816          return folderInfo;
3817      }
3818  
3819      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3820          final Collator collator = Collator.getInstance();
3821          return new Comparator&lt;AppInfo&gt;() {
3822              public final int compare(AppInfo a, AppInfo b) {
3823                  if (a.user.equals(b.user)) {
3824                      int result = collator.compare(a.title.toString().trim(),
3825                              b.title.toString().trim());
3826                      if (result == 0) {
3827                          result = a.componentName.compareTo(b.componentName);
3828                      }
3829                      return result;
3830                  } else {
3831                      // TODO Need to figure out rules for sorting
3832                      // profiles, this puts work second.
3833                      return a.user.toString().compareTo(b.user.toString());
3834                  }
3835              }
3836          };
3837      }
3838      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3839              = new Comparator&lt;AppInfo&gt;() {
3840          public final int compare(AppInfo a, AppInfo b) {
3841              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3842              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3843              return 0;
3844          }
3845      };
3846      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3847          if (info.activityInfo != null) {
3848              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3849          } else {
3850              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3851          }
3852      }
3853      public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3854          private Collator mCollator;
3855          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3856          ShortcutNameComparator(PackageManager pm) {
3857              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3858              mCollator = Collator.getInstance();
3859          }
3860          ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3861              mLabelCache = labelCache;
3862              mCollator = Collator.getInstance();
3863          }
3864          public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3865              String labelA, labelB;
3866              ComponentName keyA = a.getComponentName();
3867              ComponentName keyB = b.getComponentName();
3868              if (mLabelCache.containsKey(keyA)) {
3869                  labelA = mLabelCache.get(keyA).toString();
3870              } else {
3871                  labelA = a.getLabel().toString().trim();
3872  
3873                  mLabelCache.put(keyA, labelA);
3874              }
3875              if (mLabelCache.containsKey(keyB)) {
3876                  labelB = mLabelCache.get(keyB).toString();
3877              } else {
3878                  labelB = b.getLabel().toString().trim();
3879  
3880                  mLabelCache.put(keyB, labelB);
3881              }
3882              return mCollator.compare(labelA, labelB);
3883          }
3884      };
3885      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3886          private final AppWidgetManagerCompat mManager;
3887          private final PackageManager mPackageManager;
3888          private final HashMap&lt;Object, String&gt; mLabelCache;
3889          private final Collator mCollator;
3890  
3891          WidgetAndShortcutNameComparator(Context context) {
3892              mManager = AppWidgetManagerCompat.getInstance(context);
3893              mPackageManager = context.getPackageManager();
3894              mLabelCache = new HashMap&lt;Object, String&gt;();
3895              mCollator = Collator.getInstance();
3896          }
3897          public final int compare(Object a, Object b) {
3898              String labelA, labelB;
3899              if (mLabelCache.containsKey(a)) {
3900                  labelA = mLabelCache.get(a);
3901              } else {
3902                  labelA = (a instanceof LauncherAppWidgetProviderInfo)
3903                          ? mManager.loadLabel((LauncherAppWidgetProviderInfo) a)
3904                          : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3905                  mLabelCache.put(a, labelA);
3906              }
3907              if (mLabelCache.containsKey(b)) {
3908                  labelB = mLabelCache.get(b);
3909              } else {
3910                  labelB = (b instanceof LauncherAppWidgetProviderInfo)
3911                          ? mManager.loadLabel((LauncherAppWidgetProviderInfo) b)
3912                          : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3913                  mLabelCache.put(b, labelB);
3914              }
3915              return mCollator.compare(labelA, labelB);
3916          }
3917      };
3918  
3919      static boolean isValidProvider(AppWidgetProviderInfo provider) {
3920          return (provider != null) &amp;&amp; (provider.provider != null)
3921                  &amp;&amp; (provider.provider.getPackageName() != null);
3922      }
3923  
3924      public void dumpState() {
3925          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3926          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3927          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3928          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3929          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3930          if (mLoaderTask != null) {
3931              mLoaderTask.dumpState();
3932          } else {
3933              Log.d(TAG, &quot;mLoaderTask=null&quot;);
3934          }
3935      }
3936  
3937      public Callbacks getCallback() {
3938          return mCallbacks != null ? mCallbacks.get() : null;
3939      }
















3940  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            