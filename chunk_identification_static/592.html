<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>592</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    592
                    <a href="591.html">prev</a>
                    <a href="593.html">next</a>
                    <a href="592_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_c5c7460a4569affea024c3c8eae8946dacf053df_redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c5c7460a4569affea024c3c8eae8946dacf053df:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c5c7460a4569affea024c3c8eae8946dacf053df^1:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c5c7460a4569affea024c3c8eae8946dacf053df^2:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f9b0e576551692e224bd5e7e4b91d334a784faa4:redis5/redis5-side/redis-async-side/src/main/java/com/dtstack/flink/sql/side/redis/RedisAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [bj], [s]], subset: [[b], [b], [sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  24 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  29 </span>
  30 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31 import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  32 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  33 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  36 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  37 import com.dtstack.flink.sql.enums.ECacheContentType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  38 import com.dtstack.flink.sql.side.AsyncReqRow;</span>
  39 =======
  40 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  41 import com.dtstack.flink.sql.enums.ECacheContentType;
  42 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  43 import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  44 import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  45 import com.dtstack.flink.sql.side.JoinInfo;</span>
  46 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 import org.apache.flink.configuration.Configuration;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import org.apache.flink.streaming.api.functions.async.ResultFuture;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  50 import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  51 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  52 import com.dtstack.flink.sql.enums.ECacheContentType;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  53 import com.dtstack.flink.sql.side.AsyncReqRow;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  54 import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  55 import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  56 import com.dtstack.flink.sql.side.JoinInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  57 import com.dtstack.flink.sql.side.SideTableInfo;</span>
  58 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  59 import com.dtstack.flink.sql.side.*;</span>
  60 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  61 import com.dtstack.flink.sql.side.cache.CacheObj;
  62 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  63 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  64 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  65 import io.lettuce.core.RedisClient;
  66 import io.lettuce.core.RedisFuture;
  67 import io.lettuce.core.api.StatefulRedisConnection;
  68 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  69 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  70 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  71 import io.lettuce.core.cluster.RedisClusterClient;
  72 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  73 import org.apache.commons.collections.MapUtils;
  74 import org.apache.commons.lang.StringUtils;
  75 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  76 import com.google.common.collect.Maps;
  77 import org.apache.flink.configuration.Configuration;
  78 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  79 import org.apache.flink.table.runtime.types.CRow;
  80 import org.apache.flink.types.Row;
  81 
  82 import java.util.Collections;
  83 import java.util.List;
  84 import java.util.Map;
  85 import java.util.function.Consumer;
  86 /**
  87  * @author yanxi
  88  */
  89 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  90 
  91     private static final long serialVersionUID = -2079908694523987738L;
  92 
  93     private RedisClient redisClient;
  94 
  95     private StatefulRedisConnection&lt;String, String&gt; connection;
  96 
  97     private RedisClusterClient clusterClient;
  98 
  99     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
 100 
 101     private RedisKeyAsyncCommands&lt;String, String&gt; async;
 102 
 103     private RedisSideTableInfo redisSideTableInfo;
 104 
 105     private RedisSideReqRow redisSideReqRow;
 106 
<abbr title=" 107     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {"> 107     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
 108         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
 109         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
 110     }
 111 
 112     @Override
 113     public void open(Configuration parameters) throws Exception {
 114         super.open(parameters);
 115         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
 116         buildRedisClient(redisSideTableInfo);
 117     }
 118 
 119     private void buildRedisClient(RedisSideTableInfo tableInfo){
 120         String url = redisSideTableInfo.getUrl();
 121         String password = redisSideTableInfo.getPassword();
 122         if (password != null){
 123             password = password + &quot;@&quot;;
 124         } else {
 125             password = &quot;&quot;;
 126         }
 127         String database = redisSideTableInfo.getDatabase();
 128         if (database == null){
 129             database = &quot;0&quot;;
 130         }
 131         switch (RedisType.parse(tableInfo.getRedisType())){
 132             case STANDALONE:
 133                 StringBuilder redisUri = new StringBuilder();
 134                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 135                 redisClient = RedisClient.create(redisUri.toString());
 136                 connection = redisClient.connect();
 137                 async = connection.async();
 138                 break;
 139             case SENTINEL:
 140                 StringBuilder sentinelUri = new StringBuilder();
 141                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 142                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 142                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.g🔵</abbr>
 143                 redisClient = RedisClient.create(sentinelUri.toString());
 144                 connection = redisClient.connect();
 145                 async = connection.async();
 146                 break;
 147             case CLUSTER:
 148                 StringBuilder clusterUri = new StringBuilder();
 149                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 150                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 151                 clusterConnection = clusterClient.connect();
 152                 async = clusterConnection.async();
 153             default:
 154 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 155 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156                 clusterClient = RedisClusterClient.create(clusterUri.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157                 clusterConnection = clusterClient.connect();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158                 async = clusterConnection.async();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 161 </span>
 162 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163                 break;</span>
 164 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 165         }
 166     }
 167 
 168     @Override
 169     public Row fillData(Row input, Object sideInput) {
 170         return redisSideReqRow.fillData(input, sideInput);
 171     }
 172 
 173     @Override
 174     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 175         CRow inputCopy = new CRow(input.row(), input.change());
 176         Map&lt;String, Object&gt; refData = Maps.newHashMap();
 177         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 178             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 179             Object equalObj = input.row().getField(conValIndex);
 180             if(equalObj == null){
 181                 dealMissKey(inputCopy, resultFuture);
 182                 return;
 183             }
 184             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 185         }
 186 
 187         String key = buildCacheKey(refData);
 188         if(StringUtils.isBlank(key)){
 189             return;
 190         }
 191         if(openCache()){
 192             CacheObj val = getFromCache(key);
 193             if(val != null){
 194                 if(ECacheContentType.MissVal == val.getType()){
 195                     dealMissKey(inputCopy, resultFuture);
 196                     return;
 197                 }else if(ECacheContentType.MultiLine == val.getType()){
 198                     try {
 199                         Row row = fillData(input.row(), val.getContent());
 200                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 201                     } catch (Exception e) {
 202                         dealFillDataError(resultFuture, e, inputCopy);
 203                     }
 204                 }else{
<abbr title=" 205                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 205                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 206                     resultFuture.completeExceptionally(exception);
 207                 }
 208                 return;
 209             }
 210         }
 211 
 212         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 213         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 214             @Override
 215             public void accept(Map&lt;String, String&gt; values) {
 216                 if (MapUtils.isNotEmpty(values)) {
 217                     try {
 218                         Row row = fillData(input.row(), values);
 219                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 220                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 221                     } catch (Exception e) {
 222                         dealFillDataError(resultFuture, e, inputCopy);
 223                     }
 224                 } else {
 225                     dealMissKey(inputCopy, resultFuture);
 226                     dealCacheData(key,CacheMissVal.getMissKeyObj());
 227                 }
 228             }
 229         });
 230     }
 231 
 232     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 233         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 234         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 235         for(String primaryKey : primaryKeys){
 236             if(!refData.containsKey(primaryKey)){
 237                 return null;
 238             }
 239             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 240         }
 241         return keyBuilder.toString();
 242     }
 243 
 244     @Override
 245     public void close() throws Exception {
 246         super.close();
 247         if (connection != null){
 248             connection.close();
 249         }
 250         if (redisClient != null){
 251             redisClient.shutdown();
 252         }
 253         if (clusterConnection != null){
 254             clusterConnection.close();
 255         }
 256         if (clusterClient != null){
 257             clusterClient.shutdown();
 258         }
 259     }
 260 
 261 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.side.redis;
  20 
  21 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  22 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  23 
  24 import com.dtstack.flink.sql.enums.ECacheContentType;
  25 import com.dtstack.flink.sql.side.*;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  28 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  29 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  30 import io.lettuce.core.RedisClient;
  31 import io.lettuce.core.RedisFuture;
  32 import io.lettuce.core.api.StatefulRedisConnection;
  33 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  34 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  35 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  36 import io.lettuce.core.cluster.RedisClusterClient;
  37 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  38 import org.apache.commons.collections.MapUtils;
  39 import org.apache.commons.lang.StringUtils;
  40 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  41 import com.google.common.collect.Maps;
  42 import org.apache.flink.configuration.Configuration;
  43 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  44 import org.apache.flink.table.runtime.types.CRow;
  45 import org.apache.flink.types.Row;
  46 
  47 import java.util.Collections;
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.function.Consumer;
  51 /**
  52  * @author yanxi
  53  */
  54 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  55 
  56     private static final long serialVersionUID = -2079908694523987738L;
  57 
  58     private RedisClient redisClient;
  59 
  60     private StatefulRedisConnection&lt;String, String&gt; connection;
  61 
  62     private RedisClusterClient clusterClient;
  63 
  64     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  65 
  66     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  67 
  68     private RedisSideTableInfo redisSideTableInfo;
  69 
  70     private RedisSideReqRow redisSideReqRow;
  71 
<abbr title="  72     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  72     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
  73         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  74         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  75     }
  76 
  77     @Override
  78     public void open(Configuration parameters) throws Exception {
  79         super.open(parameters);
  80         redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  81         buildRedisClient(redisSideTableInfo);
  82     }
  83 
  84     private void buildRedisClient(RedisSideTableInfo tableInfo){
  85         String url = redisSideTableInfo.getUrl();
  86         String password = redisSideTableInfo.getPassword();
  87         if (password != null){
  88             password = password + &quot;@&quot;;
  89         } else {
  90             password = &quot;&quot;;
  91         }
  92         String database = redisSideTableInfo.getDatabase();
  93         if (database == null){
  94             database = &quot;0&quot;;
  95         }
  96         switch (RedisType.parse(tableInfo.getRedisType())){
  97             case STANDALONE:
  98                 StringBuilder redisUri = new StringBuilder();
  99                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 100                 redisClient = RedisClient.create(redisUri.toString());
 101                 connection = redisClient.connect();
 102                 async = connection.async();
 103                 break;
 104             case SENTINEL:
 105                 StringBuilder sentinelUri = new StringBuilder();
 106                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 107                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 107                         .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.g🔵</abbr>
 108                 redisClient = RedisClient.create(sentinelUri.toString());
 109                 connection = redisClient.connect();
 110                 async = connection.async();
 111                 break;
 112             case CLUSTER:
 113                 StringBuilder clusterUri = new StringBuilder();
 114                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 115                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 116                 clusterConnection = clusterClient.connect();
 117                 async = clusterConnection.async();
 118             default:
 119 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 120 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121     }</span>
 122 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 123                 break;</span>
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 125         }
 126     }
 127 
 128     @Override
 129     public Row fillData(Row input, Object sideInput) {
 130         return redisSideReqRow.fillData(input, sideInput);
 131     }
 132 
 133     @Override
 134     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 135         CRow inputCopy = new CRow(input.row(),input.change());
 136         Map&lt;String, Object&gt; refData = Maps.newHashMap();
 137         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 138             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 139             Object equalObj = input.row().getField(conValIndex);
 140             if(equalObj == null){
 141                 dealMissKey(inputCopy, resultFuture);
 142                 return;
 143             }
 144             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 145         }
 146 
 147         String key = buildCacheKey(refData);
 148         if(StringUtils.isBlank(key)){
 149             return;
 150         }
 151         if(openCache()){
 152             CacheObj val = getFromCache(key);
 153             if(val != null){
 154                 if(ECacheContentType.MissVal == val.getType()){
 155                     dealMissKey(inputCopy, resultFuture);
 156                     return;
 157                 }else if(ECacheContentType.MultiLine == val.getType()){
 158                     try {
 159                         Row row = fillData(input.row(), val.getContent());
 160                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 161                     } catch (Exception e) {
 162                         dealFillDataError(resultFuture, e, inputCopy);
 163                     }
 164                 }else{
<abbr title=" 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 166                     resultFuture.completeExceptionally(exception);
 167                 }
 168                 return;
 169             }
 170         }
 171 
 172         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);
 173         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 174                 @Override
 175             public void accept(Map&lt;String, String&gt; values) {
 176                 if (MapUtils.isNotEmpty(values)) {
 177                         try {
 178                         Row row = fillData(input.row(), values);
 179                         dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
<abbr title=" 180                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));"> 180                             resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())🔵</abbr>
 181                         } catch (Exception e) {
 182                             dealFillDataError(resultFuture, e, inputCopy);
 183                         }
 184                     } else {
 185                         dealMissKey(inputCopy, resultFuture);
 186                         dealCacheData(key, CacheMissVal.getMissKeyObj());
 187                     }
 188                 }
 189             });
 190         }
 191 
 192     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 193         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 194         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 195         for(String primaryKey : primaryKeys){
 196             if(!refData.containsKey(primaryKey)){
 197                 return null;
 198             }
 199             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 200         }
 201         return keyBuilder.toString();
 202     }
 203 
 204     @Override
 205     public void close() throws Exception {
 206         super.close();
 207         if (connection != null){
 208             connection.close();
 209         }
 210         if (redisClient != null){
 211             redisClient.shutdown();
 212         }
 213         if (clusterConnection != null){
 214             clusterConnection.close();
 215         }
 216         if (clusterClient != null){
 217             clusterClient.shutdown();
 218         }
 219     }
 220 
 221 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.redis;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.side.*;
  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.cache.CacheObj;
  25 import com.dtstack.flink.sql.side.redis.enums.RedisType;
  26 import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  27 import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  28 import com.google.common.collect.Maps;
  29 import io.lettuce.core.RedisClient;
  30 import io.lettuce.core.RedisFuture;
  31 import io.lettuce.core.api.StatefulRedisConnection;
  32 import io.lettuce.core.api.async.RedisHashAsyncCommands;
  33 import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  34 import io.lettuce.core.api.async.RedisStringAsyncCommands;
  35 import io.lettuce.core.cluster.RedisClusterClient;
  36 import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  37 import java.util.Collections;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.function.Consumer;
  41 import org.apache.commons.collections.MapUtils;
  42 import org.apache.commons.lang.StringUtils;
  43 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  44 import org.apache.flink.configuration.Configuration;
  45 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  46 import org.apache.flink.table.runtime.types.CRow;
  47 import org.apache.flink.types.Row;
  48 
  49 
  50 /**
  51  * @author yanxi
  52  */
  53 public class RedisAsyncReqRow extends BaseAsyncReqRow {
  54     private static final long serialVersionUID = -2079908694523987738L;
  55 
  56     private RedisClient redisClient;
  57 
  58     private StatefulRedisConnection&lt;String, String&gt; connection;
  59 
  60     private RedisClusterClient clusterClient;
  61 
  62     private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  63 
  64     private RedisKeyAsyncCommands&lt;String, String&gt; async;
  65 
  66     private RedisSideTableInfo redisSideTableInfo;
  67 
  68     private RedisSideReqRow redisSideReqRow;
  69 
<abbr title="  70     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  70     public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,🔵</abbr>
  71         super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  72         redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  73     }
  74 
  75     @Override
  76     public void open(Configuration parameters) throws Exception {
  77         super.open(parameters);
  78         redisSideTableInfo = ((RedisSideTableInfo) (sideInfo.getSideTableInfo()));
  79         buildRedisClient(redisSideTableInfo);
  80     }
  81 
  82     private void buildRedisClient(RedisSideTableInfo tableInfo) {
  83         String url = redisSideTableInfo.getUrl();
  84         String password = redisSideTableInfo.getPassword();
  85         if (password != null) {
  86             password = password + &quot;@&quot;;
  87         } else {
  88             password = &quot;&quot;;
  89         }
  90         String database = redisSideTableInfo.getDatabase();
  91         if (database == null) {
  92             database = &quot;0&quot;;
  93         }
  94         switch (RedisType.parse(tableInfo.getRedisType())) {
  95             case STANDALONE :
  96                 StringBuilder redisUri = new StringBuilder();
  97                 redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
  98                 redisClient = RedisClient.create(redisUri.toString());
  99                 connection = redisClient.connect();
 100                 async = connection.async();
 101                 break;
 102             case SENTINEL :
 103                 StringBuilder sentinelUri = new StringBuilder();
<abbr title=" 104                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 104                 sentinelUri.append(&quot;redis-sentinel://&quot;).append(password).append(url).append(&quot;/&quot;).append(d🔵</abbr>
 105                 redisClient = RedisClient.create(sentinelUri.toString());
 106                 connection = redisClient.connect();
 107                 async = connection.async();
 108                 break;
 109             case CLUSTER :
 110                 StringBuilder clusterUri = new StringBuilder();
 111                 clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 112                 clusterClient = RedisClusterClient.create(clusterUri.toString());
 113                 clusterConnection = clusterClient.connect();
 114                 async = clusterConnection.async();
 115 
 116 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 117             default:</span>
 118 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 119 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 119 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 120 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 121 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 122             default:</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 123                 break;</span>
 124 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 125 
 126         }
 127     }
 128 
 129     @Override
 130     public Row fillData(Row input, Object sideInput) {
 131         return redisSideReqRow.fillData(input, sideInput);
 132     }
 133 
 134     @Override
 135     public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 136         CRow inputCopy = new CRow(input.row(), input.change());
 137         Map&lt;String, Object&gt; refData = Maps.newHashMap();
 138         for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 139             Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 140             Object equalObj = input.row().getField(conValIndex);
 141             if (equalObj == null) {
 142                 dealMissKey(inputCopy, resultFuture);
 143                 return;
 144             }
 145             refData.put(sideInfo.getEqualFieldList().get(i), equalObj);
 146         }
 147         String key = buildCacheKey(refData);
 148         if (StringUtils.isBlank(key)) {
 149             return;
 150         }
 151         if (openCache()) {
 152             CacheObj val = getFromCache(key);
 153             if (val != null) {
 154                 if (ECacheContentType.MissVal == val.getType()) {
 155                     dealMissKey(inputCopy, resultFuture);
 156                     return;
 157                 } else if (ECacheContentType.MultiLine == val.getType()) {
 158                     try {
 159                         Row row = fillData(input.row(), val.getContent());
 160                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 161                     } catch (java.lang.Exception e) {
 162                         dealFillDataError(resultFuture, e, inputCopy);
 163                     }
 164                 } else {
<abbr title=" 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 165                     RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val🔵</abbr>
 166                     resultFuture.completeExceptionally(exception);
 167                 }
 168                 return;
 169             }
 170         }
 171         RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) (async)).hgetall(key);
 172         future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {
 173             @Override
 174             public void accept(Map&lt;String, String&gt; values) {
 175                 if (MapUtils.isNotEmpty(values)) {
 176                     try {
 177                         Row row = fillData(input.row(), values);
 178                         dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));
 179                         resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 180                     } catch (java.lang.Exception e) {
 181                         dealFillDataError(resultFuture, e, inputCopy);
 182                     }
 183                 } else {
 184                     dealMissKey(inputCopy, resultFuture);
 185                     dealCacheData(key, CacheMissVal.getMissKeyObj());
 186                 }
 187             }
 188         });
 189     }
 190 
 191     private String buildCacheKey(Map&lt;String, Object&gt; refData) {
 192         StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());
 193         List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();
 194         for (String primaryKey : primaryKeys) {
 195             if (!refData.containsKey(primaryKey)) {
 196                 return null;
 197             }
 198             keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));
 199         }
 200         return keyBuilder.toString();
 201     }
 202 
 203     @Override
 204     public void close() throws Exception {
 205         super.close();
 206         if (connection != null) {
 207             connection.close();
 208         }
 209         if (redisClient != null) {
 210             redisClient.shutdown();
 211         }
 212         if (clusterConnection != null) {
 213             clusterConnection.close();
 214         }
 215         if (clusterClient != null) {
 216             clusterClient.shutdown();
 217         }
 218     }
 219 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import com.dtstack.flink.sql.side.BaseAsyncReqRow;</span>














  23  import org.apache.flink.api.java.typeutils.RowTypeInfo;

  24  import org.apache.flink.configuration.Configuration;
  25  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  26  import org.apache.flink.table.runtime.types.CRow;
  27  import org.apache.flink.types.Row;
  28  
  29  import com.dtstack.flink.sql.enums.ECacheContentType;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import com.dtstack.flink.sql.side.AsyncReqRow;</span>
  31  import com.dtstack.flink.sql.side.CacheMissVal;
  32  import com.dtstack.flink.sql.side.FieldInfo;
  33  import com.dtstack.flink.sql.side.JoinInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import com.dtstack.flink.sql.side.SideTableInfo;</span>
  35  import com.dtstack.flink.sql.side.cache.CacheObj;
  36  import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;
  37  import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;
  38  import com.google.common.collect.Lists;
  39  import com.google.common.collect.Maps;
  40  import io.lettuce.core.KeyValue;
  41  import io.lettuce.core.RedisClient;
  42  import io.lettuce.core.RedisFuture;
  43  import io.lettuce.core.api.StatefulRedisConnection;
  44  import io.lettuce.core.api.async.RedisKeyAsyncCommands;
  45  import io.lettuce.core.api.async.RedisStringAsyncCommands;
  46  import io.lettuce.core.cluster.RedisClusterClient;
  47  import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;
  48  import org.apache.commons.lang3.StringUtils;
  49  
  50  import java.util.Collections;
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.function.Consumer;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -public class RedisAsyncReqRow extends AsyncReqRow {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +/**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 + * @author yanxi</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 + */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +public class RedisAsyncReqRow extends BaseAsyncReqRow {</span>
  60  
  61      private static final long serialVersionUID = -2079908694523987738L;
  62  
  63      private RedisClient redisClient;
  64  
  65      private StatefulRedisConnection&lt;String, String&gt; connection;
  66  
  67      private RedisClusterClient clusterClient;
  68  
  69      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  70  
  71      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  72  
  73      private RedisSideTableInfo redisSideTableInfo;
  74  
  75      private RedisSideReqRow redisSideReqRow;
  76  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  77 -    public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  77 -    public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTabl🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  78 +    public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  78 +    public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, Abstract🔵</abbr></span>
  79          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  80          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  81      }
  82  
  83      @Override
  84      public void open(Configuration parameters) throws Exception {
  85          super.open(parameters);
  86          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  87          buildRedisClient(redisSideTableInfo);
  88      }
  89  
  90      private void buildRedisClient(RedisSideTableInfo tableInfo){
  91          String url = redisSideTableInfo.getUrl();
  92          String password = redisSideTableInfo.getPassword();
  93          if (password != null){
  94              password = password + &quot;@&quot;;
  95          } else {
  96              password = &quot;&quot;;
  97          }
  98          String database = redisSideTableInfo.getDatabase();
  99          if (database == null){
 100              database = &quot;0&quot;;
 101          }
 102          switch (tableInfo.getRedisType()){
 103              case 1:


 104                  StringBuilder redisUri = new StringBuilder();
 105                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 106                  redisClient = RedisClient.create(redisUri.toString());
 107                  connection = redisClient.connect();
 108                  async = connection.async();
 109                  break;
 110              case 2:

 111                  StringBuilder sentinelUri = new StringBuilder();
 112                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 113                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 113                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterN🔵</abbr>
 114                  redisClient = RedisClient.create(sentinelUri.toString());
 115                  connection = redisClient.connect();
 116                  async = connection.async();
 117                  break;
 118              case 3:

 119                  StringBuilder clusterUri = new StringBuilder();
 120                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 121                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 122                  clusterConnection = clusterClient.connect();
 123                  async = clusterConnection.async();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +            default:</span>

 125          }
 126      }
 127  
 128      @Override
 129      public Row fillData(Row input, Object sideInput) {
 130          return redisSideReqRow.fillData(input, sideInput);
 131      }
 132  
 133      @Override
 134      public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
 135          CRow inputCopy = new CRow(input.row(),input.change());
 136          List&lt;String&gt; keyData = Lists.newLinkedList();


 137          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 138              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
 139              Object equalObj = inputCopy.row().getField(conValIndex);

 140              if(equalObj == null){
 141                  dealMissKey(inputCopy, resultFuture);
 142                  return;
 143              }
 144              String value = equalObj.toString();
 145              keyData.add(sideInfo.getEqualFieldList().get(i));
 146              keyData.add(value);
 147          }
 148  
 149          String key = buildCacheKey(keyData);
 150  







 151          if(openCache()){
 152              CacheObj val = getFromCache(key);
 153              if(val != null){
 154                  if(ECacheContentType.MissVal == val.getType()){
 155                      dealMissKey(inputCopy, resultFuture);
 156                      return;
 157                  }else if(ECacheContentType.MultiLine == val.getType()){
 158                      try {
 159                          Row row = fillData(inputCopy.row(), val.getContent());
 160                          resultFuture.complete(Collections.singleton(new CRow(row, input.change())));


 161                      } catch (Exception e) {
 162                          dealFillDataError(resultFuture, e, inputCopy);
 163                      }
 164                  }else{
<abbr title=" 165                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 165                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(🔵</abbr>
 166                      resultFuture.completeExceptionally(exception);
 167                  }
 168                  return;
 169              }
 170          }
 171  
 172          Map&lt;String, String&gt; keyValue = Maps.newHashMap();
 173          List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();
 174          String[] values = value.toArray(new String[value.size()]);
 175          if (values.length == 0) {
 176              dealMissKey(inputCopy, resultFuture);
 177          } else {
 178              RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);
 179              future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {
 180                  @Override
 181                  public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {
 182                      if (keyValues.size() != 0) {
 183                          for (int i = 0; i &lt; keyValues.size(); i++) {
 184                              String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);
 185                              keyValue.put(splitKeys[1], splitKeys[2]);
 186                              keyValue.put(splitKeys[3], keyValues.get(i).getValue());
 187                          }
 188                          try {
 189                              Row row = fillData(inputCopy.row(), keyValue);
 190                              dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));
 191                              resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));
 192                          } catch (Exception e) {
 193                              dealFillDataError(resultFuture, e, inputCopy);
 194                          }
 195                      } else {
 196                          dealMissKey(inputCopy, resultFuture);
 197                          dealCacheData(key, CacheMissVal.getMissKeyObj());











 198                      }



 199                  }
 200              });
 201          }
 202      }
 203  
 204      private String buildCacheKey(List&lt;String&gt; keyData) {
 205          String kv = String.join(&quot;:&quot;, keyData);
 206          String tableName = redisSideTableInfo.getTableName();
 207          StringBuilder preKey =  new StringBuilder();
 208          preKey.append(tableName).append(&quot;:&quot;).append(kv);
 209          return preKey.toString();














 210      }
 211  
 212      @Override
 213      public void close() throws Exception {
 214          super.close();
 215          if (connection != null){
 216              connection.close();
 217          }
 218          if (redisClient != null){
 219              redisClient.shutdown();
 220          }
 221          if (clusterConnection != null){
 222              clusterConnection.close();
 223          }
 224          if (clusterClient != null){
 225              clusterClient.shutdown();
 226          }
 227      }
 228  
 229  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.side.redis;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.enums.ECacheContentType;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import com.dtstack.flink.sql.side.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.dtstack.flink.sql.side.cache.CacheObj;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.dtstack.flink.sql.side.redis.enums.RedisType;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import io.lettuce.core.RedisClient;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import io.lettuce.core.RedisFuture;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import io.lettuce.core.api.StatefulRedisConnection;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import io.lettuce.core.api.async.RedisHashAsyncCommands;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import io.lettuce.core.api.async.RedisKeyAsyncCommands;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import io.lettuce.core.cluster.RedisClusterClient;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.commons.collections.MapUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.apache.commons.lang.StringUtils;</span>
  37  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import com.google.common.collect.Maps;</span>
  39  import org.apache.flink.configuration.Configuration;
  40  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  41  import org.apache.flink.table.runtime.types.CRow;
  42  import org.apache.flink.types.Row;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  43 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  44 -import com.dtstack.flink.sql.enums.ECacheContentType;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import com.dtstack.flink.sql.side.AsyncReqRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import com.dtstack.flink.sql.side.CacheMissVal;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import com.dtstack.flink.sql.side.FieldInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import com.dtstack.flink.sql.side.JoinInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import com.dtstack.flink.sql.side.SideTableInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import com.dtstack.flink.sql.side.cache.CacheObj;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import com.dtstack.flink.sql.side.redis.table.RedisSideReqRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import com.dtstack.flink.sql.side.redis.table.RedisSideTableInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import io.lettuce.core.KeyValue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -import io.lettuce.core.RedisClient;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import io.lettuce.core.RedisFuture;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import io.lettuce.core.api.StatefulRedisConnection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import io.lettuce.core.api.async.RedisKeyAsyncCommands;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import io.lettuce.core.api.async.RedisStringAsyncCommands;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import io.lettuce.core.cluster.RedisClusterClient;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  62 -import io.lettuce.core.cluster.api.StatefulRedisClusterConnection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  63 -import org.apache.commons.lang3.StringUtils;</span>
  64  
  65  import java.util.Collections;
  66  import java.util.List;
  67  import java.util.Map;
  68  import java.util.function.Consumer;
  69  
  70  public class RedisAsyncReqRow extends AsyncReqRow {




  71  
  72      private static final long serialVersionUID = -2079908694523987738L;
  73  
  74      private RedisClient redisClient;
  75  
  76      private StatefulRedisConnection&lt;String, String&gt; connection;
  77  
  78      private RedisClusterClient clusterClient;
  79  
  80      private StatefulRedisClusterConnection&lt;String, String&gt; clusterConnection;
  81  
  82      private RedisKeyAsyncCommands&lt;String, String&gt; async;
  83  
  84      private RedisSideTableInfo redisSideTableInfo;
  85  
  86      private RedisSideReqRow redisSideReqRow;
  87  
<abbr title="  88      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTableInfo sideTableInfo) {">  88      public RedisAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, SideTabl🔵</abbr>

  89          super(new RedisAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  90          redisSideReqRow = new RedisSideReqRow(super.sideInfo);
  91      }
  92  
  93      @Override
  94      public void open(Configuration parameters) throws Exception {
  95          super.open(parameters);
  96          redisSideTableInfo = (RedisSideTableInfo) sideInfo.getSideTableInfo();
  97          buildRedisClient(redisSideTableInfo);
  98      }
  99  
 100      private void buildRedisClient(RedisSideTableInfo tableInfo){
 101          String url = redisSideTableInfo.getUrl();
 102          String password = redisSideTableInfo.getPassword();
 103          if (password != null){
 104              password = password + &quot;@&quot;;
 105          } else {
 106              password = &quot;&quot;;
 107          }
 108          String database = redisSideTableInfo.getDatabase();
 109          if (database == null){
 110              database = &quot;0&quot;;
 111          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -        switch (tableInfo.getRedisType()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -            case 1:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +        switch (RedisType.parse(tableInfo.getRedisType())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +            case STANDALONE:</span>
 116                  StringBuilder redisUri = new StringBuilder();
 117                  redisUri.append(&quot;redis://&quot;).append(password).append(url).append(&quot;/&quot;).append(database);
 118                  redisClient = RedisClient.create(redisUri.toString());
 119                  connection = redisClient.connect();
 120                  async = connection.async();
 121                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -            case 2:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +            case SENTINEL:</span>
 124                  StringBuilder sentinelUri = new StringBuilder();
 125                  sentinelUri.append(&quot;redis-sentinel://&quot;).append(password)
<abbr title=" 126                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterName());"> 126                          .append(url).append(&quot;/&quot;).append(database).append(&quot;#&quot;).append(redisSideTableInfo.getMasterN🔵</abbr>
 127                  redisClient = RedisClient.create(sentinelUri.toString());
 128                  connection = redisClient.connect();
 129                  async = connection.async();
 130                  break;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -            case 3:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +            case CLUSTER:</span>
 133                  StringBuilder clusterUri = new StringBuilder();
 134                  clusterUri.append(&quot;redis://&quot;).append(password).append(url);
 135                  clusterClient = RedisClusterClient.create(clusterUri.toString());
 136                  clusterConnection = clusterClient.connect();
 137                  async = clusterConnection.async();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +            default:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +                break;</span>
 140          }
 141      }
 142  
 143      @Override
 144      public Row fillData(Row input, Object sideInput) {
 145          return redisSideReqRow.fillData(input, sideInput);
 146      }
 147  
 148      @Override
 149      public void asyncInvoke(CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -        CRow inputCopy = new CRow(input.row(),input.change());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -        List&lt;String&gt; keyData = Lists.newLinkedList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +        CRow inputCopy = new CRow(input.row(), input.change());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +        Map&lt;String, Object&gt; refData = Maps.newHashMap();</span>
 154          for (int i = 0; i &lt; sideInfo.getEqualValIndex().size(); i++) {
 155              Integer conValIndex = sideInfo.getEqualValIndex().get(i);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -            Object equalObj = inputCopy.row().getField(conValIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +            Object equalObj = input.row().getField(conValIndex);</span>
 158              if(equalObj == null){
 159                  dealMissKey(inputCopy, resultFuture);
 160                  return;
 161              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 162 -            String value = equalObj.toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 163 -            keyData.add(sideInfo.getEqualFieldList().get(i));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 164 -            keyData.add(value);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 166 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -        String key = buildCacheKey(keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 168 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +            refData.put(sideInfo.getEqualFieldList().get(i), equalObj);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        String key = buildCacheKey(refData);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +        if(StringUtils.isBlank(key)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        }</span>
 176          if(openCache()){
 177              CacheObj val = getFromCache(key);
 178              if(val != null){
 179                  if(ECacheContentType.MissVal == val.getType()){
 180                      dealMissKey(inputCopy, resultFuture);
 181                      return;
 182                  }else if(ECacheContentType.MultiLine == val.getType()){
 183                      try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -                        Row row = fillData(inputCopy.row(), val.getContent());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -                        resultFuture.complete(Collections.singleton(new CRow(row, input.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +                        Row row = fillData(input.row(), val.getContent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
 188                      } catch (Exception e) {
 189                          dealFillDataError(resultFuture, e, inputCopy);
 190                      }
 191                  }else{
<abbr title=" 192                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType());"> 192                      RuntimeException exception = new RuntimeException(&quot;not support cache obj type &quot; + val.getType(🔵</abbr>
 193                      resultFuture.completeExceptionally(exception);
 194                  }
 195                  return;
 196              }
 197          }
 198  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -        Map&lt;String, String&gt; keyValue = Maps.newHashMap();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        List&lt;String&gt; value = async.keys(key + &quot;:*&quot;).get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -        String[] values = value.toArray(new String[value.size()]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -        if (values.length == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -            dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -            RedisFuture&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt; future = ((RedisStringAsyncCommands) async).mget(values);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -            future.thenAccept(new Consumer&lt;List&lt;KeyValue&lt;String, String&gt;&gt;&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -                public void accept(List&lt;KeyValue&lt;String, String&gt;&gt; keyValues) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -                    if (keyValues.size() != 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -                        for (int i = 0; i &lt; keyValues.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -                            String[] splitKeys = StringUtils.split(keyValues.get(i).getKey(), &quot;:&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -                            keyValue.put(splitKeys[1], splitKeys[2]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -                            keyValue.put(splitKeys[3], keyValues.get(i).getValue());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -                        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 216 -                            Row row = fillData(inputCopy.row(), keyValue);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -                            dealCacheData(key, CacheObj.buildCacheObj(ECacheContentType.MultiLine, keyValue));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -                            resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -                        } catch (Exception e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -                            dealFillDataError(resultFuture, e, inputCopy);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -                    } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -                        dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -                        dealCacheData(key, CacheMissVal.getMissKeyObj());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        RedisFuture&lt;Map&lt;String, String&gt;&gt; future = ((RedisHashAsyncCommands) async).hgetall(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +        future.thenAccept(new Consumer&lt;Map&lt;String, String&gt;&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +            public void accept(Map&lt;String, String&gt; values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +                if (MapUtils.isNotEmpty(values)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +                        Row row = fillData(input.row(), values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +                        dealCacheData(key,CacheObj.buildCacheObj(ECacheContentType.MultiLine, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +                        resultFuture.complete(Collections.singleton(new CRow(row, inputCopy.change())));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +                    } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +                        dealFillDataError(resultFuture, e, inputCopy);</span>
 236                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +                    dealMissKey(inputCopy, resultFuture);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +                    dealCacheData(key,CacheMissVal.getMissKeyObj());</span>
 240                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -            });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -    private String buildCacheKey(List&lt;String&gt; keyData) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -        String kv = String.join(&quot;:&quot;, keyData);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -        String tableName = redisSideTableInfo.getTableName();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -        StringBuilder preKey =  new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -        preKey.append(tableName).append(&quot;:&quot;).append(kv);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -        return preKey.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +    private String buildCacheKey(Map&lt;String, Object&gt; refData) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +        StringBuilder keyBuilder = new StringBuilder(redisSideTableInfo.getTableName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +        List&lt;String&gt; primaryKeys = redisSideTableInfo.getPrimaryKeys();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        for(String primaryKey : primaryKeys){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +            if(!refData.containsKey(primaryKey)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +                return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +            keyBuilder.append(&quot;_&quot;).append(refData.get(primaryKey));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +        return keyBuilder.toString();</span>
 265      }
 266  
 267      @Override
 268      public void close() throws Exception {
 269          super.close();
 270          if (connection != null){
 271              connection.close();
 272          }
 273          if (redisClient != null){
 274              redisClient.shutdown();
 275          }
 276          if (clusterConnection != null){
 277              clusterConnection.close();
 278          }
 279          if (clusterClient != null){
 280              clusterClient.shutdown();
 281          }
 282      }
 283  
 284  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            