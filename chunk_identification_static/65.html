<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>65</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    65
                    <a href="64.html">prev</a>
                    <a href="66.html">next</a>
                    <a href="65_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_37826f373652ce82466012d4d60a2e81bd4d0feb_Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;37826f373652ce82466012d4d60a2e81bd4d0feb:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;37826f373652ce82466012d4d60a2e81bd4d0feb^1:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;37826f373652ce82466012d4d60a2e81bd4d0feb^2:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;33d6f073222f84b537dac4c128bca96cbd16118f:Simplenote/src/main/java/com/automattic/simplenote/NoteEditorFragment.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewStub;
  31 import android.view.ViewTreeObserver;
  32 import android.view.inputmethod.InputMethodManager;
  33 import android.webkit.WebResourceRequest;
  34 import android.webkit.WebView;
  35 import android.webkit.WebViewClient;
  36 import android.widget.CompoundButton;
  37 import android.widget.CursorAdapter;
  38 import android.widget.LinearLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 
  42 import androidx.annotation.NonNull;
  43 import androidx.appcompat.app.AppCompatActivity;
  44 import androidx.appcompat.view.ActionMode;
  45 import androidx.core.app.ShareCompat;
  46 import androidx.core.view.MenuCompat;
  47 import androidx.core.widget.NestedScrollView;
  48 import androidx.fragment.app.Fragment;
  49 import androidx.fragment.app.FragmentTransaction;
  50 import androidx.preference.PreferenceManager;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Tag;
  55 import com.automattic.simplenote.utils.AppLog;
  56 import com.automattic.simplenote.utils.AppLog.Type;
  57 import com.automattic.simplenote.utils.AutoBullet;
  58 import com.automattic.simplenote.utils.BrowserUtils;
  59 import com.automattic.simplenote.utils.ContextUtils;
  60 import com.automattic.simplenote.utils.DisplayUtils;
  61 import com.automattic.simplenote.utils.DrawableUtils;
  62 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63 import com.automattic.simplenote.utils.NetworkUtils;
  64 import com.automattic.simplenote.utils.NoteUtils;
  65 import com.automattic.simplenote.utils.PrefUtils;
  66 import com.automattic.simplenote.utils.SimplenoteLinkify;
  67 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68 import com.automattic.simplenote.utils.SpaceTokenizer;
  69 import com.automattic.simplenote.utils.TagUtils;
  70 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72 import com.automattic.simplenote.utils.TextHighlighter;
  73 import com.automattic.simplenote.utils.ThemeUtils;
  74 import com.automattic.simplenote.utils.WidgetUtils;
  75 import com.automattic.simplenote.widgets.SimplenoteEditText;
  76 import com.google.android.material.chip.Chip;
  77 import com.google.android.material.chip.ChipGroup;
  78 import com.google.android.material.snackbar.Snackbar;
  79 import com.simperium.client.Bucket;
  80 import com.simperium.client.BucketObjectMissingException;
  81 import com.simperium.client.Query;
  82 
  83 import java.lang.ref.WeakReference;
  84 import java.util.Calendar;
  85 
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  95 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  96 
  97 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99         SimplenoteEditText.OnSelectionChangedListener,
 100         ShareBottomSheetDialog.ShareSheetListener,
 101         HistoryBottomSheetDialog.HistorySheetListener,
 102         SimplenoteEditText.OnCheckboxToggledListener {
 103 
 104     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110 
 111     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 112     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 113     private static final int MAX_REVISIONS = 30;
 114     private static final int PUBLISH_TIMEOUT = 20000;
 115     private static final int HISTORY_TIMEOUT = 10000;
 116     private Note mNote;
 117     private final Runnable mAutoSaveRunnable = new Runnable() {
 118         @Override
 119         public void run() {
 120             saveAndSyncNote();
 121         }
 122     };
 123     private Bucket&lt;Note&gt; mNotesBucket;
 124     private View mRootView;
 125     private View mTagPadding;
 126     private SimplenoteEditText mContentEditText;
 127     private ChipGroup mTagChips;
 128     private TagsMultiAutoCompleteTextView mTagInput;
 129     private Handler mAutoSaveHandler;
 130     private Handler mPublishTimeoutHandler;
 131     private Handler mHistoryTimeoutHandler;
 132     private LinearLayout mPlaceholderView;
 133     private CursorAdapter mLinkAutocompleteAdapter;
 134     private CursorAdapter mTagAutocompleteAdapter;
 135     private boolean mIsLoadingNote;
 136     private boolean mIsMarkdownEnabled;
 137     private boolean mIsPreviewEnabled;
 138     private boolean mShouldScrollToSearchMatch;
 139     private ActionMode mActionMode;
 140     private MenuItem mChecklistMenuItem;
 141     private MenuItem mCopyMenuItem;
 142     private MenuItem mInformationMenuItem;
 143     private MenuItem mShareMenuItem;
 144     private MenuItem mViewLinkMenuItem;
 145     private String mLinkUrl;
 146     private String mLinkText;
 147     private MatchOffsetHighlighter mHighlighter;
 148     private Drawable mBrowserIcon;
 149     private Drawable mCallIcon;
 150     private Drawable mCopyIcon;
 151     private Drawable mEmailIcon;
 152     private Drawable mLinkIcon;
 153     private Drawable mMapIcon;
 154     private Drawable mShareIcon;
 155     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 156     private String mMatchOffsets;
 157     private int mCurrentCursorPosition;
 158     private HistoryBottomSheetDialog mHistoryBottomSheet;
 159     private LinearLayout mError;
 160     private NoteMarkdownFragment mNoteMarkdownFragment;
 161     private String mCss;
 162     private WebView mMarkdown;
 163     private boolean mIsPaused;
 164     private boolean mIsFromWidget;
 165 
 166     // Hides the history bottom sheet if no revisions are loaded
 167     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 168         @Override
 169         public void run() {
 170             if (!isAdded()) {
 171                 return;
 172             }
 173 
 174             requireActivity().runOnUiThread(new Runnable() {
 175                 @Override
 176                 public void run() {
<abbr title=" 177                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 177                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 178                         mHistoryBottomSheet.dismiss();
 179                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 180                     }
 181                 }
 182             });
 183         }
 184     };
 185     private InfoBottomSheetDialog mInfoBottomSheet;
 186     private ShareBottomSheetDialog mShareBottomSheet;
 187     // Contextual action bar for dealing with links
 188     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 189         // Called when the action mode is created; startActionMode() was called
 190         @Override
 191         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 192             // Inflate a menu resource providing context menu items
 193             MenuInflater inflater = mode.getMenuInflater();
 194 
 195             if (inflater != null) {
 196                 inflater.inflate(R.menu.view_link, menu);
 197                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 198                 mShareMenuItem = menu.findItem(R.id.menu_share);
 199                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 200                 mode.setTitle(getString(R.string.link));
 201                 mode.setTitleOptionalHint(false);
 202 
 203                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 204             }
 205 
<abbr title=" 206             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 206             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 207             return true;
 208         }
 209 
 210         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 211         // may be called multiple times if the mode is invalidated.
 212         @Override
 213         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 214             return false; // Return false if nothing is done
 215         }
 216 
 217         // Called when the user selects a contextual menu item
 218         @Override
 219         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 220             switch (item.getItemId()) {
 221                 case R.id.menu_view_link:
 222                     if (mLinkText != null) {
 223                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 224                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 224                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 225                         } else {
 226                             try {
 227                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 228                             } catch (Exception e) {
 229                                 e.printStackTrace();
 230                             }
 231                         }
 232 
 233                         mode.finish(); // Action picked, so close the CAB
 234                     }
 235 
 236                     return true;
 237                 case R.id.menu_copy:
 238                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 239                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 240                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 241                         } else {
<abbr title=" 242                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 242                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 243                         }
 244 
 245                         mode.finish();
 246                     }
 247 
 248                     return true;
 249                 case R.id.menu_share:
 250                     if (mLinkText != null) {
 251                         showShare(mLinkText);
 252                         mode.finish();
 253                     }
 254 
 255                     return true;
 256                 default:
 257                     return false;
 258             }
 259         }
 260 
 261         // Called when the user exits the action mode
 262         @Override
 263         public void onDestroyActionMode(ActionMode mode) {
 264             if (mActionMode != null) {
 265                 mActionMode.setSubtitle(&quot;&quot;);
 266                 mActionMode = null;
 267             }
 268 
 269             new Handler().postDelayed(
 270                 new Runnable() {
 271                     @Override
 272                     public void run() {
<abbr title=" 273                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 273                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 274                     }
 275                 },
 276                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 277             );
 278         }
 279     };
 280     private Snackbar mPublishingSnackbar;
 281     private boolean mHideActionOnSuccess;
 282     // Resets note publish status if Simperium never returned the new publish status
 283     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 284         @Override
 285         public void run() {
 286             if (!isAdded()) return;
 287 
 288             requireActivity().runOnUiThread(new Runnable() {
 289                 @Override
 290                 public void run() {
 291 
 292                     mNote.setPublished(!mNote.isPublished());
 293                     mNote.save();
 294 
 295                     updatePublishedState(false);
 296                 }
 297             });
 298         }
 299     };
 300 
 301     /**
 302      * Mandatory empty constructor for the fragment manager to instantiate the
 303      * fragment (e.g. upon screen orientation changes).
 304      */
 305     public NoteEditorFragment() {
 306     }
 307 
 308     @Override
 309     public void onCreate(Bundle savedInstanceState) {
 310         super.onCreate(savedInstanceState);
 311         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 312         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 313         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 314         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 315         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 316 
 317         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 318         mNotesBucket = currentApp.getNotesBucket();
 319 
<abbr title=" 320         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 320         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 321         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 321         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 322         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 322         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 323         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 323         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 324         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 324         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 325         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 325         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 326         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 326         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 327 
 328         mAutoSaveHandler = new Handler();
 329         mPublishTimeoutHandler = new Handler();
 330         mHistoryTimeoutHandler = new Handler();
 331 
 332         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 333                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 333                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 334         mTagAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 335             @Override
 336             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 337                 Activity activity = (Activity) context;
 338                 if (activity == null) return null;
 339                 return activity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 340             }
 341 
 342             @Override
 343             public void bindView(View view, Context context, Cursor cursor) {
 344                 TextView textView = (TextView) view;
 345                 textView.setText(convertToString(cursor));
 346             }
 347 
 348             @Override
 349             public CharSequence convertToString(Cursor cursor) {
 350                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 351             }
 352 
 353             @Override
 354             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 355                 Activity activity = getActivity();
 356                 if (activity == null) return null;
 357                 Simplenote application = (Simplenote) activity.getApplication();
 358                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 359                 // make the tag name available to the cursor
 360                 query.include(Tag.NAME_PROPERTY);
 361                 // sort the tags by their names
 362                 query.order(Tag.NAME_PROPERTY);
 363                 // if there&#x27;s a filter string find only matching tag names
 364                 if (filter != null)
<abbr title=" 365                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 365                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 366                 return query.execute();
 367             }
 368         };
 369 
 370         mLinkAutocompleteAdapter = new CursorAdapter(getContext(), null, 0x0) {
 371             private Activity mActivity = requireActivity();
 372 
 373             @Override
 374             public void bindView(View view, Context context, Cursor cursor) {
 375                 ((TextView) view).setText(convertToString(cursor));
 376             }
 377 
 378             @Override
 379             public CharSequence convertToString(Cursor cursor) {
 380                 return cursor.getString(cursor.getColumnIndex(Note.TITLE_INDEX_NAME));
 381             }
 382 
 383             @Override
 384             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 385                 return mActivity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 386             }
 387 
 388             @Override
 389             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 390                 if (filter == null) {
 391                     return null;
 392                 }
 393 
 394                 Simplenote application = (Simplenote) mActivity.getApplication();
 395                 Query&lt;Note&gt; query = application.getNotesBucket().query();
 396                 query.include(Note.PINNED_INDEX_NAME);
 397                 query.include(Note.TITLE_INDEX_NAME);
<abbr title=" 398                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filter));"> 398                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filðŸ”µ</abbr>
 399                 PrefUtils.sortNoteQuery(query, requireContext(), true);
 400                 Cursor cursor = query.execute();
 401 
<abbr title=" 402                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * 48);"> 402                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * ðŸ”µ</abbr>
 403                 final int heightDisplay = DisplayUtils.getDisplayPixelSize(requireContext()).y;
 404                 final int heightDropdown = Math.min(heightDisplay / 4, heightAutocomplete);
 405 
 406                 mActivity.runOnUiThread(
 407                     new Runnable() {
 408                         @Override
 409                         public void run() {
 410                             mContentEditText.setDropDownHeight(heightDropdown);
 411                         }
 412                     }
 413                 );
 414                 return cursor;
 415             }
 416         };
 417 
 418         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 419     }
 420 
 421     @Override
<abbr title=" 422     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 422     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 423         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 424         mContentEditText = mRootView.findViewById(R.id.note_content);
 425         mContentEditText.addOnSelectionChangedListener(this);
 426         mContentEditText.setOnCheckboxToggledListener(this);
 427         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 428         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 429         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 429         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 430         mContentEditText.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 431         mContentEditText.setAdapter(mLinkAutocompleteAdapter);
 432         mTagInput = mRootView.findViewById(R.id.tag_input);
 433         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 434         mTagInput.setTokenizer(new SpaceTokenizer());
 435         mTagInput.setAdapter(mTagAutocompleteAdapter);
 436         mTagInput.setOnFocusChangeListener(this);
 437         mTagChips = mRootView.findViewById(R.id.tag_chips);
 438         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 439         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 440         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 441 
 442         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 443             mPlaceholderView.setVisibility(View.VISIBLE);
 444             requireActivity().invalidateOptionsMenu();
 445 
 446             if (BrowserUtils.isWebViewInstalled(requireContext())) {
 447                 ((ViewStub) mRootView.findViewById(R.id.stub_webview)).inflate();
 448                 mMarkdown = mRootView.findViewById(R.id.markdown);
 449                 mMarkdown.setWebViewClient(
 450                     new WebViewClient() {
 451                         @Override
<abbr title=" 452                         public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){"> 452                         public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request)ðŸ”µ</abbr>
 453                             String url = request.getUrl().toString();
 454 
 455                             if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){
<abbr title=" 456                                 SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 456                                 SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINKðŸ”µ</abbr>
 457                             } else {
 458                                 BrowserUtils.launchBrowserOrShowError(requireContext(), url);
 459                             }
 460 
 461                             return true;
 462                         }
 463                     }
 464 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 465                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 466             );</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 467             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 467             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()ðŸ”µ</abbr></span>
 468 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471             );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473                 ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474                 : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477         Bundle arguments = getArguments();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             // Load note if we were passed a note Id</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481             String key = arguments.getString(ARG_ITEM_ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489             if (mIsFromWidget) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491             } else {</span>
 492 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 493                 );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 494                 mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 495                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 496                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 497             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 498                 ((ViewStub) mRootView.findViewById(R.id.stub_error)).inflate();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 499                 mError = mRootView.findViewById(R.id.error);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 500                 mRootView.findViewById(R.id.button).setOnClickListener(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 501                     new View.OnClickListener() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 502                         @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 503                         public void onClick(View view) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 504                             BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_VIEW);"> 504                             BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 505                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 506                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 507                 );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 508             }</span>
 509 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 510         }
 511 
 512         Bundle arguments = getArguments();
 513 
 514         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 515             // Load note if we were passed a note Id
 516             String key = arguments.getString(ARG_ITEM_ID);
 517 
 518             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 519                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 520             }
 521 
 522             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 523 
 524             if (mIsFromWidget) {
 525                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 526             } else {
 527                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 528             }
 529 
 530             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 531         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 532             // Restore selected note when in dual pane mode
 533             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 534 
 535             if (noteId != null) {
 536                 setNote(noteId);
 537             }
 538         }
 539 
 540         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 541         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 542             @Override
 543             public void onGlobalLayout() {
 544                 // If a note was loaded with search matches, scroll to the first match in the editor
 545                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 546                     if (!isAdded()) {
 547                         return;
 548                     }
 549 
 550                     // Get the character location of the first search match
 551                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 552                             mContentEditText.getText(),
 553                             mMatchOffsets
 554                     );
 555                     if (matchLocation == 0) {
 556                         return;
 557                     }
 558 
 559                     // Calculate how far to scroll to bring the match into view
 560                     Layout layout = mContentEditText.getLayout();
 561                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 562                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 563                     mShouldScrollToSearchMatch = false;
 564                 }
 565             }
 566         });
 567         setHasOptionsMenu(true);
 568         return mRootView;
 569     }
 570 
 571     public void scrollToMatch(int location) {
 572         if (isAdded()) {
 573             // Calculate how far to scroll to bring the match into view
 574             Layout layout = mContentEditText.getLayout();
 575             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 576             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 577         }
 578     }
 579 
 580     @Override
 581     public void onResume() {
 582         super.onResume();
 583         checkWebView();
 584         mIsPaused = false;
 585         mNotesBucket.addListener(this);
 586         AppLog.add(Type.SYNC, &quot;Added note bucket listener (NoteEditorFragment)&quot;);
 587         mTagInput.setOnTagAddedListener(this);
 588 
 589         if (mContentEditText != null) {
<abbr title=" 590             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 590             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 591 
 592             if (mContentEditText.hasFocus()) {
 593                 showSoftKeyboard();
 594             }
 595         }
 596     }
 597 
 598     private void checkWebView() {
 599         // When a WebView is installed and mMarkdown is null on a large landscape device, a WebView
 600         // was not installed when the fragment was created.  So, recreate the activity to refresh
 601         // the editor view.
 602         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown == null &amp;&amp;
 603             DisplayUtils.isLargeScreenLandscape(requireContext())) {
 604             requireActivity().recreate();
 605         }
 606     }
 607 
 608     private void showSoftKeyboard() {
 609         new Handler().postDelayed(new Runnable() {
 610             @Override
 611             public void run() {
 612                 if (getActivity() == null) {
 613                     return;
 614                 }
 615 
<abbr title=" 616                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 616                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 617                 if (inputMethodManager != null) {
 618                     inputMethodManager.showSoftInput(mContentEditText, 0);
 619                 }
 620             }
 621         }, 100);
 622     }
 623 
 624     @Override
 625     public void onPause() {
 626         super.onPause();  // Always call the superclass method first
 627         mIsPaused = true;
 628 
 629         // Hide soft keyboard if it is showing...
 630         DisplayUtils.hideKeyboard(mContentEditText);
 631 
 632         mTagInput.setOnTagAddedListener(null);
 633 
 634         if (mAutoSaveHandler != null) {
 635             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 636             mAutoSaveHandler.post(mAutoSaveRunnable);
 637         }
 638 
 639         if (mPublishTimeoutHandler != null) {
 640             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 641         }
 642 
 643         if (mHistoryTimeoutHandler != null) {
 644             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 645         }
 646 
 647         mHighlighter.stop();
 648         saveNote();
 649         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 650     }
 651 
 652     @Override
 653     public void onDestroy() {
 654         super.onDestroy();
 655         mNotesBucket.removeListener(this);
 656         AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
 657         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 658     }
 659 
 660     @Override
 661     public void onSaveInstanceState(@NonNull Bundle outState) {
 662         super.onSaveInstanceState(outState);
 663 
 664         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 665             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 666         }
 667     }
 668 
 669     @Override
 670     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 671         super.onCreateOptionsMenu(menu, inflater);
 672 
<abbr title=" 673         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 673         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 674             return;
 675         }
 676 
 677         inflater.inflate(R.menu.note_editor, menu);
 678         MenuCompat.setGroupDividerEnabled(menu, true);
 679     }
 680 
 681     @Override
 682     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 683         switch (item.getItemId()) {
 684             case R.id.menu_checklist:
 685                 insertChecklist();
 686                 return true;
 687             case R.id.menu_copy:
 688                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 689                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 690                 } else {
 691                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 692                 }
 693 
 694                 return true;
 695             case R.id.menu_copy_internal:
<abbr title=" 696                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 696                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 697                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 698                 } else {
 699                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 700                 }
 701 
 702                 return true;
 703             case R.id.menu_history:
 704                 showHistory();
 705                 return true;
 706             case R.id.menu_info:
 707                 showInfo();
 708                 return true;
 709             case R.id.menu_markdown:
 710                 setMarkdown(!item.isChecked());
 711                 return true;
 712             case R.id.menu_pin:
 713                 NoteUtils.setNotePin(mNote, !item.isChecked());
 714                 requireActivity().invalidateOptionsMenu();
 715                 return true;
 716             case R.id.menu_publish:
 717                 if (item.isChecked()) {
 718                     unpublishNote();
 719                 } else {
 720                     publishNote();
 721                 }
 722 
 723                 return true;
 724             case R.id.menu_share:
 725                 shareNote();
 726                 return true;
 727             case R.id.menu_trash:
 728                 if (!isAdded()) {
 729                     return false;
 730                 }
 731 
 732                 deleteNote();
 733                 return true;
 734             case android.R.id.home:
 735                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 736                 if (!isAdded()) {
 737                     return false;
 738                 }
 739 
 740                 requireActivity().finish();
 741                 return true;
 742             default:
 743                 return super.onOptionsItemSelected(item);
 744         }
 745     }
 746 
 747     @Override
 748     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 749         if (mNote != null) {
 750             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 751             MenuItem shareItem = menu.findItem(R.id.menu_share);
 752             MenuItem historyItem = menu.findItem(R.id.menu_history);
 753             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 754             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 755             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 756             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 757             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 758             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 759 
 760             pinItem.setChecked(mNote.isPinned());
 761             publishItem.setChecked(mNote.isPublished());
 762             markdownItem.setChecked(mNote.isMarkdownEnabled());
 763 
 764             // Disable actions when note is in Trash or markdown view is shown on large device.
 765             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 766                 pinItem.setEnabled(false);
 767                 shareItem.setEnabled(false);
 768                 historyItem.setEnabled(false);
 769                 publishItem.setEnabled(false);
 770                 copyLinkItem.setEnabled(false);
 771                 markdownItem.setEnabled(false);
 772                 mChecklistMenuItem.setEnabled(false);
 773                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 774             } else {
 775                 pinItem.setEnabled(true);
 776                 shareItem.setEnabled(true);
 777                 historyItem.setEnabled(true);
 778                 publishItem.setEnabled(true);
 779                 copyLinkItem.setEnabled(mNote.isPublished());
 780                 markdownItem.setEnabled(true);
 781                 mChecklistMenuItem.setEnabled(true);
 782                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 783             }
 784 
 785             if (mNote.isDeleted()) {
 786                 trashItem.setTitle(R.string.restore);
 787             } else {
 788                 trashItem.setTitle(R.string.trash);
 789             }
 790         }
 791 
 792         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 793         super.onPrepareOptionsMenu(menu);
 794     }
 795 
 796     public void insertChecklist() {
 797         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 798 
 799         try {
 800             mContentEditText.insertChecklist();
 801         } catch (Exception e) {
 802             e.printStackTrace();
 803             return;
 804         }
 805 
 806         AnalyticsTracker.track(
 807             EDITOR_CHECKLIST_INSERTED,
 808             CATEGORY_NOTE,
 809             &quot;toolbar_button&quot;
 810         );
 811     }
 812 
 813     @Override
 814     public void onCheckboxToggled() {
 815         // Save note (using delay) after toggling a checkbox
 816         if (mAutoSaveHandler != null) {
 817             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 818             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 819         }
 820     }
 821 
 822     private void deleteNote() {
 823         NoteUtils.deleteNote(mNote, getActivity());
 824         requireActivity().finish();
 825     }
 826 
 827     protected void clearMarkdown() {
 828         if (mMarkdown != null) {
<abbr title=" 829             mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);"> 829             mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, nullðŸ”µ</abbr>
 830         }
 831     }
 832 
 833     protected void hideMarkdown() {
 834         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {
 835             mMarkdown.setVisibility(View.INVISIBLE);
 836         } else {
 837             mError.setVisibility(View.INVISIBLE);
 838         }
 839     }
 840 
 841     protected void showMarkdown() {
 842         loadMarkdownData();
 843 
 844         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {
 845             mMarkdown.setVisibility(View.VISIBLE);
 846         } else {
 847             mError.setVisibility(View.VISIBLE);
 848         }
 849 
 850         new Handler().postDelayed(
 851             new Runnable() {
 852                 @Override
 853                 public void run() {
 854                     requireActivity().invalidateOptionsMenu();
 855                 }
 856             },
 857             getResources().getInteger(R.integer.time_animation)
 858         );
 859     }
 860 
 861     public void shareNote() {
 862         if (mNote != null) {
 863             mContentEditText.clearFocus();
 864             showShareSheet();
 865             AnalyticsTracker.track(
 866                 EDITOR_NOTE_CONTENT_SHARED,
 867                 CATEGORY_NOTE,
 868                 &quot;action_bar_share_button&quot;
 869             );
 870         }
 871     }
 872 
 873     public void showHistory() {
 874         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 875             mContentEditText.clearFocus();
 876             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 877             showHistorySheet();
 878         } else {
 879             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 880         }
 881     }
 882 
 883     public void showInfo() {
 884         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 885 
 886         if (mNote != null) {
 887             mContentEditText.clearFocus();
 888             saveNote();
 889             showInfoSheet();
 890         }
 891     }
 892 
 893     private void setMarkdown(boolean isChecked) {
 894         mIsMarkdownEnabled = isChecked;
 895         showMarkdownActionOrTabs();
 896         saveNote();
 897 
 898         // Set preference so that next new note will have markdown enabled.
 899         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 900         SharedPreferences.Editor editor = prefs.edit();
 901         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 902         editor.apply();
 903     }
 904 
 905     private void setMarkdownEnabled(boolean enabled) {
 906         mIsMarkdownEnabled = enabled;
 907 
 908         if (mIsMarkdownEnabled) {
 909             loadMarkdownData();
 910         }
 911     }
 912 
 913     private void showMarkdownActionOrTabs() {
 914         Activity activity = getActivity();
 915 
 916         if (activity instanceof NoteEditorActivity) {
 917             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 918 
 919             if (mIsMarkdownEnabled) {
 920                 editorActivity.showTabs();
 921 
 922                 if (mNoteMarkdownFragment == null) {
 923                     // Get markdown fragment and update content
 924                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 925                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 926                 }
 927             } else {
 928                 editorActivity.hideTabs();
 929             }
 930         } else if (activity instanceof NotesActivity) {
 931             setMarkdownEnabled(mIsMarkdownEnabled);
 932             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 933         }
 934     }
 935 
 936     private void loadMarkdownData() {
 937         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 938             mCss,
 939             mContentEditText.getPreviewTextContent()
 940         );
 941 
 942         if (mMarkdown != null) {
 943             mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 944         }
 945     }
 946 
 947     public void setNote(String noteID, String matchOffsets) {
 948         if (mAutoSaveHandler != null) {
 949             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 950         }
 951 
 952         mPlaceholderView.setVisibility(View.GONE);
 953         mMatchOffsets = matchOffsets;
 954         saveNote();
 955         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 956     }
 957 
 958     private void updateNote(Note updatedNote) {
 959         // update note if network change arrived
 960         mNote = updatedNote;
 961         refreshContent(true);
 962     }
 963 
 964     private void refreshContent(boolean isNoteUpdate) {
 965         if (mNote != null) {
 966             // Restore the cursor position if possible.
<abbr title=" 967             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 967             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 968             mContentEditText.setText(mNote.getContent());
 969 
 970             if (isNoteUpdate) {
 971                 // Update markdown and preview flags from updated note.
 972                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 973                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 974 
 975                 // Show/Hide action/tabs based on markdown flag.
 976                 showMarkdownActionOrTabs();
 977 
 978                 // Save note so any local changes get synced.
 979                 mNote.save();
 980 
 981                 // Update current note object on large screen devices in landscape orientation.
 982                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 983                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 984                 }
 985 
 986                 // Update overflow popup menu.
 987                 requireActivity().invalidateOptionsMenu();
 988 
 989                 if (mContentEditText.hasFocus()
 990                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 991                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 992                     mContentEditText.setSelection(cursorPosition);
 993                 }
 994             }
 995 
 996             afterTextChanged(mContentEditText.getText());
 997             mContentEditText.processChecklists();
 998             updateTagList();
 999         }
1000     }
1001 
1002     private void updateTagList() {
1003         setChips(mNote.getTagString());
1004         mTagInput.setText(&quot;&quot;);
1005     }
1006 
1007     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
1008         // Ported from the iOS app :)
1009         // Cases:
1010         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
1011         // 1. Text was added after the cursor ==&gt; no change
1012         // 2. Text was added before the cursor ==&gt; location advances
1013         // 3. Text was removed after the cursor ==&gt; no change
1014         // 4. Text was removed before the cursor ==&gt; location retreats
1015         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
1016 
1017         cursorLocation = Math.max(cursorLocation, 0);
1018 
1019         int newCursorLocation = cursorLocation;
1020 
1021         int deltaLength = newText.length() - oldText.length();
1022 
1023         // Case 0
1024         if (newText.length() &lt; cursorLocation)
1025             return newText.length();
1026 
1027         boolean beforeCursorMatches = false;
1028         boolean afterCursorMatches = false;
1029 
1030         try {
<abbr title="1031             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));">1031             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title="1032             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));">1032             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
1033         } catch (Exception e) {
1034             e.printStackTrace();
1035         }
1036 
1037         // Cases 2 and 4
1038         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
1039             newCursorLocation += deltaLength;
1040 
1041         // Cases 1, 3 and 5 have no change
1042         return newCursorLocation;
1043     }
1044 
1045     @Override
1046     public void onTagAdded(String tag) {
1047         if (mNote == null || !isAdded()) {
1048             return;
1049         }
1050 
1051         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
1052             AnalyticsTracker.track(
1053                 EDITOR_TAG_ADDED,
1054                 CATEGORY_NOTE,
1055                 &quot;tag_added_to_note&quot;
1056             );
1057         }
1058 
1059         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
1060         mNote.setModificationDate(Calendar.getInstance());
1061         updateTagList();
1062         mNote.save();
1063     }
1064 
1065     @Override
1066     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
1067         // Unused
1068     }
1069 
1070     @Override
1071     public void afterTextChanged(Editable editable) {
1072         attemptAutoList(editable);
1073         setTitleSpan(editable);
1074         mContentEditText.fixLineSpacing();
1075     }
1076 
1077     @Override
1078     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1079         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1080         if (mAutoSaveHandler != null) {
1081             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1082             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1083         }
1084 
1085         // Remove search highlight spans when note content changes
1086         if (mMatchOffsets != null) {
1087             mMatchOffsets = null;
1088             mHighlighter.removeMatches();
1089         }
1090 
1091         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1092             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1093         }
1094 
1095         // Temporarily remove the text watcher as we process checklists to prevent callback looping
1096         mContentEditText.removeTextChangedListener(this);
1097         mContentEditText.processChecklists();
1098         mContentEditText.addTextChangedListener(this);
1099     }
1100 
1101     /**
1102      * Set the note title to be a larger size and bold style.
1103      *
1104      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1105      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1106      * spans are removed when {@link MetricAffectingSpan} is removed.
1107      */
1108     private void setTitleSpan(Editable editable) {
<abbr title="1109         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1109         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1110             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1111                 editable.removeSpan(span);
1112             }
1113         }
1114 
1115         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1116 
1117         if (newLinePosition == 0) {
1118             return;
1119         }
1120 
1121         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1122         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1122         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1123         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1123         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1124     }
1125 
1126     private void attemptAutoList(Editable editable) {
1127         int oldCursorPosition = mCurrentCursorPosition;
1128         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1129         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1130         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1131     }
1132 
1133     private void saveAndSyncNote() {
1134         if (mNote == null) {
1135             return;
1136         }
1137 
1138         AppLog.add(
1139             Type.ACTION,
1140             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1141                 &quot; / Title: &quot; + mNote.getTitle() +
1142                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1143                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1144         );
1145         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1146     }
1147 
1148     public boolean isPlaceholderVisible() {
1149         if (mPlaceholderView != null) {
1150             return mPlaceholderView.getVisibility() == View.VISIBLE;
1151         } else {
1152             return false;
1153         }
1154     }
1155 
1156     public void setPlaceholderVisible(boolean isVisible) {
1157         if (isVisible) {
1158             mNote = null;
1159             mContentEditText.setText(&quot;&quot;);
1160         }
1161 
1162         if (mPlaceholderView != null) {
1163             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1164         }
1165     }
1166 
1167     @Override
1168     public void onFocusChange(View v, boolean hasFocus) {
1169         if (!hasFocus) {
1170             String tags = getNoteTagsString().trim();
1171 
1172             if (mTagInput.getText().toString().trim().length() &gt; 0
1173                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1174                 onTagAdded(mTagInput.getText().toString());
1175             } else if (tags.length() &gt; 0) {
1176                 setChips(tags);
1177             }
1178         }
1179     }
1180 
1181     private Note getNote() {
1182         return mNote;
1183     }
1184 
1185     public void setNote(String noteID) {
1186         setNote(noteID, null);
1187     }
1188 
1189     private String getNoteContentString() {
1190         if (mContentEditText == null || mContentEditText.getText() == null) {
1191             return &quot;&quot;;
1192         } else {
1193             return mContentEditText.getText().toString();
1194         }
1195     }
1196 
1197     private String getNoteTagsString() {
1198         StringBuilder tags = new StringBuilder();
1199 
1200         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1201             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1202         }
1203 
1204         return tags.toString();
1205     }
1206 
1207     /**
1208      * Share bottom sheet callbacks
1209      */
1210 
1211     @Override
1212     public void onSharePublishClicked() {
1213         publishNote();
1214         if (mShareBottomSheet != null) {
1215             mShareBottomSheet.dismiss();
1216         }
1217     }
1218 
1219     @Override
1220     public void onShareUnpublishClicked() {
1221         unpublishNote();
1222         if (mShareBottomSheet != null) {
1223             mShareBottomSheet.dismiss();
1224         }
1225     }
1226 
1227     @Override
1228     public void onWordPressPostClicked() {
1229         if (mShareBottomSheet != null) {
1230             mShareBottomSheet.dismiss();
1231         }
1232 
1233         if (getFragmentManager() == null) {
1234             return;
1235         }
1236 
1237         FragmentTransaction ft = getFragmentManager().beginTransaction();
1238         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1239         if (prev != null) {
1240             ft.remove(prev);
1241         }
1242         ft.addToBackStack(null);
1243 
1244         // Create and show the dialog.
1245         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1246         wpDialogFragment.setNote(mNote);
1247         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1248     }
1249 
1250     @Override
1251     public void onShareCollaborateClicked() {
1252         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1253     }
1254 
1255     @Override
1256     public void onShareDismissed() {
1257 
1258     }
1259 
1260     /**
1261      * History bottom sheet listeners
1262      */
1263 
1264     @Override
1265     public void onHistoryCancelClicked() {
1266         mContentEditText.setText(mNote.getContent());
1267         if (mHistoryBottomSheet != null) {
1268             mHistoryBottomSheet.dismiss();
1269         }
1270     }
1271 
1272     @Override
1273     public void onHistoryRestoreClicked() {
1274         if (mHistoryBottomSheet != null) {
1275             mHistoryBottomSheet.dismiss();
1276         }
1277         saveAndSyncNote();
1278     }
1279 
1280     @Override
1281     public void onHistoryDismissed() {
1282         if (!mHistoryBottomSheet.didTapOnButton()) {
1283             mContentEditText.setText(mNote.getContent());
1284         }
1285 
1286         if (mHistoryTimeoutHandler != null) {
1287             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1288         }
1289     }
1290 
1291     @Override
1292     public void onHistoryUpdateNote(String content) {
1293         mContentEditText.setText(content);
1294     }
1295 
1296     private void saveNote() {
1297         try {
1298             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1299                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1299                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1300                 return;
1301             } else {
1302                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1303                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1304             }
1305 
1306             String content = mContentEditText.getPlainTextContent();
1307             String tagString = getNoteTagsString();
1308 
<abbr title="1309             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1309             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1310                 mNote.setContent(content);
1311                 mNote.setTagString(tagString);
1312                 mNote.setModificationDate(Calendar.getInstance());
1313                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1314                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1315                 mNote.save();
1316 
1317                 AnalyticsTracker.track(
1318                     EDITOR_NOTE_EDITED,
1319                     CATEGORY_NOTE,
1320                     &quot;editor_save&quot;
1321                 );
1322 
1323                 AppLog.add(
1324                     Type.SYNC,
1325                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1326                         &quot; / Title: &quot; + mNote.getTitle() +
1327                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1328                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1329                 );
1330             }
1331         } catch (BucketObjectMissingException exception) {
1332             exception.printStackTrace();
1333         }
1334     }
1335 
1336     // Checks if cursor is at a URL when the selection changes
1337     // If it is a URL, show the contextual action bar
1338     @Override
1339     public void onSelectionChanged(int selStart, int selEnd) {
1340         mCurrentCursorPosition = selEnd;
1341 
1342         if (selStart == selEnd) {
1343             Editable noteContent = mContentEditText.getText();
1344 
1345             if (noteContent == null) {
1346                 return;
1347             }
1348 
1349             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1350 
1351             if (urlSpans.length &gt; 0) {
1352                 URLSpan urlSpan = urlSpans[0];
1353                 mLinkUrl = urlSpan.getURL();
<abbr title="1354                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1354                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1355 
1356                 if (mActionMode != null) {
1357                     mActionMode.setSubtitle(mLinkText);
1358                     updateMenuItems();
1359                     return;
1360                 }
1361 
1362                 // Show the Contextual Action Bar
1363                 if (getActivity() != null) {
<abbr title="1364                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1364                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1365 
1366                     if (mActionMode != null) {
1367                         mActionMode.setSubtitle(mLinkText);
1368                     }
1369 
1370                     updateMenuItems();
1371                 }
1372             } else if (mActionMode != null) {
1373                 mActionMode.finish();
1374                 mActionMode = null;
1375             }
1376         } else if (mActionMode != null) {
1377             mActionMode.finish();
1378             mActionMode = null;
1379         }
1380     }
1381 
1382     private void updateMenuItems() {
1383         mCopyMenuItem.setIcon(mCopyIcon);
1384         mShareMenuItem.setIcon(mShareIcon);
1385 
1386         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1387             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1388                 mViewLinkMenuItem.setIcon(mCallIcon);
1389                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1390             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1391                 mViewLinkMenuItem.setIcon(mEmailIcon);
1392                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1393             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1394                 mViewLinkMenuItem.setIcon(mMapIcon);
1395                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1396             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1397                 mViewLinkMenuItem.setIcon(mLinkIcon);
1398                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1399             } else {
1400                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1401                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1402             }
1403         }
1404     }
1405 
1406     private void setPublishedNote(boolean isPublished) {
1407         if (mNote != null) {
1408             mNote.setPublished(isPublished);
1409             mNote.save();
1410 
1411             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1412             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1413 
1414             AnalyticsTracker.track(
1415                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1416                 CATEGORY_NOTE,
1417                 &quot;publish_note_button&quot;
1418             );
1419         }
1420     }
1421 
1422     private void updatePublishedState(boolean isSuccess) {
1423         if (mPublishingSnackbar == null) {
1424             return;
1425         }
1426 
1427         mPublishingSnackbar.dismiss();
1428         mPublishingSnackbar = null;
1429 
1430         if (isSuccess &amp;&amp; isAdded()) {
1431             if (mNote.isPublished()) {
1432                 if (mHideActionOnSuccess) {
1433                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1434                 } else {
1435                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1436                         .setAction(
1437                             R.string.undo,
1438                             new View.OnClickListener() {
1439                                 @Override
1440                                 public void onClick(View v) {
1441                                     mHideActionOnSuccess = true;
1442                                     unpublishNote();
1443                                 }
1444                             }
1445                         )
1446                         .show();
1447                 }
1448             } else {
1449                 if (mHideActionOnSuccess) {
1450                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1451                 } else {
1452                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1453                         .setAction(
1454                             R.string.undo,
1455                             new View.OnClickListener() {
1456                                 @Override
1457                                 public void onClick(View v) {
1458                                     mHideActionOnSuccess = true;
1459                                     publishNote();
1460                                 }
1461                             }
1462                         )
1463                         .show();
1464                 }
1465             }
1466         } else {
1467             if (mNote.isPublished()) {
1468                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1469                     .setAction(
1470                         R.string.retry,
1471                         new View.OnClickListener() {
1472                             @Override
1473                             public void onClick(View v) {
1474                                 mHideActionOnSuccess = true;
1475                                 unpublishNote();
1476                             }
1477                         }
1478                     )
1479                     .show();
1480             } else {
1481                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1482                     .setAction(
1483                         R.string.retry,
1484                         new View.OnClickListener() {
1485                             @Override
1486                             public void onClick(View v) {
1487                                 mHideActionOnSuccess = true;
1488                                 publishNote();
1489                             }
1490                         }
1491                     )
1492                     .show();
1493             }
1494         }
1495 
1496         mHideActionOnSuccess = false;
1497         requireActivity().invalidateOptionsMenu();
1498     }
1499 
1500     private void publishNote() {
1501         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1502             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1503             return;
1504         }
1505 
1506         if (isAdded()) {
<abbr title="1507             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1507             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1508             mPublishingSnackbar.show();
1509         }
1510 
1511         setPublishedNote(true);
1512     }
1513 
1514     private void unpublishNote() {
1515         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1516             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1517             return;
1518         }
1519 
1520         if (isAdded()) {
<abbr title="1521             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1521             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1522             mPublishingSnackbar.show();
1523         }
1524 
1525         setPublishedNote(false);
1526     }
1527 
1528     private void showShare(String text) {
1529         startActivity(
1530             ShareCompat.IntentBuilder.from(requireActivity())
1531                 .setText(text)
1532                 .setType(&quot;text/plain&quot;)
1533                 .createChooserIntent()
1534         );
1535     }
1536     private void showShareSheet() {
1537         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1538             mShareBottomSheet.show(requireFragmentManager(), mNote);
1539         }
1540     }
1541 
1542     private void showInfoSheet() {
1543         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1544             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1545         }
1546     }
1547 
1548     private void showHistorySheet() {
1549         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1550             // Request revisions for the current note
<abbr title="1551             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1551             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1552             saveNote();
1553 
1554             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1555         }
1556     }
1557 
1558     @Override
1559     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1560     }
1561 
1562     @Override
<abbr title="1563     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1563     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1564         if (changeType == Bucket.ChangeType.MODIFY) {
1565             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1566                 try {
1567                     final Note updatedNote = noteBucket.get(key);
1568 
1569                     if (getActivity() != null) {
1570                         getActivity().runOnUiThread(new Runnable() {
1571                             @Override
1572                             public void run() {
1573                                 if (mPublishTimeoutHandler != null) {
1574                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1575                                 }
1576 
1577                                 updateNote(updatedNote);
1578                                 updatePublishedState(true);
1579                             }
1580                         });
1581                     }
1582                 } catch (BucketObjectMissingException e) {
1583                     e.printStackTrace();
1584                 }
1585             }
1586         }
1587     }
1588 
1589     @Override
1590     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1591         if (mIsPaused) {
1592             mNotesBucket.removeListener(this);
1593             AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
1594         }
1595 
1596         AppLog.add(
1597             Type.SYNC,
1598             &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1599                 &quot; / Title: &quot; + note.getTitle() +
1600                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1601                 &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1602         );
1603     }
1604 
1605     @Override
1606     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1607         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1608         if (mIsLoadingNote)
1609             return;
1610 
1611         Note openNote = getNote();
1612         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1613             return;
1614 
1615         note.setContent(mContentEditText.getPlainTextContent());
1616     }
1617 
1618     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1619         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1620 
1621         LoadNoteTask(NoteEditorFragment fragment) {
1622             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1623         }
1624 
1625         @Override
1626         protected void onPreExecute() {
1627             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1628 
1629             if (fragment != null) {
1630                 fragment.mContentEditText.removeTextChangedListener(fragment);
1631                 fragment.mIsLoadingNote = true;
1632             }
1633         }
1634 
1635         @Override
1636         protected Void doInBackground(String... args) {
1637             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1638 
1639             if (fragment == null || fragment.getActivity() == null) {
1640                 return null;
1641             }
1642 
1643             String noteID = args[0];
1644             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1645             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1646 
1647             try {
1648                 fragment.mNote = notesBucket.get(noteID);
1649 
1650                 // Set the current note in NotesActivity when on a tablet
1651                 if (fragment.getActivity() instanceof NotesActivity) {
1652                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1653                 }
1654 
1655                 // Set markdown and preview flags for current note
1656                 if (fragment.mNote != null) {
1657                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1658                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1659                     AppLog.add(
1660                         Type.SYNC,
1661                         &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1662                             &quot; / Title: &quot; + fragment.mNote.getTitle() +
<abbr title="1663                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +">1663                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent())ðŸ”µ</abbr>
1664                             &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1665                     );
1666                 }
1667             } catch (BucketObjectMissingException e) {
1668                 // See if the note is in the object store
1669                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1670 
1671                 while (notesCursor.moveToNext()) {
1672                     Note currentNote = notesCursor.getObject();
1673 
1674                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1675                         fragment.mNote = currentNote;
1676                         return null;
1677                     }
1678                 }
1679             }
1680 
1681             return null;
1682         }
1683 
1684         @Override
1685         protected void onPostExecute(Void nada) {
1686             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1687             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1687             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1688                 return;
1689             }
1690 
1691             fragment.refreshContent(false);
1692 
1693             if (fragment.mMatchOffsets != null) {
<abbr title="1694                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1694                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1695                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1696                 fragment.mShouldScrollToSearchMatch = true;
1697             }
1698 
1699             fragment.mContentEditText.addTextChangedListener(fragment);
1700 
1701             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1702                 // Show soft keyboard
1703                 fragment.mContentEditText.requestFocus();
1704 
1705                 new Handler().postDelayed(new Runnable() {
1706                     @Override
1707                     public void run() {
1708                         if (fragment.getActivity() == null) {
1709                             return;
1710                         }
1711 
<abbr title="1712                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1712                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1713 
1714                         if (inputMethodManager != null) {
1715                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1716                         }
1717                     }
1718                 }, 100);
1719             } else if (fragment.mNote != null) {
1720                 // If we have a valid note, hide the placeholder
1721                 fragment.setPlaceholderVisible(false);
1722             }
1723 
1724             fragment.updateMarkdownView();
1725             fragment.requireActivity().invalidateOptionsMenu();
1726             fragment.linkifyEditorContent();
1727             fragment.mIsLoadingNote = false;
1728         }
1729     }
1730 
1731     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1732         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1733 
1734         SaveNoteTask(NoteEditorFragment fragment) {
1735             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1736         }
1737 
1738         @Override
1739         protected Void doInBackground(Void... args) {
1740             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1741 
1742             if (fragment != null) {
1743                 fragment.saveNote();
1744             }
1745 
1746             return null;
1747         }
1748 
1749         @Override
1750         protected void onPostExecute(Void nada) {
1751             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1752 
<abbr title="1753             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1753             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1754                 // Update links
1755                 fragment.linkifyEditorContent();
1756                 fragment.updateMarkdownView();
1757             }
1758         }
1759     }
1760 
1761     private void linkifyEditorContent() {
1762         if (getActivity() == null || getActivity().isFinishing()) {
1763             return;
1764         }
1765 
1766         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1767             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1768         }
1769     }
1770 
1771     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1772     private void updateMarkdownView() {
1773         if (!mIsMarkdownEnabled) {
1774             return;
1775         }
1776 
1777         Activity activity = getActivity();
1778         if (activity instanceof NotesActivity) {
1779             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1780             loadMarkdownData();
1781         } else {
1782             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1783             if (mNoteMarkdownFragment == null) {
1784                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1785                         .getNoteMarkdownFragment();
1786                 ((NoteEditorActivity) requireActivity()).showTabs();
1787             }
1788             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1789             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1790         }
1791     }
1792 
1793     private ColorStateList getChipBackgroundColor() {
1794         int[][] states = new int[][] {
1795             new int[] { android.R.attr.state_checked}, // checked
1796             new int[] {-android.R.attr.state_checked}  // unchecked
1797         };
1798 
1799         int[] colors = new int[] {
1800             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1801             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1802         };
1803 
1804         return new ColorStateList(states, colors);
1805     }
1806 
1807     private void setChips(CharSequence text) {
1808         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1809         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1810         mTagChips.setSingleSelection(true);
1811         mTagChips.removeAllViews();
1812         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1813         tags.setString(text.toString());
1814 
1815         for (String tag : tags) {
1816             final Chip chip = new Chip(requireContext());
1817             chip.setText(tag);
1818             chip.setCheckable(true);
1819             chip.setCheckedIcon(null);
1820             chip.setChipBackgroundColor(getChipBackgroundColor());
1821             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1822             chip.setStateListAnimator(null);
1823             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1824                 @Override
1825                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1826                     chip.setCloseIconVisible(isChecked);
1827                 }
1828             });
1829             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1830                 @Override
1831                 public void onClick(View view) {
1832                     mTagChips.removeView(view);
1833                     updateTags();
1834                     AnalyticsTracker.track(
1835                         EDITOR_TAG_REMOVED,
1836                         CATEGORY_NOTE,
1837                         &quot;tag_removed_from_note&quot;
1838                     );
1839                 }
1840             });
1841             mTagChips.addView(chip);
1842         }
1843     }
1844 
1845     private void updateTags() {
1846         if (mNote == null) {
1847             return;
1848         }
1849 
1850         mNote.setTagString(getNoteTagsString());
1851         mNote.setModificationDate(Calendar.getInstance());
1852         updateTagList();
1853         mNote.save();
1854     }
1855 }</pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewStub;
  31 import android.view.ViewTreeObserver;
  32 import android.view.inputmethod.InputMethodManager;
  33 import android.webkit.WebResourceRequest;
  34 import android.webkit.WebView;
  35 import android.webkit.WebViewClient;
  36 import android.widget.CompoundButton;
  37 import android.widget.CursorAdapter;
  38 import android.widget.LinearLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 
  42 import androidx.annotation.NonNull;
  43 import androidx.appcompat.app.AppCompatActivity;
  44 import androidx.appcompat.view.ActionMode;
  45 import androidx.core.app.ShareCompat;
  46 import androidx.core.view.MenuCompat;
  47 import androidx.core.widget.NestedScrollView;
  48 import androidx.fragment.app.Fragment;
  49 import androidx.fragment.app.FragmentTransaction;
  50 import androidx.preference.PreferenceManager;
  51 
  52 import com.automattic.simplenote.analytics.AnalyticsTracker;
  53 import com.automattic.simplenote.models.Note;
  54 import com.automattic.simplenote.models.Tag;
  55 import com.automattic.simplenote.utils.AppLog;
  56 import com.automattic.simplenote.utils.AppLog.Type;
  57 import com.automattic.simplenote.utils.AutoBullet;
  58 import com.automattic.simplenote.utils.BrowserUtils;
  59 import com.automattic.simplenote.utils.ContextUtils;
  60 import com.automattic.simplenote.utils.DisplayUtils;
  61 import com.automattic.simplenote.utils.DrawableUtils;
  62 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63 import com.automattic.simplenote.utils.NetworkUtils;
  64 import com.automattic.simplenote.utils.NoteUtils;
  65 import com.automattic.simplenote.utils.PrefUtils;
  66 import com.automattic.simplenote.utils.SimplenoteLinkify;
  67 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68 import com.automattic.simplenote.utils.SpaceTokenizer;
  69 import com.automattic.simplenote.utils.TagUtils;
  70 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72 import com.automattic.simplenote.utils.TextHighlighter;
  73 import com.automattic.simplenote.utils.ThemeUtils;
  74 import com.automattic.simplenote.utils.WidgetUtils;
  75 import com.automattic.simplenote.widgets.SimplenoteEditText;
  76 import com.google.android.material.chip.Chip;
  77 import com.google.android.material.chip.ChipGroup;
  78 import com.google.android.material.snackbar.Snackbar;
  79 import com.simperium.client.Bucket;
  80 import com.simperium.client.BucketObjectMissingException;
  81 import com.simperium.client.Query;
  82 
  83 import java.lang.ref.WeakReference;
  84 import java.util.Calendar;
  85 
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  95 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  96 
  97 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98         TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99         SimplenoteEditText.OnSelectionChangedListener,
 100         ShareBottomSheetDialog.ShareSheetListener,
 101         HistoryBottomSheetDialog.HistorySheetListener,
 102         SimplenoteEditText.OnCheckboxToggledListener {
 103 
 104     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110 
 111     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 112     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 113     private static final int MAX_REVISIONS = 30;
 114     private static final int PUBLISH_TIMEOUT = 20000;
 115     private static final int HISTORY_TIMEOUT = 10000;
 116     private Note mNote;
 117     private final Runnable mAutoSaveRunnable = new Runnable() {
 118         @Override
 119         public void run() {
 120             saveAndSyncNote();
 121         }
 122     };
 123     private Bucket&lt;Note&gt; mNotesBucket;
 124     private View mRootView;
 125     private View mTagPadding;
 126     private SimplenoteEditText mContentEditText;
 127     private ChipGroup mTagChips;
 128     private TagsMultiAutoCompleteTextView mTagInput;
 129     private Handler mAutoSaveHandler;
 130     private Handler mPublishTimeoutHandler;
 131     private Handler mHistoryTimeoutHandler;
 132     private LinearLayout mPlaceholderView;
 133     private CursorAdapter mLinkAutocompleteAdapter;
 134     private CursorAdapter mTagAutocompleteAdapter;
 135     private boolean mIsLoadingNote;
 136     private boolean mIsMarkdownEnabled;
 137     private boolean mIsPreviewEnabled;
 138     private boolean mShouldScrollToSearchMatch;
 139     private ActionMode mActionMode;
 140     private MenuItem mChecklistMenuItem;
 141     private MenuItem mCopyMenuItem;
 142     private MenuItem mInformationMenuItem;
 143     private MenuItem mShareMenuItem;
 144     private MenuItem mViewLinkMenuItem;
 145     private String mLinkUrl;
 146     private String mLinkText;
 147     private MatchOffsetHighlighter mHighlighter;
 148     private Drawable mBrowserIcon;
 149     private Drawable mCallIcon;
 150     private Drawable mCopyIcon;
 151     private Drawable mEmailIcon;
 152     private Drawable mLinkIcon;
 153     private Drawable mMapIcon;
 154     private Drawable mShareIcon;
 155     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 156     private String mMatchOffsets;
 157     private int mCurrentCursorPosition;
 158     private HistoryBottomSheetDialog mHistoryBottomSheet;
 159     private LinearLayout mError;
 160     private NoteMarkdownFragment mNoteMarkdownFragment;
 161     private String mCss;
 162     private WebView mMarkdown;
 163     private boolean mIsPaused;
 164     private boolean mIsFromWidget;
 165 
 166     // Hides the history bottom sheet if no revisions are loaded
 167     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 168         @Override
 169         public void run() {
 170             if (!isAdded()) {
 171                 return;
 172             }
 173 
 174             requireActivity().runOnUiThread(new Runnable() {
 175                 @Override
 176                 public void run() {
<abbr title=" 177                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 177                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 178                         mHistoryBottomSheet.dismiss();
 179                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 180                     }
 181                 }
 182             });
 183         }
 184     };
 185     private InfoBottomSheetDialog mInfoBottomSheet;
 186     private ShareBottomSheetDialog mShareBottomSheet;
 187     // Contextual action bar for dealing with links
 188     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 189         // Called when the action mode is created; startActionMode() was called
 190         @Override
 191         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 192             // Inflate a menu resource providing context menu items
 193             MenuInflater inflater = mode.getMenuInflater();
 194 
 195             if (inflater != null) {
 196                 inflater.inflate(R.menu.view_link, menu);
 197                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 198                 mShareMenuItem = menu.findItem(R.id.menu_share);
 199                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 200                 mode.setTitle(getString(R.string.link));
 201                 mode.setTitleOptionalHint(false);
 202 
 203                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 204             }
 205 
<abbr title=" 206             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 206             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 207             return true;
 208         }
 209 
 210         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 211         // may be called multiple times if the mode is invalidated.
 212         @Override
 213         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 214             return false; // Return false if nothing is done
 215         }
 216 
 217         // Called when the user selects a contextual menu item
 218         @Override
 219         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 220             switch (item.getItemId()) {
 221                 case R.id.menu_view_link:
 222                     if (mLinkText != null) {
 223                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 224                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 224                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 225                         } else {
 226                             try {
 227                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 228                             } catch (Exception e) {
 229                                 e.printStackTrace();
 230                             }
 231                         }
 232 
 233                         mode.finish(); // Action picked, so close the CAB
 234                     }
 235 
 236                     return true;
 237                 case R.id.menu_copy:
 238                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 239                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 240                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 241                         } else {
<abbr title=" 242                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 242                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 243                         }
 244 
 245                         mode.finish();
 246                     }
 247 
 248                     return true;
 249                 case R.id.menu_share:
 250                     if (mLinkText != null) {
 251                         showShare(mLinkText);
 252                         mode.finish();
 253                     }
 254 
 255                     return true;
 256                 default:
 257                     return false;
 258             }
 259         }
 260 
 261         // Called when the user exits the action mode
 262         @Override
 263         public void onDestroyActionMode(ActionMode mode) {
 264             if (mActionMode != null) {
 265                 mActionMode.setSubtitle(&quot;&quot;);
 266                 mActionMode = null;
 267             }
 268 
 269             new Handler().postDelayed(
 270                 new Runnable() {
 271                     @Override
 272                     public void run() {
<abbr title=" 273                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 273                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 274                     }
 275                 },
 276                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 277             );
 278         }
 279     };
 280     private Snackbar mPublishingSnackbar;
 281     private boolean mHideActionOnSuccess;
 282     // Resets note publish status if Simperium never returned the new publish status
 283     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 284         @Override
 285         public void run() {
 286             if (!isAdded()) return;
 287 
 288             requireActivity().runOnUiThread(new Runnable() {
 289                 @Override
 290                 public void run() {
 291 
 292                     mNote.setPublished(!mNote.isPublished());
 293                     mNote.save();
 294 
 295                     updatePublishedState(false);
 296                 }
 297             });
 298         }
 299     };
 300 
 301     /**
 302      * Mandatory empty constructor for the fragment manager to instantiate the
 303      * fragment (e.g. upon screen orientation changes).
 304      */
 305     public NoteEditorFragment() {
 306     }
 307 
 308     @Override
 309     public void onCreate(Bundle savedInstanceState) {
 310         super.onCreate(savedInstanceState);
 311         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 312         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 313         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 314         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 315         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 316 
 317         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 318         mNotesBucket = currentApp.getNotesBucket();
 319 
<abbr title=" 320         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 320         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 321         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 321         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 322         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 322         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 323         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 323         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 324         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 324         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 325         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 325         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 326         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 326         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 327 
 328         mAutoSaveHandler = new Handler();
 329         mPublishTimeoutHandler = new Handler();
 330         mHistoryTimeoutHandler = new Handler();
 331 
 332         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 333                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 333                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 334         mTagAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 335             @Override
 336             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 337                 Activity activity = (Activity) context;
 338                 if (activity == null) return null;
 339                 return activity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 340             }
 341 
 342             @Override
 343             public void bindView(View view, Context context, Cursor cursor) {
 344                 TextView textView = (TextView) view;
 345                 textView.setText(convertToString(cursor));
 346             }
 347 
 348             @Override
 349             public CharSequence convertToString(Cursor cursor) {
 350                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 351             }
 352 
 353             @Override
 354             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 355                 Activity activity = getActivity();
 356                 if (activity == null) return null;
 357                 Simplenote application = (Simplenote) activity.getApplication();
 358                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 359                 // make the tag name available to the cursor
 360                 query.include(Tag.NAME_PROPERTY);
 361                 // sort the tags by their names
 362                 query.order(Tag.NAME_PROPERTY);
 363                 // if there&#x27;s a filter string find only matching tag names
 364                 if (filter != null)
<abbr title=" 365                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 365                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 366                 return query.execute();
 367             }
 368         };
 369 
 370         mLinkAutocompleteAdapter = new CursorAdapter(getContext(), null, 0x0) {
 371             private Activity mActivity = requireActivity();
 372 
 373             @Override
 374             public void bindView(View view, Context context, Cursor cursor) {
 375                 ((TextView) view).setText(convertToString(cursor));
 376             }
 377 
 378             @Override
 379             public CharSequence convertToString(Cursor cursor) {
 380                 return cursor.getString(cursor.getColumnIndex(Note.TITLE_INDEX_NAME));
 381             }
 382 
 383             @Override
 384             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 385                 return mActivity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 386             }
 387 
 388             @Override
 389             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 390                 if (filter == null) {
 391                     return null;
 392                 }
 393 
 394                 Simplenote application = (Simplenote) mActivity.getApplication();
 395                 Query&lt;Note&gt; query = application.getNotesBucket().query();
 396                 query.include(Note.PINNED_INDEX_NAME);
 397                 query.include(Note.TITLE_INDEX_NAME);
<abbr title=" 398                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filter));"> 398                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filðŸ”µ</abbr>
 399                 PrefUtils.sortNoteQuery(query, requireContext(), true);
 400                 Cursor cursor = query.execute();
 401 
<abbr title=" 402                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * 48);"> 402                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * ðŸ”µ</abbr>
 403                 final int heightDisplay = DisplayUtils.getDisplayPixelSize(requireContext()).y;
 404                 final int heightDropdown = Math.min(heightDisplay / 4, heightAutocomplete);
 405 
 406                 mActivity.runOnUiThread(
 407                     new Runnable() {
 408                         @Override
 409                         public void run() {
 410                             mContentEditText.setDropDownHeight(heightDropdown);
 411                         }
 412                     }
 413                 );
 414                 return cursor;
 415             }
 416         };
 417 
 418         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 419     }
 420 
 421     @Override
<abbr title=" 422     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {"> 422     public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceSðŸ”µ</abbr>
 423         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 424         mContentEditText = mRootView.findViewById(R.id.note_content);
 425         mContentEditText.addOnSelectionChangedListener(this);
 426         mContentEditText.setOnCheckboxToggledListener(this);
 427         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 428         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 429         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 429         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 430         mContentEditText.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 431         mContentEditText.setAdapter(mLinkAutocompleteAdapter);
 432         mTagInput = mRootView.findViewById(R.id.tag_input);
 433         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 434         mTagInput.setTokenizer(new SpaceTokenizer());
 435         mTagInput.setAdapter(mTagAutocompleteAdapter);
 436         mTagInput.setOnFocusChangeListener(this);
 437         mTagChips = mRootView.findViewById(R.id.tag_chips);
 438         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 439         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 440         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 441 
 442         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 443             mPlaceholderView.setVisibility(View.VISIBLE);
 444             requireActivity().invalidateOptionsMenu();
 445 
 446             if (BrowserUtils.isWebViewInstalled(requireContext())) {
 447                 ((ViewStub) mRootView.findViewById(R.id.stub_webview)).inflate();
 448             mMarkdown = mRootView.findViewById(R.id.markdown);
 449             mMarkdown.setWebViewClient(
 450                 new WebViewClient() {
 451                     @Override
 452                     public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){
 453                         String url = request.getUrl().toString();
 454 
 455                         if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){
<abbr title=" 456                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 456                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREðŸ”µ</abbr>
 457                         } else {
 458                             BrowserUtils.launchBrowserOrShowError(requireContext(), url);
 459                         }
 460 
 461                         return true;
 462                     }
 463                 }
 464             );
 465 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 466             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 466             mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()ðŸ”µ</abbr></span>
 467 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468             mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469                 ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470                 : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473         Bundle arguments = getArguments();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476             // Load note if we were passed a note Id</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477             String key = arguments.getString(ARG_ITEM_ID);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485             if (mIsFromWidget) {</span>
 486 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 487                 mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 488                     ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 489                     : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 490             } else {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 491                 ((ViewStub) mRootView.findViewById(R.id.stub_error)).inflate();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 492                 mError = mRootView.findViewById(R.id.error);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 493                 mRootView.findViewById(R.id.button).setOnClickListener(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 494                     new View.OnClickListener() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 495                         @Override</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 496                         public void onClick(View view) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 497                             BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_VIEW);"> 497                             BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 498                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 499                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 500                 );</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 501             }</span>
 502 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 503         }
 504 
 505         Bundle arguments = getArguments();
 506 
 507         if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 508             // Load note if we were passed a note Id
 509             String key = arguments.getString(ARG_ITEM_ID);
 510 
 511             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 512                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 513             }
 514 
 515             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 516 
 517             if (mIsFromWidget) {
 518                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 519             } else {
 520                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 521             }
 522 
 523             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 524         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 525             // Restore selected note when in dual pane mode
 526             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 527 
 528             if (noteId != null) {
 529                 setNote(noteId);
 530             }
 531         }
 532 
 533         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 534         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 535             @Override
 536             public void onGlobalLayout() {
 537                 // If a note was loaded with search matches, scroll to the first match in the editor
 538                 if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 539                     if (!isAdded()) {
 540                         return;
 541                     }
 542 
 543                     // Get the character location of the first search match
 544                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 545                             mContentEditText.getText(),
 546                             mMatchOffsets
 547                     );
 548                     if (matchLocation == 0) {
 549                         return;
 550                     }
 551 
 552                     // Calculate how far to scroll to bring the match into view
 553                     Layout layout = mContentEditText.getLayout();
 554                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 555                     ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 556                     mShouldScrollToSearchMatch = false;
 557                 }
 558             }
 559         });
 560         setHasOptionsMenu(true);
 561         return mRootView;
 562     }
 563 
 564     public void scrollToMatch(int location) {
 565         if (isAdded()) {
 566             // Calculate how far to scroll to bring the match into view
 567             Layout layout = mContentEditText.getLayout();
 568             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 569             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 570         }
 571     }
 572 
 573     @Override
 574     public void onResume() {
 575         super.onResume();
 576         checkWebView();
 577         mIsPaused = false;
 578         mNotesBucket.addListener(this);
 579         AppLog.add(Type.SYNC, &quot;Added note bucket listener (NoteEditorFragment)&quot;);
 580         mTagInput.setOnTagAddedListener(this);
 581 
 582         if (mContentEditText != null) {
<abbr title=" 583             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 583             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 584 
 585             if (mContentEditText.hasFocus()) {
 586                 showSoftKeyboard();
 587             }
 588         }
 589     }
 590 
 591     private void checkWebView() {
 592         // When a WebView is installed and mMarkdown is null on a large landscape device, a WebView
 593         // was not installed when the fragment was created.  So, recreate the activity to refresh
 594         // the editor view.
 595         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown == null &amp;&amp;
 596             DisplayUtils.isLargeScreenLandscape(requireContext())) {
 597             requireActivity().recreate();
 598         }
 599     }
 600 
 601     private void showSoftKeyboard() {
 602         new Handler().postDelayed(new Runnable() {
 603             @Override
 604             public void run() {
 605                 if (getActivity() == null) {
 606                     return;
 607                 }
 608 
<abbr title=" 609                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 609                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 610                 if (inputMethodManager != null) {
 611                     inputMethodManager.showSoftInput(mContentEditText, 0);
 612                 }
 613             }
 614         }, 100);
 615     }
 616 
 617     @Override
 618     public void onPause() {
 619         super.onPause();  // Always call the superclass method first
 620         mIsPaused = true;
 621 
 622         // Hide soft keyboard if it is showing...
 623         DisplayUtils.hideKeyboard(mContentEditText);
 624 
 625         mTagInput.setOnTagAddedListener(null);
 626 
 627         if (mAutoSaveHandler != null) {
 628             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 629             mAutoSaveHandler.post(mAutoSaveRunnable);
 630         }
 631 
 632         if (mPublishTimeoutHandler != null) {
 633             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 634         }
 635 
 636         if (mHistoryTimeoutHandler != null) {
 637             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 638         }
 639 
 640         mHighlighter.stop();
 641         saveNote();
 642         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 643     }
 644 
 645     @Override
 646     public void onDestroy() {
 647         super.onDestroy();
 648         mNotesBucket.removeListener(this);
 649         AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
 650         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 651     }
 652 
 653     @Override
 654     public void onSaveInstanceState(@NonNull Bundle outState) {
 655         super.onSaveInstanceState(outState);
 656 
 657         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 658             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 659         }
 660     }
 661 
 662     @Override
 663     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 664         super.onCreateOptionsMenu(menu, inflater);
 665 
<abbr title=" 666         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 666         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 667             return;
 668         }
 669 
 670         inflater.inflate(R.menu.note_editor, menu);
 671         MenuCompat.setGroupDividerEnabled(menu, true);
 672     }
 673 
 674     @Override
 675     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 676         switch (item.getItemId()) {
 677             case R.id.menu_checklist:
 678                 insertChecklist();
 679                 return true;
 680             case R.id.menu_copy:
 681                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 682                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 683                 } else {
 684                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 685                 }
 686 
 687                 return true;
 688             case R.id.menu_copy_internal:
<abbr title=" 689                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 689                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 690                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 691                 } else {
 692                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 693                 }
 694 
 695                 return true;
 696             case R.id.menu_history:
 697                 showHistory();
 698                 return true;
 699             case R.id.menu_info:
 700                 showInfo();
 701                 return true;
 702             case R.id.menu_markdown:
 703                 setMarkdown(!item.isChecked());
 704                 return true;
 705             case R.id.menu_pin:
 706                 NoteUtils.setNotePin(mNote, !item.isChecked());
 707                 requireActivity().invalidateOptionsMenu();
 708                 return true;
 709             case R.id.menu_publish:
 710                 if (item.isChecked()) {
 711                     unpublishNote();
 712                 } else {
 713                     publishNote();
 714                 }
 715 
 716                 return true;
 717             case R.id.menu_share:
 718                 shareNote();
 719                 return true;
 720             case R.id.menu_trash:
 721                 if (!isAdded()) {
 722                     return false;
 723                 }
 724 
 725                 deleteNote();
 726                 return true;
 727             case android.R.id.home:
 728                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 729                 if (!isAdded()) {
 730                     return false;
 731                 }
 732 
 733                 requireActivity().finish();
 734                 return true;
 735             default:
 736                 return super.onOptionsItemSelected(item);
 737         }
 738     }
 739 
 740     @Override
 741     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 742         if (mNote != null) {
 743             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 744             MenuItem shareItem = menu.findItem(R.id.menu_share);
 745             MenuItem historyItem = menu.findItem(R.id.menu_history);
 746             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 747             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 748             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 749             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 750             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 751             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 752 
 753             pinItem.setChecked(mNote.isPinned());
 754             publishItem.setChecked(mNote.isPublished());
 755             markdownItem.setChecked(mNote.isMarkdownEnabled());
 756 
 757             // Disable actions when note is in Trash or markdown view is shown on large device.
 758             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 759                 pinItem.setEnabled(false);
 760                 shareItem.setEnabled(false);
 761                 historyItem.setEnabled(false);
 762                 publishItem.setEnabled(false);
 763                 copyLinkItem.setEnabled(false);
 764                 markdownItem.setEnabled(false);
 765                 mChecklistMenuItem.setEnabled(false);
 766                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 767             } else {
 768                 pinItem.setEnabled(true);
 769                 shareItem.setEnabled(true);
 770                 historyItem.setEnabled(true);
 771                 publishItem.setEnabled(true);
 772                 copyLinkItem.setEnabled(mNote.isPublished());
 773                 markdownItem.setEnabled(true);
 774                 mChecklistMenuItem.setEnabled(true);
 775                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 776             }
 777 
 778             if (mNote.isDeleted()) {
 779                 trashItem.setTitle(R.string.restore);
 780             } else {
 781                 trashItem.setTitle(R.string.trash);
 782             }
 783         }
 784 
 785         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 786         super.onPrepareOptionsMenu(menu);
 787     }
 788 
 789     public void insertChecklist() {
 790         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 791 
 792         try {
 793             mContentEditText.insertChecklist();
 794         } catch (Exception e) {
 795             e.printStackTrace();
 796             return;
 797         }
 798 
 799         AnalyticsTracker.track(
 800             EDITOR_CHECKLIST_INSERTED,
 801             CATEGORY_NOTE,
 802             &quot;toolbar_button&quot;
 803         );
 804     }
 805 
 806     @Override
 807     public void onCheckboxToggled() {
 808         // Save note (using delay) after toggling a checkbox
 809         if (mAutoSaveHandler != null) {
 810             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 811             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 812         }
 813     }
 814 
 815     private void deleteNote() {
 816         NoteUtils.deleteNote(mNote, getActivity());
 817         requireActivity().finish();
 818     }
 819 
 820     protected void clearMarkdown() {
 821         if (mMarkdown != null) {
 822         mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 823     }
 824     }
 825 
 826     protected void hideMarkdown() {
 827         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {
 828         mMarkdown.setVisibility(View.INVISIBLE);
 829         } else {
 830             mError.setVisibility(View.INVISIBLE);
 831         }
 832     }
 833 
 834     protected void showMarkdown() {
 835         loadMarkdownData();
 836 
 837         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {
 838         mMarkdown.setVisibility(View.VISIBLE);
 839         } else {
 840             mError.setVisibility(View.VISIBLE);
 841         }
 842 
 843         new Handler().postDelayed(
 844             new Runnable() {
 845                 @Override
 846                 public void run() {
 847                     requireActivity().invalidateOptionsMenu();
 848                 }
 849             },
 850             getResources().getInteger(R.integer.time_animation)
 851         );
 852     }
 853 
 854     public void shareNote() {
 855         if (mNote != null) {
 856             mContentEditText.clearFocus();
 857             showShareSheet();
 858             AnalyticsTracker.track(
 859                 EDITOR_NOTE_CONTENT_SHARED,
 860                 CATEGORY_NOTE,
 861                 &quot;action_bar_share_button&quot;
 862             );
 863         }
 864     }
 865 
 866     public void showHistory() {
 867         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 868             mContentEditText.clearFocus();
 869             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 870             showHistorySheet();
 871         } else {
 872             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 873         }
 874     }
 875 
 876     public void showInfo() {
 877         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 878 
 879         if (mNote != null) {
 880             mContentEditText.clearFocus();
 881             saveNote();
 882             showInfoSheet();
 883         }
 884     }
 885 
 886     private void setMarkdown(boolean isChecked) {
 887         mIsMarkdownEnabled = isChecked;
 888         showMarkdownActionOrTabs();
 889         saveNote();
 890 
 891         // Set preference so that next new note will have markdown enabled.
 892         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 893         SharedPreferences.Editor editor = prefs.edit();
 894         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 895         editor.apply();
 896     }
 897 
 898     private void setMarkdownEnabled(boolean enabled) {
 899         mIsMarkdownEnabled = enabled;
 900 
 901         if (mIsMarkdownEnabled) {
 902             loadMarkdownData();
 903         }
 904     }
 905 
 906     private void showMarkdownActionOrTabs() {
 907         Activity activity = getActivity();
 908 
 909         if (activity instanceof NoteEditorActivity) {
 910             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 911 
 912             if (mIsMarkdownEnabled) {
 913                 editorActivity.showTabs();
 914 
 915                 if (mNoteMarkdownFragment == null) {
 916                     // Get markdown fragment and update content
 917                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 918                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 919                 }
 920             } else {
 921                 editorActivity.hideTabs();
 922             }
 923         } else if (activity instanceof NotesActivity) {
 924             setMarkdownEnabled(mIsMarkdownEnabled);
 925             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 926         }
 927     }
 928 
 929     private void loadMarkdownData() {
 930         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 931                 mCss,
 932                 mContentEditText.getPreviewTextContent()
 933         );
 934 
 935         if (mMarkdown != null) {
 936         mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 937     }
 938     }
 939 
 940     public void setNote(String noteID, String matchOffsets) {
 941         if (mAutoSaveHandler != null) {
 942             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 943         }
 944 
 945         mPlaceholderView.setVisibility(View.GONE);
 946         mMatchOffsets = matchOffsets;
 947         saveNote();
 948         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 949     }
 950 
 951     private void updateNote(Note updatedNote) {
 952         // update note if network change arrived
 953         mNote = updatedNote;
 954         refreshContent(true);
 955     }
 956 
 957     private void refreshContent(boolean isNoteUpdate) {
 958         if (mNote != null) {
 959             // Restore the cursor position if possible.
<abbr title=" 960             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 960             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 961             mContentEditText.setText(mNote.getContent());
 962 
 963             if (isNoteUpdate) {
 964                 // Update markdown and preview flags from updated note.
 965                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 966                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 967 
 968                 // Show/Hide action/tabs based on markdown flag.
 969                 showMarkdownActionOrTabs();
 970 
 971                 // Save note so any local changes get synced.
 972                 mNote.save();
 973 
 974                 // Update current note object on large screen devices in landscape orientation.
 975                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 976                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 977                 }
 978 
 979                 // Update overflow popup menu.
 980                 requireActivity().invalidateOptionsMenu();
 981 
 982                 if (mContentEditText.hasFocus()
 983                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 984                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 985                     mContentEditText.setSelection(cursorPosition);
 986                 }
 987             }
 988 
 989             afterTextChanged(mContentEditText.getText());
 990             mContentEditText.processChecklists();
 991             updateTagList();
 992         }
 993     }
 994 
 995     private void updateTagList() {
 996         setChips(mNote.getTagString());
 997         mTagInput.setText(&quot;&quot;);
 998     }
 999 
1000     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
1001         // Ported from the iOS app :)
1002         // Cases:
1003         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
1004         // 1. Text was added after the cursor ==&gt; no change
1005         // 2. Text was added before the cursor ==&gt; location advances
1006         // 3. Text was removed after the cursor ==&gt; no change
1007         // 4. Text was removed before the cursor ==&gt; location retreats
1008         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
1009 
1010         cursorLocation = Math.max(cursorLocation, 0);
1011 
1012         int newCursorLocation = cursorLocation;
1013 
1014         int deltaLength = newText.length() - oldText.length();
1015 
1016         // Case 0
1017         if (newText.length() &lt; cursorLocation)
1018             return newText.length();
1019 
1020         boolean beforeCursorMatches = false;
1021         boolean afterCursorMatches = false;
1022 
1023         try {
<abbr title="1024             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));">1024             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title="1025             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));">1025             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
1026         } catch (Exception e) {
1027             e.printStackTrace();
1028         }
1029 
1030         // Cases 2 and 4
1031         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
1032             newCursorLocation += deltaLength;
1033 
1034         // Cases 1, 3 and 5 have no change
1035         return newCursorLocation;
1036     }
1037 
1038     @Override
1039     public void onTagAdded(String tag) {
1040         if (mNote == null || !isAdded()) {
1041             return;
1042         }
1043 
1044         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
1045             AnalyticsTracker.track(
1046                 EDITOR_TAG_ADDED,
1047                 CATEGORY_NOTE,
1048                 &quot;tag_added_to_note&quot;
1049             );
1050         }
1051 
1052         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
1053         mNote.setModificationDate(Calendar.getInstance());
1054         updateTagList();
1055         mNote.save();
1056     }
1057 
1058     @Override
1059     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
1060         // Unused
1061     }
1062 
1063     @Override
1064     public void afterTextChanged(Editable editable) {
1065         attemptAutoList(editable);
1066         setTitleSpan(editable);
1067         mContentEditText.fixLineSpacing();
1068     }
1069 
1070     @Override
1071     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1072         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1073         if (mAutoSaveHandler != null) {
1074             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1075             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1076         }
1077 
1078         // Remove search highlight spans when note content changes
1079         if (mMatchOffsets != null) {
1080             mMatchOffsets = null;
1081             mHighlighter.removeMatches();
1082         }
1083 
1084         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1085             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1086         }
1087 
1088         // Temporarily remove the text watcher as we process checklists to prevent callback looping
1089         mContentEditText.removeTextChangedListener(this);
1090         mContentEditText.processChecklists();
1091         mContentEditText.addTextChangedListener(this);
1092     }
1093 
1094     /**
1095      * Set the note title to be a larger size and bold style.
1096      *
1097      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1098      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1099      * spans are removed when {@link MetricAffectingSpan} is removed.
1100      */
1101     private void setTitleSpan(Editable editable) {
<abbr title="1102         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1102         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1103             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1104                 editable.removeSpan(span);
1105             }
1106         }
1107 
1108         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1109 
1110         if (newLinePosition == 0) {
1111             return;
1112         }
1113 
1114         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1115         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1115         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1116         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1116         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1117     }
1118 
1119     private void attemptAutoList(Editable editable) {
1120         int oldCursorPosition = mCurrentCursorPosition;
1121         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1122         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1123         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1124     }
1125 
1126     private void saveAndSyncNote() {
1127         if (mNote == null) {
1128             return;
1129         }
1130 
1131         AppLog.add(
1132             Type.ACTION,
1133             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1134                 &quot; / Title: &quot; + mNote.getTitle() +
1135                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1136                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1137         );
1138         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1139     }
1140 
1141     public boolean isPlaceholderVisible() {
1142         if (mPlaceholderView != null) {
1143             return mPlaceholderView.getVisibility() == View.VISIBLE;
1144         } else {
1145             return false;
1146         }
1147     }
1148 
1149     public void setPlaceholderVisible(boolean isVisible) {
1150         if (isVisible) {
1151             mNote = null;
1152             mContentEditText.setText(&quot;&quot;);
1153         }
1154 
1155         if (mPlaceholderView != null) {
1156             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1157         }
1158     }
1159 
1160     @Override
1161     public void onFocusChange(View v, boolean hasFocus) {
1162         if (!hasFocus) {
1163             String tags = getNoteTagsString().trim();
1164 
1165             if (mTagInput.getText().toString().trim().length() &gt; 0
1166                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1167                 onTagAdded(mTagInput.getText().toString());
1168             } else if (tags.length() &gt; 0) {
1169                 setChips(tags);
1170             }
1171         }
1172     }
1173 
1174     private Note getNote() {
1175         return mNote;
1176     }
1177 
1178     public void setNote(String noteID) {
1179         setNote(noteID, null);
1180     }
1181 
1182     private String getNoteContentString() {
1183         if (mContentEditText == null || mContentEditText.getText() == null) {
1184             return &quot;&quot;;
1185         } else {
1186             return mContentEditText.getText().toString();
1187         }
1188     }
1189 
1190     private String getNoteTagsString() {
1191         StringBuilder tags = new StringBuilder();
1192 
1193         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1194             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1195         }
1196 
1197         return tags.toString();
1198     }
1199 
1200     /**
1201      * Share bottom sheet callbacks
1202      */
1203 
1204     @Override
1205     public void onSharePublishClicked() {
1206         publishNote();
1207         if (mShareBottomSheet != null) {
1208             mShareBottomSheet.dismiss();
1209         }
1210     }
1211 
1212     @Override
1213     public void onShareUnpublishClicked() {
1214         unpublishNote();
1215         if (mShareBottomSheet != null) {
1216             mShareBottomSheet.dismiss();
1217         }
1218     }
1219 
1220     @Override
1221     public void onWordPressPostClicked() {
1222         if (mShareBottomSheet != null) {
1223             mShareBottomSheet.dismiss();
1224         }
1225 
1226         if (getFragmentManager() == null) {
1227             return;
1228         }
1229 
1230         FragmentTransaction ft = getFragmentManager().beginTransaction();
1231         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1232         if (prev != null) {
1233             ft.remove(prev);
1234         }
1235         ft.addToBackStack(null);
1236 
1237         // Create and show the dialog.
1238         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1239         wpDialogFragment.setNote(mNote);
1240         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1241     }
1242 
1243     @Override
1244     public void onShareCollaborateClicked() {
1245         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1246     }
1247 
1248     @Override
1249     public void onShareDismissed() {
1250 
1251     }
1252 
1253     /**
1254      * History bottom sheet listeners
1255      */
1256 
1257     @Override
1258     public void onHistoryCancelClicked() {
1259         mContentEditText.setText(mNote.getContent());
1260         if (mHistoryBottomSheet != null) {
1261             mHistoryBottomSheet.dismiss();
1262         }
1263     }
1264 
1265     @Override
1266     public void onHistoryRestoreClicked() {
1267         if (mHistoryBottomSheet != null) {
1268             mHistoryBottomSheet.dismiss();
1269         }
1270         saveAndSyncNote();
1271     }
1272 
1273     @Override
1274     public void onHistoryDismissed() {
1275         if (!mHistoryBottomSheet.didTapOnButton()) {
1276             mContentEditText.setText(mNote.getContent());
1277         }
1278 
1279         if (mHistoryTimeoutHandler != null) {
1280             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1281         }
1282     }
1283 
1284     @Override
1285     public void onHistoryUpdateNote(String content) {
1286         mContentEditText.setText(content);
1287     }
1288 
1289     private void saveNote() {
1290         try {
1291             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1292                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1292                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1293                 return;
1294             } else {
1295                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1296                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1297             }
1298 
1299             String content = mContentEditText.getPlainTextContent();
1300             String tagString = getNoteTagsString();
1301 
<abbr title="1302             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1302             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1303                 mNote.setContent(content);
1304                 mNote.setTagString(tagString);
1305                 mNote.setModificationDate(Calendar.getInstance());
1306                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1307                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1308                 mNote.save();
1309 
1310                 AnalyticsTracker.track(
1311                     EDITOR_NOTE_EDITED,
1312                     CATEGORY_NOTE,
1313                     &quot;editor_save&quot;
1314                 );
1315 
1316                 AppLog.add(
1317                     Type.SYNC,
1318                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1319                         &quot; / Title: &quot; + mNote.getTitle() +
1320                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1321                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1322                 );
1323             }
1324         } catch (BucketObjectMissingException exception) {
1325             exception.printStackTrace();
1326         }
1327     }
1328 
1329     // Checks if cursor is at a URL when the selection changes
1330     // If it is a URL, show the contextual action bar
1331     @Override
1332     public void onSelectionChanged(int selStart, int selEnd) {
1333         mCurrentCursorPosition = selEnd;
1334 
1335         if (selStart == selEnd) {
1336             Editable noteContent = mContentEditText.getText();
1337 
1338             if (noteContent == null) {
1339                 return;
1340             }
1341 
1342             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1343 
1344             if (urlSpans.length &gt; 0) {
1345                 URLSpan urlSpan = urlSpans[0];
1346                 mLinkUrl = urlSpan.getURL();
<abbr title="1347                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1347                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1348 
1349                 if (mActionMode != null) {
1350                     mActionMode.setSubtitle(mLinkText);
1351                     updateMenuItems();
1352                     return;
1353                 }
1354 
1355                 // Show the Contextual Action Bar
1356                 if (getActivity() != null) {
<abbr title="1357                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1357                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1358 
1359                     if (mActionMode != null) {
1360                         mActionMode.setSubtitle(mLinkText);
1361                     }
1362 
1363                     updateMenuItems();
1364                 }
1365             } else if (mActionMode != null) {
1366                 mActionMode.finish();
1367                 mActionMode = null;
1368             }
1369         } else if (mActionMode != null) {
1370             mActionMode.finish();
1371             mActionMode = null;
1372         }
1373     }
1374 
1375     private void updateMenuItems() {
1376         mCopyMenuItem.setIcon(mCopyIcon);
1377         mShareMenuItem.setIcon(mShareIcon);
1378 
1379         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1380             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1381                 mViewLinkMenuItem.setIcon(mCallIcon);
1382                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1383             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1384                 mViewLinkMenuItem.setIcon(mEmailIcon);
1385                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1386             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1387                 mViewLinkMenuItem.setIcon(mMapIcon);
1388                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1389             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1390                 mViewLinkMenuItem.setIcon(mLinkIcon);
1391                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1392             } else {
1393                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1394                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1395             }
1396         }
1397     }
1398 
1399     private void setPublishedNote(boolean isPublished) {
1400         if (mNote != null) {
1401             mNote.setPublished(isPublished);
1402             mNote.save();
1403 
1404             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1405             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1406 
1407             AnalyticsTracker.track(
1408                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1409                 CATEGORY_NOTE,
1410                 &quot;publish_note_button&quot;
1411             );
1412         }
1413     }
1414 
1415     private void updatePublishedState(boolean isSuccess) {
1416         if (mPublishingSnackbar == null) {
1417             return;
1418         }
1419 
1420         mPublishingSnackbar.dismiss();
1421         mPublishingSnackbar = null;
1422 
1423         if (isSuccess &amp;&amp; isAdded()) {
1424             if (mNote.isPublished()) {
1425                 if (mHideActionOnSuccess) {
1426                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1427                 } else {
1428                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1429                         .setAction(
1430                             R.string.undo,
1431                             new View.OnClickListener() {
1432                                 @Override
1433                                 public void onClick(View v) {
1434                                     mHideActionOnSuccess = true;
1435                                     unpublishNote();
1436                                 }
1437                             }
1438                         )
1439                         .show();
1440                 }
1441             } else {
1442                 if (mHideActionOnSuccess) {
1443                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1444                 } else {
1445                     Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1446                         .setAction(
1447                             R.string.undo,
1448                             new View.OnClickListener() {
1449                                 @Override
1450                                 public void onClick(View v) {
1451                                     mHideActionOnSuccess = true;
1452                                     publishNote();
1453                                 }
1454                             }
1455                         )
1456                         .show();
1457                 }
1458             }
1459         } else {
1460             if (mNote.isPublished()) {
1461                 Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1462                     .setAction(
1463                         R.string.retry,
1464                         new View.OnClickListener() {
1465                             @Override
1466                             public void onClick(View v) {
1467                                 mHideActionOnSuccess = true;
1468                                 unpublishNote();
1469                             }
1470                         }
1471                     )
1472                     .show();
1473             } else {
1474                 Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1475                     .setAction(
1476                         R.string.retry,
1477                         new View.OnClickListener() {
1478                             @Override
1479                             public void onClick(View v) {
1480                                 mHideActionOnSuccess = true;
1481                                 publishNote();
1482                             }
1483                         }
1484                     )
1485                     .show();
1486             }
1487         }
1488 
1489         mHideActionOnSuccess = false;
1490         requireActivity().invalidateOptionsMenu();
1491     }
1492 
1493     private void publishNote() {
1494         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1495             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1496             return;
1497         }
1498 
1499         if (isAdded()) {
<abbr title="1500             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1500             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1501             mPublishingSnackbar.show();
1502         }
1503 
1504         setPublishedNote(true);
1505     }
1506 
1507     private void unpublishNote() {
1508         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1509             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1510             return;
1511         }
1512 
1513         if (isAdded()) {
<abbr title="1514             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1514             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1515             mPublishingSnackbar.show();
1516         }
1517 
1518         setPublishedNote(false);
1519     }
1520 
1521     private void showShare(String text) {
1522         startActivity(
1523             ShareCompat.IntentBuilder.from(requireActivity())
1524                 .setText(text)
1525                 .setType(&quot;text/plain&quot;)
1526                 .createChooserIntent()
1527         );
1528     }
1529     private void showShareSheet() {
1530         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1531             mShareBottomSheet.show(requireFragmentManager(), mNote);
1532         }
1533     }
1534 
1535     private void showInfoSheet() {
1536         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1537             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1538         }
1539     }
1540 
1541     private void showHistorySheet() {
1542         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1543             // Request revisions for the current note
<abbr title="1544             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1544             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1545             saveNote();
1546 
1547             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1548         }
1549     }
1550 
1551     @Override
1552     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1553     }
1554 
1555     @Override
<abbr title="1556     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1556     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1557         if (changeType == Bucket.ChangeType.MODIFY) {
1558             if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1559                 try {
1560                     final Note updatedNote = noteBucket.get(key);
1561 
1562                     if (getActivity() != null) {
1563                         getActivity().runOnUiThread(new Runnable() {
1564                             @Override
1565                             public void run() {
1566                                 if (mPublishTimeoutHandler != null) {
1567                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1568                                 }
1569 
1570                                 updateNote(updatedNote);
1571                                 updatePublishedState(true);
1572                             }
1573                         });
1574                     }
1575                 } catch (BucketObjectMissingException e) {
1576                     e.printStackTrace();
1577                 }
1578             }
1579         }
1580     }
1581 
1582     @Override
1583     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1584         if (mIsPaused) {
1585             mNotesBucket.removeListener(this);
1586             AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
1587         }
1588 
1589         AppLog.add(
1590             Type.SYNC,
1591             &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1592                 &quot; / Title: &quot; + note.getTitle() +
1593                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1594                 &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1595         );
1596     }
1597 
1598     @Override
1599     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1600         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1601         if (mIsLoadingNote)
1602             return;
1603 
1604         Note openNote = getNote();
1605         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1606             return;
1607 
1608         note.setContent(mContentEditText.getPlainTextContent());
1609     }
1610 
1611     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1612         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1613 
1614         LoadNoteTask(NoteEditorFragment fragment) {
1615             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1616         }
1617 
1618         @Override
1619         protected void onPreExecute() {
1620             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1621 
1622             if (fragment != null) {
1623                 fragment.mContentEditText.removeTextChangedListener(fragment);
1624                 fragment.mIsLoadingNote = true;
1625             }
1626         }
1627 
1628         @Override
1629         protected Void doInBackground(String... args) {
1630             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1631 
1632             if (fragment == null || fragment.getActivity() == null) {
1633                 return null;
1634             }
1635 
1636             String noteID = args[0];
1637             Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1638             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1639 
1640             try {
1641                 fragment.mNote = notesBucket.get(noteID);
1642 
1643                 // Set the current note in NotesActivity when on a tablet
1644                 if (fragment.getActivity() instanceof NotesActivity) {
1645                     ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1646                 }
1647 
1648                 // Set markdown and preview flags for current note
1649                 if (fragment.mNote != null) {
1650                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1651                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1652                     AppLog.add(
1653                         Type.SYNC,
1654                         &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1655                             &quot; / Title: &quot; + fragment.mNote.getTitle() +
<abbr title="1656                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +">1656                             &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent())ðŸ”µ</abbr>
1657                             &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1658                     );
1659                 }
1660             } catch (BucketObjectMissingException e) {
1661                 // See if the note is in the object store
1662                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1663 
1664                 while (notesCursor.moveToNext()) {
1665                     Note currentNote = notesCursor.getObject();
1666 
1667                     if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1668                         fragment.mNote = currentNote;
1669                         return null;
1670                     }
1671                 }
1672             }
1673 
1674             return null;
1675         }
1676 
1677         @Override
1678         protected void onPostExecute(Void nada) {
1679             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1680             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {">1680             if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing(ðŸ”µ</abbr>
1681                 return;
1682             }
1683 
1684             fragment.refreshContent(false);
1685 
1686             if (fragment.mMatchOffsets != null) {
<abbr title="1687                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1687                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1688                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1689                 fragment.mShouldScrollToSearchMatch = true;
1690             }
1691 
1692             fragment.mContentEditText.addTextChangedListener(fragment);
1693 
1694             if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1695                 // Show soft keyboard
1696                 fragment.mContentEditText.requestFocus();
1697 
1698                 new Handler().postDelayed(new Runnable() {
1699                     @Override
1700                     public void run() {
1701                         if (fragment.getActivity() == null) {
1702                             return;
1703                         }
1704 
<abbr title="1705                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1705                         InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivityðŸ”µ</abbr>
1706 
1707                         if (inputMethodManager != null) {
1708                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1709                         }
1710                     }
1711                 }, 100);
1712             } else if (fragment.mNote != null) {
1713                 // If we have a valid note, hide the placeholder
1714                 fragment.setPlaceholderVisible(false);
1715             }
1716 
1717             fragment.updateMarkdownView();
1718             fragment.requireActivity().invalidateOptionsMenu();
1719             fragment.linkifyEditorContent();
1720             fragment.mIsLoadingNote = false;
1721         }
1722     }
1723 
1724     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1725         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1726 
1727         SaveNoteTask(NoteEditorFragment fragment) {
1728             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1729         }
1730 
1731         @Override
1732         protected Void doInBackground(Void... args) {
1733             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1734 
1735             if (fragment != null) {
1736                 fragment.saveNote();
1737             }
1738 
1739             return null;
1740         }
1741 
1742         @Override
1743         protected void onPostExecute(Void nada) {
1744             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1745 
<abbr title="1746             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {">1746             if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishingðŸ”µ</abbr>
1747                 // Update links
1748                 fragment.linkifyEditorContent();
1749                 fragment.updateMarkdownView();
1750             }
1751         }
1752     }
1753 
1754     private void linkifyEditorContent() {
1755         if (getActivity() == null || getActivity().isFinishing()) {
1756             return;
1757         }
1758 
1759         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1760             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1761         }
1762     }
1763 
1764     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1765     private void updateMarkdownView() {
1766         if (!mIsMarkdownEnabled) {
1767             return;
1768         }
1769 
1770         Activity activity = getActivity();
1771         if (activity instanceof NotesActivity) {
1772             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1773             loadMarkdownData();
1774         } else {
1775             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1776             if (mNoteMarkdownFragment == null) {
1777                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1778                         .getNoteMarkdownFragment();
1779                 ((NoteEditorActivity) requireActivity()).showTabs();
1780             }
1781             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1782             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1783         }
1784     }
1785 
1786     private ColorStateList getChipBackgroundColor() {
1787         int[][] states = new int[][] {
1788             new int[] { android.R.attr.state_checked}, // checked
1789             new int[] {-android.R.attr.state_checked}  // unchecked
1790         };
1791 
1792         int[] colors = new int[] {
1793             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1794             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1795         };
1796 
1797         return new ColorStateList(states, colors);
1798     }
1799 
1800     private void setChips(CharSequence text) {
1801         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1802         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1803         mTagChips.setSingleSelection(true);
1804         mTagChips.removeAllViews();
1805         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1806         tags.setString(text.toString());
1807 
1808         for (String tag : tags) {
1809             final Chip chip = new Chip(requireContext());
1810             chip.setText(tag);
1811             chip.setCheckable(true);
1812             chip.setCheckedIcon(null);
1813             chip.setChipBackgroundColor(getChipBackgroundColor());
1814             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1815             chip.setStateListAnimator(null);
1816             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1817                 @Override
1818                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1819                     chip.setCloseIconVisible(isChecked);
1820                 }
1821             });
1822             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1823                 @Override
1824                 public void onClick(View view) {
1825                     mTagChips.removeView(view);
1826                     updateTags();
1827                     AnalyticsTracker.track(
1828                         EDITOR_TAG_REMOVED,
1829                         CATEGORY_NOTE,
1830                         &quot;tag_removed_from_note&quot;
1831                     );
1832                 }
1833             });
1834             mTagChips.addView(chip);
1835         }
1836     }
1837 
1838     private void updateTags() {
1839         if (mNote == null) {
1840             return;
1841         }
1842 
1843         mNote.setTagString(getNoteTagsString());
1844         mNote.setModificationDate(Calendar.getInstance());
1845         updateTagList();
1846         mNote.save();
1847     }
1848 }
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote;
   2 
   3 import android.app.Activity;
   4 import android.content.Context;
   5 import android.content.SharedPreferences;
   6 import android.content.res.ColorStateList;
   7 import android.database.Cursor;
   8 import android.graphics.Typeface;
   9 import android.graphics.drawable.Drawable;
  10 import android.os.AsyncTask;
  11 import android.os.Bundle;
  12 import android.os.Handler;
  13 import android.text.Editable;
  14 import android.text.Layout;
  15 import android.text.Spanned;
  16 import android.text.TextUtils.SimpleStringSplitter;
  17 import android.text.TextWatcher;
  18 import android.text.style.MetricAffectingSpan;
  19 import android.text.style.RelativeSizeSpan;
  20 import android.text.style.StyleSpan;
  21 import android.text.style.URLSpan;
  22 import android.text.util.Linkify;
  23 import android.util.TypedValue;
  24 import android.view.LayoutInflater;
  25 import android.view.Menu;
  26 import android.view.MenuInflater;
  27 import android.view.MenuItem;
  28 import android.view.View;
  29 import android.view.ViewGroup;
  30 import android.view.ViewStub;
  31 import android.view.ViewTreeObserver;
  32 import android.view.inputmethod.InputMethodManager;
  33 import android.webkit.WebResourceRequest;
  34 import android.webkit.WebView;
  35 import android.webkit.WebViewClient;
  36 import android.widget.CompoundButton;
  37 import android.widget.CursorAdapter;
  38 import android.widget.LinearLayout;
  39 import android.widget.TextView;
  40 import android.widget.Toast;
  41 import androidx.annotation.NonNull;
  42 import androidx.appcompat.app.AppCompatActivity;
  43 import androidx.appcompat.view.ActionMode;
  44 import androidx.core.app.ShareCompat;
  45 import androidx.core.view.MenuCompat;
  46 import androidx.core.widget.NestedScrollView;
  47 import androidx.fragment.app.Fragment;
  48 import androidx.fragment.app.FragmentTransaction;
  49 import androidx.preference.PreferenceManager;
  50 import com.automattic.simplenote.analytics.AnalyticsTracker;
  51 import com.automattic.simplenote.models.Note;
  52 import com.automattic.simplenote.models.Tag;
  53 import com.automattic.simplenote.utils.AppLog.Type;
  54 import com.automattic.simplenote.utils.AppLog;
  55 import com.automattic.simplenote.utils.AutoBullet;
  56 import com.automattic.simplenote.utils.BrowserUtils;
  57 import com.automattic.simplenote.utils.ContextUtils;
  58 import com.automattic.simplenote.utils.DisplayUtils;
  59 import com.automattic.simplenote.utils.DrawableUtils;
  60 import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  61 import com.automattic.simplenote.utils.NetworkUtils;
  62 import com.automattic.simplenote.utils.NoteUtils;
  63 import com.automattic.simplenote.utils.PrefUtils;
  64 import com.automattic.simplenote.utils.SimplenoteLinkify;
  65 import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  66 import com.automattic.simplenote.utils.SpaceTokenizer;
  67 import com.automattic.simplenote.utils.TagUtils;
  68 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  69 import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  70 import com.automattic.simplenote.utils.TextHighlighter;
  71 import com.automattic.simplenote.utils.ThemeUtils;
  72 import com.automattic.simplenote.utils.WidgetUtils;
  73 import com.automattic.simplenote.widgets.SimplenoteEditText;
  74 import com.google.android.material.chip.Chip;
  75 import com.google.android.material.chip.ChipGroup;
  76 import com.google.android.material.snackbar.Snackbar;
  77 import com.simperium.client.Bucket;
  78 import com.simperium.client.BucketObjectMissingException;
  79 import com.simperium.client.Query;
  80 import java.lang.ref.WeakReference;
  81 import java.util.Calendar;
  82 import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  83 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  84 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  85 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  86 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  87 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  88 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  89 import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  90 import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  91 import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  92 
  93 
<abbr title="  94 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAddedListener , View.OnFocusChangeListener , SimplenoteEditText.OnSelectionChangedListener , ShareBottomSheetDialog.ShareSheetListener , HistoryBottomSheetDialog.HistorySheetListener , SimplenoteEditText.OnCheckboxToggledListener {">  94 public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt; , TextWatcher , OnTagAdðŸ”µ</abbr>
  95     public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
  96 
  97     public static final String ARG_ITEM_ID = &quot;item_id&quot;;
  98 
  99     public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 100 
 101     public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 102 
 103     public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 104 
 105     public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 106 
 107     private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 108 
 109     private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 110 
 111     private static final int MAX_REVISIONS = 30;
 112 
 113     private static final int PUBLISH_TIMEOUT = 20000;
 114 
 115     private static final int HISTORY_TIMEOUT = 10000;
 116 
 117     private Note mNote;
 118 
 119     private final Runnable mAutoSaveRunnable = new Runnable() {
 120         @Override
 121         public void run() {
 122             saveAndSyncNote();
 123         }
 124     };
 125 
 126     private Bucket&lt;Note&gt; mNotesBucket;
 127 
 128     private View mRootView;
 129 
 130     private View mTagPadding;
 131 
 132     private SimplenoteEditText mContentEditText;
 133 
 134     private ChipGroup mTagChips;
 135 
 136     private TagsMultiAutoCompleteTextView mTagInput;
 137 
 138     private Handler mAutoSaveHandler;
 139 
 140     private Handler mPublishTimeoutHandler;
 141 
 142     private Handler mHistoryTimeoutHandler;
 143 
 144     private LinearLayout mPlaceholderView;
 145 
 146     private CursorAdapter mLinkAutocompleteAdapter;
 147 
 148     private CursorAdapter mTagAutocompleteAdapter;
 149 
 150     private boolean mIsLoadingNote;
 151 
 152     private boolean mIsMarkdownEnabled;
 153 
 154     private boolean mIsPreviewEnabled;
 155 
 156     private boolean mShouldScrollToSearchMatch;
 157 
 158     private ActionMode mActionMode;
 159 
 160     private MenuItem mChecklistMenuItem;
 161 
 162     private MenuItem mCopyMenuItem;
 163 
 164     private MenuItem mInformationMenuItem;
 165 
 166     private MenuItem mShareMenuItem;
 167 
 168     private MenuItem mViewLinkMenuItem;
 169 
 170     private String mLinkUrl;
 171 
 172     private String mLinkText;
 173 
 174     private MatchOffsetHighlighter mHighlighter;
 175 
 176     private Drawable mBrowserIcon;
 177 
 178     private Drawable mCallIcon;
 179 
 180     private Drawable mCopyIcon;
 181 
 182     private Drawable mEmailIcon;
 183 
 184     private Drawable mLinkIcon;
 185 
 186     private Drawable mMapIcon;
 187 
 188     private Drawable mShareIcon;
 189 
 190     private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 191 
 192     private String mMatchOffsets;
 193 
 194     private int mCurrentCursorPosition;
 195 
 196     private HistoryBottomSheetDialog mHistoryBottomSheet;
 197 
 198     private LinearLayout mError;
 199 
 200     private NoteMarkdownFragment mNoteMarkdownFragment;
 201 
 202     private String mCss;
 203 
 204     private WebView mMarkdown;
 205 
 206     private boolean mIsPaused;
 207 
 208     private boolean mIsFromWidget;
 209 
 210     // Hides the history bottom sheet if no revisions are loaded
 211     // Hides the history bottom sheet if no revisions are loaded
 212     private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 213         @Override
 214         public void run() {
 215             if (!isAdded()) {
 216                 return;
 217             }
 218 
 219             requireActivity().runOnUiThread(new Runnable() {
 220                 @Override
 221                 public void run() {
<abbr title=" 222                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 222                     if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowðŸ”µ</abbr>
 223                         mHistoryBottomSheet.dismiss();
 224                         Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 225                     }
 226                 }
 227             });
 228         }
 229     };
 230 
 231     private InfoBottomSheetDialog mInfoBottomSheet;
 232 
 233     private ShareBottomSheetDialog mShareBottomSheet;
 234 
 235     // Contextual action bar for dealing with links
 236     private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 237         // Called when the action mode is created; startActionMode() was called
 238         @Override
 239         public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 240             // Inflate a menu resource providing context menu items
 241             MenuInflater inflater = mode.getMenuInflater();
 242             if (inflater != null) {
 243                 inflater.inflate(R.menu.view_link, menu);
 244                 mCopyMenuItem = menu.findItem(R.id.menu_copy);
 245                 mShareMenuItem = menu.findItem(R.id.menu_share);
 246                 mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 247                 mode.setTitle(getString(R.string.link));
 248                 mode.setTitleOptionalHint(false);
 249                 DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 250             }
<abbr title=" 251             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 251             requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireConteðŸ”µ</abbr>
 252             return true;
 253         }
 254 
 255         // Called each time the action mode is shown. Always called after onCreateActionMode, but
 256         // may be called multiple times if the mode is invalidated.
 257         @Override
 258         public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 259             return false; // Return false if nothing is done
 260         }
 261 
 262         // Called when the user selects a contextual menu item
 263         @Override
 264         public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 265             switch (item.getItemId()) {
 266                 case R.id.menu_view_link:
 267                     if (mLinkText != null) {
 268                         if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 269                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 269                             SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LIðŸ”µ</abbr>
 270                         } else {
 271                             try {
 272                                 BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 273                             } catch (Exception e) {
 274                                 e.printStackTrace();
 275                             }
 276                         }
 277 
 278                         mode.finish(); // Action picked, so close the CAB
 279                     }
 280 
 281                     return true;
 282                 case R.id.menu_copy:
 283                     if (mLinkText != null &amp;&amp; getActivity() != null) {
 284                         if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 285                             Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 286                         } else {
<abbr title=" 287                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();"> 287                             Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT)ðŸ”µ</abbr>
 288                         }
 289 
 290                         mode.finish();
 291                     }
 292 
 293                     return true;
 294                 case R.id.menu_share:
 295                     if (mLinkText != null) {
 296                         showShare(mLinkText);
 297                         mode.finish();
 298                     }
 299 
 300                     return true;
 301                 default:
 302                     return false;
 303             }
 304         }
 305 
 306         // Called when the user exits the action mode
 307         @Override
 308         public void onDestroyActionMode(ActionMode mode) {
 309             if (mActionMode != null) {
 310                 mActionMode.setSubtitle(&quot;&quot;);
 311                 mActionMode = null;
 312             }
 313 
 314             new Handler().postDelayed(
 315                 new Runnable() {
 316                     @Override
 317                     public void run() {
<abbr title=" 318                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 318                         requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.RðŸ”µ</abbr>
 319                     }
 320                 },
 321                 requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 322             );
 323         }
 324     };
 325 
 326     private Snackbar mPublishingSnackbar;
 327 
 328     private boolean mHideActionOnSuccess;
 329 
 330     // Resets note publish status if Simperium never returned the new publish status
 331     // Resets note publish status if Simperium never returned the new publish status
 332     private final Runnable mPublishTimeoutRunnable = new Runnable() {
 333         @Override
 334         public void run() {
 335             if (!isAdded()) return;
 336 
 337             requireActivity().runOnUiThread(new Runnable() {
 338                 @Override
 339                 public void run() {
 340 
 341                     mNote.setPublished(!mNote.isPublished());
 342                     mNote.save();
 343 
 344                     updatePublishedState(false);
 345                 }
 346             });
 347         }
 348     };
 349 
 350     /**
 351      * Mandatory empty constructor for the fragment manager to instantiate the
 352      * fragment (e.g. upon screen orientation changes).
 353      */
 354     public NoteEditorFragment() {
 355     }
 356 
 357     @Override
 358     public void onCreate(Bundle savedInstanceState) {
 359         super.onCreate(savedInstanceState);
 360         AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 361         AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 362         mInfoBottomSheet = new InfoBottomSheetDialog(this);
 363         mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 364         mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 365 
 366         Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 367         mNotesBucket = currentApp.getNotesBucket();
 368 
<abbr title=" 369         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 369         mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp,ðŸ”µ</abbr>
<abbr title=" 370         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 370         mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.aðŸ”µ</abbr>
<abbr title=" 371         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 371         mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attðŸ”µ</abbr>
<abbr title=" 372         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 372         mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.ðŸ”µ</abbr>
<abbr title=" 373         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 373         mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp,ðŸ”µ</abbr>
<abbr title=" 374         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 374         mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attðŸ”µ</abbr>
<abbr title=" 375         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 375         mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.aðŸ”µ</abbr>
 376 
 377         mAutoSaveHandler = new Handler();
 378         mPublishTimeoutHandler = new Handler();
 379         mHistoryTimeoutHandler = new Handler();
 380 
 381         mMatchHighlighter = new TextHighlighter(requireActivity(),
<abbr title=" 382                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);"> 382                 R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor)ðŸ”µ</abbr>
 383         mTagAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 384             @Override
 385             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 386                 Activity activity = (Activity) context;
 387                 if (activity == null) return null;
 388                 return activity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 389             }
 390 
 391             @Override
 392             public void bindView(View view, Context context, Cursor cursor) {
 393                 TextView textView = (TextView) view;
 394                 textView.setText(convertToString(cursor));
 395             }
 396 
 397             @Override
 398             public CharSequence convertToString(Cursor cursor) {
 399                 return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 400             }
 401 
 402             @Override
 403             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 404                 Activity activity = getActivity();
 405                 if (activity == null) return null;
 406                 Simplenote application = (Simplenote) activity.getApplication();
 407                 Query&lt;Tag&gt; query = application.getTagsBucket().query();
 408                 // make the tag name available to the cursor
 409                 query.include(Tag.NAME_PROPERTY);
 410                 // sort the tags by their names
 411                 query.order(Tag.NAME_PROPERTY);
 412                 // if there&#x27;s a filter string find only matching tag names
 413                 if (filter != null)
<abbr title=" 414                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));"> 414                     query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filteðŸ”µ</abbr>
 415                 return query.execute();
 416             }
 417         };
 418 
 419         mLinkAutocompleteAdapter = new CursorAdapter(getContext(), null, 0x0) {
 420             private Activity mActivity = requireActivity();
 421 
 422             @Override
 423             public void bindView(View view, Context context, Cursor cursor) {
 424                 ((TextView) view).setText(convertToString(cursor));
 425             }
 426 
 427             @Override
 428             public CharSequence convertToString(Cursor cursor) {
 429                 return cursor.getString(cursor.getColumnIndex(Note.TITLE_INDEX_NAME));
 430             }
 431 
 432             @Override
 433             public View newView(Context context, Cursor cursor, ViewGroup parent) {
 434                 return mActivity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 435             }
 436 
 437             @Override
 438             public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 439                 if (filter == null) {
 440                     return null;
 441                 }
 442 
 443                 Simplenote application = (Simplenote) mActivity.getApplication();
 444                 Query&lt;Note&gt; query = application.getNotesBucket().query();
 445                 query.include(Note.PINNED_INDEX_NAME);
 446                 query.include(Note.TITLE_INDEX_NAME);
<abbr title=" 447                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filter));"> 447                 query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filðŸ”µ</abbr>
 448                 PrefUtils.sortNoteQuery(query, requireContext(), true);
 449                 Cursor cursor = query.execute();
 450 
<abbr title=" 451                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * 48);"> 451                 final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * ðŸ”µ</abbr>
 452                 final int heightDisplay = DisplayUtils.getDisplayPixelSize(requireContext()).y;
 453                 final int heightDropdown = Math.min(heightDisplay / 4, heightAutocomplete);
 454 
 455                 mActivity.runOnUiThread(
 456                     new Runnable() {
 457                         @Override
 458                         public void run() {
 459                             mContentEditText.setDropDownHeight(heightDropdown);
 460                         }
 461                     }
 462                 );
 463                 return cursor;
 464             }
 465         };
 466 
 467         WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 468     }
 469 
 470     @Override
 471     public View onCreateView(@NonNull
 472     LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 473         mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 474         mContentEditText = mRootView.findViewById(R.id.note_content);
 475         mContentEditText.addOnSelectionChangedListener(this);
 476         mContentEditText.setOnCheckboxToggledListener(this);
 477         mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 478         mContentEditText.setOnFocusChangeListener(this);
<abbr title=" 479         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 479         mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()))ðŸ”µ</abbr>
 480         mContentEditText.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 481         mContentEditText.setAdapter(mLinkAutocompleteAdapter);
 482         mTagInput = mRootView.findViewById(R.id.tag_input);
 483         mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 484         mTagInput.setTokenizer(new SpaceTokenizer());
 485         mTagInput.setAdapter(mTagAutocompleteAdapter);
 486         mTagInput.setOnFocusChangeListener(this);
 487         mTagChips = mRootView.findViewById(R.id.tag_chips);
 488         mTagPadding = mRootView.findViewById(R.id.tag_padding);
 489         mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 490         mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 491         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; (mNote == null)) {
 492             mPlaceholderView.setVisibility(View.VISIBLE);
 493             requireActivity().invalidateOptionsMenu();
 494             if (BrowserUtils.isWebViewInstalled(requireContext())) {
 495                 ((ViewStub) (mRootView.findViewById(R.id.stub_webview))).inflate();
 496                 mMarkdown = mRootView.findViewById(R.id.markdown);
 497                 mMarkdown.setWebViewClient(new WebViewClient() {
 498                     @Override
 499                     public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
 500                         String url = request.getUrl().toString();
 501                         if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 502                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 502                             SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREðŸ”µ</abbr>
 503                         } else {
 504                             BrowserUtils.launchBrowserOrShowError(requireContext(), url);
 505                         }
 506                         return true;
 507                     }
 508                 });
<abbr title=" 509                 mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));"> 509                 mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireConteðŸ”µ</abbr>
 510             } else {
 511                 ((ViewStub) (mRootView.findViewById(R.id.stub_error))).inflate();
 512                 mError = mRootView.findViewById(R.id.error);
 513                 mRootView.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() {
 514                     @Override
 515                     public void onClick(View view) {
<abbr title=" 516                         BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_VIEW);"> 516                         BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_VIEWðŸ”µ</abbr>
 517                     }
 518                 });
 519             }
 520         }
 521         Bundle arguments = getArguments();
 522         if ((arguments != null) &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 523             // Load note if we were passed a note Id
 524             String key = arguments.getString(ARG_ITEM_ID);
 525             if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 526                 mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 527             }
 528             mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 529             if (mIsFromWidget) {
 530                 AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 531             } else {
 532                 AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 533             }
 534             new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 535         } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; (savedInstanceState != null)) {
 536             // Restore selected note when in dual pane mode
 537             String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 538             if (noteId != null) {
 539                 setNote(noteId);
 540             }
 541         }
 542         ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 543         viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 544             @Override
 545             public void onGlobalLayout() {
 546                 // If a note was loaded with search matches, scroll to the first match in the editor
 547                 if (mShouldScrollToSearchMatch &amp;&amp; (mMatchOffsets != null)) {
 548                     if (!isAdded()) {
 549                         return;
 550                     }
 551                     // Get the character location of the first search match
<abbr title=" 552                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(mContentEditText.getText(), mMatchOffsets);"> 552                     int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(mContentEditText.getðŸ”µ</abbr>
 553                     if (matchLocation == 0) {
 554                         return;
 555                     }
 556                     // Calculate how far to scroll to bring the match into view
 557                     Layout layout = mContentEditText.getLayout();
 558                     int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 559                     ((NestedScrollView) (mRootView)).smoothScrollTo(0, lineTop);
 560                     mShouldScrollToSearchMatch = false;
 561                 }
 562             }
 563         });
 564         setHasOptionsMenu(true);
 565         return mRootView;
 566     }
 567 
 568     public void scrollToMatch(int location) {
 569         if (isAdded()) {
 570             // Calculate how far to scroll to bring the match into view
 571             Layout layout = mContentEditText.getLayout();
 572             int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 573             ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 574         }
 575     }
 576 
 577     @Override
 578     public void onResume() {
 579         super.onResume();
 580         checkWebView();
 581         mIsPaused = false;
 582         mNotesBucket.addListener(this);
 583         AppLog.add(Type.SYNC, &quot;Added note bucket listener (NoteEditorFragment)&quot;);
 584         mTagInput.setOnTagAddedListener(this);
 585         if (mContentEditText != null) {
<abbr title=" 586             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));"> 586             mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContextðŸ”µ</abbr>
 587             if (mContentEditText.hasFocus()) {
 588                 showSoftKeyboard();
 589             }
 590         }
 591     }
 592 
 593     private void checkWebView() {
 594         // When a WebView is installed and mMarkdown is null on a large landscape device, a WebView
 595         // was not installed when the fragment was created.  So, recreate the activity to refresh
 596         // the editor view.
 597         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown == null &amp;&amp;
 598             DisplayUtils.isLargeScreenLandscape(requireContext())) {
 599             requireActivity().recreate();
 600         }
 601     }
 602 
 603     private void showSoftKeyboard() {
 604         new Handler().postDelayed(new Runnable() {
 605             @Override
 606             public void run() {
 607                 if (getActivity() == null) {
 608                     return;
 609                 }
 610 
<abbr title=" 611                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 611                 InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemServiðŸ”µ</abbr>
 612                 if (inputMethodManager != null) {
 613                     inputMethodManager.showSoftInput(mContentEditText, 0);
 614                 }
 615             }
 616         }, 100);
 617     }
 618 
 619     @Override
 620     public void onPause() {
 621         super.onPause();  // Always call the superclass method first
 622         mIsPaused = true;
 623 
 624         // Hide soft keyboard if it is showing...
 625         DisplayUtils.hideKeyboard(mContentEditText);
 626 
 627         mTagInput.setOnTagAddedListener(null);
 628 
 629         if (mAutoSaveHandler != null) {
 630             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 631             mAutoSaveHandler.post(mAutoSaveRunnable);
 632         }
 633 
 634         if (mPublishTimeoutHandler != null) {
 635             mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 636         }
 637 
 638         if (mHistoryTimeoutHandler != null) {
 639             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 640         }
 641 
 642         mHighlighter.stop();
 643         saveNote();
 644         AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 645     }
 646 
 647     @Override
 648     public void onDestroy() {
 649         super.onDestroy();
 650         mNotesBucket.removeListener(this);
 651         AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
 652         AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 653     }
 654 
 655     @Override
 656     public void onSaveInstanceState(@NonNull Bundle outState) {
 657         super.onSaveInstanceState(outState);
 658 
 659         if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 660             outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 661         }
 662     }
 663 
 664     @Override
 665     public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 666         super.onCreateOptionsMenu(menu, inflater);
 667 
<abbr title=" 668         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 668         if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMðŸ”µ</abbr>
 669             return;
 670         }
 671 
 672         inflater.inflate(R.menu.note_editor, menu);
 673         MenuCompat.setGroupDividerEnabled(menu, true);
 674     }
 675 
 676     @Override
 677     public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 678         switch (item.getItemId()) {
 679             case R.id.menu_checklist:
 680                 insertChecklist();
 681                 return true;
 682             case R.id.menu_copy:
 683                 if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 684                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 685                 } else {
 686                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 687                 }
 688 
 689                 return true;
 690             case R.id.menu_copy_internal:
<abbr title=" 691                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 691                 if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitleðŸ”µ</abbr>
 692                     Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 693                 } else {
 694                     Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 695                 }
 696 
 697                 return true;
 698             case R.id.menu_history:
 699                 showHistory();
 700                 return true;
 701             case R.id.menu_info:
 702                 showInfo();
 703                 return true;
 704             case R.id.menu_markdown:
 705                 setMarkdown(!item.isChecked());
 706                 return true;
 707             case R.id.menu_pin:
 708                 NoteUtils.setNotePin(mNote, !item.isChecked());
 709                 requireActivity().invalidateOptionsMenu();
 710                 return true;
 711             case R.id.menu_publish:
 712                 if (item.isChecked()) {
 713                     unpublishNote();
 714                 } else {
 715                     publishNote();
 716                 }
 717 
 718                 return true;
 719             case R.id.menu_share:
 720                 shareNote();
 721                 return true;
 722             case R.id.menu_trash:
 723                 if (!isAdded()) {
 724                     return false;
 725                 }
 726 
 727                 deleteNote();
 728                 return true;
 729             case android.R.id.home:
 730                 AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 731                 if (!isAdded()) {
 732                     return false;
 733                 }
 734 
 735                 requireActivity().finish();
 736                 return true;
 737             default:
 738                 return super.onOptionsItemSelected(item);
 739         }
 740     }
 741 
 742     @Override
 743     public void onPrepareOptionsMenu(@NonNull Menu menu) {
 744         if (mNote != null) {
 745             MenuItem pinItem = menu.findItem(R.id.menu_pin);
 746             MenuItem shareItem = menu.findItem(R.id.menu_share);
 747             MenuItem historyItem = menu.findItem(R.id.menu_history);
 748             MenuItem publishItem = menu.findItem(R.id.menu_publish);
 749             MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 750             MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 751             MenuItem trashItem = menu.findItem(R.id.menu_trash);
 752             mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 753             mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 754 
 755             pinItem.setChecked(mNote.isPinned());
 756             publishItem.setChecked(mNote.isPublished());
 757             markdownItem.setChecked(mNote.isMarkdownEnabled());
 758 
 759             // Disable actions when note is in Trash or markdown view is shown on large device.
 760             if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 761                 pinItem.setEnabled(false);
 762                 shareItem.setEnabled(false);
 763                 historyItem.setEnabled(false);
 764                 publishItem.setEnabled(false);
 765                 copyLinkItem.setEnabled(false);
 766                 markdownItem.setEnabled(false);
 767                 mChecklistMenuItem.setEnabled(false);
 768                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 769             } else {
 770                 pinItem.setEnabled(true);
 771                 shareItem.setEnabled(true);
 772                 historyItem.setEnabled(true);
 773                 publishItem.setEnabled(true);
 774                 copyLinkItem.setEnabled(mNote.isPublished());
 775                 markdownItem.setEnabled(true);
 776                 mChecklistMenuItem.setEnabled(true);
 777                 DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 778             }
 779 
 780             if (mNote.isDeleted()) {
 781                 trashItem.setTitle(R.string.restore);
 782             } else {
 783                 trashItem.setTitle(R.string.trash);
 784             }
 785         }
 786 
 787         DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 788         super.onPrepareOptionsMenu(menu);
 789     }
 790 
 791     public void insertChecklist() {
 792         DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 793 
 794         try {
 795             mContentEditText.insertChecklist();
 796         } catch (Exception e) {
 797             e.printStackTrace();
 798             return;
 799         }
 800 
 801         AnalyticsTracker.track(
 802             EDITOR_CHECKLIST_INSERTED,
 803             CATEGORY_NOTE,
 804             &quot;toolbar_button&quot;
 805         );
 806     }
 807 
 808     @Override
 809     public void onCheckboxToggled() {
 810         // Save note (using delay) after toggling a checkbox
 811         if (mAutoSaveHandler != null) {
 812             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 813             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 814         }
 815     }
 816 
 817     private void deleteNote() {
 818         NoteUtils.deleteNote(mNote, getActivity());
 819         requireActivity().finish();
 820     }
 821 
 822     protected void clearMarkdown() {
 823         if (mMarkdown != null) {
<abbr title=" 824             mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);"> 824             mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, nullðŸ”µ</abbr>
 825         }
 826     }
 827 
 828     protected void hideMarkdown() {
 829         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; (mMarkdown != null)) {
 830             mMarkdown.setVisibility(View.INVISIBLE);
 831         } else {
 832             mError.setVisibility(View.INVISIBLE);
 833         }
 834     }
 835 
 836     protected void showMarkdown() {
 837         loadMarkdownData();
 838         if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; (mMarkdown != null)) {
 839             mMarkdown.setVisibility(View.VISIBLE);
 840         } else {
 841             mError.setVisibility(View.VISIBLE);
 842         }
 843         new Handler().postDelayed(new Runnable() {
 844             @Override
 845             public void run() {
 846                 requireActivity().invalidateOptionsMenu();
 847             }
 848         }, getResources().getInteger(R.integer.time_animation));
 849     }
 850 
 851     public void shareNote() {
 852         if (mNote != null) {
 853             mContentEditText.clearFocus();
 854             showShareSheet();
 855             AnalyticsTracker.track(
 856                 EDITOR_NOTE_CONTENT_SHARED,
 857                 CATEGORY_NOTE,
 858                 &quot;action_bar_share_button&quot;
 859             );
 860         }
 861     }
 862 
 863     public void showHistory() {
 864         if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 865             mContentEditText.clearFocus();
 866             mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 867             showHistorySheet();
 868         } else {
 869             Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 870         }
 871     }
 872 
 873     public void showInfo() {
 874         DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 875 
 876         if (mNote != null) {
 877             mContentEditText.clearFocus();
 878             saveNote();
 879             showInfoSheet();
 880         }
 881     }
 882 
 883     private void setMarkdown(boolean isChecked) {
 884         mIsMarkdownEnabled = isChecked;
 885         showMarkdownActionOrTabs();
 886         saveNote();
 887 
 888         // Set preference so that next new note will have markdown enabled.
 889         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 890         SharedPreferences.Editor editor = prefs.edit();
 891         editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 892         editor.apply();
 893     }
 894 
 895     private void setMarkdownEnabled(boolean enabled) {
 896         mIsMarkdownEnabled = enabled;
 897 
 898         if (mIsMarkdownEnabled) {
 899             loadMarkdownData();
 900         }
 901     }
 902 
 903     private void showMarkdownActionOrTabs() {
 904         Activity activity = getActivity();
 905 
 906         if (activity instanceof NoteEditorActivity) {
 907             NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 908 
 909             if (mIsMarkdownEnabled) {
 910                 editorActivity.showTabs();
 911 
 912                 if (mNoteMarkdownFragment == null) {
 913                     // Get markdown fragment and update content
 914                     mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 915                     mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 916                 }
 917             } else {
 918                 editorActivity.hideTabs();
 919             }
 920         } else if (activity instanceof NotesActivity) {
 921             setMarkdownEnabled(mIsMarkdownEnabled);
 922             ((NotesActivity) getActivity()).setMarkdownShowing(false);
 923         }
 924     }
 925 
 926     private void loadMarkdownData() {
<abbr title=" 927         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(mCss, mContentEditText.getPreviewTextContent());"> 927         String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(mCss, mContentEditTextðŸ”µ</abbr>
 928         if (mMarkdown != null) {
 929             mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);
 930         }
 931     }
 932 
 933     public void setNote(String noteID, String matchOffsets) {
 934         if (mAutoSaveHandler != null) {
 935             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 936         }
 937         mPlaceholderView.setVisibility(View.GONE);
 938         mMatchOffsets = matchOffsets;
 939         saveNote();
 940         new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 941     }
 942 
 943     private void updateNote(Note updatedNote) {
 944         // update note if network change arrived
 945         mNote = updatedNote;
 946         refreshContent(true);
 947     }
 948 
 949     private void refreshContent(boolean isNoteUpdate) {
 950         if (mNote != null) {
 951             // Restore the cursor position if possible.
<abbr title=" 952             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 952             int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEdðŸ”µ</abbr>
 953             mContentEditText.setText(mNote.getContent());
 954 
 955             if (isNoteUpdate) {
 956                 // Update markdown and preview flags from updated note.
 957                 mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 958                 mIsPreviewEnabled = mNote.isPreviewEnabled();
 959 
 960                 // Show/Hide action/tabs based on markdown flag.
 961                 showMarkdownActionOrTabs();
 962 
 963                 // Save note so any local changes get synced.
 964                 mNote.save();
 965 
 966                 // Update current note object on large screen devices in landscape orientation.
 967                 if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 968                     ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 969                 }
 970 
 971                 // Update overflow popup menu.
 972                 requireActivity().invalidateOptionsMenu();
 973 
 974                 if (mContentEditText.hasFocus()
 975                         &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 976                         &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 977                     mContentEditText.setSelection(cursorPosition);
 978                 }
 979             }
 980 
 981             afterTextChanged(mContentEditText.getText());
 982             mContentEditText.processChecklists();
 983             updateTagList();
 984         }
 985     }
 986 
 987     private void updateTagList() {
 988         setChips(mNote.getTagString());
 989         mTagInput.setText(&quot;&quot;);
 990     }
 991 
 992     private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 993         // Ported from the iOS app :)
 994         // Cases:
 995         // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 996         // 1. Text was added after the cursor ==&gt; no change
 997         // 2. Text was added before the cursor ==&gt; location advances
 998         // 3. Text was removed after the cursor ==&gt; no change
 999         // 4. Text was removed before the cursor ==&gt; location retreats
1000         // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
1001 
1002         cursorLocation = Math.max(cursorLocation, 0);
1003 
1004         int newCursorLocation = cursorLocation;
1005 
1006         int deltaLength = newText.length() - oldText.length();
1007 
1008         // Case 0
1009         if (newText.length() &lt; cursorLocation)
1010             return newText.length();
1011 
1012         boolean beforeCursorMatches = false;
1013         boolean afterCursorMatches = false;
1014 
1015         try {
<abbr title="1016             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));">1016             beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorðŸ”µ</abbr>
<abbr title="1017             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));">1017             afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocatioðŸ”µ</abbr>
1018         } catch (Exception e) {
1019             e.printStackTrace();
1020         }
1021 
1022         // Cases 2 and 4
1023         if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
1024             newCursorLocation += deltaLength;
1025 
1026         // Cases 1, 3 and 5 have no change
1027         return newCursorLocation;
1028     }
1029 
1030     @Override
1031     public void onTagAdded(String tag) {
1032         if (mNote == null || !isAdded()) {
1033             return;
1034         }
1035 
1036         if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
1037             AnalyticsTracker.track(
1038                 EDITOR_TAG_ADDED,
1039                 CATEGORY_NOTE,
1040                 &quot;tag_added_to_note&quot;
1041             );
1042         }
1043 
1044         mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
1045         mNote.setModificationDate(Calendar.getInstance());
1046         updateTagList();
1047         mNote.save();
1048     }
1049 
1050     @Override
1051     public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
1052         // Unused
1053     }
1054 
1055     @Override
1056     public void afterTextChanged(Editable editable) {
1057         attemptAutoList(editable);
1058         setTitleSpan(editable);
1059         mContentEditText.fixLineSpacing();
1060     }
1061 
1062     @Override
1063     public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1064         // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1065         if (mAutoSaveHandler != null) {
1066             mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1067             mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1068         }
1069 
1070         // Remove search highlight spans when note content changes
1071         if (mMatchOffsets != null) {
1072             mMatchOffsets = null;
1073             mHighlighter.removeMatches();
1074         }
1075 
1076         if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1077             ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1078         }
1079 
1080         // Temporarily remove the text watcher as we process checklists to prevent callback looping
1081         mContentEditText.removeTextChangedListener(this);
1082         mContentEditText.processChecklists();
1083         mContentEditText.addTextChangedListener(this);
1084     }
1085 
1086     /**
1087      * Set the note title to be a larger size and bold style.
1088      *
1089      * Remove all existing spans before applying spans or performance issues will occur.  Since both
1090      * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1091      * spans are removed when {@link MetricAffectingSpan} is removed.
1092      */
1093     private void setTitleSpan(Editable editable) {
<abbr title="1094         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {">1094         for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.classðŸ”µ</abbr>
1095             if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1096                 editable.removeSpan(span);
1097             }
1098         }
1099 
1100         int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1101 
1102         if (newLinePosition == 0) {
1103             return;
1104         }
1105 
1106         int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
<abbr title="1107         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1107         editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVðŸ”µ</abbr>
<abbr title="1108         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);">1108         editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSðŸ”µ</abbr>
1109     }
1110 
1111     private void attemptAutoList(Editable editable) {
1112         int oldCursorPosition = mCurrentCursorPosition;
1113         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1114         AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1115         mCurrentCursorPosition = mContentEditText.getSelectionStart();
1116     }
1117 
1118     private void saveAndSyncNote() {
1119         if (mNote == null) {
1120             return;
1121         }
1122 
1123         AppLog.add(
1124             Type.ACTION,
1125             &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1126                 &quot; / Title: &quot; + mNote.getTitle() +
1127                 &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1128                 &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1129         );
1130         new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1131     }
1132 
1133     public boolean isPlaceholderVisible() {
1134         if (mPlaceholderView != null) {
1135             return mPlaceholderView.getVisibility() == View.VISIBLE;
1136         } else {
1137             return false;
1138         }
1139     }
1140 
1141     public void setPlaceholderVisible(boolean isVisible) {
1142         if (isVisible) {
1143             mNote = null;
1144             mContentEditText.setText(&quot;&quot;);
1145         }
1146 
1147         if (mPlaceholderView != null) {
1148             mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1149         }
1150     }
1151 
1152     @Override
1153     public void onFocusChange(View v, boolean hasFocus) {
1154         if (!hasFocus) {
1155             String tags = getNoteTagsString().trim();
1156 
1157             if (mTagInput.getText().toString().trim().length() &gt; 0
1158                 &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1159                 onTagAdded(mTagInput.getText().toString());
1160             } else if (tags.length() &gt; 0) {
1161                 setChips(tags);
1162             }
1163         }
1164     }
1165 
1166     private Note getNote() {
1167         return mNote;
1168     }
1169 
1170     public void setNote(String noteID) {
1171         setNote(noteID, null);
1172     }
1173 
1174     private String getNoteContentString() {
1175         if (mContentEditText == null || mContentEditText.getText() == null) {
1176             return &quot;&quot;;
1177         } else {
1178             return mContentEditText.getText().toString();
1179         }
1180     }
1181 
1182     private String getNoteTagsString() {
1183         StringBuilder tags = new StringBuilder();
1184 
1185         for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1186             tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1187         }
1188 
1189         return tags.toString();
1190     }
1191 
1192     /**
1193      * Share bottom sheet callbacks
1194      */
1195 
1196     @Override
1197     public void onSharePublishClicked() {
1198         publishNote();
1199         if (mShareBottomSheet != null) {
1200             mShareBottomSheet.dismiss();
1201         }
1202     }
1203 
1204     @Override
1205     public void onShareUnpublishClicked() {
1206         unpublishNote();
1207         if (mShareBottomSheet != null) {
1208             mShareBottomSheet.dismiss();
1209         }
1210     }
1211 
1212     @Override
1213     public void onWordPressPostClicked() {
1214         if (mShareBottomSheet != null) {
1215             mShareBottomSheet.dismiss();
1216         }
1217 
1218         if (getFragmentManager() == null) {
1219             return;
1220         }
1221 
1222         FragmentTransaction ft = getFragmentManager().beginTransaction();
1223         Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1224         if (prev != null) {
1225             ft.remove(prev);
1226         }
1227         ft.addToBackStack(null);
1228 
1229         // Create and show the dialog.
1230         WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1231         wpDialogFragment.setNote(mNote);
1232         wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1233     }
1234 
1235     @Override
1236     public void onShareCollaborateClicked() {
1237         Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1238     }
1239 
1240     @Override
1241     public void onShareDismissed() {
1242 
1243     }
1244 
1245     /**
1246      * History bottom sheet listeners
1247      */
1248 
1249     @Override
1250     public void onHistoryCancelClicked() {
1251         mContentEditText.setText(mNote.getContent());
1252         if (mHistoryBottomSheet != null) {
1253             mHistoryBottomSheet.dismiss();
1254         }
1255     }
1256 
1257     @Override
1258     public void onHistoryRestoreClicked() {
1259         if (mHistoryBottomSheet != null) {
1260             mHistoryBottomSheet.dismiss();
1261         }
1262         saveAndSyncNote();
1263     }
1264 
1265     @Override
1266     public void onHistoryDismissed() {
1267         if (!mHistoryBottomSheet.didTapOnButton()) {
1268             mContentEditText.setText(mNote.getContent());
1269         }
1270 
1271         if (mHistoryTimeoutHandler != null) {
1272             mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1273         }
1274     }
1275 
1276     @Override
1277     public void onHistoryUpdateNote(String content) {
1278         mContentEditText.setText(content);
1279     }
1280 
1281     private void saveNote() {
1282         try {
1283             if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1284                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1284                 (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomðŸ”µ</abbr>
1285                 return;
1286             } else {
1287                 mNote = mNotesBucket.get(mNote.getSimperiumKey());
1288                 mIsPreviewEnabled = mNote.isPreviewEnabled();
1289             }
1290 
1291             String content = mContentEditText.getPlainTextContent();
1292             String tagString = getNoteTagsString();
1293 
<abbr title="1294             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1294             if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPrevðŸ”µ</abbr>
1295                 mNote.setContent(content);
1296                 mNote.setTagString(tagString);
1297                 mNote.setModificationDate(Calendar.getInstance());
1298                 mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1299                 mNote.setPreviewEnabled(mIsPreviewEnabled);
1300                 mNote.save();
1301 
1302                 AnalyticsTracker.track(
1303                     EDITOR_NOTE_EDITED,
1304                     CATEGORY_NOTE,
1305                     &quot;editor_save&quot;
1306                 );
1307 
1308                 AppLog.add(
1309                     Type.SYNC,
1310                     &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1311                         &quot; / Title: &quot; + mNote.getTitle() +
1312                         &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1313                         &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1314                 );
1315             }
1316         } catch (BucketObjectMissingException exception) {
1317             exception.printStackTrace();
1318         }
1319     }
1320 
1321     // Checks if cursor is at a URL when the selection changes
1322     // If it is a URL, show the contextual action bar
1323     @Override
1324     public void onSelectionChanged(int selStart, int selEnd) {
1325         mCurrentCursorPosition = selEnd;
1326 
1327         if (selStart == selEnd) {
1328             Editable noteContent = mContentEditText.getText();
1329 
1330             if (noteContent == null) {
1331                 return;
1332             }
1333 
1334             URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1335 
1336             if (urlSpans.length &gt; 0) {
1337                 URLSpan urlSpan = urlSpans[0];
1338                 mLinkUrl = urlSpan.getURL();
<abbr title="1339                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1339                 mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpaðŸ”µ</abbr>
1340 
1341                 if (mActionMode != null) {
1342                     mActionMode.setSubtitle(mLinkText);
1343                     updateMenuItems();
1344                     return;
1345                 }
1346 
1347                 // Show the Contextual Action Bar
1348                 if (getActivity() != null) {
<abbr title="1349                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);">1349                     mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCðŸ”µ</abbr>
1350 
1351                     if (mActionMode != null) {
1352                         mActionMode.setSubtitle(mLinkText);
1353                     }
1354 
1355                     updateMenuItems();
1356                 }
1357             } else if (mActionMode != null) {
1358                 mActionMode.finish();
1359                 mActionMode = null;
1360             }
1361         } else if (mActionMode != null) {
1362             mActionMode.finish();
1363             mActionMode = null;
1364         }
1365     }
1366 
1367     private void updateMenuItems() {
1368         mCopyMenuItem.setIcon(mCopyIcon);
1369         mShareMenuItem.setIcon(mShareIcon);
1370 
1371         if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1372             if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1373                 mViewLinkMenuItem.setIcon(mCallIcon);
1374                 mViewLinkMenuItem.setTitle(getString(R.string.call));
1375             } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1376                 mViewLinkMenuItem.setIcon(mEmailIcon);
1377                 mViewLinkMenuItem.setTitle(getString(R.string.email));
1378             } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1379                 mViewLinkMenuItem.setIcon(mMapIcon);
1380                 mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1381             } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1382                 mViewLinkMenuItem.setIcon(mLinkIcon);
1383                 mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1384             } else {
1385                 mViewLinkMenuItem.setIcon(mBrowserIcon);
1386                 mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1387             }
1388         }
1389     }
1390 
1391     private void setPublishedNote(boolean isPublished) {
1392         if (mNote != null) {
1393             mNote.setPublished(isPublished);
1394             mNote.save();
1395 
1396             // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1397             mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1398 
1399             AnalyticsTracker.track(
1400                 isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1401                 CATEGORY_NOTE,
1402                 &quot;publish_note_button&quot;
1403             );
1404         }
1405     }
1406 
1407     private void updatePublishedState(boolean isSuccess) {
1408         if (mPublishingSnackbar == null) {
1409             return;
1410         }
1411         mPublishingSnackbar.dismiss();
1412         mPublishingSnackbar = null;
1413         if (isSuccess &amp;&amp; isAdded()) {
1414             if (mNote.isPublished()) {
1415                 if (mHideActionOnSuccess) {
1416                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1417                 } else {
<abbr title="1418                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1418                     Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).setActionðŸ”µ</abbr>
1419                         @Override
1420                         public void onClick(View v) {
1421                             mHideActionOnSuccess = true;
1422                             unpublishNote();
1423                         }
1424                     }).show();
1425                 }
1426             } else if (mHideActionOnSuccess) {
1427                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1428             } else {
<abbr title="1429                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(R.string.undo, new View.OnClickListener() {">1429                 Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).setAction(RðŸ”µ</abbr>
1430                     @Override
1431                     public void onClick(View v) {
1432                         mHideActionOnSuccess = true;
1433                         publishNote();
1434                     }
1435                 }).show();
1436             }
1437         } else if (mNote.isPublished()) {
<abbr title="1438             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1438             Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG).setAction(R.string.rðŸ”µ</abbr>
1439                 @Override
1440                 public void onClick(View v) {
1441                     mHideActionOnSuccess = true;
1442                     unpublishNote();
1443                 }
1444             }).show();
1445         } else {
<abbr title="1446             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retry, new View.OnClickListener() {">1446             Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG).setAction(R.string.retðŸ”µ</abbr>
1447                 @Override
1448                 public void onClick(View v) {
1449                     mHideActionOnSuccess = true;
1450                     publishNote();
1451                 }
1452             }).show();
1453         }
1454         mHideActionOnSuccess = false;
1455         requireActivity().invalidateOptionsMenu();
1456     }
1457 
1458     private void publishNote() {
1459         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1460             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1461             return;
1462         }
1463 
1464         if (isAdded()) {
<abbr title="1465             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);">1465             mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITðŸ”µ</abbr>
1466             mPublishingSnackbar.show();
1467         }
1468 
1469         setPublishedNote(true);
1470     }
1471 
1472     private void unpublishNote() {
1473         if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1474             Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1475             return;
1476         }
1477 
1478         if (isAdded()) {
<abbr title="1479             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);">1479             mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINðŸ”µ</abbr>
1480             mPublishingSnackbar.show();
1481         }
1482 
1483         setPublishedNote(false);
1484     }
1485 
1486     private void showShare(String text) {
1487         startActivity(
1488             ShareCompat.IntentBuilder.from(requireActivity())
1489                 .setText(text)
1490                 .setType(&quot;text/plain&quot;)
1491                 .createChooserIntent()
1492         );
1493     }
1494 
1495     private void showShareSheet() {
1496         if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1497             mShareBottomSheet.show(requireFragmentManager(), mNote);
1498         }
1499     }
1500 
1501     private void showInfoSheet() {
1502         if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1503             mInfoBottomSheet.show(requireFragmentManager(), mNote);
1504         }
1505     }
1506 
1507     private void showHistorySheet() {
1508         if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1509             // Request revisions for the current note
<abbr title="1510             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());">1510             mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbaðŸ”µ</abbr>
1511             saveNote();
1512 
1513             mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1514         }
1515     }
1516 
1517     @Override
1518     public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1519     }
1520 
1521     @Override
<abbr title="1522     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {">1522     public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) ðŸ”µ</abbr>
1523         if (changeType == Bucket.ChangeType.MODIFY) {
1524             if ((getNote() != null) &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1525                 try {
1526                     final Note updatedNote = noteBucket.get(key);
1527                     if (getActivity() != null) {
1528                         getActivity().runOnUiThread(new Runnable() {
1529                             @Override
1530                             public void run() {
1531                                 if (mPublishTimeoutHandler != null) {
1532                                     mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1533                                 }
1534                                 updateNote(updatedNote);
1535                                 updatePublishedState(true);
1536                             }
1537                         });
1538                     }
1539                 } catch (BucketObjectMissingException e) {
1540                     e.printStackTrace();
1541                 }
1542             }
1543         }
1544     }
1545 
1546     @Override
1547     public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1548         if (mIsPaused) {
1549             mNotesBucket.removeListener(this);
1550             AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);
1551         }
<abbr title="1552         AppLog.add(Type.SYNC, (((((((&quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey()) + &quot; / Title: &quot;) + note.getTitle()) + &quot; / Characters: &quot;) + NoteUtils.getCharactersCount(note.getContent())) + &quot; / Words: &quot;) + NoteUtils.getWordCount(note.getContent())) + &quot;)&quot;);">1552         AppLog.add(Type.SYNC, (((((((&quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiuðŸ”µ</abbr>
1553     }
1554 
1555     @Override
1556     public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1557         // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1558         if (mIsLoadingNote)
1559             return;
1560 
1561         Note openNote = getNote();
1562         if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1563             return;
1564 
1565         note.setContent(mContentEditText.getPlainTextContent());
1566     }
1567 
1568     private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1569         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1570 
1571         LoadNoteTask(NoteEditorFragment fragment) {
1572             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1573         }
1574 
1575         @Override
1576         protected void onPreExecute() {
1577             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1578             if (fragment != null) {
1579                 fragment.mContentEditText.removeTextChangedListener(fragment);
1580                 fragment.mIsLoadingNote = true;
1581             }
1582         }
1583 
1584         @Override
1585         protected Void doInBackground(String... args) {
1586             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1587             if ((fragment == null) || (fragment.getActivity() == null)) {
1588                 return null;
1589             }
1590             String noteID = args[0];
1591             Simplenote application = ((Simplenote) (fragment.getActivity().getApplication()));
1592             Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1593             try {
1594                 fragment.mNote = notesBucket.get(noteID);
1595                 // Set the current note in NotesActivity when on a tablet
1596                 if (fragment.getActivity() instanceof NotesActivity) {
1597                     ((NotesActivity) (fragment.getActivity())).setCurrentNote(fragment.mNote);
1598                 }
1599                 // Set markdown and preview flags for current note
1600                 if (fragment.mNote != null) {
1601                     fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1602                     fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
<abbr title="1603                     AppLog.add(Type.SYNC, (((((((&quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey()) + &quot; / Title: &quot;) + fragment.mNote.getTitle()) + &quot; / Characters: &quot;) + NoteUtils.getCharactersCount(fragment.mNote.getContent())) + &quot; / Words: &quot;) + NoteUtils.getWordCount(fragment.mNote.getContent())) + &quot;)&quot;);">1603                     AppLog.add(Type.SYNC, (((((((&quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey()) ðŸ”µ</abbr>
1604                 }
1605             } catch (BucketObjectMissingException e) {
1606                 // See if the note is in the object store
1607                 Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1608                 while (notesCursor.moveToNext()) {
1609                     Note currentNote = notesCursor.getObject();
1610                     if ((currentNote != null) &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1611                         fragment.mNote = currentNote;
1612                         return null;
1613                     }
1614                 }
1615             }
1616             return null;
1617         }
1618 
1619         @Override
1620         protected void onPostExecute(Void nada) {
1621             final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1622             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFinishing()) {">1622             if (((fragment == null) || (fragment.getActivity() == null)) || fragment.getActivity().isFiniðŸ”µ</abbr>
1623                 return;
1624             }
1625             fragment.refreshContent(false);
1626             if (fragment.mMatchOffsets != null) {
<abbr title="1627                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1627                 int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndeðŸ”µ</abbr>
1628                 fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1629                 fragment.mShouldScrollToSearchMatch = true;
1630             }
1631             fragment.mContentEditText.addTextChangedListener(fragment);
1632             if ((fragment.mNote != null) &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1633                 // Show soft keyboard
1634                 fragment.mContentEditText.requestFocus();
1635                 new Handler().postDelayed(new Runnable() {
1636                     @Override
1637                     public void run() {
1638                         if (fragment.getActivity() == null) {
1639                             return;
1640                         }
<abbr title="1641                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE)));">1641                         InputMethodManager inputMethodManager = ((InputMethodManager) (fragment.getActiviðŸ”µ</abbr>
1642                         if (inputMethodManager != null) {
1643                             inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1644                         }
1645                     }
1646                 }, 100);
1647             } else if (fragment.mNote != null) {
1648                 // If we have a valid note, hide the placeholder
1649                 fragment.setPlaceholderVisible(false);
1650             }
1651             fragment.updateMarkdownView();
1652             fragment.requireActivity().invalidateOptionsMenu();
1653             fragment.linkifyEditorContent();
1654             fragment.mIsLoadingNote = false;
1655         }
1656     }
1657 
1658     private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1659         WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1660 
1661         SaveNoteTask(NoteEditorFragment fragment) {
1662             mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1663         }
1664 
1665         @Override
1666         protected Void doInBackground(Void... args) {
1667             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1668             if (fragment != null) {
1669                 fragment.saveNote();
1670             }
1671             return null;
1672         }
1673 
1674         @Override
1675         protected void onPostExecute(Void nada) {
1676             NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
<abbr title="1677             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFinishing())) {">1677             if (((fragment != null) &amp;&amp; (fragment.getActivity() != null)) &amp;&amp; (!fragment.getActivity().isFiðŸ”µ</abbr>
1678                 // Update links
1679                 fragment.linkifyEditorContent();
1680                 fragment.updateMarkdownView();
1681             }
1682         }
1683     }
1684 
1685     private void linkifyEditorContent() {
1686         if (getActivity() == null || getActivity().isFinishing()) {
1687             return;
1688         }
1689 
1690         if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1691             SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1692         }
1693     }
1694 
1695     // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1696     private void updateMarkdownView() {
1697         if (!mIsMarkdownEnabled) {
1698             return;
1699         }
1700 
1701         Activity activity = getActivity();
1702         if (activity instanceof NotesActivity) {
1703             // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1704             loadMarkdownData();
1705         } else {
1706             // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1707             if (mNoteMarkdownFragment == null) {
1708                 mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1709                         .getNoteMarkdownFragment();
1710                 ((NoteEditorActivity) requireActivity()).showTabs();
1711             }
1712             // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1713             mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1714         }
1715     }
1716 
1717     private ColorStateList getChipBackgroundColor() {
1718         int[][] states = new int[][] {
1719             new int[] { android.R.attr.state_checked}, // checked
1720             new int[] {-android.R.attr.state_checked}  // unchecked
1721         };
1722 
1723         int[] colors = new int[] {
1724             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1725             ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1726         };
1727 
1728         return new ColorStateList(states, colors);
1729     }
1730 
1731     private void setChips(CharSequence text) {
1732         mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1733         mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1734         mTagChips.setSingleSelection(true);
1735         mTagChips.removeAllViews();
1736         SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1737         tags.setString(text.toString());
1738 
1739         for (String tag : tags) {
1740             final Chip chip = new Chip(requireContext());
1741             chip.setText(tag);
1742             chip.setCheckable(true);
1743             chip.setCheckedIcon(null);
1744             chip.setChipBackgroundColor(getChipBackgroundColor());
1745             chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1746             chip.setStateListAnimator(null);
1747             chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1748                 @Override
1749                 public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1750                     chip.setCloseIconVisible(isChecked);
1751                 }
1752             });
1753             chip.setOnCloseIconClickListener(new View.OnClickListener() {
1754                 @Override
1755                 public void onClick(View view) {
1756                     mTagChips.removeView(view);
1757                     updateTags();
1758                     AnalyticsTracker.track(
1759                         EDITOR_TAG_REMOVED,
1760                         CATEGORY_NOTE,
1761                         &quot;tag_removed_from_note&quot;
1762                     );
1763                 }
1764             });
1765             mTagChips.addView(chip);
1766         }
1767     }
1768 
1769     private void updateTags() {
1770         if (mNote == null) {
1771             return;
1772         }
1773 
1774         mNote.setTagString(getNoteTagsString());
1775         mNote.setModificationDate(Calendar.getInstance());
1776         updateTagList();
1777         mNote.save();
1778     }
1779 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.Context;
   5  import android.content.SharedPreferences;
   6  import android.content.res.ColorStateList;
   7  import android.database.Cursor;
   8  import android.graphics.Typeface;
   9  import android.graphics.drawable.Drawable;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.Editable;
  14  import android.text.Layout;
  15  import android.text.Spanned;
  16  import android.text.TextUtils.SimpleStringSplitter;
  17  import android.text.TextWatcher;
  18  import android.text.style.MetricAffectingSpan;
  19  import android.text.style.RelativeSizeSpan;
  20  import android.text.style.StyleSpan;
  21  import android.text.style.URLSpan;
  22  import android.text.util.Linkify;
  23  import android.util.TypedValue;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.View;
  29  import android.view.ViewGroup;

  30  import android.view.ViewTreeObserver;
  31  import android.view.inputmethod.InputMethodManager;
  32  import android.webkit.WebResourceRequest;
  33  import android.webkit.WebView;
  34  import android.webkit.WebViewClient;
  35  import android.widget.CompoundButton;
  36  import android.widget.CursorAdapter;
  37  import android.widget.LinearLayout;
  38  import android.widget.TextView;
  39  import android.widget.Toast;
  40  
  41  import androidx.annotation.NonNull;
  42  import androidx.appcompat.app.AppCompatActivity;
  43  import androidx.appcompat.view.ActionMode;
  44  import androidx.core.app.ShareCompat;
  45  import androidx.core.view.MenuCompat;
  46  import androidx.core.widget.NestedScrollView;
  47  import androidx.fragment.app.Fragment;
  48  import androidx.fragment.app.FragmentTransaction;
  49  import androidx.preference.PreferenceManager;
  50  
  51  import com.automattic.simplenote.analytics.AnalyticsTracker;
  52  import com.automattic.simplenote.models.Note;
  53  import com.automattic.simplenote.models.Tag;
  54  import com.automattic.simplenote.utils.AppLog;
  55  import com.automattic.simplenote.utils.AppLog.Type;
  56  import com.automattic.simplenote.utils.AutoBullet;
  57  import com.automattic.simplenote.utils.BrowserUtils;
  58  import com.automattic.simplenote.utils.ContextUtils;
  59  import com.automattic.simplenote.utils.DisplayUtils;
  60  import com.automattic.simplenote.utils.DrawableUtils;
  61  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  62  import com.automattic.simplenote.utils.NetworkUtils;
  63  import com.automattic.simplenote.utils.NoteUtils;
  64  import com.automattic.simplenote.utils.PrefUtils;
  65  import com.automattic.simplenote.utils.SimplenoteLinkify;
  66  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  67  import com.automattic.simplenote.utils.SpaceTokenizer;
  68  import com.automattic.simplenote.utils.TagUtils;
  69  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  70  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  71  import com.automattic.simplenote.utils.TextHighlighter;
  72  import com.automattic.simplenote.utils.ThemeUtils;
  73  import com.automattic.simplenote.utils.WidgetUtils;
  74  import com.automattic.simplenote.widgets.SimplenoteEditText;
  75  import com.google.android.material.chip.Chip;
  76  import com.google.android.material.chip.ChipGroup;
  77  import com.google.android.material.snackbar.Snackbar;
  78  import com.simperium.client.Bucket;
  79  import com.simperium.client.BucketObjectMissingException;
  80  import com.simperium.client.Query;
  81  
  82  import java.lang.ref.WeakReference;
  83  import java.util.Calendar;
  84  
  85  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  91  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  92  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  93  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  94  import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  95  
  96  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  97          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  98          SimplenoteEditText.OnSelectionChangedListener,
  99          ShareBottomSheetDialog.ShareSheetListener,
 100          HistoryBottomSheetDialog.HistorySheetListener,
 101          SimplenoteEditText.OnCheckboxToggledListener {
 102  
 103      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 104      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 105      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 106      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 107      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 108      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 109  
 110      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 111      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 112      private static final int MAX_REVISIONS = 30;
 113      private static final int PUBLISH_TIMEOUT = 20000;
 114      private static final int HISTORY_TIMEOUT = 10000;
 115      private Note mNote;
 116      private final Runnable mAutoSaveRunnable = new Runnable() {
 117          @Override
 118          public void run() {
 119              saveAndSyncNote();
 120          }
 121      };
 122      private Bucket&lt;Note&gt; mNotesBucket;
 123      private View mRootView;
 124      private View mTagPadding;
 125      private SimplenoteEditText mContentEditText;
 126      private ChipGroup mTagChips;
 127      private TagsMultiAutoCompleteTextView mTagInput;
 128      private Handler mAutoSaveHandler;
 129      private Handler mPublishTimeoutHandler;
 130      private Handler mHistoryTimeoutHandler;
 131      private LinearLayout mPlaceholderView;
 132      private CursorAdapter mLinkAutocompleteAdapter;
 133      private CursorAdapter mTagAutocompleteAdapter;
 134      private boolean mIsLoadingNote;
 135      private boolean mIsMarkdownEnabled;
 136      private boolean mIsPreviewEnabled;
 137      private boolean mShouldScrollToSearchMatch;
 138      private ActionMode mActionMode;
 139      private MenuItem mChecklistMenuItem;
 140      private MenuItem mCopyMenuItem;
 141      private MenuItem mInformationMenuItem;
 142      private MenuItem mShareMenuItem;
 143      private MenuItem mViewLinkMenuItem;
 144      private String mLinkUrl;
 145      private String mLinkText;
 146      private MatchOffsetHighlighter mHighlighter;
 147      private Drawable mBrowserIcon;
 148      private Drawable mCallIcon;
 149      private Drawable mCopyIcon;
 150      private Drawable mEmailIcon;
 151      private Drawable mLinkIcon;
 152      private Drawable mMapIcon;
 153      private Drawable mShareIcon;
 154      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 155      private String mMatchOffsets;
 156      private int mCurrentCursorPosition;
 157      private HistoryBottomSheetDialog mHistoryBottomSheet;




 158      private boolean mIsPaused;
 159      private boolean mIsFromWidget;
 160  
 161      // Hides the history bottom sheet if no revisions are loaded
 162      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 163          @Override
 164          public void run() {
 165              if (!isAdded()) {
 166                  return;
 167              }
 168  
 169              requireActivity().runOnUiThread(new Runnable() {
 170                  @Override
 171                  public void run() {
<abbr title=" 172                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 172                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 173                          mHistoryBottomSheet.dismiss();
 174                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 175                      }
 176                  }
 177              });
 178          }
 179      };
 180      private InfoBottomSheetDialog mInfoBottomSheet;
 181      private ShareBottomSheetDialog mShareBottomSheet;
 182      // Contextual action bar for dealing with links
 183      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 184          // Called when the action mode is created; startActionMode() was called
 185          @Override
 186          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 187              // Inflate a menu resource providing context menu items
 188              MenuInflater inflater = mode.getMenuInflater();
 189  
 190              if (inflater != null) {
 191                  inflater.inflate(R.menu.view_link, menu);
 192                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 193                  mShareMenuItem = menu.findItem(R.id.menu_share);
 194                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 195                  mode.setTitle(getString(R.string.link));
 196                  mode.setTitleOptionalHint(false);
 197  
 198                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 199              }
 200  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 201 -            int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 201 -            int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 202 -            requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 202 -            requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 203 +            requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.mainBackgroundColor));"> 203 +            requireActivity().getWindow().setStatusBarColor(ThemeUtils.getColorFromAttribute(requireContext(), R.aðŸ”µ</abbr></span>
 204              return true;
 205          }
 206  
 207          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 208          // may be called multiple times if the mode is invalidated.
 209          @Override
 210          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 211              return false; // Return false if nothing is done
 212          }
 213  
 214          // Called when the user selects a contextual menu item
 215          @Override
 216          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 217              switch (item.getItemId()) {
 218                  case R.id.menu_view_link:
 219                      if (mLinkText != null) {
 220                          if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 221                              SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 221                              SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIXðŸ”µ</abbr>
 222                          } else {
 223                              try {
 224                                  BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 225                              } catch (Exception e) {
 226                                  e.printStackTrace();
 227                              }
 228                          }
 229  
 230                          mode.finish(); // Action picked, so close the CAB
 231                      }
 232  
 233                      return true;
 234                  case R.id.menu_copy:
 235                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 236                          if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 237                              Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 238                          } else {
 239                              Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 240                          }
 241  
 242                          mode.finish();
 243                      }
 244  
 245                      return true;
 246                  case R.id.menu_share:
 247                      if (mLinkText != null) {
 248                          showShare(mLinkText);
 249                          mode.finish();
 250                      }
 251  
 252                      return true;
 253                  default:
 254                      return false;
 255              }
 256          }
 257  
 258          // Called when the user exits the action mode
 259          @Override
 260          public void onDestroyActionMode(ActionMode mode) {
 261              if (mActionMode != null) {
 262                  mActionMode.setSubtitle(&quot;&quot;);
 263                  mActionMode = null;
 264              }
 265  
 266              new Handler().postDelayed(
 267                  new Runnable() {
 268                      @Override
 269                      public void run() {
<abbr title=" 270                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 270                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 271                      }
 272                  },
 273                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 274              );
 275          }
 276      };
 277      private Snackbar mPublishingSnackbar;
 278      private boolean mHideActionOnSuccess;
 279      // Resets note publish status if Simperium never returned the new publish status
 280      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 281          @Override
 282          public void run() {
 283              if (!isAdded()) return;
 284  
 285              requireActivity().runOnUiThread(new Runnable() {
 286                  @Override
 287                  public void run() {
 288  
 289                      mNote.setPublished(!mNote.isPublished());
 290                      mNote.save();
 291  
 292                      updatePublishedState(false);
 293                  }
 294              });
 295          }
 296      };
 297      private NoteMarkdownFragment mNoteMarkdownFragment;
 298      private String mCss;
 299      private WebView mMarkdown;
 300  
 301      /**
 302       * Mandatory empty constructor for the fragment manager to instantiate the
 303       * fragment (e.g. upon screen orientation changes).
 304       */
 305      public NoteEditorFragment() {
 306      }
 307  
 308      @Override
 309      public void onCreate(Bundle savedInstanceState) {
 310          super.onCreate(savedInstanceState);
 311          AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 312          AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 313          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 314          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 315          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 316  
 317          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 318          mNotesBucket = currentApp.getNotesBucket();
 319  
<abbr title=" 320          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 320          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 321          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 321          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>
<abbr title=" 322          mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 322          mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 323          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 323          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 324          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 324          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 325          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 325          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 326          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 326          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 327  
 328          mAutoSaveHandler = new Handler();
 329          mPublishTimeoutHandler = new Handler();
 330          mHistoryTimeoutHandler = new Handler();
 331  
 332          mMatchHighlighter = new TextHighlighter(requireActivity(),
 333                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 334          mTagAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 335              @Override
 336              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 337                  Activity activity = (Activity) context;
 338                  if (activity == null) return null;
 339                  return activity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 340              }
 341  
 342              @Override
 343              public void bindView(View view, Context context, Cursor cursor) {
 344                  TextView textView = (TextView) view;
 345                  textView.setText(convertToString(cursor));
 346              }
 347  
 348              @Override
 349              public CharSequence convertToString(Cursor cursor) {
 350                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 351              }
 352  
 353              @Override
 354              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 355                  Activity activity = getActivity();
 356                  if (activity == null) return null;
 357                  Simplenote application = (Simplenote) activity.getApplication();
 358                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 359                  // make the tag name available to the cursor
 360                  query.include(Tag.NAME_PROPERTY);
 361                  // sort the tags by their names
 362                  query.order(Tag.NAME_PROPERTY);
 363                  // if there&#x27;s a filter string find only matching tag names
 364                  if (filter != null)
 365                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 366                  return query.execute();
 367              }
 368          };
 369  
 370          mLinkAutocompleteAdapter = new CursorAdapter(getContext(), null, 0x0) {
 371              private Activity mActivity = requireActivity();
 372  
 373              @Override
 374              public void bindView(View view, Context context, Cursor cursor) {
 375                  ((TextView) view).setText(convertToString(cursor));
 376              }
 377  
 378              @Override
 379              public CharSequence convertToString(Cursor cursor) {
 380                  return cursor.getString(cursor.getColumnIndex(Note.TITLE_INDEX_NAME));
 381              }
 382  
 383              @Override
 384              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 385                  return mActivity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 386              }
 387  
 388              @Override
 389              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 390                  if (filter == null) {
 391                      return null;
 392                  }
 393  
 394                  Simplenote application = (Simplenote) mActivity.getApplication();
 395                  Query&lt;Note&gt; query = application.getNotesBucket().query();
 396                  query.include(Note.PINNED_INDEX_NAME);
 397                  query.include(Note.TITLE_INDEX_NAME);
 398                  query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filter));
 399                  PrefUtils.sortNoteQuery(query, requireContext(), true);
 400                  Cursor cursor = query.execute();
 401  
 402                  final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * 48);
 403                  final int heightDisplay = DisplayUtils.getDisplayPixelSize(requireContext()).y;
 404                  final int heightDropdown = Math.min(heightDisplay / 4, heightAutocomplete);
 405  
 406                  mActivity.runOnUiThread(
 407                      new Runnable() {
 408                          @Override
 409                          public void run() {
 410                              mContentEditText.setDropDownHeight(heightDropdown);
 411                          }
 412                      }
 413                  );
 414                  return cursor;
 415              }
 416          };
 417  
 418          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 419      }
 420  
 421      @Override
 422      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 423          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 424          mContentEditText = mRootView.findViewById(R.id.note_content);
 425          mContentEditText.addOnSelectionChangedListener(this);
 426          mContentEditText.setOnCheckboxToggledListener(this);
 427          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 428          mContentEditText.setOnFocusChangeListener(this);
 429          mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 430          mContentEditText.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 431          mContentEditText.setAdapter(mLinkAutocompleteAdapter);
 432          mTagInput = mRootView.findViewById(R.id.tag_input);
 433          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 434          mTagInput.setTokenizer(new SpaceTokenizer());
 435          mTagInput.setAdapter(mTagAutocompleteAdapter);
 436          mTagInput.setOnFocusChangeListener(this);
 437          mTagChips = mRootView.findViewById(R.id.tag_chips);
 438          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 439          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 440          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 441  
 442          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 443              mPlaceholderView.setVisibility(View.VISIBLE);
 444              requireActivity().invalidateOptionsMenu();
 445              mMarkdown = mRootView.findViewById(R.id.markdown);
 446              mMarkdown.setWebViewClient(
 447                  new WebViewClient() {
 448                      @Override
 449                      public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){
 450                          String url = request.getUrl().toString();
 451  
 452                          if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){
<abbr title=" 453                              SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 453                              SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;))ðŸ”µ</abbr>
 454                          } else {
 455                              BrowserUtils.launchBrowserOrShowError(requireContext(), url);

















 456                          }
 457  
 458                          return true;
 459                      }
 460                  }
 461              );
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -            mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -                ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -                : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +            mCss = ContextUtils.readCssFile(requireContext(), ThemeUtils.getCssFromStyle(requireContext()));</span>















 466          }
 467  
 468          Bundle arguments = getArguments();
 469  
 470          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 471              // Load note if we were passed a note Id
 472              String key = arguments.getString(ARG_ITEM_ID);
 473  
 474              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 475                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 476              }
 477  
 478              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 479  
 480              if (mIsFromWidget) {
 481                  AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 482              } else {
 483                  AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 484              }
 485  
 486              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 487          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 488              // Restore selected note when in dual pane mode
 489              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 490  
 491              if (noteId != null) {
 492                  setNote(noteId);
 493              }
 494          }
 495  
 496          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 497          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 498              @Override
 499              public void onGlobalLayout() {
 500                  // If a note was loaded with search matches, scroll to the first match in the editor
 501                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 502                      if (!isAdded()) {
 503                          return;
 504                      }
 505  
 506                      // Get the character location of the first search match
 507                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 508                              mContentEditText.getText(),
 509                              mMatchOffsets
 510                      );
 511                      if (matchLocation == 0) {
 512                          return;
 513                      }
 514  
 515                      // Calculate how far to scroll to bring the match into view
 516                      Layout layout = mContentEditText.getLayout();
 517                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 518                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 519                      mShouldScrollToSearchMatch = false;
 520                  }
 521              }
 522          });
 523          setHasOptionsMenu(true);
 524          return mRootView;
 525      }
 526  
 527      public void scrollToMatch(int location) {
 528          if (isAdded()) {
 529              // Calculate how far to scroll to bring the match into view
 530              Layout layout = mContentEditText.getLayout();
 531              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 532              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 533          }
 534      }
 535  
 536      @Override
 537      public void onResume() {
 538          super.onResume();

 539          mIsPaused = false;
 540          mNotesBucket.start();
 541          AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);
 542          mNotesBucket.addListener(this);

 543          mTagInput.setOnTagAddedListener(this);
 544  
 545          if (mContentEditText != null) {
 546              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 547  
 548              if (mContentEditText.hasFocus()) {
 549                  showSoftKeyboard();
 550              }










 551          }
 552      }
 553  
 554      private void showSoftKeyboard() {
 555          new Handler().postDelayed(new Runnable() {
 556              @Override
 557              public void run() {
 558                  if (getActivity() == null) {
 559                      return;
 560                  }
 561  
<abbr title=" 562                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 562                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 563                  if (inputMethodManager != null) {
 564                      inputMethodManager.showSoftInput(mContentEditText, 0);
 565                  }
 566              }
 567          }, 100);
 568      }
 569  
 570      @Override
 571      public void onPause() {
 572          super.onPause();  // Always call the superclass method first
 573          mIsPaused = true;
 574  
 575          // Hide soft keyboard if it is showing...
 576          DisplayUtils.hideKeyboard(mContentEditText);
 577  
 578          mTagInput.setOnTagAddedListener(null);
 579  
 580          if (mAutoSaveHandler != null) {
 581              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 582              mAutoSaveHandler.post(mAutoSaveRunnable);
 583          }
 584  
 585          if (mPublishTimeoutHandler != null) {
 586              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 587          }
 588  
 589          if (mHistoryTimeoutHandler != null) {
 590              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 591          }
 592  
 593          mHighlighter.stop();
 594          saveNote();
 595          AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 596      }
 597  
 598      @Override
 599      public void onDestroy() {
 600          super.onDestroy();
 601          mNotesBucket.removeListener(this);
 602          mNotesBucket.stop();
 603          AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);

 604          AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 605      }
 606  
 607      @Override
 608      public void onSaveInstanceState(@NonNull Bundle outState) {
 609          super.onSaveInstanceState(outState);
 610  
 611          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 612              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 613          }
 614      }
 615  
 616      @Override
 617      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 618          super.onCreateOptionsMenu(menu, inflater);
 619  
<abbr title=" 620          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 620          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 621              return;
 622          }
 623  
 624          inflater.inflate(R.menu.note_editor, menu);
 625          MenuCompat.setGroupDividerEnabled(menu, true);
 626      }
 627  
 628      @Override
 629      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 630          switch (item.getItemId()) {
 631              case R.id.menu_checklist:
 632                  insertChecklist();
 633                  return true;
 634              case R.id.menu_copy:
 635                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 636                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 637                  } else {
 638                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 639                  }
 640  
 641                  return true;
 642              case R.id.menu_copy_internal:
<abbr title=" 643                  if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 643                  if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.geðŸ”µ</abbr>
 644                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 645                  } else {
 646                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 647                  }
 648  
 649                  return true;
 650              case R.id.menu_history:
 651                  showHistory();
 652                  return true;
 653              case R.id.menu_info:
 654                  showInfo();
 655                  return true;
 656              case R.id.menu_markdown:
 657                  setMarkdown(!item.isChecked());
 658                  return true;
 659              case R.id.menu_pin:
 660                  NoteUtils.setNotePin(mNote, !item.isChecked());
 661                  requireActivity().invalidateOptionsMenu();
 662                  return true;
 663              case R.id.menu_publish:
 664                  if (item.isChecked()) {
 665                      unpublishNote();
 666                  } else {
 667                      publishNote();
 668                  }
 669  
 670                  return true;
 671              case R.id.menu_share:
 672                  shareNote();
 673                  return true;
 674              case R.id.menu_trash:
 675                  if (!isAdded()) {
 676                      return false;
 677                  }
 678  
 679                  deleteNote();
 680                  return true;
 681              case android.R.id.home:
 682                  AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 683                  if (!isAdded()) {
 684                      return false;
 685                  }
 686  
 687                  requireActivity().finish();
 688                  return true;
 689              default:
 690                  return super.onOptionsItemSelected(item);
 691          }
 692      }
 693  
 694      @Override
 695      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 696          if (mNote != null) {
 697              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 698              MenuItem shareItem = menu.findItem(R.id.menu_share);
 699              MenuItem historyItem = menu.findItem(R.id.menu_history);
 700              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 701              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 702              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 703              MenuItem trashItem = menu.findItem(R.id.menu_trash);
 704              mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 705              mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 706  
 707              pinItem.setChecked(mNote.isPinned());
 708              publishItem.setChecked(mNote.isPublished());
 709              markdownItem.setChecked(mNote.isMarkdownEnabled());
 710  
 711              // Disable actions when note is in Trash or markdown view is shown on large device.
 712              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 713                  pinItem.setEnabled(false);
 714                  shareItem.setEnabled(false);
 715                  historyItem.setEnabled(false);
 716                  publishItem.setEnabled(false);
 717                  copyLinkItem.setEnabled(false);
 718                  markdownItem.setEnabled(false);
 719                  mChecklistMenuItem.setEnabled(false);
 720                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 721              } else {
 722                  pinItem.setEnabled(true);
 723                  shareItem.setEnabled(true);
 724                  historyItem.setEnabled(true);
 725                  publishItem.setEnabled(true);
 726                  copyLinkItem.setEnabled(mNote.isPublished());
 727                  markdownItem.setEnabled(true);
 728                  mChecklistMenuItem.setEnabled(true);
 729                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 730              }
 731  
 732              if (mNote.isDeleted()) {
 733                  trashItem.setTitle(R.string.restore);
 734              } else {
 735                  trashItem.setTitle(R.string.trash);
 736              }
 737          }
 738  
 739          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 740          super.onPrepareOptionsMenu(menu);
 741      }
 742  
 743      public void insertChecklist() {
 744          DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 745  
 746          try {
 747              mContentEditText.insertChecklist();
 748          } catch (Exception e) {
 749              e.printStackTrace();
 750              return;
 751          }
 752  
 753          AnalyticsTracker.track(
 754              EDITOR_CHECKLIST_INSERTED,
 755              CATEGORY_NOTE,
 756              &quot;toolbar_button&quot;
 757          );
 758      }
 759  
 760      @Override
 761      public void onCheckboxToggled() {
 762          // Save note (using delay) after toggling a checkbox
 763          if (mAutoSaveHandler != null) {
 764              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 765              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 766          }
 767      }
 768  
 769      private void deleteNote() {
 770          NoteUtils.deleteNote(mNote, getActivity());
 771          requireActivity().finish();
 772      }
 773  
 774      protected void clearMarkdown() {
 775          mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);



 776      }
 777  
 778      protected void hideMarkdown() {
 779          mMarkdown.setVisibility(View.INVISIBLE);





 780      }
 781  
 782      protected void showMarkdown() {
 783          loadMarkdownData();
 784          mMarkdown.setVisibility(View.VISIBLE);






 785  
 786          new Handler().postDelayed(
 787              new Runnable() {
 788                  @Override
 789                  public void run() {
 790                      requireActivity().invalidateOptionsMenu();
 791                  }
 792              },
 793              getResources().getInteger(R.integer.time_animation)
 794          );
 795      }
 796  
 797      public void shareNote() {
 798          if (mNote != null) {
 799              mContentEditText.clearFocus();
 800              showShareSheet();
 801              AnalyticsTracker.track(
 802                  EDITOR_NOTE_CONTENT_SHARED,
 803                  CATEGORY_NOTE,
 804                  &quot;action_bar_share_button&quot;
 805              );
 806          }
 807      }
 808  
 809      public void showHistory() {
 810          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 811              mContentEditText.clearFocus();
 812              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 813              showHistorySheet();
 814          } else {
 815              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 816          }
 817      }
 818  
 819      public void showInfo() {
 820          DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 821  
 822          if (mNote != null) {
 823              mContentEditText.clearFocus();
 824              saveNote();
 825              showInfoSheet();
 826          }
 827      }
 828  
 829      private void setMarkdown(boolean isChecked) {
 830          mIsMarkdownEnabled = isChecked;
 831          showMarkdownActionOrTabs();
 832          saveNote();
 833  
 834          // Set preference so that next new note will have markdown enabled.
 835          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 836          SharedPreferences.Editor editor = prefs.edit();
 837          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 838          editor.apply();
 839      }
 840  
 841      private void setMarkdownEnabled(boolean enabled) {
 842          mIsMarkdownEnabled = enabled;
 843  
 844          if (mIsMarkdownEnabled) {
 845              loadMarkdownData();
 846          }
 847      }
 848  
 849      private void showMarkdownActionOrTabs() {
 850          Activity activity = getActivity();
 851  
 852          if (activity instanceof NoteEditorActivity) {
 853              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 854  
 855              if (mIsMarkdownEnabled) {
 856                  editorActivity.showTabs();
 857  
 858                  if (mNoteMarkdownFragment == null) {
 859                      // Get markdown fragment and update content
 860                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 861                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 862                  }
 863              } else {
 864                  editorActivity.hideTabs();
 865              }
 866          } else if (activity instanceof NotesActivity) {
 867              setMarkdownEnabled(mIsMarkdownEnabled);
 868              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 869          }
 870      }
 871  
 872      private void loadMarkdownData() {
 873          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
 874                  mCss,
 875                  mContentEditText.getPreviewTextContent()


 876          );
 877  
 878          mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);



 879      }
 880  
 881      public void setNote(String noteID, String matchOffsets) {
 882          if (mAutoSaveHandler != null)

 883              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);

 884  
 885          mPlaceholderView.setVisibility(View.GONE);
 886  
 887          if (matchOffsets != null) {
 888              mMatchOffsets = matchOffsets;
 889          } else {
 890              mMatchOffsets = null;
 891          }
 892  
 893  

 894          saveNote();
 895  
 896          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 897      }
 898  
 899      private void updateNote(Note updatedNote) {
 900          // update note if network change arrived
 901          mNote = updatedNote;
 902          refreshContent(true);
 903      }
 904  
 905      private void refreshContent(boolean isNoteUpdate) {
 906          if (mNote != null) {
 907              // Restore the cursor position if possible.
<abbr title=" 908              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 908              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 909              mContentEditText.setText(mNote.getContent());
 910  
 911              if (isNoteUpdate) {
 912                  // Update markdown and preview flags from updated note.
 913                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 914                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 915  
 916                  // Show/Hide action/tabs based on markdown flag.
 917                  showMarkdownActionOrTabs();
 918  
 919                  // Save note so any local changes get synced.
 920                  mNote.save();
 921  
 922                  // Update current note object on large screen devices in landscape orientation.
 923                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 924                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 925                  }
 926  
 927                  // Update overflow popup menu.
 928                  requireActivity().invalidateOptionsMenu();
 929  
 930                  if (mContentEditText.hasFocus()
 931                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
 932                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
 933                      mContentEditText.setSelection(cursorPosition);
 934                  }
 935              }
 936  
 937              afterTextChanged(mContentEditText.getText());
 938              mContentEditText.processChecklists();
 939              updateTagList();
 940          }
 941      }
 942  
 943      private void updateTagList() {
 944          setChips(mNote.getTagString());
 945          mTagInput.setText(&quot;&quot;);
 946      }
 947  
 948      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
 949          // Ported from the iOS app :)
 950          // Cases:
 951          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
 952          // 1. Text was added after the cursor ==&gt; no change
 953          // 2. Text was added before the cursor ==&gt; location advances
 954          // 3. Text was removed after the cursor ==&gt; no change
 955          // 4. Text was removed before the cursor ==&gt; location retreats
 956          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
 957  
 958          cursorLocation = Math.max(cursorLocation, 0);
 959  
 960          int newCursorLocation = cursorLocation;
 961  
 962          int deltaLength = newText.length() - oldText.length();
 963  
 964          // Case 0
 965          if (newText.length() &lt; cursorLocation)
 966              return newText.length();
 967  
 968          boolean beforeCursorMatches = false;
 969          boolean afterCursorMatches = false;
 970  
 971          try {
<abbr title=" 972              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));"> 972              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title=" 973              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));"> 973              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
 974          } catch (Exception e) {
 975              e.printStackTrace();
 976          }
 977  
 978          // Cases 2 and 4
 979          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
 980              newCursorLocation += deltaLength;
 981  
 982          // Cases 1, 3 and 5 have no change
 983          return newCursorLocation;
 984      }
 985  
 986      @Override
 987      public void onTagAdded(String tag) {
 988          if (mNote == null || !isAdded()) {
 989              return;
 990          }
 991  
 992          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
 993              AnalyticsTracker.track(
 994                  EDITOR_TAG_ADDED,
 995                  CATEGORY_NOTE,
 996                  &quot;tag_added_to_note&quot;
 997              );
 998          }
 999  
1000          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
1001          mNote.setModificationDate(Calendar.getInstance());
1002          updateTagList();
1003          mNote.save();
1004      }
1005  
1006      @Override
1007      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
1008          // Unused
1009      }
1010  
1011      @Override
1012      public void afterTextChanged(Editable editable) {
1013          attemptAutoList(editable);
1014          setTitleSpan(editable);
1015          mContentEditText.fixLineSpacing();
1016      }
1017  
1018      @Override
1019      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1020          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1021          if (mAutoSaveHandler != null) {
1022              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1023              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1024          }
1025  
1026          // Remove search highlight spans when note content changes
1027          if (mMatchOffsets != null) {
1028              mMatchOffsets = null;
1029              mHighlighter.removeMatches();
1030          }
1031  
1032          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1033              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1034          }
1035  
1036          // Temporarily remove the text watcher as we process checklists to prevent callback looping
1037          mContentEditText.removeTextChangedListener(this);
1038          mContentEditText.processChecklists();
1039          mContentEditText.addTextChangedListener(this);
1040      }
1041  
1042      /**
1043       * Set the note title to be a larger size and bold style.
1044       *
1045       * Remove all existing spans before applying spans or performance issues will occur.  Since both
1046       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1047       * spans are removed when {@link MetricAffectingSpan} is removed.
1048       */
1049      private void setTitleSpan(Editable editable) {
1050          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
1051              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1052                  editable.removeSpan(span);
1053              }
1054          }
1055  
1056          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1057  
1058          if (newLinePosition == 0) {
1059              return;
1060          }
1061  
1062          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
1063          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1064          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1065      }
1066  
1067      private void attemptAutoList(Editable editable) {
1068          int oldCursorPosition = mCurrentCursorPosition;
1069          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1070          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1071          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1072      }
1073  
1074      private void saveAndSyncNote() {
1075          if (mNote == null) {
1076              return;
1077          }
1078  
1079          AppLog.add(
1080              Type.ACTION,
1081              &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1082                  &quot; / Title: &quot; + mNote.getTitle() +
1083                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1084                  &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1085          );
1086          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1087      }
1088  
1089      public boolean isPlaceholderVisible() {
1090          if (mPlaceholderView != null) {
1091              return mPlaceholderView.getVisibility() == View.VISIBLE;
1092          } else {
1093              return false;
1094          }
1095      }
1096  
1097      public void setPlaceholderVisible(boolean isVisible) {
1098          if (isVisible) {
1099              mNote = null;
1100              mContentEditText.setText(&quot;&quot;);
1101          }
1102  
1103          if (mPlaceholderView != null) {
1104              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1105          }
1106      }
1107  
1108      @Override
1109      public void onFocusChange(View v, boolean hasFocus) {
1110          if (!hasFocus) {
1111              String tags = getNoteTagsString().trim();
1112  
1113              if (mTagInput.getText().toString().trim().length() &gt; 0
1114                  &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1115                  onTagAdded(mTagInput.getText().toString());
1116              } else if (tags.length() &gt; 0) {
1117                  setChips(tags);
1118              }
1119          }
1120      }
1121  
1122      private Note getNote() {
1123          return mNote;
1124      }
1125  
1126      public void setNote(String noteID) {
1127          setNote(noteID, null);
1128      }
1129  
1130      private String getNoteContentString() {
1131          if (mContentEditText == null || mContentEditText.getText() == null) {
1132              return &quot;&quot;;
1133          } else {
1134              return mContentEditText.getText().toString();
1135          }
1136      }
1137  
1138      private String getNoteTagsString() {
1139          StringBuilder tags = new StringBuilder();
1140  
1141          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1142              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1143          }
1144  
1145          return tags.toString();
1146      }
1147  
1148      /**
1149       * Share bottom sheet callbacks
1150       */
1151  
1152      @Override
1153      public void onSharePublishClicked() {
1154          publishNote();
1155          if (mShareBottomSheet != null) {
1156              mShareBottomSheet.dismiss();
1157          }
1158      }
1159  
1160      @Override
1161      public void onShareUnpublishClicked() {
1162          unpublishNote();
1163          if (mShareBottomSheet != null) {
1164              mShareBottomSheet.dismiss();
1165          }
1166      }
1167  
1168      @Override
1169      public void onWordPressPostClicked() {
1170          if (mShareBottomSheet != null) {
1171              mShareBottomSheet.dismiss();
1172          }
1173  
1174          if (getFragmentManager() == null) {
1175              return;
1176          }
1177  
1178          FragmentTransaction ft = getFragmentManager().beginTransaction();
1179          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1180          if (prev != null) {
1181              ft.remove(prev);
1182          }
1183          ft.addToBackStack(null);
1184  
1185          // Create and show the dialog.
1186          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1187          wpDialogFragment.setNote(mNote);
1188          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1189      }
1190  
1191      @Override
1192      public void onShareCollaborateClicked() {
1193          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1194      }
1195  
1196      @Override
1197      public void onShareDismissed() {
1198  
1199      }
1200  
1201      /**
1202       * History bottom sheet listeners
1203       */
1204  
1205      @Override
1206      public void onHistoryCancelClicked() {
1207          mContentEditText.setText(mNote.getContent());
1208          if (mHistoryBottomSheet != null) {
1209              mHistoryBottomSheet.dismiss();
1210          }
1211      }
1212  
1213      @Override
1214      public void onHistoryRestoreClicked() {
1215          if (mHistoryBottomSheet != null) {
1216              mHistoryBottomSheet.dismiss();
1217          }
1218          saveAndSyncNote();
1219      }
1220  
1221      @Override
1222      public void onHistoryDismissed() {
1223          if (!mHistoryBottomSheet.didTapOnButton()) {
1224              mContentEditText.setText(mNote.getContent());
1225          }
1226  
1227          if (mHistoryTimeoutHandler != null) {
1228              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1229          }
1230      }
1231  
1232      @Override
1233      public void onHistoryUpdateNote(String content) {
1234          mContentEditText.setText(content);
1235      }
1236  
1237      private void saveNote() {
1238          try {
1239              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1240                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1240                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1241                  return;
1242              } else {
1243                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1244                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1245              }
1246  
1247              String content = mContentEditText.getPlainTextContent();
1248              String tagString = getNoteTagsString();
1249  
<abbr title="1250              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1250              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1251                  mNote.setContent(content);
1252                  mNote.setTagString(tagString);
1253                  mNote.setModificationDate(Calendar.getInstance());
1254                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1255                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1256                  mNote.save();
1257  
1258                  AnalyticsTracker.track(
1259                      EDITOR_NOTE_EDITED,
1260                      CATEGORY_NOTE,
1261                      &quot;editor_save&quot;
1262                  );
1263  
1264                  AppLog.add(
1265                      Type.SYNC,
1266                      &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1267                          &quot; / Title: &quot; + mNote.getTitle() +
1268                          &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1269                          &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1270                  );
1271              }
1272          } catch (BucketObjectMissingException exception) {
1273              exception.printStackTrace();
1274          }
1275      }
1276  
1277      // Checks if cursor is at a URL when the selection changes
1278      // If it is a URL, show the contextual action bar
1279      @Override
1280      public void onSelectionChanged(int selStart, int selEnd) {
1281          mCurrentCursorPosition = selEnd;
1282  
1283          if (selStart == selEnd) {
1284              Editable noteContent = mContentEditText.getText();
1285  
1286              if (noteContent == null) {
1287                  return;
1288              }
1289  
1290              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1291  
1292              if (urlSpans.length &gt; 0) {
1293                  URLSpan urlSpan = urlSpans[0];
1294                  mLinkUrl = urlSpan.getURL();
<abbr title="1295                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1295                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1296  
1297                  if (mActionMode != null) {
1298                      mActionMode.setSubtitle(mLinkText);
1299                      updateMenuItems();
1300                      return;
1301                  }
1302  
1303                  // Show the Contextual Action Bar
1304                  if (getActivity() != null) {
1305                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1306  
1307                      if (mActionMode != null) {
1308                          mActionMode.setSubtitle(mLinkText);
1309                      }
1310  
1311                      updateMenuItems();
1312                  }
1313              } else if (mActionMode != null) {
1314                  mActionMode.finish();
1315                  mActionMode = null;
1316              }
1317          } else if (mActionMode != null) {
1318              mActionMode.finish();
1319              mActionMode = null;
1320          }
1321      }
1322  
1323      private void updateMenuItems() {
1324          mCopyMenuItem.setIcon(mCopyIcon);
1325          mShareMenuItem.setIcon(mShareIcon);
1326  
1327          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1328              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1329                  mViewLinkMenuItem.setIcon(mCallIcon);
1330                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1331              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1332                  mViewLinkMenuItem.setIcon(mEmailIcon);
1333                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1334              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1335                  mViewLinkMenuItem.setIcon(mMapIcon);
1336                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1337              } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1338                  mViewLinkMenuItem.setIcon(mLinkIcon);
1339                  mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1340              } else {
1341                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1342                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1343              }
1344          }
1345      }
1346  
1347      private void setPublishedNote(boolean isPublished) {
1348          if (mNote != null) {
1349              mNote.setPublished(isPublished);
1350              mNote.save();
1351  
1352              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1353              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1354  
1355              AnalyticsTracker.track(
1356                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1357                  CATEGORY_NOTE,
1358                  &quot;publish_note_button&quot;
1359              );
1360          }
1361      }
1362  
1363      private void updatePublishedState(boolean isSuccess) {
1364          if (mPublishingSnackbar == null) {
1365              return;
1366          }
1367  
1368          mPublishingSnackbar.dismiss();
1369          mPublishingSnackbar = null;
1370  
1371          if (isSuccess &amp;&amp; isAdded()) {
1372              if (mNote.isPublished()) {
1373                  if (mHideActionOnSuccess) {
1374                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1375                  } else {
1376                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1377                          .setAction(
1378                              R.string.undo,
1379                              new View.OnClickListener() {
1380                                  @Override
1381                                  public void onClick(View v) {
1382                                      mHideActionOnSuccess = true;
1383                                      unpublishNote();
1384                                  }
1385                              }
1386                          )
1387                          .show();
1388                  }
1389              } else {
1390                  if (mHideActionOnSuccess) {
1391                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1392                  } else {
1393                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1394                          .setAction(
1395                              R.string.undo,
1396                              new View.OnClickListener() {
1397                                  @Override
1398                                  public void onClick(View v) {
1399                                      mHideActionOnSuccess = true;
1400                                      publishNote();
1401                                  }
1402                              }
1403                          )
1404                          .show();
1405                  }
1406              }
1407          } else {
1408              if (mNote.isPublished()) {
1409                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1410                      .setAction(
1411                          R.string.retry,
1412                          new View.OnClickListener() {
1413                              @Override
1414                              public void onClick(View v) {
1415                                  mHideActionOnSuccess = true;
1416                                  unpublishNote();
1417                              }
1418                          }
1419                      )
1420                      .show();
1421              } else {
1422                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1423                      .setAction(
1424                          R.string.retry,
1425                          new View.OnClickListener() {
1426                              @Override
1427                              public void onClick(View v) {
1428                                  mHideActionOnSuccess = true;
1429                                  publishNote();
1430                              }
1431                          }
1432                      )
1433                      .show();
1434              }
1435          }
1436  
1437          mHideActionOnSuccess = false;
1438          requireActivity().invalidateOptionsMenu();
1439      }
1440  
1441      private void publishNote() {
1442          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1443              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1444              return;
1445          }
1446  
1447          if (isAdded()) {
1448              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1449              mPublishingSnackbar.show();
1450          }
1451  
1452          setPublishedNote(true);
1453      }
1454  
1455      private void unpublishNote() {
1456          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1457              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1458              return;
1459          }
1460  
1461          if (isAdded()) {
1462              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1463              mPublishingSnackbar.show();
1464          }
1465  
1466          setPublishedNote(false);
1467      }
1468  
1469      private void showShare(String text) {
1470          startActivity(
1471              ShareCompat.IntentBuilder.from(requireActivity())
1472                  .setText(text)
1473                  .setType(&quot;text/plain&quot;)
1474                  .createChooserIntent()
1475          );
1476      }
1477      private void showShareSheet() {
1478          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1479              mShareBottomSheet.show(requireFragmentManager(), mNote);
1480          }
1481      }
1482  
1483      private void showInfoSheet() {
1484          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1485              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1486          }
1487      }
1488  
1489      private void showHistorySheet() {
1490          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1491              // Request revisions for the current note
1492              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1493              saveNote();
1494  
1495              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1496          }
1497      }
1498  
1499      @Override
1500      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1501      }
1502  
1503      @Override
1504      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1505          if (changeType == Bucket.ChangeType.MODIFY) {
1506              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1507                  try {
1508                      mNotesBucket = noteBucket;
1509                      final Note updatedNote = mNotesBucket.get(key);


1510                      if (getActivity() != null) {
1511                          getActivity().runOnUiThread(new Runnable() {
1512                              @Override
1513                              public void run() {
1514                                  if (mPublishTimeoutHandler != null) {
1515                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1516                                  }
1517  
1518                                  updateNote(updatedNote);
1519                                  updatePublishedState(true);
1520                              }
1521                          });
1522                      }
1523                  } catch (BucketObjectMissingException e) {
1524                      e.printStackTrace();
1525                  }
1526              }
1527          }
1528      }
1529  
1530      @Override
1531      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1532          if (mIsPaused) {
1533              mNotesBucket.removeListener(this);
1534              mNotesBucket.stop();
1535              AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);

1536          }
1537  
1538          AppLog.add(
1539              Type.SYNC,
1540              &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1541                  &quot; / Title: &quot; + note.getTitle() +
1542                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1543                  &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1544          );
1545      }
1546  
1547      @Override
1548      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1549          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1550          if (mIsLoadingNote)
1551              return;
1552  
1553          Note openNote = getNote();
1554          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1555              return;
1556  
1557          note.setContent(mContentEditText.getPlainTextContent());
1558      }
1559  
1560      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1561          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1562  
1563          LoadNoteTask(NoteEditorFragment fragment) {
1564              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1565          }
1566  
1567          @Override
1568          protected void onPreExecute() {
1569              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1570  
1571              if (fragment != null) {
1572                  fragment.mContentEditText.removeTextChangedListener(fragment);
1573                  fragment.mIsLoadingNote = true;
1574              }
1575          }
1576  
1577          @Override
1578          protected Void doInBackground(String... args) {
1579              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1580  
1581              if (fragment == null || fragment.getActivity() == null) {
1582                  return null;
1583              }
1584  
1585              String noteID = args[0];
1586              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1587              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1588  
1589              try {
1590                  fragment.mNote = notesBucket.get(noteID);
1591  
1592                  // Set the current note in NotesActivity when on a tablet
1593                  if (fragment.getActivity() instanceof NotesActivity) {
1594                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1595                  }
1596  
1597                  // Set markdown and preview flags for current note
1598                  if (fragment.mNote != null) {
1599                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1600                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1601                      AppLog.add(
1602                          Type.SYNC,
1603                          &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1604                              &quot; / Title: &quot; + fragment.mNote.getTitle() +
1605                              &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +
1606                              &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1607                      );
1608                  }
1609              } catch (BucketObjectMissingException e) {
1610                  // See if the note is in the object store
1611                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1612  
1613                  while (notesCursor.moveToNext()) {
1614                      Note currentNote = notesCursor.getObject();
1615  
1616                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1617                          fragment.mNote = currentNote;
1618                          return null;
1619                      }
1620                  }
1621              }
1622  
1623              return null;
1624          }
1625  
1626          @Override
1627          protected void onPostExecute(Void nada) {
1628              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1629              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1630                  return;
1631              }
1632  
1633              fragment.refreshContent(false);
1634  
1635              if (fragment.mMatchOffsets != null) {
<abbr title="1636                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1636                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1637                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1638                  fragment.mShouldScrollToSearchMatch = true;
1639              }
1640  
1641              fragment.mContentEditText.addTextChangedListener(fragment);
1642  
1643              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1644                  // Show soft keyboard
1645                  fragment.mContentEditText.requestFocus();
1646  
1647                  new Handler().postDelayed(new Runnable() {
1648                      @Override
1649                      public void run() {
1650                          if (fragment.getActivity() == null) {
1651                              return;
1652                          }
1653  
<abbr title="1654                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1654                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1655  
1656                          if (inputMethodManager != null) {
1657                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1658                          }
1659                      }
1660                  }, 100);
1661              } else if (fragment.mNote != null) {
1662                  // If we have a valid note, hide the placeholder
1663                  fragment.setPlaceholderVisible(false);
1664              }
1665  
1666              fragment.updateMarkdownView();
1667              fragment.requireActivity().invalidateOptionsMenu();
1668              fragment.linkifyEditorContent();
1669              fragment.mIsLoadingNote = false;
1670          }
1671      }
1672  
1673      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1674          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1675  
1676          SaveNoteTask(NoteEditorFragment fragment) {
1677              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1678          }
1679  
1680          @Override
1681          protected Void doInBackground(Void... args) {
1682              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1683  
1684              if (fragment != null) {
1685                  fragment.saveNote();
1686              }
1687  
1688              return null;
1689          }
1690  
1691          @Override
1692          protected void onPostExecute(Void nada) {
1693              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1694  
1695              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1696                  // Update links
1697                  fragment.linkifyEditorContent();
1698                  fragment.updateMarkdownView();
1699              }
1700          }
1701      }
1702  
1703      private void linkifyEditorContent() {
1704          if (getActivity() == null || getActivity().isFinishing()) {
1705              return;
1706          }
1707  
1708          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1709              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1710          }
1711      }
1712  
1713      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1714      private void updateMarkdownView() {
1715          if (!mIsMarkdownEnabled) {
1716              return;
1717          }
1718  
1719          Activity activity = getActivity();
1720          if (activity instanceof NotesActivity) {
1721              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1722              loadMarkdownData();
1723          } else {
1724              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1725              if (mNoteMarkdownFragment == null) {
1726                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1727                          .getNoteMarkdownFragment();
1728                  ((NoteEditorActivity) requireActivity()).showTabs();
1729              }
1730              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1731              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1732          }
1733      }
1734  
1735      private ColorStateList getChipBackgroundColor() {
1736          int[][] states = new int[][] {
1737              new int[] { android.R.attr.state_checked}, // checked
1738              new int[] {-android.R.attr.state_checked}  // unchecked
1739          };
1740  
1741          int[] colors = new int[] {
1742              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1743              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1744          };
1745  
1746          return new ColorStateList(states, colors);
1747      }
1748  
1749      private void setChips(CharSequence text) {
1750          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1751          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1752          mTagChips.setSingleSelection(true);
1753          mTagChips.removeAllViews();
1754          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1755          tags.setString(text.toString());
1756  
1757          for (String tag : tags) {
1758              final Chip chip = new Chip(requireContext());
1759              chip.setText(tag);
1760              chip.setCheckable(true);
1761              chip.setCheckedIcon(null);
1762              chip.setChipBackgroundColor(getChipBackgroundColor());
1763              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1764              chip.setStateListAnimator(null);
1765              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1766                  @Override
1767                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1768                      chip.setCloseIconVisible(isChecked);
1769                  }
1770              });
1771              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1772                  @Override
1773                  public void onClick(View view) {
1774                      mTagChips.removeView(view);
1775                      updateTags();
1776                      AnalyticsTracker.track(
1777                          EDITOR_TAG_REMOVED,
1778                          CATEGORY_NOTE,
1779                          &quot;tag_removed_from_note&quot;
1780                      );
1781                  }
1782              });
1783              mTagChips.addView(chip);
1784          }
1785      }
1786  
1787      private void updateTags() {
1788          if (mNote == null) {
1789              return;
1790          }
1791  
1792          mNote.setTagString(getNoteTagsString());
1793          mNote.setModificationDate(Calendar.getInstance());
1794          updateTagList();
1795          mNote.save();
1796      }
1797  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote;
   2  
   3  import android.app.Activity;
   4  import android.content.Context;
   5  import android.content.SharedPreferences;
   6  import android.content.res.ColorStateList;
   7  import android.database.Cursor;
   8  import android.graphics.Typeface;
   9  import android.graphics.drawable.Drawable;
  10  import android.os.AsyncTask;
  11  import android.os.Bundle;
  12  import android.os.Handler;
  13  import android.text.Editable;
  14  import android.text.Layout;
  15  import android.text.Spanned;
  16  import android.text.TextUtils.SimpleStringSplitter;
  17  import android.text.TextWatcher;
  18  import android.text.style.MetricAffectingSpan;
  19  import android.text.style.RelativeSizeSpan;
  20  import android.text.style.StyleSpan;
  21  import android.text.style.URLSpan;
  22  import android.text.util.Linkify;
  23  import android.util.TypedValue;
  24  import android.view.LayoutInflater;
  25  import android.view.Menu;
  26  import android.view.MenuInflater;
  27  import android.view.MenuItem;
  28  import android.view.View;
  29  import android.view.ViewGroup;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.view.ViewStub;</span>
  31  import android.view.ViewTreeObserver;
  32  import android.view.inputmethod.InputMethodManager;
  33  import android.webkit.WebResourceRequest;
  34  import android.webkit.WebView;
  35  import android.webkit.WebViewClient;
  36  import android.widget.CompoundButton;
  37  import android.widget.CursorAdapter;
  38  import android.widget.LinearLayout;
  39  import android.widget.TextView;
  40  import android.widget.Toast;
  41  
  42  import androidx.annotation.NonNull;
  43  import androidx.appcompat.app.AppCompatActivity;
  44  import androidx.appcompat.view.ActionMode;
  45  import androidx.core.app.ShareCompat;
  46  import androidx.core.view.MenuCompat;
  47  import androidx.core.widget.NestedScrollView;
  48  import androidx.fragment.app.Fragment;
  49  import androidx.fragment.app.FragmentTransaction;
  50  import androidx.preference.PreferenceManager;
  51  
  52  import com.automattic.simplenote.analytics.AnalyticsTracker;
  53  import com.automattic.simplenote.models.Note;
  54  import com.automattic.simplenote.models.Tag;
  55  import com.automattic.simplenote.utils.AppLog;
  56  import com.automattic.simplenote.utils.AppLog.Type;
  57  import com.automattic.simplenote.utils.AutoBullet;
  58  import com.automattic.simplenote.utils.BrowserUtils;
  59  import com.automattic.simplenote.utils.ContextUtils;
  60  import com.automattic.simplenote.utils.DisplayUtils;
  61  import com.automattic.simplenote.utils.DrawableUtils;
  62  import com.automattic.simplenote.utils.MatchOffsetHighlighter;
  63  import com.automattic.simplenote.utils.NetworkUtils;
  64  import com.automattic.simplenote.utils.NoteUtils;
  65  import com.automattic.simplenote.utils.PrefUtils;
  66  import com.automattic.simplenote.utils.SimplenoteLinkify;
  67  import com.automattic.simplenote.utils.SimplenoteMovementMethod;
  68  import com.automattic.simplenote.utils.SpaceTokenizer;
  69  import com.automattic.simplenote.utils.TagUtils;
  70  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView;
  71  import com.automattic.simplenote.utils.TagsMultiAutoCompleteTextView.OnTagAddedListener;
  72  import com.automattic.simplenote.utils.TextHighlighter;
  73  import com.automattic.simplenote.utils.ThemeUtils;
  74  import com.automattic.simplenote.utils.WidgetUtils;
  75  import com.automattic.simplenote.widgets.SimplenoteEditText;
  76  import com.google.android.material.chip.Chip;
  77  import com.google.android.material.chip.ChipGroup;
  78  import com.google.android.material.snackbar.Snackbar;
  79  import com.simperium.client.Bucket;
  80  import com.simperium.client.BucketObjectMissingException;
  81  import com.simperium.client.Query;
  82  
  83  import java.lang.ref.WeakReference;
  84  import java.util.Calendar;
  85  
  86  import static com.automattic.simplenote.analytics.AnalyticsTracker.CATEGORY_NOTE;
  87  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_CHECKLIST_INSERTED;
  88  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_CONTENT_SHARED;
  89  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_EDITED;
  90  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_PUBLISHED;
  91  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_NOTE_UNPUBLISHED;
  92  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_ADDED;
  93  import static com.automattic.simplenote.analytics.AnalyticsTracker.Stat.EDITOR_TAG_REMOVED;
  94  import static com.automattic.simplenote.utils.SearchTokenizer.SPACE;
  95  import static com.automattic.simplenote.utils.SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX;
  96  
  97  public class NoteEditorFragment extends Fragment implements Bucket.Listener&lt;Note&gt;,
  98          TextWatcher, OnTagAddedListener, View.OnFocusChangeListener,
  99          SimplenoteEditText.OnSelectionChangedListener,
 100          ShareBottomSheetDialog.ShareSheetListener,
 101          HistoryBottomSheetDialog.HistorySheetListener,
 102          SimplenoteEditText.OnCheckboxToggledListener {
 103  
 104      public static final String ARG_IS_FROM_WIDGET = &quot;is_from_widget&quot;;
 105      public static final String ARG_ITEM_ID = &quot;item_id&quot;;
 106      public static final String ARG_NEW_NOTE = &quot;new_note&quot;;
 107      public static final String ARG_MATCH_OFFSETS = &quot;match_offsets&quot;;
 108      public static final String ARG_MARKDOWN_ENABLED = &quot;markdown_enabled&quot;;
 109      public static final String ARG_PREVIEW_ENABLED = &quot;preview_enabled&quot;;
 110  
 111      private static final String STATE_NOTE_ID = &quot;state_note_id&quot;;
 112      private static final int AUTOSAVE_DELAY_MILLIS = 2000;
 113      private static final int MAX_REVISIONS = 30;
 114      private static final int PUBLISH_TIMEOUT = 20000;
 115      private static final int HISTORY_TIMEOUT = 10000;
 116      private Note mNote;
 117      private final Runnable mAutoSaveRunnable = new Runnable() {
 118          @Override
 119          public void run() {
 120              saveAndSyncNote();
 121          }
 122      };
 123      private Bucket&lt;Note&gt; mNotesBucket;
 124      private View mRootView;
 125      private View mTagPadding;
 126      private SimplenoteEditText mContentEditText;
 127      private ChipGroup mTagChips;
 128      private TagsMultiAutoCompleteTextView mTagInput;
 129      private Handler mAutoSaveHandler;
 130      private Handler mPublishTimeoutHandler;
 131      private Handler mHistoryTimeoutHandler;
 132      private LinearLayout mPlaceholderView;
 133      private CursorAdapter mLinkAutocompleteAdapter;
 134      private CursorAdapter mTagAutocompleteAdapter;
 135      private boolean mIsLoadingNote;
 136      private boolean mIsMarkdownEnabled;
 137      private boolean mIsPreviewEnabled;
 138      private boolean mShouldScrollToSearchMatch;
 139      private ActionMode mActionMode;
 140      private MenuItem mChecklistMenuItem;
 141      private MenuItem mCopyMenuItem;
 142      private MenuItem mInformationMenuItem;
 143      private MenuItem mShareMenuItem;
 144      private MenuItem mViewLinkMenuItem;
 145      private String mLinkUrl;
 146      private String mLinkText;
 147      private MatchOffsetHighlighter mHighlighter;
 148      private Drawable mBrowserIcon;
 149      private Drawable mCallIcon;
 150      private Drawable mCopyIcon;
 151      private Drawable mEmailIcon;
 152      private Drawable mLinkIcon;
 153      private Drawable mMapIcon;
 154      private Drawable mShareIcon;
 155      private MatchOffsetHighlighter.SpanFactory mMatchHighlighter;
 156      private String mMatchOffsets;
 157      private int mCurrentCursorPosition;
 158      private HistoryBottomSheetDialog mHistoryBottomSheet;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +    private LinearLayout mError;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    private NoteMarkdownFragment mNoteMarkdownFragment;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +    private String mCss;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +    private WebView mMarkdown;</span>
 163      private boolean mIsPaused;
 164      private boolean mIsFromWidget;
 165  
 166      // Hides the history bottom sheet if no revisions are loaded
 167      private final Runnable mHistoryTimeoutRunnable = new Runnable() {
 168          @Override
 169          public void run() {
 170              if (!isAdded()) {
 171                  return;
 172              }
 173  
 174              requireActivity().runOnUiThread(new Runnable() {
 175                  @Override
 176                  public void run() {
<abbr title=" 177                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; !mHistoryBottomSheet.isHistoryLoaded()) {"> 177                      if (mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing() &amp;&amp; ðŸ”µ</abbr>
 178                          mHistoryBottomSheet.dismiss();
 179                          Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 180                      }
 181                  }
 182              });
 183          }
 184      };
 185      private InfoBottomSheetDialog mInfoBottomSheet;
 186      private ShareBottomSheetDialog mShareBottomSheet;
 187      // Contextual action bar for dealing with links
 188      private final ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
 189          // Called when the action mode is created; startActionMode() was called
 190          @Override
 191          public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 192              // Inflate a menu resource providing context menu items
 193              MenuInflater inflater = mode.getMenuInflater();
 194  
 195              if (inflater != null) {
 196                  inflater.inflate(R.menu.view_link, menu);
 197                  mCopyMenuItem = menu.findItem(R.id.menu_copy);
 198                  mShareMenuItem = menu.findItem(R.id.menu_share);
 199                  mViewLinkMenuItem = menu.findItem(R.id.menu_view_link);
 200                  mode.setTitle(getString(R.string.link));
 201                  mode.setTitleOptionalHint(false);
 202  
 203                  DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 204              }
 205  
<abbr title=" 206              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.background_dark;"> 206              int colorResId = ThemeUtils.isLightTheme(requireContext()) ? R.color.background_light : R.color.backgrðŸ”µ</abbr>
<abbr title=" 207              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().getTheme()));"> 207              requireActivity().getWindow().setStatusBarColor(getResources().getColor(colorResId, requireActivity().ðŸ”µ</abbr>

 208              return true;
 209          }
 210  
 211          // Called each time the action mode is shown. Always called after onCreateActionMode, but
 212          // may be called multiple times if the mode is invalidated.
 213          @Override
 214          public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 215              return false; // Return false if nothing is done
 216          }
 217  
 218          // Called when the user selects a contextual menu item
 219          @Override
 220          public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 221              switch (item.getItemId()) {
 222                  case R.id.menu_view_link:
 223                      if (mLinkText != null) {
 224                          if (mLinkText.startsWith(SIMPLENOTE_LINK_PREFIX)) {
<abbr title=" 225                              SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 225                              SimplenoteLinkify.openNote(requireActivity(), mLinkText.replace(SIMPLENOTE_LINK_PREFIXðŸ”µ</abbr>
 226                          } else {
 227                              try {
 228                                  BrowserUtils.launchBrowserOrShowError(requireContext(), mLinkText);
 229                              } catch (Exception e) {
 230                                  e.printStackTrace();
 231                              }
 232                          }
 233  
 234                          mode.finish(); // Action picked, so close the CAB
 235                      }
 236  
 237                      return true;
 238                  case R.id.menu_copy:
 239                      if (mLinkText != null &amp;&amp; getActivity() != null) {
 240                          if (BrowserUtils.copyToClipboard(requireContext(), mLinkText)) {
 241                              Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 242                          } else {
 243                              Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 244                          }
 245  
 246                          mode.finish();
 247                      }
 248  
 249                      return true;
 250                  case R.id.menu_share:
 251                      if (mLinkText != null) {
 252                          showShare(mLinkText);
 253                          mode.finish();
 254                      }
 255  
 256                      return true;
 257                  default:
 258                      return false;
 259              }
 260          }
 261  
 262          // Called when the user exits the action mode
 263          @Override
 264          public void onDestroyActionMode(ActionMode mode) {
 265              if (mActionMode != null) {
 266                  mActionMode.setSubtitle(&quot;&quot;);
 267                  mActionMode = null;
 268              }
 269  
 270              new Handler().postDelayed(
 271                  new Runnable() {
 272                      @Override
 273                      public void run() {
<abbr title=" 274                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.transparent, requireActivity().getTheme()));"> 274                          requireActivity().getWindow().setStatusBarColor(getResources().getColor(android.R.color.trðŸ”µ</abbr>
 275                      }
 276                  },
 277                  requireContext().getResources().getInteger(android.R.integer.config_mediumAnimTime)
 278              );
 279          }
 280      };
 281      private Snackbar mPublishingSnackbar;
 282      private boolean mHideActionOnSuccess;
 283      // Resets note publish status if Simperium never returned the new publish status
 284      private final Runnable mPublishTimeoutRunnable = new Runnable() {
 285          @Override
 286          public void run() {
 287              if (!isAdded()) return;
 288  
 289              requireActivity().runOnUiThread(new Runnable() {
 290                  @Override
 291                  public void run() {
 292  
 293                      mNote.setPublished(!mNote.isPublished());
 294                      mNote.save();
 295  
 296                      updatePublishedState(false);
 297                  }
 298              });
 299          }
 300      };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 301 -    private NoteMarkdownFragment mNoteMarkdownFragment;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 302 -    private String mCss;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 303 -    private WebView mMarkdown;</span>
 304  
 305      /**
 306       * Mandatory empty constructor for the fragment manager to instantiate the
 307       * fragment (e.g. upon screen orientation changes).
 308       */
 309      public NoteEditorFragment() {
 310      }
 311  
 312      @Override
 313      public void onCreate(Bundle savedInstanceState) {
 314          super.onCreate(savedInstanceState);
 315          AppLog.add(Type.NETWORK, NetworkUtils.getNetworkInfo(requireContext()));
 316          AppLog.add(Type.SCREEN, &quot;Created (NoteEditorFragment)&quot;);
 317          mInfoBottomSheet = new InfoBottomSheetDialog(this);
 318          mShareBottomSheet = new ShareBottomSheetDialog(this, this);
 319          mHistoryBottomSheet = new HistoryBottomSheetDialog(this, this);
 320  
 321          Simplenote currentApp = (Simplenote) requireActivity().getApplication();
 322          mNotesBucket = currentApp.getNotesBucket();
 323  
<abbr title=" 324          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.actionModeTextColor);"> 324          mCallIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_call_white_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 325          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actionModeTextColor);"> 325          mEmailIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_email_24dp, R.attr.actioðŸ”µ</abbr>
<abbr title=" 326          mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionModeTextColor);"> 326          mLinkIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_note_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 327          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModeTextColor);"> 327          mMapIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_map_24dp, R.attr.actionModðŸ”µ</abbr>
<abbr title=" 328          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.actionModeTextColor);"> 328          mBrowserIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_browser_24dp, R.attr.aðŸ”µ</abbr>
<abbr title=" 329          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionModeTextColor);"> 329          mCopyIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_copy_24dp, R.attr.actionMðŸ”µ</abbr>
<abbr title=" 330          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actionModeTextColor);"> 330          mShareIcon = DrawableUtils.tintDrawableWithAttribute(getActivity(), R.drawable.ic_share_24dp, R.attr.actioðŸ”µ</abbr>
 331  
 332          mAutoSaveHandler = new Handler();
 333          mPublishTimeoutHandler = new Handler();
 334          mHistoryTimeoutHandler = new Handler();
 335  
 336          mMatchHighlighter = new TextHighlighter(requireActivity(),
 337                  R.attr.editorSearchHighlightForegroundColor, R.attr.editorSearchHighlightBackgroundColor);
 338          mTagAutocompleteAdapter = new CursorAdapter(getActivity(), null, 0x0) {
 339              @Override
 340              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 341                  Activity activity = (Activity) context;
 342                  if (activity == null) return null;
 343                  return activity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 344              }
 345  
 346              @Override
 347              public void bindView(View view, Context context, Cursor cursor) {
 348                  TextView textView = (TextView) view;
 349                  textView.setText(convertToString(cursor));
 350              }
 351  
 352              @Override
 353              public CharSequence convertToString(Cursor cursor) {
 354                  return cursor.getString(cursor.getColumnIndex(Tag.NAME_PROPERTY));
 355              }
 356  
 357              @Override
 358              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 359                  Activity activity = getActivity();
 360                  if (activity == null) return null;
 361                  Simplenote application = (Simplenote) activity.getApplication();
 362                  Query&lt;Tag&gt; query = application.getTagsBucket().query();
 363                  // make the tag name available to the cursor
 364                  query.include(Tag.NAME_PROPERTY);
 365                  // sort the tags by their names
 366                  query.order(Tag.NAME_PROPERTY);
 367                  // if there&#x27;s a filter string find only matching tag names
 368                  if (filter != null)
 369                      query.where(Tag.NAME_PROPERTY, Query.ComparisonType.LIKE, String.format(&quot;%s%%&quot;, filter));
 370                  return query.execute();
 371              }
 372          };
 373  
 374          mLinkAutocompleteAdapter = new CursorAdapter(getContext(), null, 0x0) {
 375              private Activity mActivity = requireActivity();
 376  
 377              @Override
 378              public void bindView(View view, Context context, Cursor cursor) {
 379                  ((TextView) view).setText(convertToString(cursor));
 380              }
 381  
 382              @Override
 383              public CharSequence convertToString(Cursor cursor) {
 384                  return cursor.getString(cursor.getColumnIndex(Note.TITLE_INDEX_NAME));
 385              }
 386  
 387              @Override
 388              public View newView(Context context, Cursor cursor, ViewGroup parent) {
 389                  return mActivity.getLayoutInflater().inflate(R.layout.autocomplete_list_item, null);
 390              }
 391  
 392              @Override
 393              public Cursor runQueryOnBackgroundThread(CharSequence filter) {
 394                  if (filter == null) {
 395                      return null;
 396                  }
 397  
 398                  Simplenote application = (Simplenote) mActivity.getApplication();
 399                  Query&lt;Note&gt; query = application.getNotesBucket().query();
 400                  query.include(Note.PINNED_INDEX_NAME);
 401                  query.include(Note.TITLE_INDEX_NAME);
 402                  query.where(Note.TITLE_INDEX_NAME, Query.ComparisonType.LIKE, String.format(&quot;%%%s%%&quot;, filter));
 403                  PrefUtils.sortNoteQuery(query, requireContext(), true);
 404                  Cursor cursor = query.execute();
 405  
 406                  final int heightAutocomplete = DisplayUtils.dpToPx(requireContext(), cursor.getCount() * 48);
 407                  final int heightDisplay = DisplayUtils.getDisplayPixelSize(requireContext()).y;
 408                  final int heightDropdown = Math.min(heightDisplay / 4, heightAutocomplete);
 409  
 410                  mActivity.runOnUiThread(
 411                      new Runnable() {
 412                          @Override
 413                          public void run() {
 414                              mContentEditText.setDropDownHeight(heightDropdown);
 415                          }
 416                      }
 417                  );
 418                  return cursor;
 419              }
 420          };
 421  
 422          WidgetUtils.updateNoteWidgets(requireActivity().getApplicationContext());
 423      }
 424  
 425      @Override
 426      public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
 427          mRootView = inflater.inflate(R.layout.fragment_note_editor, container, false);
 428          mContentEditText = mRootView.findViewById(R.id.note_content);
 429          mContentEditText.addOnSelectionChangedListener(this);
 430          mContentEditText.setOnCheckboxToggledListener(this);
 431          mContentEditText.setMovementMethod(SimplenoteMovementMethod.getInstance());
 432          mContentEditText.setOnFocusChangeListener(this);
 433          mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 434          mContentEditText.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 435          mContentEditText.setAdapter(mLinkAutocompleteAdapter);
 436          mTagInput = mRootView.findViewById(R.id.tag_input);
 437          mTagInput.setDropDownBackgroundResource(R.drawable.bg_list_popup);
 438          mTagInput.setTokenizer(new SpaceTokenizer());
 439          mTagInput.setAdapter(mTagAutocompleteAdapter);
 440          mTagInput.setOnFocusChangeListener(this);
 441          mTagChips = mRootView.findViewById(R.id.tag_chips);
 442          mTagPadding = mRootView.findViewById(R.id.tag_padding);
 443          mHighlighter = new MatchOffsetHighlighter(mMatchHighlighter, mContentEditText);
 444          mPlaceholderView = mRootView.findViewById(R.id.placeholder);
 445  
 446          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote == null) {
 447              mPlaceholderView.setVisibility(View.VISIBLE);
 448              requireActivity().invalidateOptionsMenu();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -            mMarkdown = mRootView.findViewById(R.id.markdown);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -            mMarkdown.setWebViewClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -                new WebViewClient() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -                    @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -                    public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -                        String url = request.getUrl().toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -                        if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 457 -                            SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 457 -                            SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;))ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -                        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -                            BrowserUtils.launchBrowserOrShowError(requireContext(), url);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 460 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 461 +            if (BrowserUtils.isWebViewInstalled(requireContext())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +                ((ViewStub) mRootView.findViewById(R.id.stub_webview)).inflate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +                mMarkdown = mRootView.findViewById(R.id.markdown);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 464 +                mMarkdown.setWebViewClient(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +                    new WebViewClient() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +                        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +                        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +                            String url = request.getUrl().toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +                            if (url.startsWith(SimplenoteLinkify.SIMPLENOTE_LINK_PREFIX)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 471 +                                SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, &quot;&quot;));"> 471 +                                SimplenoteLinkify.openNote(requireActivity(), url.replace(SIMPLENOTE_LINK_PREFIX, ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +                                BrowserUtils.launchBrowserOrShowError(requireContext(), url);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 474 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 475 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 476 +                            return true;</span>
 477                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -                        return true;</span>
 480                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 481 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 482 -            );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -            mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -                ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 485 -                : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 486 +                );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 487 +                mCss = ThemeUtils.isLightTheme(requireContext())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 488 +                    ? ContextUtils.readCssFile(requireContext(), &quot;light.css&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 489 +                    : ContextUtils.readCssFile(requireContext(), &quot;dark.css&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 490 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +                ((ViewStub) mRootView.findViewById(R.id.stub_error)).inflate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 492 +                mError = mRootView.findViewById(R.id.error);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +                mRootView.findViewById(R.id.button).setOnClickListener(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 494 +                    new View.OnClickListener() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +                        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 496 +                        public void onClick(View view) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 497 +                            BrowserUtils.launchBrowserOrShowError(requireContext(), BrowserUtils.URL_WEB_VIEW);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 500 +                );</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +            }</span>
 502          }
 503  
 504          Bundle arguments = getArguments();
 505  
 506          if (arguments != null &amp;&amp; arguments.containsKey(ARG_ITEM_ID)) {
 507              // Load note if we were passed a note Id
 508              String key = arguments.getString(ARG_ITEM_ID);
 509  
 510              if (arguments.containsKey(ARG_MATCH_OFFSETS)) {
 511                  mMatchOffsets = arguments.getString(ARG_MATCH_OFFSETS);
 512              }
 513  
 514              mIsFromWidget = arguments.getBoolean(ARG_IS_FROM_WIDGET);
 515  
 516              if (mIsFromWidget) {
 517                  AppLog.add(Type.ACTION, &quot;Opened from widget (NoteEditorFragment)&quot;);
 518              } else {
 519                  AppLog.add(Type.ACTION, &quot;Opened from list (NoteEditorFragment)&quot;);
 520              }
 521  
 522              new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, key);
 523          } else if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; savedInstanceState != null) {
 524              // Restore selected note when in dual pane mode
 525              String noteId = savedInstanceState.getString(STATE_NOTE_ID);
 526  
 527              if (noteId != null) {
 528                  setNote(noteId);
 529              }
 530          }
 531  
 532          ViewTreeObserver viewTreeObserver = mContentEditText.getViewTreeObserver();
 533          viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
 534              @Override
 535              public void onGlobalLayout() {
 536                  // If a note was loaded with search matches, scroll to the first match in the editor
 537                  if (mShouldScrollToSearchMatch &amp;&amp; mMatchOffsets != null) {
 538                      if (!isAdded()) {
 539                          return;
 540                      }
 541  
 542                      // Get the character location of the first search match
 543                      int matchLocation = MatchOffsetHighlighter.getFirstMatchLocation(
 544                              mContentEditText.getText(),
 545                              mMatchOffsets
 546                      );
 547                      if (matchLocation == 0) {
 548                          return;
 549                      }
 550  
 551                      // Calculate how far to scroll to bring the match into view
 552                      Layout layout = mContentEditText.getLayout();
 553                      int lineTop = layout.getLineTop(layout.getLineForOffset(matchLocation));
 554                      ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 555                      mShouldScrollToSearchMatch = false;
 556                  }
 557              }
 558          });
 559          setHasOptionsMenu(true);
 560          return mRootView;
 561      }
 562  
 563      public void scrollToMatch(int location) {
 564          if (isAdded()) {
 565              // Calculate how far to scroll to bring the match into view
 566              Layout layout = mContentEditText.getLayout();
 567              int lineTop = layout.getLineTop(layout.getLineForOffset(location));
 568              ((NestedScrollView) mRootView).smoothScrollTo(0, lineTop);
 569          }
 570      }
 571  
 572      @Override
 573      public void onResume() {
 574          super.onResume();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +        checkWebView();</span>
 576          mIsPaused = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -        mNotesBucket.start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        AppLog.add(Type.SYNC, &quot;Started note bucket (NoteEditorFragment)&quot;);</span>
 579          mNotesBucket.addListener(this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +        AppLog.add(Type.SYNC, &quot;Added note bucket listener (NoteEditorFragment)&quot;);</span>
 581          mTagInput.setOnTagAddedListener(this);
 582  
 583          if (mContentEditText != null) {
 584              mContentEditText.setTextSize(TypedValue.COMPLEX_UNIT_SP, PrefUtils.getFontSize(requireContext()));
 585  
 586              if (mContentEditText.hasFocus()) {
 587                  showSoftKeyboard();
 588              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +    private void checkWebView() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +        // When a WebView is installed and mMarkdown is null on a large landscape device, a WebView</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 594 +        // was not installed when the fragment was created.  So, recreate the activity to refresh</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 595 +        // the editor view.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 596 +        if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown == null &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +            DisplayUtils.isLargeScreenLandscape(requireContext())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +            requireActivity().recreate();</span>
 599          }
 600      }
 601  
 602      private void showSoftKeyboard() {
 603          new Handler().postDelayed(new Runnable() {
 604              @Override
 605              public void run() {
 606                  if (getActivity() == null) {
 607                      return;
 608                  }
 609  
<abbr title=" 610                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);"> 610                  InputMethodManager inputMethodManager = (InputMethodManager) getActivity().getSystemService(ContexðŸ”µ</abbr>
 611                  if (inputMethodManager != null) {
 612                      inputMethodManager.showSoftInput(mContentEditText, 0);
 613                  }
 614              }
 615          }, 100);
 616      }
 617  
 618      @Override
 619      public void onPause() {
 620          super.onPause();  // Always call the superclass method first
 621          mIsPaused = true;
 622  
 623          // Hide soft keyboard if it is showing...
 624          DisplayUtils.hideKeyboard(mContentEditText);
 625  
 626          mTagInput.setOnTagAddedListener(null);
 627  
 628          if (mAutoSaveHandler != null) {
 629              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 630              mAutoSaveHandler.post(mAutoSaveRunnable);
 631          }
 632  
 633          if (mPublishTimeoutHandler != null) {
 634              mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
 635          }
 636  
 637          if (mHistoryTimeoutHandler != null) {
 638              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
 639          }
 640  
 641          mHighlighter.stop();
 642          saveNote();
 643          AppLog.add(Type.SCREEN, &quot;Paused (NoteEditorFragment)&quot;);
 644      }
 645  
 646      @Override
 647      public void onDestroy() {
 648          super.onDestroy();
 649          mNotesBucket.removeListener(this);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -        mNotesBucket.stop();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -        AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +        AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);</span>
 653          AppLog.add(Type.SCREEN, &quot;Destroyed (NoteEditorFragment)&quot;);
 654      }
 655  
 656      @Override
 657      public void onSaveInstanceState(@NonNull Bundle outState) {
 658          super.onSaveInstanceState(outState);
 659  
 660          if (DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNote != null) {
 661              outState.putString(STATE_NOTE_ID, mNote.getSimperiumKey());
 662          }
 663      }
 664  
 665      @Override
 666      public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
 667          super.onCreateOptionsMenu(menu, inflater);
 668  
<abbr title=" 669          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFragment == null)) {"> 669          if (!isAdded() || (!mIsFromWidget &amp;&amp; DisplayUtils.isLargeScreenLandscape(getActivity()) &amp;&amp; mNoteMarkdownFrðŸ”µ</abbr>
 670              return;
 671          }
 672  
 673          inflater.inflate(R.menu.note_editor, menu);
 674          MenuCompat.setGroupDividerEnabled(menu, true);
 675      }
 676  
 677      @Override
 678      public boolean onOptionsItemSelected(@NonNull MenuItem item) {
 679          switch (item.getItemId()) {
 680              case R.id.menu_checklist:
 681                  insertChecklist();
 682                  return true;
 683              case R.id.menu_copy:
 684                  if (BrowserUtils.copyToClipboard(requireContext(), mNote.getPublishedUrl())) {
 685                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 686                  } else {
 687                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 688                  }
 689  
 690                  return true;
 691              case R.id.menu_copy_internal:
<abbr title=" 692                  if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.getTitle(), mNote.getSimperiumKey()))) {"> 692                  if (BrowserUtils.copyToClipboard(requireContext(), SimplenoteLinkify.getNoteLinkWithTitle(mNote.geðŸ”µ</abbr>
 693                      Snackbar.make(mRootView, R.string.link_copied, Snackbar.LENGTH_SHORT).show();
 694                  } else {
 695                      Snackbar.make(mRootView, R.string.link_copied_failure, Snackbar.LENGTH_SHORT).show();
 696                  }
 697  
 698                  return true;
 699              case R.id.menu_history:
 700                  showHistory();
 701                  return true;
 702              case R.id.menu_info:
 703                  showInfo();
 704                  return true;
 705              case R.id.menu_markdown:
 706                  setMarkdown(!item.isChecked());
 707                  return true;
 708              case R.id.menu_pin:
 709                  NoteUtils.setNotePin(mNote, !item.isChecked());
 710                  requireActivity().invalidateOptionsMenu();
 711                  return true;
 712              case R.id.menu_publish:
 713                  if (item.isChecked()) {
 714                      unpublishNote();
 715                  } else {
 716                      publishNote();
 717                  }
 718  
 719                  return true;
 720              case R.id.menu_share:
 721                  shareNote();
 722                  return true;
 723              case R.id.menu_trash:
 724                  if (!isAdded()) {
 725                      return false;
 726                  }
 727  
 728                  deleteNote();
 729                  return true;
 730              case android.R.id.home:
 731                  AppLog.add(Type.ACTION, &quot;Tapped back arrow in app bar (NoteEditorFragment)&quot;);
 732                  if (!isAdded()) {
 733                      return false;
 734                  }
 735  
 736                  requireActivity().finish();
 737                  return true;
 738              default:
 739                  return super.onOptionsItemSelected(item);
 740          }
 741      }
 742  
 743      @Override
 744      public void onPrepareOptionsMenu(@NonNull Menu menu) {
 745          if (mNote != null) {
 746              MenuItem pinItem = menu.findItem(R.id.menu_pin);
 747              MenuItem shareItem = menu.findItem(R.id.menu_share);
 748              MenuItem historyItem = menu.findItem(R.id.menu_history);
 749              MenuItem publishItem = menu.findItem(R.id.menu_publish);
 750              MenuItem copyLinkItem = menu.findItem(R.id.menu_copy);
 751              MenuItem markdownItem = menu.findItem(R.id.menu_markdown);
 752              MenuItem trashItem = menu.findItem(R.id.menu_trash);
 753              mChecklistMenuItem = menu.findItem(R.id.menu_checklist);
 754              mInformationMenuItem = menu.findItem(R.id.menu_info).setVisible(true);
 755  
 756              pinItem.setChecked(mNote.isPinned());
 757              publishItem.setChecked(mNote.isPublished());
 758              markdownItem.setChecked(mNote.isMarkdownEnabled());
 759  
 760              // Disable actions when note is in Trash or markdown view is shown on large device.
 761              if (mNote.isDeleted() || (mMarkdown != null &amp;&amp; mMarkdown.getVisibility() == View.VISIBLE)) {
 762                  pinItem.setEnabled(false);
 763                  shareItem.setEnabled(false);
 764                  historyItem.setEnabled(false);
 765                  publishItem.setEnabled(false);
 766                  copyLinkItem.setEnabled(false);
 767                  markdownItem.setEnabled(false);
 768                  mChecklistMenuItem.setEnabled(false);
 769                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 0.3);  // 0.3 is 30% opacity.
 770              } else {
 771                  pinItem.setEnabled(true);
 772                  shareItem.setEnabled(true);
 773                  historyItem.setEnabled(true);
 774                  publishItem.setEnabled(true);
 775                  copyLinkItem.setEnabled(mNote.isPublished());
 776                  markdownItem.setEnabled(true);
 777                  mChecklistMenuItem.setEnabled(true);
 778                  DrawableUtils.setMenuItemAlpha(mChecklistMenuItem, 1.0);  // 1.0 is 100% opacity.
 779              }
 780  
 781              if (mNote.isDeleted()) {
 782                  trashItem.setTitle(R.string.restore);
 783              } else {
 784                  trashItem.setTitle(R.string.trash);
 785              }
 786          }
 787  
 788          DrawableUtils.tintMenuWithAttribute(getActivity(), menu, R.attr.toolbarIconColor);
 789          super.onPrepareOptionsMenu(menu);
 790      }
 791  
 792      public void insertChecklist() {
 793          DrawableUtils.startAnimatedVectorDrawable(mChecklistMenuItem.getIcon());
 794  
 795          try {
 796              mContentEditText.insertChecklist();
 797          } catch (Exception e) {
 798              e.printStackTrace();
 799              return;
 800          }
 801  
 802          AnalyticsTracker.track(
 803              EDITOR_CHECKLIST_INSERTED,
 804              CATEGORY_NOTE,
 805              &quot;toolbar_button&quot;
 806          );
 807      }
 808  
 809      @Override
 810      public void onCheckboxToggled() {
 811          // Save note (using delay) after toggling a checkbox
 812          if (mAutoSaveHandler != null) {
 813              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
 814              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
 815          }
 816      }
 817  
 818      private void deleteNote() {
 819          NoteUtils.deleteNote(mNote, getActivity());
 820          requireActivity().finish();
 821      }
 822  
 823      protected void clearMarkdown() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -        mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +        if (mMarkdown != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 826 +            mMarkdown.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, mCss + &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 827 +        }</span>
 828      }
 829  
 830      protected void hideMarkdown() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 831 -        mMarkdown.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 832 +        if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +            mMarkdown.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 834 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 835 +            mError.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 836 +        }</span>
 837      }
 838  
 839      protected void showMarkdown() {
 840          loadMarkdownData();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -        mMarkdown.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 842 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 843 +        if (BrowserUtils.isWebViewInstalled(requireContext()) &amp;&amp; mMarkdown != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 844 +            mMarkdown.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 846 +            mError.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 847 +        }</span>
 848  
 849          new Handler().postDelayed(
 850              new Runnable() {
 851                  @Override
 852                  public void run() {
 853                      requireActivity().invalidateOptionsMenu();
 854                  }
 855              },
 856              getResources().getInteger(R.integer.time_animation)
 857          );
 858      }
 859  
 860      public void shareNote() {
 861          if (mNote != null) {
 862              mContentEditText.clearFocus();
 863              showShareSheet();
 864              AnalyticsTracker.track(
 865                  EDITOR_NOTE_CONTENT_SHARED,
 866                  CATEGORY_NOTE,
 867                  &quot;action_bar_share_button&quot;
 868              );
 869          }
 870      }
 871  
 872      public void showHistory() {
 873          if (mNote != null &amp;&amp; mNote.getVersion() &gt; 1) {
 874              mContentEditText.clearFocus();
 875              mHistoryTimeoutHandler.postDelayed(mHistoryTimeoutRunnable, HISTORY_TIMEOUT);
 876              showHistorySheet();
 877          } else {
 878              Toast.makeText(getActivity(), R.string.error_history, Toast.LENGTH_LONG).show();
 879          }
 880      }
 881  
 882      public void showInfo() {
 883          DrawableUtils.startAnimatedVectorDrawable(mInformationMenuItem.getIcon());
 884  
 885          if (mNote != null) {
 886              mContentEditText.clearFocus();
 887              saveNote();
 888              showInfoSheet();
 889          }
 890      }
 891  
 892      private void setMarkdown(boolean isChecked) {
 893          mIsMarkdownEnabled = isChecked;
 894          showMarkdownActionOrTabs();
 895          saveNote();
 896  
 897          // Set preference so that next new note will have markdown enabled.
 898          SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(requireContext());
 899          SharedPreferences.Editor editor = prefs.edit();
 900          editor.putBoolean(PrefUtils.PREF_MARKDOWN_ENABLED, isChecked);
 901          editor.apply();
 902      }
 903  
 904      private void setMarkdownEnabled(boolean enabled) {
 905          mIsMarkdownEnabled = enabled;
 906  
 907          if (mIsMarkdownEnabled) {
 908              loadMarkdownData();
 909          }
 910      }
 911  
 912      private void showMarkdownActionOrTabs() {
 913          Activity activity = getActivity();
 914  
 915          if (activity instanceof NoteEditorActivity) {
 916              NoteEditorActivity editorActivity = (NoteEditorActivity) activity;
 917  
 918              if (mIsMarkdownEnabled) {
 919                  editorActivity.showTabs();
 920  
 921                  if (mNoteMarkdownFragment == null) {
 922                      // Get markdown fragment and update content
 923                      mNoteMarkdownFragment = editorActivity.getNoteMarkdownFragment();
 924                      mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
 925                  }
 926              } else {
 927                  editorActivity.hideTabs();
 928              }
 929          } else if (activity instanceof NotesActivity) {
 930              setMarkdownEnabled(mIsMarkdownEnabled);
 931              ((NotesActivity) getActivity()).setMarkdownShowing(false);
 932          }
 933      }
 934  
 935      private void loadMarkdownData() {
 936          String formattedContent = NoteMarkdownFragment.getMarkdownFormattedContent(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 937 -                mCss,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 938 -                mContentEditText.getPreviewTextContent()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +            mCss,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +            mContentEditText.getPreviewTextContent()</span>
 941          );
 942  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 943 -        mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +        if (mMarkdown != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +            mMarkdown.loadDataWithBaseURL(null, formattedContent, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +        }</span>
 947      }
 948  
 949      public void setNote(String noteID, String matchOffsets) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 950 -        if (mAutoSaveHandler != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +        if (mAutoSaveHandler != null) {</span>
 952              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +        }</span>
 954  
 955          mPlaceholderView.setVisibility(View.GONE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 956 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 957 -        if (matchOffsets != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 958 -            mMatchOffsets = matchOffsets;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 959 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 960 -            mMatchOffsets = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 961 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 962 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 963 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +        mMatchOffsets = matchOffsets;</span>
 965          saveNote();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 966 -</span>
 967          new LoadNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteID);
 968      }
 969  
 970      private void updateNote(Note updatedNote) {
 971          // update note if network change arrived
 972          mNote = updatedNote;
 973          refreshContent(true);
 974      }
 975  
 976      private void refreshContent(boolean isNoteUpdate) {
 977          if (mNote != null) {
 978              // Restore the cursor position if possible.
<abbr title=" 979              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.getSelectionEnd());"> 979              int cursorPosition = newCursorLocation(mNote.getContent(), getNoteContentString(), mContentEditText.geðŸ”µ</abbr>
 980              mContentEditText.setText(mNote.getContent());
 981  
 982              if (isNoteUpdate) {
 983                  // Update markdown and preview flags from updated note.
 984                  mIsMarkdownEnabled = mNote.isMarkdownEnabled();
 985                  mIsPreviewEnabled = mNote.isPreviewEnabled();
 986  
 987                  // Show/Hide action/tabs based on markdown flag.
 988                  showMarkdownActionOrTabs();
 989  
 990                  // Save note so any local changes get synced.
 991                  mNote.save();
 992  
 993                  // Update current note object on large screen devices in landscape orientation.
 994                  if (DisplayUtils.isLargeScreenLandscape(requireContext())) {
 995                      ((NotesActivity) requireActivity()).setCurrentNote(mNote);
 996                  }
 997  
 998                  // Update overflow popup menu.
 999                  requireActivity().invalidateOptionsMenu();
1000  
1001                  if (mContentEditText.hasFocus()
1002                          &amp;&amp; cursorPosition != mContentEditText.getSelectionEnd()
1003                          &amp;&amp; cursorPosition &lt; mContentEditText.getText().length()) {
1004                      mContentEditText.setSelection(cursorPosition);
1005                  }
1006              }
1007  
1008              afterTextChanged(mContentEditText.getText());
1009              mContentEditText.processChecklists();
1010              updateTagList();
1011          }
1012      }
1013  
1014      private void updateTagList() {
1015          setChips(mNote.getTagString());
1016          mTagInput.setText(&quot;&quot;);
1017      }
1018  
1019      private int newCursorLocation(String newText, String oldText, int cursorLocation) {
1020          // Ported from the iOS app :)
1021          // Cases:
1022          // 0. All text after cursor (and possibly more) was removed ==&gt; put cursor at end
1023          // 1. Text was added after the cursor ==&gt; no change
1024          // 2. Text was added before the cursor ==&gt; location advances
1025          // 3. Text was removed after the cursor ==&gt; no change
1026          // 4. Text was removed before the cursor ==&gt; location retreats
1027          // 5. Text was added/removed on both sides of the cursor ==&gt; not handled
1028  
1029          cursorLocation = Math.max(cursorLocation, 0);
1030  
1031          int newCursorLocation = cursorLocation;
1032  
1033          int deltaLength = newText.length() - oldText.length();
1034  
1035          // Case 0
1036          if (newText.length() &lt; cursorLocation)
1037              return newText.length();
1038  
1039          boolean beforeCursorMatches = false;
1040          boolean afterCursorMatches = false;
1041  
1042          try {
<abbr title="1043              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation));">1043              beforeCursorMatches = oldText.substring(0, cursorLocation).equals(newText.substring(0, cursorLocation)ðŸ”µ</abbr>
<abbr title="1044              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaLength));">1044              afterCursorMatches = oldText.substring(cursorLocation).equals(newText.substring(cursorLocation + deltaðŸ”µ</abbr>
1045          } catch (Exception e) {
1046              e.printStackTrace();
1047          }
1048  
1049          // Cases 2 and 4
1050          if (!beforeCursorMatches &amp;&amp; afterCursorMatches)
1051              newCursorLocation += deltaLength;
1052  
1053          // Cases 1, 3 and 5 have no change
1054          return newCursorLocation;
1055      }
1056  
1057      @Override
1058      public void onTagAdded(String tag) {
1059          if (mNote == null || !isAdded()) {
1060              return;
1061          }
1062  
1063          if (mNote.getTagString() != null &amp;&amp; tag.length() &gt; mNote.getTagString().length()) {
1064              AnalyticsTracker.track(
1065                  EDITOR_TAG_ADDED,
1066                  CATEGORY_NOTE,
1067                  &quot;tag_added_to_note&quot;
1068              );
1069          }
1070  
1071          mNote.setTagString(mNote.getTagString() + String.valueOf(SPACE) + tag);
1072          mNote.setModificationDate(Calendar.getInstance());
1073          updateTagList();
1074          mNote.save();
1075      }
1076  
1077      @Override
1078      public void beforeTextChanged(CharSequence charSequence, int i, int i2, int i3) {
1079          // Unused
1080      }
1081  
1082      @Override
1083      public void afterTextChanged(Editable editable) {
1084          attemptAutoList(editable);
1085          setTitleSpan(editable);
1086          mContentEditText.fixLineSpacing();
1087      }
1088  
1089      @Override
1090      public void onTextChanged(CharSequence charSequence, int start, int before, int count) {
1091          // When text changes, start timer that will fire after AUTOSAVE_DELAY_MILLIS passes
1092          if (mAutoSaveHandler != null) {
1093              mAutoSaveHandler.removeCallbacks(mAutoSaveRunnable);
1094              mAutoSaveHandler.postDelayed(mAutoSaveRunnable, AUTOSAVE_DELAY_MILLIS);
1095          }
1096  
1097          // Remove search highlight spans when note content changes
1098          if (mMatchOffsets != null) {
1099              mMatchOffsets = null;
1100              mHighlighter.removeMatches();
1101          }
1102  
1103          if (!DisplayUtils.isLargeScreenLandscape(requireContext())) {
1104              ((NoteEditorActivity) requireActivity()).setSearchMatchBarVisible(false);
1105          }
1106  
1107          // Temporarily remove the text watcher as we process checklists to prevent callback looping
1108          mContentEditText.removeTextChangedListener(this);
1109          mContentEditText.processChecklists();
1110          mContentEditText.addTextChangedListener(this);
1111      }
1112  
1113      /**
1114       * Set the note title to be a larger size and bold style.
1115       *
1116       * Remove all existing spans before applying spans or performance issues will occur.  Since both
1117       * {@link RelativeSizeSpan} and {@link StyleSpan} inherit from {@link MetricAffectingSpan}, all
1118       * spans are removed when {@link MetricAffectingSpan} is removed.
1119       */
1120      private void setTitleSpan(Editable editable) {
1121          for (MetricAffectingSpan span : editable.getSpans(0, editable.length(), MetricAffectingSpan.class)) {
1122              if (span instanceof RelativeSizeSpan || span instanceof StyleSpan) {
1123                  editable.removeSpan(span);
1124              }
1125          }
1126  
1127          int newLinePosition = getNoteContentString().indexOf(&quot;\n&quot;);
1128  
1129          if (newLinePosition == 0) {
1130              return;
1131          }
1132  
1133          int titleEndPosition = (newLinePosition &gt; 0) ? newLinePosition : editable.length();
1134          editable.setSpan(new RelativeSizeSpan(1.3f), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1135          editable.setSpan(new StyleSpan(Typeface.BOLD), 0, titleEndPosition, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
1136      }
1137  
1138      private void attemptAutoList(Editable editable) {
1139          int oldCursorPosition = mCurrentCursorPosition;
1140          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1141          AutoBullet.apply(editable, oldCursorPosition, mCurrentCursorPosition);
1142          mCurrentCursorPosition = mContentEditText.getSelectionStart();
1143      }
1144  
1145      private void saveAndSyncNote() {
1146          if (mNote == null) {
1147              return;
1148          }
1149  
1150          AppLog.add(
1151              Type.ACTION,
1152              &quot;Edited note (ID: &quot; + mNote.getSimperiumKey() +
1153                  &quot; / Title: &quot; + mNote.getTitle() +
1154                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(mNote.getContent()) +
1155                  &quot; / Words: &quot; + NoteUtils.getWordCount(mNote.getContent()) + &quot;)&quot;
1156          );
1157          new SaveNoteTask(this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
1158      }
1159  
1160      public boolean isPlaceholderVisible() {
1161          if (mPlaceholderView != null) {
1162              return mPlaceholderView.getVisibility() == View.VISIBLE;
1163          } else {
1164              return false;
1165          }
1166      }
1167  
1168      public void setPlaceholderVisible(boolean isVisible) {
1169          if (isVisible) {
1170              mNote = null;
1171              mContentEditText.setText(&quot;&quot;);
1172          }
1173  
1174          if (mPlaceholderView != null) {
1175              mPlaceholderView.setVisibility(isVisible ? View.VISIBLE : View.GONE);
1176          }
1177      }
1178  
1179      @Override
1180      public void onFocusChange(View v, boolean hasFocus) {
1181          if (!hasFocus) {
1182              String tags = getNoteTagsString().trim();
1183  
1184              if (mTagInput.getText().toString().trim().length() &gt; 0
1185                  &amp;&amp; TagUtils.hashTagValid(mTagInput.getText().toString().trim())) {
1186                  onTagAdded(mTagInput.getText().toString());
1187              } else if (tags.length() &gt; 0) {
1188                  setChips(tags);
1189              }
1190          }
1191      }
1192  
1193      private Note getNote() {
1194          return mNote;
1195      }
1196  
1197      public void setNote(String noteID) {
1198          setNote(noteID, null);
1199      }
1200  
1201      private String getNoteContentString() {
1202          if (mContentEditText == null || mContentEditText.getText() == null) {
1203              return &quot;&quot;;
1204          } else {
1205              return mContentEditText.getText().toString();
1206          }
1207      }
1208  
1209      private String getNoteTagsString() {
1210          StringBuilder tags = new StringBuilder();
1211  
1212          for (int i= 0; i &lt; mTagChips.getChildCount(); i++) {
1213              tags.append(((Chip) mTagChips.getChildAt(i)).getText()).append(&quot; &quot;);
1214          }
1215  
1216          return tags.toString();
1217      }
1218  
1219      /**
1220       * Share bottom sheet callbacks
1221       */
1222  
1223      @Override
1224      public void onSharePublishClicked() {
1225          publishNote();
1226          if (mShareBottomSheet != null) {
1227              mShareBottomSheet.dismiss();
1228          }
1229      }
1230  
1231      @Override
1232      public void onShareUnpublishClicked() {
1233          unpublishNote();
1234          if (mShareBottomSheet != null) {
1235              mShareBottomSheet.dismiss();
1236          }
1237      }
1238  
1239      @Override
1240      public void onWordPressPostClicked() {
1241          if (mShareBottomSheet != null) {
1242              mShareBottomSheet.dismiss();
1243          }
1244  
1245          if (getFragmentManager() == null) {
1246              return;
1247          }
1248  
1249          FragmentTransaction ft = getFragmentManager().beginTransaction();
1250          Fragment prev = getFragmentManager().findFragmentByTag(WordPressDialogFragment.DIALOG_TAG);
1251          if (prev != null) {
1252              ft.remove(prev);
1253          }
1254          ft.addToBackStack(null);
1255  
1256          // Create and show the dialog.
1257          WordPressDialogFragment wpDialogFragment = new WordPressDialogFragment();
1258          wpDialogFragment.setNote(mNote);
1259          wpDialogFragment.show(ft, WordPressDialogFragment.DIALOG_TAG);
1260      }
1261  
1262      @Override
1263      public void onShareCollaborateClicked() {
1264          Toast.makeText(getActivity(), R.string.collaborate_message, Toast.LENGTH_LONG).show();
1265      }
1266  
1267      @Override
1268      public void onShareDismissed() {
1269  
1270      }
1271  
1272      /**
1273       * History bottom sheet listeners
1274       */
1275  
1276      @Override
1277      public void onHistoryCancelClicked() {
1278          mContentEditText.setText(mNote.getContent());
1279          if (mHistoryBottomSheet != null) {
1280              mHistoryBottomSheet.dismiss();
1281          }
1282      }
1283  
1284      @Override
1285      public void onHistoryRestoreClicked() {
1286          if (mHistoryBottomSheet != null) {
1287              mHistoryBottomSheet.dismiss();
1288          }
1289          saveAndSyncNote();
1290      }
1291  
1292      @Override
1293      public void onHistoryDismissed() {
1294          if (!mHistoryBottomSheet.didTapOnButton()) {
1295              mContentEditText.setText(mNote.getContent());
1296          }
1297  
1298          if (mHistoryTimeoutHandler != null) {
1299              mHistoryTimeoutHandler.removeCallbacks(mHistoryTimeoutRunnable);
1300          }
1301      }
1302  
1303      @Override
1304      public void onHistoryUpdateNote(String content) {
1305          mContentEditText.setText(content);
1306      }
1307  
1308      private void saveNote() {
1309          try {
1310              if (mNote == null || mNotesBucket == null || mContentEditText == null || mIsLoadingNote ||
<abbr title="1311                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getDialog().isShowing())) {">1311                  (mHistoryBottomSheet != null &amp;&amp; mHistoryBottomSheet.getDialog() != null &amp;&amp; mHistoryBottomSheet.getðŸ”µ</abbr>
1312                  return;
1313              } else {
1314                  mNote = mNotesBucket.get(mNote.getSimperiumKey());
1315                  mIsPreviewEnabled = mNote.isPreviewEnabled();
1316              }
1317  
1318              String content = mContentEditText.getPlainTextContent();
1319              String tagString = getNoteTagsString();
1320  
<abbr title="1321              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnabled)) {">1321              if (mNote.hasChanges(content, tagString.trim(), mNote.isPinned(), mIsMarkdownEnabled, mIsPreviewEnableðŸ”µ</abbr>
1322                  mNote.setContent(content);
1323                  mNote.setTagString(tagString);
1324                  mNote.setModificationDate(Calendar.getInstance());
1325                  mNote.setMarkdownEnabled(mIsMarkdownEnabled);
1326                  mNote.setPreviewEnabled(mIsPreviewEnabled);
1327                  mNote.save();
1328  
1329                  AnalyticsTracker.track(
1330                      EDITOR_NOTE_EDITED,
1331                      CATEGORY_NOTE,
1332                      &quot;editor_save&quot;
1333                  );
1334  
1335                  AppLog.add(
1336                      Type.SYNC,
1337                      &quot;Saved note locally in NoteEditorFragment (ID: &quot; + mNote.getSimperiumKey() +
1338                          &quot; / Title: &quot; + mNote.getTitle() +
1339                          &quot; / Characters: &quot; + NoteUtils.getCharactersCount(content) +
1340                          &quot; / Words: &quot; + NoteUtils.getWordCount(content) + &quot;)&quot;
1341                  );
1342              }
1343          } catch (BucketObjectMissingException exception) {
1344              exception.printStackTrace();
1345          }
1346      }
1347  
1348      // Checks if cursor is at a URL when the selection changes
1349      // If it is a URL, show the contextual action bar
1350      @Override
1351      public void onSelectionChanged(int selStart, int selEnd) {
1352          mCurrentCursorPosition = selEnd;
1353  
1354          if (selStart == selEnd) {
1355              Editable noteContent = mContentEditText.getText();
1356  
1357              if (noteContent == null) {
1358                  return;
1359              }
1360  
1361              URLSpan[] urlSpans = noteContent.getSpans(selStart, selStart, URLSpan.class);
1362  
1363              if (urlSpans.length &gt; 0) {
1364                  URLSpan urlSpan = urlSpans[0];
1365                  mLinkUrl = urlSpan.getURL();
<abbr title="1366                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSpan)).toString();">1366                  mLinkText = noteContent.subSequence(noteContent.getSpanStart(urlSpan), noteContent.getSpanEnd(urlSðŸ”µ</abbr>
1367  
1368                  if (mActionMode != null) {
1369                      mActionMode.setSubtitle(mLinkText);
1370                      updateMenuItems();
1371                      return;
1372                  }
1373  
1374                  // Show the Contextual Action Bar
1375                  if (getActivity() != null) {
1376                      mActionMode = ((AppCompatActivity) getActivity()).startSupportActionMode(mActionModeCallback);
1377  
1378                      if (mActionMode != null) {
1379                          mActionMode.setSubtitle(mLinkText);
1380                      }
1381  
1382                      updateMenuItems();
1383                  }
1384              } else if (mActionMode != null) {
1385                  mActionMode.finish();
1386                  mActionMode = null;
1387              }
1388          } else if (mActionMode != null) {
1389              mActionMode.finish();
1390              mActionMode = null;
1391          }
1392      }
1393  
1394      private void updateMenuItems() {
1395          mCopyMenuItem.setIcon(mCopyIcon);
1396          mShareMenuItem.setIcon(mShareIcon);
1397  
1398          if (mViewLinkMenuItem != null &amp;&amp; mLinkUrl != null) {
1399              if (mLinkUrl.startsWith(&quot;tel:&quot;)) {
1400                  mViewLinkMenuItem.setIcon(mCallIcon);
1401                  mViewLinkMenuItem.setTitle(getString(R.string.call));
1402              } else if (mLinkUrl.startsWith(&quot;mailto:&quot;)) {
1403                  mViewLinkMenuItem.setIcon(mEmailIcon);
1404                  mViewLinkMenuItem.setTitle(getString(R.string.email));
1405              } else if (mLinkUrl.startsWith(&quot;geo:&quot;)) {
1406                  mViewLinkMenuItem.setIcon(mMapIcon);
1407                  mViewLinkMenuItem.setTitle(getString(R.string.view_map));
1408              } else if (mLinkUrl.startsWith(SIMPLENOTE_LINK_PREFIX)) {
1409                  mViewLinkMenuItem.setIcon(mLinkIcon);
1410                  mViewLinkMenuItem.setTitle(getString(R.string.open_note));
1411              } else {
1412                  mViewLinkMenuItem.setIcon(mBrowserIcon);
1413                  mViewLinkMenuItem.setTitle(getString(R.string.view_in_browser));
1414              }
1415          }
1416      }
1417  
1418      private void setPublishedNote(boolean isPublished) {
1419          if (mNote != null) {
1420              mNote.setPublished(isPublished);
1421              mNote.save();
1422  
1423              // reset publish status in 20 seconds if we don&#x27;t hear back from Simperium
1424              mPublishTimeoutHandler.postDelayed(mPublishTimeoutRunnable, PUBLISH_TIMEOUT);
1425  
1426              AnalyticsTracker.track(
1427                  isPublished ? EDITOR_NOTE_PUBLISHED : EDITOR_NOTE_UNPUBLISHED,
1428                  CATEGORY_NOTE,
1429                  &quot;publish_note_button&quot;
1430              );
1431          }
1432      }
1433  
1434      private void updatePublishedState(boolean isSuccess) {
1435          if (mPublishingSnackbar == null) {
1436              return;
1437          }
1438  
1439          mPublishingSnackbar.dismiss();
1440          mPublishingSnackbar = null;
1441  
1442          if (isSuccess &amp;&amp; isAdded()) {
1443              if (mNote.isPublished()) {
1444                  if (mHideActionOnSuccess) {
1445                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG).show();
1446                  } else {
1447                      Snackbar.make(mRootView, R.string.publish_successful, Snackbar.LENGTH_LONG)
1448                          .setAction(
1449                              R.string.undo,
1450                              new View.OnClickListener() {
1451                                  @Override
1452                                  public void onClick(View v) {
1453                                      mHideActionOnSuccess = true;
1454                                      unpublishNote();
1455                                  }
1456                              }
1457                          )
1458                          .show();
1459                  }
1460              } else {
1461                  if (mHideActionOnSuccess) {
1462                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG).show();
1463                  } else {
1464                      Snackbar.make(mRootView, R.string.unpublish_successful, Snackbar.LENGTH_LONG)
1465                          .setAction(
1466                              R.string.undo,
1467                              new View.OnClickListener() {
1468                                  @Override
1469                                  public void onClick(View v) {
1470                                      mHideActionOnSuccess = true;
1471                                      publishNote();
1472                                  }
1473                              }
1474                          )
1475                          .show();
1476                  }
1477              }
1478          } else {
1479              if (mNote.isPublished()) {
1480                  Snackbar.make(mRootView, R.string.unpublish_error, Snackbar.LENGTH_LONG)
1481                      .setAction(
1482                          R.string.retry,
1483                          new View.OnClickListener() {
1484                              @Override
1485                              public void onClick(View v) {
1486                                  mHideActionOnSuccess = true;
1487                                  unpublishNote();
1488                              }
1489                          }
1490                      )
1491                      .show();
1492              } else {
1493                  Snackbar.make(mRootView, R.string.publish_error, Snackbar.LENGTH_LONG)
1494                      .setAction(
1495                          R.string.retry,
1496                          new View.OnClickListener() {
1497                              @Override
1498                              public void onClick(View v) {
1499                                  mHideActionOnSuccess = true;
1500                                  publishNote();
1501                              }
1502                          }
1503                      )
1504                      .show();
1505              }
1506          }
1507  
1508          mHideActionOnSuccess = false;
1509          requireActivity().invalidateOptionsMenu();
1510      }
1511  
1512      private void publishNote() {
1513          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1514              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1515              return;
1516          }
1517  
1518          if (isAdded()) {
1519              mPublishingSnackbar = Snackbar.make(mRootView, R.string.publishing, Snackbar.LENGTH_INDEFINITE);
1520              mPublishingSnackbar.show();
1521          }
1522  
1523          setPublishedNote(true);
1524      }
1525  
1526      private void unpublishNote() {
1527          if (!NetworkUtils.isNetworkAvailable(requireContext())) {
1528              Toast.makeText(requireContext(), R.string.error_network_required, Toast.LENGTH_LONG).show();
1529              return;
1530          }
1531  
1532          if (isAdded()) {
1533              mPublishingSnackbar = Snackbar.make(mRootView, R.string.unpublishing, Snackbar.LENGTH_INDEFINITE);
1534              mPublishingSnackbar.show();
1535          }
1536  
1537          setPublishedNote(false);
1538      }
1539  
1540      private void showShare(String text) {
1541          startActivity(
1542              ShareCompat.IntentBuilder.from(requireActivity())
1543                  .setText(text)
1544                  .setType(&quot;text/plain&quot;)
1545                  .createChooserIntent()
1546          );
1547      }
1548      private void showShareSheet() {
1549          if (isAdded() &amp;&amp; mShareBottomSheet != null &amp;&amp; !mShareBottomSheet.isAdded()) {
1550              mShareBottomSheet.show(requireFragmentManager(), mNote);
1551          }
1552      }
1553  
1554      private void showInfoSheet() {
1555          if (isAdded() &amp;&amp; mInfoBottomSheet != null &amp;&amp; !mInfoBottomSheet.isAdded()) {
1556              mInfoBottomSheet.show(requireFragmentManager(), mNote);
1557          }
1558      }
1559  
1560      private void showHistorySheet() {
1561          if (isAdded() &amp;&amp; mHistoryBottomSheet != null &amp;&amp; !mHistoryBottomSheet.isAdded()) {
1562              // Request revisions for the current note
1563              mNotesBucket.getRevisions(mNote, MAX_REVISIONS, mHistoryBottomSheet.getRevisionsRequestCallbacks());
1564              saveNote();
1565  
1566              mHistoryBottomSheet.show(requireFragmentManager(), mNote);
1567          }
1568      }
1569  
1570      @Override
1571      public void onDeleteObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1572      }
1573  
1574      @Override
1575      public void onNetworkChange(Bucket&lt;Note&gt; noteBucket, Bucket.ChangeType changeType, final String key) {
1576          if (changeType == Bucket.ChangeType.MODIFY) {
1577              if (getNote() != null &amp;&amp; getNote().getSimperiumKey().equals(key)) {
1578                  try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1579 -                    mNotesBucket = noteBucket;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1580 -                    final Note updatedNote = mNotesBucket.get(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1581 +                    final Note updatedNote = noteBucket.get(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1582 +</span>
1583                      if (getActivity() != null) {
1584                          getActivity().runOnUiThread(new Runnable() {
1585                              @Override
1586                              public void run() {
1587                                  if (mPublishTimeoutHandler != null) {
1588                                      mPublishTimeoutHandler.removeCallbacks(mPublishTimeoutRunnable);
1589                                  }
1590  
1591                                  updateNote(updatedNote);
1592                                  updatePublishedState(true);
1593                              }
1594                          });
1595                      }
1596                  } catch (BucketObjectMissingException e) {
1597                      e.printStackTrace();
1598                  }
1599              }
1600          }
1601      }
1602  
1603      @Override
1604      public void onSaveObject(Bucket&lt;Note&gt; noteBucket, Note note) {
1605          if (mIsPaused) {
1606              mNotesBucket.removeListener(this);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1607 -            mNotesBucket.stop();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1608 -            AppLog.add(Type.SYNC, &quot;Stopped note bucket (NoteEditorFragment)&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1609 +            AppLog.add(Type.SYNC, &quot;Removed note bucket listener (NoteEditorFragment)&quot;);</span>
1610          }
1611  
1612          AppLog.add(
1613              Type.SYNC,
1614              &quot;Saved note callback in NoteEditorFragment (ID: &quot; + note.getSimperiumKey() +
1615                  &quot; / Title: &quot; + note.getTitle() +
1616                  &quot; / Characters: &quot; + NoteUtils.getCharactersCount(note.getContent()) +
1617                  &quot; / Words: &quot; + NoteUtils.getWordCount(note.getContent()) + &quot;)&quot;
1618          );
1619      }
1620  
1621      @Override
1622      public void onBeforeUpdateObject(Bucket&lt;Note&gt; bucket, Note note) {
1623          // Don&#x27;t apply updates if we haven&#x27;t loaded the note yet
1624          if (mIsLoadingNote)
1625              return;
1626  
1627          Note openNote = getNote();
1628          if (openNote == null || !openNote.getSimperiumKey().equals(note.getSimperiumKey()))
1629              return;
1630  
1631          note.setContent(mContentEditText.getPlainTextContent());
1632      }
1633  
1634      private static class LoadNoteTask extends AsyncTask&lt;String, Void, Void&gt; {
1635          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1636  
1637          LoadNoteTask(NoteEditorFragment fragment) {
1638              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1639          }
1640  
1641          @Override
1642          protected void onPreExecute() {
1643              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1644  
1645              if (fragment != null) {
1646                  fragment.mContentEditText.removeTextChangedListener(fragment);
1647                  fragment.mIsLoadingNote = true;
1648              }
1649          }
1650  
1651          @Override
1652          protected Void doInBackground(String... args) {
1653              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1654  
1655              if (fragment == null || fragment.getActivity() == null) {
1656                  return null;
1657              }
1658  
1659              String noteID = args[0];
1660              Simplenote application = (Simplenote) fragment.getActivity().getApplication();
1661              Bucket&lt;Note&gt; notesBucket = application.getNotesBucket();
1662  
1663              try {
1664                  fragment.mNote = notesBucket.get(noteID);
1665  
1666                  // Set the current note in NotesActivity when on a tablet
1667                  if (fragment.getActivity() instanceof NotesActivity) {
1668                      ((NotesActivity) fragment.getActivity()).setCurrentNote(fragment.mNote);
1669                  }
1670  
1671                  // Set markdown and preview flags for current note
1672                  if (fragment.mNote != null) {
1673                      fragment.mIsMarkdownEnabled = fragment.mNote.isMarkdownEnabled();
1674                      fragment.mIsPreviewEnabled = fragment.mNote.isPreviewEnabled();
1675                      AppLog.add(
1676                          Type.SYNC,
1677                          &quot;Loaded note (ID: &quot; + fragment.mNote.getSimperiumKey() +
1678                              &quot; / Title: &quot; + fragment.mNote.getTitle() +
1679                              &quot; / Characters: &quot; + NoteUtils.getCharactersCount(fragment.mNote.getContent()) +
1680                              &quot; / Words: &quot; + NoteUtils.getWordCount(fragment.mNote.getContent()) + &quot;)&quot;
1681                      );
1682                  }
1683              } catch (BucketObjectMissingException e) {
1684                  // See if the note is in the object store
1685                  Bucket.ObjectCursor&lt;Note&gt; notesCursor = notesBucket.allObjects();
1686  
1687                  while (notesCursor.moveToNext()) {
1688                      Note currentNote = notesCursor.getObject();
1689  
1690                      if (currentNote != null &amp;&amp; currentNote.getSimperiumKey().equals(noteID)) {
1691                          fragment.mNote = currentNote;
1692                          return null;
1693                      }
1694                  }
1695              }
1696  
1697              return null;
1698          }
1699  
1700          @Override
1701          protected void onPostExecute(Void nada) {
1702              final NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1703              if (fragment == null || fragment.getActivity() == null || fragment.getActivity().isFinishing()) {
1704                  return;
1705              }
1706  
1707              fragment.refreshContent(false);
1708  
1709              if (fragment.mMatchOffsets != null) {
<abbr title="1710                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.CONTENT_PROPERTY);">1710                  int columnIndex = fragment.mNote.getBucket().getSchema().getFullTextIndex().getColumnIndex(Note.COðŸ”µ</abbr>
1711                  fragment.mHighlighter.highlightMatches(fragment.mMatchOffsets, columnIndex);
1712                  fragment.mShouldScrollToSearchMatch = true;
1713              }
1714  
1715              fragment.mContentEditText.addTextChangedListener(fragment);
1716  
1717              if (fragment.mNote != null &amp;&amp; fragment.mNote.getContent().isEmpty()) {
1718                  // Show soft keyboard
1719                  fragment.mContentEditText.requestFocus();
1720  
1721                  new Handler().postDelayed(new Runnable() {
1722                      @Override
1723                      public void run() {
1724                          if (fragment.getActivity() == null) {
1725                              return;
1726                          }
1727  
<abbr title="1728                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);">1728                          InputMethodManager inputMethodManager = (InputMethodManager) fragment.getActivity().getSysðŸ”µ</abbr>
1729  
1730                          if (inputMethodManager != null) {
1731                              inputMethodManager.showSoftInput(fragment.mContentEditText, 0);
1732                          }
1733                      }
1734                  }, 100);
1735              } else if (fragment.mNote != null) {
1736                  // If we have a valid note, hide the placeholder
1737                  fragment.setPlaceholderVisible(false);
1738              }
1739  
1740              fragment.updateMarkdownView();
1741              fragment.requireActivity().invalidateOptionsMenu();
1742              fragment.linkifyEditorContent();
1743              fragment.mIsLoadingNote = false;
1744          }
1745      }
1746  
1747      private static class SaveNoteTask extends AsyncTask&lt;Void, Void, Void&gt; {
1748          WeakReference&lt;NoteEditorFragment&gt; mNoteEditorFragmentReference;
1749  
1750          SaveNoteTask(NoteEditorFragment fragment) {
1751              mNoteEditorFragmentReference = new WeakReference&lt;&gt;(fragment);
1752          }
1753  
1754          @Override
1755          protected Void doInBackground(Void... args) {
1756              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1757  
1758              if (fragment != null) {
1759                  fragment.saveNote();
1760              }
1761  
1762              return null;
1763          }
1764  
1765          @Override
1766          protected void onPostExecute(Void nada) {
1767              NoteEditorFragment fragment = mNoteEditorFragmentReference.get();
1768  
1769              if (fragment != null &amp;&amp; fragment.getActivity() != null &amp;&amp; !fragment.getActivity().isFinishing()) {
1770                  // Update links
1771                  fragment.linkifyEditorContent();
1772                  fragment.updateMarkdownView();
1773              }
1774          }
1775      }
1776  
1777      private void linkifyEditorContent() {
1778          if (getActivity() == null || getActivity().isFinishing()) {
1779              return;
1780          }
1781  
1782          if (PrefUtils.getBoolPref(getActivity(), PrefUtils.PREF_DETECT_LINKS)) {
1783              SimplenoteLinkify.addLinks(mContentEditText, Linkify.ALL);
1784          }
1785      }
1786  
1787      // Show tabs if markdown is enabled globally, for current note, and not tablet landscape
1788      private void updateMarkdownView() {
1789          if (!mIsMarkdownEnabled) {
1790              return;
1791          }
1792  
1793          Activity activity = getActivity();
1794          if (activity instanceof NotesActivity) {
1795              // This fragment lives in NotesActivity, so load markdown in this fragment&#x27;s WebView.
1796              loadMarkdownData();
1797          } else {
1798              // This fragment lives in the NoteEditorActivity&#x27;s ViewPager.
1799              if (mNoteMarkdownFragment == null) {
1800                  mNoteMarkdownFragment = ((NoteEditorActivity) requireActivity())
1801                          .getNoteMarkdownFragment();
1802                  ((NoteEditorActivity) requireActivity()).showTabs();
1803              }
1804              // Load markdown in the sibling NoteMarkdownFragment&#x27;s WebView.
1805              mNoteMarkdownFragment.updateMarkdown(mContentEditText.getPreviewTextContent());
1806          }
1807      }
1808  
1809      private ColorStateList getChipBackgroundColor() {
1810          int[][] states = new int[][] {
1811              new int[] { android.R.attr.state_checked}, // checked
1812              new int[] {-android.R.attr.state_checked}  // unchecked
1813          };
1814  
1815          int[] colors = new int[] {
1816              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOnBackgroundColor),
1817              ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipCheckedOffBackgroundColor)
1818          };
1819  
1820          return new ColorStateList(states, colors);
1821      }
1822  
1823      private void setChips(CharSequence text) {
1824          mTagPadding.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1825          mTagChips.setVisibility(text.length() &gt; 0 ? View.VISIBLE : View.GONE);
1826          mTagChips.setSingleSelection(true);
1827          mTagChips.removeAllViews();
1828          SimpleStringSplitter tags = new SimpleStringSplitter(SPACE);
1829          tags.setString(text.toString());
1830  
1831          for (String tag : tags) {
1832              final Chip chip = new Chip(requireContext());
1833              chip.setText(tag);
1834              chip.setCheckable(true);
1835              chip.setCheckedIcon(null);
1836              chip.setChipBackgroundColor(getChipBackgroundColor());
1837              chip.setTextColor(ThemeUtils.getColorFromAttribute(requireContext(), R.attr.chipTextColor));
1838              chip.setStateListAnimator(null);
1839              chip.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
1840                  @Override
1841                  public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
1842                      chip.setCloseIconVisible(isChecked);
1843                  }
1844              });
1845              chip.setOnCloseIconClickListener(new View.OnClickListener() {
1846                  @Override
1847                  public void onClick(View view) {
1848                      mTagChips.removeView(view);
1849                      updateTags();
1850                      AnalyticsTracker.track(
1851                          EDITOR_TAG_REMOVED,
1852                          CATEGORY_NOTE,
1853                          &quot;tag_removed_from_note&quot;
1854                      );
1855                  }
1856              });
1857              mTagChips.addView(chip);
1858          }
1859      }
1860  
1861      private void updateTags() {
1862          if (mNote == null) {
1863              return;
1864          }
1865  
1866          mNote.setTagString(getNoteTagsString());
1867          mNote.setModificationDate(Calendar.getInstance());
1868          updateTagList();
1869          mNote.save();
1870      }
1871  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            