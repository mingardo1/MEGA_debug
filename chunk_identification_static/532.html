<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>532</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    532
                    <a href="531.html">prev</a>
                    <a href="533.html">next</a>
                    <a href="532_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_90abcc94258ba9d9c8b68ac9764b6ab1eba12985_src/com/android/launcher2/CellLayout.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;90abcc94258ba9d9c8b68ac9764b6ab1eba12985:src/com/android/launcher2/CellLayout.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;90abcc94258ba9d9c8b68ac9764b6ab1eba12985^1:src/com/android/launcher2/CellLayout.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;90abcc94258ba9d9c8b68ac9764b6ab1eba12985^2:src/com/android/launcher2/CellLayout.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;bf5529bd401ad471658b878f313e32ed8639b479:src/com/android/launcher2/CellLayout.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  23 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  24 import android.animation.AnimatorListenerAdapter;</span>
  25 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  26 import android.animation.ObjectAnimator;</span>
  27 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  28 import android.animation.TimeInterpolator;
  29 import android.animation.ValueAnimator;
  30 import android.animation.ValueAnimator.AnimatorUpdateListener;
  31 import android.content.Context;
  32 import android.content.res.Resources;
  33 import android.content.res.TypedArray;
  34 import android.graphics.Bitmap;
  35 import android.graphics.Canvas;
  36 import android.graphics.Color;
  37 import android.graphics.Paint;
  38 import android.graphics.Point;
  39 import android.graphics.PorterDuff;
  40 import android.graphics.PorterDuffXfermode;
  41 import android.graphics.Rect;
  42 import android.graphics.drawable.ColorDrawable;
  43 import android.graphics.drawable.Drawable;
  44 import android.graphics.drawable.NinePatchDrawable;
  45 import android.os.Parcelable;
  46 import android.util.AttributeSet;
  47 import android.util.Log;
  48 import android.util.SparseArray;
  49 import android.view.MotionEvent;
  50 import android.view.View;
  51 import android.view.ViewDebug;
  52 import android.view.ViewGroup;
  53 import android.view.animation.Animation;
  54 import android.view.animation.DecelerateInterpolator;
  55 import android.view.animation.LayoutAnimationController;
  56 
  57 import com.android.launcher.R;
  58 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  59 
  60 import java.util.ArrayList;
  61 import java.util.Arrays;
  62 import java.util.HashMap;
  63 import java.util.Stack;
  64 
  65 public class CellLayout extends ViewGroup {
  66     static final String TAG = &quot;CellLayout&quot;;
  67 
  68     private Launcher mLauncher;
  69     private int mCellWidth;
  70     private int mCellHeight;
  71 
  72     private int mCountX;
  73     private int mCountY;
  74 
  75     private int mOriginalWidthGap;
  76     private int mOriginalHeightGap;
  77     private int mWidthGap;
  78     private int mHeightGap;
  79     private int mMaxGap;
  80     private boolean mScrollingTransformsDirty = false;
  81 
  82     private final Rect mRect = new Rect();
  83     private final CellInfo mCellInfo = new CellInfo();
  84 
  85     // These are temporary variables to prevent having to allocate a new object just to
  86     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  87     private final int[] mTmpXY = new int[2];
  88     private final int[] mTmpPoint = new int[2];
  89     int[] mTempLocation = new int[2];
  90 
  91     boolean[][] mOccupied;
  92     boolean[][] mTmpOccupied;
  93     private boolean mLastDownOnOccupiedCell = false;
  94 
  95     private OnTouchListener mInterceptTouchListener;
  96 
  97     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  98     private int[] mFolderLeaveBehindCell = {-1, -1};
  99 
 100     private int mForegroundAlpha = 0;
 101     private float mBackgroundAlpha;
 102     private float mBackgroundAlphaMultiplier = 1.0f;
 103 
 104     private Drawable mNormalBackground;
 105     private Drawable mActiveGlowBackground;
 106     private Drawable mOverScrollForegroundDrawable;
 107     private Drawable mOverScrollLeft;
 108     private Drawable mOverScrollRight;
 109     private Rect mBackgroundRect;
 110     private Rect mForegroundRect;
 111     private int mForegroundPadding;
 112 
 113     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 114     private boolean mIsDragOverlapping = false;
 115     private final Point mDragCenter = new Point();
 116 
 117     // These arrays are used to implement the drag visualization on x-large screens.
 118     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 119     private Rect[] mDragOutlines = new Rect[4];
 120     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 121     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 122             new InterruptibleInOutAnimator[mDragOutlines.length];
 123 
 124     // Used as an index into the above 3 arrays; indicates which is the most current value.
 125     private int mDragOutlineCurrent = 0;
 126     private final Paint mDragOutlinePaint = new Paint();
 127 
 128     private BubbleTextView mPressedOrFocusedIcon;
 129 
 130     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 131             HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 132     private HashMap&lt;View, ReorderHintAnimation&gt;
 133             mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;();
 134 
 135     private boolean mItemPlacementDirty = false;
 136 
 137     // When a drag operation is in progress, holds the nearest cell to the touch point
 138     private final int[] mDragCell = new int[2];
 139 
 140     private boolean mDragging = false;
 141 
 142     private TimeInterpolator mEaseOutInterpolator;
 143     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 144 
 145     private boolean mIsHotseat = false;
 146 
 147     public static final int MODE_DRAG_OVER = 0;
 148     public static final int MODE_ON_DROP = 1;
 149     public static final int MODE_ON_DROP_EXTERNAL = 2;
 150     public static final int MODE_ACCEPT_DROP = 3;
 151     private static final boolean DESTRUCTIVE_REORDER = false;
 152     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 153 
 154     static final int LANDSCAPE = 0;
 155     static final int PORTRAIT = 1;
 156 
 157     private static final float REORDER_HINT_MAGNITUDE = 0.12f;
 158     private static final int REORDER_ANIMATION_DURATION = 150;
 159     private float mReorderHintAnimationMagnitude;
 160 
 161     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 162     private Rect mOccupiedRect = new Rect();
 163     private int[] mDirectionVector = new int[2];
 164     int[] mPreviousReorderDirection = new int[2];
 165     private static final int INVALID_DIRECTION = -100;
 166     private DropTarget.DragEnforcer mDragEnforcer;
 167 
 168     private final static PorterDuffXfermode sAddBlendMode =
 169             new PorterDuffXfermode(PorterDuff.Mode.ADD);
 170     private final static Paint sPaint = new Paint();
 171 
 172     public CellLayout(Context context) {
 173         this(context, null);
 174     }
 175 
 176     public CellLayout(Context context, AttributeSet attrs) {
 177         this(context, attrs, 0);
 178     }
 179 
 180     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 181         super(context, attrs, defStyle);
 182         mDragEnforcer = new DropTarget.DragEnforcer(context);
 183 
 184         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 185         // the user where a dragged item will land when dropped.
 186         setWillNotDraw(false);
 187         mLauncher = (Launcher) context;
 188 
 189         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 190 
 191         mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 192         mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 193         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 194         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 195         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 196         mCountX = LauncherModel.getCellCountX();
 197         mCountY = LauncherModel.getCellCountY();
 198         mOccupied = new boolean[mCountX][mCountY];
 199         mTmpOccupied = new boolean[mCountX][mCountY];
 200         mPreviousReorderDirection[0] = INVALID_DIRECTION;
 201         mPreviousReorderDirection[1] = INVALID_DIRECTION;
 202 
 203         a.recycle();
 204 
 205         setAlwaysDrawnWithCacheEnabled(false);
 206 
 207         final Resources res = getResources();
 208 
 209         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 210         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 211 
 212         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 213         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 214         mForegroundPadding =
 215                 res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 216 
 217         mReorderHintAnimationMagnitude = (REORDER_HINT_MAGNITUDE *
 218                 res.getDimensionPixelSize(R.dimen.app_icon_size));
 219 
 220         mNormalBackground.setFilterBitmap(true);
 221         mActiveGlowBackground.setFilterBitmap(true);
 222 
 223         // Initialize the data structures used for the drag visualization.
 224 
 225         mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 226 
 227 
 228         mDragCell[0] = mDragCell[1] = -1;
 229         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 230             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 231         }
 232 
 233         // When dragging things around the home screens, we show a green outline of
 234         // where the item will land. The outlines gradually fade out, leaving a trail
 235         // behind the drag path.
 236         // Set up all the animations that are used to implement this fading.
 237         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 238         final float fromAlphaValue = 0;
 239         final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 240 
 241         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 242 
 243         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 244             final InterruptibleInOutAnimator anim =
 245                 new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 246             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 247             final int thisIndex = i;
 248             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 249                 public void onAnimationUpdate(ValueAnimator animation) {
 250                     final Bitmap outline = (Bitmap)anim.getTag();
 251 
 252                     // If an animation is started and then stopped very quickly, we can still
 253                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 254                     if (outline == null) {
 255                         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 256                         final boolean debug = false;
 257                         if (debug) {
 258                             Object val = animation.getAnimatedValue();
 259                             Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 260                                      &quot;, isStopped &quot; + anim.isStopped());
 261                         }
 262                         // Try to prevent it from continuing to run
 263                         animation.cancel();
 264                     } else {
 265                         mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 266                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 267                     }
 268                 }
 269             });
 270             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 271             // running. This way the bitmap can be GCed when the animations are complete.
 272             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 273                 @Override
 274                 public void onAnimationEnd(Animator animation) {
 275                     if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 276                         anim.setTag(null);
 277                     }
 278                 }
 279             });
 280             mDragOutlineAnims[i] = anim;
 281         }
 282 
 283         mBackgroundRect = new Rect();
 284         mForegroundRect = new Rect();
 285 
 286         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 287         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 288         addView(mShortcutsAndWidgets);
 289     }
 290 
 291     static int widthInPortrait(Resources r, int numCells) {
 292         // We use this method from Workspace to figure out how many rows/columns Launcher should
 293         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 294         // the padding extends outside the visible screen size, but it looked fine anyway.
 295         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 296         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 297                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 298 
 299         return  minGap * (numCells - 1) + cellWidth * numCells;
 300     }
 301 
 302     static int heightInLandscape(Resources r, int numCells) {
 303         // We use this method from Workspace to figure out how many rows/columns Launcher should
 304         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 305         // the padding extends outside the visible screen size, but it looked fine anyway.
 306         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 307         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 308                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 309 
 310         return minGap * (numCells - 1) + cellHeight * numCells;
 311     }
 312 
 313     public void enableHardwareLayers() {
 314         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_HARDWARE, sPaint);
 315     }
 316 
 317     public void disableHardwareLayers() {
 318         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_NONE, sPaint);
 319     }
 320 
 321     public void buildHardwareLayer() {
 322         mShortcutsAndWidgets.buildLayer();
 323     }
 324 
 325     public void setGridSize(int x, int y) {
 326         mCountX = x;
 327         mCountY = y;
 328         mOccupied = new boolean[mCountX][mCountY];
 329         mTmpOccupied = new boolean[mCountX][mCountY];
 330         mTempRectStack.clear();
 331         requestLayout();
 332     }
 333 
 334     private void invalidateBubbleTextView(BubbleTextView icon) {
 335         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 336         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 337                 icon.getTop() + getPaddingTop() - padding,
 338                 icon.getRight() + getPaddingLeft() + padding,
 339                 icon.getBottom() + getPaddingTop() + padding);
 340     }
 341 
 342     void setOverScrollAmount(float r, boolean left) {
 343         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 344             mOverScrollForegroundDrawable = mOverScrollLeft;
 345         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 346             mOverScrollForegroundDrawable = mOverScrollRight;
 347         }
 348 
 349         mForegroundAlpha = (int) Math.round((r * 255));
 350         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 351         invalidate();
 352     }
 353 
 354     void setPressedOrFocusedIcon(BubbleTextView icon) {
 355         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 356         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 357         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 358         mPressedOrFocusedIcon = icon;
 359         if (oldIcon != null) {
 360             invalidateBubbleTextView(oldIcon);
 361         }
 362         if (mPressedOrFocusedIcon != null) {
 363             invalidateBubbleTextView(mPressedOrFocusedIcon);
 364         }
 365     }
 366 
 367     void setIsDragOverlapping(boolean isDragOverlapping) {
 368         if (mIsDragOverlapping != isDragOverlapping) {
 369             mIsDragOverlapping = isDragOverlapping;
 370             invalidate();
 371         }
 372     }
 373 
 374     boolean getIsDragOverlapping() {
 375         return mIsDragOverlapping;
 376     }
 377 
 378     protected void setOverscrollTransformsDirty(boolean dirty) {
 379         mScrollingTransformsDirty = dirty;
 380     }
 381 
 382     protected void resetOverscrollTransforms() {
 383         if (mScrollingTransformsDirty) {
 384             setOverscrollTransformsDirty(false);
 385             setTranslationX(0);
 386             setRotationY(0);
 387             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 388             // pass 0, which results in the overscroll drawable not being drawn any more.
 389             setOverScrollAmount(0, false);
 390             setPivotX(getMeasuredWidth() / 2);
 391             setPivotY(getMeasuredHeight() / 2);
 392         }
 393     }
 394 
 395     @Override
 396     protected void onDraw(Canvas canvas) {
 397         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 398         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 399         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 400         // a drag). However, we also drag the mini hover background *over* one of those two
 401         // backgrounds
 402         if (mBackgroundAlpha &gt; 0.0f) {
 403             Drawable bg;
 404 
 405             if (mIsDragOverlapping) {
 406                 // In the mini case, we draw the active_glow bg *over* the active background
 407                 bg = mActiveGlowBackground;
 408             } else {
 409                 bg = mNormalBackground;
 410             }
 411 
 412             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 413             bg.setBounds(mBackgroundRect);
 414             bg.draw(canvas);
 415         }
 416 
 417         final Paint paint = mDragOutlinePaint;
 418         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 419             final float alpha = mDragOutlineAlphas[i];
 420             if (alpha &gt; 0) {
 421                 final Rect r = mDragOutlines[i];
 422                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 423                 paint.setAlpha((int)(alpha + .5f));
 424                 canvas.drawBitmap(b, null, r, paint);
 425             }
 426         }
 427 
 428         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 429         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 430         if (mPressedOrFocusedIcon != null) {
 431             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 432             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 433             if (b != null) {
 434                 canvas.drawBitmap(b,
 435                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 436                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 437                         null);
 438             }
 439         }
 440 
 441         if (DEBUG_VISUALIZE_OCCUPIED) {
 442             int[] pt = new int[2];
 443             ColorDrawable cd = new ColorDrawable(Color.RED);
 444             cd.setBounds(0, 0,  mCellWidth, mCellHeight);
 445             for (int i = 0; i &lt; mCountX; i++) {
 446                 for (int j = 0; j &lt; mCountY; j++) {
 447                     if (mOccupied[i][j]) {
 448                         cellToPoint(i, j, pt);
 449                         canvas.save();
 450                         canvas.translate(pt[0], pt[1]);
 451                         cd.draw(canvas);
 452                         canvas.restore();
 453                     }
 454                 }
 455             }
 456         }
 457 
 458         int previewOffset = FolderRingAnimator.sPreviewSize;
 459 
 460         // The folder outer / inner ring image(s)
 461         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 462             FolderRingAnimator fra = mFolderOuterRings.get(i);
 463 
 464             // Draw outer ring
 465             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 466             int width = (int) fra.getOuterRingSize();
 467             int height = width;
 468             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 469 
 470             int centerX = mTempLocation[0] + mCellWidth / 2;
 471             int centerY = mTempLocation[1] + previewOffset / 2;
 472 
 473             canvas.save();
 474             canvas.translate(centerX - width / 2, centerY - height / 2);
 475             d.setBounds(0, 0, width, height);
 476             d.draw(canvas);
 477             canvas.restore();
 478 
 479             // Draw inner ring
 480             d = FolderRingAnimator.sSharedInnerRingDrawable;
 481             width = (int) fra.getInnerRingSize();
 482             height = width;
 483             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 484 
 485             centerX = mTempLocation[0] + mCellWidth / 2;
 486             centerY = mTempLocation[1] + previewOffset / 2;
 487             canvas.save();
 488             canvas.translate(centerX - width / 2, centerY - width / 2);
 489             d.setBounds(0, 0, width, height);
 490             d.draw(canvas);
 491             canvas.restore();
 492         }
 493 
 494         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 495             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 496             int width = d.getIntrinsicWidth();
 497             int height = d.getIntrinsicHeight();
 498 
 499             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 500             int centerX = mTempLocation[0] + mCellWidth / 2;
 501             int centerY = mTempLocation[1] + previewOffset / 2;
 502 
 503             canvas.save();
 504             canvas.translate(centerX - width / 2, centerY - width / 2);
 505             d.setBounds(0, 0, width, height);
 506             d.draw(canvas);
 507             canvas.restore();
 508         }
 509     }
 510 
 511     @Override
 512     protected void dispatchDraw(Canvas canvas) {
 513         super.dispatchDraw(canvas);
 514         if (mForegroundAlpha &gt; 0) {
 515             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 516             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 517             p.setXfermode(sAddBlendMode);
 518             mOverScrollForegroundDrawable.draw(canvas);
 519             p.setXfermode(null);
 520         }
 521     }
 522 
 523     public void showFolderAccept(FolderRingAnimator fra) {
 524         mFolderOuterRings.add(fra);
 525     }
 526 
 527     public void hideFolderAccept(FolderRingAnimator fra) {
 528         if (mFolderOuterRings.contains(fra)) {
 529             mFolderOuterRings.remove(fra);
 530         }
 531         invalidate();
 532     }
 533 
 534     public void setFolderLeaveBehindCell(int x, int y) {
 535         mFolderLeaveBehindCell[0] = x;
 536         mFolderLeaveBehindCell[1] = y;
 537         invalidate();
 538     }
 539 
 540     public void clearFolderLeaveBehind() {
 541         mFolderLeaveBehindCell[0] = -1;
 542         mFolderLeaveBehindCell[1] = -1;
 543         invalidate();
 544     }
 545 
 546     @Override
 547     public boolean shouldDelayChildPressedState() {
 548         return false;
 549     }
 550 
 551     public void restoreInstanceState(SparseArray&lt;Parcelable&gt; states) {
 552         dispatchRestoreInstanceState(states);
 553     }
 554 
 555     @Override
 556     public void cancelLongPress() {
 557         super.cancelLongPress();
 558 
 559         // Cancel long press for all children
 560         final int count = getChildCount();
 561         for (int i = 0; i &lt; count; i++) {
 562             final View child = getChildAt(i);
 563             child.cancelLongPress();
 564         }
 565     }
 566 
 567     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 568         mInterceptTouchListener = listener;
 569     }
 570 
 571     int getCountX() {
 572         return mCountX;
 573     }
 574 
 575     int getCountY() {
 576         return mCountY;
 577     }
 578 
 579     public void setIsHotseat(boolean isHotseat) {
 580         mIsHotseat = isHotseat;
 581     }
 582 
 583     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 584             boolean markCells) {
 585         final LayoutParams lp = params;
 586 
 587         // Hotseat icons - remove text
 588         if (child instanceof BubbleTextView) {
 589             BubbleTextView bubbleChild = (BubbleTextView) child;
 590 
 591             Resources res = getResources();
 592             if (mIsHotseat) {
 593                 bubbleChild.setTextColor(res.getColor(android.R.color.transparent));
 594             } else {
 595                 bubbleChild.setTextColor(res.getColor(R.color.workspace_icon_text_color));
 596             }
 597         }
 598 
 599         // Generate an id for each view, this assumes we have at most 256x256 cells
 600         // per workspace screen
 601         if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 602             // If the horizontal or vertical span is set to -1, it is taken to
 603             // mean that it spans the extent of the CellLayout
 604             if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 605             if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 606 
 607             child.setId(childId);
 608 
 609             mShortcutsAndWidgets.addView(child, index, lp);
 610 
 611             if (markCells) markCellsAsOccupiedForView(child);
 612 
 613             return true;
 614         }
 615         return false;
 616     }
 617 
 618     @Override
 619     public void removeAllViews() {
 620         clearOccupiedCells();
 621         mShortcutsAndWidgets.removeAllViews();
 622     }
 623 
 624     @Override
 625     public void removeAllViewsInLayout() {
 626         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 627             clearOccupiedCells();
 628             mShortcutsAndWidgets.removeAllViewsInLayout();
 629         }
 630     }
 631 
 632     public void removeViewWithoutMarkingCells(View view) {
 633         mShortcutsAndWidgets.removeView(view);
 634     }
 635 
 636     @Override
 637     public void removeView(View view) {
 638         markCellsAsUnoccupiedForView(view);
 639         mShortcutsAndWidgets.removeView(view);
 640     }
 641 
 642     @Override
 643     public void removeViewAt(int index) {
 644         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 645         mShortcutsAndWidgets.removeViewAt(index);
 646     }
 647 
 648     @Override
 649     public void removeViewInLayout(View view) {
 650         markCellsAsUnoccupiedForView(view);
 651         mShortcutsAndWidgets.removeViewInLayout(view);
 652     }
 653 
 654     @Override
 655     public void removeViews(int start, int count) {
 656         for (int i = start; i &lt; start + count; i++) {
 657             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 658         }
 659         mShortcutsAndWidgets.removeViews(start, count);
 660     }
 661 
 662     @Override
 663     public void removeViewsInLayout(int start, int count) {
 664         for (int i = start; i &lt; start + count; i++) {
 665             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 666         }
 667         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 668     }
 669 
 670     @Override
 671     protected void onAttachedToWindow() {
 672         super.onAttachedToWindow();
 673         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 674     }
 675 
 676     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 677         final CellInfo cellInfo = mCellInfo;
 678         Rect frame = mRect;
 679         final int x = touchX + getScrollX();
 680         final int y = touchY + getScrollY();
 681         final int count = mShortcutsAndWidgets.getChildCount();
 682 
 683         boolean found = false;
 684         for (int i = count - 1; i &gt;= 0; i--) {
 685             final View child = mShortcutsAndWidgets.getChildAt(i);
 686             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 687 
 688             if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 689                     lp.isLockedToGrid) {
 690                 child.getHitRect(frame);
 691 
 692                 float scale = child.getScaleX();
 693                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 694                         child.getBottom());
 695                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 696                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 697                 // to this view.
 698                 frame.offset(getPaddingLeft(), getPaddingTop());
 699                 frame.inset((int) (frame.width() * (1f - scale) / 2),
 700                         (int) (frame.height() * (1f - scale) / 2));
 701 
 702                 if (frame.contains(x, y)) {
 703                     cellInfo.cell = child;
 704                     cellInfo.cellX = lp.cellX;
 705                     cellInfo.cellY = lp.cellY;
 706                     cellInfo.spanX = lp.cellHSpan;
 707                     cellInfo.spanY = lp.cellVSpan;
 708                     found = true;
 709                     break;
 710                 }
 711             }
 712         }
 713 
 714         mLastDownOnOccupiedCell = found;
 715 
 716         if (!found) {
 717             final int cellXY[] = mTmpXY;
 718             pointToCellExact(x, y, cellXY);
 719 
 720             cellInfo.cell = null;
 721             cellInfo.cellX = cellXY[0];
 722             cellInfo.cellY = cellXY[1];
 723             cellInfo.spanX = 1;
 724             cellInfo.spanY = 1;
 725         }
 726         setTag(cellInfo);
 727     }
 728 
 729     @Override
 730     public boolean onInterceptTouchEvent(MotionEvent ev) {
 731         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 732         // even in the case where we return early. Not clearing here was causing bugs whereby on
 733         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 734         final int action = ev.getAction();
 735 
 736         if (action == MotionEvent.ACTION_DOWN) {
 737             clearTagCellInfo();
 738         }
 739 
 740         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 741             return true;
 742         }
 743 
 744         if (action == MotionEvent.ACTION_DOWN) {
 745             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 746         }
 747 
 748         return false;
 749     }
 750 
 751     private void clearTagCellInfo() {
 752         final CellInfo cellInfo = mCellInfo;
 753         cellInfo.cell = null;
 754         cellInfo.cellX = -1;
 755         cellInfo.cellY = -1;
 756         cellInfo.spanX = 0;
 757         cellInfo.spanY = 0;
 758         setTag(cellInfo);
 759     }
 760 
 761     public CellInfo getTag() {
 762         return (CellInfo) super.getTag();
 763     }
 764 
 765     /**
 766      * Given a point, return the cell that strictly encloses that point
 767      * @param x X coordinate of the point
 768      * @param y Y coordinate of the point
 769      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 770      */
 771     void pointToCellExact(int x, int y, int[] result) {
 772         final int hStartPadding = getPaddingLeft();
 773         final int vStartPadding = getPaddingTop();
 774 
 775         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 776         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 777 
 778         final int xAxis = mCountX;
 779         final int yAxis = mCountY;
 780 
 781         if (result[0] &lt; 0) result[0] = 0;
 782         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 783         if (result[1] &lt; 0) result[1] = 0;
 784         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 785     }
 786 
 787     /**
 788      * Given a point, return the cell that most closely encloses that point
 789      * @param x X coordinate of the point
 790      * @param y Y coordinate of the point
 791      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 792      */
 793     void pointToCellRounded(int x, int y, int[] result) {
 794         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 795     }
 796 
 797     /**
 798      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 799      *
 800      * @param cellX X coordinate of the cell
 801      * @param cellY Y coordinate of the cell
 802      *
 803      * @param result Array of 2 ints to hold the x and y coordinate of the point
 804      */
 805     void cellToPoint(int cellX, int cellY, int[] result) {
 806         final int hStartPadding = getPaddingLeft();
 807         final int vStartPadding = getPaddingTop();
 808 
 809         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 810         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 811     }
 812 
 813     /**
 814      * Given a cell coordinate, return the point that represents the center of the cell
 815      *
 816      * @param cellX X coordinate of the cell
 817      * @param cellY Y coordinate of the cell
 818      *
 819      * @param result Array of 2 ints to hold the x and y coordinate of the point
 820      */
 821     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 822         regionToCenterPoint(cellX, cellY, 1, 1, result);
 823     }
 824 
 825     /**
 826      * Given a cell coordinate and span return the point that represents the center of the regio
 827      *
 828      * @param cellX X coordinate of the cell
 829      * @param cellY Y coordinate of the cell
 830      *
 831      * @param result Array of 2 ints to hold the x and y coordinate of the point
 832      */
 833     void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 834         final int hStartPadding = getPaddingLeft();
 835         final int vStartPadding = getPaddingTop();
 836         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 837                 (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 838         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 839                 (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
 840     }
 841 
 842      /**
 843      * Given a cell coordinate and span fills out a corresponding pixel rect
 844      *
 845      * @param cellX X coordinate of the cell
 846      * @param cellY Y coordinate of the cell
 847      * @param result Rect in which to write the result
 848      */
 849      void regionToRect(int cellX, int cellY, int spanX, int spanY, Rect result) {
 850         final int hStartPadding = getPaddingLeft();
 851         final int vStartPadding = getPaddingTop();
 852         final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);
 853         final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);
 854         result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),
 855                 top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
 856     }
 857 
 858     public float getDistanceFromCell(float x, float y, int[] cell) {
 859         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 860         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 861                 Math.pow(y - mTmpPoint[1], 2));
 862         return distance;
 863     }
 864 
 865     int getCellWidth() {
 866         return mCellWidth;
 867     }
 868 
 869     int getCellHeight() {
 870         return mCellHeight;
 871     }
 872 
 873     int getWidthGap() {
 874         return mWidthGap;
 875     }
 876 
 877     int getHeightGap() {
 878         return mHeightGap;
 879     }
 880 
 881     Rect getContentRect(Rect r) {
 882         if (r == null) {
 883             r = new Rect();
 884         }
 885         int left = getPaddingLeft();
 886         int top = getPaddingTop();
 887         int right = left + getWidth() - getPaddingLeft() - getPaddingRight();
 888         int bottom = top + getHeight() - getPaddingTop() - getPaddingBottom();
 889         r.set(left, top, right, bottom);
 890         return r;
 891     }
 892 
 893     static void getMetrics(Rect metrics, Resources res, int measureWidth, int measureHeight,
 894             int countX, int countY, int orientation) {
 895         int numWidthGaps = countX - 1;
 896         int numHeightGaps = countY - 1;
 897 
 898         int widthGap;
 899         int heightGap;
 900         int cellWidth;
 901         int cellHeight;
 902         int paddingLeft;
 903         int paddingRight;
 904         int paddingTop;
 905         int paddingBottom;
 906 
 907         int maxGap = res.getDimensionPixelSize(R.dimen.workspace_max_gap);
 908         if (orientation == LANDSCAPE) {
 909             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_land);
 910             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_land);
 911             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_land);
 912             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_land);
 913             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_land);
 914             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_land);
 915             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_land);
 916             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_land);
 917         } else {
 918             // PORTRAIT
 919             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_port);
 920             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_port);
 921             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_port);
 922             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_port);
 923             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_port);
 924             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_port);
 925             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_port);
 926             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_port);
 927         }
 928 
 929         if (widthGap &lt; 0 || heightGap &lt; 0) {
 930             int hSpace = measureWidth - paddingLeft - paddingRight;
 931             int vSpace = measureHeight - paddingTop - paddingBottom;
 932             int hFreeSpace = hSpace - (countX * cellWidth);
 933             int vFreeSpace = vSpace - (countY * cellHeight);
 934             widthGap = Math.min(maxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 935             heightGap = Math.min(maxGap, numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 936         }
 937         metrics.set(cellWidth, cellHeight, widthGap, heightGap);
 938     }
 939 
 940     @Override
 941     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 942         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 943         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 944 
 945         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 946         int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 947 
 948         if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 949             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 950         }
 951 
 952         int numWidthGaps = mCountX - 1;
 953         int numHeightGaps = mCountY - 1;
 954 
 955         if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 956             int hSpace = widthSpecSize - getPaddingLeft() - getPaddingRight();
 957             int vSpace = heightSpecSize - getPaddingTop() - getPaddingBottom();
 958             int hFreeSpace = hSpace - (mCountX * mCellWidth);
 959             int vFreeSpace = vSpace - (mCountY * mCellHeight);
 960             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 961             mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 962             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 963         } else {
 964             mWidthGap = mOriginalWidthGap;
 965             mHeightGap = mOriginalHeightGap;
 966         }
 967 
 968         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 969         int newWidth = widthSpecSize;
 970         int newHeight = heightSpecSize;
 971         if (widthSpecMode == MeasureSpec.AT_MOST) {
 972             newWidth = getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
 973                 ((mCountX - 1) * mWidthGap);
 974             newHeight = getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
 975                 ((mCountY - 1) * mHeightGap);
 976             setMeasuredDimension(newWidth, newHeight);
 977         }
 978 
 979         int count = getChildCount();
 980         for (int i = 0; i &lt; count; i++) {
 981             View child = getChildAt(i);
 982             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - getPaddingLeft() -
 983                     getPaddingRight(), MeasureSpec.EXACTLY);
 984             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - getPaddingTop() -
 985                     getPaddingBottom(), MeasureSpec.EXACTLY);
 986             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 987         }
 988         setMeasuredDimension(newWidth, newHeight);
 989     }
 990 
 991     @Override
 992     protected void onLayout(boolean changed, int l, int t, int r, int b) {
 993         int count = getChildCount();
 994         for (int i = 0; i &lt; count; i++) {
 995             View child = getChildAt(i);
 996             child.layout(getPaddingLeft(), getPaddingTop(),
 997                     r - l - getPaddingRight(), b - t - getPaddingBottom());
 998         }
 999     }
1000 
1001     @Override
1002     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
1003         super.onSizeChanged(w, h, oldw, oldh);
1004         mBackgroundRect.set(0, 0, w, h);
1005         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
1006                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
1007     }
1008 
1009     @Override
1010     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
1011         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
1012     }
1013 
1014     @Override
1015     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1016         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
1017     }
1018 
1019     public float getBackgroundAlpha() {
1020         return mBackgroundAlpha;
1021     }
1022 
1023     public void setBackgroundAlphaMultiplier(float multiplier) {
1024         if (mBackgroundAlphaMultiplier != multiplier) {
1025             mBackgroundAlphaMultiplier = multiplier;
1026             invalidate();
1027         }
1028     }
1029 
1030     public float getBackgroundAlphaMultiplier() {
1031         return mBackgroundAlphaMultiplier;
1032     }
1033 
1034     public void setBackgroundAlpha(float alpha) {
1035         if (mBackgroundAlpha != alpha) {
1036             mBackgroundAlpha = alpha;
1037             invalidate();
1038         }
1039     }
1040 
1041     public void setShortcutAndWidgetAlpha(float alpha) {
1042         final int childCount = getChildCount();
1043         for (int i = 0; i &lt; childCount; i++) {
1044             getChildAt(i).setAlpha(alpha);
1045         }
1046     }
1047 
1048     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1049         if (getChildCount() &gt; 0) {
1050             return (ShortcutAndWidgetContainer) getChildAt(0);
1051         }
1052         return null;
1053     }
1054 
1055     public View getChildAt(int x, int y) {
1056         return mShortcutsAndWidgets.getChildAt(x, y);
1057     }
1058 
1059     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1060             int delay, boolean permanent, boolean adjustOccupied) {
1061         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1062         boolean[][] occupied = mOccupied;
1063         if (!permanent) {
1064             occupied = mTmpOccupied;
1065         }
1066 
1067         if (clc.indexOfChild(child) != -1) {
1068             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1069             final ItemInfo info = (ItemInfo) child.getTag();
1070 
1071             // We cancel any existing animations
1072             if (mReorderAnimators.containsKey(lp)) {
1073                 mReorderAnimators.get(lp).cancel();
1074                 mReorderAnimators.remove(lp);
1075             }
1076 
1077             final int oldX = lp.x;
1078             final int oldY = lp.y;
1079             if (adjustOccupied) {
1080                 occupied[lp.cellX][lp.cellY] = false;
1081                 occupied[cellX][cellY] = true;
1082             }
1083             lp.isLockedToGrid = true;
1084             if (permanent) {
1085                 lp.cellX = info.cellX = cellX;
1086                 lp.cellY = info.cellY = cellY;
1087             } else {
1088                 lp.tmpCellX = cellX;
1089                 lp.tmpCellY = cellY;
1090             }
1091             clc.setupLp(lp);
1092             lp.isLockedToGrid = false;
1093             final int newX = lp.x;
1094             final int newY = lp.y;
1095 
1096             lp.x = oldX;
1097             lp.y = oldY;
1098 
1099             // Exit early if we&#x27;re not actually moving the view
1100             if (oldX == newX &amp;&amp; oldY == newY) {
1101                 lp.isLockedToGrid = true;
1102                 return true;
1103             }
1104 
1105             ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);
1106             va.setDuration(duration);
1107             mReorderAnimators.put(lp, va);
1108 
1109             va.addUpdateListener(new AnimatorUpdateListener() {
1110                 @Override
1111                 public void onAnimationUpdate(ValueAnimator animation) {
1112                     float r = ((Float) animation.getAnimatedValue()).floatValue();
1113                     lp.x = (int) ((1 - r) * oldX + r * newX);
1114                     lp.y = (int) ((1 - r) * oldY + r * newY);
1115                     child.requestLayout();
1116                 }
1117             });
1118             va.addListener(new AnimatorListenerAdapter() {
1119                 boolean cancelled = false;
1120                 public void onAnimationEnd(Animator animation) {
1121                     // If the animation was cancelled, it means that another animation
1122                     // has interrupted this one, and we don&#x27;t want to lock the item into
1123                     // place just yet.
1124                     if (!cancelled) {
1125                         lp.isLockedToGrid = true;
1126                         child.requestLayout();
1127                     }
1128                     if (mReorderAnimators.containsKey(lp)) {
1129                         mReorderAnimators.remove(lp);
1130                     }
1131                 }
1132                 public void onAnimationCancel(Animator animation) {
1133                     cancelled = true;
1134                 }
1135             });
1136             va.setStartDelay(delay);
1137             va.start();
1138             return true;
1139         }
1140         return false;
1141     }
1142 
1143     /**
1144      * Estimate where the top left cell of the dragged item will land if it is dropped.
1145      *
1146      * @param originX The X value of the top left corner of the item
1147      * @param originY The Y value of the top left corner of the item
1148      * @param spanX The number of horizontal cells that the item spans
1149      * @param spanY The number of vertical cells that the item spans
1150      * @param result The estimated drop cell X and Y.
1151      */
1152     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1153         final int countX = mCountX;
1154         final int countY = mCountY;
1155 
1156         // pointToCellRounded takes the top left of a cell but will pad that with
1157         // cellWidth/2 and cellHeight/2 when finding the matching cell
1158         pointToCellRounded(originX, originY, result);
1159 
1160         // If the item isn&#x27;t fully on this screen, snap to the edges
1161         int rightOverhang = result[0] + spanX - countX;
1162         if (rightOverhang &gt; 0) {
1163             result[0] -= rightOverhang; // Snap to right
1164         }
1165         result[0] = Math.max(0, result[0]); // Snap to left
1166         int bottomOverhang = result[1] + spanY - countY;
1167         if (bottomOverhang &gt; 0) {
1168             result[1] -= bottomOverhang; // Snap to bottom
1169         }
1170         result[1] = Math.max(0, result[1]); // Snap to top
1171     }
1172 
1173     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1174             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1175         final int oldDragCellX = mDragCell[0];
1176         final int oldDragCellY = mDragCell[1];
1177 
1178         if (v != null &amp;&amp; dragOffset == null) {
1179             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1180         } else {
1181             mDragCenter.set(originX, originY);
1182         }
1183 
1184         if (dragOutline == null &amp;&amp; v == null) {
1185             return;
1186         }
1187 
1188         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1189             mDragCell[0] = cellX;
1190             mDragCell[1] = cellY;
1191             // Find the top left corner of the rect the object will occupy
1192             final int[] topLeft = mTmpPoint;
1193             cellToPoint(cellX, cellY, topLeft);
1194 
1195             int left = topLeft[0];
1196             int top = topLeft[1];
1197 
1198             if (v != null &amp;&amp; dragOffset == null) {
1199                 // When drawing the drag outline, it did not account for margin offsets
1200                 // added by the view&#x27;s parent.
1201                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1202                 left += lp.leftMargin;
1203                 top += lp.topMargin;
1204 
1205                 // Offsets due to the size difference between the View and the dragOutline.
1206                 // There is a size difference to account for the outer blur, which may lie
1207                 // outside the bounds of the view.
1208                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1209                 // We center about the x axis
1210                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1211                         - dragOutline.getWidth()) / 2;
1212             } else {
1213                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1214                     // Center the drag region *horizontally* in the cell and apply a drag
1215                     // outline offset
1216                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1217                              - dragRegion.width()) / 2;
1218                     top += dragOffset.y;
1219                 } else {
1220                     // Center the drag outline in the cell
1221                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1222                             - dragOutline.getWidth()) / 2;
1223                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1224                             - dragOutline.getHeight()) / 2;
1225                 }
1226             }
1227             final int oldIndex = mDragOutlineCurrent;
1228             mDragOutlineAnims[oldIndex].animateOut();
1229             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1230             Rect r = mDragOutlines[mDragOutlineCurrent];
1231             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1232             if (resize) {
1233                 cellToRect(cellX, cellY, spanX, spanY, r);
1234             }
1235 
1236             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1237             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1238         }
1239     }
1240 
1241     public void clearDragOutlines() {
1242         final int oldIndex = mDragOutlineCurrent;
1243         mDragOutlineAnims[oldIndex].animateOut();
1244         mDragCell[0] = mDragCell[1] = -1;
1245     }
1246 
1247     /**
1248      * Find a vacant area that will fit the given bounds nearest the requested
1249      * cell location. Uses Euclidean distance to score multiple vacant areas.
1250      *
1251      * @param pixelX The X location at which you want to search for a vacant area.
1252      * @param pixelY The Y location at which you want to search for a vacant area.
1253      * @param spanX Horizontal span of the object.
1254      * @param spanY Vertical span of the object.
1255      * @param result Array in which to place the result, or null (in which case a new array will
1256      *        be allocated)
1257      * @return The X, Y cell of a vacant area that can contain this object,
1258      *         nearest the requested location.
1259      */
1260     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1261             int[] result) {
1262         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1263     }
1264 
1265     /**
1266      * Find a vacant area that will fit the given bounds nearest the requested
1267      * cell location. Uses Euclidean distance to score multiple vacant areas.
1268      *
1269      * @param pixelX The X location at which you want to search for a vacant area.
1270      * @param pixelY The Y location at which you want to search for a vacant area.
1271      * @param minSpanX The minimum horizontal span required
1272      * @param minSpanY The minimum vertical span required
1273      * @param spanX Horizontal span of the object.
1274      * @param spanY Vertical span of the object.
1275      * @param result Array in which to place the result, or null (in which case a new array will
1276      *        be allocated)
1277      * @return The X, Y cell of a vacant area that can contain this object,
1278      *         nearest the requested location.
1279      */
1280     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1281             int spanY, int[] result, int[] resultSpan) {
1282         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1283                 result, resultSpan);
1284     }
1285 
1286     /**
1287      * Find a vacant area that will fit the given bounds nearest the requested
1288      * cell location. Uses Euclidean distance to score multiple vacant areas.
1289      *
1290      * @param pixelX The X location at which you want to search for a vacant area.
1291      * @param pixelY The Y location at which you want to search for a vacant area.
1292      * @param spanX Horizontal span of the object.
1293      * @param spanY Vertical span of the object.
1294      * @param ignoreOccupied If true, the result can be an occupied cell
1295      * @param result Array in which to place the result, or null (in which case a new array will
1296      *        be allocated)
1297      * @return The X, Y cell of a vacant area that can contain this object,
1298      *         nearest the requested location.
1299      */
1300     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1301             boolean ignoreOccupied, int[] result) {
1302         return findNearestArea(pixelX, pixelY, spanX, spanY,
1303                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1304     }
1305 
1306     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1307     private void lazyInitTempRectStack() {
1308         if (mTempRectStack.isEmpty()) {
1309             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1310                 mTempRectStack.push(new Rect());
1311             }
1312         }
1313     }
1314 
1315     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1316         while (!used.isEmpty()) {
1317             mTempRectStack.push(used.pop());
1318         }
1319     }
1320 
1321     /**
1322      * Find a vacant area that will fit the given bounds nearest the requested
1323      * cell location. Uses Euclidean distance to score multiple vacant areas.
1324      *
1325      * @param pixelX The X location at which you want to search for a vacant area.
1326      * @param pixelY The Y location at which you want to search for a vacant area.
1327      * @param minSpanX The minimum horizontal span required
1328      * @param minSpanY The minimum vertical span required
1329      * @param spanX Horizontal span of the object.
1330      * @param spanY Vertical span of the object.
1331      * @param ignoreOccupied If true, the result can be an occupied cell
1332      * @param result Array in which to place the result, or null (in which case a new array will
1333      *        be allocated)
1334      * @return The X, Y cell of a vacant area that can contain this object,
1335      *         nearest the requested location.
1336      */
1337     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1338             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1339             boolean[][] occupied) {
1340         lazyInitTempRectStack();
1341         // mark space take by ignoreView as available (method checks if ignoreView is null)
1342         markCellsAsUnoccupiedForView(ignoreView, occupied);
1343 
1344         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1345         // to the center of the item, but we are searching based on the top-left cell, so
1346         // we translate the point over to correspond to the top-left.
1347         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1348         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1349 
1350         // Keep track of best-scoring drop area
1351         final int[] bestXY = result != null ? result : new int[2];
1352         double bestDistance = Double.MAX_VALUE;
1353         final Rect bestRect = new Rect(-1, -1, -1, -1);
1354         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1355 
1356         final int countX = mCountX;
1357         final int countY = mCountY;
1358 
1359         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1360                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1361             return bestXY;
1362         }
1363 
1364         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1365             inner:
1366             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1367                 int ySize = -1;
1368                 int xSize = -1;
1369                 if (ignoreOccupied) {
1370                     // First, let&#x27;s see if this thing fits anywhere
1371                     for (int i = 0; i &lt; minSpanX; i++) {
1372                         for (int j = 0; j &lt; minSpanY; j++) {
1373                             if (occupied[x + i][y + j]) {
1374                                 continue inner;
1375                             }
1376                         }
1377                     }
1378                     xSize = minSpanX;
1379                     ySize = minSpanY;
1380 
1381                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1382                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1383                     // until we hit a limit.
1384                     boolean incX = true;
1385                     boolean hitMaxX = xSize &gt;= spanX;
1386                     boolean hitMaxY = ySize &gt;= spanY;
1387                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1388                         if (incX &amp;&amp; !hitMaxX) {
1389                             for (int j = 0; j &lt; ySize; j++) {
1390                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1391                                     // We can&#x27;t move out horizontally
1392                                     hitMaxX = true;
1393                                 }
1394                             }
1395                             if (!hitMaxX) {
1396                                 xSize++;
1397                             }
1398                         } else if (!hitMaxY) {
1399                             for (int i = 0; i &lt; xSize; i++) {
1400                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1401                                     // We can&#x27;t move out vertically
1402                                     hitMaxY = true;
1403                                 }
1404                             }
1405                             if (!hitMaxY) {
1406                                 ySize++;
1407                             }
1408                         }
1409                         hitMaxX |= xSize &gt;= spanX;
1410                         hitMaxY |= ySize &gt;= spanY;
1411                         incX = !incX;
1412                     }
1413                     incX = true;
1414                     hitMaxX = xSize &gt;= spanX;
1415                     hitMaxY = ySize &gt;= spanY;
1416                 }
1417                 final int[] cellXY = mTmpXY;
1418                 cellToCenterPoint(x, y, cellXY);
1419 
1420                 // We verify that the current rect is not a sub-rect of any of our previous
1421                 // candidates. In this case, the current rect is disqualified in favour of the
1422                 // containing rect.
1423                 Rect currentRect = mTempRectStack.pop();
1424                 currentRect.set(x, y, x + xSize, y + ySize);
1425                 boolean contained = false;
1426                 for (Rect r : validRegions) {
1427                     if (r.contains(currentRect)) {
1428                         contained = true;
1429                         break;
1430                     }
1431                 }
1432                 validRegions.push(currentRect);
1433                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1434                         + Math.pow(cellXY[1] - pixelY, 2));
1435 
1436                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1437                         currentRect.contains(bestRect)) {
1438                     bestDistance = distance;
1439                     bestXY[0] = x;
1440                     bestXY[1] = y;
1441                     if (resultSpan != null) {
1442                         resultSpan[0] = xSize;
1443                         resultSpan[1] = ySize;
1444                     }
1445                     bestRect.set(currentRect);
1446                 }
1447             }
1448         }
1449         // re-mark space taken by ignoreView as occupied
1450         markCellsAsOccupiedForView(ignoreView, occupied);
1451 
1452         // Return -1, -1 if no suitable location found
1453         if (bestDistance == Double.MAX_VALUE) {
1454             bestXY[0] = -1;
1455             bestXY[1] = -1;
1456         }
1457         recycleTempRects(validRegions);
1458         return bestXY;
1459     }
1460 
1461      /**
1462      * Find a vacant area that will fit the given bounds nearest the requested
1463      * cell location, and will also weigh in a suggested direction vector of the
1464      * desired location. This method computers distance based on unit grid distances,
1465      * not pixel distances.
1466      *
1467      * @param cellX The X cell nearest to which you want to search for a vacant area.
1468      * @param cellY The Y cell nearest which you want to search for a vacant area.
1469      * @param spanX Horizontal span of the object.
1470      * @param spanY Vertical span of the object.
1471      * @param direction The favored direction in which the views should move from x, y
1472      * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1473      *        matches exactly. Otherwise we find the best matching direction.
1474      * @param occoupied The array which represents which cells in the CellLayout are occupied
1475      * @param blockOccupied The array which represents which cells in the specified block (cellX,
1476      *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views. 
1477      * @param result Array in which to place the result, or null (in which case a new array will
1478      *        be allocated)
1479      * @return The X, Y cell of a vacant area that can contain this object,
1480      *         nearest the requested location.
1481      */
1482     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1483             boolean[][] occupied, boolean blockOccupied[][], int[] result) {
1484         // Keep track of best-scoring drop area
1485         final int[] bestXY = result != null ? result : new int[2];
1486         float bestDistance = Float.MAX_VALUE;
1487         int bestDirectionScore = Integer.MIN_VALUE;
1488 
1489         final int countX = mCountX;
1490         final int countY = mCountY;
1491 
1492         for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1493             inner:
1494             for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1495                 // First, let&#x27;s see if this thing fits anywhere
1496                 for (int i = 0; i &lt; spanX; i++) {
1497                     for (int j = 0; j &lt; spanY; j++) {
1498                         if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1499                             continue inner;
1500                         }
1501                     }
1502                 }
1503 
1504                 float distance = (float)
1505                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1506                 int[] curDirection = mTmpPoint;
1507                 computeDirectionVector(x - cellX, y - cellY, curDirection);
1508                 // The direction score is just the dot product of the two candidate direction
1509                 // and that passed in.
1510                 int curDirectionScore = direction[0] * curDirection[0] +
1511                         direction[1] * curDirection[1];
1512                 boolean exactDirectionOnly = false;
1513                 boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1514                         direction[0] == curDirection[0];
1515                 if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1516                         Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1517                         bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1518                     bestDistance = distance;
1519                     bestDirectionScore = curDirectionScore;
1520                     bestXY[0] = x;
1521                     bestXY[1] = y;
1522                 }
1523             }
1524         }
1525 
1526         // Return -1, -1 if no suitable location found
1527         if (bestDistance == Float.MAX_VALUE) {
1528             bestXY[0] = -1;
1529             bestXY[1] = -1;
1530         }
1531         return bestXY;
1532     }
1533 
1534     private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY, 
1535             int[] direction,boolean[][] occupied,
1536             boolean blockOccupied[][], int[] result) {
1537         // Keep track of best-scoring drop area
1538         final int[] bestXY = result != null ? result : new int[2];
1539         bestXY[0] = -1;
1540         bestXY[1] = -1;
1541         float bestDistance = Float.MAX_VALUE;
1542 
1543         // We use this to march in a single direction
1544         if ((direction[0] != 0 &amp;&amp; direction[1] != 0) ||
1545                 (direction[0] == 0 &amp;&amp; direction[1] == 0)) {
1546             return bestXY;
1547         }
1548 
1549         // This will only incrememnet one of x or y based on the assertion above
1550         int x = cellX + direction[0];
1551         int y = cellY + direction[1];
1552         while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
1553             boolean fail = false;
1554             for (int i = 0; i &lt; spanX; i++) {
1555                 for (int j = 0; j &lt; spanY; j++) {
1556                     if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1557                         fail = true;                    
1558                     }
1559                 }
1560             }
1561             if (!fail) {
1562                 float distance = (float)
1563                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1564                 if (Float.compare(distance,  bestDistance) &lt; 0) {
1565                     bestDistance = distance;
1566                     bestXY[0] = x;
1567                     bestXY[1] = y;
1568                 }
1569             }
1570             x += direction[0];
1571             y += direction[1];
1572         }
1573         return bestXY;
1574     }
1575 
1576     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1577             int[] direction, ItemConfiguration currentState) {
1578         CellAndSpan c = currentState.map.get(v);
1579         boolean success = false;
1580         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1581         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1582 
1583         findNearestArea(c.x, c.y, c.spanX, c.spanY, direction, mTmpOccupied, null, mTempLocation);
1584 
1585         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1586             c.x = mTempLocation[0];
1587             c.y = mTempLocation[1];
1588             success = true;
1589 
1590         }
1591         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1592         return success;
1593     }
1594 
1595     // This method looks in the specified direction to see if there are additional views adjacent
1596     // to the current set of views in the. If there is, then these views are added to the current
1597     // set of views. This is performed iteratively, giving a cascading push behaviour.
1598     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,
1599             boolean[][] occupied, View dragView, ItemConfiguration currentState) {
1600         boolean found = false;
1601 
1602         int childCount = mShortcutsAndWidgets.getChildCount();
1603         Rect r0 = new Rect(boundingRect);
1604         Rect r1 = new Rect();
1605 
1606         // First, we consider the rect of the views that we are trying to translate
1607         int deltaX = 0;
1608         int deltaY = 0;
1609         if (direction[1] &lt; 0) {
1610             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom - 1);
1611             deltaY = -1;
1612         } else if (direction[1] &gt; 0) {
1613             r0.set(r0.left, r0.top + 1, r0.right, r0.bottom + 1);
1614             deltaY = 1;
1615         } else if (direction[0] &lt; 0) {
1616             r0.set(r0.left - 1, r0.top, r0.right - 1, r0.bottom);
1617             deltaX = -1;
1618         } else if (direction[0] &gt; 0) {
1619             r0.set(r0.left + 1, r0.top, r0.right + 1, r0.bottom);
1620             deltaX = 1;
1621         }
1622 
1623         // Now we see which views, if any, are being overlapped by shifting the current group
1624         // of views in the desired direction.
1625         for (int i = 0; i &lt; childCount; i++) {
1626             // We don&#x27;t need to worry about views already in our group, or the current drag view.
1627             View child = mShortcutsAndWidgets.getChildAt(i);
1628             if (views.contains(child) || child == dragView) continue;
1629             CellAndSpan c = currentState.map.get(child);
1630 
1631             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1632             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1633             if (Rect.intersects(r0, r1)) {
1634                 if (!lp.canReorder) {
1635                     return false;
1636                 }
1637                 // First we verify that the view in question is at the border of the extents
1638                 // of the block of items we are pushing
1639                 if ((direction[0] &lt; 0 &amp;&amp; c.x == r0.left) ||
1640                         (direction[0] &gt; 0 &amp;&amp; c.x == r0.right - 1) ||
1641                         (direction[1] &lt; 0 &amp;&amp; c.y == r0.top) ||
1642                         (direction[1] &gt; 0 &amp;&amp; c.y == r0.bottom - 1)) {
1643                     boolean pushed = false;
1644                     // Since the bounding rect is a course description of the region (there can
1645                     // be holes at the edge of the block), we need to check to verify that a solid
1646                     // piece is intersecting. This ensures that interlocking is possible.
1647                     for (int x = c.x; x &lt; c.x + c.spanX; x++) {
1648                         for (int y = c.y; y &lt; c.y + c.spanY; y++) {
1649                             if (occupied[x - deltaX][y - deltaY]) {
1650                                 pushed = true;
1651                                 break;
1652                             }
1653                             if (pushed) break;
1654                         }
1655                     }
1656                     if (pushed) {
1657                         views.add(child);
1658                         boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1659                         found = true;
1660                     }
1661                 }
1662             }
1663         }
1664         return found;
1665     }
1666 
1667     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1668             int[] direction, boolean push, View dragView, ItemConfiguration currentState) {
1669         if (views.size() == 0) return true;
1670 
1671         boolean success = false;
1672         Rect boundingRect = null;
1673         // We construct a rect which represents the entire group of views passed in
1674         for (View v: views) {
1675             CellAndSpan c = currentState.map.get(v);
1676             if (boundingRect == null) {
1677                 boundingRect = new Rect(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1678             } else {
1679                 boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1680             }
1681         }
1682 
1683         @SuppressWarnings(&quot;unchecked&quot;)
1684         ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();
1685         // We try and expand the group of views in the direction vector passed, based on
1686         // whether they are physically adjacent, ie. based on &quot;push mechanics&quot;.
1687         while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView,
1688                 currentState)) {
1689         }
1690 
1691         // Mark the occupied state as false for the group of views we want to move.
1692         for (View v: dup) {
1693             CellAndSpan c = currentState.map.get(v);
1694             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1695         }
1696 
1697         boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1698         int top = boundingRect.top;
1699         int left = boundingRect.left;
1700         // We mark more precisely which parts of the bounding rect are truly occupied, allowing
1701         // for interlocking.
1702         for (View v: dup) {
1703             CellAndSpan c = currentState.map.get(v);
1704             markCellsForView(c.x - left, c.y - top, c.spanX, c.spanY, blockOccupied, true);
1705         }
1706 
1707         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1708 
1709         if (push) {
1710             findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),
1711                     boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1712         } else {
1713             findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),
1714                     boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1715         }
1716 
1717         // If we successfuly found a location by pushing the block of views, we commit it
1718         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1719             int deltaX = mTempLocation[0] - boundingRect.left;
1720             int deltaY = mTempLocation[1] - boundingRect.top;
1721             for (View v: dup) {
1722                 CellAndSpan c = currentState.map.get(v);
1723                 c.x += deltaX;
1724                 c.y += deltaY;
1725             }
1726             success = true;
1727         }
1728 
1729         // In either case, we set the occupied array as marked for the location of the views
1730         for (View v: dup) {
1731             CellAndSpan c = currentState.map.get(v);
1732             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1733         }
1734         return success;
1735     }
1736 
1737     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1738         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1739     }
1740 
1741     // This method tries to find a reordering solution which satisfies the push mechanic by trying
1742     // to push items in each of the cardinal directions, in an order based on the direction vector
1743     // passed.
1744     private boolean attemptPushInDirection(ArrayList&lt;View&gt; intersectingViews, Rect occupied,
1745             int[] direction, View ignoreView, ItemConfiguration solution) {
1746         if ((Math.abs(direction[0]) + Math.abs(direction[1])) &gt; 1) {
1747             // If the direction vector has two non-zero components, we try pushing 
1748             // separately in each of the components.
1749             int temp = direction[1];
1750             direction[1] = 0;
1751             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1752                     ignoreView, solution)) {
1753                 return true;
1754             }
1755             direction[1] = temp;
1756             temp = direction[0];
1757             direction[0] = 0;
1758             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1759                     ignoreView, solution)) {
1760                 return true;
1761             }
1762             // Revert the direction
1763             direction[0] = temp;
1764 
1765             // Now we try pushing in each component of the opposite direction
1766             direction[0] *= -1;
1767             direction[1] *= -1;
1768             temp = direction[1];
1769             direction[1] = 0;
1770             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1771                     ignoreView, solution)) {
1772                 return true;
1773             }
1774 
1775             direction[1] = temp;
1776             temp = direction[0];
1777             direction[0] = 0;
1778             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1779                     ignoreView, solution)) {
1780                 return true;
1781             }
1782             // revert the direction
1783             direction[0] = temp;
1784             direction[0] *= -1;
1785             direction[1] *= -1;
1786             
1787         } else {
1788             // If the direction vector has a single non-zero component, we push first in the
1789             // direction of the vector
1790             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1791                     ignoreView, solution)) {
1792                 return true;
1793             }
1794 
1795             // Then we try the opposite direction
1796             direction[0] *= -1;
1797             direction[1] *= -1;
1798             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1799                     ignoreView, solution)) {
1800                 return true;
1801             }
1802             // Switch the direction back
1803             direction[0] *= -1;
1804             direction[1] *= -1;
1805             
1806             // If we have failed to find a push solution with the above, then we try 
1807             // to find a solution by pushing along the perpendicular axis.
1808 
1809             // Swap the components
1810             int temp = direction[1];
1811             direction[1] = direction[0];
1812             direction[0] = temp;
1813             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1814                     ignoreView, solution)) {
1815                 return true;
1816             }
1817 
1818             // Then we try the opposite direction
1819             direction[0] *= -1;
1820             direction[1] *= -1;
1821             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1822                     ignoreView, solution)) {
1823                 return true;
1824             }
1825             // Switch the direction back
1826             direction[0] *= -1;
1827             direction[1] *= -1;
1828 
1829             // Swap the components back
1830             temp = direction[1];
1831             direction[1] = direction[0];
1832             direction[0] = temp;
1833         }
1834         return false;
1835     }
1836 
1837     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1838             View ignoreView, ItemConfiguration solution) {
1839         // Return early if get invalid cell positions
1840         if (cellX &lt; 0 || cellY &lt; 0) return false;
1841 
1842         mIntersectingViews.clear();
1843         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1844 
1845         // Mark the desired location of the view currently being dragged.
1846         if (ignoreView != null) {
1847             CellAndSpan c = solution.map.get(ignoreView);
1848             if (c != null) {
1849                 c.x = cellX;
1850                 c.y = cellY;
1851             }
1852         }
1853         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1854         Rect r1 = new Rect();
1855         for (View child: solution.map.keySet()) {
1856             if (child == ignoreView) continue;
1857             CellAndSpan c = solution.map.get(child);
1858             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1859             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1860             if (Rect.intersects(r0, r1)) {
1861                 if (!lp.canReorder) {
1862                     return false;
1863                 }
1864                 mIntersectingViews.add(child);
1865             }
1866         }
1867 
1868         // First we try to find a solution which respects the push mechanic. That is, 
1869         // we try to find a solution such that no displaced item travels through another item
1870         // without also displacing that item.
1871         if (attemptPushInDirection(mIntersectingViews, mOccupiedRect, direction, ignoreView,
1872                 solution)) {
1873             return true;
1874         }
1875 
1876         // Next we try moving the views as a block, but without requiring the push mechanic.
1877         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction, false, ignoreView,
1878                 solution)) {
1879             return true;
1880         }
1881 
1882         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1883         for (View v : mIntersectingViews) {
1884             if (!addViewToTempLocation(v, mOccupiedRect, direction, solution)) {
1885                 return false;
1886             }
1887         }
1888         return true;
1889     }
1890 
1891     /*
1892      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1893      * the provided point and the provided cell
1894      */
1895     private void computeDirectionVector(float deltaX, float deltaY, int[] result) {
1896         double angle = Math.atan(((float) deltaY) / deltaX);
1897 
1898         result[0] = 0;
1899         result[1] = 0;
1900         if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1901             result[0] = (int) Math.signum(deltaX);
1902         }
1903         if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1904             result[1] = (int) Math.signum(deltaY);
1905         }
1906     }
1907 
1908     private void copyOccupiedArray(boolean[][] occupied) {
1909         for (int i = 0; i &lt; mCountX; i++) {
1910             for (int j = 0; j &lt; mCountY; j++) {
1911                 occupied[i][j] = mOccupied[i][j];
1912             }
1913         }
1914     }
1915 
1916     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1917             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1918         // Copy the current state into the solution. This solution will be manipulated as necessary.
1919         copyCurrentStateToSolution(solution, false);
1920         // Copy the current occupied array into the temporary occupied array. This array will be
1921         // manipulated as necessary to find a solution.
1922         copyOccupiedArray(mTmpOccupied);
1923 
1924         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1925         // nothing in its way.
1926         int result[] = new int[2];
1927         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1928 
1929         boolean success = false;
1930         // First we try the exact nearest position of the item being dragged,
1931         // we will then want to try to move this around to other neighbouring positions
1932         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView,
1933                 solution);
1934 
1935         if (!success) {
1936             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1937             // x, then 1 in y etc.
1938             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1939                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1940                         dragView, false, solution);
1941             } else if (spanY &gt; minSpanY) {
1942                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1943                         dragView, true, solution);
1944             }
1945             solution.isSolution = false;
1946         } else {
1947             solution.isSolution = true;
1948             solution.dragViewX = result[0];
1949             solution.dragViewY = result[1];
1950             solution.dragViewSpanX = spanX;
1951             solution.dragViewSpanY = spanY;
1952         }
1953         return solution;
1954     }
1955 
1956     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1957         int childCount = mShortcutsAndWidgets.getChildCount();
1958         for (int i = 0; i &lt; childCount; i++) {
1959             View child = mShortcutsAndWidgets.getChildAt(i);
1960             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1961             CellAndSpan c;
1962             if (temp) {
1963                 c = new CellAndSpan(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan);
1964             } else {
1965                 c = new CellAndSpan(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan);
1966             }
1967             solution.map.put(child, c);
1968         }
1969     }
1970 
1971     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1972         for (int i = 0; i &lt; mCountX; i++) {
1973             for (int j = 0; j &lt; mCountY; j++) {
1974                 mTmpOccupied[i][j] = false;
1975             }
1976         }
1977 
1978         int childCount = mShortcutsAndWidgets.getChildCount();
1979         for (int i = 0; i &lt; childCount; i++) {
1980             View child = mShortcutsAndWidgets.getChildAt(i);
1981             if (child == dragView) continue;
1982             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1983             CellAndSpan c = solution.map.get(child);
1984             if (c != null) {
1985                 lp.tmpCellX = c.x;
1986                 lp.tmpCellY = c.y;
1987                 lp.cellHSpan = c.spanX;
1988                 lp.cellVSpan = c.spanY;
1989                 markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1990             }
1991         }
1992         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1993                 solution.dragViewSpanY, mTmpOccupied, true);
1994     }
1995 
1996     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1997             commitDragView) {
1998 
1999         boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
2000         for (int i = 0; i &lt; mCountX; i++) {
2001             for (int j = 0; j &lt; mCountY; j++) {
2002                 occupied[i][j] = false;
2003             }
2004         }
2005 
2006         int childCount = mShortcutsAndWidgets.getChildCount();
2007         for (int i = 0; i &lt; childCount; i++) {
2008             View child = mShortcutsAndWidgets.getChildAt(i);
2009             if (child == dragView) continue;
2010             CellAndSpan c = solution.map.get(child);
2011             if (c != null) {
2012                 animateChildToPosition(child, c.x, c.y, REORDER_ANIMATION_DURATION, 0,
2013                         DESTRUCTIVE_REORDER, false);
2014                 markCellsForView(c.x, c.y, c.spanX, c.spanY, occupied, true);
2015             }
2016         }
2017         if (commitDragView) {
2018             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2019                     solution.dragViewSpanY, occupied, true);
2020         }
2021     }
2022 
2023     // This method starts or changes the reorder hint animations
2024     private void beginOrAdjustHintAnimations(ItemConfiguration solution, View dragView, int delay) {
2025         int childCount = mShortcutsAndWidgets.getChildCount();
2026         for (int i = 0; i &lt; childCount; i++) {
2027             View child = mShortcutsAndWidgets.getChildAt(i);
2028             if (child == dragView) continue;
2029             CellAndSpan c = solution.map.get(child);
2030             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2031             if (c != null) {
2032                 ReorderHintAnimation rha = new ReorderHintAnimation(child, lp.cellX, lp.cellY,
2033                         c.x, c.y, c.spanX, c.spanY);
2034                 rha.animate();
2035             }
2036         }
2037     }
2038 
2039     // Class which represents the reorder hint animations. These animations show that an item is
2040     // in a temporary state, and hint at where the item will return to.
2041     class ReorderHintAnimation {
2042         View child;
2043         float finalDeltaX;
2044         float finalDeltaY;
2045         float initDeltaX;
2046         float initDeltaY;
2047         float finalScale;
2048         float initScale;
2049         private static final int DURATION = 300;
2050         Animator a;
2051 
2052         public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1,
2053                 int spanX, int spanY) {
2054             regionToCenterPoint(cellX0, cellY0, spanX, spanY, mTmpPoint);
2055             final int x0 = mTmpPoint[0];
2056             final int y0 = mTmpPoint[1];
2057             regionToCenterPoint(cellX1, cellY1, spanX, spanY, mTmpPoint);
2058             final int x1 = mTmpPoint[0];
2059             final int y1 = mTmpPoint[1];
2060             final int dX = x1 - x0;
2061             final int dY = y1 - y0;
2062             finalDeltaX = 0;
2063             finalDeltaY = 0;
2064             if (dX == dY &amp;&amp; dX == 0) {
2065             } else {
2066                 if (dY == 0) {
2067                     finalDeltaX = - Math.signum(dX) * mReorderHintAnimationMagnitude;
2068                 } else if (dX == 0) {
2069                     finalDeltaY = - Math.signum(dY) * mReorderHintAnimationMagnitude;
2070                 } else {
2071                     double angle = Math.atan( (float) (dY) / dX);
2072                     finalDeltaX = (int) (- Math.signum(dX) *
2073                             Math.abs(Math.cos(angle) * mReorderHintAnimationMagnitude));
2074                     finalDeltaY = (int) (- Math.signum(dY) *
2075                             Math.abs(Math.sin(angle) * mReorderHintAnimationMagnitude));
2076                 }
2077             }
2078             initDeltaX = child.getTranslationX();
2079             initDeltaY = child.getTranslationY();
2080             finalScale = 1.0f - 4.0f / child.getWidth();
2081             initScale = child.getScaleX();
2082 
2083             child.setPivotY(child.getMeasuredHeight() * 0.5f);
2084             child.setPivotX(child.getMeasuredWidth() * 0.5f);
2085             this.child = child;
2086         }
2087 
2088         void animate() {
2089             if (mShakeAnimators.containsKey(child)) {
2090                 ReorderHintAnimation oldAnimation = mShakeAnimators.get(child);
2091                 oldAnimation.cancel();
2092                 mShakeAnimators.remove(child);
2093                 if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2094                     completeAnimationImmediately();
2095                     return;
2096                 }
2097             }
2098             if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2099                 return;
2100             }
2101             ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);
2102             a = va;
2103             va.setRepeatMode(ValueAnimator.REVERSE);
2104             va.setRepeatCount(ValueAnimator.INFINITE);
2105             va.setDuration(DURATION);
2106             va.setStartDelay((int) (Math.random() * 60));
2107             va.addUpdateListener(new AnimatorUpdateListener() {
2108                 @Override
2109                 public void onAnimationUpdate(ValueAnimator animation) {
2110                     float r = ((Float) animation.getAnimatedValue()).floatValue();
2111                     float x = r * finalDeltaX + (1 - r) * initDeltaX;
2112                     float y = r * finalDeltaY + (1 - r) * initDeltaY;
2113                     child.setTranslationX(x);
2114                     child.setTranslationY(y);
2115                     float s = r * finalScale + (1 - r) * initScale;
2116                     child.setScaleX(s);
2117                     child.setScaleY(s);
2118                 }
2119             });
2120             va.addListener(new AnimatorListenerAdapter() {
2121                 public void onAnimationRepeat(Animator animation) {
2122                     // We make sure to end only after a full period
2123                     initDeltaX = 0;
2124                     initDeltaY = 0;
2125                     initScale = 1.0f;
2126                 }
2127             });
2128             mShakeAnimators.put(child, this);
2129             va.start();
2130         }
2131 
2132         private void cancel() {
2133             if (a != null) {
2134                 a.cancel();
2135             }
2136         }
2137 
2138         private void completeAnimationImmediately() {
2139             if (a != null) {
2140                 a.cancel();
2141             }
2142 
2143             AnimatorSet s = LauncherAnimUtils.createAnimatorSet();
2144             a = s;
2145             s.playTogether(
2146                 LauncherAnimUtils.ofFloat(child, &quot;scaleX&quot;, 1f),
2147                 LauncherAnimUtils.ofFloat(child, &quot;scaleY&quot;, 1f),
2148                 LauncherAnimUtils.ofFloat(child, &quot;translationX&quot;, 0f),
2149                 LauncherAnimUtils.ofFloat(child, &quot;translationY&quot;, 0f)
2150             );
2151             s.setDuration(REORDER_ANIMATION_DURATION);
2152             s.setInterpolator(new android.view.animation.DecelerateInterpolator(1.5f));
2153             s.start();
2154         }
2155     }
2156 
2157     private void completeAndClearReorderHintAnimations() {
2158         for (ReorderHintAnimation a: mShakeAnimators.values()) {
2159             a.completeAnimationImmediately();
2160         }
2161         mShakeAnimators.clear();
2162     }
2163 
2164     private void commitTempPlacement() {
2165         for (int i = 0; i &lt; mCountX; i++) {
2166             for (int j = 0; j &lt; mCountY; j++) {
2167                 mOccupied[i][j] = mTmpOccupied[i][j];
2168             }
2169         }
2170         int childCount = mShortcutsAndWidgets.getChildCount();
2171         for (int i = 0; i &lt; childCount; i++) {
2172             View child = mShortcutsAndWidgets.getChildAt(i);
2173             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2174             ItemInfo info = (ItemInfo) child.getTag();
2175             // We do a null check here because the item info can be null in the case of the
2176             // AllApps button in the hotseat.
2177             if (info != null) {
2178                 if (info.cellX != lp.tmpCellX || info.cellY != lp.tmpCellY ||
2179                         info.spanX != lp.cellHSpan || info.spanY != lp.cellVSpan) {
2180                     info.requiresDbUpdate = true;
2181                 }
2182                 info.cellX = lp.cellX = lp.tmpCellX;
2183                 info.cellY = lp.cellY = lp.tmpCellY;
2184                 info.spanX = lp.cellHSpan;
2185                 info.spanY = lp.cellVSpan;
2186             }
2187         }
2188         mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
2189     }
2190 
2191     public void setUseTempCoords(boolean useTempCoords) {
2192         int childCount = mShortcutsAndWidgets.getChildCount();
2193         for (int i = 0; i &lt; childCount; i++) {
2194             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2195             lp.useTmpCoords = useTempCoords;
2196         }
2197     }
2198 
2199     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2200             int spanX, int spanY, View dragView, ItemConfiguration solution) {
2201         int[] result = new int[2];
2202         int[] resultSpan = new int[2];
2203         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2204                 resultSpan);
2205         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2206             copyCurrentStateToSolution(solution, false);
2207             solution.dragViewX = result[0];
2208             solution.dragViewY = result[1];
2209             solution.dragViewSpanX = resultSpan[0];
2210             solution.dragViewSpanY = resultSpan[1];
2211             solution.isSolution = true;
2212         } else {
2213             solution.isSolution = false;
2214         }
2215         return solution;
2216     }
2217 
2218     public void prepareChildForDrag(View child) {
2219         markCellsAsUnoccupiedForView(child);
2220     }
2221 
2222     /* This seems like it should be obvious and straight-forward, but when the direction vector
2223     needs to match with the notion of the dragView pushing other views, we have to employ
2224     a slightly more subtle notion of the direction vector. The question is what two points is
2225     the vector between? The center of the dragView and its desired destination? Not quite, as
2226     this doesn&#x27;t necessarily coincide with the interaction of the dragView and items occupying
2227     those cells. Instead we use some heuristics to often lock the vector to up, down, left
2228     or right, which helps make pushing feel right.
2229     */
2230     private void getDirectionVectorForDrop(int dragViewCenterX, int dragViewCenterY, int spanX,
2231             int spanY, View dragView, int[] resultDirection) {
2232         int[] targetDestination = new int[2];
2233 
2234         findNearestArea(dragViewCenterX, dragViewCenterY, spanX, spanY, targetDestination);
2235         Rect dragRect = new Rect();
2236         regionToRect(targetDestination[0], targetDestination[1], spanX, spanY, dragRect);
2237         dragRect.offset(dragViewCenterX - dragRect.centerX(), dragViewCenterY - dragRect.centerY());
2238 
2239         Rect dropRegionRect = new Rect();
2240         getViewsIntersectingRegion(targetDestination[0], targetDestination[1], spanX, spanY,
2241                 dragView, dropRegionRect, mIntersectingViews);
2242 
2243         int dropRegionSpanX = dropRegionRect.width();
2244         int dropRegionSpanY = dropRegionRect.height();
2245 
2246         regionToRect(dropRegionRect.left, dropRegionRect.top, dropRegionRect.width(),
2247                 dropRegionRect.height(), dropRegionRect);
2248 
2249         int deltaX = (dropRegionRect.centerX() - dragViewCenterX) / spanX;
2250         int deltaY = (dropRegionRect.centerY() - dragViewCenterY) / spanY;
2251 
2252         if (dropRegionSpanX == mCountX || spanX == mCountX) {
2253             deltaX = 0;
2254         }
2255         if (dropRegionSpanY == mCountY || spanY == mCountY) {
2256             deltaY = 0;
2257         }
2258 
2259         if (deltaX == 0 &amp;&amp; deltaY == 0) {
2260             // No idea what to do, give a random direction.
2261             resultDirection[0] = 1;
2262             resultDirection[1] = 0;
2263         } else {
2264             computeDirectionVector(deltaX, deltaY, resultDirection);
2265         }
2266     }
2267 
2268     // For a given cell and span, fetch the set of views intersecting the region.
2269     private void getViewsIntersectingRegion(int cellX, int cellY, int spanX, int spanY,
2270             View dragView, Rect boundingRect, ArrayList&lt;View&gt; intersectingViews) {
2271         if (boundingRect != null) {
2272             boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
2273         }
2274         intersectingViews.clear();
2275         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
2276         Rect r1 = new Rect();
2277         final int count = mShortcutsAndWidgets.getChildCount();
2278         for (int i = 0; i &lt; count; i++) {
2279             View child = mShortcutsAndWidgets.getChildAt(i);
2280             if (child == dragView) continue;
2281             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2282             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
2283             if (Rect.intersects(r0, r1)) {
2284                 mIntersectingViews.add(child);
2285                 if (boundingRect != null) {
2286                     boundingRect.union(r1);
2287                 }
2288             }
2289         }
2290     }
2291 
2292     boolean isNearestDropLocationOccupied(int pixelX, int pixelY, int spanX, int spanY,
2293             View dragView, int[] result) {
2294         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2295         getViewsIntersectingRegion(result[0], result[1], spanX, spanY, dragView, null,
2296                 mIntersectingViews);
2297         return !mIntersectingViews.isEmpty();
2298     }
2299 
2300     void revertTempState() {
2301         if (!isItemPlacementDirty() || DESTRUCTIVE_REORDER) return;
2302         final int count = mShortcutsAndWidgets.getChildCount();
2303         for (int i = 0; i &lt; count; i++) {
2304             View child = mShortcutsAndWidgets.getChildAt(i);
2305             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2306             if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
2307                 lp.tmpCellX = lp.cellX;
2308                 lp.tmpCellY = lp.cellY;
2309                 animateChildToPosition(child, lp.cellX, lp.cellY, REORDER_ANIMATION_DURATION,
2310                         0, false, false);
2311             }
2312         }
2313         completeAndClearReorderHintAnimations();
2314         setItemPlacementDirty(false);
2315     }
2316 
2317     boolean createAreaForResize(int cellX, int cellY, int spanX, int spanY,
2318             View dragView, int[] direction, boolean commit) {
2319         int[] pixelXY = new int[2];
2320         regionToCenterPoint(cellX, cellY, spanX, spanY, pixelXY);
2321 
2322         // First we determine if things have moved enough to cause a different layout
2323         ItemConfiguration swapSolution = simpleSwap(pixelXY[0], pixelXY[1], spanX, spanY,
2324                  spanX,  spanY, direction, dragView,  true,  new ItemConfiguration());
2325 
2326         setUseTempCoords(true);
2327         if (swapSolution != null &amp;&amp; swapSolution.isSolution) {
2328             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2329             // committing anything or animating anything as we just want to determine if a solution
2330             // exists
2331             copySolutionToTempState(swapSolution, dragView);
2332             setItemPlacementDirty(true);
2333             animateItemsToSolution(swapSolution, dragView, commit);
2334 
2335             if (commit) {
2336                 commitTempPlacement();
2337                 completeAndClearReorderHintAnimations();
2338                 setItemPlacementDirty(false);
2339             } else {
2340                 beginOrAdjustHintAnimations(swapSolution, dragView,
2341                         REORDER_ANIMATION_DURATION);
2342             }
2343             mShortcutsAndWidgets.requestLayout();
2344         }
2345         return swapSolution.isSolution;
2346     }
2347 
2348     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2349             View dragView, int[] result, int resultSpan[], int mode) {
2350         // First we determine if things have moved enough to cause a different layout
2351         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2352 
2353         if (resultSpan == null) {
2354             resultSpan = new int[2];
2355         }
2356 
2357         // When we are checking drop validity or actually dropping, we don&#x27;t recompute the
2358         // direction vector, since we want the solution to match the preview, and it&#x27;s possible
2359         // that the exact position of the item has changed to result in a new reordering outcome.
2360         if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP)
2361                &amp;&amp; mPreviousReorderDirection[0] != INVALID_DIRECTION) {
2362             mDirectionVector[0] = mPreviousReorderDirection[0];
2363             mDirectionVector[1] = mPreviousReorderDirection[1];
2364             // We reset this vector after drop
2365             if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2366                 mPreviousReorderDirection[0] = INVALID_DIRECTION;
2367                 mPreviousReorderDirection[1] = INVALID_DIRECTION;
2368             }
2369         } else {
2370             getDirectionVectorForDrop(pixelX, pixelY, spanX, spanY, dragView, mDirectionVector);
2371             mPreviousReorderDirection[0] = mDirectionVector[0];
2372             mPreviousReorderDirection[1] = mDirectionVector[1];
2373         }
2374 
2375         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2376                  spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2377 
2378         // We attempt the approach which doesn&#x27;t shuffle views at all
2379         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2380                 minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2381 
2382         ItemConfiguration finalSolution = null;
2383         if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2384             finalSolution = swapSolution;
2385         } else if (noShuffleSolution.isSolution) {
2386             finalSolution = noShuffleSolution;
2387         }
2388 
2389         boolean foundSolution = true;
2390         if (!DESTRUCTIVE_REORDER) {
2391             setUseTempCoords(true);
2392         }
2393 
2394         if (finalSolution != null) {
2395             result[0] = finalSolution.dragViewX;
2396             result[1] = finalSolution.dragViewY;
2397             resultSpan[0] = finalSolution.dragViewSpanX;
2398             resultSpan[1] = finalSolution.dragViewSpanY;
2399 
2400             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2401             // committing anything or animating anything as we just want to determine if a solution
2402             // exists
2403             if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2404                 if (!DESTRUCTIVE_REORDER) {
2405                     copySolutionToTempState(finalSolution, dragView);
2406                 }
2407                 setItemPlacementDirty(true);
2408                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2409 
2410                 if (!DESTRUCTIVE_REORDER &amp;&amp;
2411                         (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
2412                     commitTempPlacement();
2413                     completeAndClearReorderHintAnimations();
2414                     setItemPlacementDirty(false);
2415                 } else {
2416                     beginOrAdjustHintAnimations(finalSolution, dragView,
2417                             REORDER_ANIMATION_DURATION);
2418                 }
2419             }
2420         } else {
2421             foundSolution = false;
2422             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2423         }
2424 
2425         if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2426             setUseTempCoords(false);
2427         }
2428 
2429         mShortcutsAndWidgets.requestLayout();
2430         return result;
2431     }
2432 
2433     void setItemPlacementDirty(boolean dirty) {
2434         mItemPlacementDirty = dirty;
2435     }
2436     boolean isItemPlacementDirty() {
2437         return mItemPlacementDirty;
2438     }
2439 
2440     private class ItemConfiguration {
2441         HashMap&lt;View, CellAndSpan&gt; map = new HashMap&lt;View, CellAndSpan&gt;();
2442         boolean isSolution = false;
2443         int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2444 
2445         int area() {
2446             return dragViewSpanX * dragViewSpanY;
2447         }
2448     }
2449 
2450     private class CellAndSpan {
2451         int x, y;
2452         int spanX, spanY;
2453 
2454         public CellAndSpan(int x, int y, int spanX, int spanY) {
2455             this.x = x;
2456             this.y = y;
2457             this.spanX = spanX;
2458             this.spanY = spanY;
2459         }
2460     }
2461 
2462     /**
2463      * Find a vacant area that will fit the given bounds nearest the requested
2464      * cell location. Uses Euclidean distance to score multiple vacant areas.
2465      *
2466      * @param pixelX The X location at which you want to search for a vacant area.
2467      * @param pixelY The Y location at which you want to search for a vacant area.
2468      * @param spanX Horizontal span of the object.
2469      * @param spanY Vertical span of the object.
2470      * @param ignoreView Considers space occupied by this view as unoccupied
2471      * @param result Previously returned value to possibly recycle.
2472      * @return The X, Y cell of a vacant area that can contain this object,
2473      *         nearest the requested location.
2474      */
2475     int[] findNearestVacantArea(
2476             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2477         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2478     }
2479 
2480     /**
2481      * Find a vacant area that will fit the given bounds nearest the requested
2482      * cell location. Uses Euclidean distance to score multiple vacant areas.
2483      *
2484      * @param pixelX The X location at which you want to search for a vacant area.
2485      * @param pixelY The Y location at which you want to search for a vacant area.
2486      * @param minSpanX The minimum horizontal span required
2487      * @param minSpanY The minimum vertical span required
2488      * @param spanX Horizontal span of the object.
2489      * @param spanY Vertical span of the object.
2490      * @param ignoreView Considers space occupied by this view as unoccupied
2491      * @param result Previously returned value to possibly recycle.
2492      * @return The X, Y cell of a vacant area that can contain this object,
2493      *         nearest the requested location.
2494      */
2495     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2496             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2497         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2498                 result, resultSpan, mOccupied);
2499     }
2500 
2501     /**
2502      * Find a starting cell position that will fit the given bounds nearest the requested
2503      * cell location. Uses Euclidean distance to score multiple vacant areas.
2504      *
2505      * @param pixelX The X location at which you want to search for a vacant area.
2506      * @param pixelY The Y location at which you want to search for a vacant area.
2507      * @param spanX Horizontal span of the object.
2508      * @param spanY Vertical span of the object.
2509      * @param ignoreView Considers space occupied by this view as unoccupied
2510      * @param result Previously returned value to possibly recycle.
2511      * @return The X, Y cell of a vacant area that can contain this object,
2512      *         nearest the requested location.
2513      */
2514     int[] findNearestArea(
2515             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2516         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2517     }
2518 
2519     boolean existsEmptyCell() {
2520         return findCellForSpan(null, 1, 1);
2521     }
2522 
2523     /**
2524      * Finds the upper-left coordinate of the first rectangle in the grid that can
2525      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2526      * then this method will only return coordinates for rectangles that contain the cell
2527      * (intersectX, intersectY)
2528      *
2529      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2530      *               can be found.
2531      * @param spanX The horizontal span of the cell we want to find.
2532      * @param spanY The vertical span of the cell we want to find.
2533      *
2534      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2535      */
2536     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2537         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2538     }
2539 
2540     /**
2541      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2542      *
2543      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2544      *               can be found.
2545      * @param spanX The horizontal span of the cell we want to find.
2546      * @param spanY The vertical span of the cell we want to find.
2547      * @param ignoreView The home screen item we should treat as not occupying any space
2548      * @return
2549      */
2550     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2551         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2552                 ignoreView, mOccupied);
2553     }
2554 
2555     /**
2556      * Like above, but if intersectX and intersectY are not -1, then this method will try to
2557      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2558      *
2559      * @param spanX The horizontal span of the cell we want to find.
2560      * @param spanY The vertical span of the cell we want to find.
2561      * @param ignoreView The home screen item we should treat as not occupying any space
2562      * @param intersectX The X coordinate of the cell that we should try to overlap
2563      * @param intersectX The Y coordinate of the cell that we should try to overlap
2564      *
2565      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2566      */
2567     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2568             int intersectX, int intersectY) {
2569         return findCellForSpanThatIntersectsIgnoring(
2570                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2571     }
2572 
2573     /**
2574      * The superset of the above two methods
2575      */
2576     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2577             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2578         // mark space take by ignoreView as available (method checks if ignoreView is null)
2579         markCellsAsUnoccupiedForView(ignoreView, occupied);
2580 
2581         boolean foundCell = false;
2582         while (true) {
2583             int startX = 0;
2584             if (intersectX &gt;= 0) {
2585                 startX = Math.max(startX, intersectX - (spanX - 1));
2586             }
2587             int endX = mCountX - (spanX - 1);
2588             if (intersectX &gt;= 0) {
2589                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2590             }
2591             int startY = 0;
2592             if (intersectY &gt;= 0) {
2593                 startY = Math.max(startY, intersectY - (spanY - 1));
2594             }
2595             int endY = mCountY - (spanY - 1);
2596             if (intersectY &gt;= 0) {
2597                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2598             }
2599 
2600             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2601                 inner:
2602                 for (int x = startX; x &lt; endX; x++) {
2603                     for (int i = 0; i &lt; spanX; i++) {
2604                         for (int j = 0; j &lt; spanY; j++) {
2605                             if (occupied[x + i][y + j]) {
2606                                 // small optimization: we can skip to after the column we just found
2607                                 // an occupied cell
2608                                 x += i;
2609                                 continue inner;
2610                             }
2611                         }
2612                     }
2613                     if (cellXY != null) {
2614                         cellXY[0] = x;
2615                         cellXY[1] = y;
2616                     }
2617                     foundCell = true;
2618                     break;
2619                 }
2620             }
2621             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2622                 break;
2623             } else {
2624                 // if we failed to find anything, try again but without any requirements of
2625                 // intersecting
2626                 intersectX = -1;
2627                 intersectY = -1;
2628                 continue;
2629             }
2630         }
2631 
2632         // re-mark space taken by ignoreView as occupied
2633         markCellsAsOccupiedForView(ignoreView, occupied);
2634         return foundCell;
2635     }
2636 
2637     /**
2638      * A drag event has begun over this layout.
2639      * It may have begun over this layout (in which case onDragChild is called first),
2640      * or it may have begun on another layout.
2641      */
2642     void onDragEnter() {
2643         mDragEnforcer.onDragEnter();
2644         mDragging = true;
2645     }
2646 
2647     /**
2648      * Called when drag has left this CellLayout or has been completed (successfully or not)
2649      */
2650     void onDragExit() {
2651         mDragEnforcer.onDragExit();
2652         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2653         // item to this layout via the customize drawer.
2654         // Guard against that case.
2655         if (mDragging) {
2656             mDragging = false;
2657         }
2658 
2659         // Invalidate the drag data
2660         mDragCell[0] = mDragCell[1] = -1;
2661         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2662         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2663         revertTempState();
2664         setIsDragOverlapping(false);
2665     }
2666 
2667     /**
2668      * Mark a child as having been dropped.
2669      * At the beginning of the drag operation, the child may have been on another
2670      * screen, but it is re-parented before this method is called.
2671      *
2672      * @param child The child that is being dropped
2673      */
2674     void onDropChild(View child) {
2675         if (child != null) {
2676             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2677             lp.dropped = true;
2678             child.requestLayout();
2679         }
2680     }
2681 
2682     /**
2683      * Computes a bounding rectangle for a range of cells
2684      *
2685      * @param cellX X coordinate of upper left corner expressed as a cell position
2686      * @param cellY Y coordinate of upper left corner expressed as a cell position
2687      * @param cellHSpan Width in cells
2688      * @param cellVSpan Height in cells
2689      * @param resultRect Rect into which to put the results
2690      */
2691     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2692         final int cellWidth = mCellWidth;
2693         final int cellHeight = mCellHeight;
2694         final int widthGap = mWidthGap;
2695         final int heightGap = mHeightGap;
2696 
2697         final int hStartPadding = getPaddingLeft();
2698         final int vStartPadding = getPaddingTop();
2699 
2700         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2701         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2702 
2703         int x = hStartPadding + cellX * (cellWidth + widthGap);
2704         int y = vStartPadding + cellY * (cellHeight + heightGap);
2705 
2706         resultRect.set(x, y, x + width, y + height);
2707     }
2708 
2709     /**
2710      * Computes the required horizontal and vertical cell spans to always
2711      * fit the given rectangle.
2712      *
2713      * @param width Width in pixels
2714      * @param height Height in pixels
2715      * @param result An array of length 2 in which to store the result (may be null).
2716      */
2717     public int[] rectToCell(int width, int height, int[] result) {
2718         return rectToCell(getResources(), width, height, result);
2719     }
2720 
2721     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2722         // Always assume we&#x27;re working with the smallest span to make sure we
2723         // reserve enough space in both orientations.
2724         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2725         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2726         int smallerSize = Math.min(actualWidth, actualHeight);
2727 
2728         // Always round up to next largest cell
2729         int spanX = (int) Math.ceil(width / (float) smallerSize);
2730         int spanY = (int) Math.ceil(height / (float) smallerSize);
2731 
2732         if (result == null) {
2733             return new int[] { spanX, spanY };
2734         }
2735         result[0] = spanX;
2736         result[1] = spanY;
2737         return result;
2738     }
2739 
2740     public int[] cellSpansToSize(int hSpans, int vSpans) {
2741         int[] size = new int[2];
2742         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2743         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2744         return size;
2745     }
2746 
2747     /**
2748      * Calculate the grid spans needed to fit given item
2749      */
2750     public void calculateSpans(ItemInfo info) {
2751         final int minWidth;
2752         final int minHeight;
2753 
2754         if (info instanceof LauncherAppWidgetInfo) {
2755             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2756             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2757         } else if (info instanceof PendingAddWidgetInfo) {
2758             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2759             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2760         } else {
2761             // It&#x27;s not a widget, so it must be 1x1
2762             info.spanX = info.spanY = 1;
2763             return;
2764         }
2765         int[] spans = rectToCell(minWidth, minHeight, null);
2766         info.spanX = spans[0];
2767         info.spanY = spans[1];
2768     }
2769 
2770     /**
2771      * Find the first vacant cell, if there is one.
2772      *
2773      * @param vacant Holds the x and y coordinate of the vacant cell
2774      * @param spanX Horizontal cell span.
2775      * @param spanY Vertical cell span.
2776      *
2777      * @return True if a vacant cell was found
2778      */
2779     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2780 
2781         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2782     }
2783 
2784     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2785             int xCount, int yCount, boolean[][] occupied) {
2786 
2787         for (int y = 0; y &lt; yCount; y++) {
2788             for (int x = 0; x &lt; xCount; x++) {
2789                 boolean available = !occupied[x][y];
2790 out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2791                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2792                         available = available &amp;&amp; !occupied[i][j];
2793                         if (!available) break out;
2794                     }
2795                 }
2796 
2797                 if (available) {
2798                     vacant[0] = x;
2799                     vacant[1] = y;
2800                     return true;
2801                 }
2802             }
2803         }
2804 
2805         return false;
2806     }
2807 
2808     private void clearOccupiedCells() {
2809         for (int x = 0; x &lt; mCountX; x++) {
2810             for (int y = 0; y &lt; mCountY; y++) {
2811                 mOccupied[x][y] = false;
2812             }
2813         }
2814     }
2815 
2816     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2817         markCellsAsUnoccupiedForView(view);
2818         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2819     }
2820 
2821     public void markCellsAsOccupiedForView(View view) {
2822         markCellsAsOccupiedForView(view, mOccupied);
2823     }
2824     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2825         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2826         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2827         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2828     }
2829 
2830     public void markCellsAsUnoccupiedForView(View view) {
2831         markCellsAsUnoccupiedForView(view, mOccupied);
2832     }
2833     public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2834         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2835         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2836         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2837     }
2838 
2839     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2840             boolean value) {
2841         if (cellX &lt; 0 || cellY &lt; 0) return;
2842         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2843             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2844                 occupied[x][y] = value;
2845             }
2846         }
2847     }
2848 
2849     public int getDesiredWidth() {
2850         return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
2851                 (Math.max((mCountX - 1), 0) * mWidthGap);
2852     }
2853 
2854     public int getDesiredHeight()  {
2855         return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
2856                 (Math.max((mCountY - 1), 0) * mHeightGap);
2857     }
2858 
2859     public boolean isOccupied(int x, int y) {
2860         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2861             return mOccupied[x][y];
2862         } else {
2863             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2864         }
2865     }
2866 
2867     @Override
2868     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2869         return new CellLayout.LayoutParams(getContext(), attrs);
2870     }
2871 
2872     @Override
2873     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2874         return p instanceof CellLayout.LayoutParams;
2875     }
2876 
2877     @Override
2878     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2879         return new CellLayout.LayoutParams(p);
2880     }
2881 
2882     public static class CellLayoutAnimationController extends LayoutAnimationController {
2883         public CellLayoutAnimationController(Animation animation, float delay) {
2884             super(animation, delay);
2885         }
2886 
2887         @Override
2888         protected long getDelayForView(View view) {
2889             return (int) (Math.random() * 150);
2890         }
2891     }
2892 
2893     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2894         /**
2895          * Horizontal location of the item in the grid.
2896          */
2897         @ViewDebug.ExportedProperty
2898         public int cellX;
2899 
2900         /**
2901          * Vertical location of the item in the grid.
2902          */
2903         @ViewDebug.ExportedProperty
2904         public int cellY;
2905 
2906         /**
2907          * Temporary horizontal location of the item in the grid during reorder
2908          */
2909         public int tmpCellX;
2910 
2911         /**
2912          * Temporary vertical location of the item in the grid during reorder
2913          */
2914         public int tmpCellY;
2915 
2916         /**
2917          * Indicates that the temporary coordinates should be used to layout the items
2918          */
2919         public boolean useTmpCoords;
2920 
2921         /**
2922          * Number of cells spanned horizontally by the item.
2923          */
2924         @ViewDebug.ExportedProperty
2925         public int cellHSpan;
2926 
2927         /**
2928          * Number of cells spanned vertically by the item.
2929          */
2930         @ViewDebug.ExportedProperty
2931         public int cellVSpan;
2932 
2933         /**
2934          * Indicates whether the item will set its x, y, width and height parameters freely,
2935          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2936          */
2937         public boolean isLockedToGrid = true;
2938 
2939         /**
2940          * Indicates whether this item can be reordered. Always true except in the case of the
2941          * the AllApps button.
2942          */
2943         public boolean canReorder = true;
2944 
2945         // X coordinate of the view in the layout.
2946         @ViewDebug.ExportedProperty
2947         int x;
2948         // Y coordinate of the view in the layout.
2949         @ViewDebug.ExportedProperty
2950         int y;
2951 
2952         boolean dropped;
2953 
2954         public LayoutParams(Context c, AttributeSet attrs) {
2955             super(c, attrs);
2956             cellHSpan = 1;
2957             cellVSpan = 1;
2958         }
2959 
2960         public LayoutParams(ViewGroup.LayoutParams source) {
2961             super(source);
2962             cellHSpan = 1;
2963             cellVSpan = 1;
2964         }
2965 
2966         public LayoutParams(LayoutParams source) {
2967             super(source);
2968             this.cellX = source.cellX;
2969             this.cellY = source.cellY;
2970             this.cellHSpan = source.cellHSpan;
2971             this.cellVSpan = source.cellVSpan;
2972         }
2973 
2974         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2975             super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2976             this.cellX = cellX;
2977             this.cellY = cellY;
2978             this.cellHSpan = cellHSpan;
2979             this.cellVSpan = cellVSpan;
2980         }
2981 
2982         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2983             if (isLockedToGrid) {
2984                 final int myCellHSpan = cellHSpan;
2985                 final int myCellVSpan = cellVSpan;
2986                 final int myCellX = useTmpCoords ? tmpCellX : cellX;
2987                 final int myCellY = useTmpCoords ? tmpCellY : cellY;
2988 
2989                 width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2990                         leftMargin - rightMargin;
2991                 height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2992                         topMargin - bottomMargin;
2993                 x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2994                 y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2995             }
2996         }
2997 
2998         public String toString() {
2999             return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
3000         }
3001 
3002         public void setWidth(int width) {
3003             this.width = width;
3004         }
3005 
3006         public int getWidth() {
3007             return width;
3008         }
3009 
3010         public void setHeight(int height) {
3011             this.height = height;
3012         }
3013 
3014         public int getHeight() {
3015             return height;
3016         }
3017 
3018         public void setX(int x) {
3019             this.x = x;
3020         }
3021 
3022         public int getX() {
3023             return x;
3024         }
3025 
3026         public void setY(int y) {
3027             this.y = y;
3028         }
3029 
3030         public int getY() {
3031             return y;
3032         }
3033     }
3034 
3035     // This class stores info for two purposes:
3036     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
3037     //    its spanX, spanY, and the screen it is on
3038     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
3039     //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
3040     //    the CellLayout that was long clicked
3041     static final class CellInfo {
3042         View cell;
3043         int cellX = -1;
3044         int cellY = -1;
3045         int spanX;
3046         int spanY;
3047         int screen;
3048         long container;
3049 
3050         @Override
3051         public String toString() {
3052             return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
3053                     + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
3054         }
3055     }
3056 
3057     public boolean lastDownOnOccupiedCell() {
3058         return mLastDownOnOccupiedCell;
3059     }
3060 }
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher2;
  18 
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.TimeInterpolator;
  23 import android.animation.ValueAnimator;
  24 import android.animation.ValueAnimator.AnimatorUpdateListener;
  25 import android.content.Context;
  26 import android.content.res.Resources;
  27 import android.content.res.TypedArray;
  28 import android.graphics.Bitmap;
  29 import android.graphics.Canvas;
  30 import android.graphics.Color;
  31 import android.graphics.Paint;
  32 import android.graphics.Point;
  33 import android.graphics.PorterDuff;
  34 import android.graphics.PorterDuffXfermode;
  35 import android.graphics.Rect;
  36 import android.graphics.drawable.ColorDrawable;
  37 import android.graphics.drawable.Drawable;
  38 import android.graphics.drawable.NinePatchDrawable;
  39 import android.os.Parcelable;
  40 import android.util.AttributeSet;
  41 import android.util.Log;
  42 import android.util.SparseArray;
  43 import android.view.MotionEvent;
  44 import android.view.View;
  45 import android.view.ViewDebug;
  46 import android.view.ViewGroup;
  47 import android.view.animation.Animation;
  48 import android.view.animation.DecelerateInterpolator;
  49 import android.view.animation.LayoutAnimationController;
  50 
  51 import com.android.launcher.R;
  52 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53 
  54 import java.util.ArrayList;
  55 import java.util.Arrays;
  56 import java.util.HashMap;
  57 import java.util.Stack;
  58 
  59 public class CellLayout extends ViewGroup {
  60     static final String TAG = &quot;CellLayout&quot;;
  61 
  62     private Launcher mLauncher;
  63     private int mCellWidth;
  64     private int mCellHeight;
  65 
  66     private int mCountX;
  67     private int mCountY;
  68 
  69     private int mOriginalWidthGap;
  70     private int mOriginalHeightGap;
  71     private int mWidthGap;
  72     private int mHeightGap;
  73     private int mMaxGap;
  74     private boolean mScrollingTransformsDirty = false;
  75 
  76     private final Rect mRect = new Rect();
  77     private final CellInfo mCellInfo = new CellInfo();
  78 
  79     // These are temporary variables to prevent having to allocate a new object just to
  80     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  81     private final int[] mTmpXY = new int[2];
  82     private final int[] mTmpPoint = new int[2];
  83     int[] mTempLocation = new int[2];
  84 
  85     boolean[][] mOccupied;
  86     boolean[][] mTmpOccupied;
  87     private boolean mLastDownOnOccupiedCell = false;
  88 
  89     private OnTouchListener mInterceptTouchListener;
  90 
  91     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  92     private int[] mFolderLeaveBehindCell = {-1, -1};
  93 
  94     private int mForegroundAlpha = 0;
  95     private float mBackgroundAlpha;
  96     private float mBackgroundAlphaMultiplier = 1.0f;
  97 
  98     private Drawable mNormalBackground;
  99     private Drawable mActiveGlowBackground;
 100     private Drawable mOverScrollForegroundDrawable;
 101     private Drawable mOverScrollLeft;
 102     private Drawable mOverScrollRight;
 103     private Rect mBackgroundRect;
 104     private Rect mForegroundRect;
 105     private int mForegroundPadding;
 106 
 107     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 108     private boolean mIsDragOverlapping = false;
 109     private final Point mDragCenter = new Point();
 110 
 111     // These arrays are used to implement the drag visualization on x-large screens.
 112     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 113     private Rect[] mDragOutlines = new Rect[4];
 114     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 115     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 116             new InterruptibleInOutAnimator[mDragOutlines.length];
 117 
 118     // Used as an index into the above 3 arrays; indicates which is the most current value.
 119     private int mDragOutlineCurrent = 0;
 120     private final Paint mDragOutlinePaint = new Paint();
 121 
 122     private BubbleTextView mPressedOrFocusedIcon;
 123 
 124     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 125             HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 126     private HashMap&lt;View, ReorderHintAnimation&gt;
 127             mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;();
 128 
 129     private boolean mItemPlacementDirty = false;
 130 
 131     // When a drag operation is in progress, holds the nearest cell to the touch point
 132     private final int[] mDragCell = new int[2];
 133 
 134     private boolean mDragging = false;
 135 
 136     private TimeInterpolator mEaseOutInterpolator;
 137     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 138 
 139     private boolean mIsHotseat = false;
 140 
 141     public static final int MODE_DRAG_OVER = 0;
 142     public static final int MODE_ON_DROP = 1;
 143     public static final int MODE_ON_DROP_EXTERNAL = 2;
 144     public static final int MODE_ACCEPT_DROP = 3;
 145     private static final boolean DESTRUCTIVE_REORDER = false;
 146     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 147 
 148     static final int LANDSCAPE = 0;
 149     static final int PORTRAIT = 1;
 150 
 151     private static final float REORDER_HINT_MAGNITUDE = 0.12f;
 152     private static final int REORDER_ANIMATION_DURATION = 150;
 153     private float mReorderHintAnimationMagnitude;
 154 
 155     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 156     private Rect mOccupiedRect = new Rect();
 157     private int[] mDirectionVector = new int[2];
 158     int[] mPreviousReorderDirection = new int[2];
 159     private static final int INVALID_DIRECTION = -100;
 160     private DropTarget.DragEnforcer mDragEnforcer;
 161 
 162     private final static PorterDuffXfermode sAddBlendMode =
 163             new PorterDuffXfermode(PorterDuff.Mode.ADD);
 164     private final static Paint sPaint = new Paint();
 165 
 166     public CellLayout(Context context) {
 167         this(context, null);
 168     }
 169 
 170     public CellLayout(Context context, AttributeSet attrs) {
 171         this(context, attrs, 0);
 172     }
 173 
 174     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 175         super(context, attrs, defStyle);
 176         mDragEnforcer = new DropTarget.DragEnforcer(context);
 177 
 178         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 179         // the user where a dragged item will land when dropped.
 180         setWillNotDraw(false);
 181         mLauncher = (Launcher) context;
 182 
 183         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 184 
 185         mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 186         mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 187         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 188         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 189         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 190         mCountX = LauncherModel.getCellCountX();
 191         mCountY = LauncherModel.getCellCountY();
 192         mOccupied = new boolean[mCountX][mCountY];
 193         mTmpOccupied = new boolean[mCountX][mCountY];
 194         mPreviousReorderDirection[0] = INVALID_DIRECTION;
 195         mPreviousReorderDirection[1] = INVALID_DIRECTION;
 196 
 197         a.recycle();
 198 
 199         setAlwaysDrawnWithCacheEnabled(false);
 200 
 201         final Resources res = getResources();
 202 
 203         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 204         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 205 
 206         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 207         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 208         mForegroundPadding =
 209                 res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 210 
 211         mReorderHintAnimationMagnitude = (REORDER_HINT_MAGNITUDE *
 212                 res.getDimensionPixelSize(R.dimen.app_icon_size));
 213 
 214         mNormalBackground.setFilterBitmap(true);
 215         mActiveGlowBackground.setFilterBitmap(true);
 216 
 217         // Initialize the data structures used for the drag visualization.
 218 
 219         mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 220 
 221 
 222         mDragCell[0] = mDragCell[1] = -1;
 223         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 224             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 225         }
 226 
 227         // When dragging things around the home screens, we show a green outline of
 228         // where the item will land. The outlines gradually fade out, leaving a trail
 229         // behind the drag path.
 230         // Set up all the animations that are used to implement this fading.
 231         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 232         final float fromAlphaValue = 0;
 233         final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 234 
 235         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 236 
 237         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 238             final InterruptibleInOutAnimator anim =
 239                 new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 240             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 241             final int thisIndex = i;
 242             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 243                 public void onAnimationUpdate(ValueAnimator animation) {
 244                     final Bitmap outline = (Bitmap)anim.getTag();
 245 
 246                     // If an animation is started and then stopped very quickly, we can still
 247                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 248                     if (outline == null) {
 249                         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 250                         final boolean debug = false;
 251                         if (debug) {
 252                             Object val = animation.getAnimatedValue();
 253                             Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 254                                      &quot;, isStopped &quot; + anim.isStopped());
 255                         }
 256                         // Try to prevent it from continuing to run
 257                         animation.cancel();
 258                     } else {
 259                         mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 260                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 261                     }
 262                 }
 263             });
 264             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 265             // running. This way the bitmap can be GCed when the animations are complete.
 266             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 267                 @Override
 268                 public void onAnimationEnd(Animator animation) {
 269                     if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 270                         anim.setTag(null);
 271                     }
 272                 }
 273             });
 274             mDragOutlineAnims[i] = anim;
 275         }
 276 
 277         mBackgroundRect = new Rect();
 278         mForegroundRect = new Rect();
 279 
 280         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 281         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 282         addView(mShortcutsAndWidgets);
 283     }
 284 
 285     static int widthInPortrait(Resources r, int numCells) {
 286         // We use this method from Workspace to figure out how many rows/columns Launcher should
 287         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 288         // the padding extends outside the visible screen size, but it looked fine anyway.
 289         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 290         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 291                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 292 
 293         return  minGap * (numCells - 1) + cellWidth * numCells;
 294     }
 295 
 296     static int heightInLandscape(Resources r, int numCells) {
 297         // We use this method from Workspace to figure out how many rows/columns Launcher should
 298         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 299         // the padding extends outside the visible screen size, but it looked fine anyway.
 300         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 301         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 302                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 303 
 304         return minGap * (numCells - 1) + cellHeight * numCells;
 305     }
 306 
 307     public void enableHardwareLayers() {
 308         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_HARDWARE, sPaint);
 309     }
 310 
 311     public void disableHardwareLayers() {
 312         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_NONE, sPaint);
 313     }
 314 
 315     public void buildHardwareLayer() {
 316         mShortcutsAndWidgets.buildLayer();
 317     }
 318 
 319     public void setGridSize(int x, int y) {
 320         mCountX = x;
 321         mCountY = y;
 322         mOccupied = new boolean[mCountX][mCountY];
 323         mTmpOccupied = new boolean[mCountX][mCountY];
 324         mTempRectStack.clear();
 325         requestLayout();
 326     }
 327 
 328     private void invalidateBubbleTextView(BubbleTextView icon) {
 329         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 330         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 331                 icon.getTop() + getPaddingTop() - padding,
 332                 icon.getRight() + getPaddingLeft() + padding,
 333                 icon.getBottom() + getPaddingTop() + padding);
 334     }
 335 
 336     void setOverScrollAmount(float r, boolean left) {
 337         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 338             mOverScrollForegroundDrawable = mOverScrollLeft;
 339         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 340             mOverScrollForegroundDrawable = mOverScrollRight;
 341         }
 342 
 343         mForegroundAlpha = (int) Math.round((r * 255));
 344         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 345         invalidate();
 346     }
 347 
 348     void setPressedOrFocusedIcon(BubbleTextView icon) {
 349         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 350         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 351         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 352         mPressedOrFocusedIcon = icon;
 353         if (oldIcon != null) {
 354             invalidateBubbleTextView(oldIcon);
 355         }
 356         if (mPressedOrFocusedIcon != null) {
 357             invalidateBubbleTextView(mPressedOrFocusedIcon);
 358         }
 359     }
 360 
 361     void setIsDragOverlapping(boolean isDragOverlapping) {
 362         if (mIsDragOverlapping != isDragOverlapping) {
 363             mIsDragOverlapping = isDragOverlapping;
 364             invalidate();
 365         }
 366     }
 367 
 368     boolean getIsDragOverlapping() {
 369         return mIsDragOverlapping;
 370     }
 371 
 372     protected void setOverscrollTransformsDirty(boolean dirty) {
 373         mScrollingTransformsDirty = dirty;
 374     }
 375 
 376     protected void resetOverscrollTransforms() {
 377         if (mScrollingTransformsDirty) {
 378             setOverscrollTransformsDirty(false);
 379             setTranslationX(0);
 380             setRotationY(0);
 381             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 382             // pass 0, which results in the overscroll drawable not being drawn any more.
 383             setOverScrollAmount(0, false);
 384             setPivotX(getMeasuredWidth() / 2);
 385             setPivotY(getMeasuredHeight() / 2);
 386         }
 387     }
 388 
 389     @Override
 390     protected void onDraw(Canvas canvas) {
 391         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 392         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 393         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 394         // a drag). However, we also drag the mini hover background *over* one of those two
 395         // backgrounds
 396         if (mBackgroundAlpha &gt; 0.0f) {
 397             Drawable bg;
 398 
 399             if (mIsDragOverlapping) {
 400                 // In the mini case, we draw the active_glow bg *over* the active background
 401                 bg = mActiveGlowBackground;
 402             } else {
 403                 bg = mNormalBackground;
 404             }
 405 
 406             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 407             bg.setBounds(mBackgroundRect);
 408             bg.draw(canvas);
 409         }
 410 
 411         final Paint paint = mDragOutlinePaint;
 412         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 413             final float alpha = mDragOutlineAlphas[i];
 414             if (alpha &gt; 0) {
 415                 final Rect r = mDragOutlines[i];
 416                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 417                 paint.setAlpha((int)(alpha + .5f));
 418                 canvas.drawBitmap(b, null, r, paint);
 419             }
 420         }
 421 
 422         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 423         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 424         if (mPressedOrFocusedIcon != null) {
 425             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 426             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 427             if (b != null) {
 428                 canvas.drawBitmap(b,
 429                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 430                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 431                         null);
 432             }
 433         }
 434 
 435         if (DEBUG_VISUALIZE_OCCUPIED) {
 436             int[] pt = new int[2];
 437             ColorDrawable cd = new ColorDrawable(Color.RED);
 438             cd.setBounds(0, 0,  mCellWidth, mCellHeight);
 439             for (int i = 0; i &lt; mCountX; i++) {
 440                 for (int j = 0; j &lt; mCountY; j++) {
 441                     if (mOccupied[i][j]) {
 442                         cellToPoint(i, j, pt);
 443                         canvas.save();
 444                         canvas.translate(pt[0], pt[1]);
 445                         cd.draw(canvas);
 446                         canvas.restore();
 447                     }
 448                 }
 449             }
 450         }
 451 
 452         int previewOffset = FolderRingAnimator.sPreviewSize;
 453 
 454         // The folder outer / inner ring image(s)
 455         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 456             FolderRingAnimator fra = mFolderOuterRings.get(i);
 457 
 458             // Draw outer ring
 459             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 460             int width = (int) fra.getOuterRingSize();
 461             int height = width;
 462             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 463 
 464             int centerX = mTempLocation[0] + mCellWidth / 2;
 465             int centerY = mTempLocation[1] + previewOffset / 2;
 466 
 467             canvas.save();
 468             canvas.translate(centerX - width / 2, centerY - height / 2);
 469             d.setBounds(0, 0, width, height);
 470             d.draw(canvas);
 471             canvas.restore();
 472 
 473             // Draw inner ring
 474             d = FolderRingAnimator.sSharedInnerRingDrawable;
 475             width = (int) fra.getInnerRingSize();
 476             height = width;
 477             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 478 
 479             centerX = mTempLocation[0] + mCellWidth / 2;
 480             centerY = mTempLocation[1] + previewOffset / 2;
 481             canvas.save();
 482             canvas.translate(centerX - width / 2, centerY - width / 2);
 483             d.setBounds(0, 0, width, height);
 484             d.draw(canvas);
 485             canvas.restore();
 486         }
 487 
 488         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 489             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 490             int width = d.getIntrinsicWidth();
 491             int height = d.getIntrinsicHeight();
 492 
 493             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 494             int centerX = mTempLocation[0] + mCellWidth / 2;
 495             int centerY = mTempLocation[1] + previewOffset / 2;
 496 
 497             canvas.save();
 498             canvas.translate(centerX - width / 2, centerY - width / 2);
 499             d.setBounds(0, 0, width, height);
 500             d.draw(canvas);
 501             canvas.restore();
 502         }
 503     }
 504 
 505     @Override
 506     protected void dispatchDraw(Canvas canvas) {
 507         super.dispatchDraw(canvas);
 508         if (mForegroundAlpha &gt; 0) {
 509             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 510             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 511             p.setXfermode(sAddBlendMode);
 512             mOverScrollForegroundDrawable.draw(canvas);
 513             p.setXfermode(null);
 514         }
 515     }
 516 
 517     public void showFolderAccept(FolderRingAnimator fra) {
 518         mFolderOuterRings.add(fra);
 519     }
 520 
 521     public void hideFolderAccept(FolderRingAnimator fra) {
 522         if (mFolderOuterRings.contains(fra)) {
 523             mFolderOuterRings.remove(fra);
 524         }
 525         invalidate();
 526     }
 527 
 528     public void setFolderLeaveBehindCell(int x, int y) {
 529         mFolderLeaveBehindCell[0] = x;
 530         mFolderLeaveBehindCell[1] = y;
 531         invalidate();
 532     }
 533 
 534     public void clearFolderLeaveBehind() {
 535         mFolderLeaveBehindCell[0] = -1;
 536         mFolderLeaveBehindCell[1] = -1;
 537         invalidate();
 538     }
 539 
 540     @Override
 541     public boolean shouldDelayChildPressedState() {
 542         return false;
 543     }
 544 
 545     public void restoreInstanceState(SparseArray&lt;Parcelable&gt; states) {
 546         dispatchRestoreInstanceState(states);
 547     }
 548 
 549     @Override
 550     public void cancelLongPress() {
 551         super.cancelLongPress();
 552 
 553         // Cancel long press for all children
 554         final int count = getChildCount();
 555         for (int i = 0; i &lt; count; i++) {
 556             final View child = getChildAt(i);
 557             child.cancelLongPress();
 558         }
 559     }
 560 
 561     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 562         mInterceptTouchListener = listener;
 563     }
 564 
 565     int getCountX() {
 566         return mCountX;
 567     }
 568 
 569     int getCountY() {
 570         return mCountY;
 571     }
 572 
 573     public void setIsHotseat(boolean isHotseat) {
 574         mIsHotseat = isHotseat;
 575     }
 576 
 577     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 578             boolean markCells) {
 579         final LayoutParams lp = params;
 580 
 581         // Hotseat icons - remove text
 582         if (child instanceof BubbleTextView) {
 583             BubbleTextView bubbleChild = (BubbleTextView) child;
 584 
 585             Resources res = getResources();
 586             if (mIsHotseat) {
 587                 bubbleChild.setTextColor(res.getColor(android.R.color.transparent));
 588             } else {
 589                 bubbleChild.setTextColor(res.getColor(R.color.workspace_icon_text_color));
 590             }
 591         }
 592 
 593         // Generate an id for each view, this assumes we have at most 256x256 cells
 594         // per workspace screen
 595         if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 596             // If the horizontal or vertical span is set to -1, it is taken to
 597             // mean that it spans the extent of the CellLayout
 598             if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 599             if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 600 
 601             child.setId(childId);
 602 
 603             mShortcutsAndWidgets.addView(child, index, lp);
 604 
 605             if (markCells) markCellsAsOccupiedForView(child);
 606 
 607             return true;
 608         }
 609         return false;
 610     }
 611 
 612     @Override
 613     public void removeAllViews() {
 614         clearOccupiedCells();
 615         mShortcutsAndWidgets.removeAllViews();
 616     }
 617 
 618     @Override
 619     public void removeAllViewsInLayout() {
 620         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 621             clearOccupiedCells();
 622             mShortcutsAndWidgets.removeAllViewsInLayout();
 623         }
 624     }
 625 
 626     public void removeViewWithoutMarkingCells(View view) {
 627         mShortcutsAndWidgets.removeView(view);
 628     }
 629 
 630     @Override
 631     public void removeView(View view) {
 632         markCellsAsUnoccupiedForView(view);
 633         mShortcutsAndWidgets.removeView(view);
 634     }
 635 
 636     @Override
 637     public void removeViewAt(int index) {
 638         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 639         mShortcutsAndWidgets.removeViewAt(index);
 640     }
 641 
 642     @Override
 643     public void removeViewInLayout(View view) {
 644         markCellsAsUnoccupiedForView(view);
 645         mShortcutsAndWidgets.removeViewInLayout(view);
 646     }
 647 
 648     @Override
 649     public void removeViews(int start, int count) {
 650         for (int i = start; i &lt; start + count; i++) {
 651             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 652         }
 653         mShortcutsAndWidgets.removeViews(start, count);
 654     }
 655 
 656     @Override
 657     public void removeViewsInLayout(int start, int count) {
 658         for (int i = start; i &lt; start + count; i++) {
 659             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 660         }
 661         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 662     }
 663 
 664     @Override
 665     protected void onAttachedToWindow() {
 666         super.onAttachedToWindow();
 667         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 668     }
 669 
 670     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 671         final CellInfo cellInfo = mCellInfo;
 672         Rect frame = mRect;
 673         final int x = touchX + getScrollX();
 674         final int y = touchY + getScrollY();
 675         final int count = mShortcutsAndWidgets.getChildCount();
 676 
 677         boolean found = false;
 678         for (int i = count - 1; i &gt;= 0; i--) {
 679             final View child = mShortcutsAndWidgets.getChildAt(i);
 680             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 681 
 682             if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 683                     lp.isLockedToGrid) {
 684                 child.getHitRect(frame);
 685 
 686                 float scale = child.getScaleX();
 687                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 688                         child.getBottom());
 689                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 690                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 691                 // to this view.
 692                 frame.offset(getPaddingLeft(), getPaddingTop());
 693                 frame.inset((int) (frame.width() * (1f - scale) / 2),
 694                         (int) (frame.height() * (1f - scale) / 2));
 695 
 696                 if (frame.contains(x, y)) {
 697                     cellInfo.cell = child;
 698                     cellInfo.cellX = lp.cellX;
 699                     cellInfo.cellY = lp.cellY;
 700                     cellInfo.spanX = lp.cellHSpan;
 701                     cellInfo.spanY = lp.cellVSpan;
 702                     found = true;
 703                     break;
 704                 }
 705             }
 706         }
 707 
 708         mLastDownOnOccupiedCell = found;
 709 
 710         if (!found) {
 711             final int cellXY[] = mTmpXY;
 712             pointToCellExact(x, y, cellXY);
 713 
 714             cellInfo.cell = null;
 715             cellInfo.cellX = cellXY[0];
 716             cellInfo.cellY = cellXY[1];
 717             cellInfo.spanX = 1;
 718             cellInfo.spanY = 1;
 719         }
 720         setTag(cellInfo);
 721     }
 722 
 723     @Override
 724     public boolean onInterceptTouchEvent(MotionEvent ev) {
 725         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 726         // even in the case where we return early. Not clearing here was causing bugs whereby on
 727         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 728         final int action = ev.getAction();
 729 
 730         if (action == MotionEvent.ACTION_DOWN) {
 731             clearTagCellInfo();
 732         }
 733 
 734         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 735             return true;
 736         }
 737 
 738         if (action == MotionEvent.ACTION_DOWN) {
 739             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 740         }
 741 
 742         return false;
 743     }
 744 
 745     private void clearTagCellInfo() {
 746         final CellInfo cellInfo = mCellInfo;
 747         cellInfo.cell = null;
 748         cellInfo.cellX = -1;
 749         cellInfo.cellY = -1;
 750         cellInfo.spanX = 0;
 751         cellInfo.spanY = 0;
 752         setTag(cellInfo);
 753     }
 754 
 755     public CellInfo getTag() {
 756         return (CellInfo) super.getTag();
 757     }
 758 
 759     /**
 760      * Given a point, return the cell that strictly encloses that point
 761      * @param x X coordinate of the point
 762      * @param y Y coordinate of the point
 763      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 764      */
 765     void pointToCellExact(int x, int y, int[] result) {
 766         final int hStartPadding = getPaddingLeft();
 767         final int vStartPadding = getPaddingTop();
 768 
 769         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 770         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 771 
 772         final int xAxis = mCountX;
 773         final int yAxis = mCountY;
 774 
 775         if (result[0] &lt; 0) result[0] = 0;
 776         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 777         if (result[1] &lt; 0) result[1] = 0;
 778         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 779     }
 780 
 781     /**
 782      * Given a point, return the cell that most closely encloses that point
 783      * @param x X coordinate of the point
 784      * @param y Y coordinate of the point
 785      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 786      */
 787     void pointToCellRounded(int x, int y, int[] result) {
 788         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 789     }
 790 
 791     /**
 792      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 793      *
 794      * @param cellX X coordinate of the cell
 795      * @param cellY Y coordinate of the cell
 796      *
 797      * @param result Array of 2 ints to hold the x and y coordinate of the point
 798      */
 799     void cellToPoint(int cellX, int cellY, int[] result) {
 800         final int hStartPadding = getPaddingLeft();
 801         final int vStartPadding = getPaddingTop();
 802 
 803         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 804         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 805     }
 806 
 807     /**
 808      * Given a cell coordinate, return the point that represents the center of the cell
 809      *
 810      * @param cellX X coordinate of the cell
 811      * @param cellY Y coordinate of the cell
 812      *
 813      * @param result Array of 2 ints to hold the x and y coordinate of the point
 814      */
 815     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 816         regionToCenterPoint(cellX, cellY, 1, 1, result);
 817     }
 818 
 819     /**
 820      * Given a cell coordinate and span return the point that represents the center of the regio
 821      *
 822      * @param cellX X coordinate of the cell
 823      * @param cellY Y coordinate of the cell
 824      *
 825      * @param result Array of 2 ints to hold the x and y coordinate of the point
 826      */
 827     void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 828         final int hStartPadding = getPaddingLeft();
 829         final int vStartPadding = getPaddingTop();
 830         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 831                 (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 832         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 833                 (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
 834     }
 835 
 836      /**
 837      * Given a cell coordinate and span fills out a corresponding pixel rect
 838      *
 839      * @param cellX X coordinate of the cell
 840      * @param cellY Y coordinate of the cell
 841      * @param result Rect in which to write the result
 842      */
 843      void regionToRect(int cellX, int cellY, int spanX, int spanY, Rect result) {
 844         final int hStartPadding = getPaddingLeft();
 845         final int vStartPadding = getPaddingTop();
 846         final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);
 847         final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);
 848         result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),
 849                 top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
 850     }
 851 
 852     public float getDistanceFromCell(float x, float y, int[] cell) {
 853         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 854         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 855                 Math.pow(y - mTmpPoint[1], 2));
 856         return distance;
 857     }
 858 
 859     int getCellWidth() {
 860         return mCellWidth;
 861     }
 862 
 863     int getCellHeight() {
 864         return mCellHeight;
 865     }
 866 
 867     int getWidthGap() {
 868         return mWidthGap;
 869     }
 870 
 871     int getHeightGap() {
 872         return mHeightGap;
 873     }
 874 
 875     Rect getContentRect(Rect r) {
 876         if (r == null) {
 877             r = new Rect();
 878         }
 879         int left = getPaddingLeft();
 880         int top = getPaddingTop();
 881         int right = left + getWidth() - getPaddingLeft() - getPaddingRight();
 882         int bottom = top + getHeight() - getPaddingTop() - getPaddingBottom();
 883         r.set(left, top, right, bottom);
 884         return r;
 885     }
 886 
 887     static void getMetrics(Rect metrics, Resources res, int measureWidth, int measureHeight,
 888             int countX, int countY, int orientation) {
 889         int numWidthGaps = countX - 1;
 890         int numHeightGaps = countY - 1;
 891 
 892         int widthGap;
 893         int heightGap;
 894         int cellWidth;
 895         int cellHeight;
 896         int paddingLeft;
 897         int paddingRight;
 898         int paddingTop;
 899         int paddingBottom;
 900 
 901         int maxGap = res.getDimensionPixelSize(R.dimen.workspace_max_gap);
 902         if (orientation == LANDSCAPE) {
 903             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_land);
 904             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_land);
 905             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_land);
 906             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_land);
 907             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_land);
 908             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_land);
 909             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_land);
 910             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_land);
 911         } else {
 912             // PORTRAIT
 913             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_port);
 914             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_port);
 915             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_port);
 916             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_port);
 917             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_port);
 918             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_port);
 919             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_port);
 920             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_port);
 921         }
 922 
 923         if (widthGap &lt; 0 || heightGap &lt; 0) {
 924             int hSpace = measureWidth - paddingLeft - paddingRight;
 925             int vSpace = measureHeight - paddingTop - paddingBottom;
 926             int hFreeSpace = hSpace - (countX * cellWidth);
 927             int vFreeSpace = vSpace - (countY * cellHeight);
 928             widthGap = Math.min(maxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 929             heightGap = Math.min(maxGap, numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 930         }
 931         metrics.set(cellWidth, cellHeight, widthGap, heightGap);
 932     }
 933 
 934     @Override
 935     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 936         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 937         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 938 
 939         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 940         int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 941 
 942         if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 943             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 944         }
 945 
 946         int numWidthGaps = mCountX - 1;
 947         int numHeightGaps = mCountY - 1;
 948 
 949         if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 950             int hSpace = widthSpecSize - getPaddingLeft() - getPaddingRight();
 951             int vSpace = heightSpecSize - getPaddingTop() - getPaddingBottom();
 952             int hFreeSpace = hSpace - (mCountX * mCellWidth);
 953             int vFreeSpace = vSpace - (mCountY * mCellHeight);
 954             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 955             mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 956             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 957         } else {
 958             mWidthGap = mOriginalWidthGap;
 959             mHeightGap = mOriginalHeightGap;
 960         }
 961 
 962         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 963         int newWidth = widthSpecSize;
 964         int newHeight = heightSpecSize;
 965         if (widthSpecMode == MeasureSpec.AT_MOST) {
 966             newWidth = getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
 967                 ((mCountX - 1) * mWidthGap);
 968             newHeight = getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
 969                 ((mCountY - 1) * mHeightGap);
 970             setMeasuredDimension(newWidth, newHeight);
 971         }
 972 
 973         int count = getChildCount();
 974         for (int i = 0; i &lt; count; i++) {
 975             View child = getChildAt(i);
 976             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - getPaddingLeft() -
 977                     getPaddingRight(), MeasureSpec.EXACTLY);
 978             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - getPaddingTop() -
 979                     getPaddingBottom(), MeasureSpec.EXACTLY);
 980             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 981         }
 982         setMeasuredDimension(newWidth, newHeight);
 983     }
 984 
 985     @Override
 986     protected void onLayout(boolean changed, int l, int t, int r, int b) {
 987         int count = getChildCount();
 988         for (int i = 0; i &lt; count; i++) {
 989             View child = getChildAt(i);
 990             child.layout(getPaddingLeft(), getPaddingTop(),
 991                     r - l - getPaddingRight(), b - t - getPaddingBottom());
 992         }
 993     }
 994 
 995     @Override
 996     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 997         super.onSizeChanged(w, h, oldw, oldh);
 998         mBackgroundRect.set(0, 0, w, h);
 999         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
1000                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
1001     }
1002 
1003     @Override
1004     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
1005         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
1006     }
1007 
1008     @Override
1009     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1010         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
1011     }
1012 
1013     public float getBackgroundAlpha() {
1014         return mBackgroundAlpha;
1015     }
1016 
1017     public void setBackgroundAlphaMultiplier(float multiplier) {
1018         if (mBackgroundAlphaMultiplier != multiplier) {
1019             mBackgroundAlphaMultiplier = multiplier;
1020             invalidate();
1021         }
1022     }
1023 
1024     public float getBackgroundAlphaMultiplier() {
1025         return mBackgroundAlphaMultiplier;
1026     }
1027 
1028     public void setBackgroundAlpha(float alpha) {
1029         if (mBackgroundAlpha != alpha) {
1030             mBackgroundAlpha = alpha;
1031             invalidate();
1032         }
1033     }
1034 
1035     public void setShortcutAndWidgetAlpha(float alpha) {
1036         final int childCount = getChildCount();
1037         for (int i = 0; i &lt; childCount; i++) {
1038             getChildAt(i).setAlpha(alpha);
1039         }
1040     }
1041 
1042     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1043         if (getChildCount() &gt; 0) {
1044             return (ShortcutAndWidgetContainer) getChildAt(0);
1045         }
1046         return null;
1047     }
1048 
1049     public View getChildAt(int x, int y) {
1050         return mShortcutsAndWidgets.getChildAt(x, y);
1051     }
1052 
1053     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1054             int delay, boolean permanent, boolean adjustOccupied) {
1055         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1056         boolean[][] occupied = mOccupied;
1057         if (!permanent) {
1058             occupied = mTmpOccupied;
1059         }
1060 
1061         if (clc.indexOfChild(child) != -1) {
1062             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1063             final ItemInfo info = (ItemInfo) child.getTag();
1064 
1065             // We cancel any existing animations
1066             if (mReorderAnimators.containsKey(lp)) {
1067                 mReorderAnimators.get(lp).cancel();
1068                 mReorderAnimators.remove(lp);
1069             }
1070 
1071             final int oldX = lp.x;
1072             final int oldY = lp.y;
1073             if (adjustOccupied) {
1074                 occupied[lp.cellX][lp.cellY] = false;
1075                 occupied[cellX][cellY] = true;
1076             }
1077             lp.isLockedToGrid = true;
1078             if (permanent) {
1079                 lp.cellX = info.cellX = cellX;
1080                 lp.cellY = info.cellY = cellY;
1081             } else {
1082                 lp.tmpCellX = cellX;
1083                 lp.tmpCellY = cellY;
1084             }
1085             clc.setupLp(lp);
1086             lp.isLockedToGrid = false;
1087             final int newX = lp.x;
1088             final int newY = lp.y;
1089 
1090             lp.x = oldX;
1091             lp.y = oldY;
1092 
1093             // Exit early if we&#x27;re not actually moving the view
1094             if (oldX == newX &amp;&amp; oldY == newY) {
1095                 lp.isLockedToGrid = true;
1096                 return true;
1097             }
1098 
1099             ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);
1100             va.setDuration(duration);
1101             mReorderAnimators.put(lp, va);
1102 
1103             va.addUpdateListener(new AnimatorUpdateListener() {
1104                 @Override
1105                 public void onAnimationUpdate(ValueAnimator animation) {
1106                     float r = ((Float) animation.getAnimatedValue()).floatValue();
1107                     lp.x = (int) ((1 - r) * oldX + r * newX);
1108                     lp.y = (int) ((1 - r) * oldY + r * newY);
1109                     child.requestLayout();
1110                 }
1111             });
1112             va.addListener(new AnimatorListenerAdapter() {
1113                 boolean cancelled = false;
1114                 public void onAnimationEnd(Animator animation) {
1115                     // If the animation was cancelled, it means that another animation
1116                     // has interrupted this one, and we don&#x27;t want to lock the item into
1117                     // place just yet.
1118                     if (!cancelled) {
1119                         lp.isLockedToGrid = true;
1120                         child.requestLayout();
1121                     }
1122                     if (mReorderAnimators.containsKey(lp)) {
1123                         mReorderAnimators.remove(lp);
1124                     }
1125                 }
1126                 public void onAnimationCancel(Animator animation) {
1127                     cancelled = true;
1128                 }
1129             });
1130             va.setStartDelay(delay);
1131             va.start();
1132             return true;
1133         }
1134         return false;
1135     }
1136 
1137     /**
1138      * Estimate where the top left cell of the dragged item will land if it is dropped.
1139      *
1140      * @param originX The X value of the top left corner of the item
1141      * @param originY The Y value of the top left corner of the item
1142      * @param spanX The number of horizontal cells that the item spans
1143      * @param spanY The number of vertical cells that the item spans
1144      * @param result The estimated drop cell X and Y.
1145      */
1146     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1147         final int countX = mCountX;
1148         final int countY = mCountY;
1149 
1150         // pointToCellRounded takes the top left of a cell but will pad that with
1151         // cellWidth/2 and cellHeight/2 when finding the matching cell
1152         pointToCellRounded(originX, originY, result);
1153 
1154         // If the item isn&#x27;t fully on this screen, snap to the edges
1155         int rightOverhang = result[0] + spanX - countX;
1156         if (rightOverhang &gt; 0) {
1157             result[0] -= rightOverhang; // Snap to right
1158         }
1159         result[0] = Math.max(0, result[0]); // Snap to left
1160         int bottomOverhang = result[1] + spanY - countY;
1161         if (bottomOverhang &gt; 0) {
1162             result[1] -= bottomOverhang; // Snap to bottom
1163         }
1164         result[1] = Math.max(0, result[1]); // Snap to top
1165     }
1166 
1167     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1168             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1169         final int oldDragCellX = mDragCell[0];
1170         final int oldDragCellY = mDragCell[1];
1171 
1172         if (v != null &amp;&amp; dragOffset == null) {
1173             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1174         } else {
1175             mDragCenter.set(originX, originY);
1176         }
1177 
1178         if (dragOutline == null &amp;&amp; v == null) {
1179             return;
1180         }
1181 
1182         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1183             mDragCell[0] = cellX;
1184             mDragCell[1] = cellY;
1185             // Find the top left corner of the rect the object will occupy
1186             final int[] topLeft = mTmpPoint;
1187             cellToPoint(cellX, cellY, topLeft);
1188 
1189             int left = topLeft[0];
1190             int top = topLeft[1];
1191 
1192             if (v != null &amp;&amp; dragOffset == null) {
1193                 // When drawing the drag outline, it did not account for margin offsets
1194                 // added by the view&#x27;s parent.
1195                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1196                 left += lp.leftMargin;
1197                 top += lp.topMargin;
1198 
1199                 // Offsets due to the size difference between the View and the dragOutline.
1200                 // There is a size difference to account for the outer blur, which may lie
1201                 // outside the bounds of the view.
1202                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1203                 // We center about the x axis
1204                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1205                         - dragOutline.getWidth()) / 2;
1206             } else {
1207                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1208                     // Center the drag region *horizontally* in the cell and apply a drag
1209                     // outline offset
1210                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1211                              - dragRegion.width()) / 2;
1212                     top += dragOffset.y;
1213                 } else {
1214                     // Center the drag outline in the cell
1215                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1216                             - dragOutline.getWidth()) / 2;
1217                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1218                             - dragOutline.getHeight()) / 2;
1219                 }
1220             }
1221             final int oldIndex = mDragOutlineCurrent;
1222             mDragOutlineAnims[oldIndex].animateOut();
1223             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1224             Rect r = mDragOutlines[mDragOutlineCurrent];
1225             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1226             if (resize) {
1227                 cellToRect(cellX, cellY, spanX, spanY, r);
1228             }
1229 
1230             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1231             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1232         }
1233     }
1234 
1235     public void clearDragOutlines() {
1236         final int oldIndex = mDragOutlineCurrent;
1237         mDragOutlineAnims[oldIndex].animateOut();
1238         mDragCell[0] = mDragCell[1] = -1;
1239     }
1240 
1241     /**
1242      * Find a vacant area that will fit the given bounds nearest the requested
1243      * cell location. Uses Euclidean distance to score multiple vacant areas.
1244      *
1245      * @param pixelX The X location at which you want to search for a vacant area.
1246      * @param pixelY The Y location at which you want to search for a vacant area.
1247      * @param spanX Horizontal span of the object.
1248      * @param spanY Vertical span of the object.
1249      * @param result Array in which to place the result, or null (in which case a new array will
1250      *        be allocated)
1251      * @return The X, Y cell of a vacant area that can contain this object,
1252      *         nearest the requested location.
1253      */
1254     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1255             int[] result) {
1256         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1257     }
1258 
1259     /**
1260      * Find a vacant area that will fit the given bounds nearest the requested
1261      * cell location. Uses Euclidean distance to score multiple vacant areas.
1262      *
1263      * @param pixelX The X location at which you want to search for a vacant area.
1264      * @param pixelY The Y location at which you want to search for a vacant area.
1265      * @param minSpanX The minimum horizontal span required
1266      * @param minSpanY The minimum vertical span required
1267      * @param spanX Horizontal span of the object.
1268      * @param spanY Vertical span of the object.
1269      * @param result Array in which to place the result, or null (in which case a new array will
1270      *        be allocated)
1271      * @return The X, Y cell of a vacant area that can contain this object,
1272      *         nearest the requested location.
1273      */
1274     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1275             int spanY, int[] result, int[] resultSpan) {
1276         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1277                 result, resultSpan);
1278     }
1279 
1280     /**
1281      * Find a vacant area that will fit the given bounds nearest the requested
1282      * cell location. Uses Euclidean distance to score multiple vacant areas.
1283      *
1284      * @param pixelX The X location at which you want to search for a vacant area.
1285      * @param pixelY The Y location at which you want to search for a vacant area.
1286      * @param spanX Horizontal span of the object.
1287      * @param spanY Vertical span of the object.
1288      * @param ignoreOccupied If true, the result can be an occupied cell
1289      * @param result Array in which to place the result, or null (in which case a new array will
1290      *        be allocated)
1291      * @return The X, Y cell of a vacant area that can contain this object,
1292      *         nearest the requested location.
1293      */
1294     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1295             boolean ignoreOccupied, int[] result) {
1296         return findNearestArea(pixelX, pixelY, spanX, spanY,
1297                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1298     }
1299 
1300     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1301     private void lazyInitTempRectStack() {
1302         if (mTempRectStack.isEmpty()) {
1303             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1304                 mTempRectStack.push(new Rect());
1305             }
1306         }
1307     }
1308 
1309     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1310         while (!used.isEmpty()) {
1311             mTempRectStack.push(used.pop());
1312         }
1313     }
1314 
1315     /**
1316      * Find a vacant area that will fit the given bounds nearest the requested
1317      * cell location. Uses Euclidean distance to score multiple vacant areas.
1318      *
1319      * @param pixelX The X location at which you want to search for a vacant area.
1320      * @param pixelY The Y location at which you want to search for a vacant area.
1321      * @param minSpanX The minimum horizontal span required
1322      * @param minSpanY The minimum vertical span required
1323      * @param spanX Horizontal span of the object.
1324      * @param spanY Vertical span of the object.
1325      * @param ignoreOccupied If true, the result can be an occupied cell
1326      * @param result Array in which to place the result, or null (in which case a new array will
1327      *        be allocated)
1328      * @return The X, Y cell of a vacant area that can contain this object,
1329      *         nearest the requested location.
1330      */
1331     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1332             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1333             boolean[][] occupied) {
1334         lazyInitTempRectStack();
1335         // mark space take by ignoreView as available (method checks if ignoreView is null)
1336         markCellsAsUnoccupiedForView(ignoreView, occupied);
1337 
1338         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1339         // to the center of the item, but we are searching based on the top-left cell, so
1340         // we translate the point over to correspond to the top-left.
1341         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1342         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1343 
1344         // Keep track of best-scoring drop area
1345         final int[] bestXY = result != null ? result : new int[2];
1346         double bestDistance = Double.MAX_VALUE;
1347         final Rect bestRect = new Rect(-1, -1, -1, -1);
1348         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1349 
1350         final int countX = mCountX;
1351         final int countY = mCountY;
1352 
1353         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1354                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1355             return bestXY;
1356         }
1357 
1358         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1359             inner:
1360             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1361                 int ySize = -1;
1362                 int xSize = -1;
1363                 if (ignoreOccupied) {
1364                     // First, let&#x27;s see if this thing fits anywhere
1365                     for (int i = 0; i &lt; minSpanX; i++) {
1366                         for (int j = 0; j &lt; minSpanY; j++) {
1367                             if (occupied[x + i][y + j]) {
1368                                 continue inner;
1369                             }
1370                         }
1371                     }
1372                     xSize = minSpanX;
1373                     ySize = minSpanY;
1374 
1375                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1376                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1377                     // until we hit a limit.
1378                     boolean incX = true;
1379                     boolean hitMaxX = xSize &gt;= spanX;
1380                     boolean hitMaxY = ySize &gt;= spanY;
1381                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1382                         if (incX &amp;&amp; !hitMaxX) {
1383                             for (int j = 0; j &lt; ySize; j++) {
1384                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1385                                     // We can&#x27;t move out horizontally
1386                                     hitMaxX = true;
1387                                 }
1388                             }
1389                             if (!hitMaxX) {
1390                                 xSize++;
1391                             }
1392                         } else if (!hitMaxY) {
1393                             for (int i = 0; i &lt; xSize; i++) {
1394                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1395                                     // We can&#x27;t move out vertically
1396                                     hitMaxY = true;
1397                                 }
1398                             }
1399                             if (!hitMaxY) {
1400                                 ySize++;
1401                             }
1402                         }
1403                         hitMaxX |= xSize &gt;= spanX;
1404                         hitMaxY |= ySize &gt;= spanY;
1405                         incX = !incX;
1406                     }
1407                     incX = true;
1408                     hitMaxX = xSize &gt;= spanX;
1409                     hitMaxY = ySize &gt;= spanY;
1410                 }
1411                 final int[] cellXY = mTmpXY;
1412                 cellToCenterPoint(x, y, cellXY);
1413 
1414                 // We verify that the current rect is not a sub-rect of any of our previous
1415                 // candidates. In this case, the current rect is disqualified in favour of the
1416                 // containing rect.
1417                 Rect currentRect = mTempRectStack.pop();
1418                 currentRect.set(x, y, x + xSize, y + ySize);
1419                 boolean contained = false;
1420                 for (Rect r : validRegions) {
1421                     if (r.contains(currentRect)) {
1422                         contained = true;
1423                         break;
1424                     }
1425                 }
1426                 validRegions.push(currentRect);
1427                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1428                         + Math.pow(cellXY[1] - pixelY, 2));
1429 
1430                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1431                         currentRect.contains(bestRect)) {
1432                     bestDistance = distance;
1433                     bestXY[0] = x;
1434                     bestXY[1] = y;
1435                     if (resultSpan != null) {
1436                         resultSpan[0] = xSize;
1437                         resultSpan[1] = ySize;
1438                     }
1439                     bestRect.set(currentRect);
1440                 }
1441             }
1442         }
1443         // re-mark space taken by ignoreView as occupied
1444         markCellsAsOccupiedForView(ignoreView, occupied);
1445 
1446         // Return -1, -1 if no suitable location found
1447         if (bestDistance == Double.MAX_VALUE) {
1448             bestXY[0] = -1;
1449             bestXY[1] = -1;
1450         }
1451         recycleTempRects(validRegions);
1452         return bestXY;
1453     }
1454 
1455      /**
1456      * Find a vacant area that will fit the given bounds nearest the requested
1457      * cell location, and will also weigh in a suggested direction vector of the
1458      * desired location. This method computers distance based on unit grid distances,
1459      * not pixel distances.
1460      *
1461      * @param cellX The X cell nearest to which you want to search for a vacant area.
1462      * @param cellY The Y cell nearest which you want to search for a vacant area.
1463      * @param spanX Horizontal span of the object.
1464      * @param spanY Vertical span of the object.
1465      * @param direction The favored direction in which the views should move from x, y
1466      * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1467      *        matches exactly. Otherwise we find the best matching direction.
1468      * @param occoupied The array which represents which cells in the CellLayout are occupied
1469      * @param blockOccupied The array which represents which cells in the specified block (cellX,
1470      *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.
1471      * @param result Array in which to place the result, or null (in which case a new array will
1472      *        be allocated)
1473      * @return The X, Y cell of a vacant area that can contain this object,
1474      *         nearest the requested location.
1475      */
1476     private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1477             boolean[][] occupied, boolean blockOccupied[][], int[] result) {
1478         // Keep track of best-scoring drop area
1479         final int[] bestXY = result != null ? result : new int[2];
1480         float bestDistance = Float.MAX_VALUE;
1481         int bestDirectionScore = Integer.MIN_VALUE;
1482 
1483         final int countX = mCountX;
1484         final int countY = mCountY;
1485 
1486         for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1487             inner:
1488             for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1489                 // First, let&#x27;s see if this thing fits anywhere
1490                 for (int i = 0; i &lt; spanX; i++) {
1491                     for (int j = 0; j &lt; spanY; j++) {
1492                         if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1493                             continue inner;
1494                         }
1495                     }
1496                 }
1497 
1498                 float distance = (float)
1499                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1500                 int[] curDirection = mTmpPoint;
1501                 computeDirectionVector(x - cellX, y - cellY, curDirection);
1502                 // The direction score is just the dot product of the two candidate direction
1503                 // and that passed in.
1504                 int curDirectionScore = direction[0] * curDirection[0] +
1505                         direction[1] * curDirection[1];
1506                 boolean exactDirectionOnly = false;
1507                 boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1508                         direction[0] == curDirection[0];
1509                 if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1510                         Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1511                         bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1512                     bestDistance = distance;
1513                     bestDirectionScore = curDirectionScore;
1514                     bestXY[0] = x;
1515                     bestXY[1] = y;
1516                 }
1517             }
1518         }
1519 
1520         // Return -1, -1 if no suitable location found
1521         if (bestDistance == Float.MAX_VALUE) {
1522             bestXY[0] = -1;
1523             bestXY[1] = -1;
1524         }
1525         return bestXY;
1526     }
1527 
1528     private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,
1529             int[] direction,boolean[][] occupied,
1530             boolean blockOccupied[][], int[] result) {
1531         // Keep track of best-scoring drop area
1532         final int[] bestXY = result != null ? result : new int[2];
1533         bestXY[0] = -1;
1534         bestXY[1] = -1;
1535         float bestDistance = Float.MAX_VALUE;
1536 
1537         // We use this to march in a single direction
1538         if ((direction[0] != 0 &amp;&amp; direction[1] != 0) ||
1539                 (direction[0] == 0 &amp;&amp; direction[1] == 0)) {
1540             return bestXY;
1541         }
1542 
1543         // This will only incrememnet one of x or y based on the assertion above
1544         int x = cellX + direction[0];
1545         int y = cellY + direction[1];
1546         while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
1547             boolean fail = false;
1548             for (int i = 0; i &lt; spanX; i++) {
1549                 for (int j = 0; j &lt; spanY; j++) {
1550                     if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1551                         fail = true;
1552                     }
1553                 }
1554             }
1555             if (!fail) {
1556                 float distance = (float)
1557                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1558                 if (Float.compare(distance,  bestDistance) &lt; 0) {
1559                     bestDistance = distance;
1560                     bestXY[0] = x;
1561                     bestXY[1] = y;
1562                 }
1563             }
1564             x += direction[0];
1565             y += direction[1];
1566         }
1567         return bestXY;
1568     }
1569 
1570     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1571             int[] direction, ItemConfiguration currentState) {
1572         CellAndSpan c = currentState.map.get(v);
1573         boolean success = false;
1574         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1575         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1576 
1577         findNearestArea(c.x, c.y, c.spanX, c.spanY, direction, mTmpOccupied, null, mTempLocation);
1578 
1579         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1580             c.x = mTempLocation[0];
1581             c.y = mTempLocation[1];
1582             success = true;
1583 
1584         }
1585         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1586         return success;
1587     }
1588 
1589     // This method looks in the specified direction to see if there are additional views adjacent
1590     // to the current set of views in the. If there is, then these views are added to the current
1591     // set of views. This is performed iteratively, giving a cascading push behaviour.
1592     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,
1593             boolean[][] occupied, View dragView, ItemConfiguration currentState) {
1594         boolean found = false;
1595 
1596         int childCount = mShortcutsAndWidgets.getChildCount();
1597         Rect r0 = new Rect(boundingRect);
1598         Rect r1 = new Rect();
1599 
1600         // First, we consider the rect of the views that we are trying to translate
1601         int deltaX = 0;
1602         int deltaY = 0;
1603         if (direction[1] &lt; 0) {
1604             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom - 1);
1605             deltaY = -1;
1606         } else if (direction[1] &gt; 0) {
1607             r0.set(r0.left, r0.top + 1, r0.right, r0.bottom + 1);
1608             deltaY = 1;
1609         } else if (direction[0] &lt; 0) {
1610             r0.set(r0.left - 1, r0.top, r0.right - 1, r0.bottom);
1611             deltaX = -1;
1612         } else if (direction[0] &gt; 0) {
1613             r0.set(r0.left + 1, r0.top, r0.right + 1, r0.bottom);
1614             deltaX = 1;
1615         }
1616 
1617         // Now we see which views, if any, are being overlapped by shifting the current group
1618         // of views in the desired direction.
1619         for (int i = 0; i &lt; childCount; i++) {
1620             // We don&#x27;t need to worry about views already in our group, or the current drag view.
1621             View child = mShortcutsAndWidgets.getChildAt(i);
1622             if (views.contains(child) || child == dragView) continue;
1623             CellAndSpan c = currentState.map.get(child);
1624 
1625             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1626             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1627             if (Rect.intersects(r0, r1)) {
1628                 if (!lp.canReorder) {
1629                     return false;
1630                 }
1631                 // First we verify that the view in question is at the border of the extents
1632                 // of the block of items we are pushing
1633                 if ((direction[0] &lt; 0 &amp;&amp; c.x == r0.left) ||
1634                         (direction[0] &gt; 0 &amp;&amp; c.x == r0.right - 1) ||
1635                         (direction[1] &lt; 0 &amp;&amp; c.y == r0.top) ||
1636                         (direction[1] &gt; 0 &amp;&amp; c.y == r0.bottom - 1)) {
1637                 boolean pushed = false;
1638                     // Since the bounding rect is a course description of the region (there can
1639                     // be holes at the edge of the block), we need to check to verify that a solid
1640                     // piece is intersecting. This ensures that interlocking is possible.
1641                 for (int x = c.x; x &lt; c.x + c.spanX; x++) {
1642                     for (int y = c.y; y &lt; c.y + c.spanY; y++) {
1643                             if (occupied[x - deltaX][y - deltaY]) {
1644                             pushed = true;
1645                                 break;
1646                         }
1647                             if (pushed) break;
1648                     }
1649                 }
1650                 if (pushed) {
1651                     views.add(child);
1652                     boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1653                     found = true;
1654                 }
1655             }
1656         }
1657         }
1658         return found;
1659     }
1660 
1661     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1662             int[] direction, boolean push, View dragView, ItemConfiguration currentState) {
1663         if (views.size() == 0) return true;
1664 
1665         boolean success = false;
1666         Rect boundingRect = null;
1667         // We construct a rect which represents the entire group of views passed in
1668         for (View v: views) {
1669             CellAndSpan c = currentState.map.get(v);
1670             if (boundingRect == null) {
1671                 boundingRect = new Rect(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1672             } else {
1673                 boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1674             }
1675         }
1676 
1677         @SuppressWarnings(&quot;unchecked&quot;)
1678         ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();
1679         // We try and expand the group of views in the direction vector passed, based on
1680         // whether they are physically adjacent, ie. based on &quot;push mechanics&quot;.
1681         while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView,
1682                 currentState)) {
1683         }
1684 
1685         // Mark the occupied state as false for the group of views we want to move.
1686         for (View v: dup) {
1687             CellAndSpan c = currentState.map.get(v);
1688             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1689         }
1690 
1691         boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1692         int top = boundingRect.top;
1693         int left = boundingRect.left;
1694         // We mark more precisely which parts of the bounding rect are truly occupied, allowing
1695         // for interlocking.
1696         for (View v: dup) {
1697             CellAndSpan c = currentState.map.get(v);
1698             markCellsForView(c.x - left, c.y - top, c.spanX, c.spanY, blockOccupied, true);
1699         }
1700 
1701         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1702 
1703         if (push) {
1704             findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),
1705                     boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1706         } else {
1707             findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),
1708                     boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1709         }
1710 
1711         // If we successfuly found a location by pushing the block of views, we commit it
1712         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1713             int deltaX = mTempLocation[0] - boundingRect.left;
1714             int deltaY = mTempLocation[1] - boundingRect.top;
1715             for (View v: dup) {
1716                 CellAndSpan c = currentState.map.get(v);
1717                 c.x += deltaX;
1718                 c.y += deltaY;
1719             }
1720             success = true;
1721         }
1722 
1723         // In either case, we set the occupied array as marked for the location of the views
1724         for (View v: dup) {
1725             CellAndSpan c = currentState.map.get(v);
1726             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1727         }
1728         return success;
1729     }
1730 
1731     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1732         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1733     }
1734 
1735     // This method tries to find a reordering solution which satisfies the push mechanic by trying
1736     // to push items in each of the cardinal directions, in an order based on the direction vector
1737     // passed.
1738     private boolean attemptPushInDirection(ArrayList&lt;View&gt; intersectingViews, Rect occupied,
1739             int[] direction, View ignoreView, ItemConfiguration solution) {
1740         if ((Math.abs(direction[0]) + Math.abs(direction[1])) &gt; 1) {
1741             // If the direction vector has two non-zero components, we try pushing
1742             // separately in each of the components.
1743             int temp = direction[1];
1744             direction[1] = 0;
1745             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1746                     ignoreView, solution)) {
1747                 return true;
1748             }
1749             direction[1] = temp;
1750             temp = direction[0];
1751             direction[0] = 0;
1752             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1753                     ignoreView, solution)) {
1754                 return true;
1755             }
1756             // Revert the direction
1757             direction[0] = temp;
1758 
1759             // Now we try pushing in each component of the opposite direction
1760             direction[0] *= -1;
1761             direction[1] *= -1;
1762             temp = direction[1];
1763             direction[1] = 0;
1764             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1765                     ignoreView, solution)) {
1766                 return true;
1767             }
1768 
1769             direction[1] = temp;
1770             temp = direction[0];
1771             direction[0] = 0;
1772             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1773                     ignoreView, solution)) {
1774                 return true;
1775             }
1776             // revert the direction
1777             direction[0] = temp;
1778             direction[0] *= -1;
1779             direction[1] *= -1;
1780 
1781         } else {
1782             // If the direction vector has a single non-zero component, we push first in the
1783             // direction of the vector
1784             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1785                     ignoreView, solution)) {
1786                 return true;
1787             }
1788 
1789             // Then we try the opposite direction
1790             direction[0] *= -1;
1791             direction[1] *= -1;
1792             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1793                     ignoreView, solution)) {
1794                 return true;
1795             }
1796             // Switch the direction back
1797             direction[0] *= -1;
1798             direction[1] *= -1;
1799 
1800             // If we have failed to find a push solution with the above, then we try
1801             // to find a solution by pushing along the perpendicular axis.
1802 
1803             // Swap the components
1804             int temp = direction[1];
1805             direction[1] = direction[0];
1806             direction[0] = temp;
1807             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1808                     ignoreView, solution)) {
1809                 return true;
1810             }
1811 
1812             // Then we try the opposite direction
1813             direction[0] *= -1;
1814             direction[1] *= -1;
1815             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1816                     ignoreView, solution)) {
1817                 return true;
1818             }
1819             // Switch the direction back
1820             direction[0] *= -1;
1821             direction[1] *= -1;
1822 
1823             // Swap the components back
1824             temp = direction[1];
1825             direction[1] = direction[0];
1826             direction[0] = temp;
1827         }
1828         return false;
1829     }
1830 
1831     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1832             View ignoreView, ItemConfiguration solution) {
1833         // Return early if get invalid cell positions
1834         if (cellX &lt; 0 || cellY &lt; 0) return false;
1835 
1836         mIntersectingViews.clear();
1837         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1838 
1839         // Mark the desired location of the view currently being dragged.
1840         if (ignoreView != null) {
1841             CellAndSpan c = solution.map.get(ignoreView);
1842             if (c != null) {
1843                 c.x = cellX;
1844                 c.y = cellY;
1845             }
1846         }
1847         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1848         Rect r1 = new Rect();
1849         for (View child: solution.map.keySet()) {
1850             if (child == ignoreView) continue;
1851             CellAndSpan c = solution.map.get(child);
1852             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1853             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1854             if (Rect.intersects(r0, r1)) {
1855                 if (!lp.canReorder) {
1856                     return false;
1857                 }
1858                 mIntersectingViews.add(child);
1859             }
1860         }
1861 
1862         // First we try to find a solution which respects the push mechanic. That is,
1863         // we try to find a solution such that no displaced item travels through another item
1864         // without also displacing that item.
1865         if (attemptPushInDirection(mIntersectingViews, mOccupiedRect, direction, ignoreView,
1866                 solution)) {
1867             return true;
1868         }
1869 
1870         // Next we try moving the views as a block, but without requiring the push mechanic.
1871         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction, false, ignoreView,
1872                 solution)) {
1873             return true;
1874         }
1875 
1876         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1877         for (View v : mIntersectingViews) {
1878             if (!addViewToTempLocation(v, mOccupiedRect, direction, solution)) {
1879                 return false;
1880             }
1881         }
1882         return true;
1883     }
1884 
1885     /*
1886      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1887      * the provided point and the provided cell
1888      */
1889     private void computeDirectionVector(float deltaX, float deltaY, int[] result) {
1890         double angle = Math.atan(((float) deltaY) / deltaX);
1891 
1892         result[0] = 0;
1893         result[1] = 0;
1894         if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1895             result[0] = (int) Math.signum(deltaX);
1896         }
1897         if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1898             result[1] = (int) Math.signum(deltaY);
1899         }
1900     }
1901 
1902     private void copyOccupiedArray(boolean[][] occupied) {
1903         for (int i = 0; i &lt; mCountX; i++) {
1904             for (int j = 0; j &lt; mCountY; j++) {
1905                 occupied[i][j] = mOccupied[i][j];
1906             }
1907         }
1908     }
1909 
1910     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1911             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1912         // Copy the current state into the solution. This solution will be manipulated as necessary.
1913         copyCurrentStateToSolution(solution, false);
1914         // Copy the current occupied array into the temporary occupied array. This array will be
1915         // manipulated as necessary to find a solution.
1916         copyOccupiedArray(mTmpOccupied);
1917 
1918         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1919         // nothing in its way.
1920         int result[] = new int[2];
1921         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1922 
1923         boolean success = false;
1924         // First we try the exact nearest position of the item being dragged,
1925         // we will then want to try to move this around to other neighbouring positions
1926         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView,
1927                 solution);
1928 
1929         if (!success) {
1930             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1931             // x, then 1 in y etc.
1932             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1933                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1934                         dragView, false, solution);
1935             } else if (spanY &gt; minSpanY) {
1936                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1937                         dragView, true, solution);
1938             }
1939             solution.isSolution = false;
1940         } else {
1941             solution.isSolution = true;
1942             solution.dragViewX = result[0];
1943             solution.dragViewY = result[1];
1944             solution.dragViewSpanX = spanX;
1945             solution.dragViewSpanY = spanY;
1946         }
1947         return solution;
1948     }
1949 
1950     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1951         int childCount = mShortcutsAndWidgets.getChildCount();
1952         for (int i = 0; i &lt; childCount; i++) {
1953             View child = mShortcutsAndWidgets.getChildAt(i);
1954             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1955             CellAndSpan c;
1956             if (temp) {
1957                 c = new CellAndSpan(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan);
1958             } else {
1959                 c = new CellAndSpan(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan);
1960             }
1961             solution.map.put(child, c);
1962         }
1963     }
1964 
1965     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1966         for (int i = 0; i &lt; mCountX; i++) {
1967             for (int j = 0; j &lt; mCountY; j++) {
1968                 mTmpOccupied[i][j] = false;
1969             }
1970         }
1971 
1972         int childCount = mShortcutsAndWidgets.getChildCount();
1973         for (int i = 0; i &lt; childCount; i++) {
1974             View child = mShortcutsAndWidgets.getChildAt(i);
1975             if (child == dragView) continue;
1976             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1977             CellAndSpan c = solution.map.get(child);
1978             if (c != null) {
1979                 lp.tmpCellX = c.x;
1980                 lp.tmpCellY = c.y;
1981                 lp.cellHSpan = c.spanX;
1982                 lp.cellVSpan = c.spanY;
1983                 markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1984             }
1985         }
1986         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1987                 solution.dragViewSpanY, mTmpOccupied, true);
1988     }
1989 
1990     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1991             commitDragView) {
1992 
1993         boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1994         for (int i = 0; i &lt; mCountX; i++) {
1995             for (int j = 0; j &lt; mCountY; j++) {
1996                 occupied[i][j] = false;
1997             }
1998         }
1999 
2000         int childCount = mShortcutsAndWidgets.getChildCount();
2001         for (int i = 0; i &lt; childCount; i++) {
2002             View child = mShortcutsAndWidgets.getChildAt(i);
2003             if (child == dragView) continue;
2004             CellAndSpan c = solution.map.get(child);
2005             if (c != null) {
2006                 animateChildToPosition(child, c.x, c.y, REORDER_ANIMATION_DURATION, 0,
2007                         DESTRUCTIVE_REORDER, false);
2008                 markCellsForView(c.x, c.y, c.spanX, c.spanY, occupied, true);
2009             }
2010         }
2011         if (commitDragView) {
2012             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2013                     solution.dragViewSpanY, occupied, true);
2014         }
2015     }
2016 
2017     // This method starts or changes the reorder hint animations
2018     private void beginOrAdjustHintAnimations(ItemConfiguration solution, View dragView, int delay) {
2019         int childCount = mShortcutsAndWidgets.getChildCount();
2020         for (int i = 0; i &lt; childCount; i++) {
2021             View child = mShortcutsAndWidgets.getChildAt(i);
2022             if (child == dragView) continue;
2023             CellAndSpan c = solution.map.get(child);
2024             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2025             if (c != null) {
2026                 ReorderHintAnimation rha = new ReorderHintAnimation(child, lp.cellX, lp.cellY,
2027                         c.x, c.y, c.spanX, c.spanY);
2028                 rha.animate();
2029             }
2030         }
2031     }
2032 
2033     // Class which represents the reorder hint animations. These animations show that an item is
2034     // in a temporary state, and hint at where the item will return to.
2035 
2036 
2037     // Class which represents the reorder hint animations. These animations show that an item is
2038     // in a temporary state, and hint at where the item will return to.
2039     class ReorderHintAnimation {
2040         View child;
2041         float finalDeltaX;
2042         float finalDeltaY;
2043         float initDeltaX;
2044         float initDeltaY;
2045         float finalScale;
2046         float initScale;
2047         private static final int DURATION = 300;
2048         Animator a;
2049 
2050         public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1,
2051                 int spanX, int spanY) {
2052             regionToCenterPoint(cellX0, cellY0, spanX, spanY, mTmpPoint);
2053             final int x0 = mTmpPoint[0];
2054             final int y0 = mTmpPoint[1];
2055             regionToCenterPoint(cellX1, cellY1, spanX, spanY, mTmpPoint);
2056             final int x1 = mTmpPoint[0];
2057             final int y1 = mTmpPoint[1];
2058             final int dX = x1 - x0;
2059             final int dY = y1 - y0;
2060             finalDeltaX = 0;
2061             finalDeltaY = 0;
2062             if (dX == dY &amp;&amp; dX == 0) {
2063             } else {
2064                 if (dY == 0) {
2065                     finalDeltaX = - Math.signum(dX) * mReorderHintAnimationMagnitude;
2066                 } else if (dX == 0) {
2067                     finalDeltaY = - Math.signum(dY) * mReorderHintAnimationMagnitude;
2068                 } else {
2069                     double angle = Math.atan( (float) (dY) / dX);
2070                     finalDeltaX = (int) (- Math.signum(dX) *
2071                             Math.abs(Math.cos(angle) * mReorderHintAnimationMagnitude));
2072                     finalDeltaY = (int) (- Math.signum(dY) *
2073                             Math.abs(Math.sin(angle) * mReorderHintAnimationMagnitude));
2074                 }
2075             }
2076             initDeltaX = child.getTranslationX();
2077             initDeltaY = child.getTranslationY();
2078             finalScale = 1.0f - 4.0f / child.getWidth();
2079             initScale = child.getScaleX();
2080 
2081             child.setPivotY(child.getMeasuredHeight() * 0.5f);
2082             child.setPivotX(child.getMeasuredWidth() * 0.5f);
2083             this.child = child;
2084         }
2085 
2086         void animate() {
2087             if (mShakeAnimators.containsKey(child)) {
2088                 ReorderHintAnimation oldAnimation = mShakeAnimators.get(child);
2089                 oldAnimation.cancel();
2090                 mShakeAnimators.remove(child);
2091                 if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2092                     completeAnimationImmediately();
2093                     return;
2094                 }
2095             }
2096             if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2097                 return;
2098             }
2099             ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);
2100             a = va;
2101             va.setRepeatMode(ValueAnimator.REVERSE);
2102             va.setRepeatCount(ValueAnimator.INFINITE);
2103             va.setDuration(DURATION);
2104             va.setStartDelay((int) (Math.random() * 60));
2105             va.addUpdateListener(new AnimatorUpdateListener() {
2106                 @Override
2107                 public void onAnimationUpdate(ValueAnimator animation) {
2108                     float r = ((Float) animation.getAnimatedValue()).floatValue();
2109                     float x = r * finalDeltaX + (1 - r) * initDeltaX;
2110                     float y = r * finalDeltaY + (1 - r) * initDeltaY;
2111                     child.setTranslationX(x);
2112                     child.setTranslationY(y);
2113                     float s = r * finalScale + (1 - r) * initScale;
2114                     child.setScaleX(s);
2115                     child.setScaleY(s);
2116                 }
2117             });
2118             va.addListener(new AnimatorListenerAdapter() {
2119                 public void onAnimationRepeat(Animator animation) {
2120                     // We make sure to end only after a full period
2121                     initDeltaX = 0;
2122                     initDeltaY = 0;
2123                     initScale = 1.0f;
2124                 }
2125             });
2126             mShakeAnimators.put(child, this);
2127             va.start();
2128         }
2129 
2130         private void cancel() {
2131             if (a != null) {
2132                 a.cancel();
2133             }
2134         }
2135 
2136         private void completeAnimationImmediately() {
2137             if (a != null) {
2138                 a.cancel();
2139             }
2140 
2141             AnimatorSet s = LauncherAnimUtils.createAnimatorSet();
2142             a = s;
2143             s.playTogether(
2144                 LauncherAnimUtils.ofFloat(child, &quot;scaleX&quot;, 1f),
2145                 LauncherAnimUtils.ofFloat(child, &quot;scaleY&quot;, 1f),
2146                 LauncherAnimUtils.ofFloat(child, &quot;translationX&quot;, 0f),
2147                 LauncherAnimUtils.ofFloat(child, &quot;translationY&quot;, 0f)
2148             );
2149             s.setDuration(REORDER_ANIMATION_DURATION);
2150             s.setInterpolator(new android.view.animation.DecelerateInterpolator(1.5f));
2151             s.start();
2152         }
2153     }
2154 
2155     private void completeAndClearReorderHintAnimations() {
2156         for (ReorderHintAnimation a: mShakeAnimators.values()) {
2157             a.completeAnimationImmediately();
2158         }
2159         mShakeAnimators.clear();
2160     }
2161 
2162     private void commitTempPlacement() {
2163         for (int i = 0; i &lt; mCountX; i++) {
2164             for (int j = 0; j &lt; mCountY; j++) {
2165                 mOccupied[i][j] = mTmpOccupied[i][j];
2166             }
2167         }
2168         int childCount = mShortcutsAndWidgets.getChildCount();
2169         for (int i = 0; i &lt; childCount; i++) {
2170             View child = mShortcutsAndWidgets.getChildAt(i);
2171             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2172             ItemInfo info = (ItemInfo) child.getTag();
2173             // We do a null check here because the item info can be null in the case of the
2174             // AllApps button in the hotseat.
2175             if (info != null) {
2176                 if (info.cellX != lp.tmpCellX || info.cellY != lp.tmpCellY ||
2177                         info.spanX != lp.cellHSpan || info.spanY != lp.cellVSpan) {
2178                     info.requiresDbUpdate = true;
2179                 }
2180                 info.cellX = lp.cellX = lp.tmpCellX;
2181                 info.cellY = lp.cellY = lp.tmpCellY;
2182                 info.spanX = lp.cellHSpan;
2183                 info.spanY = lp.cellVSpan;
2184             }
2185         }
2186         mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
2187     }
2188 
2189     public void setUseTempCoords(boolean useTempCoords) {
2190         int childCount = mShortcutsAndWidgets.getChildCount();
2191         for (int i = 0; i &lt; childCount; i++) {
2192             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2193             lp.useTmpCoords = useTempCoords;
2194         }
2195     }
2196 
2197     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2198             int spanX, int spanY, View dragView, ItemConfiguration solution) {
2199         int[] result = new int[2];
2200         int[] resultSpan = new int[2];
2201         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2202                 resultSpan);
2203         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2204             copyCurrentStateToSolution(solution, false);
2205             solution.dragViewX = result[0];
2206             solution.dragViewY = result[1];
2207             solution.dragViewSpanX = resultSpan[0];
2208             solution.dragViewSpanY = resultSpan[1];
2209             solution.isSolution = true;
2210         } else {
2211             solution.isSolution = false;
2212         }
2213         return solution;
2214     }
2215 
2216     public void prepareChildForDrag(View child) {
2217         markCellsAsUnoccupiedForView(child);
2218     }
2219 
2220     /* This seems like it should be obvious and straight-forward, but when the direction vector
2221     needs to match with the notion of the dragView pushing other views, we have to employ
2222     a slightly more subtle notion of the direction vector. The question is what two points is
2223     the vector between? The center of the dragView and its desired destination? Not quite, as
2224     this doesn&#x27;t necessarily coincide with the interaction of the dragView and items occupying
2225     those cells. Instead we use some heuristics to often lock the vector to up, down, left
2226     or right, which helps make pushing feel right.
2227     */
2228     private void getDirectionVectorForDrop(int dragViewCenterX, int dragViewCenterY, int spanX,
2229             int spanY, View dragView, int[] resultDirection) {
2230         int[] targetDestination = new int[2];
2231 
2232         findNearestArea(dragViewCenterX, dragViewCenterY, spanX, spanY, targetDestination);
2233         Rect dragRect = new Rect();
2234         regionToRect(targetDestination[0], targetDestination[1], spanX, spanY, dragRect);
2235         dragRect.offset(dragViewCenterX - dragRect.centerX(), dragViewCenterY - dragRect.centerY());
2236 
2237         Rect dropRegionRect = new Rect();
2238         getViewsIntersectingRegion(targetDestination[0], targetDestination[1], spanX, spanY,
2239                 dragView, dropRegionRect, mIntersectingViews);
2240 
2241         int dropRegionSpanX = dropRegionRect.width();
2242         int dropRegionSpanY = dropRegionRect.height();
2243 
2244         regionToRect(dropRegionRect.left, dropRegionRect.top, dropRegionRect.width(),
2245                 dropRegionRect.height(), dropRegionRect);
2246 
2247         int deltaX = (dropRegionRect.centerX() - dragViewCenterX) / spanX;
2248         int deltaY = (dropRegionRect.centerY() - dragViewCenterY) / spanY;
2249 
2250         if (dropRegionSpanX == mCountX || spanX == mCountX) {
2251             deltaX = 0;
2252         }
2253         if (dropRegionSpanY == mCountY || spanY == mCountY) {
2254             deltaY = 0;
2255         }
2256 
2257         if (deltaX == 0 &amp;&amp; deltaY == 0) {
2258             // No idea what to do, give a random direction.
2259             resultDirection[0] = 1;
2260             resultDirection[1] = 0;
2261         } else {
2262             computeDirectionVector(deltaX, deltaY, resultDirection);
2263         }
2264     }
2265 
2266     // For a given cell and span, fetch the set of views intersecting the region.
2267     private void getViewsIntersectingRegion(int cellX, int cellY, int spanX, int spanY,
2268             View dragView, Rect boundingRect, ArrayList&lt;View&gt; intersectingViews) {
2269         if (boundingRect != null) {
2270             boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
2271         }
2272         intersectingViews.clear();
2273         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
2274         Rect r1 = new Rect();
2275         final int count = mShortcutsAndWidgets.getChildCount();
2276         for (int i = 0; i &lt; count; i++) {
2277             View child = mShortcutsAndWidgets.getChildAt(i);
2278             if (child == dragView) continue;
2279             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2280             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
2281             if (Rect.intersects(r0, r1)) {
2282                 mIntersectingViews.add(child);
2283                 if (boundingRect != null) {
2284                     boundingRect.union(r1);
2285                 }
2286             }
2287         }
2288     }
2289 
2290     boolean isNearestDropLocationOccupied(int pixelX, int pixelY, int spanX, int spanY,
2291             View dragView, int[] result) {
2292         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2293         getViewsIntersectingRegion(result[0], result[1], spanX, spanY, dragView, null,
2294                 mIntersectingViews);
2295         return !mIntersectingViews.isEmpty();
2296     }
2297 
2298     void revertTempState() {
2299         if (!isItemPlacementDirty() || DESTRUCTIVE_REORDER) return;
2300         final int count = mShortcutsAndWidgets.getChildCount();
2301         for (int i = 0; i &lt; count; i++) {
2302             View child = mShortcutsAndWidgets.getChildAt(i);
2303             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2304             if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
2305                 lp.tmpCellX = lp.cellX;
2306                 lp.tmpCellY = lp.cellY;
2307                 animateChildToPosition(child, lp.cellX, lp.cellY, REORDER_ANIMATION_DURATION,
2308                         0, false, false);
2309             }
2310         }
2311         completeAndClearReorderHintAnimations();
2312         setItemPlacementDirty(false);
2313     }
2314 
2315     boolean createAreaForResize(int cellX, int cellY, int spanX, int spanY,
2316             View dragView, int[] direction, boolean commit) {
2317         int[] pixelXY = new int[2];
2318         regionToCenterPoint(cellX, cellY, spanX, spanY, pixelXY);
2319 
2320         // First we determine if things have moved enough to cause a different layout
2321         ItemConfiguration swapSolution = simpleSwap(pixelXY[0], pixelXY[1], spanX, spanY,
2322                  spanX,  spanY, direction, dragView,  true,  new ItemConfiguration());
2323 
2324         setUseTempCoords(true);
2325         if (swapSolution != null &amp;&amp; swapSolution.isSolution) {
2326             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2327             // committing anything or animating anything as we just want to determine if a solution
2328             // exists
2329             copySolutionToTempState(swapSolution, dragView);
2330             setItemPlacementDirty(true);
2331             animateItemsToSolution(swapSolution, dragView, commit);
2332 
2333             if (commit) {
2334                 commitTempPlacement();
2335                 completeAndClearReorderHintAnimations();
2336                 setItemPlacementDirty(false);
2337             } else {
2338                 beginOrAdjustHintAnimations(swapSolution, dragView,
2339                         REORDER_ANIMATION_DURATION);
2340             }
2341             mShortcutsAndWidgets.requestLayout();
2342         }
2343         return swapSolution.isSolution;
2344     }
2345 
2346     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2347             View dragView, int[] result, int resultSpan[], int mode) {
2348         // First we determine if things have moved enough to cause a different layout
2349         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2350 
2351         if (resultSpan == null) {
2352             resultSpan = new int[2];
2353         }
2354 
2355         // When we are checking drop validity or actually dropping, we don&#x27;t recompute the
2356         // direction vector, since we want the solution to match the preview, and it&#x27;s possible
2357         // that the exact position of the item has changed to result in a new reordering outcome.
2358         if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP)
2359                &amp;&amp; mPreviousReorderDirection[0] != INVALID_DIRECTION) {
2360             mDirectionVector[0] = mPreviousReorderDirection[0];
2361             mDirectionVector[1] = mPreviousReorderDirection[1];
2362             // We reset this vector after drop
2363             if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2364                 mPreviousReorderDirection[0] = INVALID_DIRECTION;
2365                 mPreviousReorderDirection[1] = INVALID_DIRECTION;
2366             }
2367         } else {
2368             getDirectionVectorForDrop(pixelX, pixelY, spanX, spanY, dragView, mDirectionVector);
2369             mPreviousReorderDirection[0] = mDirectionVector[0];
2370             mPreviousReorderDirection[1] = mDirectionVector[1];
2371         }
2372 
2373         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2374                  spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2375 
2376         // We attempt the approach which doesn&#x27;t shuffle views at all
2377         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2378                 minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2379 
2380         ItemConfiguration finalSolution = null;
2381         if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2382             finalSolution = swapSolution;
2383         } else if (noShuffleSolution.isSolution) {
2384             finalSolution = noShuffleSolution;
2385         }
2386 
2387         boolean foundSolution = true;
2388         if (!DESTRUCTIVE_REORDER) {
2389             setUseTempCoords(true);
2390         }
2391 
2392         if (finalSolution != null) {
2393             result[0] = finalSolution.dragViewX;
2394             result[1] = finalSolution.dragViewY;
2395             resultSpan[0] = finalSolution.dragViewSpanX;
2396             resultSpan[1] = finalSolution.dragViewSpanY;
2397 
2398             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2399             // committing anything or animating anything as we just want to determine if a solution
2400             // exists
2401             if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2402                 if (!DESTRUCTIVE_REORDER) {
2403                     copySolutionToTempState(finalSolution, dragView);
2404                 }
2405                 setItemPlacementDirty(true);
2406                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2407 
2408                 if (!DESTRUCTIVE_REORDER &amp;&amp;
2409                         (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
2410                     commitTempPlacement();
2411                     completeAndClearReorderHintAnimations();
2412                     setItemPlacementDirty(false);
2413                 } else {
2414                     beginOrAdjustHintAnimations(finalSolution, dragView,
2415                             REORDER_ANIMATION_DURATION);
2416                 }
2417             }
2418         } else {
2419             foundSolution = false;
2420             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2421         }
2422 
2423         if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2424             setUseTempCoords(false);
2425         }
2426 
2427         mShortcutsAndWidgets.requestLayout();
2428         return result;
2429     }
2430 
2431     void setItemPlacementDirty(boolean dirty) {
2432         mItemPlacementDirty = dirty;
2433     }
2434     boolean isItemPlacementDirty() {
2435         return mItemPlacementDirty;
2436     }
2437 
2438     private class ItemConfiguration {
2439         HashMap&lt;View, CellAndSpan&gt; map = new HashMap&lt;View, CellAndSpan&gt;();
2440         boolean isSolution = false;
2441         int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2442 
2443         int area() {
2444             return dragViewSpanX * dragViewSpanY;
2445         }
2446     }
2447 
2448     private class CellAndSpan {
2449         int x, y;
2450         int spanX, spanY;
2451 
2452         public CellAndSpan(int x, int y, int spanX, int spanY) {
2453             this.x = x;
2454             this.y = y;
2455             this.spanX = spanX;
2456             this.spanY = spanY;
2457         }
2458     }
2459 
2460     /**
2461      * Find a vacant area that will fit the given bounds nearest the requested
2462      * cell location. Uses Euclidean distance to score multiple vacant areas.
2463      *
2464      * @param pixelX The X location at which you want to search for a vacant area.
2465      * @param pixelY The Y location at which you want to search for a vacant area.
2466      * @param spanX Horizontal span of the object.
2467      * @param spanY Vertical span of the object.
2468      * @param ignoreView Considers space occupied by this view as unoccupied
2469      * @param result Previously returned value to possibly recycle.
2470      * @return The X, Y cell of a vacant area that can contain this object,
2471      *         nearest the requested location.
2472      */
2473     int[] findNearestVacantArea(
2474             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2475         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2476     }
2477 
2478     /**
2479      * Find a vacant area that will fit the given bounds nearest the requested
2480      * cell location. Uses Euclidean distance to score multiple vacant areas.
2481      *
2482      * @param pixelX The X location at which you want to search for a vacant area.
2483      * @param pixelY The Y location at which you want to search for a vacant area.
2484      * @param minSpanX The minimum horizontal span required
2485      * @param minSpanY The minimum vertical span required
2486      * @param spanX Horizontal span of the object.
2487      * @param spanY Vertical span of the object.
2488      * @param ignoreView Considers space occupied by this view as unoccupied
2489      * @param result Previously returned value to possibly recycle.
2490      * @return The X, Y cell of a vacant area that can contain this object,
2491      *         nearest the requested location.
2492      */
2493     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2494             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2495         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2496                 result, resultSpan, mOccupied);
2497     }
2498 
2499     /**
2500      * Find a starting cell position that will fit the given bounds nearest the requested
2501      * cell location. Uses Euclidean distance to score multiple vacant areas.
2502      *
2503      * @param pixelX The X location at which you want to search for a vacant area.
2504      * @param pixelY The Y location at which you want to search for a vacant area.
2505      * @param spanX Horizontal span of the object.
2506      * @param spanY Vertical span of the object.
2507      * @param ignoreView Considers space occupied by this view as unoccupied
2508      * @param result Previously returned value to possibly recycle.
2509      * @return The X, Y cell of a vacant area that can contain this object,
2510      *         nearest the requested location.
2511      */
2512     int[] findNearestArea(
2513             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2514         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2515     }
2516 
2517     boolean existsEmptyCell() {
2518         return findCellForSpan(null, 1, 1);
2519     }
2520 
2521     /**
2522      * Finds the upper-left coordinate of the first rectangle in the grid that can
2523      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2524      * then this method will only return coordinates for rectangles that contain the cell
2525      * (intersectX, intersectY)
2526      *
2527      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2528      *               can be found.
2529      * @param spanX The horizontal span of the cell we want to find.
2530      * @param spanY The vertical span of the cell we want to find.
2531      *
2532      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2533      */
2534     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2535         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2536     }
2537 
2538     /**
2539      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2540      *
2541      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2542      *               can be found.
2543      * @param spanX The horizontal span of the cell we want to find.
2544      * @param spanY The vertical span of the cell we want to find.
2545      * @param ignoreView The home screen item we should treat as not occupying any space
2546      * @return
2547      */
2548     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2549         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2550                 ignoreView, mOccupied);
2551     }
2552 
2553     /**
2554      * Like above, but if intersectX and intersectY are not -1, then this method will try to
2555      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2556      *
2557      * @param spanX The horizontal span of the cell we want to find.
2558      * @param spanY The vertical span of the cell we want to find.
2559      * @param ignoreView The home screen item we should treat as not occupying any space
2560      * @param intersectX The X coordinate of the cell that we should try to overlap
2561      * @param intersectX The Y coordinate of the cell that we should try to overlap
2562      *
2563      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2564      */
2565     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2566             int intersectX, int intersectY) {
2567         return findCellForSpanThatIntersectsIgnoring(
2568                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2569     }
2570 
2571     /**
2572      * The superset of the above two methods
2573      */
2574     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2575             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2576         // mark space take by ignoreView as available (method checks if ignoreView is null)
2577         markCellsAsUnoccupiedForView(ignoreView, occupied);
2578 
2579         boolean foundCell = false;
2580         while (true) {
2581             int startX = 0;
2582             if (intersectX &gt;= 0) {
2583                 startX = Math.max(startX, intersectX - (spanX - 1));
2584             }
2585             int endX = mCountX - (spanX - 1);
2586             if (intersectX &gt;= 0) {
2587                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2588             }
2589             int startY = 0;
2590             if (intersectY &gt;= 0) {
2591                 startY = Math.max(startY, intersectY - (spanY - 1));
2592             }
2593             int endY = mCountY - (spanY - 1);
2594             if (intersectY &gt;= 0) {
2595                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2596             }
2597 
2598             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2599                 inner:
2600                 for (int x = startX; x &lt; endX; x++) {
2601                     for (int i = 0; i &lt; spanX; i++) {
2602                         for (int j = 0; j &lt; spanY; j++) {
2603                             if (occupied[x + i][y + j]) {
2604                                 // small optimization: we can skip to after the column we just found
2605                                 // an occupied cell
2606                                 x += i;
2607                                 continue inner;
2608                             }
2609                         }
2610                     }
2611                     if (cellXY != null) {
2612                         cellXY[0] = x;
2613                         cellXY[1] = y;
2614                     }
2615                     foundCell = true;
2616                     break;
2617                 }
2618             }
2619             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2620                 break;
2621             } else {
2622                 // if we failed to find anything, try again but without any requirements of
2623                 // intersecting
2624                 intersectX = -1;
2625                 intersectY = -1;
2626                 continue;
2627             }
2628         }
2629 
2630         // re-mark space taken by ignoreView as occupied
2631         markCellsAsOccupiedForView(ignoreView, occupied);
2632         return foundCell;
2633     }
2634 
2635     /**
2636      * A drag event has begun over this layout.
2637      * It may have begun over this layout (in which case onDragChild is called first),
2638      * or it may have begun on another layout.
2639      */
2640     void onDragEnter() {
2641         mDragEnforcer.onDragEnter();
2642         mDragging = true;
2643     }
2644 
2645     /**
2646      * Called when drag has left this CellLayout or has been completed (successfully or not)
2647      */
2648     void onDragExit() {
2649         mDragEnforcer.onDragExit();
2650         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2651         // item to this layout via the customize drawer.
2652         // Guard against that case.
2653         if (mDragging) {
2654             mDragging = false;
2655         }
2656 
2657         // Invalidate the drag data
2658         mDragCell[0] = mDragCell[1] = -1;
2659         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2660         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2661         revertTempState();
2662         setIsDragOverlapping(false);
2663     }
2664 
2665     /**
2666      * Mark a child as having been dropped.
2667      * At the beginning of the drag operation, the child may have been on another
2668      * screen, but it is re-parented before this method is called.
2669      *
2670      * @param child The child that is being dropped
2671      */
2672     void onDropChild(View child) {
2673         if (child != null) {
2674             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2675             lp.dropped = true;
2676             child.requestLayout();
2677         }
2678     }
2679 
2680     /**
2681      * Computes a bounding rectangle for a range of cells
2682      *
2683      * @param cellX X coordinate of upper left corner expressed as a cell position
2684      * @param cellY Y coordinate of upper left corner expressed as a cell position
2685      * @param cellHSpan Width in cells
2686      * @param cellVSpan Height in cells
2687      * @param resultRect Rect into which to put the results
2688      */
2689     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2690         final int cellWidth = mCellWidth;
2691         final int cellHeight = mCellHeight;
2692         final int widthGap = mWidthGap;
2693         final int heightGap = mHeightGap;
2694 
2695         final int hStartPadding = getPaddingLeft();
2696         final int vStartPadding = getPaddingTop();
2697 
2698         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2699         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2700 
2701         int x = hStartPadding + cellX * (cellWidth + widthGap);
2702         int y = vStartPadding + cellY * (cellHeight + heightGap);
2703 
2704         resultRect.set(x, y, x + width, y + height);
2705     }
2706 
2707     /**
2708      * Computes the required horizontal and vertical cell spans to always
2709      * fit the given rectangle.
2710      *
2711      * @param width Width in pixels
2712      * @param height Height in pixels
2713      * @param result An array of length 2 in which to store the result (may be null).
2714      */
2715     public int[] rectToCell(int width, int height, int[] result) {
2716         return rectToCell(getResources(), width, height, result);
2717     }
2718 
2719     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2720         // Always assume we&#x27;re working with the smallest span to make sure we
2721         // reserve enough space in both orientations.
2722         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2723         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2724         int smallerSize = Math.min(actualWidth, actualHeight);
2725 
2726         // Always round up to next largest cell
2727         int spanX = (int) Math.ceil(width / (float) smallerSize);
2728         int spanY = (int) Math.ceil(height / (float) smallerSize);
2729 
2730         if (result == null) {
2731             return new int[] { spanX, spanY };
2732         }
2733         result[0] = spanX;
2734         result[1] = spanY;
2735         return result;
2736     }
2737 
2738     public int[] cellSpansToSize(int hSpans, int vSpans) {
2739         int[] size = new int[2];
2740         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2741         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2742         return size;
2743     }
2744 
2745     /**
2746      * Calculate the grid spans needed to fit given item
2747      */
2748     public void calculateSpans(ItemInfo info) {
2749         final int minWidth;
2750         final int minHeight;
2751 
2752         if (info instanceof LauncherAppWidgetInfo) {
2753             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2754             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2755         } else if (info instanceof PendingAddWidgetInfo) {
2756             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2757             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2758         } else {
2759             // It&#x27;s not a widget, so it must be 1x1
2760             info.spanX = info.spanY = 1;
2761             return;
2762         }
2763         int[] spans = rectToCell(minWidth, minHeight, null);
2764         info.spanX = spans[0];
2765         info.spanY = spans[1];
2766     }
2767 
2768     /**
2769      * Find the first vacant cell, if there is one.
2770      *
2771      * @param vacant Holds the x and y coordinate of the vacant cell
2772      * @param spanX Horizontal cell span.
2773      * @param spanY Vertical cell span.
2774      *
2775      * @return True if a vacant cell was found
2776      */
2777     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2778 
2779         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2780     }
2781 
2782     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2783             int xCount, int yCount, boolean[][] occupied) {
2784 
2785         for (int y = 0; y &lt; yCount; y++) {
2786             for (int x = 0; x &lt; xCount; x++) {
2787                 boolean available = !occupied[x][y];
2788 out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2789                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2790                         available = available &amp;&amp; !occupied[i][j];
2791                         if (!available) break out;
2792                     }
2793                 }
2794 
2795                 if (available) {
2796                     vacant[0] = x;
2797                     vacant[1] = y;
2798                     return true;
2799                 }
2800             }
2801         }
2802 
2803         return false;
2804     }
2805 
2806     private void clearOccupiedCells() {
2807         for (int x = 0; x &lt; mCountX; x++) {
2808             for (int y = 0; y &lt; mCountY; y++) {
2809                 mOccupied[x][y] = false;
2810             }
2811         }
2812     }
2813 
2814     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2815         markCellsAsUnoccupiedForView(view);
2816         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2817     }
2818 
2819     public void markCellsAsOccupiedForView(View view) {
2820         markCellsAsOccupiedForView(view, mOccupied);
2821     }
2822     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2823         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2824         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2825         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2826     }
2827 
2828     public void markCellsAsUnoccupiedForView(View view) {
2829         markCellsAsUnoccupiedForView(view, mOccupied);
2830     }
2831     public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2832         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2833         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2834         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2835     }
2836 
2837     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2838             boolean value) {
2839         if (cellX &lt; 0 || cellY &lt; 0) return;
2840         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2841             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2842                 occupied[x][y] = value;
2843             }
2844         }
2845     }
2846 
2847     public int getDesiredWidth() {
2848         return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
2849                 (Math.max((mCountX - 1), 0) * mWidthGap);
2850     }
2851 
2852     public int getDesiredHeight()  {
2853         return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
2854                 (Math.max((mCountY - 1), 0) * mHeightGap);
2855     }
2856 
2857     public boolean isOccupied(int x, int y) {
2858         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2859             return mOccupied[x][y];
2860         } else {
2861             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2862         }
2863     }
2864 
2865     @Override
2866     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2867         return new CellLayout.LayoutParams(getContext(), attrs);
2868     }
2869 
2870     @Override
2871     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2872         return p instanceof CellLayout.LayoutParams;
2873     }
2874 
2875     @Override
2876     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2877         return new CellLayout.LayoutParams(p);
2878     }
2879 
2880     public static class CellLayoutAnimationController extends LayoutAnimationController {
2881         public CellLayoutAnimationController(Animation animation, float delay) {
2882             super(animation, delay);
2883         }
2884 
2885         @Override
2886         protected long getDelayForView(View view) {
2887             return (int) (Math.random() * 150);
2888         }
2889     }
2890 
2891     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2892         /**
2893          * Horizontal location of the item in the grid.
2894          */
2895         @ViewDebug.ExportedProperty
2896         public int cellX;
2897 
2898         /**
2899          * Vertical location of the item in the grid.
2900          */
2901         @ViewDebug.ExportedProperty
2902         public int cellY;
2903 
2904         /**
2905          * Temporary horizontal location of the item in the grid during reorder
2906          */
2907         public int tmpCellX;
2908 
2909         /**
2910          * Temporary vertical location of the item in the grid during reorder
2911          */
2912         public int tmpCellY;
2913 
2914         /**
2915          * Indicates that the temporary coordinates should be used to layout the items
2916          */
2917         public boolean useTmpCoords;
2918 
2919         /**
2920          * Number of cells spanned horizontally by the item.
2921          */
2922         @ViewDebug.ExportedProperty
2923         public int cellHSpan;
2924 
2925         /**
2926          * Number of cells spanned vertically by the item.
2927          */
2928         @ViewDebug.ExportedProperty
2929         public int cellVSpan;
2930 
2931         /**
2932          * Indicates whether the item will set its x, y, width and height parameters freely,
2933          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2934          */
2935         public boolean isLockedToGrid = true;
2936 
2937         /**
2938          * Indicates whether this item can be reordered. Always true except in the case of the
2939          * the AllApps button.
2940          */
2941         public boolean canReorder = true;
2942 
2943         // X coordinate of the view in the layout.
2944         @ViewDebug.ExportedProperty
2945         int x;
2946         // Y coordinate of the view in the layout.
2947         @ViewDebug.ExportedProperty
2948         int y;
2949 
2950         boolean dropped;
2951 
2952         public LayoutParams(Context c, AttributeSet attrs) {
2953             super(c, attrs);
2954             cellHSpan = 1;
2955             cellVSpan = 1;
2956         }
2957 
2958         public LayoutParams(ViewGroup.LayoutParams source) {
2959             super(source);
2960             cellHSpan = 1;
2961             cellVSpan = 1;
2962         }
2963 
2964         public LayoutParams(LayoutParams source) {
2965             super(source);
2966             this.cellX = source.cellX;
2967             this.cellY = source.cellY;
2968             this.cellHSpan = source.cellHSpan;
2969             this.cellVSpan = source.cellVSpan;
2970         }
2971 
2972         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2973             super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2974             this.cellX = cellX;
2975             this.cellY = cellY;
2976             this.cellHSpan = cellHSpan;
2977             this.cellVSpan = cellVSpan;
2978         }
2979 
2980         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2981             if (isLockedToGrid) {
2982                 final int myCellHSpan = cellHSpan;
2983                 final int myCellVSpan = cellVSpan;
2984                 final int myCellX = useTmpCoords ? tmpCellX : cellX;
2985                 final int myCellY = useTmpCoords ? tmpCellY : cellY;
2986 
2987                 width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2988                         leftMargin - rightMargin;
2989                 height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2990                         topMargin - bottomMargin;
2991                 x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2992                 y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2993             }
2994         }
2995 
2996         public String toString() {
2997             return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2998         }
2999 
3000         public void setWidth(int width) {
3001             this.width = width;
3002         }
3003 
3004         public int getWidth() {
3005             return width;
3006         }
3007 
3008         public void setHeight(int height) {
3009             this.height = height;
3010         }
3011 
3012         public int getHeight() {
3013             return height;
3014         }
3015 
3016         public void setX(int x) {
3017             this.x = x;
3018         }
3019 
3020         public int getX() {
3021             return x;
3022         }
3023 
3024         public void setY(int y) {
3025             this.y = y;
3026         }
3027 
3028         public int getY() {
3029             return y;
3030         }
3031     }
3032 
3033     // This class stores info for two purposes:
3034     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
3035     //    its spanX, spanY, and the screen it is on
3036     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
3037     //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
3038     //    the CellLayout that was long clicked
3039     static final class CellInfo {
3040         View cell;
3041         int cellX = -1;
3042         int cellY = -1;
3043         int spanX;
3044         int spanY;
3045         int screen;
3046         long container;
3047 
3048         @Override
3049         public String toString() {
3050             return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
3051                     + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
3052         }
3053     }
3054 
3055     public boolean lastDownOnOccupiedCell() {
3056         return mLastDownOnOccupiedCell;
3057     }
3058 }
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher2;
  17 
  18 import android.animation.Animator;
  19 import android.animation.AnimatorListenerAdapter;
  20 import android.animation.AnimatorSet;
  21 import android.animation.TimeInterpolator;
  22 import android.animation.ValueAnimator.AnimatorUpdateListener;
  23 import android.animation.ValueAnimator;
  24 import android.content.Context;
  25 import android.content.res.Resources;
  26 import android.content.res.TypedArray;
  27 import android.graphics.Bitmap;
  28 import android.graphics.Canvas;
  29 import android.graphics.Color;
  30 import android.graphics.Paint;
  31 import android.graphics.Point;
  32 import android.graphics.PorterDuff;
  33 import android.graphics.PorterDuffXfermode;
  34 import android.graphics.Rect;
  35 import android.graphics.drawable.ColorDrawable;
  36 import android.graphics.drawable.Drawable;
  37 import android.graphics.drawable.NinePatchDrawable;
  38 import android.os.Parcelable;
  39 import android.util.AttributeSet;
  40 import android.util.Log;
  41 import android.util.SparseArray;
  42 import android.view.MotionEvent;
  43 import android.view.View;
  44 import android.view.ViewDebug;
  45 import android.view.ViewGroup;
  46 import android.view.animation.Animation;
  47 import android.view.animation.DecelerateInterpolator;
  48 import android.view.animation.LayoutAnimationController;
  49 import com.android.launcher.R;
  50 import com.android.launcher2.FolderIcon.FolderRingAnimator;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.HashMap;
  54 import java.util.Stack;
  55 
  56 
  57 public class CellLayout extends ViewGroup {
  58     static final String TAG = &quot;CellLayout&quot;;
  59 
  60     private Launcher mLauncher;
  61 
  62     private int mCellWidth;
  63 
  64     private int mCellHeight;
  65 
  66     private int mCountX;
  67 
  68     private int mCountY;
  69 
  70     private int mOriginalWidthGap;
  71 
  72     private int mOriginalHeightGap;
  73 
  74     private int mWidthGap;
  75 
  76     private int mHeightGap;
  77 
  78     private int mMaxGap;
  79 
  80     private boolean mScrollingTransformsDirty = false;
  81 
  82     private final Rect mRect = new Rect();
  83 
  84     private final CellInfo mCellInfo = new CellInfo();
  85 
  86     // These are temporary variables to prevent having to allocate a new object just to
  87     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  88     private final int[] mTmpXY = new int[2];
  89 
  90     private final int[] mTmpPoint = new int[2];
  91 
  92     int[] mTempLocation = new int[2];
  93 
  94     boolean[][] mOccupied;
  95 
  96     boolean[][] mTmpOccupied;
  97 
  98     private boolean mLastDownOnOccupiedCell = false;
  99 
 100     private OnTouchListener mInterceptTouchListener;
 101 
 102     private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
 103 
 104     private int[] mFolderLeaveBehindCell = new int[]{ -1, -1 };
 105 
 106     private int mForegroundAlpha = 0;
 107 
 108     private float mBackgroundAlpha;
 109 
 110     private float mBackgroundAlphaMultiplier = 1.0f;
 111 
 112     private Drawable mNormalBackground;
 113 
 114     private Drawable mActiveGlowBackground;
 115 
 116     private Drawable mOverScrollForegroundDrawable;
 117 
 118     private Drawable mOverScrollLeft;
 119 
 120     private Drawable mOverScrollRight;
 121 
 122     private Rect mBackgroundRect;
 123 
 124     private Rect mForegroundRect;
 125 
 126     private int mForegroundPadding;
 127 
 128     // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 129     private boolean mIsDragOverlapping = false;
 130 
 131     private final Point mDragCenter = new Point();
 132 
 133     // These arrays are used to implement the drag visualization on x-large screens.
 134     // They are used as circular arrays, indexed by mDragOutlineCurrent.
 135     private Rect[] mDragOutlines = new Rect[4];
 136 
 137     private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 138 
 139     private InterruptibleInOutAnimator[] mDragOutlineAnims =
 140             new InterruptibleInOutAnimator[mDragOutlines.length];
 141 
 142     // Used as an index into the above 3 arrays; indicates which is the most current value.
 143     // Used as an index into the above 3 arrays; indicates which is the most current value.
 144     private int mDragOutlineCurrent = 0;
 145 
 146     private final Paint mDragOutlinePaint = new Paint();
 147 
 148     private BubbleTextView mPressedOrFocusedIcon;
 149 
<abbr title=" 150     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new HashMap&lt;CellLayout.LayoutParams, Animator&gt;();"> 150     private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new HashMap&lt;CellLayout.LayoutP🔵</abbr>
 151 
<abbr title=" 152     private HashMap&lt;View, ReorderHintAnimation&gt; mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;();"> 152     private HashMap&lt;View, ReorderHintAnimation&gt; mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;🔵</abbr>
 153 
 154     private boolean mItemPlacementDirty = false;
 155 
 156     // When a drag operation is in progress, holds the nearest cell to the touch point
 157     private final int[] mDragCell = new int[2];
 158 
 159     private boolean mDragging = false;
 160 
 161     private TimeInterpolator mEaseOutInterpolator;
 162 
 163     private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 164 
 165     private boolean mIsHotseat = false;
 166 
 167     public static final int MODE_DRAG_OVER = 0;
 168 
 169     public static final int MODE_ON_DROP = 1;
 170 
 171     public static final int MODE_ON_DROP_EXTERNAL = 2;
 172 
 173     public static final int MODE_ACCEPT_DROP = 3;
 174 
 175     private static final boolean DESTRUCTIVE_REORDER = false;
 176 
 177     private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 178 
 179     static final int LANDSCAPE = 0;
 180 
 181     static final int PORTRAIT = 1;
 182 
 183     private static final float REORDER_HINT_MAGNITUDE = 0.12f;
 184 
 185     private static final int REORDER_ANIMATION_DURATION = 150;
 186 
 187     private float mReorderHintAnimationMagnitude;
 188 
 189     private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 190 
 191     private Rect mOccupiedRect = new Rect();
 192 
 193     private int[] mDirectionVector = new int[2];
 194 
 195     int[] mPreviousReorderDirection = new int[2];
 196 
 197     private static final int INVALID_DIRECTION = -100;
 198 
 199     private DropTarget.DragEnforcer mDragEnforcer;
 200 
 201     private final static PorterDuffXfermode sAddBlendMode =
 202             new PorterDuffXfermode(PorterDuff.Mode.ADD);
 203 
 204     private final static Paint sPaint = new Paint();
 205 
 206     public CellLayout(Context context) {
 207         this(context, null);
 208     }
 209 
 210     public CellLayout(Context context, AttributeSet attrs) {
 211         this(context, attrs, 0);
 212     }
 213 
 214     public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 215         super(context, attrs, defStyle);
 216         mDragEnforcer = new DropTarget.DragEnforcer(context);
 217         // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 218         // the user where a dragged item will land when dropped.
 219         setWillNotDraw(false);
 220         mLauncher = ((Launcher) (context));
 221         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 222         mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 223         mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 224         mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 225         mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 226         mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 227         mCountX = LauncherModel.getCellCountX();
 228         mCountY = LauncherModel.getCellCountY();
 229         mOccupied = new boolean[mCountX][mCountY];
 230         mTmpOccupied = new boolean[mCountX][mCountY];
 231         mPreviousReorderDirection[0] = INVALID_DIRECTION;
 232         mPreviousReorderDirection[1] = INVALID_DIRECTION;
 233         a.recycle();
 234         setAlwaysDrawnWithCacheEnabled(false);
 235         final Resources res = getResources();
 236         mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 237         mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 238         mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 239         mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 240         mForegroundPadding = res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
<abbr title=" 241         mReorderHintAnimationMagnitude = REORDER_HINT_MAGNITUDE * res.getDimensionPixelSize(R.dimen.app_icon_size);"> 241         mReorderHintAnimationMagnitude = REORDER_HINT_MAGNITUDE * res.getDimensionPixelSize(R.dimen.app_i🔵</abbr>
 242         mNormalBackground.setFilterBitmap(true);
 243         mActiveGlowBackground.setFilterBitmap(true);
 244         // Initialize the data structures used for the drag visualization.
 245         mEaseOutInterpolator = new DecelerateInterpolator(2.5F);// Quint ease out
 246 
 247         mDragCell[0] = mDragCell[1] = -1;
 248         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 249             mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 250         }
 251         // When dragging things around the home screens, we show a green outline of
 252         // where the item will land. The outlines gradually fade out, leaving a trail
 253         // behind the drag path.
 254         // Set up all the animations that are used to implement this fading.
 255         final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 256         final float fromAlphaValue = 0;
 257         final float toAlphaValue = ((float) (res.getInteger(R.integer.config_dragOutlineMaxAlpha)));
 258         Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 259         for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
<abbr title=" 260             final InterruptibleInOutAnimator anim = new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);"> 260             final InterruptibleInOutAnimator anim = new InterruptibleInOutAnimator(duration, fromAlphaVal🔵</abbr>
 261             anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 262             final int thisIndex = i;
 263             anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 264                 public void onAnimationUpdate(ValueAnimator animation) {
 265                     final Bitmap outline = ((Bitmap) (anim.getTag()));
 266                     // If an animation is started and then stopped very quickly, we can still
 267                     // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 268                     if (outline == null) {
 269                         // suppress dead code warning
 270                         @SuppressWarnings(&quot;all&quot;)
 271                         final boolean debug = false;
 272                         if (debug) {
 273                             Object val = animation.getAnimatedValue();
<abbr title=" 274                             Log.d(TAG, ((((&quot;anim &quot; + thisIndex) + &quot; update: &quot;) + val) + &quot;, isStopped &quot;) + anim.isStopped());"> 274                             Log.d(TAG, ((((&quot;anim &quot; + thisIndex) + &quot; update: &quot;) + val) + &quot;, isStopped &quot;) +🔵</abbr>
 275                         }
 276                         // Try to prevent it from continuing to run
 277                         animation.cancel();
 278                     } else {
 279                         mDragOutlineAlphas[thisIndex] = ((Float) (animation.getAnimatedValue()));
 280                         CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 281                     }
 282                 }
 283             });
 284             // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 285             // running. This way the bitmap can be GCed when the animations are complete.
 286             anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 287                 @Override
 288                 public void onAnimationEnd(Animator animation) {
 289                     if (((Float) (((ValueAnimator) (animation)).getAnimatedValue())) == 0.0F) {
 290                         anim.setTag(null);
 291                     }
 292                 }
 293             });
 294             mDragOutlineAnims[i] = anim;
 295         }
 296         mBackgroundRect = new Rect();
 297         mForegroundRect = new Rect();
 298         mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 299         mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 300         addView(mShortcutsAndWidgets);
 301     }
 302 
 303     static int widthInPortrait(Resources r, int numCells) {
 304         // We use this method from Workspace to figure out how many rows/columns Launcher should
 305         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 306         // the padding extends outside the visible screen size, but it looked fine anyway.
 307         int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 308         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 309                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 310 
 311         return  minGap * (numCells - 1) + cellWidth * numCells;
 312     }
 313 
 314     static int heightInLandscape(Resources r, int numCells) {
 315         // We use this method from Workspace to figure out how many rows/columns Launcher should
 316         // have. We ignore the left/right padding on CellLayout because it turns out in our design
 317         // the padding extends outside the visible screen size, but it looked fine anyway.
 318         int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 319         int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 320                 r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 321 
 322         return minGap * (numCells - 1) + cellHeight * numCells;
 323     }
 324 
 325     public void enableHardwareLayers() {
 326         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_HARDWARE, sPaint);
 327     }
 328 
 329     public void disableHardwareLayers() {
 330         mShortcutsAndWidgets.setLayerType(LAYER_TYPE_NONE, sPaint);
 331     }
 332 
 333     public void buildHardwareLayer() {
 334         mShortcutsAndWidgets.buildLayer();
 335     }
 336 
 337     public void setGridSize(int x, int y) {
 338         mCountX = x;
 339         mCountY = y;
 340         mOccupied = new boolean[mCountX][mCountY];
 341         mTmpOccupied = new boolean[mCountX][mCountY];
 342         mTempRectStack.clear();
 343         requestLayout();
 344     }
 345 
 346     private void invalidateBubbleTextView(BubbleTextView icon) {
 347         final int padding = icon.getPressedOrFocusedBackgroundPadding();
 348         invalidate(icon.getLeft() + getPaddingLeft() - padding,
 349                 icon.getTop() + getPaddingTop() - padding,
 350                 icon.getRight() + getPaddingLeft() + padding,
 351                 icon.getBottom() + getPaddingTop() + padding);
 352     }
 353 
 354     void setOverScrollAmount(float r, boolean left) {
 355         if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 356             mOverScrollForegroundDrawable = mOverScrollLeft;
 357         } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 358             mOverScrollForegroundDrawable = mOverScrollRight;
 359         }
 360 
 361         mForegroundAlpha = (int) Math.round((r * 255));
 362         mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 363         invalidate();
 364     }
 365 
 366     void setPressedOrFocusedIcon(BubbleTextView icon) {
 367         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 368         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 369         BubbleTextView oldIcon = mPressedOrFocusedIcon;
 370         mPressedOrFocusedIcon = icon;
 371         if (oldIcon != null) {
 372             invalidateBubbleTextView(oldIcon);
 373         }
 374         if (mPressedOrFocusedIcon != null) {
 375             invalidateBubbleTextView(mPressedOrFocusedIcon);
 376         }
 377     }
 378 
 379     void setIsDragOverlapping(boolean isDragOverlapping) {
 380         if (mIsDragOverlapping != isDragOverlapping) {
 381             mIsDragOverlapping = isDragOverlapping;
 382             invalidate();
 383         }
 384     }
 385 
 386     boolean getIsDragOverlapping() {
 387         return mIsDragOverlapping;
 388     }
 389 
 390     protected void setOverscrollTransformsDirty(boolean dirty) {
 391         mScrollingTransformsDirty = dirty;
 392     }
 393 
 394     protected void resetOverscrollTransforms() {
 395         if (mScrollingTransformsDirty) {
 396             setOverscrollTransformsDirty(false);
 397             setTranslationX(0);
 398             setRotationY(0);
 399             // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 400             // pass 0, which results in the overscroll drawable not being drawn any more.
 401             setOverScrollAmount(0, false);
 402             setPivotX(getMeasuredWidth() / 2);
 403             setPivotY(getMeasuredHeight() / 2);
 404         }
 405     }
 406 
 407     @Override
 408     protected void onDraw(Canvas canvas) {
 409         // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 410         // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 411         // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 412         // a drag). However, we also drag the mini hover background *over* one of those two
 413         // backgrounds
 414         if (mBackgroundAlpha &gt; 0.0f) {
 415             Drawable bg;
 416 
 417             if (mIsDragOverlapping) {
 418                 // In the mini case, we draw the active_glow bg *over* the active background
 419                 bg = mActiveGlowBackground;
 420             } else {
 421                 bg = mNormalBackground;
 422             }
 423 
 424             bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 425             bg.setBounds(mBackgroundRect);
 426             bg.draw(canvas);
 427         }
 428 
 429         final Paint paint = mDragOutlinePaint;
 430         for (int i = 0; i &lt; mDragOutlines.length; i++) {
 431             final float alpha = mDragOutlineAlphas[i];
 432             if (alpha &gt; 0) {
 433                 final Rect r = mDragOutlines[i];
 434                 final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 435                 paint.setAlpha((int)(alpha + .5f));
 436                 canvas.drawBitmap(b, null, r, paint);
 437             }
 438         }
 439 
 440         // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 441         // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 442         if (mPressedOrFocusedIcon != null) {
 443             final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 444             final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 445             if (b != null) {
 446                 canvas.drawBitmap(b,
 447                         mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 448                         mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 449                         null);
 450             }
 451         }
 452 
 453         if (DEBUG_VISUALIZE_OCCUPIED) {
 454             int[] pt = new int[2];
 455             ColorDrawable cd = new ColorDrawable(Color.RED);
 456             cd.setBounds(0, 0,  mCellWidth, mCellHeight);
 457             for (int i = 0; i &lt; mCountX; i++) {
 458                 for (int j = 0; j &lt; mCountY; j++) {
 459                     if (mOccupied[i][j]) {
 460                         cellToPoint(i, j, pt);
 461                         canvas.save();
 462                         canvas.translate(pt[0], pt[1]);
 463                         cd.draw(canvas);
 464                         canvas.restore();
 465                     }
 466                 }
 467             }
 468         }
 469 
 470         int previewOffset = FolderRingAnimator.sPreviewSize;
 471 
 472         // The folder outer / inner ring image(s)
 473         for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 474             FolderRingAnimator fra = mFolderOuterRings.get(i);
 475 
 476             // Draw outer ring
 477             Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 478             int width = (int) fra.getOuterRingSize();
 479             int height = width;
 480             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 481 
 482             int centerX = mTempLocation[0] + mCellWidth / 2;
 483             int centerY = mTempLocation[1] + previewOffset / 2;
 484 
 485             canvas.save();
 486             canvas.translate(centerX - width / 2, centerY - height / 2);
 487             d.setBounds(0, 0, width, height);
 488             d.draw(canvas);
 489             canvas.restore();
 490 
 491             // Draw inner ring
 492             d = FolderRingAnimator.sSharedInnerRingDrawable;
 493             width = (int) fra.getInnerRingSize();
 494             height = width;
 495             cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 496 
 497             centerX = mTempLocation[0] + mCellWidth / 2;
 498             centerY = mTempLocation[1] + previewOffset / 2;
 499             canvas.save();
 500             canvas.translate(centerX - width / 2, centerY - width / 2);
 501             d.setBounds(0, 0, width, height);
 502             d.draw(canvas);
 503             canvas.restore();
 504         }
 505 
 506         if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 507             Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 508             int width = d.getIntrinsicWidth();
 509             int height = d.getIntrinsicHeight();
 510 
 511             cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 512             int centerX = mTempLocation[0] + mCellWidth / 2;
 513             int centerY = mTempLocation[1] + previewOffset / 2;
 514 
 515             canvas.save();
 516             canvas.translate(centerX - width / 2, centerY - width / 2);
 517             d.setBounds(0, 0, width, height);
 518             d.draw(canvas);
 519             canvas.restore();
 520         }
 521     }
 522 
 523     @Override
 524     protected void dispatchDraw(Canvas canvas) {
 525         super.dispatchDraw(canvas);
 526         if (mForegroundAlpha &gt; 0) {
 527             mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 528             Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 529             p.setXfermode(sAddBlendMode);
 530             mOverScrollForegroundDrawable.draw(canvas);
 531             p.setXfermode(null);
 532         }
 533     }
 534 
 535     public void showFolderAccept(FolderRingAnimator fra) {
 536         mFolderOuterRings.add(fra);
 537     }
 538 
 539     public void hideFolderAccept(FolderRingAnimator fra) {
 540         if (mFolderOuterRings.contains(fra)) {
 541             mFolderOuterRings.remove(fra);
 542         }
 543         invalidate();
 544     }
 545 
 546     public void setFolderLeaveBehindCell(int x, int y) {
 547         mFolderLeaveBehindCell[0] = x;
 548         mFolderLeaveBehindCell[1] = y;
 549         invalidate();
 550     }
 551 
 552     public void clearFolderLeaveBehind() {
 553         mFolderLeaveBehindCell[0] = -1;
 554         mFolderLeaveBehindCell[1] = -1;
 555         invalidate();
 556     }
 557 
 558     @Override
 559     public boolean shouldDelayChildPressedState() {
 560         return false;
 561     }
 562 
 563     public void restoreInstanceState(SparseArray&lt;Parcelable&gt; states) {
 564         dispatchRestoreInstanceState(states);
 565     }
 566 
 567     @Override
 568     public void cancelLongPress() {
 569         super.cancelLongPress();
 570 
 571         // Cancel long press for all children
 572         final int count = getChildCount();
 573         for (int i = 0; i &lt; count; i++) {
 574             final View child = getChildAt(i);
 575             child.cancelLongPress();
 576         }
 577     }
 578 
 579     public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 580         mInterceptTouchListener = listener;
 581     }
 582 
 583     int getCountX() {
 584         return mCountX;
 585     }
 586 
 587     int getCountY() {
 588         return mCountY;
 589     }
 590 
 591     public void setIsHotseat(boolean isHotseat) {
 592         mIsHotseat = isHotseat;
 593     }
 594 
 595     public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 596             boolean markCells) {
 597         final LayoutParams lp = params;
 598 
 599         // Hotseat icons - remove text
 600         if (child instanceof BubbleTextView) {
 601             BubbleTextView bubbleChild = (BubbleTextView) child;
 602 
 603             Resources res = getResources();
 604             if (mIsHotseat) {
 605                 bubbleChild.setTextColor(res.getColor(android.R.color.transparent));
 606             } else {
 607                 bubbleChild.setTextColor(res.getColor(R.color.workspace_icon_text_color));
 608             }
 609         }
 610 
 611         // Generate an id for each view, this assumes we have at most 256x256 cells
 612         // per workspace screen
 613         if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 614             // If the horizontal or vertical span is set to -1, it is taken to
 615             // mean that it spans the extent of the CellLayout
 616             if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 617             if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 618 
 619             child.setId(childId);
 620 
 621             mShortcutsAndWidgets.addView(child, index, lp);
 622 
 623             if (markCells) markCellsAsOccupiedForView(child);
 624 
 625             return true;
 626         }
 627         return false;
 628     }
 629 
 630     @Override
 631     public void removeAllViews() {
 632         clearOccupiedCells();
 633         mShortcutsAndWidgets.removeAllViews();
 634     }
 635 
 636     @Override
 637     public void removeAllViewsInLayout() {
 638         if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 639             clearOccupiedCells();
 640             mShortcutsAndWidgets.removeAllViewsInLayout();
 641         }
 642     }
 643 
 644     public void removeViewWithoutMarkingCells(View view) {
 645         mShortcutsAndWidgets.removeView(view);
 646     }
 647 
 648     @Override
 649     public void removeView(View view) {
 650         markCellsAsUnoccupiedForView(view);
 651         mShortcutsAndWidgets.removeView(view);
 652     }
 653 
 654     @Override
 655     public void removeViewAt(int index) {
 656         markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 657         mShortcutsAndWidgets.removeViewAt(index);
 658     }
 659 
 660     @Override
 661     public void removeViewInLayout(View view) {
 662         markCellsAsUnoccupiedForView(view);
 663         mShortcutsAndWidgets.removeViewInLayout(view);
 664     }
 665 
 666     @Override
 667     public void removeViews(int start, int count) {
 668         for (int i = start; i &lt; start + count; i++) {
 669             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 670         }
 671         mShortcutsAndWidgets.removeViews(start, count);
 672     }
 673 
 674     @Override
 675     public void removeViewsInLayout(int start, int count) {
 676         for (int i = start; i &lt; start + count; i++) {
 677             markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 678         }
 679         mShortcutsAndWidgets.removeViewsInLayout(start, count);
 680     }
 681 
 682     @Override
 683     protected void onAttachedToWindow() {
 684         super.onAttachedToWindow();
 685         mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 686     }
 687 
 688     public void setTagToCellInfoForPoint(int touchX, int touchY) {
 689         final CellInfo cellInfo = mCellInfo;
 690         Rect frame = mRect;
 691         final int x = touchX + getScrollX();
 692         final int y = touchY + getScrollY();
 693         final int count = mShortcutsAndWidgets.getChildCount();
 694 
 695         boolean found = false;
 696         for (int i = count - 1; i &gt;= 0; i--) {
 697             final View child = mShortcutsAndWidgets.getChildAt(i);
 698             final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 699 
 700             if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 701                     lp.isLockedToGrid) {
 702                 child.getHitRect(frame);
 703 
 704                 float scale = child.getScaleX();
 705                 frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 706                         child.getBottom());
 707                 // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 708                 // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 709                 // to this view.
 710                 frame.offset(getPaddingLeft(), getPaddingTop());
 711                 frame.inset((int) (frame.width() * (1f - scale) / 2),
 712                         (int) (frame.height() * (1f - scale) / 2));
 713 
 714                 if (frame.contains(x, y)) {
 715                     cellInfo.cell = child;
 716                     cellInfo.cellX = lp.cellX;
 717                     cellInfo.cellY = lp.cellY;
 718                     cellInfo.spanX = lp.cellHSpan;
 719                     cellInfo.spanY = lp.cellVSpan;
 720                     found = true;
 721                     break;
 722                 }
 723             }
 724         }
 725 
 726         mLastDownOnOccupiedCell = found;
 727 
 728         if (!found) {
 729             final int cellXY[] = mTmpXY;
 730             pointToCellExact(x, y, cellXY);
 731 
 732             cellInfo.cell = null;
 733             cellInfo.cellX = cellXY[0];
 734             cellInfo.cellY = cellXY[1];
 735             cellInfo.spanX = 1;
 736             cellInfo.spanY = 1;
 737         }
 738         setTag(cellInfo);
 739     }
 740 
 741     @Override
 742     public boolean onInterceptTouchEvent(MotionEvent ev) {
 743         // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 744         // even in the case where we return early. Not clearing here was causing bugs whereby on
 745         // long-press we&#x27;d end up picking up an item from a previous drag operation.
 746         final int action = ev.getAction();
 747 
 748         if (action == MotionEvent.ACTION_DOWN) {
 749             clearTagCellInfo();
 750         }
 751 
 752         if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 753             return true;
 754         }
 755 
 756         if (action == MotionEvent.ACTION_DOWN) {
 757             setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 758         }
 759 
 760         return false;
 761     }
 762 
 763     private void clearTagCellInfo() {
 764         final CellInfo cellInfo = mCellInfo;
 765         cellInfo.cell = null;
 766         cellInfo.cellX = -1;
 767         cellInfo.cellY = -1;
 768         cellInfo.spanX = 0;
 769         cellInfo.spanY = 0;
 770         setTag(cellInfo);
 771     }
 772 
 773     public CellInfo getTag() {
 774         return (CellInfo) super.getTag();
 775     }
 776 
 777     /**
 778      * Given a point, return the cell that strictly encloses that point
 779      * @param x X coordinate of the point
 780      * @param y Y coordinate of the point
 781      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 782      */
 783     void pointToCellExact(int x, int y, int[] result) {
 784         final int hStartPadding = getPaddingLeft();
 785         final int vStartPadding = getPaddingTop();
 786 
 787         result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 788         result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 789 
 790         final int xAxis = mCountX;
 791         final int yAxis = mCountY;
 792 
 793         if (result[0] &lt; 0) result[0] = 0;
 794         if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 795         if (result[1] &lt; 0) result[1] = 0;
 796         if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 797     }
 798 
 799     /**
 800      * Given a point, return the cell that most closely encloses that point
 801      * @param x X coordinate of the point
 802      * @param y Y coordinate of the point
 803      * @param result Array of 2 ints to hold the x and y coordinate of the cell
 804      */
 805     void pointToCellRounded(int x, int y, int[] result) {
 806         pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 807     }
 808 
 809     /**
 810      * Given a cell coordinate, return the point that represents the upper left corner of that cell
 811      *
 812      * @param cellX X coordinate of the cell
 813      * @param cellY Y coordinate of the cell
 814      *
 815      * @param result Array of 2 ints to hold the x and y coordinate of the point
 816      */
 817     void cellToPoint(int cellX, int cellY, int[] result) {
 818         final int hStartPadding = getPaddingLeft();
 819         final int vStartPadding = getPaddingTop();
 820 
 821         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 822         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 823     }
 824 
 825     /**
 826      * Given a cell coordinate, return the point that represents the center of the cell
 827      *
 828      * @param cellX X coordinate of the cell
 829      * @param cellY Y coordinate of the cell
 830      *
 831      * @param result Array of 2 ints to hold the x and y coordinate of the point
 832      */
 833     void cellToCenterPoint(int cellX, int cellY, int[] result) {
 834         regionToCenterPoint(cellX, cellY, 1, 1, result);
 835     }
 836 
 837     /**
 838      * Given a cell coordinate and span return the point that represents the center of the regio
 839      *
 840      * @param cellX X coordinate of the cell
 841      * @param cellY Y coordinate of the cell
 842      *
 843      * @param result Array of 2 ints to hold the x and y coordinate of the point
 844      */
 845     void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 846         final int hStartPadding = getPaddingLeft();
 847         final int vStartPadding = getPaddingTop();
 848         result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 849                 (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 850         result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 851                 (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
 852     }
 853 
 854     /**
 855     * Given a cell coordinate and span fills out a corresponding pixel rect
 856     *
 857     * @param cellX X coordinate of the cell
 858     * @param cellY Y coordinate of the cell
 859     * @param result Rect in which to write the result
 860     */
 861     void regionToRect(int cellX, int cellY, int spanX, int spanY, Rect result) {
 862        final int hStartPadding = getPaddingLeft();
 863        final int vStartPadding = getPaddingTop();
 864        final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);
 865        final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);
 866        result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),
 867                top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
 868         }
 869 
 870     public float getDistanceFromCell(float x, float y, int[] cell) {
 871         cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 872         float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 873                 Math.pow(y - mTmpPoint[1], 2));
 874         return distance;
 875     }
 876 
 877     int getCellWidth() {
 878         return mCellWidth;
 879     }
 880 
 881     int getCellHeight() {
 882         return mCellHeight;
 883     }
 884 
 885     int getWidthGap() {
 886         return mWidthGap;
 887     }
 888 
 889     int getHeightGap() {
 890         return mHeightGap;
 891     }
 892 
 893     Rect getContentRect(Rect r) {
 894         if (r == null) {
 895             r = new Rect();
 896         }
 897         int left = getPaddingLeft();
 898         int top = getPaddingTop();
 899         int right = left + getWidth() - getPaddingLeft() - getPaddingRight();
 900         int bottom = top + getHeight() - getPaddingTop() - getPaddingBottom();
 901         r.set(left, top, right, bottom);
 902         return r;
 903     }
 904 
 905     static void getMetrics(Rect metrics, Resources res, int measureWidth, int measureHeight,
 906             int countX, int countY, int orientation) {
 907         int numWidthGaps = countX - 1;
 908         int numHeightGaps = countY - 1;
 909 
 910         int widthGap;
 911         int heightGap;
 912         int cellWidth;
 913         int cellHeight;
 914         int paddingLeft;
 915         int paddingRight;
 916         int paddingTop;
 917         int paddingBottom;
 918 
 919         int maxGap = res.getDimensionPixelSize(R.dimen.workspace_max_gap);
 920         if (orientation == LANDSCAPE) {
 921             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_land);
 922             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_land);
 923             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_land);
 924             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_land);
 925             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_land);
 926             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_land);
 927             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_land);
 928             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_land);
 929         } else {
 930             // PORTRAIT
 931             cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_port);
 932             cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_port);
 933             widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_port);
 934             heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_port);
 935             paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_port);
 936             paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_port);
 937             paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_port);
 938             paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_port);
 939         }
 940 
 941         if (widthGap &lt; 0 || heightGap &lt; 0) {
 942             int hSpace = measureWidth - paddingLeft - paddingRight;
 943             int vSpace = measureHeight - paddingTop - paddingBottom;
 944             int hFreeSpace = hSpace - (countX * cellWidth);
 945             int vFreeSpace = vSpace - (countY * cellHeight);
 946             widthGap = Math.min(maxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 947             heightGap = Math.min(maxGap, numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 948         }
 949         metrics.set(cellWidth, cellHeight, widthGap, heightGap);
 950     }
 951 
 952     @Override
 953     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 954         int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 955         int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 956 
 957         int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 958         int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 959 
 960         if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 961             throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 962         }
 963 
 964         int numWidthGaps = mCountX - 1;
 965         int numHeightGaps = mCountY - 1;
 966 
 967         if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 968             int hSpace = widthSpecSize - getPaddingLeft() - getPaddingRight();
 969             int vSpace = heightSpecSize - getPaddingTop() - getPaddingBottom();
 970             int hFreeSpace = hSpace - (mCountX * mCellWidth);
 971             int vFreeSpace = vSpace - (mCountY * mCellHeight);
 972             mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 973             mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 974             mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 975         } else {
 976             mWidthGap = mOriginalWidthGap;
 977             mHeightGap = mOriginalHeightGap;
 978         }
 979 
 980         // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 981         int newWidth = widthSpecSize;
 982         int newHeight = heightSpecSize;
 983         if (widthSpecMode == MeasureSpec.AT_MOST) {
 984             newWidth = getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
 985                 ((mCountX - 1) * mWidthGap);
 986             newHeight = getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
 987                 ((mCountY - 1) * mHeightGap);
 988             setMeasuredDimension(newWidth, newHeight);
 989         }
 990 
 991         int count = getChildCount();
 992         for (int i = 0; i &lt; count; i++) {
 993             View child = getChildAt(i);
 994             int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - getPaddingLeft() -
 995                     getPaddingRight(), MeasureSpec.EXACTLY);
 996             int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - getPaddingTop() -
 997                     getPaddingBottom(), MeasureSpec.EXACTLY);
 998             child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 999         }
1000         setMeasuredDimension(newWidth, newHeight);
1001     }
1002 
1003     @Override
1004     protected void onLayout(boolean changed, int l, int t, int r, int b) {
1005         int count = getChildCount();
1006         for (int i = 0; i &lt; count; i++) {
1007             View child = getChildAt(i);
1008             child.layout(getPaddingLeft(), getPaddingTop(),
1009                     r - l - getPaddingRight(), b - t - getPaddingBottom());
1010         }
1011     }
1012 
1013     @Override
1014     protected void onSizeChanged(int w, int h, int oldw, int oldh) {
1015         super.onSizeChanged(w, h, oldw, oldh);
1016         mBackgroundRect.set(0, 0, w, h);
1017         mForegroundRect.set(mForegroundPadding, mForegroundPadding,
1018                 w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
1019     }
1020 
1021     @Override
1022     protected void setChildrenDrawingCacheEnabled(boolean enabled) {
1023         mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
1024     }
1025 
1026     @Override
1027     protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1028         mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
1029     }
1030 
1031     public float getBackgroundAlpha() {
1032         return mBackgroundAlpha;
1033     }
1034 
1035     public void setBackgroundAlphaMultiplier(float multiplier) {
1036         if (mBackgroundAlphaMultiplier != multiplier) {
1037             mBackgroundAlphaMultiplier = multiplier;
1038             invalidate();
1039         }
1040     }
1041 
1042     public float getBackgroundAlphaMultiplier() {
1043         return mBackgroundAlphaMultiplier;
1044     }
1045 
1046     public void setBackgroundAlpha(float alpha) {
1047         if (mBackgroundAlpha != alpha) {
1048             mBackgroundAlpha = alpha;
1049             invalidate();
1050         }
1051     }
1052 
1053     public void setShortcutAndWidgetAlpha(float alpha) {
1054         final int childCount = getChildCount();
1055         for (int i = 0; i &lt; childCount; i++) {
1056             getChildAt(i).setAlpha(alpha);
1057         }
1058     }
1059 
1060     public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1061         if (getChildCount() &gt; 0) {
1062             return (ShortcutAndWidgetContainer) getChildAt(0);
1063         }
1064         return null;
1065     }
1066 
1067     public View getChildAt(int x, int y) {
1068         return mShortcutsAndWidgets.getChildAt(x, y);
1069     }
1070 
<abbr title="1071     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration, int delay, boolean permanent, boolean adjustOccupied) {">1071     public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration, int delay🔵</abbr>
1072         ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1073         boolean[][] occupied = mOccupied;
1074         if (!permanent) {
1075             occupied = mTmpOccupied;
1076         }
1077         if (clc.indexOfChild(child) != (-1)) {
1078             final LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1079             final ItemInfo info = ((ItemInfo) (child.getTag()));
1080             // We cancel any existing animations
1081             if (mReorderAnimators.containsKey(lp)) {
1082                 mReorderAnimators.get(lp).cancel();
1083                 mReorderAnimators.remove(lp);
1084             }
1085             final int oldX = lp.x;
1086             final int oldY = lp.y;
1087             if (adjustOccupied) {
1088                 occupied[lp.cellX][lp.cellY] = false;
1089                 occupied[cellX][cellY] = true;
1090             }
1091             lp.isLockedToGrid = true;
1092             if (permanent) {
1093                 lp.cellX = info.cellX = cellX;
1094                 lp.cellY = info.cellY = cellY;
1095             } else {
1096                 lp.tmpCellX = cellX;
1097                 lp.tmpCellY = cellY;
1098             }
1099             clc.setupLp(lp);
1100             lp.isLockedToGrid = false;
1101             final int newX = lp.x;
1102             final int newY = lp.y;
1103             lp.x = oldX;
1104             lp.y = oldY;
1105             // Exit early if we&#x27;re not actually moving the view
1106             if ((oldX == newX) &amp;&amp; (oldY == newY)) {
1107                 lp.isLockedToGrid = true;
1108                 return true;
1109             }
1110             ValueAnimator va = LauncherAnimUtils.ofFloat(0.0F, 1.0F);
1111             va.setDuration(duration);
1112             mReorderAnimators.put(lp, va);
1113             va.addUpdateListener(new AnimatorUpdateListener() {
1114                 @Override
1115                 public void onAnimationUpdate(ValueAnimator animation) {
1116                     float r = ((Float) (animation.getAnimatedValue())).floatValue();
1117                     lp.x = ((int) (((1 - r) * oldX) + (r * newX)));
1118                     lp.y = ((int) (((1 - r) * oldY) + (r * newY)));
1119                     child.requestLayout();
1120                 }
1121             });
1122             va.addListener(new AnimatorListenerAdapter() {
1123                 boolean cancelled = false;
1124 
1125                 public void onAnimationEnd(Animator animation) {
1126                     // If the animation was cancelled, it means that another animation
1127                     // has interrupted this one, and we don&#x27;t want to lock the item into
1128                     // place just yet.
1129                     if (!cancelled) {
1130                         lp.isLockedToGrid = true;
1131                         child.requestLayout();
1132                     }
1133                     if (mReorderAnimators.containsKey(lp)) {
1134                         mReorderAnimators.remove(lp);
1135                     }
1136                 }
1137 
1138                 public void onAnimationCancel(Animator animation) {
1139                     cancelled = true;
1140                 }
1141             });
1142             va.setStartDelay(delay);
1143             va.start();
1144             return true;
1145         }
1146         return false;
1147     }
1148 
1149     /**
1150      * Estimate where the top left cell of the dragged item will land if it is dropped.
1151      *
1152      * @param originX The X value of the top left corner of the item
1153      * @param originY The Y value of the top left corner of the item
1154      * @param spanX The number of horizontal cells that the item spans
1155      * @param spanY The number of vertical cells that the item spans
1156      * @param result The estimated drop cell X and Y.
1157      */
1158     void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1159         final int countX = mCountX;
1160         final int countY = mCountY;
1161 
1162         // pointToCellRounded takes the top left of a cell but will pad that with
1163         // cellWidth/2 and cellHeight/2 when finding the matching cell
1164         pointToCellRounded(originX, originY, result);
1165 
1166         // If the item isn&#x27;t fully on this screen, snap to the edges
1167         int rightOverhang = result[0] + spanX - countX;
1168         if (rightOverhang &gt; 0) {
1169             result[0] -= rightOverhang; // Snap to right
1170         }
1171         result[0] = Math.max(0, result[0]); // Snap to left
1172         int bottomOverhang = result[1] + spanY - countY;
1173         if (bottomOverhang &gt; 0) {
1174             result[1] -= bottomOverhang; // Snap to bottom
1175         }
1176         result[1] = Math.max(0, result[1]); // Snap to top
1177     }
1178 
1179     void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1180             int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1181         final int oldDragCellX = mDragCell[0];
1182         final int oldDragCellY = mDragCell[1];
1183 
1184         if (v != null &amp;&amp; dragOffset == null) {
1185             mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1186         } else {
1187             mDragCenter.set(originX, originY);
1188         }
1189 
1190         if (dragOutline == null &amp;&amp; v == null) {
1191             return;
1192         }
1193 
1194         if (cellX != oldDragCellX || cellY != oldDragCellY) {
1195             mDragCell[0] = cellX;
1196             mDragCell[1] = cellY;
1197             // Find the top left corner of the rect the object will occupy
1198             final int[] topLeft = mTmpPoint;
1199             cellToPoint(cellX, cellY, topLeft);
1200 
1201             int left = topLeft[0];
1202             int top = topLeft[1];
1203 
1204             if (v != null &amp;&amp; dragOffset == null) {
1205                 // When drawing the drag outline, it did not account for margin offsets
1206                 // added by the view&#x27;s parent.
1207                 MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1208                 left += lp.leftMargin;
1209                 top += lp.topMargin;
1210 
1211                 // Offsets due to the size difference between the View and the dragOutline.
1212                 // There is a size difference to account for the outer blur, which may lie
1213                 // outside the bounds of the view.
1214                 top += (v.getHeight() - dragOutline.getHeight()) / 2;
1215                 // We center about the x axis
1216                 left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1217                         - dragOutline.getWidth()) / 2;
1218             } else {
1219                 if (dragOffset != null &amp;&amp; dragRegion != null) {
1220                     // Center the drag region *horizontally* in the cell and apply a drag
1221                     // outline offset
1222                     left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1223                              - dragRegion.width()) / 2;
1224                     top += dragOffset.y;
1225                 } else {
1226                     // Center the drag outline in the cell
1227                     left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1228                             - dragOutline.getWidth()) / 2;
1229                     top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1230                             - dragOutline.getHeight()) / 2;
1231                 }
1232             }
1233             final int oldIndex = mDragOutlineCurrent;
1234             mDragOutlineAnims[oldIndex].animateOut();
1235             mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1236             Rect r = mDragOutlines[mDragOutlineCurrent];
1237             r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1238             if (resize) {
1239                 cellToRect(cellX, cellY, spanX, spanY, r);
1240             }
1241 
1242             mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1243             mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1244         }
1245     }
1246 
1247     public void clearDragOutlines() {
1248         final int oldIndex = mDragOutlineCurrent;
1249         mDragOutlineAnims[oldIndex].animateOut();
1250         mDragCell[0] = mDragCell[1] = -1;
1251     }
1252 
1253     /**
1254      * Find a vacant area that will fit the given bounds nearest the requested
1255      * cell location. Uses Euclidean distance to score multiple vacant areas.
1256      *
1257      * @param pixelX The X location at which you want to search for a vacant area.
1258      * @param pixelY The Y location at which you want to search for a vacant area.
1259      * @param spanX Horizontal span of the object.
1260      * @param spanY Vertical span of the object.
1261      * @param result Array in which to place the result, or null (in which case a new array will
1262      *        be allocated)
1263      * @return The X, Y cell of a vacant area that can contain this object,
1264      *         nearest the requested location.
1265      */
1266     int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1267             int[] result) {
1268         return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1269     }
1270 
1271     /**
1272      * Find a vacant area that will fit the given bounds nearest the requested
1273      * cell location. Uses Euclidean distance to score multiple vacant areas.
1274      *
1275      * @param pixelX The X location at which you want to search for a vacant area.
1276      * @param pixelY The Y location at which you want to search for a vacant area.
1277      * @param minSpanX The minimum horizontal span required
1278      * @param minSpanY The minimum vertical span required
1279      * @param spanX Horizontal span of the object.
1280      * @param spanY Vertical span of the object.
1281      * @param result Array in which to place the result, or null (in which case a new array will
1282      *        be allocated)
1283      * @return The X, Y cell of a vacant area that can contain this object,
1284      *         nearest the requested location.
1285      */
1286     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1287             int spanY, int[] result, int[] resultSpan) {
1288         return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1289                 result, resultSpan);
1290     }
1291 
1292     /**
1293      * Find a vacant area that will fit the given bounds nearest the requested
1294      * cell location. Uses Euclidean distance to score multiple vacant areas.
1295      *
1296      * @param pixelX The X location at which you want to search for a vacant area.
1297      * @param pixelY The Y location at which you want to search for a vacant area.
1298      * @param spanX Horizontal span of the object.
1299      * @param spanY Vertical span of the object.
1300      * @param ignoreOccupied If true, the result can be an occupied cell
1301      * @param result Array in which to place the result, or null (in which case a new array will
1302      *        be allocated)
1303      * @return The X, Y cell of a vacant area that can contain this object,
1304      *         nearest the requested location.
1305      */
1306     int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1307             boolean ignoreOccupied, int[] result) {
1308         return findNearestArea(pixelX, pixelY, spanX, spanY,
1309                 spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1310     }
1311 
1312     private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1313 
1314     private void lazyInitTempRectStack() {
1315         if (mTempRectStack.isEmpty()) {
1316             for (int i = 0; i &lt; mCountX * mCountY; i++) {
1317                 mTempRectStack.push(new Rect());
1318             }
1319         }
1320     }
1321 
1322     private void recycleTempRects(Stack&lt;Rect&gt; used) {
1323         while (!used.isEmpty()) {
1324             mTempRectStack.push(used.pop());
1325         }
1326     }
1327 
1328     /**
1329      * Find a vacant area that will fit the given bounds nearest the requested
1330      * cell location. Uses Euclidean distance to score multiple vacant areas.
1331      *
1332      * @param pixelX The X location at which you want to search for a vacant area.
1333      * @param pixelY The Y location at which you want to search for a vacant area.
1334      * @param minSpanX The minimum horizontal span required
1335      * @param minSpanY The minimum vertical span required
1336      * @param spanX Horizontal span of the object.
1337      * @param spanY Vertical span of the object.
1338      * @param ignoreOccupied If true, the result can be an occupied cell
1339      * @param result Array in which to place the result, or null (in which case a new array will
1340      *        be allocated)
1341      * @return The X, Y cell of a vacant area that can contain this object,
1342      *         nearest the requested location.
1343      */
1344     int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1345             View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1346             boolean[][] occupied) {
1347         lazyInitTempRectStack();
1348         // mark space take by ignoreView as available (method checks if ignoreView is null)
1349         markCellsAsUnoccupiedForView(ignoreView, occupied);
1350 
1351         // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1352         // to the center of the item, but we are searching based on the top-left cell, so
1353         // we translate the point over to correspond to the top-left.
1354         pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1355         pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1356 
1357         // Keep track of best-scoring drop area
1358         final int[] bestXY = result != null ? result : new int[2];
1359         double bestDistance = Double.MAX_VALUE;
1360         final Rect bestRect = new Rect(-1, -1, -1, -1);
1361         final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1362 
1363         final int countX = mCountX;
1364         final int countY = mCountY;
1365 
1366         if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1367                 spanX &lt; minSpanX || spanY &lt; minSpanY) {
1368             return bestXY;
1369         }
1370 
1371         for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1372             inner:
1373             for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1374                 int ySize = -1;
1375                 int xSize = -1;
1376                 if (ignoreOccupied) {
1377                     // First, let&#x27;s see if this thing fits anywhere
1378                     for (int i = 0; i &lt; minSpanX; i++) {
1379                         for (int j = 0; j &lt; minSpanY; j++) {
1380                             if (occupied[x + i][y + j]) {
1381                                 continue inner;
1382                             }
1383                         }
1384                     }
1385                     xSize = minSpanX;
1386                     ySize = minSpanY;
1387 
1388                     // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1389                     // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1390                     // until we hit a limit.
1391                     boolean incX = true;
1392                     boolean hitMaxX = xSize &gt;= spanX;
1393                     boolean hitMaxY = ySize &gt;= spanY;
1394                     while (!(hitMaxX &amp;&amp; hitMaxY)) {
1395                         if (incX &amp;&amp; !hitMaxX) {
1396                             for (int j = 0; j &lt; ySize; j++) {
1397                                 if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1398                                     // We can&#x27;t move out horizontally
1399                                     hitMaxX = true;
1400                                 }
1401                             }
1402                             if (!hitMaxX) {
1403                                 xSize++;
1404                             }
1405                         } else if (!hitMaxY) {
1406                             for (int i = 0; i &lt; xSize; i++) {
1407                                 if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1408                                     // We can&#x27;t move out vertically
1409                                     hitMaxY = true;
1410                                 }
1411                             }
1412                             if (!hitMaxY) {
1413                                 ySize++;
1414                             }
1415                         }
1416                         hitMaxX |= xSize &gt;= spanX;
1417                         hitMaxY |= ySize &gt;= spanY;
1418                         incX = !incX;
1419                     }
1420                     incX = true;
1421                     hitMaxX = xSize &gt;= spanX;
1422                     hitMaxY = ySize &gt;= spanY;
1423                 }
1424                 final int[] cellXY = mTmpXY;
1425                 cellToCenterPoint(x, y, cellXY);
1426 
1427                 // We verify that the current rect is not a sub-rect of any of our previous
1428                 // candidates. In this case, the current rect is disqualified in favour of the
1429                 // containing rect.
1430                 Rect currentRect = mTempRectStack.pop();
1431                 currentRect.set(x, y, x + xSize, y + ySize);
1432                 boolean contained = false;
1433                 for (Rect r : validRegions) {
1434                     if (r.contains(currentRect)) {
1435                         contained = true;
1436                         break;
1437                     }
1438                 }
1439                 validRegions.push(currentRect);
1440                 double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1441                         + Math.pow(cellXY[1] - pixelY, 2));
1442 
1443                 if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1444                         currentRect.contains(bestRect)) {
1445                     bestDistance = distance;
1446                     bestXY[0] = x;
1447                     bestXY[1] = y;
1448                     if (resultSpan != null) {
1449                         resultSpan[0] = xSize;
1450                         resultSpan[1] = ySize;
1451                     }
1452                     bestRect.set(currentRect);
1453                 }
1454             }
1455         }
1456         // re-mark space taken by ignoreView as occupied
1457         markCellsAsOccupiedForView(ignoreView, occupied);
1458 
1459         // Return -1, -1 if no suitable location found
1460         if (bestDistance == Double.MAX_VALUE) {
1461             bestXY[0] = -1;
1462             bestXY[1] = -1;
1463         }
1464         recycleTempRects(validRegions);
1465         return bestXY;
1466     }
1467 
1468     /**
1469     * Find a vacant area that will fit the given bounds nearest the requested
1470     * cell location, and will also weigh in a suggested direction vector of the
1471     * desired location. This method computers distance based on unit grid distances,
1472     * not pixel distances.
1473     *
1474     * @param cellX The X cell nearest to which you want to search for a vacant area.
1475     * @param cellY The Y cell nearest which you want to search for a vacant area.
1476     * @param spanX Horizontal span of the object.
1477     * @param spanY Vertical span of the object.
1478     * @param direction The favored direction in which the views should move from x, y
1479     * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1480     *        matches exactly. Otherwise we find the best matching direction.
1481     * @param occoupied The array which represents which cells in the CellLayout are occupied
1482     * @param blockOccupied The array which represents which cells in the specified block (cellX,
1483     *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.
1484     * @param result Array in which to place the result, or null (in which case a new array will
1485     *        be allocated)
1486     * @return The X, Y cell of a vacant area that can contain this object,
1487     *         nearest the requested location.
1488     */
1489         private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1490            boolean[][] occupied, boolean blockOccupied[][], int[] result) {
1491        // Keep track of best-scoring drop area
1492        final int[] bestXY = result != null ? result : new int[2];
1493        float bestDistance = Float.MAX_VALUE;
1494        int bestDirectionScore = Integer.MIN_VALUE;
1495 
1496        final int countX = mCountX;
1497        final int countY = mCountY;
1498 
1499        for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1500            inner:
1501            for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1502                // First, let&#x27;s see if this thing fits anywhere
1503                for (int i = 0; i &lt; spanX; i++) {
1504                    for (int j = 0; j &lt; spanY; j++) {
1505                        if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1506                            continue inner;
1507                        }
1508                    }
1509                }
1510 
1511                float distance = (float)
1512                        Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1513                int[] curDirection = mTmpPoint;
1514                computeDirectionVector(x - cellX, y - cellY, curDirection);
1515                // The direction score is just the dot product of the two candidate direction
1516                // and that passed in.
1517                int curDirectionScore = direction[0] * curDirection[0] +
1518                        direction[1] * curDirection[1];
1519                boolean exactDirectionOnly = false;
1520                boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1521                        direction[0] == curDirection[0];
1522                if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1523                        Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1524                        bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1525                    bestDistance = distance;
1526                    bestDirectionScore = curDirectionScore;
1527                    bestXY[0] = x;
1528                    bestXY[1] = y;
1529                }
1530            }
1531        }
1532 
1533        // Return -1, -1 if no suitable location found
1534        if (bestDistance == Float.MAX_VALUE) {
1535            bestXY[0] = -1;
1536            bestXY[1] = -1;
1537        }
1538        return bestXY;
1539         }
1540 
1541     private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,
1542             int[] direction,boolean[][] occupied,
1543             boolean blockOccupied[][], int[] result) {
1544         // Keep track of best-scoring drop area
1545         final int[] bestXY = result != null ? result : new int[2];
1546         bestXY[0] = -1;
1547         bestXY[1] = -1;
1548         float bestDistance = Float.MAX_VALUE;
1549 
1550         // We use this to march in a single direction
1551         if ((direction[0] != 0 &amp;&amp; direction[1] != 0) ||
1552                 (direction[0] == 0 &amp;&amp; direction[1] == 0)) {
1553             return bestXY;
1554         }
1555 
1556         // This will only incrememnet one of x or y based on the assertion above
1557         int x = cellX + direction[0];
1558         int y = cellY + direction[1];
1559         while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
1560 
1561             boolean fail = false;
1562             for (int i = 0; i &lt; spanX; i++) {
1563                 for (int j = 0; j &lt; spanY; j++) {
1564                     if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1565                         fail = true;
1566                     }
1567                 }
1568             }
1569             if (!fail) {
1570                 float distance = (float)
1571                         Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1572                 if (Float.compare(distance,  bestDistance) &lt; 0) {
1573                     bestDistance = distance;
1574                     bestXY[0] = x;
1575                     bestXY[1] = y;
1576                 }
1577             }
1578             x += direction[0];
1579             y += direction[1];
1580         }
1581         return bestXY;
1582     }
1583 
1584     private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1585             int[] direction, ItemConfiguration currentState) {
1586         CellAndSpan c = currentState.map.get(v);
1587         boolean success = false;
1588         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1589         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1590 
1591         findNearestArea(c.x, c.y, c.spanX, c.spanY, direction, mTmpOccupied, null, mTempLocation);
1592 
1593         if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1594             c.x = mTempLocation[0];
1595             c.y = mTempLocation[1];
1596             success = true;
1597 
1598         }
1599         markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1600         return success;
1601     }
1602 
1603     // This method looks in the specified direction to see if there are additional views adjacent
1604     // to the current set of views in the. If there is, then these views are added to the current
1605     // set of views. This is performed iteratively, giving a cascading push behaviour.
<abbr title="1606     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction, boolean[][] occupied, View dragView, ItemConfiguration currentState) {">1606     private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction, boolean🔵</abbr>
1607         boolean found = false;
1608         int childCount = mShortcutsAndWidgets.getChildCount();
1609         Rect r0 = new Rect(boundingRect);
1610         Rect r1 = new Rect();
1611         // First, we consider the rect of the views that we are trying to translate
1612         int deltaX = 0;
1613         int deltaY = 0;
1614         if (direction[1] &lt; 0) {
1615             r0.set(r0.left, r0.top - 1, r0.right, r0.bottom - 1);
1616             deltaY = -1;
1617         } else if (direction[1] &gt; 0) {
1618             r0.set(r0.left, r0.top + 1, r0.right, r0.bottom + 1);
1619             deltaY = 1;
1620         } else if (direction[0] &lt; 0) {
1621             r0.set(r0.left - 1, r0.top, r0.right - 1, r0.bottom);
1622             deltaX = -1;
1623         } else if (direction[0] &gt; 0) {
1624             r0.set(r0.left + 1, r0.top, r0.right + 1, r0.bottom);
1625             deltaX = 1;
1626         }
1627         // Now we see which views, if any, are being overlapped by shifting the current group
1628         // of views in the desired direction.
1629         for (int i = 0; i &lt; childCount; i++) {
1630             // We don&#x27;t need to worry about views already in our group, or the current drag view.
1631             View child = mShortcutsAndWidgets.getChildAt(i);
1632             if (views.contains(child) || (child == dragView)) {
1633                 continue;
1634             }
1635             CellAndSpan c = currentState.map.get(child);
1636             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
1637             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1638             if (Rect.intersects(r0, r1)) {
1639                 if (!lp.canReorder) {
1640                     return false;
1641                 }
1642                 // First we verify that the view in question is at the border of the extents
1643                 // of the block of items we are pushing
<abbr title="1644                 if (((((direction[0] &lt; 0) &amp;&amp; (c.x == r0.left)) || ((direction[0] &gt; 0) &amp;&amp; (c.x == (r0.right - 1)))) || ((direction[1] &lt; 0) &amp;&amp; (c.y == r0.top))) || ((direction[1] &gt; 0) &amp;&amp; (c.y == (r0.bottom - 1)))) {">1644                 if (((((direction[0] &lt; 0) &amp;&amp; (c.x == r0.left)) || ((direction[0] &gt; 0) &amp;&amp; (c.x == (r0.righ🔵</abbr>
1645                     boolean pushed = false;
1646                     // Since the bounding rect is a course description of the region (there can
1647                     // be holes at the edge of the block), we need to check to verify that a solid
1648                     // piece is intersecting. This ensures that interlocking is possible.
1649                     for (int x = c.x; x &lt; (c.x + c.spanX); x++) {
1650                         for (int y = c.y; y &lt; (c.y + c.spanY); y++) {
1651                             if (occupied[x - deltaX][y - deltaY]) {
1652                                 pushed = true;
1653                                 break;
1654                             }
1655                             if (pushed) {
1656                                 break;
1657                             }
1658                         }
1659                     }
1660                     if (pushed) {
1661                         views.add(child);
1662                         boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1663                         found = true;
1664                     }
1665                 }
1666             }
1667         }
1668         return found;
1669     }
1670 
<abbr title="1671     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop, int[] direction, boolean push, View dragView, ItemConfiguration currentState) {">1671     private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop, int[]🔵</abbr>
1672         if (views.size() == 0) {
1673             return true;
1674         }
1675         boolean success = false;
1676         Rect boundingRect = null;
1677         // We construct a rect which represents the entire group of views passed in
1678         for (View v : views) {
1679             CellAndSpan c = currentState.map.get(v);
1680             if (boundingRect == null) {
1681                 boundingRect = new Rect(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1682             } else {
1683                 boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1684             }
1685         }
1686         @SuppressWarnings(&quot;unchecked&quot;)
1687         ArrayList&lt;View&gt; dup = ((ArrayList&lt;View&gt;) (views.clone()));
1688         // We try and expand the group of views in the direction vector passed, based on
1689         // whether they are physically adjacent, ie. based on &quot;push mechanics&quot;.
<abbr title="1690         while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView, currentState)) {">1690         while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView, currentSt🔵</abbr>
1691         }
1692         // Mark the occupied state as false for the group of views we want to move.
1693         for (View v : dup) {
1694             CellAndSpan c = currentState.map.get(v);
1695             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1696         }
1697         boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1698         int top = boundingRect.top;
1699         int left = boundingRect.left;
1700         // We mark more precisely which parts of the bounding rect are truly occupied, allowing
1701         // for interlocking.
1702         for (View v : dup) {
1703             CellAndSpan c = currentState.map.get(v);
1704             markCellsForView(c.x - left, c.y - top, c.spanX, c.spanY, blockOccupied, true);
1705         }
1706         markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1707         if (push) {
<abbr title="1708             findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);">1708             findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(), boundin🔵</abbr>
1709         } else {
<abbr title="1710             findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);">1710             findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(), boundingRect.heigh🔵</abbr>
1711         }
1712         // If we successfuly found a location by pushing the block of views, we commit it
1713         if ((mTempLocation[0] &gt;= 0) &amp;&amp; (mTempLocation[1] &gt;= 0)) {
1714             int deltaX = mTempLocation[0] - boundingRect.left;
1715             int deltaY = mTempLocation[1] - boundingRect.top;
1716             for (View v : dup) {
1717                 CellAndSpan c = currentState.map.get(v);
1718                 c.x += deltaX;
1719                 c.y += deltaY;
1720             }
1721             success = true;
1722         }
1723         // In either case, we set the occupied array as marked for the location of the views
1724         for (View v : dup) {
1725             CellAndSpan c = currentState.map.get(v);
1726             markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1727         }
1728         return success;
1729     }
1730 
1731     private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1732         markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1733     }
1734 
1735     // This method tries to find a reordering solution which satisfies the push mechanic by trying
1736     // to push items in each of the cardinal directions, in an order based on the direction vector
1737     // passed.
1738     private boolean attemptPushInDirection(ArrayList&lt;View&gt; intersectingViews, Rect occupied,
1739             int[] direction, View ignoreView, ItemConfiguration solution) {
1740         if ((Math.abs(direction[0]) + Math.abs(direction[1])) &gt; 1) {
1741             // If the direction vector has two non-zero components, we try pushing
1742             // separately in each of the components.
1743             int temp = direction[1];
1744             direction[1] = 0;
1745             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1746                     ignoreView, solution)) {
1747                 return true;
1748             }
1749             direction[1] = temp;
1750             temp = direction[0];
1751             direction[0] = 0;
1752             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1753                     ignoreView, solution)) {
1754                 return true;
1755             }
1756             // Revert the direction
1757             direction[0] = temp;
1758 
1759             // Now we try pushing in each component of the opposite direction
1760             direction[0] *= -1;
1761             direction[1] *= -1;
1762             temp = direction[1];
1763             direction[1] = 0;
1764             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1765                     ignoreView, solution)) {
1766                 return true;
1767             }
1768 
1769             direction[1] = temp;
1770             temp = direction[0];
1771             direction[0] = 0;
1772             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1773                     ignoreView, solution)) {
1774                 return true;
1775             }
1776             // revert the direction
1777             direction[0] = temp;
1778             direction[0] *= -1;
1779             direction[1] *= -1;
1780 
1781         } else {
1782             // If the direction vector has a single non-zero component, we push first in the
1783             // direction of the vector
1784             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1785                     ignoreView, solution)) {
1786                 return true;
1787             }
1788 
1789             // Then we try the opposite direction
1790             direction[0] *= -1;
1791             direction[1] *= -1;
1792             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1793                     ignoreView, solution)) {
1794                 return true;
1795             }
1796             // Switch the direction back
1797             direction[0] *= -1;
1798             direction[1] *= -1;
1799 
1800             // If we have failed to find a push solution with the above, then we try
1801             // to find a solution by pushing along the perpendicular axis.
1802 
1803             // Swap the components
1804             int temp = direction[1];
1805             direction[1] = direction[0];
1806             direction[0] = temp;
1807             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1808                     ignoreView, solution)) {
1809                 return true;
1810             }
1811 
1812             // Then we try the opposite direction
1813             direction[0] *= -1;
1814             direction[1] *= -1;
1815             if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1816                     ignoreView, solution)) {
1817                 return true;
1818             }
1819             // Switch the direction back
1820             direction[0] *= -1;
1821             direction[1] *= -1;
1822 
1823             // Swap the components back
1824             temp = direction[1];
1825             direction[1] = direction[0];
1826             direction[0] = temp;
1827         }
1828         return false;
1829     }
1830 
1831     private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1832             View ignoreView, ItemConfiguration solution) {
1833         // Return early if get invalid cell positions
1834         if (cellX &lt; 0 || cellY &lt; 0) return false;
1835 
1836         mIntersectingViews.clear();
1837         mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1838 
1839         // Mark the desired location of the view currently being dragged.
1840         if (ignoreView != null) {
1841             CellAndSpan c = solution.map.get(ignoreView);
1842             if (c != null) {
1843                 c.x = cellX;
1844                 c.y = cellY;
1845             }
1846         }
1847         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1848         Rect r1 = new Rect();
1849         for (View child: solution.map.keySet()) {
1850             if (child == ignoreView) continue;
1851             CellAndSpan c = solution.map.get(child);
1852             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1853             r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1854             if (Rect.intersects(r0, r1)) {
1855                 if (!lp.canReorder) {
1856                     return false;
1857                 }
1858                 mIntersectingViews.add(child);
1859             }
1860         }
1861 
1862         // First we try to find a solution which respects the push mechanic. That is,
1863         // we try to find a solution such that no displaced item travels through another item
1864         // without also displacing that item.
1865         if (attemptPushInDirection(mIntersectingViews, mOccupiedRect, direction, ignoreView,
1866                 solution)) {
1867             return true;
1868         }
1869 
1870         // Next we try moving the views as a block, but without requiring the push mechanic.
1871         if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction, false, ignoreView,
1872                 solution)) {
1873             return true;
1874         }
1875 
1876         // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1877         for (View v : mIntersectingViews) {
1878             if (!addViewToTempLocation(v, mOccupiedRect, direction, solution)) {
1879                 return false;
1880             }
1881         }
1882         return true;
1883     }
1884 
1885     /*
1886      * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1887      * the provided point and the provided cell
1888      */
1889     private void computeDirectionVector(float deltaX, float deltaY, int[] result) {
1890         double angle = Math.atan(((float) deltaY) / deltaX);
1891 
1892         result[0] = 0;
1893         result[1] = 0;
1894         if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1895             result[0] = (int) Math.signum(deltaX);
1896         }
1897         if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1898             result[1] = (int) Math.signum(deltaY);
1899         }
1900     }
1901 
1902     private void copyOccupiedArray(boolean[][] occupied) {
1903         for (int i = 0; i &lt; mCountX; i++) {
1904             for (int j = 0; j &lt; mCountY; j++) {
1905                 occupied[i][j] = mOccupied[i][j];
1906             }
1907         }
1908     }
1909 
1910     ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1911             int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1912         // Copy the current state into the solution. This solution will be manipulated as necessary.
1913         copyCurrentStateToSolution(solution, false);
1914         // Copy the current occupied array into the temporary occupied array. This array will be
1915         // manipulated as necessary to find a solution.
1916         copyOccupiedArray(mTmpOccupied);
1917 
1918         // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1919         // nothing in its way.
1920         int result[] = new int[2];
1921         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1922 
1923         boolean success = false;
1924         // First we try the exact nearest position of the item being dragged,
1925         // we will then want to try to move this around to other neighbouring positions
1926         success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView,
1927                 solution);
1928 
1929         if (!success) {
1930             // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1931             // x, then 1 in y etc.
1932             if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1933                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1934                         dragView, false, solution);
1935             } else if (spanY &gt; minSpanY) {
1936                 return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1937                         dragView, true, solution);
1938             }
1939             solution.isSolution = false;
1940         } else {
1941             solution.isSolution = true;
1942             solution.dragViewX = result[0];
1943             solution.dragViewY = result[1];
1944             solution.dragViewSpanX = spanX;
1945             solution.dragViewSpanY = spanY;
1946         }
1947         return solution;
1948     }
1949 
1950     private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1951         int childCount = mShortcutsAndWidgets.getChildCount();
1952         for (int i = 0; i &lt; childCount; i++) {
1953             View child = mShortcutsAndWidgets.getChildAt(i);
1954             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1955             CellAndSpan c;
1956             if (temp) {
1957                 c = new CellAndSpan(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan);
1958             } else {
1959                 c = new CellAndSpan(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan);
1960             }
1961             solution.map.put(child, c);
1962         }
1963     }
1964 
1965     private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1966         for (int i = 0; i &lt; mCountX; i++) {
1967             for (int j = 0; j &lt; mCountY; j++) {
1968                 mTmpOccupied[i][j] = false;
1969             }
1970         }
1971 
1972         int childCount = mShortcutsAndWidgets.getChildCount();
1973         for (int i = 0; i &lt; childCount; i++) {
1974             View child = mShortcutsAndWidgets.getChildAt(i);
1975             if (child == dragView) continue;
1976             LayoutParams lp = (LayoutParams) child.getLayoutParams();
1977             CellAndSpan c = solution.map.get(child);
1978             if (c != null) {
1979                 lp.tmpCellX = c.x;
1980                 lp.tmpCellY = c.y;
1981                 lp.cellHSpan = c.spanX;
1982                 lp.cellVSpan = c.spanY;
1983                 markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1984             }
1985         }
1986         markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1987                 solution.dragViewSpanY, mTmpOccupied, true);
1988     }
1989 
1990     private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1991             commitDragView) {
1992 
1993         boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1994         for (int i = 0; i &lt; mCountX; i++) {
1995             for (int j = 0; j &lt; mCountY; j++) {
1996                 occupied[i][j] = false;
1997             }
1998         }
1999 
2000         int childCount = mShortcutsAndWidgets.getChildCount();
2001         for (int i = 0; i &lt; childCount; i++) {
2002             View child = mShortcutsAndWidgets.getChildAt(i);
2003             if (child == dragView) continue;
2004             CellAndSpan c = solution.map.get(child);
2005             if (c != null) {
2006                 animateChildToPosition(child, c.x, c.y, REORDER_ANIMATION_DURATION, 0,
2007                         DESTRUCTIVE_REORDER, false);
2008                 markCellsForView(c.x, c.y, c.spanX, c.spanY, occupied, true);
2009             }
2010         }
2011         if (commitDragView) {
2012             markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2013                     solution.dragViewSpanY, occupied, true);
2014         }
2015     }
2016 
2017     // This method starts or changes the reorder hint animations
2018     private void beginOrAdjustHintAnimations(ItemConfiguration solution, View dragView, int delay) {
2019         int childCount = mShortcutsAndWidgets.getChildCount();
2020         for (int i = 0; i &lt; childCount; i++) {
2021             View child = mShortcutsAndWidgets.getChildAt(i);
2022             if (child == dragView) continue;
2023             CellAndSpan c = solution.map.get(child);
2024             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2025             if (c != null) {
2026                 ReorderHintAnimation rha = new ReorderHintAnimation(child, lp.cellX, lp.cellY,
2027                         c.x, c.y, c.spanX, c.spanY);
2028                 rha.animate();
2029             }
2030         }
2031     }
2032 
2033     // Class which represents the reorder hint animations. These animations show that an item is
2034     // in a temporary state, and hint at where the item will return to.
2035     class ReorderHintAnimation {
2036         View child;
2037 
2038         float finalDeltaX;
2039 
2040         float finalDeltaY;
2041 
2042         float initDeltaX;
2043 
2044         float initDeltaY;
2045 
2046         float finalScale;
2047 
2048         float initScale;
2049 
2050         private static final int DURATION = 300;
2051 
2052         Animator a;
2053 
<abbr title="2054         public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1, int spanX, int spanY) {">2054         public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1, int spanX🔵</abbr>
2055             regionToCenterPoint(cellX0, cellY0, spanX, spanY, mTmpPoint);
2056             final int x0 = mTmpPoint[0];
2057             final int y0 = mTmpPoint[1];
2058             regionToCenterPoint(cellX1, cellY1, spanX, spanY, mTmpPoint);
2059             final int x1 = mTmpPoint[0];
2060             final int y1 = mTmpPoint[1];
2061             final int dX = x1 - x0;
2062             final int dY = y1 - y0;
2063             finalDeltaX = 0;
2064             finalDeltaY = 0;
2065             if ((dX == dY) &amp;&amp; (dX == 0)) {
2066             } else if (dY == 0) {
2067                 finalDeltaX = (-Math.signum(dX)) * mReorderHintAnimationMagnitude;
2068             } else if (dX == 0) {
2069                 finalDeltaY = (-Math.signum(dY)) * mReorderHintAnimationMagnitude;
2070             } else {
2071                 double angle = Math.atan(((float) (dY)) / dX);
<abbr title="2072                 finalDeltaX = ((int) ((-Math.signum(dX)) * Math.abs(Math.cos(angle) * mReorderHintAnimationMagnitude)));">2072                 finalDeltaX = ((int) ((-Math.signum(dX)) * Math.abs(Math.cos(angle) * mReorderHintAnimati🔵</abbr>
<abbr title="2073                 finalDeltaY = ((int) ((-Math.signum(dY)) * Math.abs(Math.sin(angle) * mReorderHintAnimationMagnitude)));">2073                 finalDeltaY = ((int) ((-Math.signum(dY)) * Math.abs(Math.sin(angle) * mReorderHintAnimati🔵</abbr>
2074             }
2075             initDeltaX = child.getTranslationX();
2076             initDeltaY = child.getTranslationY();
2077             finalScale = 1.0F - (4.0F / child.getWidth());
2078             initScale = child.getScaleX();
2079             child.setPivotY(child.getMeasuredHeight() * 0.5F);
2080             child.setPivotX(child.getMeasuredWidth() * 0.5F);
2081             this.child = child;
2082         }
2083 
2084         void animate() {
2085             if (mShakeAnimators.containsKey(child)) {
2086                 ReorderHintAnimation oldAnimation = mShakeAnimators.get(child);
2087                 oldAnimation.cancel();
2088                 mShakeAnimators.remove(child);
2089                 if ((finalDeltaX == 0) &amp;&amp; (finalDeltaY == 0)) {
2090                     completeAnimationImmediately();
2091                     return;
2092                 }
2093             }
2094             if ((finalDeltaX == 0) &amp;&amp; (finalDeltaY == 0)) {
2095                 return;
2096             }
2097             ValueAnimator va = LauncherAnimUtils.ofFloat(0.0F, 1.0F);
2098             a = va;
2099             va.setRepeatMode(ValueAnimator.REVERSE);
2100             va.setRepeatCount(ValueAnimator.INFINITE);
2101             va.setDuration(DURATION);
2102             va.setStartDelay(((int) (Math.random() * 60)));
2103             va.addUpdateListener(new AnimatorUpdateListener() {
2104                 @Override
2105                 public void onAnimationUpdate(ValueAnimator animation) {
2106                     float r = ((Float) (animation.getAnimatedValue())).floatValue();
2107                     float x = (r * finalDeltaX) + ((1 - r) * initDeltaX);
2108                     float y = (r * finalDeltaY) + ((1 - r) * initDeltaY);
2109                     child.setTranslationX(x);
2110                     child.setTranslationY(y);
2111                     float s = (r * finalScale) + ((1 - r) * initScale);
2112                     child.setScaleX(s);
2113                     child.setScaleY(s);
2114                 }
2115             });
2116             va.addListener(new AnimatorListenerAdapter() {
2117                 public void onAnimationRepeat(Animator animation) {
2118                     // We make sure to end only after a full period
2119                     initDeltaX = 0;
2120                     initDeltaY = 0;
2121                     initScale = 1.0F;
2122                 }
2123             });
2124             mShakeAnimators.put(child, this);
2125             va.start();
2126         }
2127 
2128         private void cancel() {
2129             if (a != null) {
2130                 a.cancel();
2131             }
2132         }
2133 
2134         private void completeAnimationImmediately() {
2135             if (a != null) {
2136                 a.cancel();
2137             }
2138             AnimatorSet s = LauncherAnimUtils.createAnimatorSet();
2139             a = s;
<abbr title="2140             s.playTogether(LauncherAnimUtils.ofFloat(child, &quot;scaleX&quot;, 1.0F), LauncherAnimUtils.ofFloat(child, &quot;scaleY&quot;, 1.0F), LauncherAnimUtils.ofFloat(child, &quot;translationX&quot;, 0.0F), LauncherAnimUtils.ofFloat(child, &quot;translationY&quot;, 0.0F));">2140             s.playTogether(LauncherAnimUtils.ofFloat(child, &quot;scaleX&quot;, 1.0F), LauncherAnimUtils.ofFloat(ch🔵</abbr>
2141             s.setDuration(REORDER_ANIMATION_DURATION);
2142             s.setInterpolator(new DecelerateInterpolator(1.5F));
2143             s.start();
2144         }
2145     }
2146 
2147     private void completeAndClearReorderHintAnimations() {
2148         for (ReorderHintAnimation a: mShakeAnimators.values()) {
2149             a.completeAnimationImmediately();
2150         }
2151         mShakeAnimators.clear();
2152     }
2153 
2154     private void commitTempPlacement() {
2155         for (int i = 0; i &lt; mCountX; i++) {
2156             for (int j = 0; j &lt; mCountY; j++) {
2157                 mOccupied[i][j] = mTmpOccupied[i][j];
2158             }
2159         }
2160         int childCount = mShortcutsAndWidgets.getChildCount();
2161         for (int i = 0; i &lt; childCount; i++) {
2162             View child = mShortcutsAndWidgets.getChildAt(i);
2163             LayoutParams lp = ((LayoutParams) (child.getLayoutParams()));
2164             ItemInfo info = ((ItemInfo) (child.getTag()));
2165             // We do a null check here because the item info can be null in the case of the
2166             // AllApps button in the hotseat.
2167             if (info != null) {
<abbr title="2168                 if ((((info.cellX != lp.tmpCellX) || (info.cellY != lp.tmpCellY)) || (info.spanX != lp.cellHSpan)) || (info.spanY != lp.cellVSpan)) {">2168                 if ((((info.cellX != lp.tmpCellX) || (info.cellY != lp.tmpCellY)) || (info.spanX != lp.ce🔵</abbr>
2169                     info.requiresDbUpdate = true;
2170                 }
2171                 info.cellX = lp.cellX = lp.tmpCellX;
2172                 info.cellY = lp.cellY = lp.tmpCellY;
2173                 info.spanX = lp.cellHSpan;
2174                 info.spanY = lp.cellVSpan;
2175             }
2176         }
2177         mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
2178     }
2179 
2180     public void setUseTempCoords(boolean useTempCoords) {
2181         int childCount = mShortcutsAndWidgets.getChildCount();
2182         for (int i = 0; i &lt; childCount; i++) {
2183             LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2184             lp.useTmpCoords = useTempCoords;
2185         }
2186     }
2187 
2188     ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2189             int spanX, int spanY, View dragView, ItemConfiguration solution) {
2190         int[] result = new int[2];
2191         int[] resultSpan = new int[2];
2192         findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2193                 resultSpan);
2194         if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2195             copyCurrentStateToSolution(solution, false);
2196             solution.dragViewX = result[0];
2197             solution.dragViewY = result[1];
2198             solution.dragViewSpanX = resultSpan[0];
2199             solution.dragViewSpanY = resultSpan[1];
2200             solution.isSolution = true;
2201         } else {
2202             solution.isSolution = false;
2203         }
2204         return solution;
2205     }
2206 
2207     public void prepareChildForDrag(View child) {
2208         markCellsAsUnoccupiedForView(child);
2209     }
2210 
2211     /* This seems like it should be obvious and straight-forward, but when the direction vector
2212     needs to match with the notion of the dragView pushing other views, we have to employ
2213     a slightly more subtle notion of the direction vector. The question is what two points is
2214     the vector between? The center of the dragView and its desired destination? Not quite, as
2215     this doesn&#x27;t necessarily coincide with the interaction of the dragView and items occupying
2216     those cells. Instead we use some heuristics to often lock the vector to up, down, left
2217     or right, which helps make pushing feel right.
2218     */
2219     private void getDirectionVectorForDrop(int dragViewCenterX, int dragViewCenterY, int spanX,
2220             int spanY, View dragView, int[] resultDirection) {
2221         int[] targetDestination = new int[2];
2222 
2223         findNearestArea(dragViewCenterX, dragViewCenterY, spanX, spanY, targetDestination);
2224         Rect dragRect = new Rect();
2225         regionToRect(targetDestination[0], targetDestination[1], spanX, spanY, dragRect);
2226         dragRect.offset(dragViewCenterX - dragRect.centerX(), dragViewCenterY - dragRect.centerY());
2227 
2228         Rect dropRegionRect = new Rect();
2229         getViewsIntersectingRegion(targetDestination[0], targetDestination[1], spanX, spanY,
2230                 dragView, dropRegionRect, mIntersectingViews);
2231 
2232         int dropRegionSpanX = dropRegionRect.width();
2233         int dropRegionSpanY = dropRegionRect.height();
2234 
2235         regionToRect(dropRegionRect.left, dropRegionRect.top, dropRegionRect.width(),
2236                 dropRegionRect.height(), dropRegionRect);
2237 
2238         int deltaX = (dropRegionRect.centerX() - dragViewCenterX) / spanX;
2239         int deltaY = (dropRegionRect.centerY() - dragViewCenterY) / spanY;
2240 
2241         if (dropRegionSpanX == mCountX || spanX == mCountX) {
2242             deltaX = 0;
2243         }
2244         if (dropRegionSpanY == mCountY || spanY == mCountY) {
2245             deltaY = 0;
2246         }
2247 
2248         if (deltaX == 0 &amp;&amp; deltaY == 0) {
2249             // No idea what to do, give a random direction.
2250             resultDirection[0] = 1;
2251             resultDirection[1] = 0;
2252         } else {
2253             computeDirectionVector(deltaX, deltaY, resultDirection);
2254         }
2255     }
2256 
2257     // For a given cell and span, fetch the set of views intersecting the region.
2258     private void getViewsIntersectingRegion(int cellX, int cellY, int spanX, int spanY,
2259             View dragView, Rect boundingRect, ArrayList&lt;View&gt; intersectingViews) {
2260         if (boundingRect != null) {
2261             boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
2262         }
2263         intersectingViews.clear();
2264         Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
2265         Rect r1 = new Rect();
2266         final int count = mShortcutsAndWidgets.getChildCount();
2267         for (int i = 0; i &lt; count; i++) {
2268             View child = mShortcutsAndWidgets.getChildAt(i);
2269             if (child == dragView) continue;
2270             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2271             r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
2272             if (Rect.intersects(r0, r1)) {
2273                 mIntersectingViews.add(child);
2274                 if (boundingRect != null) {
2275                     boundingRect.union(r1);
2276                 }
2277             }
2278         }
2279     }
2280 
2281     boolean isNearestDropLocationOccupied(int pixelX, int pixelY, int spanX, int spanY,
2282             View dragView, int[] result) {
2283         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2284         getViewsIntersectingRegion(result[0], result[1], spanX, spanY, dragView, null,
2285                 mIntersectingViews);
2286         return !mIntersectingViews.isEmpty();
2287     }
2288 
2289     void revertTempState() {
2290         if (!isItemPlacementDirty() || DESTRUCTIVE_REORDER) return;
2291         final int count = mShortcutsAndWidgets.getChildCount();
2292         for (int i = 0; i &lt; count; i++) {
2293             View child = mShortcutsAndWidgets.getChildAt(i);
2294             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2295             if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
2296                 lp.tmpCellX = lp.cellX;
2297                 lp.tmpCellY = lp.cellY;
2298                 animateChildToPosition(child, lp.cellX, lp.cellY, REORDER_ANIMATION_DURATION,
2299                         0, false, false);
2300             }
2301         }
2302         completeAndClearReorderHintAnimations();
2303         setItemPlacementDirty(false);
2304     }
2305 
2306     boolean createAreaForResize(int cellX, int cellY, int spanX, int spanY,
2307             View dragView, int[] direction, boolean commit) {
2308         int[] pixelXY = new int[2];
2309         regionToCenterPoint(cellX, cellY, spanX, spanY, pixelXY);
2310 
2311         // First we determine if things have moved enough to cause a different layout
2312         ItemConfiguration swapSolution = simpleSwap(pixelXY[0], pixelXY[1], spanX, spanY,
2313                  spanX,  spanY, direction, dragView,  true,  new ItemConfiguration());
2314 
2315         setUseTempCoords(true);
2316         if (swapSolution != null &amp;&amp; swapSolution.isSolution) {
2317             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2318             // committing anything or animating anything as we just want to determine if a solution
2319             // exists
2320             copySolutionToTempState(swapSolution, dragView);
2321             setItemPlacementDirty(true);
2322             animateItemsToSolution(swapSolution, dragView, commit);
2323 
2324             if (commit) {
2325                 commitTempPlacement();
2326                 completeAndClearReorderHintAnimations();
2327                 setItemPlacementDirty(false);
2328             } else {
2329                 beginOrAdjustHintAnimations(swapSolution, dragView,
2330                         REORDER_ANIMATION_DURATION);
2331             }
2332             mShortcutsAndWidgets.requestLayout();
2333         }
2334         return swapSolution.isSolution;
2335     }
2336 
2337     int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2338             View dragView, int[] result, int resultSpan[], int mode) {
2339         // First we determine if things have moved enough to cause a different layout
2340         result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2341 
2342         if (resultSpan == null) {
2343             resultSpan = new int[2];
2344         }
2345 
2346         // When we are checking drop validity or actually dropping, we don&#x27;t recompute the
2347         // direction vector, since we want the solution to match the preview, and it&#x27;s possible
2348         // that the exact position of the item has changed to result in a new reordering outcome.
2349         if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP)
2350                &amp;&amp; mPreviousReorderDirection[0] != INVALID_DIRECTION) {
2351             mDirectionVector[0] = mPreviousReorderDirection[0];
2352             mDirectionVector[1] = mPreviousReorderDirection[1];
2353             // We reset this vector after drop
2354             if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2355                 mPreviousReorderDirection[0] = INVALID_DIRECTION;
2356                 mPreviousReorderDirection[1] = INVALID_DIRECTION;
2357             }
2358         } else {
2359             getDirectionVectorForDrop(pixelX, pixelY, spanX, spanY, dragView, mDirectionVector);
2360             mPreviousReorderDirection[0] = mDirectionVector[0];
2361             mPreviousReorderDirection[1] = mDirectionVector[1];
2362         }
2363 
2364         ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2365                  spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2366 
2367         // We attempt the approach which doesn&#x27;t shuffle views at all
2368         ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2369                 minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2370 
2371         ItemConfiguration finalSolution = null;
2372         if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2373             finalSolution = swapSolution;
2374         } else if (noShuffleSolution.isSolution) {
2375             finalSolution = noShuffleSolution;
2376         }
2377 
2378         boolean foundSolution = true;
2379         if (!DESTRUCTIVE_REORDER) {
2380             setUseTempCoords(true);
2381         }
2382 
2383         if (finalSolution != null) {
2384             result[0] = finalSolution.dragViewX;
2385             result[1] = finalSolution.dragViewY;
2386             resultSpan[0] = finalSolution.dragViewSpanX;
2387             resultSpan[1] = finalSolution.dragViewSpanY;
2388 
2389             // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2390             // committing anything or animating anything as we just want to determine if a solution
2391             // exists
2392             if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2393                 if (!DESTRUCTIVE_REORDER) {
2394                     copySolutionToTempState(finalSolution, dragView);
2395                 }
2396                 setItemPlacementDirty(true);
2397                 animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2398 
2399                 if (!DESTRUCTIVE_REORDER &amp;&amp;
2400                         (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
2401                     commitTempPlacement();
2402                     completeAndClearReorderHintAnimations();
2403                     setItemPlacementDirty(false);
2404                 } else {
2405                     beginOrAdjustHintAnimations(finalSolution, dragView,
2406                             REORDER_ANIMATION_DURATION);
2407                 }
2408             }
2409         } else {
2410             foundSolution = false;
2411             result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2412         }
2413 
2414         if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2415             setUseTempCoords(false);
2416         }
2417 
2418         mShortcutsAndWidgets.requestLayout();
2419         return result;
2420     }
2421 
2422     void setItemPlacementDirty(boolean dirty) {
2423         mItemPlacementDirty = dirty;
2424     }
2425 
2426     boolean isItemPlacementDirty() {
2427         return mItemPlacementDirty;
2428     }
2429 
2430     private class ItemConfiguration {
2431         HashMap&lt;View, CellAndSpan&gt; map = new HashMap&lt;View, CellAndSpan&gt;();
2432 
2433         boolean isSolution = false;
2434 
2435         int dragViewX;
2436 
2437         int dragViewY;
2438 
2439         int dragViewSpanX;
2440 
2441         int dragViewSpanY;
2442 
2443         int area() {
2444             return dragViewSpanX * dragViewSpanY;
2445         }
2446     }
2447 
2448     private class CellAndSpan {
2449         int x;
2450 
2451         int y;
2452 
2453         int spanX;
2454 
2455         int spanY;
2456 
2457         public CellAndSpan(int x, int y, int spanX, int spanY) {
2458             this.x = x;
2459             this.y = y;
2460             this.spanX = spanX;
2461             this.spanY = spanY;
2462         }
2463     }
2464 
2465     /**
2466      * Find a vacant area that will fit the given bounds nearest the requested
2467      * cell location. Uses Euclidean distance to score multiple vacant areas.
2468      *
2469      * @param pixelX The X location at which you want to search for a vacant area.
2470      * @param pixelY The Y location at which you want to search for a vacant area.
2471      * @param spanX Horizontal span of the object.
2472      * @param spanY Vertical span of the object.
2473      * @param ignoreView Considers space occupied by this view as unoccupied
2474      * @param result Previously returned value to possibly recycle.
2475      * @return The X, Y cell of a vacant area that can contain this object,
2476      *         nearest the requested location.
2477      */
2478     int[] findNearestVacantArea(
2479             int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2480         return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2481     }
2482 
2483     /**
2484      * Find a vacant area that will fit the given bounds nearest the requested
2485      * cell location. Uses Euclidean distance to score multiple vacant areas.
2486      *
2487      * @param pixelX The X location at which you want to search for a vacant area.
2488      * @param pixelY The Y location at which you want to search for a vacant area.
2489      * @param minSpanX The minimum horizontal span required
2490      * @param minSpanY The minimum vertical span required
2491      * @param spanX Horizontal span of the object.
2492      * @param spanY Vertical span of the object.
2493      * @param ignoreView Considers space occupied by this view as unoccupied
2494      * @param result Previously returned value to possibly recycle.
2495      * @return The X, Y cell of a vacant area that can contain this object,
2496      *         nearest the requested location.
2497      */
2498     int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2499             int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2500         return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2501                 result, resultSpan, mOccupied);
2502     }
2503 
2504     /**
2505      * Find a starting cell position that will fit the given bounds nearest the requested
2506      * cell location. Uses Euclidean distance to score multiple vacant areas.
2507      *
2508      * @param pixelX The X location at which you want to search for a vacant area.
2509      * @param pixelY The Y location at which you want to search for a vacant area.
2510      * @param spanX Horizontal span of the object.
2511      * @param spanY Vertical span of the object.
2512      * @param ignoreView Considers space occupied by this view as unoccupied
2513      * @param result Previously returned value to possibly recycle.
2514      * @return The X, Y cell of a vacant area that can contain this object,
2515      *         nearest the requested location.
2516      */
2517     int[] findNearestArea(
2518             int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2519         return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2520     }
2521 
2522     boolean existsEmptyCell() {
2523         return findCellForSpan(null, 1, 1);
2524     }
2525 
2526     /**
2527      * Finds the upper-left coordinate of the first rectangle in the grid that can
2528      * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2529      * then this method will only return coordinates for rectangles that contain the cell
2530      * (intersectX, intersectY)
2531      *
2532      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2533      *               can be found.
2534      * @param spanX The horizontal span of the cell we want to find.
2535      * @param spanY The vertical span of the cell we want to find.
2536      *
2537      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2538      */
2539     boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2540         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2541     }
2542 
2543     /**
2544      * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2545      *
2546      * @param cellXY The array that will contain the position of a vacant cell if such a cell
2547      *               can be found.
2548      * @param spanX The horizontal span of the cell we want to find.
2549      * @param spanY The vertical span of the cell we want to find.
2550      * @param ignoreView The home screen item we should treat as not occupying any space
2551      * @return
2552      */
2553     boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2554         return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2555                 ignoreView, mOccupied);
2556     }
2557 
2558     /**
2559      * Like above, but if intersectX and intersectY are not -1, then this method will try to
2560      * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2561      *
2562      * @param spanX The horizontal span of the cell we want to find.
2563      * @param spanY The vertical span of the cell we want to find.
2564      * @param ignoreView The home screen item we should treat as not occupying any space
2565      * @param intersectX The X coordinate of the cell that we should try to overlap
2566      * @param intersectX The Y coordinate of the cell that we should try to overlap
2567      *
2568      * @return True if a vacant cell of the specified dimension was found, false otherwise.
2569      */
2570     boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2571             int intersectX, int intersectY) {
2572         return findCellForSpanThatIntersectsIgnoring(
2573                 cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2574     }
2575 
2576     /**
2577      * The superset of the above two methods
2578      */
2579     boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2580             int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2581         // mark space take by ignoreView as available (method checks if ignoreView is null)
2582         markCellsAsUnoccupiedForView(ignoreView, occupied);
2583 
2584         boolean foundCell = false;
2585         while (true) {
2586             int startX = 0;
2587             if (intersectX &gt;= 0) {
2588                 startX = Math.max(startX, intersectX - (spanX - 1));
2589             }
2590             int endX = mCountX - (spanX - 1);
2591             if (intersectX &gt;= 0) {
2592                 endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2593             }
2594             int startY = 0;
2595             if (intersectY &gt;= 0) {
2596                 startY = Math.max(startY, intersectY - (spanY - 1));
2597             }
2598             int endY = mCountY - (spanY - 1);
2599             if (intersectY &gt;= 0) {
2600                 endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2601             }
2602 
2603             for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2604                 inner:
2605                 for (int x = startX; x &lt; endX; x++) {
2606                     for (int i = 0; i &lt; spanX; i++) {
2607                         for (int j = 0; j &lt; spanY; j++) {
2608                             if (occupied[x + i][y + j]) {
2609                                 // small optimization: we can skip to after the column we just found
2610                                 // an occupied cell
2611                                 x += i;
2612                                 continue inner;
2613                             }
2614                         }
2615                     }
2616                     if (cellXY != null) {
2617                         cellXY[0] = x;
2618                         cellXY[1] = y;
2619                     }
2620                     foundCell = true;
2621                     break;
2622                 }
2623             }
2624             if (intersectX == -1 &amp;&amp; intersectY == -1) {
2625                 break;
2626             } else {
2627                 // if we failed to find anything, try again but without any requirements of
2628                 // intersecting
2629                 intersectX = -1;
2630                 intersectY = -1;
2631                 continue;
2632             }
2633         }
2634 
2635         // re-mark space taken by ignoreView as occupied
2636         markCellsAsOccupiedForView(ignoreView, occupied);
2637         return foundCell;
2638     }
2639 
2640     /**
2641      * A drag event has begun over this layout.
2642      * It may have begun over this layout (in which case onDragChild is called first),
2643      * or it may have begun on another layout.
2644      */
2645     void onDragEnter() {
2646         mDragEnforcer.onDragEnter();
2647         mDragging = true;
2648     }
2649 
2650     /**
2651      * Called when drag has left this CellLayout or has been completed (successfully or not)
2652      */
2653     void onDragExit() {
2654         mDragEnforcer.onDragExit();
2655         // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2656         // item to this layout via the customize drawer.
2657         // Guard against that case.
2658         if (mDragging) {
2659             mDragging = false;
2660         }
2661 
2662         // Invalidate the drag data
2663         mDragCell[0] = mDragCell[1] = -1;
2664         mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2665         mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2666         revertTempState();
2667         setIsDragOverlapping(false);
2668     }
2669 
2670     /**
2671      * Mark a child as having been dropped.
2672      * At the beginning of the drag operation, the child may have been on another
2673      * screen, but it is re-parented before this method is called.
2674      *
2675      * @param child The child that is being dropped
2676      */
2677     void onDropChild(View child) {
2678         if (child != null) {
2679             LayoutParams lp = (LayoutParams) child.getLayoutParams();
2680             lp.dropped = true;
2681             child.requestLayout();
2682         }
2683     }
2684 
2685     /**
2686      * Computes a bounding rectangle for a range of cells
2687      *
2688      * @param cellX X coordinate of upper left corner expressed as a cell position
2689      * @param cellY Y coordinate of upper left corner expressed as a cell position
2690      * @param cellHSpan Width in cells
2691      * @param cellVSpan Height in cells
2692      * @param resultRect Rect into which to put the results
2693      */
2694     public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2695         final int cellWidth = mCellWidth;
2696         final int cellHeight = mCellHeight;
2697         final int widthGap = mWidthGap;
2698         final int heightGap = mHeightGap;
2699 
2700         final int hStartPadding = getPaddingLeft();
2701         final int vStartPadding = getPaddingTop();
2702 
2703         int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2704         int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2705 
2706         int x = hStartPadding + cellX * (cellWidth + widthGap);
2707         int y = vStartPadding + cellY * (cellHeight + heightGap);
2708 
2709         resultRect.set(x, y, x + width, y + height);
2710     }
2711 
2712     /**
2713      * Computes the required horizontal and vertical cell spans to always
2714      * fit the given rectangle.
2715      *
2716      * @param width Width in pixels
2717      * @param height Height in pixels
2718      * @param result An array of length 2 in which to store the result (may be null).
2719      */
2720     public int[] rectToCell(int width, int height, int[] result) {
2721         return rectToCell(getResources(), width, height, result);
2722     }
2723 
2724     public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2725         // Always assume we&#x27;re working with the smallest span to make sure we
2726         // reserve enough space in both orientations.
2727         int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2728         int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2729         int smallerSize = Math.min(actualWidth, actualHeight);
2730 
2731         // Always round up to next largest cell
2732         int spanX = (int) Math.ceil(width / (float) smallerSize);
2733         int spanY = (int) Math.ceil(height / (float) smallerSize);
2734 
2735         if (result == null) {
2736             return new int[] { spanX, spanY };
2737         }
2738         result[0] = spanX;
2739         result[1] = spanY;
2740         return result;
2741     }
2742 
2743     public int[] cellSpansToSize(int hSpans, int vSpans) {
2744         int[] size = new int[2];
2745         size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2746         size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2747         return size;
2748     }
2749 
2750     /**
2751      * Calculate the grid spans needed to fit given item
2752      */
2753     public void calculateSpans(ItemInfo info) {
2754         final int minWidth;
2755         final int minHeight;
2756 
2757         if (info instanceof LauncherAppWidgetInfo) {
2758             minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2759             minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2760         } else if (info instanceof PendingAddWidgetInfo) {
2761             minWidth = ((PendingAddWidgetInfo) info).minWidth;
2762             minHeight = ((PendingAddWidgetInfo) info).minHeight;
2763         } else {
2764             // It&#x27;s not a widget, so it must be 1x1
2765             info.spanX = info.spanY = 1;
2766             return;
2767         }
2768         int[] spans = rectToCell(minWidth, minHeight, null);
2769         info.spanX = spans[0];
2770         info.spanY = spans[1];
2771     }
2772 
2773     /**
2774      * Find the first vacant cell, if there is one.
2775      *
2776      * @param vacant Holds the x and y coordinate of the vacant cell
2777      * @param spanX Horizontal cell span.
2778      * @param spanY Vertical cell span.
2779      *
2780      * @return True if a vacant cell was found
2781      */
2782     public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2783 
2784         return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2785     }
2786 
2787     static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2788             int xCount, int yCount, boolean[][] occupied) {
2789 
2790         for (int y = 0; y &lt; yCount; y++) {
2791             for (int x = 0; x &lt; xCount; x++) {
2792                 boolean available = !occupied[x][y];
2793     out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2794                     for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2795                         available = available &amp;&amp; !occupied[i][j];
2796                         if (!available) break out;
2797                     }
2798                 }
2799 
2800                 if (available) {
2801                     vacant[0] = x;
2802                     vacant[1] = y;
2803                     return true;
2804                 }
2805             }
2806         }
2807 
2808         return false;
2809     }
2810 
2811     private void clearOccupiedCells() {
2812         for (int x = 0; x &lt; mCountX; x++) {
2813             for (int y = 0; y &lt; mCountY; y++) {
2814                 mOccupied[x][y] = false;
2815             }
2816         }
2817     }
2818 
2819     public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2820         markCellsAsUnoccupiedForView(view);
2821         markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2822     }
2823 
2824     public void markCellsAsOccupiedForView(View view) {
2825         markCellsAsOccupiedForView(view, mOccupied);
2826     }
2827 
2828     public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2829         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2830         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2831         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2832     }
2833 
2834     public void markCellsAsUnoccupiedForView(View view) {
2835         markCellsAsUnoccupiedForView(view, mOccupied);
2836     }
2837 
2838     public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2839         if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2840         LayoutParams lp = (LayoutParams) view.getLayoutParams();
2841         markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2842     }
2843 
2844     private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2845             boolean value) {
2846         if (cellX &lt; 0 || cellY &lt; 0) return;
2847         for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2848             for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2849                 occupied[x][y] = value;
2850             }
2851         }
2852     }
2853 
2854     public int getDesiredWidth() {
2855         return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
2856                 (Math.max((mCountX - 1), 0) * mWidthGap);
2857     }
2858 
2859     public int getDesiredHeight()  {
2860         return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
2861                 (Math.max((mCountY - 1), 0) * mHeightGap);
2862     }
2863 
2864     public boolean isOccupied(int x, int y) {
2865         if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2866             return mOccupied[x][y];
2867         } else {
2868             throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2869         }
2870     }
2871 
2872     @Override
2873     public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2874         return new CellLayout.LayoutParams(getContext(), attrs);
2875     }
2876 
2877     @Override
2878     protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2879         return p instanceof CellLayout.LayoutParams;
2880     }
2881 
2882     @Override
2883     protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2884         return new CellLayout.LayoutParams(p);
2885     }
2886 
2887     public static class CellLayoutAnimationController extends LayoutAnimationController {
2888         public CellLayoutAnimationController(Animation animation, float delay) {
2889             super(animation, delay);
2890         }
2891 
2892         @Override
2893         protected long getDelayForView(View view) {
2894             return ((int) (Math.random() * 150));
2895         }
2896     }
2897 
2898     public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2899         /**
2900          * Horizontal location of the item in the grid.
2901          */
2902         @ViewDebug.ExportedProperty
2903         public int cellX;
2904 
2905         /**
2906          * Vertical location of the item in the grid.
2907          */
2908         @ViewDebug.ExportedProperty
2909         public int cellY;
2910 
2911         /**
2912          * Temporary horizontal location of the item in the grid during reorder
2913          */
2914         public int tmpCellX;
2915 
2916         /**
2917          * Temporary vertical location of the item in the grid during reorder
2918          */
2919         public int tmpCellY;
2920 
2921         /**
2922          * Indicates that the temporary coordinates should be used to layout the items
2923          */
2924         public boolean useTmpCoords;
2925 
2926         /**
2927          * Number of cells spanned horizontally by the item.
2928          */
2929         @ViewDebug.ExportedProperty
2930         public int cellHSpan;
2931 
2932         /**
2933          * Number of cells spanned vertically by the item.
2934          */
2935         @ViewDebug.ExportedProperty
2936         public int cellVSpan;
2937 
2938         /**
2939          * Indicates whether the item will set its x, y, width and height parameters freely,
2940          * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2941          */
2942         public boolean isLockedToGrid = true;
2943 
2944         /**
2945          * Indicates whether this item can be reordered. Always true except in the case of the
2946          * the AllApps button.
2947          */
2948         public boolean canReorder = true;
2949 
2950         // X coordinate of the view in the layout.
2951         @ViewDebug.ExportedProperty
2952         int x;
2953 
2954         // Y coordinate of the view in the layout.
2955         @ViewDebug.ExportedProperty
2956         int y;
2957 
2958         boolean dropped;
2959 
2960         public LayoutParams(Context c, AttributeSet attrs) {
2961             super(c, attrs);
2962             cellHSpan = 1;
2963             cellVSpan = 1;
2964         }
2965 
2966         public LayoutParams(ViewGroup.LayoutParams source) {
2967             super(source);
2968             cellHSpan = 1;
2969             cellVSpan = 1;
2970         }
2971 
2972         public LayoutParams(LayoutParams source) {
2973             super(source);
2974             this.cellX = source.cellX;
2975             this.cellY = source.cellY;
2976             this.cellHSpan = source.cellHSpan;
2977             this.cellVSpan = source.cellVSpan;
2978         }
2979 
2980         public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2981             super(CellLayout.LayoutParams.MATCH_PARENT, CellLayout.LayoutParams.MATCH_PARENT);
2982             this.cellX = cellX;
2983             this.cellY = cellY;
2984             this.cellHSpan = cellHSpan;
2985             this.cellVSpan = cellVSpan;
2986         }
2987 
2988         public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2989             if (isLockedToGrid) {
2990                 final int myCellHSpan = cellHSpan;
2991                 final int myCellVSpan = cellVSpan;
2992                 final int myCellX = (useTmpCoords) ? tmpCellX : cellX;
2993                 final int myCellY = (useTmpCoords) ? tmpCellY : cellY;
<abbr title="2994                 width = (((myCellHSpan * cellWidth) + ((myCellHSpan - 1) * widthGap)) - leftMargin) - rightMargin;">2994                 width = (((myCellHSpan * cellWidth) + ((myCellHSpan - 1) * widthGap)) - leftMargin) - rig🔵</abbr>
<abbr title="2995                 height = (((myCellVSpan * cellHeight) + ((myCellVSpan - 1) * heightGap)) - topMargin) - bottomMargin;">2995                 height = (((myCellVSpan * cellHeight) + ((myCellVSpan - 1) * heightGap)) - topMargin) - b🔵</abbr>
2996                 x = ((int) ((myCellX * (cellWidth + widthGap)) + leftMargin));
2997                 y = ((int) ((myCellY * (cellHeight + heightGap)) + topMargin));
2998             }
2999         }
3000 
3001         public String toString() {
3002             return (((&quot;(&quot; + this.cellX) + &quot;, &quot;) + this.cellY) + &quot;)&quot;;
3003         }
3004 
3005         public void setWidth(int width) {
3006             this.width = width;
3007         }
3008 
3009         public int getWidth() {
3010             return width;
3011         }
3012 
3013         public void setHeight(int height) {
3014             this.height = height;
3015         }
3016 
3017         public int getHeight() {
3018             return height;
3019         }
3020 
3021         public void setX(int x) {
3022             this.x = x;
3023         }
3024 
3025         public int getX() {
3026             return x;
3027         }
3028 
3029         public void setY(int y) {
3030             this.y = y;
3031         }
3032 
3033         public int getY() {
3034             return y;
3035         }
3036     }
3037 
3038     // This class stores info for two purposes:
3039     // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
3040     // its spanX, spanY, and the screen it is on
3041     // 2. When long clicking on an empty cell in a CellLayout, we save information about the
3042     // cellX and cellY coordinates and which page was clicked. We then set this as a tag on
3043     // the CellLayout that was long clicked
3044     static final class CellInfo {
3045         View cell;
3046 
3047         int cellX = -1;
3048 
3049         int cellY = -1;
3050 
3051         int spanX;
3052 
3053         int spanY;
3054 
3055         int screen;
3056 
3057         long container;
3058 
3059         @Override
3060         public String toString() {
<abbr title="3061             return (((((&quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())) + &quot;, x=&quot;) + cellX) + &quot;, y=&quot;) + cellY) + &quot;]&quot;;">3061             return (((((&quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())) + &quot;, x=&quot;) + cellX) + &quot;,🔵</abbr>
3062         }
3063     }
3064 
3065     public boolean lastDownOnOccupiedCell() {
3066         return mLastDownOnOccupiedCell;
3067     }
3068 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +import android.animation.AnimatorListenerAdapter;</span>
  21  import android.animation.AnimatorSet;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.animation.ObjectAnimator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import android.animation.AnimatorListenerAdapter;</span>
  24  import android.animation.TimeInterpolator;
  25  import android.animation.ValueAnimator;
  26  import android.animation.ValueAnimator.AnimatorUpdateListener;
  27  import android.content.Context;
  28  import android.content.res.Resources;
  29  import android.content.res.TypedArray;
  30  import android.graphics.Bitmap;
  31  import android.graphics.Canvas;
  32  import android.graphics.Color;
  33  import android.graphics.Paint;
  34  import android.graphics.Point;
  35  import android.graphics.PorterDuff;
  36  import android.graphics.PorterDuffXfermode;
  37  import android.graphics.Rect;
  38  import android.graphics.drawable.ColorDrawable;
  39  import android.graphics.drawable.Drawable;
  40  import android.graphics.drawable.NinePatchDrawable;

  41  import android.util.AttributeSet;
  42  import android.util.Log;

  43  import android.view.MotionEvent;
  44  import android.view.View;
  45  import android.view.ViewDebug;
  46  import android.view.ViewGroup;
  47  import android.view.animation.Animation;
  48  import android.view.animation.DecelerateInterpolator;
  49  import android.view.animation.LayoutAnimationController;
  50  
  51  import com.android.launcher.R;
  52  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  53  
  54  import java.util.ArrayList;
  55  import java.util.Arrays;
  56  import java.util.HashMap;
  57  import java.util.Stack;
  58  
  59  public class CellLayout extends ViewGroup {
  60      static final String TAG = &quot;CellLayout&quot;;
  61  
  62      private Launcher mLauncher;
  63      private int mCellWidth;
  64      private int mCellHeight;
  65  
  66      private int mCountX;
  67      private int mCountY;
  68  
  69      private int mOriginalWidthGap;
  70      private int mOriginalHeightGap;
  71      private int mWidthGap;
  72      private int mHeightGap;
  73      private int mMaxGap;
  74      private boolean mScrollingTransformsDirty = false;
  75  
  76      private final Rect mRect = new Rect();
  77      private final CellInfo mCellInfo = new CellInfo();
  78  
  79      // These are temporary variables to prevent having to allocate a new object just to
  80      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  81      private final int[] mTmpXY = new int[2];
  82      private final int[] mTmpPoint = new int[2];
  83      int[] mTempLocation = new int[2];
  84  
  85      boolean[][] mOccupied;
  86      boolean[][] mTmpOccupied;
  87      private boolean mLastDownOnOccupiedCell = false;
  88  
  89      private OnTouchListener mInterceptTouchListener;
  90  
  91      private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  92      private int[] mFolderLeaveBehindCell = {-1, -1};
  93  
  94      private int mForegroundAlpha = 0;
  95      private float mBackgroundAlpha;
  96      private float mBackgroundAlphaMultiplier = 1.0f;
  97  
  98      private Drawable mNormalBackground;
  99      private Drawable mActiveGlowBackground;
 100      private Drawable mOverScrollForegroundDrawable;
 101      private Drawable mOverScrollLeft;
 102      private Drawable mOverScrollRight;
 103      private Rect mBackgroundRect;
 104      private Rect mForegroundRect;
 105      private int mForegroundPadding;
 106  
 107      // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 108      private boolean mIsDragOverlapping = false;
 109      private final Point mDragCenter = new Point();
 110  
 111      // These arrays are used to implement the drag visualization on x-large screens.
 112      // They are used as circular arrays, indexed by mDragOutlineCurrent.
 113      private Rect[] mDragOutlines = new Rect[4];
 114      private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 115      private InterruptibleInOutAnimator[] mDragOutlineAnims =
 116              new InterruptibleInOutAnimator[mDragOutlines.length];
 117  
 118      // Used as an index into the above 3 arrays; indicates which is the most current value.
 119      private int mDragOutlineCurrent = 0;
 120      private final Paint mDragOutlinePaint = new Paint();
 121  
 122      private BubbleTextView mPressedOrFocusedIcon;
 123  
 124      private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 125              HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 126      private HashMap&lt;View, ReorderHintAnimation&gt;
 127              mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;();
 128  
 129      private boolean mItemPlacementDirty = false;
 130  
 131      // When a drag operation is in progress, holds the nearest cell to the touch point
 132      private final int[] mDragCell = new int[2];
 133  
 134      private boolean mDragging = false;
 135  
 136      private TimeInterpolator mEaseOutInterpolator;
 137      private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 138  
 139      private boolean mIsHotseat = false;
 140  
 141      public static final int MODE_DRAG_OVER = 0;
 142      public static final int MODE_ON_DROP = 1;
 143      public static final int MODE_ON_DROP_EXTERNAL = 2;
 144      public static final int MODE_ACCEPT_DROP = 3;
 145      private static final boolean DESTRUCTIVE_REORDER = false;
 146      private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 147  
 148      static final int LANDSCAPE = 0;
 149      static final int PORTRAIT = 1;
 150  
 151      private static final float REORDER_HINT_MAGNITUDE = 0.12f;
 152      private static final int REORDER_ANIMATION_DURATION = 150;
 153      private float mReorderHintAnimationMagnitude;
 154  
 155      private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 156      private Rect mOccupiedRect = new Rect();
 157      private int[] mDirectionVector = new int[2];
 158      int[] mPreviousReorderDirection = new int[2];
 159      private static final int INVALID_DIRECTION = -100;
 160      private DropTarget.DragEnforcer mDragEnforcer;
 161  
 162      private final static PorterDuffXfermode sAddBlendMode =
 163              new PorterDuffXfermode(PorterDuff.Mode.ADD);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    private final static Paint sPaint = new Paint();</span>
 165  
 166      public CellLayout(Context context) {
 167          this(context, null);
 168      }
 169  
 170      public CellLayout(Context context, AttributeSet attrs) {
 171          this(context, attrs, 0);
 172      }
 173  
 174      public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 175          super(context, attrs, defStyle);
 176          mDragEnforcer = new DropTarget.DragEnforcer(context);
 177  
 178          // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 179          // the user where a dragged item will land when dropped.
 180          setWillNotDraw(false);
 181          mLauncher = (Launcher) context;
 182  
 183          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 184  
 185          mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 186          mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 187          mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 188          mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 189          mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 190          mCountX = LauncherModel.getCellCountX();
 191          mCountY = LauncherModel.getCellCountY();
 192          mOccupied = new boolean[mCountX][mCountY];
 193          mTmpOccupied = new boolean[mCountX][mCountY];
 194          mPreviousReorderDirection[0] = INVALID_DIRECTION;
 195          mPreviousReorderDirection[1] = INVALID_DIRECTION;
 196  
 197          a.recycle();
 198  
 199          setAlwaysDrawnWithCacheEnabled(false);
 200  
 201          final Resources res = getResources();
 202  
 203          mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 204          mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 205  
 206          mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 207          mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 208          mForegroundPadding =
 209                  res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 210  
 211          mReorderHintAnimationMagnitude = (REORDER_HINT_MAGNITUDE *
 212                  res.getDimensionPixelSize(R.dimen.app_icon_size));
 213  
 214          mNormalBackground.setFilterBitmap(true);
 215          mActiveGlowBackground.setFilterBitmap(true);
 216  
 217          // Initialize the data structures used for the drag visualization.
 218  
 219          mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 220  
 221  
 222          mDragCell[0] = mDragCell[1] = -1;
 223          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 224              mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 225          }
 226  
 227          // When dragging things around the home screens, we show a green outline of
 228          // where the item will land. The outlines gradually fade out, leaving a trail
 229          // behind the drag path.
 230          // Set up all the animations that are used to implement this fading.
 231          final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 232          final float fromAlphaValue = 0;
 233          final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 234  
 235          Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 236  
 237          for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 238              final InterruptibleInOutAnimator anim =
 239                  new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 240              anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 241              final int thisIndex = i;
 242              anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 243                  public void onAnimationUpdate(ValueAnimator animation) {
 244                      final Bitmap outline = (Bitmap)anim.getTag();
 245  
 246                      // If an animation is started and then stopped very quickly, we can still
 247                      // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 248                      if (outline == null) {
 249                          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 250                          final boolean debug = false;
 251                          if (debug) {
 252                              Object val = animation.getAnimatedValue();
 253                              Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 254                                       &quot;, isStopped &quot; + anim.isStopped());
 255                          }
 256                          // Try to prevent it from continuing to run
 257                          animation.cancel();
 258                      } else {
 259                          mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 260                          CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 261                      }
 262                  }
 263              });
 264              // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 265              // running. This way the bitmap can be GCed when the animations are complete.
 266              anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 267                  @Override
 268                  public void onAnimationEnd(Animator animation) {
 269                      if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 270                          anim.setTag(null);
 271                      }
 272                  }
 273              });
 274              mDragOutlineAnims[i] = anim;
 275          }
 276  
 277          mBackgroundRect = new Rect();
 278          mForegroundRect = new Rect();
 279  
 280          mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 281          mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 282          addView(mShortcutsAndWidgets);
 283      }
 284  
 285      static int widthInPortrait(Resources r, int numCells) {
 286          // We use this method from Workspace to figure out how many rows/columns Launcher should
 287          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 288          // the padding extends outside the visible screen size, but it looked fine anyway.
 289          int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 290          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 291                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 292  
 293          return  minGap * (numCells - 1) + cellWidth * numCells;
 294      }
 295  
 296      static int heightInLandscape(Resources r, int numCells) {
 297          // We use this method from Workspace to figure out how many rows/columns Launcher should
 298          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 299          // the padding extends outside the visible screen size, but it looked fine anyway.
 300          int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 301          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 302                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 303  
 304          return minGap * (numCells - 1) + cellHeight * numCells;
 305      }
 306  
 307      public void enableHardwareLayers() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 308 -        mShortcutsAndWidgets.enableHardwareLayers();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +        mShortcutsAndWidgets.setLayerType(LAYER_TYPE_HARDWARE, sPaint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +    public void disableHardwareLayers() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +        mShortcutsAndWidgets.setLayerType(LAYER_TYPE_NONE, sPaint);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +    public void buildHardwareLayer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +        mShortcutsAndWidgets.buildLayer();</span>
 318      }
 319  
 320      public void setGridSize(int x, int y) {
 321          mCountX = x;
 322          mCountY = y;
 323          mOccupied = new boolean[mCountX][mCountY];
 324          mTmpOccupied = new boolean[mCountX][mCountY];
 325          mTempRectStack.clear();
 326          requestLayout();
 327      }
 328  
 329      private void invalidateBubbleTextView(BubbleTextView icon) {
 330          final int padding = icon.getPressedOrFocusedBackgroundPadding();
 331          invalidate(icon.getLeft() + getPaddingLeft() - padding,
 332                  icon.getTop() + getPaddingTop() - padding,
 333                  icon.getRight() + getPaddingLeft() + padding,
 334                  icon.getBottom() + getPaddingTop() + padding);
 335      }
 336  
 337      void setOverScrollAmount(float r, boolean left) {
 338          if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 339              mOverScrollForegroundDrawable = mOverScrollLeft;
 340          } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 341              mOverScrollForegroundDrawable = mOverScrollRight;
 342          }
 343  
 344          mForegroundAlpha = (int) Math.round((r * 255));
 345          mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 346          invalidate();
 347      }
 348  
 349      void setPressedOrFocusedIcon(BubbleTextView icon) {
 350          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 351          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 352          BubbleTextView oldIcon = mPressedOrFocusedIcon;
 353          mPressedOrFocusedIcon = icon;
 354          if (oldIcon != null) {
 355              invalidateBubbleTextView(oldIcon);
 356          }
 357          if (mPressedOrFocusedIcon != null) {
 358              invalidateBubbleTextView(mPressedOrFocusedIcon);
 359          }
 360      }
 361  
 362      void setIsDragOverlapping(boolean isDragOverlapping) {
 363          if (mIsDragOverlapping != isDragOverlapping) {
 364              mIsDragOverlapping = isDragOverlapping;
 365              invalidate();
 366          }
 367      }
 368  
 369      boolean getIsDragOverlapping() {
 370          return mIsDragOverlapping;
 371      }
 372  
 373      protected void setOverscrollTransformsDirty(boolean dirty) {
 374          mScrollingTransformsDirty = dirty;
 375      }
 376  
 377      protected void resetOverscrollTransforms() {
 378          if (mScrollingTransformsDirty) {
 379              setOverscrollTransformsDirty(false);
 380              setTranslationX(0);
 381              setRotationY(0);
 382              // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 383              // pass 0, which results in the overscroll drawable not being drawn any more.
 384              setOverScrollAmount(0, false);
 385              setPivotX(getMeasuredWidth() / 2);
 386              setPivotY(getMeasuredHeight() / 2);
 387          }
 388      }
 389  
 390      @Override
 391      protected void onDraw(Canvas canvas) {
 392          // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 393          // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 394          // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 395          // a drag). However, we also drag the mini hover background *over* one of those two
 396          // backgrounds
 397          if (mBackgroundAlpha &gt; 0.0f) {
 398              Drawable bg;
 399  
 400              if (mIsDragOverlapping) {
 401                  // In the mini case, we draw the active_glow bg *over* the active background
 402                  bg = mActiveGlowBackground;
 403              } else {
 404                  bg = mNormalBackground;
 405              }
 406  
 407              bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 408              bg.setBounds(mBackgroundRect);
 409              bg.draw(canvas);
 410          }
 411  
 412          final Paint paint = mDragOutlinePaint;
 413          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 414              final float alpha = mDragOutlineAlphas[i];
 415              if (alpha &gt; 0) {
 416                  final Rect r = mDragOutlines[i];
 417                  final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 418                  paint.setAlpha((int)(alpha + .5f));
 419                  canvas.drawBitmap(b, null, r, paint);
 420              }
 421          }
 422  
 423          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 424          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 425          if (mPressedOrFocusedIcon != null) {
 426              final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 427              final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 428              if (b != null) {
 429                  canvas.drawBitmap(b,
 430                          mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 431                          mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 432                          null);
 433              }
 434          }
 435  
 436          if (DEBUG_VISUALIZE_OCCUPIED) {
 437              int[] pt = new int[2];
 438              ColorDrawable cd = new ColorDrawable(Color.RED);
 439              cd.setBounds(0, 0,  mCellWidth, mCellHeight);
 440              for (int i = 0; i &lt; mCountX; i++) {
 441                  for (int j = 0; j &lt; mCountY; j++) {
 442                      if (mOccupied[i][j]) {
 443                          cellToPoint(i, j, pt);
 444                          canvas.save();
 445                          canvas.translate(pt[0], pt[1]);
 446                          cd.draw(canvas);
 447                          canvas.restore();
 448                      }
 449                  }
 450              }
 451          }
 452  
 453          int previewOffset = FolderRingAnimator.sPreviewSize;
 454  
 455          // The folder outer / inner ring image(s)
 456          for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 457              FolderRingAnimator fra = mFolderOuterRings.get(i);
 458  
 459              // Draw outer ring
 460              Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 461              int width = (int) fra.getOuterRingSize();
 462              int height = width;
 463              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 464  
 465              int centerX = mTempLocation[0] + mCellWidth / 2;
 466              int centerY = mTempLocation[1] + previewOffset / 2;
 467  
 468              canvas.save();
 469              canvas.translate(centerX - width / 2, centerY - height / 2);
 470              d.setBounds(0, 0, width, height);
 471              d.draw(canvas);
 472              canvas.restore();
 473  
 474              // Draw inner ring
 475              d = FolderRingAnimator.sSharedInnerRingDrawable;
 476              width = (int) fra.getInnerRingSize();
 477              height = width;
 478              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 479  
 480              centerX = mTempLocation[0] + mCellWidth / 2;
 481              centerY = mTempLocation[1] + previewOffset / 2;
 482              canvas.save();
 483              canvas.translate(centerX - width / 2, centerY - width / 2);
 484              d.setBounds(0, 0, width, height);
 485              d.draw(canvas);
 486              canvas.restore();
 487          }
 488  
 489          if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 490              Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 491              int width = d.getIntrinsicWidth();
 492              int height = d.getIntrinsicHeight();
 493  
 494              cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 495              int centerX = mTempLocation[0] + mCellWidth / 2;
 496              int centerY = mTempLocation[1] + previewOffset / 2;
 497  
 498              canvas.save();
 499              canvas.translate(centerX - width / 2, centerY - width / 2);
 500              d.setBounds(0, 0, width, height);
 501              d.draw(canvas);
 502              canvas.restore();
 503          }
 504      }
 505  
 506      @Override
 507      protected void dispatchDraw(Canvas canvas) {
 508          super.dispatchDraw(canvas);
 509          if (mForegroundAlpha &gt; 0) {
 510              mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 511              Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 512              p.setXfermode(sAddBlendMode);
 513              mOverScrollForegroundDrawable.draw(canvas);
 514              p.setXfermode(null);
 515          }
 516      }
 517  
 518      public void showFolderAccept(FolderRingAnimator fra) {
 519          mFolderOuterRings.add(fra);
 520      }
 521  
 522      public void hideFolderAccept(FolderRingAnimator fra) {
 523          if (mFolderOuterRings.contains(fra)) {
 524              mFolderOuterRings.remove(fra);
 525          }
 526          invalidate();
 527      }
 528  
 529      public void setFolderLeaveBehindCell(int x, int y) {
 530          mFolderLeaveBehindCell[0] = x;
 531          mFolderLeaveBehindCell[1] = y;
 532          invalidate();
 533      }
 534  
 535      public void clearFolderLeaveBehind() {
 536          mFolderLeaveBehindCell[0] = -1;
 537          mFolderLeaveBehindCell[1] = -1;
 538          invalidate();
 539      }
 540  
 541      @Override
 542      public boolean shouldDelayChildPressedState() {
 543          return false;




 544      }
 545  
 546      @Override
 547      public void cancelLongPress() {
 548          super.cancelLongPress();
 549  
 550          // Cancel long press for all children
 551          final int count = getChildCount();
 552          for (int i = 0; i &lt; count; i++) {
 553              final View child = getChildAt(i);
 554              child.cancelLongPress();
 555          }
 556      }
 557  
 558      public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 559          mInterceptTouchListener = listener;
 560      }
 561  
 562      int getCountX() {
 563          return mCountX;
 564      }
 565  
 566      int getCountY() {
 567          return mCountY;
 568      }
 569  
 570      public void setIsHotseat(boolean isHotseat) {
 571          mIsHotseat = isHotseat;
 572      }
 573  
 574      public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 575              boolean markCells) {
 576          final LayoutParams lp = params;
 577  
 578          // Hotseat icons - remove text
 579          if (child instanceof BubbleTextView) {
 580              BubbleTextView bubbleChild = (BubbleTextView) child;
 581  
 582              Resources res = getResources();
 583              if (mIsHotseat) {
 584                  bubbleChild.setTextColor(res.getColor(android.R.color.transparent));
 585              } else {
 586                  bubbleChild.setTextColor(res.getColor(R.color.workspace_icon_text_color));
 587              }
 588          }
 589  
 590          // Generate an id for each view, this assumes we have at most 256x256 cells
 591          // per workspace screen
 592          if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 593              // If the horizontal or vertical span is set to -1, it is taken to
 594              // mean that it spans the extent of the CellLayout
 595              if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 596              if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 597  
 598              child.setId(childId);
 599  
 600              mShortcutsAndWidgets.addView(child, index, lp);
 601  
 602              if (markCells) markCellsAsOccupiedForView(child);
 603  
 604              return true;
 605          }
 606          return false;
 607      }
 608  
 609      @Override
 610      public void removeAllViews() {
 611          clearOccupiedCells();
 612          mShortcutsAndWidgets.removeAllViews();
 613      }
 614  
 615      @Override
 616      public void removeAllViewsInLayout() {
 617          if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 618              clearOccupiedCells();
 619              mShortcutsAndWidgets.removeAllViewsInLayout();
 620          }
 621      }
 622  
 623      public void removeViewWithoutMarkingCells(View view) {
 624          mShortcutsAndWidgets.removeView(view);
 625      }
 626  
 627      @Override
 628      public void removeView(View view) {
 629          markCellsAsUnoccupiedForView(view);
 630          mShortcutsAndWidgets.removeView(view);
 631      }
 632  
 633      @Override
 634      public void removeViewAt(int index) {
 635          markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 636          mShortcutsAndWidgets.removeViewAt(index);
 637      }
 638  
 639      @Override
 640      public void removeViewInLayout(View view) {
 641          markCellsAsUnoccupiedForView(view);
 642          mShortcutsAndWidgets.removeViewInLayout(view);
 643      }
 644  
 645      @Override
 646      public void removeViews(int start, int count) {
 647          for (int i = start; i &lt; start + count; i++) {
 648              markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 649          }
 650          mShortcutsAndWidgets.removeViews(start, count);
 651      }
 652  
 653      @Override
 654      public void removeViewsInLayout(int start, int count) {
 655          for (int i = start; i &lt; start + count; i++) {
 656              markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 657          }
 658          mShortcutsAndWidgets.removeViewsInLayout(start, count);
 659      }
 660  
 661      @Override
 662      protected void onAttachedToWindow() {
 663          super.onAttachedToWindow();
 664          mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 665      }
 666  
 667      public void setTagToCellInfoForPoint(int touchX, int touchY) {
 668          final CellInfo cellInfo = mCellInfo;
 669          Rect frame = mRect;
 670          final int x = touchX + getScrollX();
 671          final int y = touchY + getScrollY();
 672          final int count = mShortcutsAndWidgets.getChildCount();
 673  
 674          boolean found = false;
 675          for (int i = count - 1; i &gt;= 0; i--) {
 676              final View child = mShortcutsAndWidgets.getChildAt(i);
 677              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 678  
 679              if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 680                      lp.isLockedToGrid) {
 681                  child.getHitRect(frame);
 682  
 683                  float scale = child.getScaleX();
 684                  frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 685                          child.getBottom());
 686                  // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 687                  // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 688                  // to this view.
 689                  frame.offset(getPaddingLeft(), getPaddingTop());
 690                  frame.inset((int) (frame.width() * (1f - scale) / 2),
 691                          (int) (frame.height() * (1f - scale) / 2));
 692  
 693                  if (frame.contains(x, y)) {
 694                      cellInfo.cell = child;
 695                      cellInfo.cellX = lp.cellX;
 696                      cellInfo.cellY = lp.cellY;
 697                      cellInfo.spanX = lp.cellHSpan;
 698                      cellInfo.spanY = lp.cellVSpan;
 699                      found = true;
 700                      break;
 701                  }
 702              }
 703          }
 704  
 705          mLastDownOnOccupiedCell = found;
 706  
 707          if (!found) {
 708              final int cellXY[] = mTmpXY;
 709              pointToCellExact(x, y, cellXY);
 710  
 711              cellInfo.cell = null;
 712              cellInfo.cellX = cellXY[0];
 713              cellInfo.cellY = cellXY[1];
 714              cellInfo.spanX = 1;
 715              cellInfo.spanY = 1;
 716          }
 717          setTag(cellInfo);
 718      }
 719  
 720      @Override
 721      public boolean onInterceptTouchEvent(MotionEvent ev) {
 722          // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 723          // even in the case where we return early. Not clearing here was causing bugs whereby on
 724          // long-press we&#x27;d end up picking up an item from a previous drag operation.
 725          final int action = ev.getAction();
 726  
 727          if (action == MotionEvent.ACTION_DOWN) {
 728              clearTagCellInfo();
 729          }
 730  
 731          if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 732              return true;
 733          }
 734  
 735          if (action == MotionEvent.ACTION_DOWN) {
 736              setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 737          }
 738  
 739          return false;
 740      }
 741  
 742      private void clearTagCellInfo() {
 743          final CellInfo cellInfo = mCellInfo;
 744          cellInfo.cell = null;
 745          cellInfo.cellX = -1;
 746          cellInfo.cellY = -1;
 747          cellInfo.spanX = 0;
 748          cellInfo.spanY = 0;
 749          setTag(cellInfo);
 750      }
 751  
 752      public CellInfo getTag() {
 753          return (CellInfo) super.getTag();
 754      }
 755  
 756      /**
 757       * Given a point, return the cell that strictly encloses that point
 758       * @param x X coordinate of the point
 759       * @param y Y coordinate of the point
 760       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 761       */
 762      void pointToCellExact(int x, int y, int[] result) {
 763          final int hStartPadding = getPaddingLeft();
 764          final int vStartPadding = getPaddingTop();
 765  
 766          result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 767          result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 768  
 769          final int xAxis = mCountX;
 770          final int yAxis = mCountY;
 771  
 772          if (result[0] &lt; 0) result[0] = 0;
 773          if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 774          if (result[1] &lt; 0) result[1] = 0;
 775          if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 776      }
 777  
 778      /**
 779       * Given a point, return the cell that most closely encloses that point
 780       * @param x X coordinate of the point
 781       * @param y Y coordinate of the point
 782       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 783       */
 784      void pointToCellRounded(int x, int y, int[] result) {
 785          pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 786      }
 787  
 788      /**
 789       * Given a cell coordinate, return the point that represents the upper left corner of that cell
 790       *
 791       * @param cellX X coordinate of the cell
 792       * @param cellY Y coordinate of the cell
 793       *
 794       * @param result Array of 2 ints to hold the x and y coordinate of the point
 795       */
 796      void cellToPoint(int cellX, int cellY, int[] result) {
 797          final int hStartPadding = getPaddingLeft();
 798          final int vStartPadding = getPaddingTop();
 799  
 800          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 801          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 802      }
 803  
 804      /**
 805       * Given a cell coordinate, return the point that represents the center of the cell
 806       *
 807       * @param cellX X coordinate of the cell
 808       * @param cellY Y coordinate of the cell
 809       *
 810       * @param result Array of 2 ints to hold the x and y coordinate of the point
 811       */
 812      void cellToCenterPoint(int cellX, int cellY, int[] result) {
 813          regionToCenterPoint(cellX, cellY, 1, 1, result);
 814      }
 815  
 816      /**
 817       * Given a cell coordinate and span return the point that represents the center of the regio
 818       *
 819       * @param cellX X coordinate of the cell
 820       * @param cellY Y coordinate of the cell
 821       *
 822       * @param result Array of 2 ints to hold the x and y coordinate of the point
 823       */
 824      void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 825          final int hStartPadding = getPaddingLeft();
 826          final int vStartPadding = getPaddingTop();
 827          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 828                  (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 829          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 830                  (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
 831      }
 832  
 833       /**
 834       * Given a cell coordinate and span fills out a corresponding pixel rect
 835       *
 836       * @param cellX X coordinate of the cell
 837       * @param cellY Y coordinate of the cell
 838       * @param result Rect in which to write the result
 839       */
 840       void regionToRect(int cellX, int cellY, int spanX, int spanY, Rect result) {
 841          final int hStartPadding = getPaddingLeft();
 842          final int vStartPadding = getPaddingTop();
 843          final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);
 844          final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);
 845          result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),
 846                  top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
 847      }
 848  
 849      public float getDistanceFromCell(float x, float y, int[] cell) {
 850          cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 851          float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 852                  Math.pow(y - mTmpPoint[1], 2));
 853          return distance;
 854      }
 855  
 856      int getCellWidth() {
 857          return mCellWidth;
 858      }
 859  
 860      int getCellHeight() {
 861          return mCellHeight;
 862      }
 863  
 864      int getWidthGap() {
 865          return mWidthGap;
 866      }
 867  
 868      int getHeightGap() {
 869          return mHeightGap;
 870      }
 871  
 872      Rect getContentRect(Rect r) {
 873          if (r == null) {
 874              r = new Rect();
 875          }
 876          int left = getPaddingLeft();
 877          int top = getPaddingTop();
 878          int right = left + getWidth() - getPaddingLeft() - getPaddingRight();
 879          int bottom = top + getHeight() - getPaddingTop() - getPaddingBottom();
 880          r.set(left, top, right, bottom);
 881          return r;
 882      }
 883  
 884      static void getMetrics(Rect metrics, Resources res, int measureWidth, int measureHeight,
 885              int countX, int countY, int orientation) {
 886          int numWidthGaps = countX - 1;
 887          int numHeightGaps = countY - 1;
 888  
 889          int widthGap;
 890          int heightGap;
 891          int cellWidth;
 892          int cellHeight;
 893          int paddingLeft;
 894          int paddingRight;
 895          int paddingTop;
 896          int paddingBottom;
 897  
 898          int maxGap = res.getDimensionPixelSize(R.dimen.workspace_max_gap);
 899          if (orientation == LANDSCAPE) {
 900              cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_land);
 901              cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_land);
 902              widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_land);
 903              heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_land);
 904              paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_land);
 905              paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_land);
 906              paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_land);
 907              paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_land);
 908          } else {
 909              // PORTRAIT
 910              cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_port);
 911              cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_port);
 912              widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_port);
 913              heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_port);
 914              paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_port);
 915              paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_port);
 916              paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_port);
 917              paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_port);
 918          }
 919  
 920          if (widthGap &lt; 0 || heightGap &lt; 0) {
 921              int hSpace = measureWidth - paddingLeft - paddingRight;
 922              int vSpace = measureHeight - paddingTop - paddingBottom;
 923              int hFreeSpace = hSpace - (countX * cellWidth);
 924              int vFreeSpace = vSpace - (countY * cellHeight);
 925              widthGap = Math.min(maxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 926              heightGap = Math.min(maxGap, numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 927          }
 928          metrics.set(cellWidth, cellHeight, widthGap, heightGap);
 929      }
 930  
 931      @Override
 932      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 933          int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 934          int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 935  
 936          int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 937          int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 938  
 939          if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 940              throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 941          }
 942  
 943          int numWidthGaps = mCountX - 1;
 944          int numHeightGaps = mCountY - 1;
 945  
 946          if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 947              int hSpace = widthSpecSize - getPaddingLeft() - getPaddingRight();
 948              int vSpace = heightSpecSize - getPaddingTop() - getPaddingBottom();
 949              int hFreeSpace = hSpace - (mCountX * mCellWidth);
 950              int vFreeSpace = vSpace - (mCountY * mCellHeight);
 951              mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 952              mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 953              mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 954          } else {
 955              mWidthGap = mOriginalWidthGap;
 956              mHeightGap = mOriginalHeightGap;
 957          }
 958  
 959          // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 960          int newWidth = widthSpecSize;
 961          int newHeight = heightSpecSize;
 962          if (widthSpecMode == MeasureSpec.AT_MOST) {
 963              newWidth = getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
 964                  ((mCountX - 1) * mWidthGap);
 965              newHeight = getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
 966                  ((mCountY - 1) * mHeightGap);
 967              setMeasuredDimension(newWidth, newHeight);
 968          }
 969  
 970          int count = getChildCount();
 971          for (int i = 0; i &lt; count; i++) {
 972              View child = getChildAt(i);
 973              int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - getPaddingLeft() -
 974                      getPaddingRight(), MeasureSpec.EXACTLY);
 975              int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - getPaddingTop() -
 976                      getPaddingBottom(), MeasureSpec.EXACTLY);
 977              child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 978          }
 979          setMeasuredDimension(newWidth, newHeight);
 980      }
 981  
 982      @Override
 983      protected void onLayout(boolean changed, int l, int t, int r, int b) {
 984          int count = getChildCount();
 985          for (int i = 0; i &lt; count; i++) {
 986              View child = getChildAt(i);
 987              child.layout(getPaddingLeft(), getPaddingTop(),
 988                      r - l - getPaddingRight(), b - t - getPaddingBottom());
 989          }
 990      }
 991  
 992      @Override
 993      protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 994          super.onSizeChanged(w, h, oldw, oldh);
 995          mBackgroundRect.set(0, 0, w, h);
 996          mForegroundRect.set(mForegroundPadding, mForegroundPadding,
 997                  w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
 998      }
 999  
1000      @Override
1001      protected void setChildrenDrawingCacheEnabled(boolean enabled) {
1002          mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
1003      }
1004  
1005      @Override
1006      protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1007          mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
1008      }
1009  
1010      public float getBackgroundAlpha() {
1011          return mBackgroundAlpha;
1012      }
1013  
1014      public void setBackgroundAlphaMultiplier(float multiplier) {
1015          if (mBackgroundAlphaMultiplier != multiplier) {
1016              mBackgroundAlphaMultiplier = multiplier;
1017              invalidate();
1018          }
1019      }
1020  
1021      public float getBackgroundAlphaMultiplier() {
1022          return mBackgroundAlphaMultiplier;
1023      }
1024  
1025      public void setBackgroundAlpha(float alpha) {
1026          if (mBackgroundAlpha != alpha) {
1027              mBackgroundAlpha = alpha;
1028              invalidate();
1029          }
1030      }
1031  
1032      public void setShortcutAndWidgetAlpha(float alpha) {
1033          final int childCount = getChildCount();
1034          for (int i = 0; i &lt; childCount; i++) {
1035              getChildAt(i).setAlpha(alpha);
1036          }
1037      }
1038  
1039      public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1040          if (getChildCount() &gt; 0) {
1041              return (ShortcutAndWidgetContainer) getChildAt(0);
1042          }
1043          return null;
1044      }
1045  
1046      public View getChildAt(int x, int y) {
1047          return mShortcutsAndWidgets.getChildAt(x, y);
1048      }
1049  
1050      public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1051              int delay, boolean permanent, boolean adjustOccupied) {
1052          ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1053          boolean[][] occupied = mOccupied;
1054          if (!permanent) {
1055              occupied = mTmpOccupied;
1056          }
1057  
1058          if (clc.indexOfChild(child) != -1) {
1059              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1060              final ItemInfo info = (ItemInfo) child.getTag();
1061  
1062              // We cancel any existing animations
1063              if (mReorderAnimators.containsKey(lp)) {
1064                  mReorderAnimators.get(lp).cancel();
1065                  mReorderAnimators.remove(lp);
1066              }
1067  
1068              final int oldX = lp.x;
1069              final int oldY = lp.y;
1070              if (adjustOccupied) {
1071                  occupied[lp.cellX][lp.cellY] = false;
1072                  occupied[cellX][cellY] = true;
1073              }
1074              lp.isLockedToGrid = true;
1075              if (permanent) {
1076                  lp.cellX = info.cellX = cellX;
1077                  lp.cellY = info.cellY = cellY;
1078              } else {
1079                  lp.tmpCellX = cellX;
1080                  lp.tmpCellY = cellY;
1081              }
1082              clc.setupLp(lp);
1083              lp.isLockedToGrid = false;
1084              final int newX = lp.x;
1085              final int newY = lp.y;
1086  
1087              lp.x = oldX;
1088              lp.y = oldY;
1089  
1090              // Exit early if we&#x27;re not actually moving the view
1091              if (oldX == newX &amp;&amp; oldY == newY) {
1092                  lp.isLockedToGrid = true;
1093                  return true;
1094              }
1095  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1096 -            ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1097 +            ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);</span>
1098              va.setDuration(duration);
1099              mReorderAnimators.put(lp, va);
1100  
1101              va.addUpdateListener(new AnimatorUpdateListener() {
1102                  @Override
1103                  public void onAnimationUpdate(ValueAnimator animation) {
1104                      float r = ((Float) animation.getAnimatedValue()).floatValue();
1105                      lp.x = (int) ((1 - r) * oldX + r * newX);
1106                      lp.y = (int) ((1 - r) * oldY + r * newY);
1107                      child.requestLayout();
1108                  }
1109              });
1110              va.addListener(new AnimatorListenerAdapter() {
1111                  boolean cancelled = false;
1112                  public void onAnimationEnd(Animator animation) {
1113                      // If the animation was cancelled, it means that another animation
1114                      // has interrupted this one, and we don&#x27;t want to lock the item into
1115                      // place just yet.
1116                      if (!cancelled) {
1117                          lp.isLockedToGrid = true;
1118                          child.requestLayout();
1119                      }
1120                      if (mReorderAnimators.containsKey(lp)) {
1121                          mReorderAnimators.remove(lp);
1122                      }
1123                  }
1124                  public void onAnimationCancel(Animator animation) {
1125                      cancelled = true;
1126                  }
1127              });
1128              va.setStartDelay(delay);
1129              va.start();
1130              return true;
1131          }
1132          return false;
1133      }
1134  
1135      /**
1136       * Estimate where the top left cell of the dragged item will land if it is dropped.
1137       *
1138       * @param originX The X value of the top left corner of the item
1139       * @param originY The Y value of the top left corner of the item
1140       * @param spanX The number of horizontal cells that the item spans
1141       * @param spanY The number of vertical cells that the item spans
1142       * @param result The estimated drop cell X and Y.
1143       */
1144      void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1145          final int countX = mCountX;
1146          final int countY = mCountY;
1147  
1148          // pointToCellRounded takes the top left of a cell but will pad that with
1149          // cellWidth/2 and cellHeight/2 when finding the matching cell
1150          pointToCellRounded(originX, originY, result);
1151  
1152          // If the item isn&#x27;t fully on this screen, snap to the edges
1153          int rightOverhang = result[0] + spanX - countX;
1154          if (rightOverhang &gt; 0) {
1155              result[0] -= rightOverhang; // Snap to right
1156          }
1157          result[0] = Math.max(0, result[0]); // Snap to left
1158          int bottomOverhang = result[1] + spanY - countY;
1159          if (bottomOverhang &gt; 0) {
1160              result[1] -= bottomOverhang; // Snap to bottom
1161          }
1162          result[1] = Math.max(0, result[1]); // Snap to top
1163      }
1164  
1165      void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1166              int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1167          final int oldDragCellX = mDragCell[0];
1168          final int oldDragCellY = mDragCell[1];
1169  
1170          if (v != null &amp;&amp; dragOffset == null) {
1171              mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1172          } else {
1173              mDragCenter.set(originX, originY);
1174          }
1175  
1176          if (dragOutline == null &amp;&amp; v == null) {
1177              return;
1178          }
1179  
1180          if (cellX != oldDragCellX || cellY != oldDragCellY) {
1181              mDragCell[0] = cellX;
1182              mDragCell[1] = cellY;
1183              // Find the top left corner of the rect the object will occupy
1184              final int[] topLeft = mTmpPoint;
1185              cellToPoint(cellX, cellY, topLeft);
1186  
1187              int left = topLeft[0];
1188              int top = topLeft[1];
1189  
1190              if (v != null &amp;&amp; dragOffset == null) {
1191                  // When drawing the drag outline, it did not account for margin offsets
1192                  // added by the view&#x27;s parent.
1193                  MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1194                  left += lp.leftMargin;
1195                  top += lp.topMargin;
1196  
1197                  // Offsets due to the size difference between the View and the dragOutline.
1198                  // There is a size difference to account for the outer blur, which may lie
1199                  // outside the bounds of the view.
1200                  top += (v.getHeight() - dragOutline.getHeight()) / 2;
1201                  // We center about the x axis
1202                  left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1203                          - dragOutline.getWidth()) / 2;
1204              } else {
1205                  if (dragOffset != null &amp;&amp; dragRegion != null) {
1206                      // Center the drag region *horizontally* in the cell and apply a drag
1207                      // outline offset
1208                      left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1209                               - dragRegion.width()) / 2;
1210                      top += dragOffset.y;
1211                  } else {
1212                      // Center the drag outline in the cell
1213                      left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1214                              - dragOutline.getWidth()) / 2;
1215                      top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1216                              - dragOutline.getHeight()) / 2;
1217                  }
1218              }
1219              final int oldIndex = mDragOutlineCurrent;
1220              mDragOutlineAnims[oldIndex].animateOut();
1221              mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1222              Rect r = mDragOutlines[mDragOutlineCurrent];
1223              r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1224              if (resize) {
1225                  cellToRect(cellX, cellY, spanX, spanY, r);
1226              }
1227  
1228              mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1229              mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1230          }
1231      }
1232  
1233      public void clearDragOutlines() {
1234          final int oldIndex = mDragOutlineCurrent;
1235          mDragOutlineAnims[oldIndex].animateOut();
1236          mDragCell[0] = mDragCell[1] = -1;
1237      }
1238  
1239      /**
1240       * Find a vacant area that will fit the given bounds nearest the requested
1241       * cell location. Uses Euclidean distance to score multiple vacant areas.
1242       *
1243       * @param pixelX The X location at which you want to search for a vacant area.
1244       * @param pixelY The Y location at which you want to search for a vacant area.
1245       * @param spanX Horizontal span of the object.
1246       * @param spanY Vertical span of the object.
1247       * @param result Array in which to place the result, or null (in which case a new array will
1248       *        be allocated)
1249       * @return The X, Y cell of a vacant area that can contain this object,
1250       *         nearest the requested location.
1251       */
1252      int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1253              int[] result) {
1254          return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1255      }
1256  
1257      /**
1258       * Find a vacant area that will fit the given bounds nearest the requested
1259       * cell location. Uses Euclidean distance to score multiple vacant areas.
1260       *
1261       * @param pixelX The X location at which you want to search for a vacant area.
1262       * @param pixelY The Y location at which you want to search for a vacant area.
1263       * @param minSpanX The minimum horizontal span required
1264       * @param minSpanY The minimum vertical span required
1265       * @param spanX Horizontal span of the object.
1266       * @param spanY Vertical span of the object.
1267       * @param result Array in which to place the result, or null (in which case a new array will
1268       *        be allocated)
1269       * @return The X, Y cell of a vacant area that can contain this object,
1270       *         nearest the requested location.
1271       */
1272      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1273              int spanY, int[] result, int[] resultSpan) {
1274          return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1275                  result, resultSpan);
1276      }
1277  
1278      /**
1279       * Find a vacant area that will fit the given bounds nearest the requested
1280       * cell location. Uses Euclidean distance to score multiple vacant areas.
1281       *
1282       * @param pixelX The X location at which you want to search for a vacant area.
1283       * @param pixelY The Y location at which you want to search for a vacant area.
1284       * @param spanX Horizontal span of the object.
1285       * @param spanY Vertical span of the object.
1286       * @param ignoreOccupied If true, the result can be an occupied cell
1287       * @param result Array in which to place the result, or null (in which case a new array will
1288       *        be allocated)
1289       * @return The X, Y cell of a vacant area that can contain this object,
1290       *         nearest the requested location.
1291       */
1292      int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1293              boolean ignoreOccupied, int[] result) {
1294          return findNearestArea(pixelX, pixelY, spanX, spanY,
1295                  spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1296      }
1297  
1298      private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1299      private void lazyInitTempRectStack() {
1300          if (mTempRectStack.isEmpty()) {
1301              for (int i = 0; i &lt; mCountX * mCountY; i++) {
1302                  mTempRectStack.push(new Rect());
1303              }
1304          }
1305      }
1306  
1307      private void recycleTempRects(Stack&lt;Rect&gt; used) {
1308          while (!used.isEmpty()) {
1309              mTempRectStack.push(used.pop());
1310          }
1311      }
1312  
1313      /**
1314       * Find a vacant area that will fit the given bounds nearest the requested
1315       * cell location. Uses Euclidean distance to score multiple vacant areas.
1316       *
1317       * @param pixelX The X location at which you want to search for a vacant area.
1318       * @param pixelY The Y location at which you want to search for a vacant area.
1319       * @param minSpanX The minimum horizontal span required
1320       * @param minSpanY The minimum vertical span required
1321       * @param spanX Horizontal span of the object.
1322       * @param spanY Vertical span of the object.
1323       * @param ignoreOccupied If true, the result can be an occupied cell
1324       * @param result Array in which to place the result, or null (in which case a new array will
1325       *        be allocated)
1326       * @return The X, Y cell of a vacant area that can contain this object,
1327       *         nearest the requested location.
1328       */
1329      int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1330              View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1331              boolean[][] occupied) {
1332          lazyInitTempRectStack();
1333          // mark space take by ignoreView as available (method checks if ignoreView is null)
1334          markCellsAsUnoccupiedForView(ignoreView, occupied);
1335  
1336          // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1337          // to the center of the item, but we are searching based on the top-left cell, so
1338          // we translate the point over to correspond to the top-left.
1339          pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1340          pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1341  
1342          // Keep track of best-scoring drop area
1343          final int[] bestXY = result != null ? result : new int[2];
1344          double bestDistance = Double.MAX_VALUE;
1345          final Rect bestRect = new Rect(-1, -1, -1, -1);
1346          final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1347  
1348          final int countX = mCountX;
1349          final int countY = mCountY;
1350  
1351          if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1352                  spanX &lt; minSpanX || spanY &lt; minSpanY) {
1353              return bestXY;
1354          }
1355  
1356          for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1357              inner:
1358              for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1359                  int ySize = -1;
1360                  int xSize = -1;
1361                  if (ignoreOccupied) {
1362                      // First, let&#x27;s see if this thing fits anywhere
1363                      for (int i = 0; i &lt; minSpanX; i++) {
1364                          for (int j = 0; j &lt; minSpanY; j++) {
1365                              if (occupied[x + i][y + j]) {
1366                                  continue inner;
1367                              }
1368                          }
1369                      }
1370                      xSize = minSpanX;
1371                      ySize = minSpanY;
1372  
1373                      // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1374                      // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1375                      // until we hit a limit.
1376                      boolean incX = true;
1377                      boolean hitMaxX = xSize &gt;= spanX;
1378                      boolean hitMaxY = ySize &gt;= spanY;
1379                      while (!(hitMaxX &amp;&amp; hitMaxY)) {
1380                          if (incX &amp;&amp; !hitMaxX) {
1381                              for (int j = 0; j &lt; ySize; j++) {
1382                                  if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1383                                      // We can&#x27;t move out horizontally
1384                                      hitMaxX = true;
1385                                  }
1386                              }
1387                              if (!hitMaxX) {
1388                                  xSize++;
1389                              }
1390                          } else if (!hitMaxY) {
1391                              for (int i = 0; i &lt; xSize; i++) {
1392                                  if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1393                                      // We can&#x27;t move out vertically
1394                                      hitMaxY = true;
1395                                  }
1396                              }
1397                              if (!hitMaxY) {
1398                                  ySize++;
1399                              }
1400                          }
1401                          hitMaxX |= xSize &gt;= spanX;
1402                          hitMaxY |= ySize &gt;= spanY;
1403                          incX = !incX;
1404                      }
1405                      incX = true;
1406                      hitMaxX = xSize &gt;= spanX;
1407                      hitMaxY = ySize &gt;= spanY;
1408                  }
1409                  final int[] cellXY = mTmpXY;
1410                  cellToCenterPoint(x, y, cellXY);
1411  
1412                  // We verify that the current rect is not a sub-rect of any of our previous
1413                  // candidates. In this case, the current rect is disqualified in favour of the
1414                  // containing rect.
1415                  Rect currentRect = mTempRectStack.pop();
1416                  currentRect.set(x, y, x + xSize, y + ySize);
1417                  boolean contained = false;
1418                  for (Rect r : validRegions) {
1419                      if (r.contains(currentRect)) {
1420                          contained = true;
1421                          break;
1422                      }
1423                  }
1424                  validRegions.push(currentRect);
1425                  double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1426                          + Math.pow(cellXY[1] - pixelY, 2));
1427  
1428                  if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1429                          currentRect.contains(bestRect)) {
1430                      bestDistance = distance;
1431                      bestXY[0] = x;
1432                      bestXY[1] = y;
1433                      if (resultSpan != null) {
1434                          resultSpan[0] = xSize;
1435                          resultSpan[1] = ySize;
1436                      }
1437                      bestRect.set(currentRect);
1438                  }
1439              }
1440          }
1441          // re-mark space taken by ignoreView as occupied
1442          markCellsAsOccupiedForView(ignoreView, occupied);
1443  
1444          // Return -1, -1 if no suitable location found
1445          if (bestDistance == Double.MAX_VALUE) {
1446              bestXY[0] = -1;
1447              bestXY[1] = -1;
1448          }
1449          recycleTempRects(validRegions);
1450          return bestXY;
1451      }
1452  
1453       /**
1454       * Find a vacant area that will fit the given bounds nearest the requested
1455       * cell location, and will also weigh in a suggested direction vector of the
1456       * desired location. This method computers distance based on unit grid distances,
1457       * not pixel distances.
1458       *
1459       * @param cellX The X cell nearest to which you want to search for a vacant area.
1460       * @param cellY The Y cell nearest which you want to search for a vacant area.
1461       * @param spanX Horizontal span of the object.
1462       * @param spanY Vertical span of the object.
1463       * @param direction The favored direction in which the views should move from x, y
1464       * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1465       *        matches exactly. Otherwise we find the best matching direction.
1466       * @param occoupied The array which represents which cells in the CellLayout are occupied
1467       * @param blockOccupied The array which represents which cells in the specified block (cellX,
1468       *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.
1469       * @param result Array in which to place the result, or null (in which case a new array will
1470       *        be allocated)
1471       * @return The X, Y cell of a vacant area that can contain this object,
1472       *         nearest the requested location.
1473       */
1474      private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1475              boolean[][] occupied, boolean blockOccupied[][], int[] result) {
1476          // Keep track of best-scoring drop area
1477          final int[] bestXY = result != null ? result : new int[2];
1478          float bestDistance = Float.MAX_VALUE;
1479          int bestDirectionScore = Integer.MIN_VALUE;
1480  
1481          final int countX = mCountX;
1482          final int countY = mCountY;
1483  
1484          for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1485              inner:
1486              for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1487                  // First, let&#x27;s see if this thing fits anywhere
1488                  for (int i = 0; i &lt; spanX; i++) {
1489                      for (int j = 0; j &lt; spanY; j++) {
1490                          if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1491                              continue inner;
1492                          }
1493                      }
1494                  }
1495  
1496                  float distance = (float)
1497                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1498                  int[] curDirection = mTmpPoint;
1499                  computeDirectionVector(x - cellX, y - cellY, curDirection);
1500                  // The direction score is just the dot product of the two candidate direction
1501                  // and that passed in.
1502                  int curDirectionScore = direction[0] * curDirection[0] +
1503                          direction[1] * curDirection[1];
1504                  boolean exactDirectionOnly = false;
1505                  boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1506                          direction[0] == curDirection[0];
1507                  if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1508                          Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1509                          bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1510                      bestDistance = distance;
1511                      bestDirectionScore = curDirectionScore;
1512                      bestXY[0] = x;
1513                      bestXY[1] = y;
1514                  }
1515              }
1516          }
1517  
1518          // Return -1, -1 if no suitable location found
1519          if (bestDistance == Float.MAX_VALUE) {
1520              bestXY[0] = -1;
1521              bestXY[1] = -1;
1522          }
1523          return bestXY;
1524      }
1525  
1526      private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,
1527              int[] direction,boolean[][] occupied,
1528              boolean blockOccupied[][], int[] result) {
1529          // Keep track of best-scoring drop area
1530          final int[] bestXY = result != null ? result : new int[2];
1531          bestXY[0] = -1;
1532          bestXY[1] = -1;
1533          float bestDistance = Float.MAX_VALUE;
1534  
1535          // We use this to march in a single direction
1536          if ((direction[0] != 0 &amp;&amp; direction[1] != 0) ||
1537                  (direction[0] == 0 &amp;&amp; direction[1] == 0)) {
1538              return bestXY;
1539          }
1540  
1541          // This will only incrememnet one of x or y based on the assertion above
1542          int x = cellX + direction[0];
1543          int y = cellY + direction[1];
1544          while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1545 -</span>
1546              boolean fail = false;
1547              for (int i = 0; i &lt; spanX; i++) {
1548                  for (int j = 0; j &lt; spanY; j++) {
1549                      if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1550                          fail = true;
1551                      }
1552                  }
1553              }
1554              if (!fail) {
1555                  float distance = (float)
1556                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1557                  if (Float.compare(distance,  bestDistance) &lt; 0) {
1558                      bestDistance = distance;
1559                      bestXY[0] = x;
1560                      bestXY[1] = y;
1561                  }
1562              }
1563              x += direction[0];
1564              y += direction[1];
1565          }
1566          return bestXY;
1567      }
1568  
1569      private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1570              int[] direction, ItemConfiguration currentState) {
1571          CellAndSpan c = currentState.map.get(v);
1572          boolean success = false;
1573          markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1574          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1575  
1576          findNearestArea(c.x, c.y, c.spanX, c.spanY, direction, mTmpOccupied, null, mTempLocation);
1577  
1578          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1579              c.x = mTempLocation[0];
1580              c.y = mTempLocation[1];
1581              success = true;
1582  
1583          }
1584          markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1585          return success;
1586      }
1587  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1588 -    // This method looks in the specified direction to see if there is an additional view</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1589 -    // immediately adjecent in that direction</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1590 +    // This method looks in the specified direction to see if there are additional views adjacent</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1591 +    // to the current set of views in the. If there is, then these views are added to the current</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1592 +    // set of views. This is performed iteratively, giving a cascading push behaviour.</span>
1593      private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,
1594              boolean[][] occupied, View dragView, ItemConfiguration currentState) {
1595          boolean found = false;
1596  
1597          int childCount = mShortcutsAndWidgets.getChildCount();
1598          Rect r0 = new Rect(boundingRect);
1599          Rect r1 = new Rect();
1600  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1601 +        // First, we consider the rect of the views that we are trying to translate</span>
1602          int deltaX = 0;
1603          int deltaY = 0;
1604          if (direction[1] &lt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1605 -            r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1606 +            r0.set(r0.left, r0.top - 1, r0.right, r0.bottom - 1);</span>
1607              deltaY = -1;
1608          } else if (direction[1] &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1609 -            r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1610 +            r0.set(r0.left, r0.top + 1, r0.right, r0.bottom + 1);</span>
1611              deltaY = 1;
1612          } else if (direction[0] &lt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1613 -            r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1614 +            r0.set(r0.left - 1, r0.top, r0.right - 1, r0.bottom);</span>
1615              deltaX = -1;
1616          } else if (direction[0] &gt; 0) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1617 -            r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1618 +            r0.set(r0.left + 1, r0.top, r0.right + 1, r0.bottom);</span>
1619              deltaX = 1;
1620          }
1621  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1622 +        // Now we see which views, if any, are being overlapped by shifting the current group</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1623 +        // of views in the desired direction.</span>
1624          for (int i = 0; i &lt; childCount; i++) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1625 +            // We don&#x27;t need to worry about views already in our group, or the current drag view.</span>
1626              View child = mShortcutsAndWidgets.getChildAt(i);
1627              if (views.contains(child) || child == dragView) continue;
1628              CellAndSpan c = currentState.map.get(child);
1629  
1630              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1631              r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1632              if (Rect.intersects(r0, r1)) {
1633                  if (!lp.canReorder) {
1634                      return false;
1635                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1636 -                boolean pushed = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1637 -                for (int x = c.x; x &lt; c.x + c.spanX; x++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1638 -                    for (int y = c.y; y &lt; c.y + c.spanY; y++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1639 -                        boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1640 -                                &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1641 -                        if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1642 -                            pushed = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1643 +                // First we verify that the view in question is at the border of the extents</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1644 +                // of the block of items we are pushing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1645 +                if ((direction[0] &lt; 0 &amp;&amp; c.x == r0.left) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1646 +                        (direction[0] &gt; 0 &amp;&amp; c.x == r0.right - 1) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1647 +                        (direction[1] &lt; 0 &amp;&amp; c.y == r0.top) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1648 +                        (direction[1] &gt; 0 &amp;&amp; c.y == r0.bottom - 1)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1649 +                    boolean pushed = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1650 +                    // Since the bounding rect is a course description of the region (there can</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1651 +                    // be holes at the edge of the block), we need to check to verify that a solid</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1652 +                    // piece is intersecting. This ensures that interlocking is possible.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1653 +                    for (int x = c.x; x &lt; c.x + c.spanX; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1654 +                        for (int y = c.y; y &lt; c.y + c.spanY; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1655 +                            if (occupied[x - deltaX][y - deltaY]) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1656 +                                pushed = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1657 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1658 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1659 +                            if (pushed) break;</span>
1660                          }
1661                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1662 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1663 -                if (pushed) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1664 -                    views.add(child);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1665 -                    boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1666 -                    found = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1667 +                    if (pushed) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1668 +                        views.add(child);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1669 +                        boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1670 +                        found = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1671 +                    }</span>
1672                  }
1673              }
1674          }
1675          return found;
1676      }
1677  
1678      private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1679              int[] direction, boolean push, View dragView, ItemConfiguration currentState) {
1680          if (views.size() == 0) return true;
1681  
1682          boolean success = false;
1683          Rect boundingRect = null;
1684          // We construct a rect which represents the entire group of views passed in
1685          for (View v: views) {
1686              CellAndSpan c = currentState.map.get(v);
1687              if (boundingRect == null) {
1688                  boundingRect = new Rect(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1689              } else {
1690                  boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1691              }
1692          }
1693  
1694          @SuppressWarnings(&quot;unchecked&quot;)
1695          ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();
1696          // We try and expand the group of views in the direction vector passed, based on
1697          // whether they are physically adjacent, ie. based on &quot;push mechanics&quot;.
1698          while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView,
1699                  currentState)) {
1700          }
1701  
1702          // Mark the occupied state as false for the group of views we want to move.
1703          for (View v: dup) {
1704              CellAndSpan c = currentState.map.get(v);
1705              markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1706          }
1707  
1708          boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1709          int top = boundingRect.top;
1710          int left = boundingRect.left;
1711          // We mark more precisely which parts of the bounding rect are truly occupied, allowing
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1712 -        // for tetris-style interlocking.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1713 +        // for interlocking.</span>
1714          for (View v: dup) {
1715              CellAndSpan c = currentState.map.get(v);
1716              markCellsForView(c.x - left, c.y - top, c.spanX, c.spanY, blockOccupied, true);
1717          }
1718  
1719          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1720  
1721          if (push) {
1722              findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),
1723                      boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1724          } else {
1725              findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),
1726                      boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1727          }
1728  
1729          // If we successfuly found a location by pushing the block of views, we commit it
1730          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1731              int deltaX = mTempLocation[0] - boundingRect.left;
1732              int deltaY = mTempLocation[1] - boundingRect.top;
1733              for (View v: dup) {
1734                  CellAndSpan c = currentState.map.get(v);
1735                  c.x += deltaX;
1736                  c.y += deltaY;
1737              }
1738              success = true;
1739          }
1740  
1741          // In either case, we set the occupied array as marked for the location of the views
1742          for (View v: dup) {
1743              CellAndSpan c = currentState.map.get(v);
1744              markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1745          }
1746          return success;
1747      }
1748  
1749      private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1750          markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1751      }
1752  
1753      // This method tries to find a reordering solution which satisfies the push mechanic by trying
1754      // to push items in each of the cardinal directions, in an order based on the direction vector
1755      // passed.
1756      private boolean attemptPushInDirection(ArrayList&lt;View&gt; intersectingViews, Rect occupied,
1757              int[] direction, View ignoreView, ItemConfiguration solution) {
1758          if ((Math.abs(direction[0]) + Math.abs(direction[1])) &gt; 1) {
1759              // If the direction vector has two non-zero components, we try pushing
1760              // separately in each of the components.
1761              int temp = direction[1];
1762              direction[1] = 0;
1763              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1764                      ignoreView, solution)) {
1765                  return true;
1766              }
1767              direction[1] = temp;
1768              temp = direction[0];
1769              direction[0] = 0;
1770              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1771                      ignoreView, solution)) {
1772                  return true;
1773              }
1774              // Revert the direction
1775              direction[0] = temp;
1776  
1777              // Now we try pushing in each component of the opposite direction
1778              direction[0] *= -1;
1779              direction[1] *= -1;
1780              temp = direction[1];
1781              direction[1] = 0;
1782              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1783                      ignoreView, solution)) {
1784                  return true;
1785              }
1786  
1787              direction[1] = temp;
1788              temp = direction[0];
1789              direction[0] = 0;
1790              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1791                      ignoreView, solution)) {
1792                  return true;
1793              }
1794              // revert the direction
1795              direction[0] = temp;
1796              direction[0] *= -1;
1797              direction[1] *= -1;
1798  
1799          } else {
1800              // If the direction vector has a single non-zero component, we push first in the
1801              // direction of the vector
1802              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1803                      ignoreView, solution)) {
1804                  return true;
1805              }
1806  
1807              // Then we try the opposite direction
1808              direction[0] *= -1;
1809              direction[1] *= -1;
1810              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1811                      ignoreView, solution)) {
1812                  return true;
1813              }
1814              // Switch the direction back
1815              direction[0] *= -1;
1816              direction[1] *= -1;
1817  
1818              // If we have failed to find a push solution with the above, then we try
1819              // to find a solution by pushing along the perpendicular axis.
1820  
1821              // Swap the components
1822              int temp = direction[1];
1823              direction[1] = direction[0];
1824              direction[0] = temp;
1825              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1826                      ignoreView, solution)) {
1827                  return true;
1828              }
1829  
1830              // Then we try the opposite direction
1831              direction[0] *= -1;
1832              direction[1] *= -1;
1833              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1834                      ignoreView, solution)) {
1835                  return true;
1836              }
1837              // Switch the direction back
1838              direction[0] *= -1;
1839              direction[1] *= -1;
1840  
1841              // Swap the components back
1842              temp = direction[1];
1843              direction[1] = direction[0];
1844              direction[0] = temp;
1845          }
1846          return false;
1847      }
1848  
1849      private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1850              View ignoreView, ItemConfiguration solution) {
1851          // Return early if get invalid cell positions
1852          if (cellX &lt; 0 || cellY &lt; 0) return false;
1853  
1854          mIntersectingViews.clear();
1855          mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1856  
1857          // Mark the desired location of the view currently being dragged.
1858          if (ignoreView != null) {
1859              CellAndSpan c = solution.map.get(ignoreView);
1860              if (c != null) {
1861                  c.x = cellX;
1862                  c.y = cellY;
1863              }
1864          }
1865          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1866          Rect r1 = new Rect();
1867          for (View child: solution.map.keySet()) {
1868              if (child == ignoreView) continue;
1869              CellAndSpan c = solution.map.get(child);
1870              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1871              r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1872              if (Rect.intersects(r0, r1)) {
1873                  if (!lp.canReorder) {
1874                      return false;
1875                  }
1876                  mIntersectingViews.add(child);
1877              }
1878          }
1879  
1880          // First we try to find a solution which respects the push mechanic. That is,
1881          // we try to find a solution such that no displaced item travels through another item
1882          // without also displacing that item.
1883          if (attemptPushInDirection(mIntersectingViews, mOccupiedRect, direction, ignoreView,
1884                  solution)) {
1885              return true;
1886          }
1887  
1888          // Next we try moving the views as a block, but without requiring the push mechanic.
1889          if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction, false, ignoreView,
1890                  solution)) {
1891              return true;
1892          }
1893  
1894          // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1895          for (View v : mIntersectingViews) {
1896              if (!addViewToTempLocation(v, mOccupiedRect, direction, solution)) {
1897                  return false;
1898              }
1899          }
1900          return true;
1901      }
1902  
1903      /*
1904       * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1905       * the provided point and the provided cell
1906       */
1907      private void computeDirectionVector(float deltaX, float deltaY, int[] result) {
1908          double angle = Math.atan(((float) deltaY) / deltaX);
1909  
1910          result[0] = 0;
1911          result[1] = 0;
1912          if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1913              result[0] = (int) Math.signum(deltaX);
1914          }
1915          if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1916              result[1] = (int) Math.signum(deltaY);
1917          }
1918      }
1919  
1920      private void copyOccupiedArray(boolean[][] occupied) {
1921          for (int i = 0; i &lt; mCountX; i++) {
1922              for (int j = 0; j &lt; mCountY; j++) {
1923                  occupied[i][j] = mOccupied[i][j];
1924              }
1925          }
1926      }
1927  
1928      ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1929              int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1930          // Copy the current state into the solution. This solution will be manipulated as necessary.
1931          copyCurrentStateToSolution(solution, false);
1932          // Copy the current occupied array into the temporary occupied array. This array will be
1933          // manipulated as necessary to find a solution.
1934          copyOccupiedArray(mTmpOccupied);
1935  
1936          // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1937          // nothing in its way.
1938          int result[] = new int[2];
1939          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1940  
1941          boolean success = false;
1942          // First we try the exact nearest position of the item being dragged,
1943          // we will then want to try to move this around to other neighbouring positions
1944          success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView,
1945                  solution);
1946  
1947          if (!success) {
1948              // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1949              // x, then 1 in y etc.
1950              if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1951                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1952                          dragView, false, solution);
1953              } else if (spanY &gt; minSpanY) {
1954                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1955                          dragView, true, solution);
1956              }
1957              solution.isSolution = false;
1958          } else {
1959              solution.isSolution = true;
1960              solution.dragViewX = result[0];
1961              solution.dragViewY = result[1];
1962              solution.dragViewSpanX = spanX;
1963              solution.dragViewSpanY = spanY;
1964          }
1965          return solution;
1966      }
1967  
1968      private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1969          int childCount = mShortcutsAndWidgets.getChildCount();
1970          for (int i = 0; i &lt; childCount; i++) {
1971              View child = mShortcutsAndWidgets.getChildAt(i);
1972              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1973              CellAndSpan c;
1974              if (temp) {
1975                  c = new CellAndSpan(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan);
1976              } else {
1977                  c = new CellAndSpan(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan);
1978              }
1979              solution.map.put(child, c);
1980          }
1981      }
1982  
1983      private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1984          for (int i = 0; i &lt; mCountX; i++) {
1985              for (int j = 0; j &lt; mCountY; j++) {
1986                  mTmpOccupied[i][j] = false;
1987              }
1988          }
1989  
1990          int childCount = mShortcutsAndWidgets.getChildCount();
1991          for (int i = 0; i &lt; childCount; i++) {
1992              View child = mShortcutsAndWidgets.getChildAt(i);
1993              if (child == dragView) continue;
1994              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1995              CellAndSpan c = solution.map.get(child);
1996              if (c != null) {
1997                  lp.tmpCellX = c.x;
1998                  lp.tmpCellY = c.y;
1999                  lp.cellHSpan = c.spanX;
2000                  lp.cellVSpan = c.spanY;
2001                  markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
2002              }
2003          }
2004          markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2005                  solution.dragViewSpanY, mTmpOccupied, true);
2006      }
2007  
2008      private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
2009              commitDragView) {
2010  
2011          boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
2012          for (int i = 0; i &lt; mCountX; i++) {
2013              for (int j = 0; j &lt; mCountY; j++) {
2014                  occupied[i][j] = false;
2015              }
2016          }
2017  
2018          int childCount = mShortcutsAndWidgets.getChildCount();
2019          for (int i = 0; i &lt; childCount; i++) {
2020              View child = mShortcutsAndWidgets.getChildAt(i);
2021              if (child == dragView) continue;
2022              CellAndSpan c = solution.map.get(child);
2023              if (c != null) {
2024                  animateChildToPosition(child, c.x, c.y, REORDER_ANIMATION_DURATION, 0,
2025                          DESTRUCTIVE_REORDER, false);
2026                  markCellsForView(c.x, c.y, c.spanX, c.spanY, occupied, true);
2027              }
2028          }
2029          if (commitDragView) {
2030              markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
2031                      solution.dragViewSpanY, occupied, true);
2032          }
2033      }
2034  
2035      // This method starts or changes the reorder hint animations
2036      private void beginOrAdjustHintAnimations(ItemConfiguration solution, View dragView, int delay) {
2037          int childCount = mShortcutsAndWidgets.getChildCount();
2038          for (int i = 0; i &lt; childCount; i++) {
2039              View child = mShortcutsAndWidgets.getChildAt(i);
2040              if (child == dragView) continue;
2041              CellAndSpan c = solution.map.get(child);
2042              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2043              if (c != null) {
2044                  ReorderHintAnimation rha = new ReorderHintAnimation(child, lp.cellX, lp.cellY,
2045                          c.x, c.y, c.spanX, c.spanY);
2046                  rha.animate();
2047              }
2048          }
2049      }
2050  
2051      // Class which represents the reorder hint animations. These animations show that an item is
2052      // in a temporary state, and hint at where the item will return to.
2053      class ReorderHintAnimation {
2054          View child;
2055          float finalDeltaX;
2056          float finalDeltaY;
2057          float initDeltaX;
2058          float initDeltaY;
2059          float finalScale;
2060          float initScale;
2061          private static final int DURATION = 300;
2062          Animator a;
2063  
2064          public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1,
2065                  int spanX, int spanY) {
2066              regionToCenterPoint(cellX0, cellY0, spanX, spanY, mTmpPoint);
2067              final int x0 = mTmpPoint[0];
2068              final int y0 = mTmpPoint[1];
2069              regionToCenterPoint(cellX1, cellY1, spanX, spanY, mTmpPoint);
2070              final int x1 = mTmpPoint[0];
2071              final int y1 = mTmpPoint[1];
2072              final int dX = x1 - x0;
2073              final int dY = y1 - y0;
2074              finalDeltaX = 0;
2075              finalDeltaY = 0;
2076              if (dX == dY &amp;&amp; dX == 0) {
2077              } else {
2078                  if (dY == 0) {
2079                      finalDeltaX = - Math.signum(dX) * mReorderHintAnimationMagnitude;
2080                  } else if (dX == 0) {
2081                      finalDeltaY = - Math.signum(dY) * mReorderHintAnimationMagnitude;
2082                  } else {
2083                      double angle = Math.atan( (float) (dY) / dX);
2084                      finalDeltaX = (int) (- Math.signum(dX) *
2085                              Math.abs(Math.cos(angle) * mReorderHintAnimationMagnitude));
2086                      finalDeltaY = (int) (- Math.signum(dY) *
2087                              Math.abs(Math.sin(angle) * mReorderHintAnimationMagnitude));
2088                  }
2089              }
2090              initDeltaX = child.getTranslationX();
2091              initDeltaY = child.getTranslationY();
2092              finalScale = 1.0f - 4.0f / child.getWidth();
2093              initScale = child.getScaleX();
2094  
2095              child.setPivotY(child.getMeasuredHeight() * 0.5f);
2096              child.setPivotX(child.getMeasuredWidth() * 0.5f);
2097              this.child = child;
2098          }
2099  
2100          void animate() {
2101              if (mShakeAnimators.containsKey(child)) {
2102                  ReorderHintAnimation oldAnimation = mShakeAnimators.get(child);
2103                  oldAnimation.cancel();
2104                  mShakeAnimators.remove(child);
2105                  if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2106                      completeAnimationImmediately();
2107                      return;
2108                  }
2109              }
2110              if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2111                  return;
2112              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2113 -            ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2114 +            ValueAnimator va = LauncherAnimUtils.ofFloat(0f, 1f);</span>
2115              a = va;
2116              va.setRepeatMode(ValueAnimator.REVERSE);
2117              va.setRepeatCount(ValueAnimator.INFINITE);
2118              va.setDuration(DURATION);
2119              va.setStartDelay((int) (Math.random() * 60));
2120              va.addUpdateListener(new AnimatorUpdateListener() {
2121                  @Override
2122                  public void onAnimationUpdate(ValueAnimator animation) {
2123                      float r = ((Float) animation.getAnimatedValue()).floatValue();
2124                      float x = r * finalDeltaX + (1 - r) * initDeltaX;
2125                      float y = r * finalDeltaY + (1 - r) * initDeltaY;
2126                      child.setTranslationX(x);
2127                      child.setTranslationY(y);
2128                      float s = r * finalScale + (1 - r) * initScale;
2129                      child.setScaleX(s);
2130                      child.setScaleY(s);
2131                  }
2132              });
2133              va.addListener(new AnimatorListenerAdapter() {
2134                  public void onAnimationRepeat(Animator animation) {
2135                      // We make sure to end only after a full period
2136                      initDeltaX = 0;
2137                      initDeltaY = 0;
2138                      initScale = 1.0f;
2139                  }
2140              });
2141              mShakeAnimators.put(child, this);
2142              va.start();
2143          }
2144  
2145          private void cancel() {
2146              if (a != null) {
2147                  a.cancel();
2148              }
2149          }
2150  
2151          private void completeAnimationImmediately() {
2152              if (a != null) {
2153                  a.cancel();
2154              }
2155  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2156 -            AnimatorSet s = new AnimatorSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2157 +            AnimatorSet s = LauncherAnimUtils.createAnimatorSet();</span>
2158              a = s;
2159              s.playTogether(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2160 -                ObjectAnimator.ofFloat(child, &quot;scaleX&quot;, 1f),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2161 -                ObjectAnimator.ofFloat(child, &quot;scaleY&quot;, 1f),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2162 -                ObjectAnimator.ofFloat(child, &quot;translationX&quot;, 0f),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2163 -                ObjectAnimator.ofFloat(child, &quot;translationY&quot;, 0f)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2164 +                LauncherAnimUtils.ofFloat(child, &quot;scaleX&quot;, 1f),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2165 +                LauncherAnimUtils.ofFloat(child, &quot;scaleY&quot;, 1f),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2166 +                LauncherAnimUtils.ofFloat(child, &quot;translationX&quot;, 0f),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2167 +                LauncherAnimUtils.ofFloat(child, &quot;translationY&quot;, 0f)</span>
2168              );
2169              s.setDuration(REORDER_ANIMATION_DURATION);
2170              s.setInterpolator(new android.view.animation.DecelerateInterpolator(1.5f));
2171              s.start();
2172          }
2173      }
2174  
2175      private void completeAndClearReorderHintAnimations() {
2176          for (ReorderHintAnimation a: mShakeAnimators.values()) {
2177              a.completeAnimationImmediately();
2178          }
2179          mShakeAnimators.clear();
2180      }
2181  
2182      private void commitTempPlacement() {
2183          for (int i = 0; i &lt; mCountX; i++) {
2184              for (int j = 0; j &lt; mCountY; j++) {
2185                  mOccupied[i][j] = mTmpOccupied[i][j];
2186              }
2187          }
2188          int childCount = mShortcutsAndWidgets.getChildCount();
2189          for (int i = 0; i &lt; childCount; i++) {
2190              View child = mShortcutsAndWidgets.getChildAt(i);
2191              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2192              ItemInfo info = (ItemInfo) child.getTag();
2193              // We do a null check here because the item info can be null in the case of the
2194              // AllApps button in the hotseat.
2195              if (info != null) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2196 +                if (info.cellX != lp.tmpCellX || info.cellY != lp.tmpCellY ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2197 +                        info.spanX != lp.cellHSpan || info.spanY != lp.cellVSpan) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2198 +                    info.requiresDbUpdate = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2199 +                }</span>
2200                  info.cellX = lp.cellX = lp.tmpCellX;
2201                  info.cellY = lp.cellY = lp.tmpCellY;
2202                  info.spanX = lp.cellHSpan;
2203                  info.spanY = lp.cellVSpan;
2204              }
2205          }
2206          mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
2207      }
2208  
2209      public void setUseTempCoords(boolean useTempCoords) {
2210          int childCount = mShortcutsAndWidgets.getChildCount();
2211          for (int i = 0; i &lt; childCount; i++) {
2212              LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2213              lp.useTmpCoords = useTempCoords;
2214          }
2215      }
2216  
2217      ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2218              int spanX, int spanY, View dragView, ItemConfiguration solution) {
2219          int[] result = new int[2];
2220          int[] resultSpan = new int[2];
2221          findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2222                  resultSpan);
2223          if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2224              copyCurrentStateToSolution(solution, false);
2225              solution.dragViewX = result[0];
2226              solution.dragViewY = result[1];
2227              solution.dragViewSpanX = resultSpan[0];
2228              solution.dragViewSpanY = resultSpan[1];
2229              solution.isSolution = true;
2230          } else {
2231              solution.isSolution = false;
2232          }
2233          return solution;
2234      }
2235  
2236      public void prepareChildForDrag(View child) {
2237          markCellsAsUnoccupiedForView(child);
2238      }
2239  
2240      /* This seems like it should be obvious and straight-forward, but when the direction vector
2241      needs to match with the notion of the dragView pushing other views, we have to employ
2242      a slightly more subtle notion of the direction vector. The question is what two points is
2243      the vector between? The center of the dragView and its desired destination? Not quite, as
2244      this doesn&#x27;t necessarily coincide with the interaction of the dragView and items occupying
2245      those cells. Instead we use some heuristics to often lock the vector to up, down, left
2246      or right, which helps make pushing feel right.
2247      */
2248      private void getDirectionVectorForDrop(int dragViewCenterX, int dragViewCenterY, int spanX,
2249              int spanY, View dragView, int[] resultDirection) {
2250          int[] targetDestination = new int[2];
2251  
2252          findNearestArea(dragViewCenterX, dragViewCenterY, spanX, spanY, targetDestination);
2253          Rect dragRect = new Rect();
2254          regionToRect(targetDestination[0], targetDestination[1], spanX, spanY, dragRect);
2255          dragRect.offset(dragViewCenterX - dragRect.centerX(), dragViewCenterY - dragRect.centerY());
2256  
2257          Rect dropRegionRect = new Rect();
2258          getViewsIntersectingRegion(targetDestination[0], targetDestination[1], spanX, spanY,
2259                  dragView, dropRegionRect, mIntersectingViews);
2260  
2261          int dropRegionSpanX = dropRegionRect.width();
2262          int dropRegionSpanY = dropRegionRect.height();
2263  
2264          regionToRect(dropRegionRect.left, dropRegionRect.top, dropRegionRect.width(),
2265                  dropRegionRect.height(), dropRegionRect);
2266  
2267          int deltaX = (dropRegionRect.centerX() - dragViewCenterX) / spanX;
2268          int deltaY = (dropRegionRect.centerY() - dragViewCenterY) / spanY;
2269  
2270          if (dropRegionSpanX == mCountX || spanX == mCountX) {
2271              deltaX = 0;
2272          }
2273          if (dropRegionSpanY == mCountY || spanY == mCountY) {
2274              deltaY = 0;
2275          }
2276  
2277          if (deltaX == 0 &amp;&amp; deltaY == 0) {
2278              // No idea what to do, give a random direction.
2279              resultDirection[0] = 1;
2280              resultDirection[1] = 0;
2281          } else {
2282              computeDirectionVector(deltaX, deltaY, resultDirection);
2283          }
2284      }
2285  
2286      // For a given cell and span, fetch the set of views intersecting the region.
2287      private void getViewsIntersectingRegion(int cellX, int cellY, int spanX, int spanY,
2288              View dragView, Rect boundingRect, ArrayList&lt;View&gt; intersectingViews) {
2289          if (boundingRect != null) {
2290              boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
2291          }
2292          intersectingViews.clear();
2293          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
2294          Rect r1 = new Rect();
2295          final int count = mShortcutsAndWidgets.getChildCount();
2296          for (int i = 0; i &lt; count; i++) {
2297              View child = mShortcutsAndWidgets.getChildAt(i);
2298              if (child == dragView) continue;
2299              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2300              r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
2301              if (Rect.intersects(r0, r1)) {
2302                  mIntersectingViews.add(child);
2303                  if (boundingRect != null) {
2304                      boundingRect.union(r1);
2305                  }
2306              }
2307          }
2308      }
2309  
2310      boolean isNearestDropLocationOccupied(int pixelX, int pixelY, int spanX, int spanY,
2311              View dragView, int[] result) {
2312          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2313          getViewsIntersectingRegion(result[0], result[1], spanX, spanY, dragView, null,
2314                  mIntersectingViews);
2315          return !mIntersectingViews.isEmpty();
2316      }
2317  
2318      void revertTempState() {
2319          if (!isItemPlacementDirty() || DESTRUCTIVE_REORDER) return;
2320          final int count = mShortcutsAndWidgets.getChildCount();
2321          for (int i = 0; i &lt; count; i++) {
2322              View child = mShortcutsAndWidgets.getChildAt(i);
2323              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2324              if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
2325                  lp.tmpCellX = lp.cellX;
2326                  lp.tmpCellY = lp.cellY;
2327                  animateChildToPosition(child, lp.cellX, lp.cellY, REORDER_ANIMATION_DURATION,
2328                          0, false, false);
2329              }
2330          }
2331          completeAndClearReorderHintAnimations();
2332          setItemPlacementDirty(false);
2333      }
2334  
2335      boolean createAreaForResize(int cellX, int cellY, int spanX, int spanY,
2336              View dragView, int[] direction, boolean commit) {
2337          int[] pixelXY = new int[2];
2338          regionToCenterPoint(cellX, cellY, spanX, spanY, pixelXY);
2339  
2340          // First we determine if things have moved enough to cause a different layout
2341          ItemConfiguration swapSolution = simpleSwap(pixelXY[0], pixelXY[1], spanX, spanY,
2342                   spanX,  spanY, direction, dragView,  true,  new ItemConfiguration());
2343  
2344          setUseTempCoords(true);
2345          if (swapSolution != null &amp;&amp; swapSolution.isSolution) {
2346              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2347              // committing anything or animating anything as we just want to determine if a solution
2348              // exists
2349              copySolutionToTempState(swapSolution, dragView);
2350              setItemPlacementDirty(true);
2351              animateItemsToSolution(swapSolution, dragView, commit);
2352  
2353              if (commit) {
2354                  commitTempPlacement();
2355                  completeAndClearReorderHintAnimations();
2356                  setItemPlacementDirty(false);
2357              } else {
2358                  beginOrAdjustHintAnimations(swapSolution, dragView,
2359                          REORDER_ANIMATION_DURATION);
2360              }
2361              mShortcutsAndWidgets.requestLayout();
2362          }
2363          return swapSolution.isSolution;
2364      }
2365  
2366      int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2367              View dragView, int[] result, int resultSpan[], int mode) {
2368          // First we determine if things have moved enough to cause a different layout
2369          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2370  
2371          if (resultSpan == null) {
2372              resultSpan = new int[2];
2373          }
2374  
2375          // When we are checking drop validity or actually dropping, we don&#x27;t recompute the
2376          // direction vector, since we want the solution to match the preview, and it&#x27;s possible
2377          // that the exact position of the item has changed to result in a new reordering outcome.
2378          if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP)
2379                 &amp;&amp; mPreviousReorderDirection[0] != INVALID_DIRECTION) {
2380              mDirectionVector[0] = mPreviousReorderDirection[0];
2381              mDirectionVector[1] = mPreviousReorderDirection[1];
2382              // We reset this vector after drop
2383              if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2384                  mPreviousReorderDirection[0] = INVALID_DIRECTION;
2385                  mPreviousReorderDirection[1] = INVALID_DIRECTION;
2386              }
2387          } else {
2388              getDirectionVectorForDrop(pixelX, pixelY, spanX, spanY, dragView, mDirectionVector);
2389              mPreviousReorderDirection[0] = mDirectionVector[0];
2390              mPreviousReorderDirection[1] = mDirectionVector[1];
2391          }
2392  
2393          ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2394                   spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2395  
2396          // We attempt the approach which doesn&#x27;t shuffle views at all
2397          ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2398                  minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2399  
2400          ItemConfiguration finalSolution = null;
2401          if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2402              finalSolution = swapSolution;
2403          } else if (noShuffleSolution.isSolution) {
2404              finalSolution = noShuffleSolution;
2405          }
2406  
2407          boolean foundSolution = true;
2408          if (!DESTRUCTIVE_REORDER) {
2409              setUseTempCoords(true);
2410          }
2411  
2412          if (finalSolution != null) {
2413              result[0] = finalSolution.dragViewX;
2414              result[1] = finalSolution.dragViewY;
2415              resultSpan[0] = finalSolution.dragViewSpanX;
2416              resultSpan[1] = finalSolution.dragViewSpanY;
2417  
2418              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2419              // committing anything or animating anything as we just want to determine if a solution
2420              // exists
2421              if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2422                  if (!DESTRUCTIVE_REORDER) {
2423                      copySolutionToTempState(finalSolution, dragView);
2424                  }
2425                  setItemPlacementDirty(true);
2426                  animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2427  
2428                  if (!DESTRUCTIVE_REORDER &amp;&amp;
2429                          (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
2430                      commitTempPlacement();
2431                      completeAndClearReorderHintAnimations();
2432                      setItemPlacementDirty(false);
2433                  } else {
2434                      beginOrAdjustHintAnimations(finalSolution, dragView,
2435                              REORDER_ANIMATION_DURATION);
2436                  }
2437              }
2438          } else {
2439              foundSolution = false;
2440              result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2441          }
2442  
2443          if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2444              setUseTempCoords(false);
2445          }
2446  
2447          mShortcutsAndWidgets.requestLayout();
2448          return result;
2449      }
2450  
2451      void setItemPlacementDirty(boolean dirty) {
2452          mItemPlacementDirty = dirty;
2453      }
2454      boolean isItemPlacementDirty() {
2455          return mItemPlacementDirty;
2456      }
2457  
2458      private class ItemConfiguration {
2459          HashMap&lt;View, CellAndSpan&gt; map = new HashMap&lt;View, CellAndSpan&gt;();
2460          boolean isSolution = false;
2461          int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2462  
2463          int area() {
2464              return dragViewSpanX * dragViewSpanY;
2465          }
2466      }
2467  
2468      private class CellAndSpan {
2469          int x, y;
2470          int spanX, spanY;
2471  
2472          public CellAndSpan(int x, int y, int spanX, int spanY) {
2473              this.x = x;
2474              this.y = y;
2475              this.spanX = spanX;
2476              this.spanY = spanY;
2477          }
2478      }
2479  
2480      /**
2481       * Find a vacant area that will fit the given bounds nearest the requested
2482       * cell location. Uses Euclidean distance to score multiple vacant areas.
2483       *
2484       * @param pixelX The X location at which you want to search for a vacant area.
2485       * @param pixelY The Y location at which you want to search for a vacant area.
2486       * @param spanX Horizontal span of the object.
2487       * @param spanY Vertical span of the object.
2488       * @param ignoreView Considers space occupied by this view as unoccupied
2489       * @param result Previously returned value to possibly recycle.
2490       * @return The X, Y cell of a vacant area that can contain this object,
2491       *         nearest the requested location.
2492       */
2493      int[] findNearestVacantArea(
2494              int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2495          return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2496      }
2497  
2498      /**
2499       * Find a vacant area that will fit the given bounds nearest the requested
2500       * cell location. Uses Euclidean distance to score multiple vacant areas.
2501       *
2502       * @param pixelX The X location at which you want to search for a vacant area.
2503       * @param pixelY The Y location at which you want to search for a vacant area.
2504       * @param minSpanX The minimum horizontal span required
2505       * @param minSpanY The minimum vertical span required
2506       * @param spanX Horizontal span of the object.
2507       * @param spanY Vertical span of the object.
2508       * @param ignoreView Considers space occupied by this view as unoccupied
2509       * @param result Previously returned value to possibly recycle.
2510       * @return The X, Y cell of a vacant area that can contain this object,
2511       *         nearest the requested location.
2512       */
2513      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2514              int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2515          return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2516                  result, resultSpan, mOccupied);
2517      }
2518  
2519      /**
2520       * Find a starting cell position that will fit the given bounds nearest the requested
2521       * cell location. Uses Euclidean distance to score multiple vacant areas.
2522       *
2523       * @param pixelX The X location at which you want to search for a vacant area.
2524       * @param pixelY The Y location at which you want to search for a vacant area.
2525       * @param spanX Horizontal span of the object.
2526       * @param spanY Vertical span of the object.
2527       * @param ignoreView Considers space occupied by this view as unoccupied
2528       * @param result Previously returned value to possibly recycle.
2529       * @return The X, Y cell of a vacant area that can contain this object,
2530       *         nearest the requested location.
2531       */
2532      int[] findNearestArea(
2533              int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2534          return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2535      }
2536  
2537      boolean existsEmptyCell() {
2538          return findCellForSpan(null, 1, 1);
2539      }
2540  
2541      /**
2542       * Finds the upper-left coordinate of the first rectangle in the grid that can
2543       * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2544       * then this method will only return coordinates for rectangles that contain the cell
2545       * (intersectX, intersectY)
2546       *
2547       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2548       *               can be found.
2549       * @param spanX The horizontal span of the cell we want to find.
2550       * @param spanY The vertical span of the cell we want to find.
2551       *
2552       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2553       */
2554      boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2555          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2556      }
2557  
2558      /**
2559       * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2560       *
2561       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2562       *               can be found.
2563       * @param spanX The horizontal span of the cell we want to find.
2564       * @param spanY The vertical span of the cell we want to find.
2565       * @param ignoreView The home screen item we should treat as not occupying any space
2566       * @return
2567       */
2568      boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2569          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2570                  ignoreView, mOccupied);
2571      }
2572  
2573      /**
2574       * Like above, but if intersectX and intersectY are not -1, then this method will try to
2575       * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2576       *
2577       * @param spanX The horizontal span of the cell we want to find.
2578       * @param spanY The vertical span of the cell we want to find.
2579       * @param ignoreView The home screen item we should treat as not occupying any space
2580       * @param intersectX The X coordinate of the cell that we should try to overlap
2581       * @param intersectX The Y coordinate of the cell that we should try to overlap
2582       *
2583       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2584       */
2585      boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2586              int intersectX, int intersectY) {
2587          return findCellForSpanThatIntersectsIgnoring(
2588                  cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2589      }
2590  
2591      /**
2592       * The superset of the above two methods
2593       */
2594      boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2595              int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2596          // mark space take by ignoreView as available (method checks if ignoreView is null)
2597          markCellsAsUnoccupiedForView(ignoreView, occupied);
2598  
2599          boolean foundCell = false;
2600          while (true) {
2601              int startX = 0;
2602              if (intersectX &gt;= 0) {
2603                  startX = Math.max(startX, intersectX - (spanX - 1));
2604              }
2605              int endX = mCountX - (spanX - 1);
2606              if (intersectX &gt;= 0) {
2607                  endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2608              }
2609              int startY = 0;
2610              if (intersectY &gt;= 0) {
2611                  startY = Math.max(startY, intersectY - (spanY - 1));
2612              }
2613              int endY = mCountY - (spanY - 1);
2614              if (intersectY &gt;= 0) {
2615                  endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2616              }
2617  
2618              for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2619                  inner:
2620                  for (int x = startX; x &lt; endX; x++) {
2621                      for (int i = 0; i &lt; spanX; i++) {
2622                          for (int j = 0; j &lt; spanY; j++) {
2623                              if (occupied[x + i][y + j]) {
2624                                  // small optimization: we can skip to after the column we just found
2625                                  // an occupied cell
2626                                  x += i;
2627                                  continue inner;
2628                              }
2629                          }
2630                      }
2631                      if (cellXY != null) {
2632                          cellXY[0] = x;
2633                          cellXY[1] = y;
2634                      }
2635                      foundCell = true;
2636                      break;
2637                  }
2638              }
2639              if (intersectX == -1 &amp;&amp; intersectY == -1) {
2640                  break;
2641              } else {
2642                  // if we failed to find anything, try again but without any requirements of
2643                  // intersecting
2644                  intersectX = -1;
2645                  intersectY = -1;
2646                  continue;
2647              }
2648          }
2649  
2650          // re-mark space taken by ignoreView as occupied
2651          markCellsAsOccupiedForView(ignoreView, occupied);
2652          return foundCell;
2653      }
2654  
2655      /**
2656       * A drag event has begun over this layout.
2657       * It may have begun over this layout (in which case onDragChild is called first),
2658       * or it may have begun on another layout.
2659       */
2660      void onDragEnter() {
2661          mDragEnforcer.onDragEnter();
2662          mDragging = true;
2663      }
2664  
2665      /**
2666       * Called when drag has left this CellLayout or has been completed (successfully or not)
2667       */
2668      void onDragExit() {
2669          mDragEnforcer.onDragExit();
2670          // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2671          // item to this layout via the customize drawer.
2672          // Guard against that case.
2673          if (mDragging) {
2674              mDragging = false;
2675          }
2676  
2677          // Invalidate the drag data
2678          mDragCell[0] = mDragCell[1] = -1;
2679          mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2680          mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2681          revertTempState();
2682          setIsDragOverlapping(false);
2683      }
2684  
2685      /**
2686       * Mark a child as having been dropped.
2687       * At the beginning of the drag operation, the child may have been on another
2688       * screen, but it is re-parented before this method is called.
2689       *
2690       * @param child The child that is being dropped
2691       */
2692      void onDropChild(View child) {
2693          if (child != null) {
2694              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2695              lp.dropped = true;
2696              child.requestLayout();
2697          }
2698      }
2699  
2700      /**
2701       * Computes a bounding rectangle for a range of cells
2702       *
2703       * @param cellX X coordinate of upper left corner expressed as a cell position
2704       * @param cellY Y coordinate of upper left corner expressed as a cell position
2705       * @param cellHSpan Width in cells
2706       * @param cellVSpan Height in cells
2707       * @param resultRect Rect into which to put the results
2708       */
2709      public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2710          final int cellWidth = mCellWidth;
2711          final int cellHeight = mCellHeight;
2712          final int widthGap = mWidthGap;
2713          final int heightGap = mHeightGap;
2714  
2715          final int hStartPadding = getPaddingLeft();
2716          final int vStartPadding = getPaddingTop();
2717  
2718          int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2719          int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2720  
2721          int x = hStartPadding + cellX * (cellWidth + widthGap);
2722          int y = vStartPadding + cellY * (cellHeight + heightGap);
2723  
2724          resultRect.set(x, y, x + width, y + height);
2725      }
2726  
2727      /**
2728       * Computes the required horizontal and vertical cell spans to always
2729       * fit the given rectangle.
2730       *
2731       * @param width Width in pixels
2732       * @param height Height in pixels
2733       * @param result An array of length 2 in which to store the result (may be null).
2734       */
2735      public int[] rectToCell(int width, int height, int[] result) {
2736          return rectToCell(getResources(), width, height, result);
2737      }
2738  
2739      public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2740          // Always assume we&#x27;re working with the smallest span to make sure we
2741          // reserve enough space in both orientations.
2742          int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2743          int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2744          int smallerSize = Math.min(actualWidth, actualHeight);
2745  
2746          // Always round up to next largest cell
2747          int spanX = (int) Math.ceil(width / (float) smallerSize);
2748          int spanY = (int) Math.ceil(height / (float) smallerSize);
2749  
2750          if (result == null) {
2751              return new int[] { spanX, spanY };
2752          }
2753          result[0] = spanX;
2754          result[1] = spanY;
2755          return result;
2756      }
2757  
2758      public int[] cellSpansToSize(int hSpans, int vSpans) {
2759          int[] size = new int[2];
2760          size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2761          size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2762          return size;
2763      }
2764  
2765      /**
2766       * Calculate the grid spans needed to fit given item
2767       */
2768      public void calculateSpans(ItemInfo info) {
2769          final int minWidth;
2770          final int minHeight;
2771  
2772          if (info instanceof LauncherAppWidgetInfo) {
2773              minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2774              minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2775          } else if (info instanceof PendingAddWidgetInfo) {
2776              minWidth = ((PendingAddWidgetInfo) info).minWidth;
2777              minHeight = ((PendingAddWidgetInfo) info).minHeight;
2778          } else {
2779              // It&#x27;s not a widget, so it must be 1x1
2780              info.spanX = info.spanY = 1;
2781              return;
2782          }
2783          int[] spans = rectToCell(minWidth, minHeight, null);
2784          info.spanX = spans[0];
2785          info.spanY = spans[1];
2786      }
2787  
2788      /**
2789       * Find the first vacant cell, if there is one.
2790       *
2791       * @param vacant Holds the x and y coordinate of the vacant cell
2792       * @param spanX Horizontal cell span.
2793       * @param spanY Vertical cell span.
2794       *
2795       * @return True if a vacant cell was found
2796       */
2797      public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2798  
2799          return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2800      }
2801  
2802      static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2803              int xCount, int yCount, boolean[][] occupied) {
2804  
2805          for (int y = 0; y &lt; yCount; y++) {
2806              for (int x = 0; x &lt; xCount; x++) {
2807                  boolean available = !occupied[x][y];
2808  out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2809                      for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2810                          available = available &amp;&amp; !occupied[i][j];
2811                          if (!available) break out;
2812                      }
2813                  }
2814  
2815                  if (available) {
2816                      vacant[0] = x;
2817                      vacant[1] = y;
2818                      return true;
2819                  }
2820              }
2821          }
2822  
2823          return false;
2824      }
2825  
2826      private void clearOccupiedCells() {
2827          for (int x = 0; x &lt; mCountX; x++) {
2828              for (int y = 0; y &lt; mCountY; y++) {
2829                  mOccupied[x][y] = false;
2830              }
2831          }
2832      }
2833  
2834      public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2835          markCellsAsUnoccupiedForView(view);
2836          markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2837      }
2838  
2839      public void markCellsAsOccupiedForView(View view) {
2840          markCellsAsOccupiedForView(view, mOccupied);
2841      }
2842      public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2843          if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2844          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2845          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2846      }
2847  
2848      public void markCellsAsUnoccupiedForView(View view) {
2849          markCellsAsUnoccupiedForView(view, mOccupied);
2850      }
2851      public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2852          if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2853          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2854          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2855      }
2856  
2857      private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2858              boolean value) {
2859          if (cellX &lt; 0 || cellY &lt; 0) return;
2860          for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2861              for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2862                  occupied[x][y] = value;
2863              }
2864          }
2865      }
2866  
2867      public int getDesiredWidth() {
2868          return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
2869                  (Math.max((mCountX - 1), 0) * mWidthGap);
2870      }
2871  
2872      public int getDesiredHeight()  {
2873          return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
2874                  (Math.max((mCountY - 1), 0) * mHeightGap);
2875      }
2876  
2877      public boolean isOccupied(int x, int y) {
2878          if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2879              return mOccupied[x][y];
2880          } else {
2881              throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2882          }
2883      }
2884  
2885      @Override
2886      public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2887          return new CellLayout.LayoutParams(getContext(), attrs);
2888      }
2889  
2890      @Override
2891      protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2892          return p instanceof CellLayout.LayoutParams;
2893      }
2894  
2895      @Override
2896      protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2897          return new CellLayout.LayoutParams(p);
2898      }
2899  
2900      public static class CellLayoutAnimationController extends LayoutAnimationController {
2901          public CellLayoutAnimationController(Animation animation, float delay) {
2902              super(animation, delay);
2903          }
2904  
2905          @Override
2906          protected long getDelayForView(View view) {
2907              return (int) (Math.random() * 150);
2908          }
2909      }
2910  
2911      public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2912          /**
2913           * Horizontal location of the item in the grid.
2914           */
2915          @ViewDebug.ExportedProperty
2916          public int cellX;
2917  
2918          /**
2919           * Vertical location of the item in the grid.
2920           */
2921          @ViewDebug.ExportedProperty
2922          public int cellY;
2923  
2924          /**
2925           * Temporary horizontal location of the item in the grid during reorder
2926           */
2927          public int tmpCellX;
2928  
2929          /**
2930           * Temporary vertical location of the item in the grid during reorder
2931           */
2932          public int tmpCellY;
2933  
2934          /**
2935           * Indicates that the temporary coordinates should be used to layout the items
2936           */
2937          public boolean useTmpCoords;
2938  
2939          /**
2940           * Number of cells spanned horizontally by the item.
2941           */
2942          @ViewDebug.ExportedProperty
2943          public int cellHSpan;
2944  
2945          /**
2946           * Number of cells spanned vertically by the item.
2947           */
2948          @ViewDebug.ExportedProperty
2949          public int cellVSpan;
2950  
2951          /**
2952           * Indicates whether the item will set its x, y, width and height parameters freely,
2953           * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2954           */
2955          public boolean isLockedToGrid = true;
2956  
2957          /**
2958           * Indicates whether this item can be reordered. Always true except in the case of the
2959           * the AllApps button.
2960           */
2961          public boolean canReorder = true;
2962  
2963          // X coordinate of the view in the layout.
2964          @ViewDebug.ExportedProperty
2965          int x;
2966          // Y coordinate of the view in the layout.
2967          @ViewDebug.ExportedProperty
2968          int y;
2969  
2970          boolean dropped;
2971  
2972          public LayoutParams(Context c, AttributeSet attrs) {
2973              super(c, attrs);
2974              cellHSpan = 1;
2975              cellVSpan = 1;
2976          }
2977  
2978          public LayoutParams(ViewGroup.LayoutParams source) {
2979              super(source);
2980              cellHSpan = 1;
2981              cellVSpan = 1;
2982          }
2983  
2984          public LayoutParams(LayoutParams source) {
2985              super(source);
2986              this.cellX = source.cellX;
2987              this.cellY = source.cellY;
2988              this.cellHSpan = source.cellHSpan;
2989              this.cellVSpan = source.cellVSpan;
2990          }
2991  
2992          public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2993              super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2994              this.cellX = cellX;
2995              this.cellY = cellY;
2996              this.cellHSpan = cellHSpan;
2997              this.cellVSpan = cellVSpan;
2998          }
2999  
3000          public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
3001              if (isLockedToGrid) {
3002                  final int myCellHSpan = cellHSpan;
3003                  final int myCellVSpan = cellVSpan;
3004                  final int myCellX = useTmpCoords ? tmpCellX : cellX;
3005                  final int myCellY = useTmpCoords ? tmpCellY : cellY;
3006  
3007                  width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
3008                          leftMargin - rightMargin;
3009                  height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
3010                          topMargin - bottomMargin;
3011                  x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
3012                  y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
3013              }
3014          }
3015  
3016          public String toString() {
3017              return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
3018          }
3019  
3020          public void setWidth(int width) {
3021              this.width = width;
3022          }
3023  
3024          public int getWidth() {
3025              return width;
3026          }
3027  
3028          public void setHeight(int height) {
3029              this.height = height;
3030          }
3031  
3032          public int getHeight() {
3033              return height;
3034          }
3035  
3036          public void setX(int x) {
3037              this.x = x;
3038          }
3039  
3040          public int getX() {
3041              return x;
3042          }
3043  
3044          public void setY(int y) {
3045              this.y = y;
3046          }
3047  
3048          public int getY() {
3049              return y;
3050          }
3051      }
3052  
3053      // This class stores info for two purposes:
3054      // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
3055      //    its spanX, spanY, and the screen it is on
3056      // 2. When long clicking on an empty cell in a CellLayout, we save information about the
3057      //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
3058      //    the CellLayout that was long clicked
3059      static final class CellInfo {
3060          View cell;
3061          int cellX = -1;
3062          int cellY = -1;
3063          int spanX;
3064          int spanY;
3065          int screen;
3066          long container;
3067  
3068          @Override
3069          public String toString() {
3070              return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
3071                      + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
3072          }
3073      }
3074  
3075      public boolean lastDownOnOccupiedCell() {
3076          return mLastDownOnOccupiedCell;
3077      }
3078  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher2;
  18  
  19  import android.animation.Animator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +import android.animation.AnimatorListenerAdapter;</span>
  21  import android.animation.AnimatorSet;
  22  import android.animation.ObjectAnimator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import android.animation.AnimatorListenerAdapter;</span>
  24  import android.animation.TimeInterpolator;
  25  import android.animation.ValueAnimator;
  26  import android.animation.ValueAnimator.AnimatorUpdateListener;
  27  import android.content.Context;
  28  import android.content.res.Resources;
  29  import android.content.res.TypedArray;
  30  import android.graphics.Bitmap;
  31  import android.graphics.Canvas;
  32  import android.graphics.Color;
  33  import android.graphics.Paint;
  34  import android.graphics.Point;
  35  import android.graphics.PorterDuff;
  36  import android.graphics.PorterDuffXfermode;
  37  import android.graphics.Rect;
  38  import android.graphics.drawable.ColorDrawable;
  39  import android.graphics.drawable.Drawable;
  40  import android.graphics.drawable.NinePatchDrawable;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import android.os.Parcelable;</span>
  42  import android.util.AttributeSet;
  43  import android.util.Log;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import android.util.SparseArray;</span>
  45  import android.view.MotionEvent;
  46  import android.view.View;
  47  import android.view.ViewDebug;
  48  import android.view.ViewGroup;
  49  import android.view.animation.Animation;
  50  import android.view.animation.DecelerateInterpolator;
  51  import android.view.animation.LayoutAnimationController;
  52  
  53  import com.android.launcher.R;
  54  import com.android.launcher2.FolderIcon.FolderRingAnimator;
  55  
  56  import java.util.ArrayList;
  57  import java.util.Arrays;
  58  import java.util.HashMap;
  59  import java.util.Stack;
  60  
  61  public class CellLayout extends ViewGroup {
  62      static final String TAG = &quot;CellLayout&quot;;
  63  
  64      private Launcher mLauncher;
  65      private int mCellWidth;
  66      private int mCellHeight;
  67  
  68      private int mCountX;
  69      private int mCountY;
  70  
  71      private int mOriginalWidthGap;
  72      private int mOriginalHeightGap;
  73      private int mWidthGap;
  74      private int mHeightGap;
  75      private int mMaxGap;
  76      private boolean mScrollingTransformsDirty = false;
  77  
  78      private final Rect mRect = new Rect();
  79      private final CellInfo mCellInfo = new CellInfo();
  80  
  81      // These are temporary variables to prevent having to allocate a new object just to
  82      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
  83      private final int[] mTmpXY = new int[2];
  84      private final int[] mTmpPoint = new int[2];
  85      int[] mTempLocation = new int[2];
  86  
  87      boolean[][] mOccupied;
  88      boolean[][] mTmpOccupied;
  89      private boolean mLastDownOnOccupiedCell = false;
  90  
  91      private OnTouchListener mInterceptTouchListener;
  92  
  93      private ArrayList&lt;FolderRingAnimator&gt; mFolderOuterRings = new ArrayList&lt;FolderRingAnimator&gt;();
  94      private int[] mFolderLeaveBehindCell = {-1, -1};
  95  
  96      private int mForegroundAlpha = 0;
  97      private float mBackgroundAlpha;
  98      private float mBackgroundAlphaMultiplier = 1.0f;
  99  
 100      private Drawable mNormalBackground;
 101      private Drawable mActiveGlowBackground;
 102      private Drawable mOverScrollForegroundDrawable;
 103      private Drawable mOverScrollLeft;
 104      private Drawable mOverScrollRight;
 105      private Rect mBackgroundRect;
 106      private Rect mForegroundRect;
 107      private int mForegroundPadding;
 108  
 109      // If we&#x27;re actively dragging something over this screen, mIsDragOverlapping is true
 110      private boolean mIsDragOverlapping = false;
 111      private final Point mDragCenter = new Point();
 112  
 113      // These arrays are used to implement the drag visualization on x-large screens.
 114      // They are used as circular arrays, indexed by mDragOutlineCurrent.
 115      private Rect[] mDragOutlines = new Rect[4];
 116      private float[] mDragOutlineAlphas = new float[mDragOutlines.length];
 117      private InterruptibleInOutAnimator[] mDragOutlineAnims =
 118              new InterruptibleInOutAnimator[mDragOutlines.length];
 119  
 120      // Used as an index into the above 3 arrays; indicates which is the most current value.
 121      private int mDragOutlineCurrent = 0;
 122      private final Paint mDragOutlinePaint = new Paint();
 123  
 124      private BubbleTextView mPressedOrFocusedIcon;
 125  
 126      private HashMap&lt;CellLayout.LayoutParams, Animator&gt; mReorderAnimators = new
 127              HashMap&lt;CellLayout.LayoutParams, Animator&gt;();
 128      private HashMap&lt;View, ReorderHintAnimation&gt;
 129              mShakeAnimators = new HashMap&lt;View, ReorderHintAnimation&gt;();
 130  
 131      private boolean mItemPlacementDirty = false;
 132  
 133      // When a drag operation is in progress, holds the nearest cell to the touch point
 134      private final int[] mDragCell = new int[2];
 135  
 136      private boolean mDragging = false;
 137  
 138      private TimeInterpolator mEaseOutInterpolator;
 139      private ShortcutAndWidgetContainer mShortcutsAndWidgets;
 140  
 141      private boolean mIsHotseat = false;
 142  
 143      public static final int MODE_DRAG_OVER = 0;
 144      public static final int MODE_ON_DROP = 1;
 145      public static final int MODE_ON_DROP_EXTERNAL = 2;
 146      public static final int MODE_ACCEPT_DROP = 3;
 147      private static final boolean DESTRUCTIVE_REORDER = false;
 148      private static final boolean DEBUG_VISUALIZE_OCCUPIED = false;
 149  
 150      static final int LANDSCAPE = 0;
 151      static final int PORTRAIT = 1;
 152  
 153      private static final float REORDER_HINT_MAGNITUDE = 0.12f;
 154      private static final int REORDER_ANIMATION_DURATION = 150;
 155      private float mReorderHintAnimationMagnitude;
 156  
 157      private ArrayList&lt;View&gt; mIntersectingViews = new ArrayList&lt;View&gt;();
 158      private Rect mOccupiedRect = new Rect();
 159      private int[] mDirectionVector = new int[2];
 160      int[] mPreviousReorderDirection = new int[2];
 161      private static final int INVALID_DIRECTION = -100;
 162      private DropTarget.DragEnforcer mDragEnforcer;
 163  
 164      private final static PorterDuffXfermode sAddBlendMode =
 165              new PorterDuffXfermode(PorterDuff.Mode.ADD);

 166  
 167      public CellLayout(Context context) {
 168          this(context, null);
 169      }
 170  
 171      public CellLayout(Context context, AttributeSet attrs) {
 172          this(context, attrs, 0);
 173      }
 174  
 175      public CellLayout(Context context, AttributeSet attrs, int defStyle) {
 176          super(context, attrs, defStyle);
 177          mDragEnforcer = new DropTarget.DragEnforcer(context);
 178  
 179          // A ViewGroup usually does not draw, but CellLayout needs to draw a rectangle to show
 180          // the user where a dragged item will land when dropped.
 181          setWillNotDraw(false);
 182          mLauncher = (Launcher) context;
 183  
 184          TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CellLayout, defStyle, 0);
 185  
 186          mCellWidth = a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth, 10);
 187          mCellHeight = a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight, 10);
 188          mWidthGap = mOriginalWidthGap = a.getDimensionPixelSize(R.styleable.CellLayout_widthGap, 0);
 189          mHeightGap = mOriginalHeightGap = a.getDimensionPixelSize(R.styleable.CellLayout_heightGap, 0);
 190          mMaxGap = a.getDimensionPixelSize(R.styleable.CellLayout_maxGap, 0);
 191          mCountX = LauncherModel.getCellCountX();
 192          mCountY = LauncherModel.getCellCountY();
 193          mOccupied = new boolean[mCountX][mCountY];
 194          mTmpOccupied = new boolean[mCountX][mCountY];
 195          mPreviousReorderDirection[0] = INVALID_DIRECTION;
 196          mPreviousReorderDirection[1] = INVALID_DIRECTION;
 197  
 198          a.recycle();
 199  
 200          setAlwaysDrawnWithCacheEnabled(false);
 201  
 202          final Resources res = getResources();
 203  
 204          mNormalBackground = res.getDrawable(R.drawable.homescreen_blue_normal_holo);
 205          mActiveGlowBackground = res.getDrawable(R.drawable.homescreen_blue_strong_holo);
 206  
 207          mOverScrollLeft = res.getDrawable(R.drawable.overscroll_glow_left);
 208          mOverScrollRight = res.getDrawable(R.drawable.overscroll_glow_right);
 209          mForegroundPadding =
 210                  res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
 211  
 212          mReorderHintAnimationMagnitude = (REORDER_HINT_MAGNITUDE *
 213                  res.getDimensionPixelSize(R.dimen.app_icon_size));
 214  
 215          mNormalBackground.setFilterBitmap(true);
 216          mActiveGlowBackground.setFilterBitmap(true);
 217  
 218          // Initialize the data structures used for the drag visualization.
 219  
 220          mEaseOutInterpolator = new DecelerateInterpolator(2.5f); // Quint ease out
 221  
 222  
 223          mDragCell[0] = mDragCell[1] = -1;
 224          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 225              mDragOutlines[i] = new Rect(-1, -1, -1, -1);
 226          }
 227  
 228          // When dragging things around the home screens, we show a green outline of
 229          // where the item will land. The outlines gradually fade out, leaving a trail
 230          // behind the drag path.
 231          // Set up all the animations that are used to implement this fading.
 232          final int duration = res.getInteger(R.integer.config_dragOutlineFadeTime);
 233          final float fromAlphaValue = 0;
 234          final float toAlphaValue = (float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
 235  
 236          Arrays.fill(mDragOutlineAlphas, fromAlphaValue);
 237  
 238          for (int i = 0; i &lt; mDragOutlineAnims.length; i++) {
 239              final InterruptibleInOutAnimator anim =
 240                  new InterruptibleInOutAnimator(duration, fromAlphaValue, toAlphaValue);
 241              anim.getAnimator().setInterpolator(mEaseOutInterpolator);
 242              final int thisIndex = i;
 243              anim.getAnimator().addUpdateListener(new AnimatorUpdateListener() {
 244                  public void onAnimationUpdate(ValueAnimator animation) {
 245                      final Bitmap outline = (Bitmap)anim.getTag();
 246  
 247                      // If an animation is started and then stopped very quickly, we can still
 248                      // get spurious updates we&#x27;ve cleared the tag. Guard against this.
 249                      if (outline == null) {
 250                          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 251                          final boolean debug = false;
 252                          if (debug) {
 253                              Object val = animation.getAnimatedValue();
 254                              Log.d(TAG, &quot;anim &quot; + thisIndex + &quot; update: &quot; + val +
 255                                       &quot;, isStopped &quot; + anim.isStopped());
 256                          }
 257                          // Try to prevent it from continuing to run
 258                          animation.cancel();
 259                      } else {
 260                          mDragOutlineAlphas[thisIndex] = (Float) animation.getAnimatedValue();
 261                          CellLayout.this.invalidate(mDragOutlines[thisIndex]);
 262                      }
 263                  }
 264              });
 265              // The animation holds a reference to the drag outline bitmap as long is it&#x27;s
 266              // running. This way the bitmap can be GCed when the animations are complete.
 267              anim.getAnimator().addListener(new AnimatorListenerAdapter() {
 268                  @Override
 269                  public void onAnimationEnd(Animator animation) {
 270                      if ((Float) ((ValueAnimator) animation).getAnimatedValue() == 0f) {
 271                          anim.setTag(null);
 272                      }
 273                  }
 274              });
 275              mDragOutlineAnims[i] = anim;
 276          }
 277  
 278          mBackgroundRect = new Rect();
 279          mForegroundRect = new Rect();
 280  
 281          mShortcutsAndWidgets = new ShortcutAndWidgetContainer(context);
 282          mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 283          addView(mShortcutsAndWidgets);
 284      }
 285  
 286      static int widthInPortrait(Resources r, int numCells) {
 287          // We use this method from Workspace to figure out how many rows/columns Launcher should
 288          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 289          // the padding extends outside the visible screen size, but it looked fine anyway.
 290          int cellWidth = r.getDimensionPixelSize(R.dimen.workspace_cell_width);
 291          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 292                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 293  
 294          return  minGap * (numCells - 1) + cellWidth * numCells;
 295      }
 296  
 297      static int heightInLandscape(Resources r, int numCells) {
 298          // We use this method from Workspace to figure out how many rows/columns Launcher should
 299          // have. We ignore the left/right padding on CellLayout because it turns out in our design
 300          // the padding extends outside the visible screen size, but it looked fine anyway.
 301          int cellHeight = r.getDimensionPixelSize(R.dimen.workspace_cell_height);
 302          int minGap = Math.min(r.getDimensionPixelSize(R.dimen.workspace_width_gap),
 303                  r.getDimensionPixelSize(R.dimen.workspace_height_gap));
 304  
 305          return minGap * (numCells - 1) + cellHeight * numCells;
 306      }
 307  
 308      public void enableHardwareLayers() {
 309          mShortcutsAndWidgets.enableHardwareLayers();









 310      }
 311  
 312      public void setGridSize(int x, int y) {
 313          mCountX = x;
 314          mCountY = y;
 315          mOccupied = new boolean[mCountX][mCountY];
 316          mTmpOccupied = new boolean[mCountX][mCountY];
 317          mTempRectStack.clear();
 318          requestLayout();
 319      }
 320  
 321      private void invalidateBubbleTextView(BubbleTextView icon) {
 322          final int padding = icon.getPressedOrFocusedBackgroundPadding();
 323          invalidate(icon.getLeft() + getPaddingLeft() - padding,
 324                  icon.getTop() + getPaddingTop() - padding,
 325                  icon.getRight() + getPaddingLeft() + padding,
 326                  icon.getBottom() + getPaddingTop() + padding);
 327      }
 328  
 329      void setOverScrollAmount(float r, boolean left) {
 330          if (left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollLeft) {
 331              mOverScrollForegroundDrawable = mOverScrollLeft;
 332          } else if (!left &amp;&amp; mOverScrollForegroundDrawable != mOverScrollRight) {
 333              mOverScrollForegroundDrawable = mOverScrollRight;
 334          }
 335  
 336          mForegroundAlpha = (int) Math.round((r * 255));
 337          mOverScrollForegroundDrawable.setAlpha(mForegroundAlpha);
 338          invalidate();
 339      }
 340  
 341      void setPressedOrFocusedIcon(BubbleTextView icon) {
 342          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 343          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 344          BubbleTextView oldIcon = mPressedOrFocusedIcon;
 345          mPressedOrFocusedIcon = icon;
 346          if (oldIcon != null) {
 347              invalidateBubbleTextView(oldIcon);
 348          }
 349          if (mPressedOrFocusedIcon != null) {
 350              invalidateBubbleTextView(mPressedOrFocusedIcon);
 351          }
 352      }
 353  
 354      void setIsDragOverlapping(boolean isDragOverlapping) {
 355          if (mIsDragOverlapping != isDragOverlapping) {
 356              mIsDragOverlapping = isDragOverlapping;
 357              invalidate();
 358          }
 359      }
 360  
 361      boolean getIsDragOverlapping() {
 362          return mIsDragOverlapping;
 363      }
 364  
 365      protected void setOverscrollTransformsDirty(boolean dirty) {
 366          mScrollingTransformsDirty = dirty;
 367      }
 368  
 369      protected void resetOverscrollTransforms() {
 370          if (mScrollingTransformsDirty) {
 371              setOverscrollTransformsDirty(false);
 372              setTranslationX(0);
 373              setRotationY(0);
 374              // It doesn&#x27;t matter if we pass true or false here, the important thing is that we
 375              // pass 0, which results in the overscroll drawable not being drawn any more.
 376              setOverScrollAmount(0, false);
 377              setPivotX(getMeasuredWidth() / 2);
 378              setPivotY(getMeasuredHeight() / 2);
 379          }
 380      }
 381  
 382      @Override
 383      protected void onDraw(Canvas canvas) {
 384          // When we&#x27;re large, we are either drawn in a &quot;hover&quot; state (ie when dragging an item to
 385          // a neighboring page) or with just a normal background (if backgroundAlpha &gt; 0.0f)
 386          // When we&#x27;re small, we are either drawn normally or in the &quot;accepts drops&quot; state (during
 387          // a drag). However, we also drag the mini hover background *over* one of those two
 388          // backgrounds
 389          if (mBackgroundAlpha &gt; 0.0f) {
 390              Drawable bg;
 391  
 392              if (mIsDragOverlapping) {
 393                  // In the mini case, we draw the active_glow bg *over* the active background
 394                  bg = mActiveGlowBackground;
 395              } else {
 396                  bg = mNormalBackground;
 397              }
 398  
 399              bg.setAlpha((int) (mBackgroundAlpha * mBackgroundAlphaMultiplier * 255));
 400              bg.setBounds(mBackgroundRect);
 401              bg.draw(canvas);
 402          }
 403  
 404          final Paint paint = mDragOutlinePaint;
 405          for (int i = 0; i &lt; mDragOutlines.length; i++) {
 406              final float alpha = mDragOutlineAlphas[i];
 407              if (alpha &gt; 0) {
 408                  final Rect r = mDragOutlines[i];
 409                  final Bitmap b = (Bitmap) mDragOutlineAnims[i].getTag();
 410                  paint.setAlpha((int)(alpha + .5f));
 411                  canvas.drawBitmap(b, null, r, paint);
 412              }
 413          }
 414  
 415          // We draw the pressed or focused BubbleTextView&#x27;s background in CellLayout because it
 416          // requires an expanded clip rect (due to the glow&#x27;s blur radius)
 417          if (mPressedOrFocusedIcon != null) {
 418              final int padding = mPressedOrFocusedIcon.getPressedOrFocusedBackgroundPadding();
 419              final Bitmap b = mPressedOrFocusedIcon.getPressedOrFocusedBackground();
 420              if (b != null) {
 421                  canvas.drawBitmap(b,
 422                          mPressedOrFocusedIcon.getLeft() + getPaddingLeft() - padding,
 423                          mPressedOrFocusedIcon.getTop() + getPaddingTop() - padding,
 424                          null);
 425              }
 426          }
 427  
 428          if (DEBUG_VISUALIZE_OCCUPIED) {
 429              int[] pt = new int[2];
 430              ColorDrawable cd = new ColorDrawable(Color.RED);
 431              cd.setBounds(0, 0,  mCellWidth, mCellHeight);
 432              for (int i = 0; i &lt; mCountX; i++) {
 433                  for (int j = 0; j &lt; mCountY; j++) {
 434                      if (mOccupied[i][j]) {
 435                          cellToPoint(i, j, pt);
 436                          canvas.save();
 437                          canvas.translate(pt[0], pt[1]);
 438                          cd.draw(canvas);
 439                          canvas.restore();
 440                      }
 441                  }
 442              }
 443          }
 444  
 445          int previewOffset = FolderRingAnimator.sPreviewSize;
 446  
 447          // The folder outer / inner ring image(s)
 448          for (int i = 0; i &lt; mFolderOuterRings.size(); i++) {
 449              FolderRingAnimator fra = mFolderOuterRings.get(i);
 450  
 451              // Draw outer ring
 452              Drawable d = FolderRingAnimator.sSharedOuterRingDrawable;
 453              int width = (int) fra.getOuterRingSize();
 454              int height = width;
 455              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 456  
 457              int centerX = mTempLocation[0] + mCellWidth / 2;
 458              int centerY = mTempLocation[1] + previewOffset / 2;
 459  
 460              canvas.save();
 461              canvas.translate(centerX - width / 2, centerY - height / 2);
 462              d.setBounds(0, 0, width, height);
 463              d.draw(canvas);
 464              canvas.restore();
 465  
 466              // Draw inner ring
 467              d = FolderRingAnimator.sSharedInnerRingDrawable;
 468              width = (int) fra.getInnerRingSize();
 469              height = width;
 470              cellToPoint(fra.mCellX, fra.mCellY, mTempLocation);
 471  
 472              centerX = mTempLocation[0] + mCellWidth / 2;
 473              centerY = mTempLocation[1] + previewOffset / 2;
 474              canvas.save();
 475              canvas.translate(centerX - width / 2, centerY - width / 2);
 476              d.setBounds(0, 0, width, height);
 477              d.draw(canvas);
 478              canvas.restore();
 479          }
 480  
 481          if (mFolderLeaveBehindCell[0] &gt;= 0 &amp;&amp; mFolderLeaveBehindCell[1] &gt;= 0) {
 482              Drawable d = FolderIcon.sSharedFolderLeaveBehind;
 483              int width = d.getIntrinsicWidth();
 484              int height = d.getIntrinsicHeight();
 485  
 486              cellToPoint(mFolderLeaveBehindCell[0], mFolderLeaveBehindCell[1], mTempLocation);
 487              int centerX = mTempLocation[0] + mCellWidth / 2;
 488              int centerY = mTempLocation[1] + previewOffset / 2;
 489  
 490              canvas.save();
 491              canvas.translate(centerX - width / 2, centerY - width / 2);
 492              d.setBounds(0, 0, width, height);
 493              d.draw(canvas);
 494              canvas.restore();
 495          }
 496      }
 497  
 498      @Override
 499      protected void dispatchDraw(Canvas canvas) {
 500          super.dispatchDraw(canvas);
 501          if (mForegroundAlpha &gt; 0) {
 502              mOverScrollForegroundDrawable.setBounds(mForegroundRect);
 503              Paint p = ((NinePatchDrawable) mOverScrollForegroundDrawable).getPaint();
 504              p.setXfermode(sAddBlendMode);
 505              mOverScrollForegroundDrawable.draw(canvas);
 506              p.setXfermode(null);
 507          }
 508      }
 509  
 510      public void showFolderAccept(FolderRingAnimator fra) {
 511          mFolderOuterRings.add(fra);
 512      }
 513  
 514      public void hideFolderAccept(FolderRingAnimator fra) {
 515          if (mFolderOuterRings.contains(fra)) {
 516              mFolderOuterRings.remove(fra);
 517          }
 518          invalidate();
 519      }
 520  
 521      public void setFolderLeaveBehindCell(int x, int y) {
 522          mFolderLeaveBehindCell[0] = x;
 523          mFolderLeaveBehindCell[1] = y;
 524          invalidate();
 525      }
 526  
 527      public void clearFolderLeaveBehind() {
 528          mFolderLeaveBehindCell[0] = -1;
 529          mFolderLeaveBehindCell[1] = -1;
 530          invalidate();
 531      }
 532  
 533      @Override
 534      public boolean shouldDelayChildPressedState() {
 535          return false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 536 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 537 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 538 +    public void restoreInstanceState(SparseArray&lt;Parcelable&gt; states) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 539 +        dispatchRestoreInstanceState(states);</span>
 540      }
 541  
 542      @Override
 543      public void cancelLongPress() {
 544          super.cancelLongPress();
 545  
 546          // Cancel long press for all children
 547          final int count = getChildCount();
 548          for (int i = 0; i &lt; count; i++) {
 549              final View child = getChildAt(i);
 550              child.cancelLongPress();
 551          }
 552      }
 553  
 554      public void setOnInterceptTouchListener(View.OnTouchListener listener) {
 555          mInterceptTouchListener = listener;
 556      }
 557  
 558      int getCountX() {
 559          return mCountX;
 560      }
 561  
 562      int getCountY() {
 563          return mCountY;
 564      }
 565  
 566      public void setIsHotseat(boolean isHotseat) {
 567          mIsHotseat = isHotseat;
 568      }
 569  
 570      public boolean addViewToCellLayout(View child, int index, int childId, LayoutParams params,
 571              boolean markCells) {
 572          final LayoutParams lp = params;
 573  
 574          // Hotseat icons - remove text
 575          if (child instanceof BubbleTextView) {
 576              BubbleTextView bubbleChild = (BubbleTextView) child;
 577  
 578              Resources res = getResources();
 579              if (mIsHotseat) {
 580                  bubbleChild.setTextColor(res.getColor(android.R.color.transparent));
 581              } else {
 582                  bubbleChild.setTextColor(res.getColor(R.color.workspace_icon_text_color));
 583              }
 584          }
 585  
 586          // Generate an id for each view, this assumes we have at most 256x256 cells
 587          // per workspace screen
 588          if (lp.cellX &gt;= 0 &amp;&amp; lp.cellX &lt;= mCountX - 1 &amp;&amp; lp.cellY &gt;= 0 &amp;&amp; lp.cellY &lt;= mCountY - 1) {
 589              // If the horizontal or vertical span is set to -1, it is taken to
 590              // mean that it spans the extent of the CellLayout
 591              if (lp.cellHSpan &lt; 0) lp.cellHSpan = mCountX;
 592              if (lp.cellVSpan &lt; 0) lp.cellVSpan = mCountY;
 593  
 594              child.setId(childId);
 595  
 596              mShortcutsAndWidgets.addView(child, index, lp);
 597  
 598              if (markCells) markCellsAsOccupiedForView(child);
 599  
 600              return true;
 601          }
 602          return false;
 603      }
 604  
 605      @Override
 606      public void removeAllViews() {
 607          clearOccupiedCells();
 608          mShortcutsAndWidgets.removeAllViews();
 609      }
 610  
 611      @Override
 612      public void removeAllViewsInLayout() {
 613          if (mShortcutsAndWidgets.getChildCount() &gt; 0) {
 614              clearOccupiedCells();
 615              mShortcutsAndWidgets.removeAllViewsInLayout();
 616          }
 617      }
 618  
 619      public void removeViewWithoutMarkingCells(View view) {
 620          mShortcutsAndWidgets.removeView(view);
 621      }
 622  
 623      @Override
 624      public void removeView(View view) {
 625          markCellsAsUnoccupiedForView(view);
 626          mShortcutsAndWidgets.removeView(view);
 627      }
 628  
 629      @Override
 630      public void removeViewAt(int index) {
 631          markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(index));
 632          mShortcutsAndWidgets.removeViewAt(index);
 633      }
 634  
 635      @Override
 636      public void removeViewInLayout(View view) {
 637          markCellsAsUnoccupiedForView(view);
 638          mShortcutsAndWidgets.removeViewInLayout(view);
 639      }
 640  
 641      @Override
 642      public void removeViews(int start, int count) {
 643          for (int i = start; i &lt; start + count; i++) {
 644              markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 645          }
 646          mShortcutsAndWidgets.removeViews(start, count);
 647      }
 648  
 649      @Override
 650      public void removeViewsInLayout(int start, int count) {
 651          for (int i = start; i &lt; start + count; i++) {
 652              markCellsAsUnoccupiedForView(mShortcutsAndWidgets.getChildAt(i));
 653          }
 654          mShortcutsAndWidgets.removeViewsInLayout(start, count);
 655      }
 656  
 657      @Override
 658      protected void onAttachedToWindow() {
 659          super.onAttachedToWindow();
 660          mCellInfo.screen = ((ViewGroup) getParent()).indexOfChild(this);
 661      }
 662  
 663      public void setTagToCellInfoForPoint(int touchX, int touchY) {
 664          final CellInfo cellInfo = mCellInfo;
 665          Rect frame = mRect;
 666          final int x = touchX + getScrollX();
 667          final int y = touchY + getScrollY();
 668          final int count = mShortcutsAndWidgets.getChildCount();
 669  
 670          boolean found = false;
 671          for (int i = count - 1; i &gt;= 0; i--) {
 672              final View child = mShortcutsAndWidgets.getChildAt(i);
 673              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
 674  
 675              if ((child.getVisibility() == VISIBLE || child.getAnimation() != null) &amp;&amp;
 676                      lp.isLockedToGrid) {
 677                  child.getHitRect(frame);
 678  
 679                  float scale = child.getScaleX();
 680                  frame = new Rect(child.getLeft(), child.getTop(), child.getRight(),
 681                          child.getBottom());
 682                  // The child hit rect is relative to the CellLayoutChildren parent, so we need to
 683                  // offset that by this CellLayout&#x27;s padding to test an (x,y) point that is relative
 684                  // to this view.
 685                  frame.offset(getPaddingLeft(), getPaddingTop());
 686                  frame.inset((int) (frame.width() * (1f - scale) / 2),
 687                          (int) (frame.height() * (1f - scale) / 2));
 688  
 689                  if (frame.contains(x, y)) {
 690                      cellInfo.cell = child;
 691                      cellInfo.cellX = lp.cellX;
 692                      cellInfo.cellY = lp.cellY;
 693                      cellInfo.spanX = lp.cellHSpan;
 694                      cellInfo.spanY = lp.cellVSpan;
 695                      found = true;
 696                      break;
 697                  }
 698              }
 699          }
 700  
 701          mLastDownOnOccupiedCell = found;
 702  
 703          if (!found) {
 704              final int cellXY[] = mTmpXY;
 705              pointToCellExact(x, y, cellXY);
 706  
 707              cellInfo.cell = null;
 708              cellInfo.cellX = cellXY[0];
 709              cellInfo.cellY = cellXY[1];
 710              cellInfo.spanX = 1;
 711              cellInfo.spanY = 1;
 712          }
 713          setTag(cellInfo);
 714      }
 715  
 716      @Override
 717      public boolean onInterceptTouchEvent(MotionEvent ev) {
 718          // First we clear the tag to ensure that on every touch down we start with a fresh slate,
 719          // even in the case where we return early. Not clearing here was causing bugs whereby on
 720          // long-press we&#x27;d end up picking up an item from a previous drag operation.
 721          final int action = ev.getAction();
 722  
 723          if (action == MotionEvent.ACTION_DOWN) {
 724              clearTagCellInfo();
 725          }
 726  
 727          if (mInterceptTouchListener != null &amp;&amp; mInterceptTouchListener.onTouch(this, ev)) {
 728              return true;
 729          }
 730  
 731          if (action == MotionEvent.ACTION_DOWN) {
 732              setTagToCellInfoForPoint((int) ev.getX(), (int) ev.getY());
 733          }
 734  
 735          return false;
 736      }
 737  
 738      private void clearTagCellInfo() {
 739          final CellInfo cellInfo = mCellInfo;
 740          cellInfo.cell = null;
 741          cellInfo.cellX = -1;
 742          cellInfo.cellY = -1;
 743          cellInfo.spanX = 0;
 744          cellInfo.spanY = 0;
 745          setTag(cellInfo);
 746      }
 747  
 748      public CellInfo getTag() {
 749          return (CellInfo) super.getTag();
 750      }
 751  
 752      /**
 753       * Given a point, return the cell that strictly encloses that point
 754       * @param x X coordinate of the point
 755       * @param y Y coordinate of the point
 756       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 757       */
 758      void pointToCellExact(int x, int y, int[] result) {
 759          final int hStartPadding = getPaddingLeft();
 760          final int vStartPadding = getPaddingTop();
 761  
 762          result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);
 763          result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);
 764  
 765          final int xAxis = mCountX;
 766          final int yAxis = mCountY;
 767  
 768          if (result[0] &lt; 0) result[0] = 0;
 769          if (result[0] &gt;= xAxis) result[0] = xAxis - 1;
 770          if (result[1] &lt; 0) result[1] = 0;
 771          if (result[1] &gt;= yAxis) result[1] = yAxis - 1;
 772      }
 773  
 774      /**
 775       * Given a point, return the cell that most closely encloses that point
 776       * @param x X coordinate of the point
 777       * @param y Y coordinate of the point
 778       * @param result Array of 2 ints to hold the x and y coordinate of the cell
 779       */
 780      void pointToCellRounded(int x, int y, int[] result) {
 781          pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);
 782      }
 783  
 784      /**
 785       * Given a cell coordinate, return the point that represents the upper left corner of that cell
 786       *
 787       * @param cellX X coordinate of the cell
 788       * @param cellY Y coordinate of the cell
 789       *
 790       * @param result Array of 2 ints to hold the x and y coordinate of the point
 791       */
 792      void cellToPoint(int cellX, int cellY, int[] result) {
 793          final int hStartPadding = getPaddingLeft();
 794          final int vStartPadding = getPaddingTop();
 795  
 796          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);
 797          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);
 798      }
 799  
 800      /**
 801       * Given a cell coordinate, return the point that represents the center of the cell
 802       *
 803       * @param cellX X coordinate of the cell
 804       * @param cellY Y coordinate of the cell
 805       *
 806       * @param result Array of 2 ints to hold the x and y coordinate of the point
 807       */
 808      void cellToCenterPoint(int cellX, int cellY, int[] result) {
 809          regionToCenterPoint(cellX, cellY, 1, 1, result);
 810      }
 811  
 812      /**
 813       * Given a cell coordinate and span return the point that represents the center of the regio
 814       *
 815       * @param cellX X coordinate of the cell
 816       * @param cellY Y coordinate of the cell
 817       *
 818       * @param result Array of 2 ints to hold the x and y coordinate of the point
 819       */
 820      void regionToCenterPoint(int cellX, int cellY, int spanX, int spanY, int[] result) {
 821          final int hStartPadding = getPaddingLeft();
 822          final int vStartPadding = getPaddingTop();
 823          result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) +
 824                  (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;
 825          result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) +
 826                  (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;
 827      }
 828  
 829       /**
 830       * Given a cell coordinate and span fills out a corresponding pixel rect
 831       *
 832       * @param cellX X coordinate of the cell
 833       * @param cellY Y coordinate of the cell
 834       * @param result Rect in which to write the result
 835       */
 836       void regionToRect(int cellX, int cellY, int spanX, int spanY, Rect result) {
 837          final int hStartPadding = getPaddingLeft();
 838          final int vStartPadding = getPaddingTop();
 839          final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);
 840          final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);
 841          result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap),
 842                  top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));
 843      }
 844  
 845      public float getDistanceFromCell(float x, float y, int[] cell) {
 846          cellToCenterPoint(cell[0], cell[1], mTmpPoint);
 847          float distance = (float) Math.sqrt( Math.pow(x - mTmpPoint[0], 2) +
 848                  Math.pow(y - mTmpPoint[1], 2));
 849          return distance;
 850      }
 851  
 852      int getCellWidth() {
 853          return mCellWidth;
 854      }
 855  
 856      int getCellHeight() {
 857          return mCellHeight;
 858      }
 859  
 860      int getWidthGap() {
 861          return mWidthGap;
 862      }
 863  
 864      int getHeightGap() {
 865          return mHeightGap;
 866      }
 867  
 868      Rect getContentRect(Rect r) {
 869          if (r == null) {
 870              r = new Rect();
 871          }
 872          int left = getPaddingLeft();
 873          int top = getPaddingTop();
 874          int right = left + getWidth() - getPaddingLeft() - getPaddingRight();
 875          int bottom = top + getHeight() - getPaddingTop() - getPaddingBottom();
 876          r.set(left, top, right, bottom);
 877          return r;
 878      }
 879  
 880      static void getMetrics(Rect metrics, Resources res, int measureWidth, int measureHeight,
 881              int countX, int countY, int orientation) {
 882          int numWidthGaps = countX - 1;
 883          int numHeightGaps = countY - 1;
 884  
 885          int widthGap;
 886          int heightGap;
 887          int cellWidth;
 888          int cellHeight;
 889          int paddingLeft;
 890          int paddingRight;
 891          int paddingTop;
 892          int paddingBottom;
 893  
 894          int maxGap = res.getDimensionPixelSize(R.dimen.workspace_max_gap);
 895          if (orientation == LANDSCAPE) {
 896              cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_land);
 897              cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_land);
 898              widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_land);
 899              heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_land);
 900              paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_land);
 901              paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_land);
 902              paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_land);
 903              paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_land);
 904          } else {
 905              // PORTRAIT
 906              cellWidth = res.getDimensionPixelSize(R.dimen.workspace_cell_width_port);
 907              cellHeight = res.getDimensionPixelSize(R.dimen.workspace_cell_height_port);
 908              widthGap = res.getDimensionPixelSize(R.dimen.workspace_width_gap_port);
 909              heightGap = res.getDimensionPixelSize(R.dimen.workspace_height_gap_port);
 910              paddingLeft = res.getDimensionPixelSize(R.dimen.cell_layout_left_padding_port);
 911              paddingRight = res.getDimensionPixelSize(R.dimen.cell_layout_right_padding_port);
 912              paddingTop = res.getDimensionPixelSize(R.dimen.cell_layout_top_padding_port);
 913              paddingBottom = res.getDimensionPixelSize(R.dimen.cell_layout_bottom_padding_port);
 914          }
 915  
 916          if (widthGap &lt; 0 || heightGap &lt; 0) {
 917              int hSpace = measureWidth - paddingLeft - paddingRight;
 918              int vSpace = measureHeight - paddingTop - paddingBottom;
 919              int hFreeSpace = hSpace - (countX * cellWidth);
 920              int vFreeSpace = vSpace - (countY * cellHeight);
 921              widthGap = Math.min(maxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 922              heightGap = Math.min(maxGap, numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 923          }
 924          metrics.set(cellWidth, cellHeight, widthGap, heightGap);
 925      }
 926  
 927      @Override
 928      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
 929          int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
 930          int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
 931  
 932          int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
 933          int heightSpecSize =  MeasureSpec.getSize(heightMeasureSpec);
 934  
 935          if (widthSpecMode == MeasureSpec.UNSPECIFIED || heightSpecMode == MeasureSpec.UNSPECIFIED) {
 936              throw new RuntimeException(&quot;CellLayout cannot have UNSPECIFIED dimensions&quot;);
 937          }
 938  
 939          int numWidthGaps = mCountX - 1;
 940          int numHeightGaps = mCountY - 1;
 941  
 942          if (mOriginalWidthGap &lt; 0 || mOriginalHeightGap &lt; 0) {
 943              int hSpace = widthSpecSize - getPaddingLeft() - getPaddingRight();
 944              int vSpace = heightSpecSize - getPaddingTop() - getPaddingBottom();
 945              int hFreeSpace = hSpace - (mCountX * mCellWidth);
 946              int vFreeSpace = vSpace - (mCountY * mCellHeight);
 947              mWidthGap = Math.min(mMaxGap, numWidthGaps &gt; 0 ? (hFreeSpace / numWidthGaps) : 0);
 948              mHeightGap = Math.min(mMaxGap,numHeightGaps &gt; 0 ? (vFreeSpace / numHeightGaps) : 0);
 949              mShortcutsAndWidgets.setCellDimensions(mCellWidth, mCellHeight, mWidthGap, mHeightGap);
 950          } else {
 951              mWidthGap = mOriginalWidthGap;
 952              mHeightGap = mOriginalHeightGap;
 953          }
 954  
 955          // Initial values correspond to widthSpecMode == MeasureSpec.EXACTLY
 956          int newWidth = widthSpecSize;
 957          int newHeight = heightSpecSize;
 958          if (widthSpecMode == MeasureSpec.AT_MOST) {
 959              newWidth = getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
 960                  ((mCountX - 1) * mWidthGap);
 961              newHeight = getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
 962                  ((mCountY - 1) * mHeightGap);
 963              setMeasuredDimension(newWidth, newHeight);
 964          }
 965  
 966          int count = getChildCount();
 967          for (int i = 0; i &lt; count; i++) {
 968              View child = getChildAt(i);
 969              int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(newWidth - getPaddingLeft() -
 970                      getPaddingRight(), MeasureSpec.EXACTLY);
 971              int childheightMeasureSpec = MeasureSpec.makeMeasureSpec(newHeight - getPaddingTop() -
 972                      getPaddingBottom(), MeasureSpec.EXACTLY);
 973              child.measure(childWidthMeasureSpec, childheightMeasureSpec);
 974          }
 975          setMeasuredDimension(newWidth, newHeight);
 976      }
 977  
 978      @Override
 979      protected void onLayout(boolean changed, int l, int t, int r, int b) {
 980          int count = getChildCount();
 981          for (int i = 0; i &lt; count; i++) {
 982              View child = getChildAt(i);
 983              child.layout(getPaddingLeft(), getPaddingTop(),
 984                      r - l - getPaddingRight(), b - t - getPaddingBottom());
 985          }
 986      }
 987  
 988      @Override
 989      protected void onSizeChanged(int w, int h, int oldw, int oldh) {
 990          super.onSizeChanged(w, h, oldw, oldh);
 991          mBackgroundRect.set(0, 0, w, h);
 992          mForegroundRect.set(mForegroundPadding, mForegroundPadding,
 993                  w - 2 * mForegroundPadding, h - 2 * mForegroundPadding);
 994      }
 995  
 996      @Override
 997      protected void setChildrenDrawingCacheEnabled(boolean enabled) {
 998          mShortcutsAndWidgets.setChildrenDrawingCacheEnabled(enabled);
 999      }
1000  
1001      @Override
1002      protected void setChildrenDrawnWithCacheEnabled(boolean enabled) {
1003          mShortcutsAndWidgets.setChildrenDrawnWithCacheEnabled(enabled);
1004      }
1005  
1006      public float getBackgroundAlpha() {
1007          return mBackgroundAlpha;
1008      }
1009  
1010      public void setBackgroundAlphaMultiplier(float multiplier) {
1011          if (mBackgroundAlphaMultiplier != multiplier) {
1012              mBackgroundAlphaMultiplier = multiplier;
1013              invalidate();
1014          }
1015      }
1016  
1017      public float getBackgroundAlphaMultiplier() {
1018          return mBackgroundAlphaMultiplier;
1019      }
1020  
1021      public void setBackgroundAlpha(float alpha) {
1022          if (mBackgroundAlpha != alpha) {
1023              mBackgroundAlpha = alpha;
1024              invalidate();
1025          }
1026      }
1027  
1028      public void setShortcutAndWidgetAlpha(float alpha) {
1029          final int childCount = getChildCount();
1030          for (int i = 0; i &lt; childCount; i++) {
1031              getChildAt(i).setAlpha(alpha);
1032          }
1033      }
1034  
1035      public ShortcutAndWidgetContainer getShortcutsAndWidgets() {
1036          if (getChildCount() &gt; 0) {
1037              return (ShortcutAndWidgetContainer) getChildAt(0);
1038          }
1039          return null;
1040      }
1041  
1042      public View getChildAt(int x, int y) {
1043          return mShortcutsAndWidgets.getChildAt(x, y);
1044      }
1045  
1046      public boolean animateChildToPosition(final View child, int cellX, int cellY, int duration,
1047              int delay, boolean permanent, boolean adjustOccupied) {
1048          ShortcutAndWidgetContainer clc = getShortcutsAndWidgets();
1049          boolean[][] occupied = mOccupied;
1050          if (!permanent) {
1051              occupied = mTmpOccupied;
1052          }
1053  
1054          if (clc.indexOfChild(child) != -1) {
1055              final LayoutParams lp = (LayoutParams) child.getLayoutParams();
1056              final ItemInfo info = (ItemInfo) child.getTag();
1057  
1058              // We cancel any existing animations
1059              if (mReorderAnimators.containsKey(lp)) {
1060                  mReorderAnimators.get(lp).cancel();
1061                  mReorderAnimators.remove(lp);
1062              }
1063  
1064              final int oldX = lp.x;
1065              final int oldY = lp.y;
1066              if (adjustOccupied) {
1067                  occupied[lp.cellX][lp.cellY] = false;
1068                  occupied[cellX][cellY] = true;
1069              }
1070              lp.isLockedToGrid = true;
1071              if (permanent) {
1072                  lp.cellX = info.cellX = cellX;
1073                  lp.cellY = info.cellY = cellY;
1074              } else {
1075                  lp.tmpCellX = cellX;
1076                  lp.tmpCellY = cellY;
1077              }
1078              clc.setupLp(lp);
1079              lp.isLockedToGrid = false;
1080              final int newX = lp.x;
1081              final int newY = lp.y;
1082  
1083              lp.x = oldX;
1084              lp.y = oldY;
1085  
1086              // Exit early if we&#x27;re not actually moving the view
1087              if (oldX == newX &amp;&amp; oldY == newY) {
1088                  lp.isLockedToGrid = true;
1089                  return true;
1090              }
1091  
1092              ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);

1093              va.setDuration(duration);
1094              mReorderAnimators.put(lp, va);
1095  
1096              va.addUpdateListener(new AnimatorUpdateListener() {
1097                  @Override
1098                  public void onAnimationUpdate(ValueAnimator animation) {
1099                      float r = ((Float) animation.getAnimatedValue()).floatValue();
1100                      lp.x = (int) ((1 - r) * oldX + r * newX);
1101                      lp.y = (int) ((1 - r) * oldY + r * newY);
1102                      child.requestLayout();
1103                  }
1104              });
1105              va.addListener(new AnimatorListenerAdapter() {
1106                  boolean cancelled = false;
1107                  public void onAnimationEnd(Animator animation) {
1108                      // If the animation was cancelled, it means that another animation
1109                      // has interrupted this one, and we don&#x27;t want to lock the item into
1110                      // place just yet.
1111                      if (!cancelled) {
1112                          lp.isLockedToGrid = true;
1113                          child.requestLayout();
1114                      }
1115                      if (mReorderAnimators.containsKey(lp)) {
1116                          mReorderAnimators.remove(lp);
1117                      }
1118                  }
1119                  public void onAnimationCancel(Animator animation) {
1120                      cancelled = true;
1121                  }
1122              });
1123              va.setStartDelay(delay);
1124              va.start();
1125              return true;
1126          }
1127          return false;
1128      }
1129  
1130      /**
1131       * Estimate where the top left cell of the dragged item will land if it is dropped.
1132       *
1133       * @param originX The X value of the top left corner of the item
1134       * @param originY The Y value of the top left corner of the item
1135       * @param spanX The number of horizontal cells that the item spans
1136       * @param spanY The number of vertical cells that the item spans
1137       * @param result The estimated drop cell X and Y.
1138       */
1139      void estimateDropCell(int originX, int originY, int spanX, int spanY, int[] result) {
1140          final int countX = mCountX;
1141          final int countY = mCountY;
1142  
1143          // pointToCellRounded takes the top left of a cell but will pad that with
1144          // cellWidth/2 and cellHeight/2 when finding the matching cell
1145          pointToCellRounded(originX, originY, result);
1146  
1147          // If the item isn&#x27;t fully on this screen, snap to the edges
1148          int rightOverhang = result[0] + spanX - countX;
1149          if (rightOverhang &gt; 0) {
1150              result[0] -= rightOverhang; // Snap to right
1151          }
1152          result[0] = Math.max(0, result[0]); // Snap to left
1153          int bottomOverhang = result[1] + spanY - countY;
1154          if (bottomOverhang &gt; 0) {
1155              result[1] -= bottomOverhang; // Snap to bottom
1156          }
1157          result[1] = Math.max(0, result[1]); // Snap to top
1158      }
1159  
1160      void visualizeDropLocation(View v, Bitmap dragOutline, int originX, int originY, int cellX,
1161              int cellY, int spanX, int spanY, boolean resize, Point dragOffset, Rect dragRegion) {
1162          final int oldDragCellX = mDragCell[0];
1163          final int oldDragCellY = mDragCell[1];
1164  
1165          if (v != null &amp;&amp; dragOffset == null) {
1166              mDragCenter.set(originX + (v.getWidth() / 2), originY + (v.getHeight() / 2));
1167          } else {
1168              mDragCenter.set(originX, originY);
1169          }
1170  
1171          if (dragOutline == null &amp;&amp; v == null) {
1172              return;
1173          }
1174  
1175          if (cellX != oldDragCellX || cellY != oldDragCellY) {
1176              mDragCell[0] = cellX;
1177              mDragCell[1] = cellY;
1178              // Find the top left corner of the rect the object will occupy
1179              final int[] topLeft = mTmpPoint;
1180              cellToPoint(cellX, cellY, topLeft);
1181  
1182              int left = topLeft[0];
1183              int top = topLeft[1];
1184  
1185              if (v != null &amp;&amp; dragOffset == null) {
1186                  // When drawing the drag outline, it did not account for margin offsets
1187                  // added by the view&#x27;s parent.
1188                  MarginLayoutParams lp = (MarginLayoutParams) v.getLayoutParams();
1189                  left += lp.leftMargin;
1190                  top += lp.topMargin;
1191  
1192                  // Offsets due to the size difference between the View and the dragOutline.
1193                  // There is a size difference to account for the outer blur, which may lie
1194                  // outside the bounds of the view.
1195                  top += (v.getHeight() - dragOutline.getHeight()) / 2;
1196                  // We center about the x axis
1197                  left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1198                          - dragOutline.getWidth()) / 2;
1199              } else {
1200                  if (dragOffset != null &amp;&amp; dragRegion != null) {
1201                      // Center the drag region *horizontally* in the cell and apply a drag
1202                      // outline offset
1203                      left += dragOffset.x + ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1204                               - dragRegion.width()) / 2;
1205                      top += dragOffset.y;
1206                  } else {
1207                      // Center the drag outline in the cell
1208                      left += ((mCellWidth * spanX) + ((spanX - 1) * mWidthGap)
1209                              - dragOutline.getWidth()) / 2;
1210                      top += ((mCellHeight * spanY) + ((spanY - 1) * mHeightGap)
1211                              - dragOutline.getHeight()) / 2;
1212                  }
1213              }
1214              final int oldIndex = mDragOutlineCurrent;
1215              mDragOutlineAnims[oldIndex].animateOut();
1216              mDragOutlineCurrent = (oldIndex + 1) % mDragOutlines.length;
1217              Rect r = mDragOutlines[mDragOutlineCurrent];
1218              r.set(left, top, left + dragOutline.getWidth(), top + dragOutline.getHeight());
1219              if (resize) {
1220                  cellToRect(cellX, cellY, spanX, spanY, r);
1221              }
1222  
1223              mDragOutlineAnims[mDragOutlineCurrent].setTag(dragOutline);
1224              mDragOutlineAnims[mDragOutlineCurrent].animateIn();
1225          }
1226      }
1227  
1228      public void clearDragOutlines() {
1229          final int oldIndex = mDragOutlineCurrent;
1230          mDragOutlineAnims[oldIndex].animateOut();
1231          mDragCell[0] = mDragCell[1] = -1;
1232      }
1233  
1234      /**
1235       * Find a vacant area that will fit the given bounds nearest the requested
1236       * cell location. Uses Euclidean distance to score multiple vacant areas.
1237       *
1238       * @param pixelX The X location at which you want to search for a vacant area.
1239       * @param pixelY The Y location at which you want to search for a vacant area.
1240       * @param spanX Horizontal span of the object.
1241       * @param spanY Vertical span of the object.
1242       * @param result Array in which to place the result, or null (in which case a new array will
1243       *        be allocated)
1244       * @return The X, Y cell of a vacant area that can contain this object,
1245       *         nearest the requested location.
1246       */
1247      int[] findNearestVacantArea(int pixelX, int pixelY, int spanX, int spanY,
1248              int[] result) {
1249          return findNearestVacantArea(pixelX, pixelY, spanX, spanY, null, result);
1250      }
1251  
1252      /**
1253       * Find a vacant area that will fit the given bounds nearest the requested
1254       * cell location. Uses Euclidean distance to score multiple vacant areas.
1255       *
1256       * @param pixelX The X location at which you want to search for a vacant area.
1257       * @param pixelY The Y location at which you want to search for a vacant area.
1258       * @param minSpanX The minimum horizontal span required
1259       * @param minSpanY The minimum vertical span required
1260       * @param spanX Horizontal span of the object.
1261       * @param spanY Vertical span of the object.
1262       * @param result Array in which to place the result, or null (in which case a new array will
1263       *        be allocated)
1264       * @return The X, Y cell of a vacant area that can contain this object,
1265       *         nearest the requested location.
1266       */
1267      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1268              int spanY, int[] result, int[] resultSpan) {
1269          return findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null,
1270                  result, resultSpan);
1271      }
1272  
1273      /**
1274       * Find a vacant area that will fit the given bounds nearest the requested
1275       * cell location. Uses Euclidean distance to score multiple vacant areas.
1276       *
1277       * @param pixelX The X location at which you want to search for a vacant area.
1278       * @param pixelY The Y location at which you want to search for a vacant area.
1279       * @param spanX Horizontal span of the object.
1280       * @param spanY Vertical span of the object.
1281       * @param ignoreOccupied If true, the result can be an occupied cell
1282       * @param result Array in which to place the result, or null (in which case a new array will
1283       *        be allocated)
1284       * @return The X, Y cell of a vacant area that can contain this object,
1285       *         nearest the requested location.
1286       */
1287      int[] findNearestArea(int pixelX, int pixelY, int spanX, int spanY, View ignoreView,
1288              boolean ignoreOccupied, int[] result) {
1289          return findNearestArea(pixelX, pixelY, spanX, spanY,
1290                  spanX, spanY, ignoreView, ignoreOccupied, result, null, mOccupied);
1291      }
1292  
1293      private final Stack&lt;Rect&gt; mTempRectStack = new Stack&lt;Rect&gt;();
1294      private void lazyInitTempRectStack() {
1295          if (mTempRectStack.isEmpty()) {
1296              for (int i = 0; i &lt; mCountX * mCountY; i++) {
1297                  mTempRectStack.push(new Rect());
1298              }
1299          }
1300      }
1301  
1302      private void recycleTempRects(Stack&lt;Rect&gt; used) {
1303          while (!used.isEmpty()) {
1304              mTempRectStack.push(used.pop());
1305          }
1306      }
1307  
1308      /**
1309       * Find a vacant area that will fit the given bounds nearest the requested
1310       * cell location. Uses Euclidean distance to score multiple vacant areas.
1311       *
1312       * @param pixelX The X location at which you want to search for a vacant area.
1313       * @param pixelY The Y location at which you want to search for a vacant area.
1314       * @param minSpanX The minimum horizontal span required
1315       * @param minSpanY The minimum vertical span required
1316       * @param spanX Horizontal span of the object.
1317       * @param spanY Vertical span of the object.
1318       * @param ignoreOccupied If true, the result can be an occupied cell
1319       * @param result Array in which to place the result, or null (in which case a new array will
1320       *        be allocated)
1321       * @return The X, Y cell of a vacant area that can contain this object,
1322       *         nearest the requested location.
1323       */
1324      int[] findNearestArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
1325              View ignoreView, boolean ignoreOccupied, int[] result, int[] resultSpan,
1326              boolean[][] occupied) {
1327          lazyInitTempRectStack();
1328          // mark space take by ignoreView as available (method checks if ignoreView is null)
1329          markCellsAsUnoccupiedForView(ignoreView, occupied);
1330  
1331          // For items with a spanX / spanY &gt; 1, the passed in point (pixelX, pixelY) corresponds
1332          // to the center of the item, but we are searching based on the top-left cell, so
1333          // we translate the point over to correspond to the top-left.
1334          pixelX -= (mCellWidth + mWidthGap) * (spanX - 1) / 2f;
1335          pixelY -= (mCellHeight + mHeightGap) * (spanY - 1) / 2f;
1336  
1337          // Keep track of best-scoring drop area
1338          final int[] bestXY = result != null ? result : new int[2];
1339          double bestDistance = Double.MAX_VALUE;
1340          final Rect bestRect = new Rect(-1, -1, -1, -1);
1341          final Stack&lt;Rect&gt; validRegions = new Stack&lt;Rect&gt;();
1342  
1343          final int countX = mCountX;
1344          final int countY = mCountY;
1345  
1346          if (minSpanX &lt;= 0 || minSpanY &lt;= 0 || spanX &lt;= 0 || spanY &lt;= 0 ||
1347                  spanX &lt; minSpanX || spanY &lt; minSpanY) {
1348              return bestXY;
1349          }
1350  
1351          for (int y = 0; y &lt; countY - (minSpanY - 1); y++) {
1352              inner:
1353              for (int x = 0; x &lt; countX - (minSpanX - 1); x++) {
1354                  int ySize = -1;
1355                  int xSize = -1;
1356                  if (ignoreOccupied) {
1357                      // First, let&#x27;s see if this thing fits anywhere
1358                      for (int i = 0; i &lt; minSpanX; i++) {
1359                          for (int j = 0; j &lt; minSpanY; j++) {
1360                              if (occupied[x + i][y + j]) {
1361                                  continue inner;
1362                              }
1363                          }
1364                      }
1365                      xSize = minSpanX;
1366                      ySize = minSpanY;
1367  
1368                      // We know that the item will fit at _some_ acceptable size, now let&#x27;s see
1369                      // how big we can make it. We&#x27;ll alternate between incrementing x and y spans
1370                      // until we hit a limit.
1371                      boolean incX = true;
1372                      boolean hitMaxX = xSize &gt;= spanX;
1373                      boolean hitMaxY = ySize &gt;= spanY;
1374                      while (!(hitMaxX &amp;&amp; hitMaxY)) {
1375                          if (incX &amp;&amp; !hitMaxX) {
1376                              for (int j = 0; j &lt; ySize; j++) {
1377                                  if (x + xSize &gt; countX -1 || occupied[x + xSize][y + j]) {
1378                                      // We can&#x27;t move out horizontally
1379                                      hitMaxX = true;
1380                                  }
1381                              }
1382                              if (!hitMaxX) {
1383                                  xSize++;
1384                              }
1385                          } else if (!hitMaxY) {
1386                              for (int i = 0; i &lt; xSize; i++) {
1387                                  if (y + ySize &gt; countY - 1 || occupied[x + i][y + ySize]) {
1388                                      // We can&#x27;t move out vertically
1389                                      hitMaxY = true;
1390                                  }
1391                              }
1392                              if (!hitMaxY) {
1393                                  ySize++;
1394                              }
1395                          }
1396                          hitMaxX |= xSize &gt;= spanX;
1397                          hitMaxY |= ySize &gt;= spanY;
1398                          incX = !incX;
1399                      }
1400                      incX = true;
1401                      hitMaxX = xSize &gt;= spanX;
1402                      hitMaxY = ySize &gt;= spanY;
1403                  }
1404                  final int[] cellXY = mTmpXY;
1405                  cellToCenterPoint(x, y, cellXY);
1406  
1407                  // We verify that the current rect is not a sub-rect of any of our previous
1408                  // candidates. In this case, the current rect is disqualified in favour of the
1409                  // containing rect.
1410                  Rect currentRect = mTempRectStack.pop();
1411                  currentRect.set(x, y, x + xSize, y + ySize);
1412                  boolean contained = false;
1413                  for (Rect r : validRegions) {
1414                      if (r.contains(currentRect)) {
1415                          contained = true;
1416                          break;
1417                      }
1418                  }
1419                  validRegions.push(currentRect);
1420                  double distance = Math.sqrt(Math.pow(cellXY[0] - pixelX, 2)
1421                          + Math.pow(cellXY[1] - pixelY, 2));
1422  
1423                  if ((distance &lt;= bestDistance &amp;&amp; !contained) ||
1424                          currentRect.contains(bestRect)) {
1425                      bestDistance = distance;
1426                      bestXY[0] = x;
1427                      bestXY[1] = y;
1428                      if (resultSpan != null) {
1429                          resultSpan[0] = xSize;
1430                          resultSpan[1] = ySize;
1431                      }
1432                      bestRect.set(currentRect);
1433                  }
1434              }
1435          }
1436          // re-mark space taken by ignoreView as occupied
1437          markCellsAsOccupiedForView(ignoreView, occupied);
1438  
1439          // Return -1, -1 if no suitable location found
1440          if (bestDistance == Double.MAX_VALUE) {
1441              bestXY[0] = -1;
1442              bestXY[1] = -1;
1443          }
1444          recycleTempRects(validRegions);
1445          return bestXY;
1446      }
1447  
1448       /**
1449       * Find a vacant area that will fit the given bounds nearest the requested
1450       * cell location, and will also weigh in a suggested direction vector of the
1451       * desired location. This method computers distance based on unit grid distances,
1452       * not pixel distances.
1453       *
1454       * @param cellX The X cell nearest to which you want to search for a vacant area.
1455       * @param cellY The Y cell nearest which you want to search for a vacant area.
1456       * @param spanX Horizontal span of the object.
1457       * @param spanY Vertical span of the object.
1458       * @param direction The favored direction in which the views should move from x, y
1459       * @param exactDirectionOnly If this parameter is true, then only solutions where the direction
1460       *        matches exactly. Otherwise we find the best matching direction.
1461       * @param occoupied The array which represents which cells in the CellLayout are occupied
1462       * @param blockOccupied The array which represents which cells in the specified block (cellX,
1463       *        cellY, spanX, spanY) are occupied. This is used when try to move a group of views.
1464       * @param result Array in which to place the result, or null (in which case a new array will
1465       *        be allocated)
1466       * @return The X, Y cell of a vacant area that can contain this object,
1467       *         nearest the requested location.
1468       */
1469      private int[] findNearestArea(int cellX, int cellY, int spanX, int spanY, int[] direction,
1470              boolean[][] occupied, boolean blockOccupied[][], int[] result) {
1471          // Keep track of best-scoring drop area
1472          final int[] bestXY = result != null ? result : new int[2];
1473          float bestDistance = Float.MAX_VALUE;
1474          int bestDirectionScore = Integer.MIN_VALUE;
1475  
1476          final int countX = mCountX;
1477          final int countY = mCountY;
1478  
1479          for (int y = 0; y &lt; countY - (spanY - 1); y++) {
1480              inner:
1481              for (int x = 0; x &lt; countX - (spanX - 1); x++) {
1482                  // First, let&#x27;s see if this thing fits anywhere
1483                  for (int i = 0; i &lt; spanX; i++) {
1484                      for (int j = 0; j &lt; spanY; j++) {
1485                          if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1486                              continue inner;
1487                          }
1488                      }
1489                  }
1490  
1491                  float distance = (float)
1492                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1493                  int[] curDirection = mTmpPoint;
1494                  computeDirectionVector(x - cellX, y - cellY, curDirection);
1495                  // The direction score is just the dot product of the two candidate direction
1496                  // and that passed in.
1497                  int curDirectionScore = direction[0] * curDirection[0] +
1498                          direction[1] * curDirection[1];
1499                  boolean exactDirectionOnly = false;
1500                  boolean directionMatches = direction[0] == curDirection[0] &amp;&amp;
1501                          direction[0] == curDirection[0];
1502                  if ((directionMatches || !exactDirectionOnly) &amp;&amp;
1503                          Float.compare(distance,  bestDistance) &lt; 0 || (Float.compare(distance,
1504                          bestDistance) == 0 &amp;&amp; curDirectionScore &gt; bestDirectionScore)) {
1505                      bestDistance = distance;
1506                      bestDirectionScore = curDirectionScore;
1507                      bestXY[0] = x;
1508                      bestXY[1] = y;
1509                  }
1510              }
1511          }
1512  
1513          // Return -1, -1 if no suitable location found
1514          if (bestDistance == Float.MAX_VALUE) {
1515              bestXY[0] = -1;
1516              bestXY[1] = -1;
1517          }
1518          return bestXY;
1519      }
1520  
1521      private int[] findNearestAreaInDirection(int cellX, int cellY, int spanX, int spanY,
1522              int[] direction,boolean[][] occupied,
1523              boolean blockOccupied[][], int[] result) {
1524          // Keep track of best-scoring drop area
1525          final int[] bestXY = result != null ? result : new int[2];
1526          bestXY[0] = -1;
1527          bestXY[1] = -1;
1528          float bestDistance = Float.MAX_VALUE;
1529  
1530          // We use this to march in a single direction
1531          if ((direction[0] != 0 &amp;&amp; direction[1] != 0) ||
1532                  (direction[0] == 0 &amp;&amp; direction[1] == 0)) {
1533              return bestXY;
1534          }
1535  
1536          // This will only incrememnet one of x or y based on the assertion above
1537          int x = cellX + direction[0];
1538          int y = cellY + direction[1];
1539          while (x &gt;= 0 &amp;&amp; x + spanX &lt;= mCountX &amp;&amp; y &gt;= 0 &amp;&amp; y + spanY &lt;= mCountY) {
1540  
1541              boolean fail = false;
1542              for (int i = 0; i &lt; spanX; i++) {
1543                  for (int j = 0; j &lt; spanY; j++) {
1544                      if (occupied[x + i][y + j] &amp;&amp; (blockOccupied == null || blockOccupied[i][j])) {
1545                          fail = true;
1546                      }
1547                  }
1548              }
1549              if (!fail) {
1550                  float distance = (float)
1551                          Math.sqrt((x - cellX) * (x - cellX) + (y - cellY) * (y - cellY));
1552                  if (Float.compare(distance,  bestDistance) &lt; 0) {
1553                      bestDistance = distance;
1554                      bestXY[0] = x;
1555                      bestXY[1] = y;
1556                  }
1557              }
1558              x += direction[0];
1559              y += direction[1];
1560          }
1561          return bestXY;
1562      }
1563  
1564      private boolean addViewToTempLocation(View v, Rect rectOccupiedByPotentialDrop,
1565              int[] direction, ItemConfiguration currentState) {
1566          CellAndSpan c = currentState.map.get(v);
1567          boolean success = false;
1568          markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1569          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1570  
1571          findNearestArea(c.x, c.y, c.spanX, c.spanY, direction, mTmpOccupied, null, mTempLocation);
1572  
1573          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1574              c.x = mTempLocation[0];
1575              c.y = mTempLocation[1];
1576              success = true;
1577  
1578          }
1579          markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1580          return success;
1581      }
1582  
1583      // This method looks in the specified direction to see if there is an additional view
1584      // immediately adjecent in that direction



1585      private boolean addViewInDirection(ArrayList&lt;View&gt; views, Rect boundingRect, int[] direction,
1586              boolean[][] occupied, View dragView, ItemConfiguration currentState) {
1587          boolean found = false;
1588  
1589          int childCount = mShortcutsAndWidgets.getChildCount();
1590          Rect r0 = new Rect(boundingRect);
1591          Rect r1 = new Rect();
1592  

1593          int deltaX = 0;
1594          int deltaY = 0;
1595          if (direction[1] &lt; 0) {
1596              r0.set(r0.left, r0.top - 1, r0.right, r0.bottom);

1597              deltaY = -1;
1598          } else if (direction[1] &gt; 0) {
1599              r0.set(r0.left, r0.top, r0.right, r0.bottom + 1);

1600              deltaY = 1;
1601          } else if (direction[0] &lt; 0) {
1602              r0.set(r0.left - 1, r0.top, r0.right, r0.bottom);

1603              deltaX = -1;
1604          } else if (direction[0] &gt; 0) {
1605              r0.set(r0.left, r0.top, r0.right + 1, r0.bottom);

1606              deltaX = 1;
1607          }
1608  


1609          for (int i = 0; i &lt; childCount; i++) {

1610              View child = mShortcutsAndWidgets.getChildAt(i);
1611              if (views.contains(child) || child == dragView) continue;
1612              CellAndSpan c = currentState.map.get(child);
1613  
1614              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1615              r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1616              if (Rect.intersects(r0, r1)) {
1617                  if (!lp.canReorder) {
1618                      return false;
1619                  }
1620                  boolean pushed = false;
1621                  for (int x = c.x; x &lt; c.x + c.spanX; x++) {
1622                      for (int y = c.y; y &lt; c.y + c.spanY; y++) {
1623                          boolean inBounds = x - deltaX &gt;= 0 &amp;&amp; x -deltaX &lt; mCountX
1624                                  &amp;&amp; y - deltaY &gt;= 0 &amp;&amp; y - deltaY &lt; mCountY;
1625                          if (inBounds &amp;&amp; occupied[x - deltaX][y - deltaY]) {
1626                              pushed = true;

















1627                          }
1628                      }
1629                  }
1630                  if (pushed) {
1631                      views.add(child);
1632                      boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1633                      found = true;





1634                  }
1635              }
1636          }
1637          return found;
1638      }
1639  
1640      private boolean addViewsToTempLocation(ArrayList&lt;View&gt; views, Rect rectOccupiedByPotentialDrop,
1641              int[] direction, boolean push, View dragView, ItemConfiguration currentState) {
1642          if (views.size() == 0) return true;
1643  
1644          boolean success = false;
1645          Rect boundingRect = null;
1646          // We construct a rect which represents the entire group of views passed in
1647          for (View v: views) {
1648              CellAndSpan c = currentState.map.get(v);
1649              if (boundingRect == null) {
1650                  boundingRect = new Rect(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1651              } else {
1652                  boundingRect.union(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1653              }
1654          }
1655  
1656          @SuppressWarnings(&quot;unchecked&quot;)
1657          ArrayList&lt;View&gt; dup = (ArrayList&lt;View&gt;) views.clone();
1658          // We try and expand the group of views in the direction vector passed, based on
1659          // whether they are physically adjacent, ie. based on &quot;push mechanics&quot;.
1660          while (push &amp;&amp; addViewInDirection(dup, boundingRect, direction, mTmpOccupied, dragView,
1661                  currentState)) {
1662          }
1663  
1664          // Mark the occupied state as false for the group of views we want to move.
1665          for (View v: dup) {
1666              CellAndSpan c = currentState.map.get(v);
1667              markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, false);
1668          }
1669  
1670          boolean[][] blockOccupied = new boolean[boundingRect.width()][boundingRect.height()];
1671          int top = boundingRect.top;
1672          int left = boundingRect.left;
1673          // We mark more precisely which parts of the bounding rect are truly occupied, allowing
1674          // for tetris-style interlocking.

1675          for (View v: dup) {
1676              CellAndSpan c = currentState.map.get(v);
1677              markCellsForView(c.x - left, c.y - top, c.spanX, c.spanY, blockOccupied, true);
1678          }
1679  
1680          markCellsForRect(rectOccupiedByPotentialDrop, mTmpOccupied, true);
1681  
1682          if (push) {
1683              findNearestAreaInDirection(boundingRect.left, boundingRect.top, boundingRect.width(),
1684                      boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1685          } else {
1686              findNearestArea(boundingRect.left, boundingRect.top, boundingRect.width(),
1687                      boundingRect.height(), direction, mTmpOccupied, blockOccupied, mTempLocation);
1688          }
1689  
1690          // If we successfuly found a location by pushing the block of views, we commit it
1691          if (mTempLocation[0] &gt;= 0 &amp;&amp; mTempLocation[1] &gt;= 0) {
1692              int deltaX = mTempLocation[0] - boundingRect.left;
1693              int deltaY = mTempLocation[1] - boundingRect.top;
1694              for (View v: dup) {
1695                  CellAndSpan c = currentState.map.get(v);
1696                  c.x += deltaX;
1697                  c.y += deltaY;
1698              }
1699              success = true;
1700          }
1701  
1702          // In either case, we set the occupied array as marked for the location of the views
1703          for (View v: dup) {
1704              CellAndSpan c = currentState.map.get(v);
1705              markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1706          }
1707          return success;
1708      }
1709  
1710      private void markCellsForRect(Rect r, boolean[][] occupied, boolean value) {
1711          markCellsForView(r.left, r.top, r.width(), r.height(), occupied, value);
1712      }
1713  
1714      // This method tries to find a reordering solution which satisfies the push mechanic by trying
1715      // to push items in each of the cardinal directions, in an order based on the direction vector
1716      // passed.
1717      private boolean attemptPushInDirection(ArrayList&lt;View&gt; intersectingViews, Rect occupied,
1718              int[] direction, View ignoreView, ItemConfiguration solution) {
1719          if ((Math.abs(direction[0]) + Math.abs(direction[1])) &gt; 1) {
1720              // If the direction vector has two non-zero components, we try pushing
1721              // separately in each of the components.
1722              int temp = direction[1];
1723              direction[1] = 0;
1724              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1725                      ignoreView, solution)) {
1726                  return true;
1727              }
1728              direction[1] = temp;
1729              temp = direction[0];
1730              direction[0] = 0;
1731              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1732                      ignoreView, solution)) {
1733                  return true;
1734              }
1735              // Revert the direction
1736              direction[0] = temp;
1737  
1738              // Now we try pushing in each component of the opposite direction
1739              direction[0] *= -1;
1740              direction[1] *= -1;
1741              temp = direction[1];
1742              direction[1] = 0;
1743              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1744                      ignoreView, solution)) {
1745                  return true;
1746              }
1747  
1748              direction[1] = temp;
1749              temp = direction[0];
1750              direction[0] = 0;
1751              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1752                      ignoreView, solution)) {
1753                  return true;
1754              }
1755              // revert the direction
1756              direction[0] = temp;
1757              direction[0] *= -1;
1758              direction[1] *= -1;
1759  
1760          } else {
1761              // If the direction vector has a single non-zero component, we push first in the
1762              // direction of the vector
1763              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1764                      ignoreView, solution)) {
1765                  return true;
1766              }
1767  
1768              // Then we try the opposite direction
1769              direction[0] *= -1;
1770              direction[1] *= -1;
1771              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1772                      ignoreView, solution)) {
1773                  return true;
1774              }
1775              // Switch the direction back
1776              direction[0] *= -1;
1777              direction[1] *= -1;
1778  
1779              // If we have failed to find a push solution with the above, then we try
1780              // to find a solution by pushing along the perpendicular axis.
1781  
1782              // Swap the components
1783              int temp = direction[1];
1784              direction[1] = direction[0];
1785              direction[0] = temp;
1786              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1787                      ignoreView, solution)) {
1788                  return true;
1789              }
1790  
1791              // Then we try the opposite direction
1792              direction[0] *= -1;
1793              direction[1] *= -1;
1794              if (addViewsToTempLocation(intersectingViews, occupied, direction, true,
1795                      ignoreView, solution)) {
1796                  return true;
1797              }
1798              // Switch the direction back
1799              direction[0] *= -1;
1800              direction[1] *= -1;
1801  
1802              // Swap the components back
1803              temp = direction[1];
1804              direction[1] = direction[0];
1805              direction[0] = temp;
1806          }
1807          return false;
1808      }
1809  
1810      private boolean rearrangementExists(int cellX, int cellY, int spanX, int spanY, int[] direction,
1811              View ignoreView, ItemConfiguration solution) {
1812          // Return early if get invalid cell positions
1813          if (cellX &lt; 0 || cellY &lt; 0) return false;
1814  
1815          mIntersectingViews.clear();
1816          mOccupiedRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
1817  
1818          // Mark the desired location of the view currently being dragged.
1819          if (ignoreView != null) {
1820              CellAndSpan c = solution.map.get(ignoreView);
1821              if (c != null) {
1822                  c.x = cellX;
1823                  c.y = cellY;
1824              }
1825          }
1826          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
1827          Rect r1 = new Rect();
1828          for (View child: solution.map.keySet()) {
1829              if (child == ignoreView) continue;
1830              CellAndSpan c = solution.map.get(child);
1831              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1832              r1.set(c.x, c.y, c.x + c.spanX, c.y + c.spanY);
1833              if (Rect.intersects(r0, r1)) {
1834                  if (!lp.canReorder) {
1835                      return false;
1836                  }
1837                  mIntersectingViews.add(child);
1838              }
1839          }
1840  
1841          // First we try to find a solution which respects the push mechanic. That is,
1842          // we try to find a solution such that no displaced item travels through another item
1843          // without also displacing that item.
1844          if (attemptPushInDirection(mIntersectingViews, mOccupiedRect, direction, ignoreView,
1845                  solution)) {
1846              return true;
1847          }
1848  
1849          // Next we try moving the views as a block, but without requiring the push mechanic.
1850          if (addViewsToTempLocation(mIntersectingViews, mOccupiedRect, direction, false, ignoreView,
1851                  solution)) {
1852              return true;
1853          }
1854  
1855          // Ok, they couldn&#x27;t move as a block, let&#x27;s move them individually
1856          for (View v : mIntersectingViews) {
1857              if (!addViewToTempLocation(v, mOccupiedRect, direction, solution)) {
1858                  return false;
1859              }
1860          }
1861          return true;
1862      }
1863  
1864      /*
1865       * Returns a pair (x, y), where x,y are in {-1, 0, 1} corresponding to vector between
1866       * the provided point and the provided cell
1867       */
1868      private void computeDirectionVector(float deltaX, float deltaY, int[] result) {
1869          double angle = Math.atan(((float) deltaY) / deltaX);
1870  
1871          result[0] = 0;
1872          result[1] = 0;
1873          if (Math.abs(Math.cos(angle)) &gt; 0.5f) {
1874              result[0] = (int) Math.signum(deltaX);
1875          }
1876          if (Math.abs(Math.sin(angle)) &gt; 0.5f) {
1877              result[1] = (int) Math.signum(deltaY);
1878          }
1879      }
1880  
1881      private void copyOccupiedArray(boolean[][] occupied) {
1882          for (int i = 0; i &lt; mCountX; i++) {
1883              for (int j = 0; j &lt; mCountY; j++) {
1884                  occupied[i][j] = mOccupied[i][j];
1885              }
1886          }
1887      }
1888  
1889      ItemConfiguration simpleSwap(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX,
1890              int spanY, int[] direction, View dragView, boolean decX, ItemConfiguration solution) {
1891          // Copy the current state into the solution. This solution will be manipulated as necessary.
1892          copyCurrentStateToSolution(solution, false);
1893          // Copy the current occupied array into the temporary occupied array. This array will be
1894          // manipulated as necessary to find a solution.
1895          copyOccupiedArray(mTmpOccupied);
1896  
1897          // We find the nearest cell into which we would place the dragged item, assuming there&#x27;s
1898          // nothing in its way.
1899          int result[] = new int[2];
1900          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
1901  
1902          boolean success = false;
1903          // First we try the exact nearest position of the item being dragged,
1904          // we will then want to try to move this around to other neighbouring positions
1905          success = rearrangementExists(result[0], result[1], spanX, spanY, direction, dragView,
1906                  solution);
1907  
1908          if (!success) {
1909              // We try shrinking the widget down to size in an alternating pattern, shrink 1 in
1910              // x, then 1 in y etc.
1911              if (spanX &gt; minSpanX &amp;&amp; (minSpanY == spanY || decX)) {
1912                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX - 1, spanY, direction,
1913                          dragView, false, solution);
1914              } else if (spanY &gt; minSpanY) {
1915                  return simpleSwap(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY - 1, direction,
1916                          dragView, true, solution);
1917              }
1918              solution.isSolution = false;
1919          } else {
1920              solution.isSolution = true;
1921              solution.dragViewX = result[0];
1922              solution.dragViewY = result[1];
1923              solution.dragViewSpanX = spanX;
1924              solution.dragViewSpanY = spanY;
1925          }
1926          return solution;
1927      }
1928  
1929      private void copyCurrentStateToSolution(ItemConfiguration solution, boolean temp) {
1930          int childCount = mShortcutsAndWidgets.getChildCount();
1931          for (int i = 0; i &lt; childCount; i++) {
1932              View child = mShortcutsAndWidgets.getChildAt(i);
1933              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1934              CellAndSpan c;
1935              if (temp) {
1936                  c = new CellAndSpan(lp.tmpCellX, lp.tmpCellY, lp.cellHSpan, lp.cellVSpan);
1937              } else {
1938                  c = new CellAndSpan(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan);
1939              }
1940              solution.map.put(child, c);
1941          }
1942      }
1943  
1944      private void copySolutionToTempState(ItemConfiguration solution, View dragView) {
1945          for (int i = 0; i &lt; mCountX; i++) {
1946              for (int j = 0; j &lt; mCountY; j++) {
1947                  mTmpOccupied[i][j] = false;
1948              }
1949          }
1950  
1951          int childCount = mShortcutsAndWidgets.getChildCount();
1952          for (int i = 0; i &lt; childCount; i++) {
1953              View child = mShortcutsAndWidgets.getChildAt(i);
1954              if (child == dragView) continue;
1955              LayoutParams lp = (LayoutParams) child.getLayoutParams();
1956              CellAndSpan c = solution.map.get(child);
1957              if (c != null) {
1958                  lp.tmpCellX = c.x;
1959                  lp.tmpCellY = c.y;
1960                  lp.cellHSpan = c.spanX;
1961                  lp.cellVSpan = c.spanY;
1962                  markCellsForView(c.x, c.y, c.spanX, c.spanY, mTmpOccupied, true);
1963              }
1964          }
1965          markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1966                  solution.dragViewSpanY, mTmpOccupied, true);
1967      }
1968  
1969      private void animateItemsToSolution(ItemConfiguration solution, View dragView, boolean
1970              commitDragView) {
1971  
1972          boolean[][] occupied = DESTRUCTIVE_REORDER ? mOccupied : mTmpOccupied;
1973          for (int i = 0; i &lt; mCountX; i++) {
1974              for (int j = 0; j &lt; mCountY; j++) {
1975                  occupied[i][j] = false;
1976              }
1977          }
1978  
1979          int childCount = mShortcutsAndWidgets.getChildCount();
1980          for (int i = 0; i &lt; childCount; i++) {
1981              View child = mShortcutsAndWidgets.getChildAt(i);
1982              if (child == dragView) continue;
1983              CellAndSpan c = solution.map.get(child);
1984              if (c != null) {
1985                  animateChildToPosition(child, c.x, c.y, REORDER_ANIMATION_DURATION, 0,
1986                          DESTRUCTIVE_REORDER, false);
1987                  markCellsForView(c.x, c.y, c.spanX, c.spanY, occupied, true);
1988              }
1989          }
1990          if (commitDragView) {
1991              markCellsForView(solution.dragViewX, solution.dragViewY, solution.dragViewSpanX,
1992                      solution.dragViewSpanY, occupied, true);
1993          }
1994      }
1995  
1996      // This method starts or changes the reorder hint animations
1997      private void beginOrAdjustHintAnimations(ItemConfiguration solution, View dragView, int delay) {
1998          int childCount = mShortcutsAndWidgets.getChildCount();
1999          for (int i = 0; i &lt; childCount; i++) {
2000              View child = mShortcutsAndWidgets.getChildAt(i);
2001              if (child == dragView) continue;
2002              CellAndSpan c = solution.map.get(child);
2003              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2004              if (c != null) {
2005                  ReorderHintAnimation rha = new ReorderHintAnimation(child, lp.cellX, lp.cellY,
2006                          c.x, c.y, c.spanX, c.spanY);
2007                  rha.animate();
2008              }
2009          }
2010      }
2011  
2012      // Class which represents the reorder hint animations. These animations show that an item is
2013      // in a temporary state, and hint at where the item will return to.
2014      class ReorderHintAnimation {
2015          View child;
2016          float finalDeltaX;
2017          float finalDeltaY;
2018          float initDeltaX;
2019          float initDeltaY;
2020          float finalScale;
2021          float initScale;
2022          private static final int DURATION = 300;
2023          Animator a;
2024  
2025          public ReorderHintAnimation(View child, int cellX0, int cellY0, int cellX1, int cellY1,
2026                  int spanX, int spanY) {
2027              regionToCenterPoint(cellX0, cellY0, spanX, spanY, mTmpPoint);
2028              final int x0 = mTmpPoint[0];
2029              final int y0 = mTmpPoint[1];
2030              regionToCenterPoint(cellX1, cellY1, spanX, spanY, mTmpPoint);
2031              final int x1 = mTmpPoint[0];
2032              final int y1 = mTmpPoint[1];
2033              final int dX = x1 - x0;
2034              final int dY = y1 - y0;
2035              finalDeltaX = 0;
2036              finalDeltaY = 0;
2037              if (dX == dY &amp;&amp; dX == 0) {
2038              } else {
2039                  if (dY == 0) {
2040                      finalDeltaX = - Math.signum(dX) * mReorderHintAnimationMagnitude;
2041                  } else if (dX == 0) {
2042                      finalDeltaY = - Math.signum(dY) * mReorderHintAnimationMagnitude;
2043                  } else {
2044                      double angle = Math.atan( (float) (dY) / dX);
2045                      finalDeltaX = (int) (- Math.signum(dX) *
2046                              Math.abs(Math.cos(angle) * mReorderHintAnimationMagnitude));
2047                      finalDeltaY = (int) (- Math.signum(dY) *
2048                              Math.abs(Math.sin(angle) * mReorderHintAnimationMagnitude));
2049                  }
2050              }
2051              initDeltaX = child.getTranslationX();
2052              initDeltaY = child.getTranslationY();
2053              finalScale = 1.0f - 4.0f / child.getWidth();
2054              initScale = child.getScaleX();
2055  
2056              child.setPivotY(child.getMeasuredHeight() * 0.5f);
2057              child.setPivotX(child.getMeasuredWidth() * 0.5f);
2058              this.child = child;
2059          }
2060  
2061          void animate() {
2062              if (mShakeAnimators.containsKey(child)) {
2063                  ReorderHintAnimation oldAnimation = mShakeAnimators.get(child);
2064                  oldAnimation.cancel();
2065                  mShakeAnimators.remove(child);
2066                  if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2067                      completeAnimationImmediately();
2068                      return;
2069                  }
2070              }
2071              if (finalDeltaX == 0 &amp;&amp; finalDeltaY == 0) {
2072                  return;
2073              }
2074              ValueAnimator va = ValueAnimator.ofFloat(0f, 1f);

2075              a = va;
2076              va.setRepeatMode(ValueAnimator.REVERSE);
2077              va.setRepeatCount(ValueAnimator.INFINITE);
2078              va.setDuration(DURATION);
2079              va.setStartDelay((int) (Math.random() * 60));
2080              va.addUpdateListener(new AnimatorUpdateListener() {
2081                  @Override
2082                  public void onAnimationUpdate(ValueAnimator animation) {
2083                      float r = ((Float) animation.getAnimatedValue()).floatValue();
2084                      float x = r * finalDeltaX + (1 - r) * initDeltaX;
2085                      float y = r * finalDeltaY + (1 - r) * initDeltaY;
2086                      child.setTranslationX(x);
2087                      child.setTranslationY(y);
2088                      float s = r * finalScale + (1 - r) * initScale;
2089                      child.setScaleX(s);
2090                      child.setScaleY(s);
2091                  }
2092              });
2093              va.addListener(new AnimatorListenerAdapter() {
2094                  public void onAnimationRepeat(Animator animation) {
2095                      // We make sure to end only after a full period
2096                      initDeltaX = 0;
2097                      initDeltaY = 0;
2098                      initScale = 1.0f;
2099                  }
2100              });
2101              mShakeAnimators.put(child, this);
2102              va.start();
2103          }
2104  
2105          private void cancel() {
2106              if (a != null) {
2107                  a.cancel();
2108              }
2109          }
2110  
2111          private void completeAnimationImmediately() {
2112              if (a != null) {
2113                  a.cancel();
2114              }
2115  
2116              AnimatorSet s = new AnimatorSet();

2117              a = s;
2118              s.playTogether(
2119                  ObjectAnimator.ofFloat(child, &quot;scaleX&quot;, 1f),
2120                  ObjectAnimator.ofFloat(child, &quot;scaleY&quot;, 1f),
2121                  ObjectAnimator.ofFloat(child, &quot;translationX&quot;, 0f),
2122                  ObjectAnimator.ofFloat(child, &quot;translationY&quot;, 0f)




2123              );
2124              s.setDuration(REORDER_ANIMATION_DURATION);
2125              s.setInterpolator(new android.view.animation.DecelerateInterpolator(1.5f));
2126              s.start();
2127          }
2128      }
2129  
2130      private void completeAndClearReorderHintAnimations() {
2131          for (ReorderHintAnimation a: mShakeAnimators.values()) {
2132              a.completeAnimationImmediately();
2133          }
2134          mShakeAnimators.clear();
2135      }
2136  
2137      private void commitTempPlacement() {
2138          for (int i = 0; i &lt; mCountX; i++) {
2139              for (int j = 0; j &lt; mCountY; j++) {
2140                  mOccupied[i][j] = mTmpOccupied[i][j];
2141              }
2142          }
2143          int childCount = mShortcutsAndWidgets.getChildCount();
2144          for (int i = 0; i &lt; childCount; i++) {
2145              View child = mShortcutsAndWidgets.getChildAt(i);
2146              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2147              ItemInfo info = (ItemInfo) child.getTag();
2148              // We do a null check here because the item info can be null in the case of the
2149              // AllApps button in the hotseat.
2150              if (info != null) {




2151                  info.cellX = lp.cellX = lp.tmpCellX;
2152                  info.cellY = lp.cellY = lp.tmpCellY;
2153                  info.spanX = lp.cellHSpan;
2154                  info.spanY = lp.cellVSpan;
2155              }
2156          }
2157          mLauncher.getWorkspace().updateItemLocationsInDatabase(this);
2158      }
2159  
2160      public void setUseTempCoords(boolean useTempCoords) {
2161          int childCount = mShortcutsAndWidgets.getChildCount();
2162          for (int i = 0; i &lt; childCount; i++) {
2163              LayoutParams lp = (LayoutParams) mShortcutsAndWidgets.getChildAt(i).getLayoutParams();
2164              lp.useTmpCoords = useTempCoords;
2165          }
2166      }
2167  
2168      ItemConfiguration findConfigurationNoShuffle(int pixelX, int pixelY, int minSpanX, int minSpanY,
2169              int spanX, int spanY, View dragView, ItemConfiguration solution) {
2170          int[] result = new int[2];
2171          int[] resultSpan = new int[2];
2172          findNearestVacantArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, null, result,
2173                  resultSpan);
2174          if (result[0] &gt;= 0 &amp;&amp; result[1] &gt;= 0) {
2175              copyCurrentStateToSolution(solution, false);
2176              solution.dragViewX = result[0];
2177              solution.dragViewY = result[1];
2178              solution.dragViewSpanX = resultSpan[0];
2179              solution.dragViewSpanY = resultSpan[1];
2180              solution.isSolution = true;
2181          } else {
2182              solution.isSolution = false;
2183          }
2184          return solution;
2185      }
2186  
2187      public void prepareChildForDrag(View child) {
2188          markCellsAsUnoccupiedForView(child);
2189      }
2190  
2191      /* This seems like it should be obvious and straight-forward, but when the direction vector
2192      needs to match with the notion of the dragView pushing other views, we have to employ
2193      a slightly more subtle notion of the direction vector. The question is what two points is
2194      the vector between? The center of the dragView and its desired destination? Not quite, as
2195      this doesn&#x27;t necessarily coincide with the interaction of the dragView and items occupying
2196      those cells. Instead we use some heuristics to often lock the vector to up, down, left
2197      or right, which helps make pushing feel right.
2198      */
2199      private void getDirectionVectorForDrop(int dragViewCenterX, int dragViewCenterY, int spanX,
2200              int spanY, View dragView, int[] resultDirection) {
2201          int[] targetDestination = new int[2];
2202  
2203          findNearestArea(dragViewCenterX, dragViewCenterY, spanX, spanY, targetDestination);
2204          Rect dragRect = new Rect();
2205          regionToRect(targetDestination[0], targetDestination[1], spanX, spanY, dragRect);
2206          dragRect.offset(dragViewCenterX - dragRect.centerX(), dragViewCenterY - dragRect.centerY());
2207  
2208          Rect dropRegionRect = new Rect();
2209          getViewsIntersectingRegion(targetDestination[0], targetDestination[1], spanX, spanY,
2210                  dragView, dropRegionRect, mIntersectingViews);
2211  
2212          int dropRegionSpanX = dropRegionRect.width();
2213          int dropRegionSpanY = dropRegionRect.height();
2214  
2215          regionToRect(dropRegionRect.left, dropRegionRect.top, dropRegionRect.width(),
2216                  dropRegionRect.height(), dropRegionRect);
2217  
2218          int deltaX = (dropRegionRect.centerX() - dragViewCenterX) / spanX;
2219          int deltaY = (dropRegionRect.centerY() - dragViewCenterY) / spanY;
2220  
2221          if (dropRegionSpanX == mCountX || spanX == mCountX) {
2222              deltaX = 0;
2223          }
2224          if (dropRegionSpanY == mCountY || spanY == mCountY) {
2225              deltaY = 0;
2226          }
2227  
2228          if (deltaX == 0 &amp;&amp; deltaY == 0) {
2229              // No idea what to do, give a random direction.
2230              resultDirection[0] = 1;
2231              resultDirection[1] = 0;
2232          } else {
2233              computeDirectionVector(deltaX, deltaY, resultDirection);
2234          }
2235      }
2236  
2237      // For a given cell and span, fetch the set of views intersecting the region.
2238      private void getViewsIntersectingRegion(int cellX, int cellY, int spanX, int spanY,
2239              View dragView, Rect boundingRect, ArrayList&lt;View&gt; intersectingViews) {
2240          if (boundingRect != null) {
2241              boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);
2242          }
2243          intersectingViews.clear();
2244          Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);
2245          Rect r1 = new Rect();
2246          final int count = mShortcutsAndWidgets.getChildCount();
2247          for (int i = 0; i &lt; count; i++) {
2248              View child = mShortcutsAndWidgets.getChildAt(i);
2249              if (child == dragView) continue;
2250              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2251              r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);
2252              if (Rect.intersects(r0, r1)) {
2253                  mIntersectingViews.add(child);
2254                  if (boundingRect != null) {
2255                      boundingRect.union(r1);
2256                  }
2257              }
2258          }
2259      }
2260  
2261      boolean isNearestDropLocationOccupied(int pixelX, int pixelY, int spanX, int spanY,
2262              View dragView, int[] result) {
2263          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2264          getViewsIntersectingRegion(result[0], result[1], spanX, spanY, dragView, null,
2265                  mIntersectingViews);
2266          return !mIntersectingViews.isEmpty();
2267      }
2268  
2269      void revertTempState() {
2270          if (!isItemPlacementDirty() || DESTRUCTIVE_REORDER) return;
2271          final int count = mShortcutsAndWidgets.getChildCount();
2272          for (int i = 0; i &lt; count; i++) {
2273              View child = mShortcutsAndWidgets.getChildAt(i);
2274              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2275              if (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.cellY) {
2276                  lp.tmpCellX = lp.cellX;
2277                  lp.tmpCellY = lp.cellY;
2278                  animateChildToPosition(child, lp.cellX, lp.cellY, REORDER_ANIMATION_DURATION,
2279                          0, false, false);
2280              }
2281          }
2282          completeAndClearReorderHintAnimations();
2283          setItemPlacementDirty(false);
2284      }
2285  
2286      boolean createAreaForResize(int cellX, int cellY, int spanX, int spanY,
2287              View dragView, int[] direction, boolean commit) {
2288          int[] pixelXY = new int[2];
2289          regionToCenterPoint(cellX, cellY, spanX, spanY, pixelXY);
2290  
2291          // First we determine if things have moved enough to cause a different layout
2292          ItemConfiguration swapSolution = simpleSwap(pixelXY[0], pixelXY[1], spanX, spanY,
2293                   spanX,  spanY, direction, dragView,  true,  new ItemConfiguration());
2294  
2295          setUseTempCoords(true);
2296          if (swapSolution != null &amp;&amp; swapSolution.isSolution) {
2297              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2298              // committing anything or animating anything as we just want to determine if a solution
2299              // exists
2300              copySolutionToTempState(swapSolution, dragView);
2301              setItemPlacementDirty(true);
2302              animateItemsToSolution(swapSolution, dragView, commit);
2303  
2304              if (commit) {
2305                  commitTempPlacement();
2306                  completeAndClearReorderHintAnimations();
2307                  setItemPlacementDirty(false);
2308              } else {
2309                  beginOrAdjustHintAnimations(swapSolution, dragView,
2310                          REORDER_ANIMATION_DURATION);
2311              }
2312              mShortcutsAndWidgets.requestLayout();
2313          }
2314          return swapSolution.isSolution;
2315      }
2316  
2317      int[] createArea(int pixelX, int pixelY, int minSpanX, int minSpanY, int spanX, int spanY,
2318              View dragView, int[] result, int resultSpan[], int mode) {
2319          // First we determine if things have moved enough to cause a different layout
2320          result = findNearestArea(pixelX, pixelY, spanX, spanY, result);
2321  
2322          if (resultSpan == null) {
2323              resultSpan = new int[2];
2324          }
2325  
2326          // When we are checking drop validity or actually dropping, we don&#x27;t recompute the
2327          // direction vector, since we want the solution to match the preview, and it&#x27;s possible
2328          // that the exact position of the item has changed to result in a new reordering outcome.
2329          if ((mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL || mode == MODE_ACCEPT_DROP)
2330                 &amp;&amp; mPreviousReorderDirection[0] != INVALID_DIRECTION) {
2331              mDirectionVector[0] = mPreviousReorderDirection[0];
2332              mDirectionVector[1] = mPreviousReorderDirection[1];
2333              // We reset this vector after drop
2334              if (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2335                  mPreviousReorderDirection[0] = INVALID_DIRECTION;
2336                  mPreviousReorderDirection[1] = INVALID_DIRECTION;
2337              }
2338          } else {
2339              getDirectionVectorForDrop(pixelX, pixelY, spanX, spanY, dragView, mDirectionVector);
2340              mPreviousReorderDirection[0] = mDirectionVector[0];
2341              mPreviousReorderDirection[1] = mDirectionVector[1];
2342          }
2343  
2344          ItemConfiguration swapSolution = simpleSwap(pixelX, pixelY, minSpanX, minSpanY,
2345                   spanX,  spanY, mDirectionVector, dragView,  true,  new ItemConfiguration());
2346  
2347          // We attempt the approach which doesn&#x27;t shuffle views at all
2348          ItemConfiguration noShuffleSolution = findConfigurationNoShuffle(pixelX, pixelY, minSpanX,
2349                  minSpanY, spanX, spanY, dragView, new ItemConfiguration());
2350  
2351          ItemConfiguration finalSolution = null;
2352          if (swapSolution.isSolution &amp;&amp; swapSolution.area() &gt;= noShuffleSolution.area()) {
2353              finalSolution = swapSolution;
2354          } else if (noShuffleSolution.isSolution) {
2355              finalSolution = noShuffleSolution;
2356          }
2357  
2358          boolean foundSolution = true;
2359          if (!DESTRUCTIVE_REORDER) {
2360              setUseTempCoords(true);
2361          }
2362  
2363          if (finalSolution != null) {
2364              result[0] = finalSolution.dragViewX;
2365              result[1] = finalSolution.dragViewY;
2366              resultSpan[0] = finalSolution.dragViewSpanX;
2367              resultSpan[1] = finalSolution.dragViewSpanY;
2368  
2369              // If we&#x27;re just testing for a possible location (MODE_ACCEPT_DROP), we don&#x27;t bother
2370              // committing anything or animating anything as we just want to determine if a solution
2371              // exists
2372              if (mode == MODE_DRAG_OVER || mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL) {
2373                  if (!DESTRUCTIVE_REORDER) {
2374                      copySolutionToTempState(finalSolution, dragView);
2375                  }
2376                  setItemPlacementDirty(true);
2377                  animateItemsToSolution(finalSolution, dragView, mode == MODE_ON_DROP);
2378  
2379                  if (!DESTRUCTIVE_REORDER &amp;&amp;
2380                          (mode == MODE_ON_DROP || mode == MODE_ON_DROP_EXTERNAL)) {
2381                      commitTempPlacement();
2382                      completeAndClearReorderHintAnimations();
2383                      setItemPlacementDirty(false);
2384                  } else {
2385                      beginOrAdjustHintAnimations(finalSolution, dragView,
2386                              REORDER_ANIMATION_DURATION);
2387                  }
2388              }
2389          } else {
2390              foundSolution = false;
2391              result[0] = result[1] = resultSpan[0] = resultSpan[1] = -1;
2392          }
2393  
2394          if ((mode == MODE_ON_DROP || !foundSolution) &amp;&amp; !DESTRUCTIVE_REORDER) {
2395              setUseTempCoords(false);
2396          }
2397  
2398          mShortcutsAndWidgets.requestLayout();
2399          return result;
2400      }
2401  
2402      void setItemPlacementDirty(boolean dirty) {
2403          mItemPlacementDirty = dirty;
2404      }
2405      boolean isItemPlacementDirty() {
2406          return mItemPlacementDirty;
2407      }
2408  
2409      private class ItemConfiguration {
2410          HashMap&lt;View, CellAndSpan&gt; map = new HashMap&lt;View, CellAndSpan&gt;();
2411          boolean isSolution = false;
2412          int dragViewX, dragViewY, dragViewSpanX, dragViewSpanY;
2413  
2414          int area() {
2415              return dragViewSpanX * dragViewSpanY;
2416          }
2417      }
2418  
2419      private class CellAndSpan {
2420          int x, y;
2421          int spanX, spanY;
2422  
2423          public CellAndSpan(int x, int y, int spanX, int spanY) {
2424              this.x = x;
2425              this.y = y;
2426              this.spanX = spanX;
2427              this.spanY = spanY;
2428          }
2429      }
2430  
2431      /**
2432       * Find a vacant area that will fit the given bounds nearest the requested
2433       * cell location. Uses Euclidean distance to score multiple vacant areas.
2434       *
2435       * @param pixelX The X location at which you want to search for a vacant area.
2436       * @param pixelY The Y location at which you want to search for a vacant area.
2437       * @param spanX Horizontal span of the object.
2438       * @param spanY Vertical span of the object.
2439       * @param ignoreView Considers space occupied by this view as unoccupied
2440       * @param result Previously returned value to possibly recycle.
2441       * @return The X, Y cell of a vacant area that can contain this object,
2442       *         nearest the requested location.
2443       */
2444      int[] findNearestVacantArea(
2445              int pixelX, int pixelY, int spanX, int spanY, View ignoreView, int[] result) {
2446          return findNearestArea(pixelX, pixelY, spanX, spanY, ignoreView, true, result);
2447      }
2448  
2449      /**
2450       * Find a vacant area that will fit the given bounds nearest the requested
2451       * cell location. Uses Euclidean distance to score multiple vacant areas.
2452       *
2453       * @param pixelX The X location at which you want to search for a vacant area.
2454       * @param pixelY The Y location at which you want to search for a vacant area.
2455       * @param minSpanX The minimum horizontal span required
2456       * @param minSpanY The minimum vertical span required
2457       * @param spanX Horizontal span of the object.
2458       * @param spanY Vertical span of the object.
2459       * @param ignoreView Considers space occupied by this view as unoccupied
2460       * @param result Previously returned value to possibly recycle.
2461       * @return The X, Y cell of a vacant area that can contain this object,
2462       *         nearest the requested location.
2463       */
2464      int[] findNearestVacantArea(int pixelX, int pixelY, int minSpanX, int minSpanY,
2465              int spanX, int spanY, View ignoreView, int[] result, int[] resultSpan) {
2466          return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, ignoreView, true,
2467                  result, resultSpan, mOccupied);
2468      }
2469  
2470      /**
2471       * Find a starting cell position that will fit the given bounds nearest the requested
2472       * cell location. Uses Euclidean distance to score multiple vacant areas.
2473       *
2474       * @param pixelX The X location at which you want to search for a vacant area.
2475       * @param pixelY The Y location at which you want to search for a vacant area.
2476       * @param spanX Horizontal span of the object.
2477       * @param spanY Vertical span of the object.
2478       * @param ignoreView Considers space occupied by this view as unoccupied
2479       * @param result Previously returned value to possibly recycle.
2480       * @return The X, Y cell of a vacant area that can contain this object,
2481       *         nearest the requested location.
2482       */
2483      int[] findNearestArea(
2484              int pixelX, int pixelY, int spanX, int spanY, int[] result) {
2485          return findNearestArea(pixelX, pixelY, spanX, spanY, null, false, result);
2486      }
2487  
2488      boolean existsEmptyCell() {
2489          return findCellForSpan(null, 1, 1);
2490      }
2491  
2492      /**
2493       * Finds the upper-left coordinate of the first rectangle in the grid that can
2494       * hold a cell of the specified dimensions. If intersectX and intersectY are not -1,
2495       * then this method will only return coordinates for rectangles that contain the cell
2496       * (intersectX, intersectY)
2497       *
2498       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2499       *               can be found.
2500       * @param spanX The horizontal span of the cell we want to find.
2501       * @param spanY The vertical span of the cell we want to find.
2502       *
2503       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2504       */
2505      boolean findCellForSpan(int[] cellXY, int spanX, int spanY) {
2506          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1, null, mOccupied);
2507      }
2508  
2509      /**
2510       * Like above, but ignores any cells occupied by the item &quot;ignoreView&quot;
2511       *
2512       * @param cellXY The array that will contain the position of a vacant cell if such a cell
2513       *               can be found.
2514       * @param spanX The horizontal span of the cell we want to find.
2515       * @param spanY The vertical span of the cell we want to find.
2516       * @param ignoreView The home screen item we should treat as not occupying any space
2517       * @return
2518       */
2519      boolean findCellForSpanIgnoring(int[] cellXY, int spanX, int spanY, View ignoreView) {
2520          return findCellForSpanThatIntersectsIgnoring(cellXY, spanX, spanY, -1, -1,
2521                  ignoreView, mOccupied);
2522      }
2523  
2524      /**
2525       * Like above, but if intersectX and intersectY are not -1, then this method will try to
2526       * return coordinates for rectangles that contain the cell [intersectX, intersectY]
2527       *
2528       * @param spanX The horizontal span of the cell we want to find.
2529       * @param spanY The vertical span of the cell we want to find.
2530       * @param ignoreView The home screen item we should treat as not occupying any space
2531       * @param intersectX The X coordinate of the cell that we should try to overlap
2532       * @param intersectX The Y coordinate of the cell that we should try to overlap
2533       *
2534       * @return True if a vacant cell of the specified dimension was found, false otherwise.
2535       */
2536      boolean findCellForSpanThatIntersects(int[] cellXY, int spanX, int spanY,
2537              int intersectX, int intersectY) {
2538          return findCellForSpanThatIntersectsIgnoring(
2539                  cellXY, spanX, spanY, intersectX, intersectY, null, mOccupied);
2540      }
2541  
2542      /**
2543       * The superset of the above two methods
2544       */
2545      boolean findCellForSpanThatIntersectsIgnoring(int[] cellXY, int spanX, int spanY,
2546              int intersectX, int intersectY, View ignoreView, boolean occupied[][]) {
2547          // mark space take by ignoreView as available (method checks if ignoreView is null)
2548          markCellsAsUnoccupiedForView(ignoreView, occupied);
2549  
2550          boolean foundCell = false;
2551          while (true) {
2552              int startX = 0;
2553              if (intersectX &gt;= 0) {
2554                  startX = Math.max(startX, intersectX - (spanX - 1));
2555              }
2556              int endX = mCountX - (spanX - 1);
2557              if (intersectX &gt;= 0) {
2558                  endX = Math.min(endX, intersectX + (spanX - 1) + (spanX == 1 ? 1 : 0));
2559              }
2560              int startY = 0;
2561              if (intersectY &gt;= 0) {
2562                  startY = Math.max(startY, intersectY - (spanY - 1));
2563              }
2564              int endY = mCountY - (spanY - 1);
2565              if (intersectY &gt;= 0) {
2566                  endY = Math.min(endY, intersectY + (spanY - 1) + (spanY == 1 ? 1 : 0));
2567              }
2568  
2569              for (int y = startY; y &lt; endY &amp;&amp; !foundCell; y++) {
2570                  inner:
2571                  for (int x = startX; x &lt; endX; x++) {
2572                      for (int i = 0; i &lt; spanX; i++) {
2573                          for (int j = 0; j &lt; spanY; j++) {
2574                              if (occupied[x + i][y + j]) {
2575                                  // small optimization: we can skip to after the column we just found
2576                                  // an occupied cell
2577                                  x += i;
2578                                  continue inner;
2579                              }
2580                          }
2581                      }
2582                      if (cellXY != null) {
2583                          cellXY[0] = x;
2584                          cellXY[1] = y;
2585                      }
2586                      foundCell = true;
2587                      break;
2588                  }
2589              }
2590              if (intersectX == -1 &amp;&amp; intersectY == -1) {
2591                  break;
2592              } else {
2593                  // if we failed to find anything, try again but without any requirements of
2594                  // intersecting
2595                  intersectX = -1;
2596                  intersectY = -1;
2597                  continue;
2598              }
2599          }
2600  
2601          // re-mark space taken by ignoreView as occupied
2602          markCellsAsOccupiedForView(ignoreView, occupied);
2603          return foundCell;
2604      }
2605  
2606      /**
2607       * A drag event has begun over this layout.
2608       * It may have begun over this layout (in which case onDragChild is called first),
2609       * or it may have begun on another layout.
2610       */
2611      void onDragEnter() {
2612          mDragEnforcer.onDragEnter();
2613          mDragging = true;
2614      }
2615  
2616      /**
2617       * Called when drag has left this CellLayout or has been completed (successfully or not)
2618       */
2619      void onDragExit() {
2620          mDragEnforcer.onDragExit();
2621          // This can actually be called when we aren&#x27;t in a drag, e.g. when adding a new
2622          // item to this layout via the customize drawer.
2623          // Guard against that case.
2624          if (mDragging) {
2625              mDragging = false;
2626          }
2627  
2628          // Invalidate the drag data
2629          mDragCell[0] = mDragCell[1] = -1;
2630          mDragOutlineAnims[mDragOutlineCurrent].animateOut();
2631          mDragOutlineCurrent = (mDragOutlineCurrent + 1) % mDragOutlineAnims.length;
2632          revertTempState();
2633          setIsDragOverlapping(false);
2634      }
2635  
2636      /**
2637       * Mark a child as having been dropped.
2638       * At the beginning of the drag operation, the child may have been on another
2639       * screen, but it is re-parented before this method is called.
2640       *
2641       * @param child The child that is being dropped
2642       */
2643      void onDropChild(View child) {
2644          if (child != null) {
2645              LayoutParams lp = (LayoutParams) child.getLayoutParams();
2646              lp.dropped = true;
2647              child.requestLayout();
2648          }
2649      }
2650  
2651      /**
2652       * Computes a bounding rectangle for a range of cells
2653       *
2654       * @param cellX X coordinate of upper left corner expressed as a cell position
2655       * @param cellY Y coordinate of upper left corner expressed as a cell position
2656       * @param cellHSpan Width in cells
2657       * @param cellVSpan Height in cells
2658       * @param resultRect Rect into which to put the results
2659       */
2660      public void cellToRect(int cellX, int cellY, int cellHSpan, int cellVSpan, Rect resultRect) {
2661          final int cellWidth = mCellWidth;
2662          final int cellHeight = mCellHeight;
2663          final int widthGap = mWidthGap;
2664          final int heightGap = mHeightGap;
2665  
2666          final int hStartPadding = getPaddingLeft();
2667          final int vStartPadding = getPaddingTop();
2668  
2669          int width = cellHSpan * cellWidth + ((cellHSpan - 1) * widthGap);
2670          int height = cellVSpan * cellHeight + ((cellVSpan - 1) * heightGap);
2671  
2672          int x = hStartPadding + cellX * (cellWidth + widthGap);
2673          int y = vStartPadding + cellY * (cellHeight + heightGap);
2674  
2675          resultRect.set(x, y, x + width, y + height);
2676      }
2677  
2678      /**
2679       * Computes the required horizontal and vertical cell spans to always
2680       * fit the given rectangle.
2681       *
2682       * @param width Width in pixels
2683       * @param height Height in pixels
2684       * @param result An array of length 2 in which to store the result (may be null).
2685       */
2686      public int[] rectToCell(int width, int height, int[] result) {
2687          return rectToCell(getResources(), width, height, result);
2688      }
2689  
2690      public static int[] rectToCell(Resources resources, int width, int height, int[] result) {
2691          // Always assume we&#x27;re working with the smallest span to make sure we
2692          // reserve enough space in both orientations.
2693          int actualWidth = resources.getDimensionPixelSize(R.dimen.workspace_cell_width);
2694          int actualHeight = resources.getDimensionPixelSize(R.dimen.workspace_cell_height);
2695          int smallerSize = Math.min(actualWidth, actualHeight);
2696  
2697          // Always round up to next largest cell
2698          int spanX = (int) Math.ceil(width / (float) smallerSize);
2699          int spanY = (int) Math.ceil(height / (float) smallerSize);
2700  
2701          if (result == null) {
2702              return new int[] { spanX, spanY };
2703          }
2704          result[0] = spanX;
2705          result[1] = spanY;
2706          return result;
2707      }
2708  
2709      public int[] cellSpansToSize(int hSpans, int vSpans) {
2710          int[] size = new int[2];
2711          size[0] = hSpans * mCellWidth + (hSpans - 1) * mWidthGap;
2712          size[1] = vSpans * mCellHeight + (vSpans - 1) * mHeightGap;
2713          return size;
2714      }
2715  
2716      /**
2717       * Calculate the grid spans needed to fit given item
2718       */
2719      public void calculateSpans(ItemInfo info) {
2720          final int minWidth;
2721          final int minHeight;
2722  
2723          if (info instanceof LauncherAppWidgetInfo) {
2724              minWidth = ((LauncherAppWidgetInfo) info).minWidth;
2725              minHeight = ((LauncherAppWidgetInfo) info).minHeight;
2726          } else if (info instanceof PendingAddWidgetInfo) {
2727              minWidth = ((PendingAddWidgetInfo) info).minWidth;
2728              minHeight = ((PendingAddWidgetInfo) info).minHeight;
2729          } else {
2730              // It&#x27;s not a widget, so it must be 1x1
2731              info.spanX = info.spanY = 1;
2732              return;
2733          }
2734          int[] spans = rectToCell(minWidth, minHeight, null);
2735          info.spanX = spans[0];
2736          info.spanY = spans[1];
2737      }
2738  
2739      /**
2740       * Find the first vacant cell, if there is one.
2741       *
2742       * @param vacant Holds the x and y coordinate of the vacant cell
2743       * @param spanX Horizontal cell span.
2744       * @param spanY Vertical cell span.
2745       *
2746       * @return True if a vacant cell was found
2747       */
2748      public boolean getVacantCell(int[] vacant, int spanX, int spanY) {
2749  
2750          return findVacantCell(vacant, spanX, spanY, mCountX, mCountY, mOccupied);
2751      }
2752  
2753      static boolean findVacantCell(int[] vacant, int spanX, int spanY,
2754              int xCount, int yCount, boolean[][] occupied) {
2755  
2756          for (int y = 0; y &lt; yCount; y++) {
2757              for (int x = 0; x &lt; xCount; x++) {
2758                  boolean available = !occupied[x][y];
2759  out:            for (int i = x; i &lt; x + spanX - 1 &amp;&amp; x &lt; xCount; i++) {
2760                      for (int j = y; j &lt; y + spanY - 1 &amp;&amp; y &lt; yCount; j++) {
2761                          available = available &amp;&amp; !occupied[i][j];
2762                          if (!available) break out;
2763                      }
2764                  }
2765  
2766                  if (available) {
2767                      vacant[0] = x;
2768                      vacant[1] = y;
2769                      return true;
2770                  }
2771              }
2772          }
2773  
2774          return false;
2775      }
2776  
2777      private void clearOccupiedCells() {
2778          for (int x = 0; x &lt; mCountX; x++) {
2779              for (int y = 0; y &lt; mCountY; y++) {
2780                  mOccupied[x][y] = false;
2781              }
2782          }
2783      }
2784  
2785      public void onMove(View view, int newCellX, int newCellY, int newSpanX, int newSpanY) {
2786          markCellsAsUnoccupiedForView(view);
2787          markCellsForView(newCellX, newCellY, newSpanX, newSpanY, mOccupied, true);
2788      }
2789  
2790      public void markCellsAsOccupiedForView(View view) {
2791          markCellsAsOccupiedForView(view, mOccupied);
2792      }
2793      public void markCellsAsOccupiedForView(View view, boolean[][] occupied) {
2794          if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2795          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2796          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, true);
2797      }
2798  
2799      public void markCellsAsUnoccupiedForView(View view) {
2800          markCellsAsUnoccupiedForView(view, mOccupied);
2801      }
2802      public void markCellsAsUnoccupiedForView(View view, boolean occupied[][]) {
2803          if (view == null || view.getParent() != mShortcutsAndWidgets) return;
2804          LayoutParams lp = (LayoutParams) view.getLayoutParams();
2805          markCellsForView(lp.cellX, lp.cellY, lp.cellHSpan, lp.cellVSpan, occupied, false);
2806      }
2807  
2808      private void markCellsForView(int cellX, int cellY, int spanX, int spanY, boolean[][] occupied,
2809              boolean value) {
2810          if (cellX &lt; 0 || cellY &lt; 0) return;
2811          for (int x = cellX; x &lt; cellX + spanX &amp;&amp; x &lt; mCountX; x++) {
2812              for (int y = cellY; y &lt; cellY + spanY &amp;&amp; y &lt; mCountY; y++) {
2813                  occupied[x][y] = value;
2814              }
2815          }
2816      }
2817  
2818      public int getDesiredWidth() {
2819          return getPaddingLeft() + getPaddingRight() + (mCountX * mCellWidth) +
2820                  (Math.max((mCountX - 1), 0) * mWidthGap);
2821      }
2822  
2823      public int getDesiredHeight()  {
2824          return getPaddingTop() + getPaddingBottom() + (mCountY * mCellHeight) +
2825                  (Math.max((mCountY - 1), 0) * mHeightGap);
2826      }
2827  
2828      public boolean isOccupied(int x, int y) {
2829          if (x &lt; mCountX &amp;&amp; y &lt; mCountY) {
2830              return mOccupied[x][y];
2831          } else {
2832              throw new RuntimeException(&quot;Position exceeds the bound of this CellLayout&quot;);
2833          }
2834      }
2835  
2836      @Override
2837      public ViewGroup.LayoutParams generateLayoutParams(AttributeSet attrs) {
2838          return new CellLayout.LayoutParams(getContext(), attrs);
2839      }
2840  
2841      @Override
2842      protected boolean checkLayoutParams(ViewGroup.LayoutParams p) {
2843          return p instanceof CellLayout.LayoutParams;
2844      }
2845  
2846      @Override
2847      protected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) {
2848          return new CellLayout.LayoutParams(p);
2849      }
2850  
2851      public static class CellLayoutAnimationController extends LayoutAnimationController {
2852          public CellLayoutAnimationController(Animation animation, float delay) {
2853              super(animation, delay);
2854          }
2855  
2856          @Override
2857          protected long getDelayForView(View view) {
2858              return (int) (Math.random() * 150);
2859          }
2860      }
2861  
2862      public static class LayoutParams extends ViewGroup.MarginLayoutParams {
2863          /**
2864           * Horizontal location of the item in the grid.
2865           */
2866          @ViewDebug.ExportedProperty
2867          public int cellX;
2868  
2869          /**
2870           * Vertical location of the item in the grid.
2871           */
2872          @ViewDebug.ExportedProperty
2873          public int cellY;
2874  
2875          /**
2876           * Temporary horizontal location of the item in the grid during reorder
2877           */
2878          public int tmpCellX;
2879  
2880          /**
2881           * Temporary vertical location of the item in the grid during reorder
2882           */
2883          public int tmpCellY;
2884  
2885          /**
2886           * Indicates that the temporary coordinates should be used to layout the items
2887           */
2888          public boolean useTmpCoords;
2889  
2890          /**
2891           * Number of cells spanned horizontally by the item.
2892           */
2893          @ViewDebug.ExportedProperty
2894          public int cellHSpan;
2895  
2896          /**
2897           * Number of cells spanned vertically by the item.
2898           */
2899          @ViewDebug.ExportedProperty
2900          public int cellVSpan;
2901  
2902          /**
2903           * Indicates whether the item will set its x, y, width and height parameters freely,
2904           * or whether these will be computed based on cellX, cellY, cellHSpan and cellVSpan.
2905           */
2906          public boolean isLockedToGrid = true;
2907  
2908          /**
2909           * Indicates whether this item can be reordered. Always true except in the case of the
2910           * the AllApps button.
2911           */
2912          public boolean canReorder = true;
2913  
2914          // X coordinate of the view in the layout.
2915          @ViewDebug.ExportedProperty
2916          int x;
2917          // Y coordinate of the view in the layout.
2918          @ViewDebug.ExportedProperty
2919          int y;
2920  
2921          boolean dropped;
2922  
2923          public LayoutParams(Context c, AttributeSet attrs) {
2924              super(c, attrs);
2925              cellHSpan = 1;
2926              cellVSpan = 1;
2927          }
2928  
2929          public LayoutParams(ViewGroup.LayoutParams source) {
2930              super(source);
2931              cellHSpan = 1;
2932              cellVSpan = 1;
2933          }
2934  
2935          public LayoutParams(LayoutParams source) {
2936              super(source);
2937              this.cellX = source.cellX;
2938              this.cellY = source.cellY;
2939              this.cellHSpan = source.cellHSpan;
2940              this.cellVSpan = source.cellVSpan;
2941          }
2942  
2943          public LayoutParams(int cellX, int cellY, int cellHSpan, int cellVSpan) {
2944              super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
2945              this.cellX = cellX;
2946              this.cellY = cellY;
2947              this.cellHSpan = cellHSpan;
2948              this.cellVSpan = cellVSpan;
2949          }
2950  
2951          public void setup(int cellWidth, int cellHeight, int widthGap, int heightGap) {
2952              if (isLockedToGrid) {
2953                  final int myCellHSpan = cellHSpan;
2954                  final int myCellVSpan = cellVSpan;
2955                  final int myCellX = useTmpCoords ? tmpCellX : cellX;
2956                  final int myCellY = useTmpCoords ? tmpCellY : cellY;
2957  
2958                  width = myCellHSpan * cellWidth + ((myCellHSpan - 1) * widthGap) -
2959                          leftMargin - rightMargin;
2960                  height = myCellVSpan * cellHeight + ((myCellVSpan - 1) * heightGap) -
2961                          topMargin - bottomMargin;
2962                  x = (int) (myCellX * (cellWidth + widthGap) + leftMargin);
2963                  y = (int) (myCellY * (cellHeight + heightGap) + topMargin);
2964              }
2965          }
2966  
2967          public String toString() {
2968              return &quot;(&quot; + this.cellX + &quot;, &quot; + this.cellY + &quot;)&quot;;
2969          }
2970  
2971          public void setWidth(int width) {
2972              this.width = width;
2973          }
2974  
2975          public int getWidth() {
2976              return width;
2977          }
2978  
2979          public void setHeight(int height) {
2980              this.height = height;
2981          }
2982  
2983          public int getHeight() {
2984              return height;
2985          }
2986  
2987          public void setX(int x) {
2988              this.x = x;
2989          }
2990  
2991          public int getX() {
2992              return x;
2993          }
2994  
2995          public void setY(int y) {
2996              this.y = y;
2997          }
2998  
2999          public int getY() {
3000              return y;
3001          }
3002      }
3003  
3004      // This class stores info for two purposes:
3005      // 1. When dragging items (mDragInfo in Workspace), we store the View, its cellX &amp; cellY,
3006      //    its spanX, spanY, and the screen it is on
3007      // 2. When long clicking on an empty cell in a CellLayout, we save information about the
3008      //    cellX and cellY coordinates and which page was clicked. We then set this as a tag on
3009      //    the CellLayout that was long clicked
3010      static final class CellInfo {
3011          View cell;
3012          int cellX = -1;
3013          int cellY = -1;
3014          int spanX;
3015          int spanY;
3016          int screen;
3017          long container;
3018  
3019          @Override
3020          public String toString() {
3021              return &quot;Cell[view=&quot; + (cell == null ? &quot;null&quot; : cell.getClass())
3022                      + &quot;, x=&quot; + cellX + &quot;, y=&quot; + cellY + &quot;]&quot;;
3023          }
3024      }
3025  
3026      public boolean lastDownOnOccupiedCell() {
3027          return mLastDownOnOccupiedCell;
3028      }
3029  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            