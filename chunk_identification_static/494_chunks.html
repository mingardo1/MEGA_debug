<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>494 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.JDBCUpsertOutputFormat;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.rdb.format.ExtendOutputFormat;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Iterator;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.stream.Collectors;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public OracleSink() {\n&#x27;
                         &#x27;        super(new OracleDialect());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private final String SQL_DEFAULT_PLACEHOLDER = &#x27;
                           &#x27;&quot; ? &quot;;\n&#x27;
                           &#x27;    private final String DEAL_CHAR_KEY = &quot;char&quot;;\n&#x27;
                           &#x27;    private String RPAD_FORMAT = &quot; rpad(?, %d, \&#x27; &#x27;
                           &#x27;\&#x27;) &quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public String getDriverName() {\n&#x27;
                           &#x27;        return ORACLE_DRIVER;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void buildSql(String scheam, String &#x27;
                           &#x27;tableName, List&lt;String&gt; fields) {\n&#x27;
                           &#x27;        buildInsertSql(scheam, tableName, &#x27;
                           &#x27;fields);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void buildInsertSql(String scheam, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fields) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        tableName = &#x27;
                           &#x27;DtStringUtil.getTableFullPath(scheam,tableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String sqlTmp = &quot;insert into &quot; + tableName &#x27;
                           &#x27;+ &quot; (${fields}) values (${placeholder})&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; adaptFields = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        fields.forEach(field -&gt; &#x27;
                           &#x27;adaptFields.add(DtStringUtil.addQuoteForStr(field)));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String fieldsStr = &#x27;
                           &#x27;StringUtils.join(adaptFields, &quot;,&quot;);\n&#x27;
                           &#x27;        String placeholder = &quot;&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (String fieldName : fields) {\n&#x27;
                           &#x27;            placeholder += &quot;,?&quot;;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        placeholder = &#x27;
                           &#x27;placeholder.replaceFirst(&quot;,&quot;, &quot;&quot;);\n&#x27;
                           &#x27;        sqlTmp = sqlTmp.replace(&quot;${fields}&quot;, &#x27;
                           &#x27;fieldsStr).replace(&quot;${placeholder}&quot;, &#x27;
                           &#x27;placeholder);\n&#x27;
                           &#x27;        this.sql = sqlTmp;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   use MERGE INTO build oracle replace into &#x27;
                           &#x27;sql\n&#x27;
                           &#x27;     * @param tableName\n&#x27;
                           &#x27;     * @param fieldNames   create table contained  &#x27;
                           &#x27;column columns\n&#x27;
                           &#x27;     * @param realIndexes  &lt;key: indexName, value: &#x27;
                           &#x27;index contains columns &gt;\n&#x27;
                           &#x27;     * @param fullField    real columns , query &#x27;
                           &#x27;from db\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public String buildUpdateSql(String scheam, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fieldNames, &#x27;
                           &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, &#x27;
                           &#x27;List&lt;String&gt; fullField) {\n&#x27;
                           &#x27;        tableName = &#x27;
                           &#x27;DtStringUtil.getTableFullPath(scheam, tableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(&quot;MERGE INTO &quot; + tableName + &quot; T1 &#x27;
                           &#x27;USING &quot;\n&#x27;
                           &#x27;                + &quot;(&quot; + makeValues(fieldNames) + &#x27;
                           &#x27;&quot;) T2 ON (&quot;\n&#x27;
                           &#x27;                + updateKeySql(realIndexes) + &quot;) &#x27;
                           &#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String updateSql = &#x27;
                           &#x27;getUpdateSql(fieldNames, fullField, &quot;T1&quot;, &quot;T2&quot;, &#x27;
                           &#x27;keyColList(realIndexes));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(updateSql)) {\n&#x27;
                           &#x27;            sb.append(&quot; WHEN MATCHED THEN UPDATE &#x27;
                           &#x27;SET &quot;);\n&#x27;
                           &#x27;            sb.append(updateSql);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(&quot; WHEN NOT MATCHED THEN &quot;\n&#x27;
                           &#x27;                + &quot;INSERT (&quot; + &#x27;
                           &#x27;quoteColumns(fieldNames) + &quot;) VALUES (&quot;\n&#x27;
                           &#x27;                + quoteColumns(fieldNames, &quot;T2&quot;) + &#x27;
                           &#x27;&quot;)&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String quoteColumns(List&lt;String&gt; &#x27;
                           &#x27;column) {\n&#x27;
                           &#x27;        return quoteColumns(column, null);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String quoteColumns(List&lt;String&gt; &#x27;
                           &#x27;column, String table) {\n&#x27;
                           &#x27;        String prefix = StringUtils.isBlank(table) &#x27;
                           &#x27;? &quot;&quot; : DtStringUtil.addQuoteForStr(table) + &quot;.&quot;;\n&#x27;
                           &#x27;        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (String col : column) {\n&#x27;
                           &#x27;            list.add(prefix + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(list, &quot;,&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  extract all distinct index column\n&#x27;
                           &#x27;     * @param realIndexes\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    protected List&lt;String&gt; keyColList(Map&lt;String, &#x27;
                           &#x27;List&lt;String&gt;&gt; realIndexes) {\n&#x27;
                           &#x27;        List&lt;String&gt; keyCols = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry &#x27;
                           &#x27;: realIndexes.entrySet()) {\n&#x27;
                           &#x27;            List&lt;String&gt; list = entry.getValue();\n&#x27;
                           &#x27;            for (String col : list) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(!containsIgnoreCase(keyCols,col)) {\n&#x27;
                           &#x27;                    keyCols.add(col);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return keyCols;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  build update sql , such as UPDATE SET &#x27;
                           &#x27;&quot;T1&quot;.A=&quot;T2&quot;.A\n&#x27;
                           &#x27;     * @param updateColumn       create table &#x27;
                           &#x27;contained  column columns\n&#x27;
                           &#x27;     * @param fullColumn   real columns , query &#x27;
                           &#x27;from db\n&#x27;
                           &#x27;     * @param leftTable    alias\n&#x27;
                           &#x27;     * @param rightTable   alias\n&#x27;
                           &#x27;     * @param indexCols   index column\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String getUpdateSql(List&lt;String&gt; &#x27;
                           &#x27;updateColumn, List&lt;String&gt; fullColumn, String &#x27;
                           &#x27;leftTable, String rightTable, List&lt;String&gt; &#x27;
                           &#x27;indexCols) {\n&#x27;
                           &#x27;        String prefixLeft = &#x27;
                           &#x27;StringUtils.isBlank(leftTable) ? &quot;&quot; : &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(leftTable) + &quot;.&quot;;\n&#x27;
                           &#x27;        String prefixRight = &#x27;
                           &#x27;StringUtils.isBlank(rightTable) ? &quot;&quot; : &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(rightTable) + &quot;.&quot;;\n&#x27;
                           &#x27;        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (String col : fullColumn) {\n&#x27;
                           &#x27;            // filter index column\n&#x27;
                           &#x27;            if (indexCols == null || &#x27;
                           &#x27;indexCols.size() == 0 || &#x27;
                           &#x27;containsIgnoreCase(indexCols,col)) {\n&#x27;
                           &#x27;                continue;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(containsIgnoreCase(updateColumn,col)) {\n&#x27;
                           &#x27;                list.add(prefixLeft + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=&quot; + &#x27;
                           &#x27;prefixRight + DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                list.add(prefixLeft + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=null&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(list, &quot;,&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  build connect sql by index column, such &#x27;
                           &#x27;as    T1.&quot;A&quot;=T2.&quot;A&quot;\n&#x27;
                           &#x27;     * @param updateKey\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String updateKeySql(Map&lt;String, &#x27;
                           &#x27;List&lt;String&gt;&gt; updateKey) {\n&#x27;
                           &#x27;        List&lt;String&gt; exprList = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry &#x27;
                           &#x27;: updateKey.entrySet()) {\n&#x27;
                           &#x27;            List&lt;String&gt; colList = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;            for (String col : entry.getValue()) {\n&#x27;
                           &#x27;                colList.add(&quot;T1.&quot; + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=T2.&quot; + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            exprList.add(StringUtils.join(colList, &#x27;
                           &#x27;&quot; AND &quot;));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(exprList, &quot; OR &#x27;
                           &#x27;&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   build select sql , such as (SELECT ? &#x27;
                           &#x27;&quot;A&quot;,? &quot;B&quot; FROM DUAL)\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param column   destination column\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String makeValues(List&lt;String&gt; column) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        StringBuilder sb = new &#x27;
                           &#x27;StringBuilder(&quot;SELECT &quot;);\n&#x27;
                           &#x27;        String collect = column.stream()\n&#x27;
                           &#x27;                .map(col -&gt; &#x27;
                           &#x27;wrapperPlaceholder(col) + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col))\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(collect).append(&quot; FROM DUAL&quot;);\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  char type is wrapped with rpad\n&#x27;
                           &#x27;     * @param fieldName\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String wrapperPlaceholder(String &#x27;
                           &#x27;fieldName) {\n&#x27;
                           &#x27;        int pos = &#x27;
                           &#x27;rdbTableInfo.getFieldList().indexOf(fieldName);\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;rdbTableInfo.getFieldTypeList().get(pos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(StringUtils.contains(type.toLowerCase(), &#x27;
                           &#x27;DEAL_CHAR_KEY)) {\n&#x27;
                           &#x27;            TableInfo.FieldExtraInfo &#x27;
                           &#x27;fieldExtraInfo = &#x27;
                           &#x27;rdbTableInfo.getFieldExtraInfoList().get(pos);\n&#x27;
                           &#x27;            int charLength = fieldExtraInfo == &#x27;
                           &#x27;null ? 0 : fieldExtraInfo.getLength();\n&#x27;
                           &#x27;            if (charLength &gt; 0) {\n&#x27;
                           &#x27;                return String.format(RPAD_FORMAT, &#x27;
                           &#x27;charLength);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return SQL_DEFAULT_PLACEHOLDER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsIgnoreCase(List&lt;String&gt; &#x27;
                           &#x27;l, String s) {\n&#x27;
                           &#x27;        Iterator&lt;String&gt; it = l.iterator();\n&#x27;
                           &#x27;        while (it.hasNext()) {\n&#x27;
                           &#x27;            if (it.next().equalsIgnoreCase(s))\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public String makeValues(List&lt;String&gt; column) {\n&#x27;
                           &#x27;        StringBuilder sb = new &#x27;
                           &#x27;StringBuilder(&quot;SELECT &quot;);\n&#x27;
                           &#x27;        String collect = column.stream()\n&#x27;
                           &#x27;                .map(col -&gt; &#x27;
                           &#x27;wrapperPlaceholder(col) + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col))\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(collect).append(&quot; FROM DUAL&quot;);\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;com.dtstack.flink.sql.sink.rdb.format.JDBCUpsertOutputFormat;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.rdb.format.ExtendOutputFormat;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.dtstack.flink.sql.sink.rdb.format.RetractJDBCOutputFormat;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.table.TableInfo;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.util.DtStringUtil;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import com.google.common.collect.Lists;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;import java.util.Arrays;\n&#x27;
                           &#x27;import java.util.Iterator;\n&#x27;
                           &#x27;import java.util.List;\n&#x27;
                           &#x27;import java.util.Map;\n&#x27;
                           &#x27;import java.util.stream.Collectors;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public OracleSink() {\n&#x27;
                         &#x27;        super(new OracleDialect());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private final String SQL_DEFAULT_PLACEHOLDER = &#x27;
                           &#x27;&quot; ? &quot;;\n&#x27;
                           &#x27;    private final String DEAL_CHAR_KEY = &quot;char&quot;;\n&#x27;
                           &#x27;    private String RPAD_FORMAT = &quot; rpad(?, %d, \&#x27; &#x27;
                           &#x27;\&#x27;) &quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public String getDriverName() {\n&#x27;
                           &#x27;        return ORACLE_DRIVER;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void buildSql(String scheam, String &#x27;
                           &#x27;tableName, List&lt;String&gt; fields) {\n&#x27;
                           &#x27;        buildInsertSql(scheam, tableName, &#x27;
                           &#x27;fields);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private void buildInsertSql(String scheam, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fields) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        tableName = &#x27;
                           &#x27;DtStringUtil.getTableFullPath(scheam,tableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String sqlTmp = &quot;insert into &quot; + tableName &#x27;
                           &#x27;+ &quot; (${fields}) values (${placeholder})&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;String&gt; adaptFields = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        fields.forEach(field -&gt; &#x27;
                           &#x27;adaptFields.add(DtStringUtil.addQuoteForStr(field)));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String fieldsStr = &#x27;
                           &#x27;StringUtils.join(adaptFields, &quot;,&quot;);\n&#x27;
                           &#x27;        String placeholder = &quot;&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (String fieldName : fields) {\n&#x27;
                           &#x27;            placeholder += &quot;,?&quot;;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        placeholder = &#x27;
                           &#x27;placeholder.replaceFirst(&quot;,&quot;, &quot;&quot;);\n&#x27;
                           &#x27;        sqlTmp = sqlTmp.replace(&quot;${fields}&quot;, &#x27;
                           &#x27;fieldsStr).replace(&quot;${placeholder}&quot;, &#x27;
                           &#x27;placeholder);\n&#x27;
                           &#x27;        this.sql = sqlTmp;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   use MERGE INTO build oracle replace into &#x27;
                           &#x27;sql\n&#x27;
                           &#x27;     * @param tableName\n&#x27;
                           &#x27;     * @param fieldNames   create table contained  &#x27;
                           &#x27;column columns\n&#x27;
                           &#x27;     * @param realIndexes  &lt;key: indexName, value: &#x27;
                           &#x27;index contains columns &gt;\n&#x27;
                           &#x27;     * @param fullField    real columns , query &#x27;
                           &#x27;from db\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public String buildUpdateSql(String scheam, &#x27;
                           &#x27;String tableName, List&lt;String&gt; fieldNames, &#x27;
                           &#x27;Map&lt;String, List&lt;String&gt;&gt; realIndexes, &#x27;
                           &#x27;List&lt;String&gt; fullField) {\n&#x27;
                           &#x27;        tableName = &#x27;
                           &#x27;DtStringUtil.getTableFullPath(scheam, tableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        StringBuilder sb = new StringBuilder();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(&quot;MERGE INTO &quot; + tableName + &quot; T1 &#x27;
                           &#x27;USING &quot;\n&#x27;
                           &#x27;                + &quot;(&quot; + makeValues(fieldNames) + &#x27;
                           &#x27;&quot;) T2 ON (&quot;\n&#x27;
                           &#x27;                + updateKeySql(realIndexes) + &quot;) &#x27;
                           &#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String updateSql = &#x27;
                           &#x27;getUpdateSql(fieldNames, fullField, &quot;T1&quot;, &quot;T2&quot;, &#x27;
                           &#x27;keyColList(realIndexes));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (StringUtils.isNotEmpty(updateSql)) {\n&#x27;
                           &#x27;            sb.append(&quot; WHEN MATCHED THEN UPDATE &#x27;
                           &#x27;SET &quot;);\n&#x27;
                           &#x27;            sb.append(updateSql);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(&quot; WHEN NOT MATCHED THEN &quot;\n&#x27;
                           &#x27;                + &quot;INSERT (&quot; + &#x27;
                           &#x27;quoteColumns(fieldNames) + &quot;) VALUES (&quot;\n&#x27;
                           &#x27;                + quoteColumns(fieldNames, &quot;T2&quot;) + &#x27;
                           &#x27;&quot;)&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String quoteColumns(List&lt;String&gt; &#x27;
                           &#x27;column) {\n&#x27;
                           &#x27;        return quoteColumns(column, null);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public String quoteColumns(List&lt;String&gt; &#x27;
                           &#x27;column, String table) {\n&#x27;
                           &#x27;        String prefix = StringUtils.isBlank(table) &#x27;
                           &#x27;? &quot;&quot; : DtStringUtil.addQuoteForStr(table) + &quot;.&quot;;\n&#x27;
                           &#x27;        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (String col : column) {\n&#x27;
                           &#x27;            list.add(prefix + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(list, &quot;,&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  extract all distinct index column\n&#x27;
                           &#x27;     * @param realIndexes\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    protected List&lt;String&gt; keyColList(Map&lt;String, &#x27;
                           &#x27;List&lt;String&gt;&gt; realIndexes) {\n&#x27;
                           &#x27;        List&lt;String&gt; keyCols = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry &#x27;
                           &#x27;: realIndexes.entrySet()) {\n&#x27;
                           &#x27;            List&lt;String&gt; list = entry.getValue();\n&#x27;
                           &#x27;            for (String col : list) {\n&#x27;
                           &#x27;                if &#x27;
                           &#x27;(!containsIgnoreCase(keyCols,col)) {\n&#x27;
                           &#x27;                    keyCols.add(col);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return keyCols;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  build update sql , such as UPDATE SET &#x27;
                           &#x27;&quot;T1&quot;.A=&quot;T2&quot;.A\n&#x27;
                           &#x27;     * @param updateColumn       create table &#x27;
                           &#x27;contained  column columns\n&#x27;
                           &#x27;     * @param fullColumn   real columns , query &#x27;
                           &#x27;from db\n&#x27;
                           &#x27;     * @param leftTable    alias\n&#x27;
                           &#x27;     * @param rightTable   alias\n&#x27;
                           &#x27;     * @param indexCols   index column\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String getUpdateSql(List&lt;String&gt; &#x27;
                           &#x27;updateColumn, List&lt;String&gt; fullColumn, String &#x27;
                           &#x27;leftTable, String rightTable, List&lt;String&gt; &#x27;
                           &#x27;indexCols) {\n&#x27;
                           &#x27;        String prefixLeft = &#x27;
                           &#x27;StringUtils.isBlank(leftTable) ? &quot;&quot; : &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(leftTable) + &quot;.&quot;;\n&#x27;
                           &#x27;        String prefixRight = &#x27;
                           &#x27;StringUtils.isBlank(rightTable) ? &quot;&quot; : &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(rightTable) + &quot;.&quot;;\n&#x27;
                           &#x27;        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (String col : fullColumn) {\n&#x27;
                           &#x27;            // filter index column\n&#x27;
                           &#x27;            if (indexCols == null || &#x27;
                           &#x27;indexCols.size() == 0 || &#x27;
                           &#x27;containsIgnoreCase(indexCols,col)) {\n&#x27;
                           &#x27;                continue;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(containsIgnoreCase(updateColumn,col)) {\n&#x27;
                           &#x27;                list.add(prefixLeft + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=&quot; + &#x27;
                           &#x27;prefixRight + DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                list.add(prefixLeft + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=null&quot;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(list, &quot;,&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  build connect sql by index column, such &#x27;
                           &#x27;as    T1.&quot;A&quot;=T2.&quot;A&quot;\n&#x27;
                           &#x27;     * @param updateKey\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String updateKeySql(Map&lt;String, &#x27;
                           &#x27;List&lt;String&gt;&gt; updateKey) {\n&#x27;
                           &#x27;        List&lt;String&gt; exprList = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry &#x27;
                           &#x27;: updateKey.entrySet()) {\n&#x27;
                           &#x27;            List&lt;String&gt; colList = new &#x27;
                           &#x27;ArrayList&lt;&gt;();\n&#x27;
                           &#x27;            for (String col : entry.getValue()) {\n&#x27;
                           &#x27;                colList.add(&quot;T1.&quot; + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col) + &quot;=T2.&quot; + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            exprList.add(StringUtils.join(colList, &#x27;
                           &#x27;&quot; AND &quot;));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return StringUtils.join(exprList, &quot; OR &#x27;
                           &#x27;&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *   build select sql , such as (SELECT ? &#x27;
                           &#x27;&quot;A&quot;,? &quot;B&quot; FROM DUAL)\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param column   destination column\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String makeValues(List&lt;String&gt; column) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        StringBuilder sb = new &#x27;
                           &#x27;StringBuilder(&quot;SELECT &quot;);\n&#x27;
                           &#x27;        String collect = column.stream()\n&#x27;
                           &#x27;                .map(col -&gt; &#x27;
                           &#x27;wrapperPlaceholder(col) + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col))\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(collect).append(&quot; FROM DUAL&quot;);\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     *  char type is wrapped with rpad\n&#x27;
                           &#x27;     * @param fieldName\n&#x27;
                           &#x27;     * @return\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public String wrapperPlaceholder(String &#x27;
                           &#x27;fieldName) {\n&#x27;
                           &#x27;        int pos = &#x27;
                           &#x27;rdbTableInfo.getFieldList().indexOf(fieldName);\n&#x27;
                           &#x27;        String type = &#x27;
                           &#x27;rdbTableInfo.getFieldTypeList().get(pos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(StringUtils.contains(type.toLowerCase(), &#x27;
                           &#x27;DEAL_CHAR_KEY)) {\n&#x27;
                           &#x27;            TableInfo.FieldExtraInfo &#x27;
                           &#x27;fieldExtraInfo = &#x27;
                           &#x27;rdbTableInfo.getFieldExtraInfoList().get(pos);\n&#x27;
                           &#x27;            int charLength = fieldExtraInfo == &#x27;
                           &#x27;null ? 0 : fieldExtraInfo.getLength();\n&#x27;
                           &#x27;            if (charLength &gt; 0) {\n&#x27;
                           &#x27;                return String.format(RPAD_FORMAT, &#x27;
                           &#x27;charLength);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return SQL_DEFAULT_PLACEHOLDER;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public boolean containsIgnoreCase(List&lt;String&gt; &#x27;
                           &#x27;l, String s) {\n&#x27;
                           &#x27;        Iterator&lt;String&gt; it = l.iterator();\n&#x27;
                           &#x27;        while (it.hasNext()) {\n&#x27;
                           &#x27;            if (it.next().equalsIgnoreCase(s))\n&#x27;
                           &#x27;                return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public String makeValues(List&lt;String&gt; column) {\n&#x27;
                           &#x27;        StringBuilder sb = new &#x27;
                           &#x27;StringBuilder(&quot;SELECT &quot;);\n&#x27;
                           &#x27;        String collect = column.stream()\n&#x27;
                           &#x27;                .map(col -&gt; &#x27;
                           &#x27;wrapperPlaceholder(col) + &#x27;
                           &#x27;DtStringUtil.addQuoteForStr(col))\n&#x27;
                           &#x27;                .collect(Collectors.joining(&quot;, &#x27;
                           &#x27;&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        sb.append(collect).append(&quot; FROM DUAL&quot;);\n&#x27;
                           &#x27;        return sb.toString();\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        