<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>266</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    266
                    <a href="265.html">prev</a>
                    <a href="267.html">next</a>
                    <a href="266_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_8f73d7032e557c6f01a9954a2ec0f386987946e4_src/com/android/launcher3/Utilities.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8f73d7032e557c6f01a9954a2ec0f386987946e4:src/com/android/launcher3/Utilities.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8f73d7032e557c6f01a9954a2ec0f386987946e4^1:src/com/android/launcher3/Utilities.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;8f73d7032e557c6f01a9954a2ec0f386987946e4^2:src/com/android/launcher3/Utilities.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;a6095969bb5938ad95ee9f858970d5eb54eb124d:src/com/android/launcher3/Utilities.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.annotation.TargetApi;
  20 import android.app.Activity;
  21 import android.app.SearchManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ActivityNotFoundException;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.pm.ApplicationInfo;
  29 import android.content.pm.PackageInfo;
  30 import android.content.pm.PackageManager;
  31 import android.content.pm.PackageManager.NameNotFoundException;
  32 import android.content.pm.ResolveInfo;
  33 import android.content.res.Resources;
  34 import android.database.Cursor;
  35 import android.graphics.Bitmap;
  36 import android.graphics.BitmapFactory;
  37 import android.graphics.Canvas;
  38 import android.graphics.Color;
  39 import android.graphics.Matrix;
  40 import android.graphics.Paint;
  41 import android.graphics.PaintFlagsDrawFilter;
  42 import android.graphics.Rect;
  43 import android.graphics.drawable.BitmapDrawable;
  44 import android.graphics.drawable.Drawable;
  45 import android.graphics.drawable.PaintDrawable;
  46 import android.os.Build;
  47 import android.os.Process;
  48 import android.text.TextUtils;
  49 import android.util.DisplayMetrics;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import android.util.SparseArray;
  53 import android.util.TypedValue;
  54 import android.view.View;
  55 import android.widget.Toast;
  56 
  57 import junit.framework.Assert;
  58 
  59 import java.io.ByteArrayOutputStream;
  60 import java.io.IOException;
  61 import java.util.ArrayList;
  62 import java.util.Comparator;
  63 import java.util.regex.Matcher;
  64 import java.util.regex.Pattern;
  65 
  66 /**
  67  * Various utilities shared amongst the Launcher&#x27;s classes.
  68  */
  69 public final class Utilities {
  70     private static final String TAG = &quot;Launcher.Utilities&quot;;
  71 
  72     private static int sIconWidth = -1;
  73     private static int sIconHeight = -1;
  74 
  75     private static final Rect sOldBounds = new Rect();
  76     private static final Canvas sCanvas = new Canvas();
  77 
  78     private static final Pattern sTrimPattern =
  79             Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);
  80 
  81     static {
  82         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  83                 Paint.FILTER_BITMAP_FLAG));
  84     }
  85     static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  86     static int sColorIndex = 0;
  87 
  88     static int[] sLoc0 = new int[2];
  89     static int[] sLoc1 = new int[2];
  90 
  91     // To turn on these properties, type
  92     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  93     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  94     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  95 
  96     /**
  97      * Returns a FastBitmapDrawable with the icon, accurately sized.
  98      */
  99     public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
 100         FastBitmapDrawable d = new FastBitmapDrawable(icon);
 101         d.setFilterBitmap(true);
 102         resizeIconDrawable(d);
 103         return d;
 104     }
 105 
 106     /**
 107      * Resizes an icon drawable to the correct icon size.
 108      */
 109     static void resizeIconDrawable(Drawable icon) {
 110         icon.setBounds(0, 0, sIconWidth, sIconHeight);
 111     }
 112 
 113     public static boolean isPropertyEnabled(String propertyName) {
 114         return Log.isLoggable(propertyName, Log.VERBOSE);
 115     }
 116 
 117     public static boolean isRotationEnabled(Context c) {
 118         boolean enableRotation = sForceEnableRotation ||
 119                 c.getResources().getBoolean(R.bool.allow_rotation);
 120         return enableRotation;
 121     }
 122 
 123     /**
 124      * Indicates if the device is running LMP or higher.
 125      */
 126     public static boolean isLmpOrAbove() {
 127         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 128     }
 129 
 130 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 131     static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 132         byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 133         try {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 134             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 135         } catch (Exception e) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 136             return null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 137         }</span>
 138 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140      * Returns a bitmap suitable for the all apps view. If the package or the resource do not</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141      * exist, it returns null.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143     static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144             Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 145         PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 146         // the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 147         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 148             Resources resources = packageManager.getResourcesForApplication(packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 149             if (resources != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150                 final int id = resources.getIdentifier(resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151                 return createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152                         resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 153             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 154         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 155             // Icon not found.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 156         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 157         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 158     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 159 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 160     /**</span>
 161 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162     public static boolean isLmpMr1() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163         return Build.VERSION.SDK_INT == 22;</span>
 164 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 165     }
 166 
 167     /**
 168      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 169      * exist, it returns null.
 170      */
 171     static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,
 172             Context context) {
 173         PackageManager packageManager = context.getPackageManager();
 174         // the resource
 175         try {
 176             Resources resources = packageManager.getResourcesForApplication(packageName);
 177             if (resources != null) {
 178                 final int id = resources.getIdentifier(resourceName, null, null);
 179                 return createIconBitmap(
 180                         resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);
 181             }
 182         } catch (Exception e) {
 183             // Icon not found.
 184         }
 185         return null;
 186     }
 187 
 188     /**
 189      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 190      */
 191     static Bitmap createIconBitmap(Bitmap icon, Context context) {
 192         synchronized (sCanvas) { // we share the statics :-(
 193             if (sIconWidth == -1) {
 194                 initStatics(context);
 195             }
 196         }
 197         if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {
 198             return icon;
 199         }
 200         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 201     }
 202 
 203     /**
 204      * Returns a bitmap suitable for the all apps view.
 205      */
 206     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 207         synchronized (sCanvas) { // we share the statics :-(
 208             if (sIconWidth == -1) {
 209                 initStatics(context);
 210             }
 211 
 212             int width = sIconWidth;
 213             int height = sIconHeight;
 214 
 215             if (icon instanceof PaintDrawable) {
 216                 PaintDrawable painter = (PaintDrawable) icon;
 217                 painter.setIntrinsicWidth(width);
 218                 painter.setIntrinsicHeight(height);
 219             } else if (icon instanceof BitmapDrawable) {
 220                 // Ensure the bitmap has a density.
 221                 BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 222                 Bitmap bitmap = bitmapDrawable.getBitmap();
 223                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 224                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 225                 }
 226             }
 227             int sourceWidth = icon.getIntrinsicWidth();
 228             int sourceHeight = icon.getIntrinsicHeight();
 229             if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 230                 // Scale the icon proportionally to the icon dimensions
 231                 final float ratio = (float) sourceWidth / sourceHeight;
 232                 if (sourceWidth &gt; sourceHeight) {
 233                     height = (int) (width / ratio);
 234                 } else if (sourceHeight &gt; sourceWidth) {
 235                     width = (int) (height * ratio);
 236                 }
 237             }
 238 
 239             // no intrinsic size --&gt; use default size
 240             int textureWidth = sIconWidth;
 241             int textureHeight = sIconHeight;
 242 
 243             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 244                     Bitmap.Config.ARGB_8888);
 245             final Canvas canvas = sCanvas;
 246             canvas.setBitmap(bitmap);
 247 
 248             final int left = (textureWidth-width) / 2;
 249             final int top = (textureHeight-height) / 2;
 250 
 251             @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 252             final boolean debug = false;
 253             if (debug) {
 254                 // draw a big box for the icon for debugging
 255                 canvas.drawColor(sColors[sColorIndex]);
 256                 if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 257                 Paint debugPaint = new Paint();
 258                 debugPaint.setColor(0xffcccc00);
 259                 canvas.drawRect(left, top, left+width, top+height, debugPaint);
 260             }
 261 
 262             sOldBounds.set(icon.getBounds());
 263             icon.setBounds(left, top, left+width, top+height);
 264             icon.draw(canvas);
 265             icon.setBounds(sOldBounds);
 266             canvas.setBitmap(null);
 267 
 268             return bitmap;
 269         }
 270     }
 271 
 272     /**
 273      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 274      * coordinates.
 275      *
 276      * @param descendant The descendant to which the passed coordinate is relative.
 277      * @param root The root view to make the coordinates relative to.
 278      * @param coord The coordinate that we want mapped.
 279      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 280      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 281      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 282      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 283      *         assumption fails, we will need to return a pair of scale factors.
 284      */
 285     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 286                                                            int[] coord, boolean includeRootScroll) {
 287         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 288 
 289         float[] pt = {coord[0], coord[1]};
 290 
 291         View v = descendant;
 292         while(v != root &amp;&amp; v != null) {
 293             ancestorChain.add(v);
 294             v = (View) v.getParent();
 295         }
 296         ancestorChain.add(root);
 297 
 298         float scale = 1.0f;
 299         int count = ancestorChain.size();
 300         for (int i = 0; i &lt; count; i++) {
 301             View v0 = ancestorChain.get(i);
 302             // For TextViews, scroll has a meaning which relates to the text position
 303             // which is very strange... ignore the scroll.
 304             if (v0 != descendant || includeRootScroll) {
 305                 pt[0] -= v0.getScrollX();
 306                 pt[1] -= v0.getScrollY();
 307             }
 308 
 309             v0.getMatrix().mapPoints(pt);
 310             pt[0] += v0.getLeft();
 311             pt[1] += v0.getTop();
 312             scale *= v0.getScaleX();
 313         }
 314 
 315         coord[0] = (int) Math.round(pt[0]);
 316         coord[1] = (int) Math.round(pt[1]);
 317         return scale;
 318     }
 319 
 320     /**
 321      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 322      */
 323     public static float mapCoordInSelfToDescendent(View descendant, View root,
 324                                                    int[] coord) {
 325         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 326 
 327         float[] pt = {coord[0], coord[1]};
 328 
 329         View v = descendant;
 330         while(v != root) {
 331             ancestorChain.add(v);
 332             v = (View) v.getParent();
 333         }
 334         ancestorChain.add(root);
 335 
 336         float scale = 1.0f;
 337         Matrix inverse = new Matrix();
 338         int count = ancestorChain.size();
 339         for (int i = count - 1; i &gt;= 0; i--) {
 340             View ancestor = ancestorChain.get(i);
 341             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 342 
 343             pt[0] += ancestor.getScrollX();
 344             pt[1] += ancestor.getScrollY();
 345 
 346             if (next != null) {
 347                 pt[0] -= next.getLeft();
 348                 pt[1] -= next.getTop();
 349                 next.getMatrix().invert(inverse);
 350                 inverse.mapPoints(pt);
 351                 scale *= next.getScaleX();
 352             }
 353         }
 354 
 355         coord[0] = (int) Math.round(pt[0]);
 356         coord[1] = (int) Math.round(pt[1]);
 357         return scale;
 358     }
 359 
 360     /**
 361      * Utility method to determine whether the given point, in local coordinates,
 362      * is inside the view, where the area of the view is expanded by the slop factor.
 363      * This method is called while processing touch-move events to determine if the event
 364      * is still within the view.
 365      */
 366     public static boolean pointInView(View v, float localX, float localY, float slop) {
 367         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 368                 localY &lt; (v.getHeight() + slop);
 369     }
 370 
 371     private static void initStatics(Context context) {
 372         final Resources resources = context.getResources();
 373         sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 374     }
 375 
 376     public static void setIconSize(int widthPx) {
 377         sIconWidth = sIconHeight = widthPx;
 378     }
 379 
 380     public static void scaleRect(Rect r, float scale) {
 381         if (scale != 1.0f) {
 382             r.left = (int) (r.left * scale + 0.5f);
 383             r.top = (int) (r.top * scale + 0.5f);
 384             r.right = (int) (r.right * scale + 0.5f);
 385             r.bottom = (int) (r.bottom * scale + 0.5f);
 386         }
 387     }
 388 
 389     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 390         v0.getLocationInWindow(sLoc0);
 391         v1.getLocationInWindow(sLoc1);
 392 
 393         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 394         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 395         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 396         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 397 
 398         if (delta == null) {
 399             delta = new int[2];
 400         }
 401 
 402         delta[0] = sLoc1[0] - sLoc0[0];
 403         delta[1] = sLoc1[1] - sLoc0[1];
 404 
 405         return delta;
 406     }
 407 
 408     public static void scaleRectAboutCenter(Rect r, float scale) {
 409         int cx = r.centerX();
 410         int cy = r.centerY();
 411         r.offset(-cx, -cy);
 412         Utilities.scaleRect(r, scale);
 413         r.offset(cx, cy);
 414     }
 415 
 416     public static void startActivityForResultSafely(
 417             Activity activity, Intent intent, int requestCode) {
 418         try {
 419             activity.startActivityForResult(intent, requestCode);
 420         } catch (ActivityNotFoundException e) {
 421             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 422         } catch (SecurityException e) {
 423             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 424             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 425                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 426                     &quot;or use the exported attribute for this activity.&quot;, e);
 427         }
 428     }
 429 
 430     static boolean isSystemApp(Context context, Intent intent) {
 431         PackageManager pm = context.getPackageManager();
 432         ComponentName cn = intent.getComponent();
 433         String packageName = null;
 434         if (cn == null) {
 435             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 436             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 437                 packageName = info.activityInfo.packageName;
 438             }
 439         } else {
 440             packageName = cn.getPackageName();
 441         }
 442         if (packageName != null) {
 443             try {
 444                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 445                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 446                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 447             } catch (NameNotFoundException e) {
 448                 return false;
 449             }
 450         } else {
 451             return false;
 452         }
 453     }
 454 
 455     /**
 456      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 457      * @param bitmap The bitmap to scan
 458      * @param samples The approximate max number of samples to use.
 459      */
 460     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 461         final int height = bitmap.getHeight();
 462         final int width = bitmap.getWidth();
 463         int sampleStride = (int) Math.sqrt((height * width) / samples);
 464         if (sampleStride &lt; 1) {
 465             sampleStride = 1;
 466         }
 467 
 468         // This is an out-param, for getting the hsv values for an rgb
 469         float[] hsv = new float[3];
 470 
 471         // First get the best hue, by creating a histogram over 360 hue buckets,
 472         // where each pixel contributes a score weighted by saturation, value, and alpha.
 473         float[] hueScoreHistogram = new float[360];
 474         float highScore = -1;
 475         int bestHue = -1;
 476 
 477         for (int y = 0; y &lt; height; y += sampleStride) {
 478             for (int x = 0; x &lt; width; x += sampleStride) {
 479                 int argb = bitmap.getPixel(x, y);
 480                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 481                 if (alpha &lt; 0x80) {
 482                     // Drop mostly-transparent pixels.
 483                     continue;
 484                 }
 485                 // Remove the alpha channel.
 486                 int rgb = argb | 0xFF000000;
 487                 Color.colorToHSV(rgb, hsv);
 488                 // Bucket colors by the 360 integer hues.
 489                 int hue = (int) hsv[0];
 490                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 491                     // Defensively avoid array bounds violations.
 492                     continue;
 493                 }
 494                 float score = hsv[1] * hsv[2];
 495                 hueScoreHistogram[hue] += score;
 496                 if (hueScoreHistogram[hue] &gt; highScore) {
 497                     highScore = hueScoreHistogram[hue];
 498                     bestHue = hue;
 499                 }
 500             }
 501         }
 502 
 503         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 504         int bestColor = 0xff000000;
 505         highScore = -1;
 506         // Go back over the RGB colors that match the winning hue,
 507         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 508         // The highest-scoring RGB color wins.
 509         for (int y = 0; y &lt; height; y += sampleStride) {
 510             for (int x = 0; x &lt; width; x += sampleStride) {
 511                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 512                 Color.colorToHSV(rgb, hsv);
 513                 int hue = (int) hsv[0];
 514                 if (hue == bestHue) {
 515                     float s = hsv[1];
 516                     float v = hsv[2];
 517                     int bucket = (int) (s * 100) + (int) (v * 10000);
 518                     // Score by cumulative saturation * value.
 519                     float score = s * v;
 520                     Float oldTotal = rgbScores.get(bucket);
 521                     float newTotal = oldTotal == null ? score : oldTotal + score;
 522                     rgbScores.put(bucket, newTotal);
 523                     if (newTotal &gt; highScore) {
 524                         highScore = newTotal;
 525                         // All the colors in the winning bucket are very similar. Last in wins.
 526                         bestColor = rgb;
 527                     }
 528                 }
 529             }
 530         }
 531         return bestColor;
 532     }
 533 
 534     /*
 535      * Finds a system apk which had a broadcast receiver listening to a particular action.
 536      * @param action intent action used to find the apk
 537      * @return a pair of apk package name and the resources.
 538      */
 539     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 540         final Intent intent = new Intent(action);
 541         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 542             if (info.activityInfo != null &amp;&amp;
 543                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 544                 final String packageName = info.activityInfo.packageName;
 545                 try {
 546                     final Resources res = pm.getResourcesForApplication(packageName);
 547                     return Pair.create(packageName, res);
 548                 } catch (NameNotFoundException e) {
 549                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 550                 }
 551             }
 552         }
 553         return null;
 554     }
 555 
 556     @TargetApi(Build.VERSION_CODES.KITKAT)
 557     public static boolean isViewAttachedToWindow(View v) {
 558         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 559             return v.isAttachedToWindow();
 560         } else {
 561             // A proxy call which returns null, if the view is not attached to the window.
 562             return v.getKeyDispatcherState() != null;
 563         }
 564     }
 565 
 566     /**
 567      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 568      * provided by the same package which is set to be global search activity.
 569      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 570      * provided by the package.
 571      */
 572     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 573     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 574         SearchManager searchManager =
 575                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 576         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 577         if (searchComponent == null) return null;
 578         String providerPkg = searchComponent.getPackageName();
 579 
 580         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 581 
 582         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 583         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 584             if (info.provider.getPackageName().equals(providerPkg)) {
 585                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 586                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 587                         return info;
 588                     } else if (defaultWidgetForSearchPackage == null) {
 589                         defaultWidgetForSearchPackage = info;
 590                     }
 591                 } else {
 592                     return info;
 593                 }
 594             }
 595         }
 596         return defaultWidgetForSearchPackage;
 597     }
 598 
 599     /**
 600      * Compresses the bitmap to a byte array for serialization.
 601      */
 602     public static byte[] flattenBitmap(Bitmap bitmap) {
 603         // Try go guesstimate how much space the icon will take when serialized
 604         // to avoid unnecessary allocations/copies during the write.
 605         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 606         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 607         try {
 608             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 609             out.flush();
 610             out.close();
 611             return out.toByteArray();
 612         } catch (IOException e) {
 613             Log.w(TAG, &quot;Could not write bitmap&quot;);
 614             return null;
 615         }
 616     }
 617 
 618     public static final Comparator&lt;ItemInfo&gt; RANK_COMPARATOR = new Comparator&lt;ItemInfo&gt;() {
 619 
 620         @Override
 621         public int compare(ItemInfo lhs, ItemInfo rhs) {
 622             return lhs.rank - rhs.rank;
 623         }
 624     };
 625 
 626     /**
 627      * Find the first vacant cell, if there is one.
 628      *
 629      * @param vacant Holds the x and y coordinate of the vacant cell
 630      * @param spanX Horizontal cell span.
 631      * @param spanY Vertical cell span.
 632      *
 633      * @return true if a vacant cell was found
 634      */
 635     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 636             int xCount, int yCount, boolean[][] occupied) {
 637 
 638         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 639             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 640                 boolean available = !occupied[x][y];
 641                 out:            for (int i = x; i &lt; x + spanX; i++) {
 642                     for (int j = y; j &lt; y + spanY; j++) {
 643                         available = available &amp;&amp; !occupied[i][j];
 644                         if (!available) break out;
 645                     }
 646                 }
 647 
 648                 if (available) {
 649                     vacant[0] = x;
 650                     vacant[1] = y;
 651                     return true;
 652                 }
 653             }
 654         }
 655 
 656         return false;
 657     }
 658 
 659     /**
 660      * Trims the string, removing all whitespace at the beginning and end of the string.
 661      * Non-breaking whitespaces are also removed.
 662      */
 663     public static String trim(CharSequence s) {
 664         if (s == null) {
 665             return null;
 666         }
 667 
 668         // Just strip any sequence of whitespace or java space characters from the beginning and end
 669         Matcher m = sTrimPattern.matcher(s);
 670         return m.replaceAll(&quot;$1&quot;);
 671     }
 672 
 673     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 674     public static boolean isRtl(Resources res) {
 675         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 676                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 677     }
 678 
 679     public static void assertWorkerThread() {
 680         if (LauncherAppState.isDogfoodBuild()) {
 681             Assert.assertTrue(LauncherModel.sWorkerThread.getThreadId() == Process.myTid());
 682         }
 683     }
 684 
 685     /**
 686      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 687      * This is used to identify shortcuts which are different from the ones exposed by the
 688      * applications&#x27; manifest file.
 689      *
 690      * @param launchIntent The intent that will be launched when the shortcut is clicked.
 691      */
 692     public static boolean isLauncherAppTarget(Intent launchIntent) {
 693         return launchIntent != null
 694                 &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())
 695                 &amp;&amp; launchIntent.getComponent() != null
 696                 &amp;&amp; launchIntent.getCategories() != null
 697                 &amp;&amp; launchIntent.getCategories().size() == 1
 698                 &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)
 699                 &amp;&amp; launchIntent.getExtras() == null
 700                 &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString());
 701     }
 702 
 703     public static float dpiFromPx(int size, DisplayMetrics metrics){
 704         float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;
 705         return (size / densityRatio);
 706     }
 707     public static int pxFromDp(float size, DisplayMetrics metrics) {
 708         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
 709                 size, metrics));
 710     }
 711     public static int pxFromSp(float size, DisplayMetrics metrics) {
 712         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
 713                 size, metrics));
 714     }
 715 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.annotation.TargetApi;
  20 import android.app.Activity;
  21 import android.app.SearchManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ActivityNotFoundException;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.pm.ApplicationInfo;
  29 import android.content.pm.PackageInfo;
  30 import android.content.pm.PackageManager;
  31 import android.content.pm.PackageManager.NameNotFoundException;
  32 import android.content.pm.ResolveInfo;
  33 import android.content.res.Resources;
  34 import android.database.Cursor;
  35 import android.graphics.Bitmap;
  36 import android.graphics.BitmapFactory;
  37 import android.graphics.Canvas;
  38 import android.graphics.Color;
  39 import android.graphics.Matrix;
  40 import android.graphics.Paint;
  41 import android.graphics.PaintFlagsDrawFilter;
  42 import android.graphics.Rect;
  43 import android.graphics.drawable.BitmapDrawable;
  44 import android.graphics.drawable.Drawable;
  45 import android.graphics.drawable.PaintDrawable;
  46 import android.os.Build;
  47 import android.os.Process;
  48 import android.text.TextUtils;
  49 import android.util.DisplayMetrics;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import android.util.SparseArray;
  53 import android.util.TypedValue;
  54 import android.view.View;
  55 import android.widget.Toast;
  56 
  57 import junit.framework.Assert;
  58 
  59 import java.io.ByteArrayOutputStream;
  60 import java.io.IOException;
  61 import java.util.ArrayList;
  62 import java.util.Comparator;
  63 import java.util.regex.Matcher;
  64 import java.util.regex.Pattern;
  65 
  66 /**
  67  * Various utilities shared amongst the Launcher&#x27;s classes.
  68  */
  69 public final class Utilities {
  70     private static final String TAG = &quot;Launcher.Utilities&quot;;
  71 
  72     private static int sIconWidth = -1;
  73     private static int sIconHeight = -1;
  74 
  75     private static final Rect sOldBounds = new Rect();
  76     private static final Canvas sCanvas = new Canvas();
  77 
  78     private static final Pattern sTrimPattern =
  79             Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);
  80 
  81     static {
  82         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  83                 Paint.FILTER_BITMAP_FLAG));
  84     }
  85     static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  86     static int sColorIndex = 0;
  87 
  88     static int[] sLoc0 = new int[2];
  89     static int[] sLoc1 = new int[2];
  90 
  91     // To turn on these properties, type
  92     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  93     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  94     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  95 
  96     /**
  97      * Returns a FastBitmapDrawable with the icon, accurately sized.
  98      */
  99     public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
 100         FastBitmapDrawable d = new FastBitmapDrawable(icon);
 101         d.setFilterBitmap(true);
 102         resizeIconDrawable(d);
 103         return d;
 104     }
 105 
 106     /**
 107      * Resizes an icon drawable to the correct icon size.
 108      */
 109     static void resizeIconDrawable(Drawable icon) {
 110         icon.setBounds(0, 0, sIconWidth, sIconHeight);
 111     }
 112 
 113     public static boolean isPropertyEnabled(String propertyName) {
 114         return Log.isLoggable(propertyName, Log.VERBOSE);
 115     }
 116 
 117     public static boolean isRotationEnabled(Context c) {
 118         boolean enableRotation = sForceEnableRotation ||
 119                 c.getResources().getBoolean(R.bool.allow_rotation);
 120         return enableRotation;
 121     }
 122 
 123     /**
 124      * Indicates if the device is running LMP or higher.
 125      */
 126     public static boolean isLmpOrAbove() {
 127         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 128     }
 129 
 130     static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {
 131         byte[] data = c.getBlob(iconIndex);
 132         try {
 133             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);
 134         } catch (Exception e) {
 135             return null;
 136         }
 137     }
 138 
 139     public static boolean isLmpMr1() {
 140         return Build.VERSION.SDK_INT == 22;
 141     }
 142 
 143     /**
 144      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 145      * exist, it returns null.
 146      */
 147     static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,
 148             Context context) {
 149         PackageManager packageManager = context.getPackageManager();
 150         // the resource
 151         try {
 152             Resources resources = packageManager.getResourcesForApplication(packageName);
 153             if (resources != null) {
 154                 final int id = resources.getIdentifier(resourceName, null, null);
 155                 return createIconBitmap(
 156                         resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);
 157             }
 158         } catch (Exception e) {
 159             // Icon not found.
 160         }
 161         return null;
 162     }
 163 
 164     /**
 165      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 166      */
 167     static Bitmap createIconBitmap(Bitmap icon, Context context) {
 168         synchronized (sCanvas) { // we share the statics :-(
 169             if (sIconWidth == -1) {
 170                 initStatics(context);
 171             }
 172         }
 173         if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {
 174             return icon;
 175         }
 176         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 177     }
 178 
 179     /**
 180      * Returns a bitmap suitable for the all apps view.
 181      */
 182     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 183         synchronized (sCanvas) { // we share the statics :-(
 184             if (sIconWidth == -1) {
 185                 initStatics(context);
 186             }
 187 
 188             int width = sIconWidth;
 189             int height = sIconHeight;
 190 
 191             if (icon instanceof PaintDrawable) {
 192                 PaintDrawable painter = (PaintDrawable) icon;
 193                 painter.setIntrinsicWidth(width);
 194                 painter.setIntrinsicHeight(height);
 195             } else if (icon instanceof BitmapDrawable) {
 196                 // Ensure the bitmap has a density.
 197                 BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 198                 Bitmap bitmap = bitmapDrawable.getBitmap();
 199                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 200                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 201                 }
 202             }
 203             int sourceWidth = icon.getIntrinsicWidth();
 204             int sourceHeight = icon.getIntrinsicHeight();
 205             if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 206                 // Scale the icon proportionally to the icon dimensions
 207                 final float ratio = (float) sourceWidth / sourceHeight;
 208                 if (sourceWidth &gt; sourceHeight) {
 209                     height = (int) (width / ratio);
 210                 } else if (sourceHeight &gt; sourceWidth) {
 211                     width = (int) (height * ratio);
 212                 }
 213             }
 214 
 215             // no intrinsic size --&gt; use default size
 216             int textureWidth = sIconWidth;
 217             int textureHeight = sIconHeight;
 218 
 219             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 220                     Bitmap.Config.ARGB_8888);
 221             final Canvas canvas = sCanvas;
 222             canvas.setBitmap(bitmap);
 223 
 224             final int left = (textureWidth-width) / 2;
 225             final int top = (textureHeight-height) / 2;
 226 
 227             @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 228             final boolean debug = false;
 229             if (debug) {
 230                 // draw a big box for the icon for debugging
 231                 canvas.drawColor(sColors[sColorIndex]);
 232                 if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 233                 Paint debugPaint = new Paint();
 234                 debugPaint.setColor(0xffcccc00);
 235                 canvas.drawRect(left, top, left+width, top+height, debugPaint);
 236             }
 237 
 238             sOldBounds.set(icon.getBounds());
 239             icon.setBounds(left, top, left+width, top+height);
 240             icon.draw(canvas);
 241             icon.setBounds(sOldBounds);
 242             canvas.setBitmap(null);
 243 
 244             return bitmap;
 245         }
 246     }
 247 
 248     /**
 249      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 250      * coordinates.
 251      *
 252      * @param descendant The descendant to which the passed coordinate is relative.
 253      * @param root The root view to make the coordinates relative to.
 254      * @param coord The coordinate that we want mapped.
 255      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 256      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 257      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 258      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 259      *         assumption fails, we will need to return a pair of scale factors.
 260      */
 261     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 262                                                            int[] coord, boolean includeRootScroll) {
 263         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 264 
 265         float[] pt = {coord[0], coord[1]};
 266 
 267         View v = descendant;
 268         while(v != root &amp;&amp; v != null) {
 269             ancestorChain.add(v);
 270             v = (View) v.getParent();
 271         }
 272         ancestorChain.add(root);
 273 
 274         float scale = 1.0f;
 275         int count = ancestorChain.size();
 276         for (int i = 0; i &lt; count; i++) {
 277             View v0 = ancestorChain.get(i);
 278             // For TextViews, scroll has a meaning which relates to the text position
 279             // which is very strange... ignore the scroll.
 280             if (v0 != descendant || includeRootScroll) {
 281                 pt[0] -= v0.getScrollX();
 282                 pt[1] -= v0.getScrollY();
 283             }
 284 
 285             v0.getMatrix().mapPoints(pt);
 286             pt[0] += v0.getLeft();
 287             pt[1] += v0.getTop();
 288             scale *= v0.getScaleX();
 289         }
 290 
 291         coord[0] = (int) Math.round(pt[0]);
 292         coord[1] = (int) Math.round(pt[1]);
 293         return scale;
 294     }
 295 
 296     /**
 297      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 298      */
 299     public static float mapCoordInSelfToDescendent(View descendant, View root,
 300                                                    int[] coord) {
 301         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 302 
 303         float[] pt = {coord[0], coord[1]};
 304 
 305         View v = descendant;
 306         while(v != root) {
 307             ancestorChain.add(v);
 308             v = (View) v.getParent();
 309         }
 310         ancestorChain.add(root);
 311 
 312         float scale = 1.0f;
 313         Matrix inverse = new Matrix();
 314         int count = ancestorChain.size();
 315         for (int i = count - 1; i &gt;= 0; i--) {
 316             View ancestor = ancestorChain.get(i);
 317             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 318 
 319             pt[0] += ancestor.getScrollX();
 320             pt[1] += ancestor.getScrollY();
 321 
 322             if (next != null) {
 323                 pt[0] -= next.getLeft();
 324                 pt[1] -= next.getTop();
 325                 next.getMatrix().invert(inverse);
 326                 inverse.mapPoints(pt);
 327                 scale *= next.getScaleX();
 328             }
 329         }
 330 
 331         coord[0] = (int) Math.round(pt[0]);
 332         coord[1] = (int) Math.round(pt[1]);
 333         return scale;
 334     }
 335 
 336     /**
 337      * Utility method to determine whether the given point, in local coordinates,
 338      * is inside the view, where the area of the view is expanded by the slop factor.
 339      * This method is called while processing touch-move events to determine if the event
 340      * is still within the view.
 341      */
 342     public static boolean pointInView(View v, float localX, float localY, float slop) {
 343         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 344                 localY &lt; (v.getHeight() + slop);
 345     }
 346 
 347     private static void initStatics(Context context) {
 348         final Resources resources = context.getResources();
 349         sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 350     }
 351 
 352     public static void setIconSize(int widthPx) {
 353         sIconWidth = sIconHeight = widthPx;
 354     }
 355 
 356     public static void scaleRect(Rect r, float scale) {
 357         if (scale != 1.0f) {
 358             r.left = (int) (r.left * scale + 0.5f);
 359             r.top = (int) (r.top * scale + 0.5f);
 360             r.right = (int) (r.right * scale + 0.5f);
 361             r.bottom = (int) (r.bottom * scale + 0.5f);
 362         }
 363     }
 364 
 365     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 366         v0.getLocationInWindow(sLoc0);
 367         v1.getLocationInWindow(sLoc1);
 368 
 369         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 370         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 371         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 372         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 373 
 374         if (delta == null) {
 375             delta = new int[2];
 376         }
 377 
 378         delta[0] = sLoc1[0] - sLoc0[0];
 379         delta[1] = sLoc1[1] - sLoc0[1];
 380 
 381         return delta;
 382     }
 383 
 384     public static void scaleRectAboutCenter(Rect r, float scale) {
 385         int cx = r.centerX();
 386         int cy = r.centerY();
 387         r.offset(-cx, -cy);
 388         Utilities.scaleRect(r, scale);
 389         r.offset(cx, cy);
 390     }
 391 
 392     public static void startActivityForResultSafely(
 393             Activity activity, Intent intent, int requestCode) {
 394         try {
 395             activity.startActivityForResult(intent, requestCode);
 396         } catch (ActivityNotFoundException e) {
 397             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 398         } catch (SecurityException e) {
 399             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 400             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 401                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 402                     &quot;or use the exported attribute for this activity.&quot;, e);
 403         }
 404     }
 405 
 406     static boolean isSystemApp(Context context, Intent intent) {
 407         PackageManager pm = context.getPackageManager();
 408         ComponentName cn = intent.getComponent();
 409         String packageName = null;
 410         if (cn == null) {
 411             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 412             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 413                 packageName = info.activityInfo.packageName;
 414             }
 415         } else {
 416             packageName = cn.getPackageName();
 417         }
 418         if (packageName != null) {
 419             try {
 420                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 421                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 422                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 423             } catch (NameNotFoundException e) {
 424                 return false;
 425             }
 426         } else {
 427             return false;
 428         }
 429     }
 430 
 431     /**
 432      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 433      * @param bitmap The bitmap to scan
 434      * @param samples The approximate max number of samples to use.
 435      */
 436     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 437         final int height = bitmap.getHeight();
 438         final int width = bitmap.getWidth();
 439         int sampleStride = (int) Math.sqrt((height * width) / samples);
 440         if (sampleStride &lt; 1) {
 441             sampleStride = 1;
 442         }
 443 
 444         // This is an out-param, for getting the hsv values for an rgb
 445         float[] hsv = new float[3];
 446 
 447         // First get the best hue, by creating a histogram over 360 hue buckets,
 448         // where each pixel contributes a score weighted by saturation, value, and alpha.
 449         float[] hueScoreHistogram = new float[360];
 450         float highScore = -1;
 451         int bestHue = -1;
 452 
 453         for (int y = 0; y &lt; height; y += sampleStride) {
 454             for (int x = 0; x &lt; width; x += sampleStride) {
 455                 int argb = bitmap.getPixel(x, y);
 456                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 457                 if (alpha &lt; 0x80) {
 458                     // Drop mostly-transparent pixels.
 459                     continue;
 460                 }
 461                 // Remove the alpha channel.
 462                 int rgb = argb | 0xFF000000;
 463                 Color.colorToHSV(rgb, hsv);
 464                 // Bucket colors by the 360 integer hues.
 465                 int hue = (int) hsv[0];
 466                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 467                     // Defensively avoid array bounds violations.
 468                     continue;
 469                 }
 470                 float score = hsv[1] * hsv[2];
 471                 hueScoreHistogram[hue] += score;
 472                 if (hueScoreHistogram[hue] &gt; highScore) {
 473                     highScore = hueScoreHistogram[hue];
 474                     bestHue = hue;
 475                 }
 476             }
 477         }
 478 
 479         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 480         int bestColor = 0xff000000;
 481         highScore = -1;
 482         // Go back over the RGB colors that match the winning hue,
 483         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 484         // The highest-scoring RGB color wins.
 485         for (int y = 0; y &lt; height; y += sampleStride) {
 486             for (int x = 0; x &lt; width; x += sampleStride) {
 487                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 488                 Color.colorToHSV(rgb, hsv);
 489                 int hue = (int) hsv[0];
 490                 if (hue == bestHue) {
 491                     float s = hsv[1];
 492                     float v = hsv[2];
 493                     int bucket = (int) (s * 100) + (int) (v * 10000);
 494                     // Score by cumulative saturation * value.
 495                     float score = s * v;
 496                     Float oldTotal = rgbScores.get(bucket);
 497                     float newTotal = oldTotal == null ? score : oldTotal + score;
 498                     rgbScores.put(bucket, newTotal);
 499                     if (newTotal &gt; highScore) {
 500                         highScore = newTotal;
 501                         // All the colors in the winning bucket are very similar. Last in wins.
 502                         bestColor = rgb;
 503                     }
 504                 }
 505             }
 506         }
 507         return bestColor;
 508     }
 509 
 510     /*
 511      * Finds a system apk which had a broadcast receiver listening to a particular action.
 512      * @param action intent action used to find the apk
 513      * @return a pair of apk package name and the resources.
 514      */
 515     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 516         final Intent intent = new Intent(action);
 517         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 518             if (info.activityInfo != null &amp;&amp;
 519                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 520                 final String packageName = info.activityInfo.packageName;
 521                 try {
 522                     final Resources res = pm.getResourcesForApplication(packageName);
 523                     return Pair.create(packageName, res);
 524                 } catch (NameNotFoundException e) {
 525                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 526                 }
 527             }
 528         }
 529         return null;
 530     }
 531 
 532     @TargetApi(Build.VERSION_CODES.KITKAT)
 533     public static boolean isViewAttachedToWindow(View v) {
 534         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 535             return v.isAttachedToWindow();
 536         } else {
 537             // A proxy call which returns null, if the view is not attached to the window.
 538             return v.getKeyDispatcherState() != null;
 539         }
 540     }
 541 
 542     /**
 543      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 544      * provided by the same package which is set to be global search activity.
 545      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 546      * provided by the package.
 547      */
 548     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 549     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 550         SearchManager searchManager =
 551                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 552         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 553         if (searchComponent == null) return null;
 554         String providerPkg = searchComponent.getPackageName();
 555 
 556         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 557 
 558         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 559         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 560             if (info.provider.getPackageName().equals(providerPkg)) {
 561                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 562                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 563                         return info;
 564                     } else if (defaultWidgetForSearchPackage == null) {
 565                         defaultWidgetForSearchPackage = info;
 566                     }
 567                 } else {
 568                     return info;
 569                 }
 570             }
 571         }
 572         return defaultWidgetForSearchPackage;
 573     }
 574 
 575     /**
 576      * Compresses the bitmap to a byte array for serialization.
 577      */
 578     public static byte[] flattenBitmap(Bitmap bitmap) {
 579         // Try go guesstimate how much space the icon will take when serialized
 580         // to avoid unnecessary allocations/copies during the write.
 581         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 582         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 583         try {
 584             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 585             out.flush();
 586             out.close();
 587             return out.toByteArray();
 588         } catch (IOException e) {
 589             Log.w(TAG, &quot;Could not write bitmap&quot;);
 590             return null;
 591         }
 592     }
 593 
 594     public static final Comparator&lt;ItemInfo&gt; RANK_COMPARATOR = new Comparator&lt;ItemInfo&gt;() {
 595 
 596         @Override
 597         public int compare(ItemInfo lhs, ItemInfo rhs) {
 598             return lhs.rank - rhs.rank;
 599         }
 600     };
 601 
 602     /**
 603      * Find the first vacant cell, if there is one.
 604      *
 605      * @param vacant Holds the x and y coordinate of the vacant cell
 606      * @param spanX Horizontal cell span.
 607      * @param spanY Vertical cell span.
 608      *
 609      * @return true if a vacant cell was found
 610      */
 611     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 612             int xCount, int yCount, boolean[][] occupied) {
 613 
 614         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 615             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 616                 boolean available = !occupied[x][y];
 617                 out:            for (int i = x; i &lt; x + spanX; i++) {
 618                     for (int j = y; j &lt; y + spanY; j++) {
 619                         available = available &amp;&amp; !occupied[i][j];
 620                         if (!available) break out;
 621                     }
 622                 }
 623 
 624                 if (available) {
 625                     vacant[0] = x;
 626                     vacant[1] = y;
 627                     return true;
 628                 }
 629             }
 630         }
 631 
 632         return false;
 633     }
 634 
 635     /**
 636      * Trims the string, removing all whitespace at the beginning and end of the string.
 637      * Non-breaking whitespaces are also removed.
 638      */
 639     public static String trim(CharSequence s) {
 640         if (s == null) {
 641             return null;
 642         }
 643 
 644         // Just strip any sequence of whitespace or java space characters from the beginning and end
 645         Matcher m = sTrimPattern.matcher(s);
 646         return m.replaceAll(&quot;$1&quot;);
 647     }
 648 
 649     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 650     public static boolean isRtl(Resources res) {
 651         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 652                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 653     }
 654 
 655     public static void assertWorkerThread() {
 656         if (LauncherAppState.isDogfoodBuild()) {
 657             Assert.assertTrue(LauncherModel.sWorkerThread.getThreadId() == Process.myTid());
 658         }
 659     }
 660 
 661     /**
 662      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 663      * This is used to identify shortcuts which are different from the ones exposed by the
 664      * applications&#x27; manifest file.
 665      *
 666      * @param launchIntent The intent that will be launched when the shortcut is clicked.
 667      */
 668     public static boolean isLauncherAppTarget(Intent launchIntent) {
 669         return launchIntent != null
 670                 &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())
 671                 &amp;&amp; launchIntent.getComponent() != null
 672                 &amp;&amp; launchIntent.getCategories() != null
 673                 &amp;&amp; launchIntent.getCategories().size() == 1
 674                 &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)
 675                 &amp;&amp; launchIntent.getExtras() == null
 676                 &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString());
 677     }
 678 
 679     public static float dpiFromPx(int size, DisplayMetrics metrics){
 680         float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;
 681         return (size / densityRatio);
 682     }
 683     public static int pxFromDp(float size, DisplayMetrics metrics) {
 684         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
 685                 size, metrics));
 686     }
 687     public static int pxFromSp(float size, DisplayMetrics metrics) {
 688         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
 689                 size, metrics));
 690     }
 691 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.annotation.TargetApi;
  19 import android.app.Activity;
  20 import android.app.SearchManager;
  21 import android.appwidget.AppWidgetManager;
  22 import android.appwidget.AppWidgetProviderInfo;
  23 import android.content.ActivityNotFoundException;
  24 import android.content.ComponentName;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ApplicationInfo;
  28 import android.content.pm.PackageInfo;
  29 import android.content.pm.PackageManager.NameNotFoundException;
  30 import android.content.pm.PackageManager;
  31 import android.content.pm.ResolveInfo;
  32 import android.content.res.Resources;
  33 import android.database.Cursor;
  34 import android.graphics.Bitmap;
  35 import android.graphics.BitmapFactory;
  36 import android.graphics.Canvas;
  37 import android.graphics.Color;
  38 import android.graphics.Matrix;
  39 import android.graphics.Paint;
  40 import android.graphics.PaintFlagsDrawFilter;
  41 import android.graphics.Rect;
  42 import android.graphics.drawable.BitmapDrawable;
  43 import android.graphics.drawable.Drawable;
  44 import android.graphics.drawable.PaintDrawable;
  45 import android.os.Build;
  46 import android.os.Process;
  47 import android.text.TextUtils;
  48 import android.util.DisplayMetrics;
  49 import android.util.Log;
  50 import android.util.Pair;
  51 import android.util.SparseArray;
  52 import android.util.TypedValue;
  53 import android.view.View;
  54 import android.widget.Toast;
  55 import java.io.ByteArrayOutputStream;
  56 import java.io.IOException;
  57 import java.util.ArrayList;
  58 import java.util.Comparator;
  59 import java.util.regex.Matcher;
  60 import java.util.regex.Pattern;
  61 import junit.framework.Assert;
  62 
  63 
  64 /**
  65  * Various utilities shared amongst the Launcher&#x27;s classes.
  66  */
  67 public final class Utilities {
  68     private static final String TAG = &quot;Launcher.Utilities&quot;;
  69 
  70     private static int sIconWidth = -1;
  71 
  72     private static int sIconHeight = -1;
  73 
  74     private static final Rect sOldBounds = new Rect();
  75 
  76     private static final Canvas sCanvas = new Canvas();
  77 
  78     private static final Pattern sTrimPattern =
  79             Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);
  80 
  81     static {
  82         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG, Paint.FILTER_BITMAP_FLAG));
  83     }
  84 
  85     static int[] sColors = new int[]{ 0xffff0000, 0xff00ff00, 0xff0000ff };
  86 
  87     static int sColorIndex = 0;
  88 
  89     static int[] sLoc0 = new int[2];
  90 
  91     static int[] sLoc1 = new int[2];
  92 
  93     // To turn on these properties, type
  94     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  95     static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  96 
  97     public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  98 
  99     /**
 100      * Returns a FastBitmapDrawable with the icon, accurately sized.
 101      */
 102     public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
 103         FastBitmapDrawable d = new FastBitmapDrawable(icon);
 104         d.setFilterBitmap(true);
 105         resizeIconDrawable(d);
 106         return d;
 107     }
 108 
 109     /**
 110      * Resizes an icon drawable to the correct icon size.
 111      */
 112     static void resizeIconDrawable(Drawable icon) {
 113         icon.setBounds(0, 0, sIconWidth, sIconHeight);
 114     }
 115 
 116     public static boolean isPropertyEnabled(String propertyName) {
 117         return Log.isLoggable(propertyName, Log.VERBOSE);
 118     }
 119 
 120     public static boolean isRotationEnabled(Context c) {
 121         boolean enableRotation = sForceEnableRotation ||
 122                 c.getResources().getBoolean(R.bool.allow_rotation);
 123         return enableRotation;
 124     }
 125 
 126     /**
 127      * Indicates if the device is running LMP or higher.
 128      */
 129     public static boolean isLmpOrAbove() {
 130         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 131     }
 132 
 133     static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {
 134         byte[] data = c.getBlob(iconIndex);
 135         try {
 136             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);
 137         } catch (Exception e) {
 138             return null;
 139         }
 140     }
 141 
 142     public static boolean isLmpMr1() {
 143         return Build.VERSION.SDK_INT == 22;
 144     }
 145 
 146     /**
 147      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 148      * exist, it returns null.
 149      */
 150     static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,
 151             Context context) {
 152         PackageManager packageManager = context.getPackageManager();
 153         // the resource
 154         try {
 155             Resources resources = packageManager.getResourcesForApplication(packageName);
 156             if (resources != null) {
 157                 final int id = resources.getIdentifier(resourceName, null, null);
 158                 return createIconBitmap(
 159                         resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);
 160             }
 161         } catch (Exception e) {
 162             // Icon not found.
 163         }
 164         return null;
 165     }
 166 
 167     /**
 168      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 169      */
 170     static Bitmap createIconBitmap(Bitmap icon, Context context) {
 171         synchronized (sCanvas) { // we share the statics :-(
 172             if (sIconWidth == -1) {
 173                 initStatics(context);
 174             }
 175         }
 176         if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {
 177             return icon;
 178         }
 179         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 180     }
 181 
 182     /**
 183      * Returns a bitmap suitable for the all apps view.
 184      */
 185     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 186         synchronized (sCanvas) { // we share the statics :-(
 187             if (sIconWidth == -1) {
 188                 initStatics(context);
 189             }
 190 
 191             int width = sIconWidth;
 192             int height = sIconHeight;
 193 
 194             if (icon instanceof PaintDrawable) {
 195                 PaintDrawable painter = (PaintDrawable) icon;
 196                 painter.setIntrinsicWidth(width);
 197                 painter.setIntrinsicHeight(height);
 198             } else if (icon instanceof BitmapDrawable) {
 199                 // Ensure the bitmap has a density.
 200                 BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 201                 Bitmap bitmap = bitmapDrawable.getBitmap();
 202                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 203                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 204                 }
 205             }
 206             int sourceWidth = icon.getIntrinsicWidth();
 207             int sourceHeight = icon.getIntrinsicHeight();
 208             if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 209                 // Scale the icon proportionally to the icon dimensions
 210                 final float ratio = (float) sourceWidth / sourceHeight;
 211                 if (sourceWidth &gt; sourceHeight) {
 212                     height = (int) (width / ratio);
 213                 } else if (sourceHeight &gt; sourceWidth) {
 214                     width = (int) (height * ratio);
 215                 }
 216             }
 217 
 218             // no intrinsic size --&gt; use default size
 219             int textureWidth = sIconWidth;
 220             int textureHeight = sIconHeight;
 221 
 222             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 223                     Bitmap.Config.ARGB_8888);
 224             final Canvas canvas = sCanvas;
 225             canvas.setBitmap(bitmap);
 226 
 227             final int left = (textureWidth-width) / 2;
 228             final int top = (textureHeight-height) / 2;
 229 
 230             @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 231             final boolean debug = false;
 232             if (debug) {
 233                 // draw a big box for the icon for debugging
 234                 canvas.drawColor(sColors[sColorIndex]);
 235                 if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 236                 Paint debugPaint = new Paint();
 237                 debugPaint.setColor(0xffcccc00);
 238                 canvas.drawRect(left, top, left+width, top+height, debugPaint);
 239             }
 240 
 241             sOldBounds.set(icon.getBounds());
 242             icon.setBounds(left, top, left+width, top+height);
 243             icon.draw(canvas);
 244             icon.setBounds(sOldBounds);
 245             canvas.setBitmap(null);
 246 
 247             return bitmap;
 248         }
 249     }
 250 
 251     /**
 252      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 253      * coordinates.
 254      *
 255      * @param descendant The descendant to which the passed coordinate is relative.
 256      * @param root The root view to make the coordinates relative to.
 257      * @param coord The coordinate that we want mapped.
 258      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 259      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 260      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 261      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 262      *         assumption fails, we will need to return a pair of scale factors.
 263      */
 264     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 265                                                            int[] coord, boolean includeRootScroll) {
 266         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 267 
 268         float[] pt = {coord[0], coord[1]};
 269 
 270         View v = descendant;
 271         while(v != root &amp;&amp; v != null) {
 272             ancestorChain.add(v);
 273             v = (View) v.getParent();
 274         }
 275         ancestorChain.add(root);
 276 
 277         float scale = 1.0f;
 278         int count = ancestorChain.size();
 279         for (int i = 0; i &lt; count; i++) {
 280             View v0 = ancestorChain.get(i);
 281             // For TextViews, scroll has a meaning which relates to the text position
 282             // which is very strange... ignore the scroll.
 283             if (v0 != descendant || includeRootScroll) {
 284                 pt[0] -= v0.getScrollX();
 285                 pt[1] -= v0.getScrollY();
 286             }
 287 
 288             v0.getMatrix().mapPoints(pt);
 289             pt[0] += v0.getLeft();
 290             pt[1] += v0.getTop();
 291             scale *= v0.getScaleX();
 292         }
 293 
 294         coord[0] = (int) Math.round(pt[0]);
 295         coord[1] = (int) Math.round(pt[1]);
 296         return scale;
 297     }
 298 
 299     /**
 300      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 301      */
 302     public static float mapCoordInSelfToDescendent(View descendant, View root,
 303                                                    int[] coord) {
 304         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 305 
 306         float[] pt = {coord[0], coord[1]};
 307 
 308         View v = descendant;
 309         while(v != root) {
 310             ancestorChain.add(v);
 311             v = (View) v.getParent();
 312         }
 313         ancestorChain.add(root);
 314 
 315         float scale = 1.0f;
 316         Matrix inverse = new Matrix();
 317         int count = ancestorChain.size();
 318         for (int i = count - 1; i &gt;= 0; i--) {
 319             View ancestor = ancestorChain.get(i);
 320             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 321 
 322             pt[0] += ancestor.getScrollX();
 323             pt[1] += ancestor.getScrollY();
 324 
 325             if (next != null) {
 326                 pt[0] -= next.getLeft();
 327                 pt[1] -= next.getTop();
 328                 next.getMatrix().invert(inverse);
 329                 inverse.mapPoints(pt);
 330                 scale *= next.getScaleX();
 331             }
 332         }
 333 
 334         coord[0] = (int) Math.round(pt[0]);
 335         coord[1] = (int) Math.round(pt[1]);
 336         return scale;
 337     }
 338 
 339     /**
 340      * Utility method to determine whether the given point, in local coordinates,
 341      * is inside the view, where the area of the view is expanded by the slop factor.
 342      * This method is called while processing touch-move events to determine if the event
 343      * is still within the view.
 344      */
 345     public static boolean pointInView(View v, float localX, float localY, float slop) {
 346         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 347                 localY &lt; (v.getHeight() + slop);
 348     }
 349 
 350     private static void initStatics(Context context) {
 351         final Resources resources = context.getResources();
 352         sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 353     }
 354 
 355     public static void setIconSize(int widthPx) {
 356         sIconWidth = sIconHeight = widthPx;
 357     }
 358 
 359     public static void scaleRect(Rect r, float scale) {
 360         if (scale != 1.0f) {
 361             r.left = (int) (r.left * scale + 0.5f);
 362             r.top = (int) (r.top * scale + 0.5f);
 363             r.right = (int) (r.right * scale + 0.5f);
 364             r.bottom = (int) (r.bottom * scale + 0.5f);
 365         }
 366     }
 367 
 368     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 369         v0.getLocationInWindow(sLoc0);
 370         v1.getLocationInWindow(sLoc1);
 371 
 372         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 373         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 374         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 375         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 376 
 377         if (delta == null) {
 378             delta = new int[2];
 379         }
 380 
 381         delta[0] = sLoc1[0] - sLoc0[0];
 382         delta[1] = sLoc1[1] - sLoc0[1];
 383 
 384         return delta;
 385     }
 386 
 387     public static void scaleRectAboutCenter(Rect r, float scale) {
 388         int cx = r.centerX();
 389         int cy = r.centerY();
 390         r.offset(-cx, -cy);
 391         Utilities.scaleRect(r, scale);
 392         r.offset(cx, cy);
 393     }
 394 
 395     public static void startActivityForResultSafely(
 396             Activity activity, Intent intent, int requestCode) {
 397         try {
 398             activity.startActivityForResult(intent, requestCode);
 399         } catch (ActivityNotFoundException e) {
 400             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 401         } catch (SecurityException e) {
 402             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 403             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 404                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 405                     &quot;or use the exported attribute for this activity.&quot;, e);
 406         }
 407     }
 408 
 409     static boolean isSystemApp(Context context, Intent intent) {
 410         PackageManager pm = context.getPackageManager();
 411         ComponentName cn = intent.getComponent();
 412         String packageName = null;
 413         if (cn == null) {
 414             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 415             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 416                 packageName = info.activityInfo.packageName;
 417             }
 418         } else {
 419             packageName = cn.getPackageName();
 420         }
 421         if (packageName != null) {
 422             try {
 423                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 424                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 425                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 426             } catch (NameNotFoundException e) {
 427                 return false;
 428             }
 429         } else {
 430             return false;
 431         }
 432     }
 433 
 434     /**
 435      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 436      * @param bitmap The bitmap to scan
 437      * @param samples The approximate max number of samples to use.
 438      */
 439     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 440         final int height = bitmap.getHeight();
 441         final int width = bitmap.getWidth();
 442         int sampleStride = (int) Math.sqrt((height * width) / samples);
 443         if (sampleStride &lt; 1) {
 444             sampleStride = 1;
 445         }
 446 
 447         // This is an out-param, for getting the hsv values for an rgb
 448         float[] hsv = new float[3];
 449 
 450         // First get the best hue, by creating a histogram over 360 hue buckets,
 451         // where each pixel contributes a score weighted by saturation, value, and alpha.
 452         float[] hueScoreHistogram = new float[360];
 453         float highScore = -1;
 454         int bestHue = -1;
 455 
 456         for (int y = 0; y &lt; height; y += sampleStride) {
 457             for (int x = 0; x &lt; width; x += sampleStride) {
 458                 int argb = bitmap.getPixel(x, y);
 459                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 460                 if (alpha &lt; 0x80) {
 461                     // Drop mostly-transparent pixels.
 462                     continue;
 463                 }
 464                 // Remove the alpha channel.
 465                 int rgb = argb | 0xFF000000;
 466                 Color.colorToHSV(rgb, hsv);
 467                 // Bucket colors by the 360 integer hues.
 468                 int hue = (int) hsv[0];
 469                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 470                     // Defensively avoid array bounds violations.
 471                     continue;
 472                 }
 473                 float score = hsv[1] * hsv[2];
 474                 hueScoreHistogram[hue] += score;
 475                 if (hueScoreHistogram[hue] &gt; highScore) {
 476                     highScore = hueScoreHistogram[hue];
 477                     bestHue = hue;
 478                 }
 479             }
 480         }
 481 
 482         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 483         int bestColor = 0xff000000;
 484         highScore = -1;
 485         // Go back over the RGB colors that match the winning hue,
 486         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 487         // The highest-scoring RGB color wins.
 488         for (int y = 0; y &lt; height; y += sampleStride) {
 489             for (int x = 0; x &lt; width; x += sampleStride) {
 490                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 491                 Color.colorToHSV(rgb, hsv);
 492                 int hue = (int) hsv[0];
 493                 if (hue == bestHue) {
 494                     float s = hsv[1];
 495                     float v = hsv[2];
 496                     int bucket = (int) (s * 100) + (int) (v * 10000);
 497                     // Score by cumulative saturation * value.
 498                     float score = s * v;
 499                     Float oldTotal = rgbScores.get(bucket);
 500                     float newTotal = oldTotal == null ? score : oldTotal + score;
 501                     rgbScores.put(bucket, newTotal);
 502                     if (newTotal &gt; highScore) {
 503                         highScore = newTotal;
 504                         // All the colors in the winning bucket are very similar. Last in wins.
 505                         bestColor = rgb;
 506                     }
 507                 }
 508             }
 509         }
 510         return bestColor;
 511     }
 512 
 513     /*
 514      * Finds a system apk which had a broadcast receiver listening to a particular action.
 515      * @param action intent action used to find the apk
 516      * @return a pair of apk package name and the resources.
 517      */
 518     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 519         final Intent intent = new Intent(action);
 520         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 521             if (info.activityInfo != null &amp;&amp;
 522                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 523                 final String packageName = info.activityInfo.packageName;
 524                 try {
 525                     final Resources res = pm.getResourcesForApplication(packageName);
 526                     return Pair.create(packageName, res);
 527                 } catch (NameNotFoundException e) {
 528                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 529                 }
 530             }
 531         }
 532         return null;
 533     }
 534 
 535     @TargetApi(Build.VERSION_CODES.KITKAT)
 536     public static boolean isViewAttachedToWindow(View v) {
 537         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 538             return v.isAttachedToWindow();
 539         } else {
 540             // A proxy call which returns null, if the view is not attached to the window.
 541             return v.getKeyDispatcherState() != null;
 542         }
 543     }
 544 
 545     /**
 546      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 547      * provided by the same package which is set to be global search activity.
 548      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 549      * provided by the package.
 550      */
 551     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 552     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 553         SearchManager searchManager =
 554                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 555         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 556         if (searchComponent == null) return null;
 557         String providerPkg = searchComponent.getPackageName();
 558 
 559         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 560 
 561         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 562         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 563             if (info.provider.getPackageName().equals(providerPkg)) {
 564                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 565                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 566                         return info;
 567                     } else if (defaultWidgetForSearchPackage == null) {
 568                         defaultWidgetForSearchPackage = info;
 569                     }
 570                 } else {
 571                     return info;
 572                 }
 573             }
 574         }
 575         return defaultWidgetForSearchPackage;
 576     }
 577 
 578     /**
 579      * Compresses the bitmap to a byte array for serialization.
 580      */
 581     public static byte[] flattenBitmap(Bitmap bitmap) {
 582         // Try go guesstimate how much space the icon will take when serialized
 583         // to avoid unnecessary allocations/copies during the write.
 584         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 585         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 586         try {
 587             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 588             out.flush();
 589             out.close();
 590             return out.toByteArray();
 591         } catch (IOException e) {
 592             Log.w(TAG, &quot;Could not write bitmap&quot;);
 593             return null;
 594         }
 595     }
 596 
 597     public static final Comparator&lt;ItemInfo&gt; RANK_COMPARATOR = new Comparator&lt;ItemInfo&gt;() {
 598         @Override
 599         public int compare(ItemInfo lhs, ItemInfo rhs) {
 600             return lhs.rank - rhs.rank;
 601         }
 602     };
 603 
 604     /**
 605      * Find the first vacant cell, if there is one.
 606      *
 607      * @param vacant Holds the x and y coordinate of the vacant cell
 608      * @param spanX Horizontal cell span.
 609      * @param spanY Vertical cell span.
 610      *
 611      * @return true if a vacant cell was found
 612      */
 613     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 614             int xCount, int yCount, boolean[][] occupied) {
 615 
 616         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 617             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 618                 boolean available = !occupied[x][y];
 619                 out:            for (int i = x; i &lt; x + spanX; i++) {
 620                     for (int j = y; j &lt; y + spanY; j++) {
 621                         available = available &amp;&amp; !occupied[i][j];
 622                         if (!available) break out;
 623                     }
 624                 }
 625 
 626                 if (available) {
 627                     vacant[0] = x;
 628                     vacant[1] = y;
 629                     return true;
 630                 }
 631             }
 632         }
 633 
 634         return false;
 635     }
 636 
 637     /**
 638      * Trims the string, removing all whitespace at the beginning and end of the string.
 639      * Non-breaking whitespaces are also removed.
 640      */
 641     public static String trim(CharSequence s) {
 642         if (s == null) {
 643             return null;
 644         }
 645 
 646         // Just strip any sequence of whitespace or java space characters from the beginning and end
 647         Matcher m = sTrimPattern.matcher(s);
 648         return m.replaceAll(&quot;$1&quot;);
 649     }
 650 
 651     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 652     public static boolean isRtl(Resources res) {
 653         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 654                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 655     }
 656 
 657     public static void assertWorkerThread() {
 658         if (LauncherAppState.isDogfoodBuild()) {
 659             Assert.assertTrue(LauncherModel.sWorkerThread.getThreadId() == Process.myTid());
 660         }
 661     }
 662 
 663     /**
 664      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 665      * This is used to identify shortcuts which are different from the ones exposed by the
 666      * applications&#x27; manifest file.
 667      *
 668      * @param launchIntent The intent that will be launched when the shortcut is clicked.
 669      */
 670     public static boolean isLauncherAppTarget(Intent launchIntent) {
 671         return launchIntent != null
 672                 &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())
 673                 &amp;&amp; launchIntent.getComponent() != null
 674                 &amp;&amp; launchIntent.getCategories() != null
 675                 &amp;&amp; launchIntent.getCategories().size() == 1
 676                 &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)
 677                 &amp;&amp; launchIntent.getExtras() == null
 678                 &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString());
 679     }
 680 
 681     public static float dpiFromPx(int size, DisplayMetrics metrics){
 682         float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;
 683         return (size / densityRatio);
 684     }
 685 
 686     public static int pxFromDp(float size, DisplayMetrics metrics) {
 687         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
 688                 size, metrics));
 689     }
 690 
 691     public static int pxFromSp(float size, DisplayMetrics metrics) {
 692         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
 693                 size, metrics));
 694     }
 695 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.annotation.TargetApi;
  20  import android.app.Activity;
  21  import android.app.SearchManager;
  22  import android.appwidget.AppWidgetManager;
  23  import android.appwidget.AppWidgetProviderInfo;
  24  import android.content.ActivityNotFoundException;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.ApplicationInfo;
  29  import android.content.pm.PackageInfo;
  30  import android.content.pm.PackageManager;
  31  import android.content.pm.PackageManager.NameNotFoundException;
  32  import android.content.pm.ResolveInfo;
  33  import android.content.res.Resources;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import android.database.Cursor;</span>
  35  import android.graphics.Bitmap;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import android.graphics.BitmapFactory;</span>
  37  import android.graphics.Canvas;
  38  import android.graphics.Color;
  39  import android.graphics.Matrix;
  40  import android.graphics.Paint;
  41  import android.graphics.PaintFlagsDrawFilter;
  42  import android.graphics.Rect;
  43  import android.graphics.drawable.BitmapDrawable;
  44  import android.graphics.drawable.Drawable;
  45  import android.graphics.drawable.PaintDrawable;
  46  import android.os.Build;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import android.os.Process;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import android.text.TextUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import android.util.DisplayMetrics;</span>
  50  import android.util.Log;
  51  import android.util.Pair;
  52  import android.util.SparseArray;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import android.util.TypedValue;</span>
  54  import android.view.View;
  55  import android.widget.Toast;
  56  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import junit.framework.Assert;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import java.io.ByteArrayOutputStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import java.io.IOException;</span>
  61  import java.util.ArrayList;
  62  import java.util.Comparator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.util.regex.Matcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import java.util.regex.Pattern;</span>
  65  
  66  /**
  67   * Various utilities shared amongst the Launcher&#x27;s classes.
  68   */
  69  public final class Utilities {
  70      private static final String TAG = &quot;Launcher.Utilities&quot;;
  71  
  72      private static int sIconWidth = -1;
  73      private static int sIconHeight = -1;
  74  
  75      private static final Rect sOldBounds = new Rect();
  76      private static final Canvas sCanvas = new Canvas();
  77  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +    private static final Pattern sTrimPattern =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +            Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +</span>
  81      static {
  82          sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  83                  Paint.FILTER_BITMAP_FLAG));
  84      }
  85      static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  86      static int sColorIndex = 0;
  87  
  88      static int[] sLoc0 = new int[2];
  89      static int[] sLoc1 = new int[2];
  90  
  91      // To turn on these properties, type
  92      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  93      static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  94      public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  95  
  96      /**
  97       * Returns a FastBitmapDrawable with the icon, accurately sized.
  98       */
  99      public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
 100          FastBitmapDrawable d = new FastBitmapDrawable(icon);
 101          d.setFilterBitmap(true);
 102          resizeIconDrawable(d);
 103          return d;
 104      }
 105  
 106      /**
 107       * Resizes an icon drawable to the correct icon size.
 108       */
 109      static void resizeIconDrawable(Drawable icon) {
 110          icon.setBounds(0, 0, sIconWidth, sIconHeight);
 111      }
 112  
 113      public static boolean isPropertyEnabled(String propertyName) {
 114          return Log.isLoggable(propertyName, Log.VERBOSE);
 115      }
 116  
 117      public static boolean isRotationEnabled(Context c) {
 118          boolean enableRotation = sForceEnableRotation ||
 119                  c.getResources().getBoolean(R.bool.allow_rotation);
 120          return enableRotation;
 121      }
 122  
 123      /**
 124       * Indicates if the device is running LMP or higher.
 125       */
 126      public static boolean isLmpOrAbove() {
 127          return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +    static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +        byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +            return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +        }</span>
 137      }
 138  




 139      /**
 140       * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 141       * exist, it returns null.
 142       */
 143      static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,
 144              Context context) {
 145          PackageManager packageManager = context.getPackageManager();
 146          // the resource
 147          try {
 148              Resources resources = packageManager.getResourcesForApplication(packageName);
 149              if (resources != null) {
 150                  final int id = resources.getIdentifier(resourceName, null, null);
 151                  return createIconBitmap(
 152                          resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);
 153              }
 154          } catch (Exception e) {
 155              // Icon not found.
 156          }
 157          return null;
 158      }
 159  
 160      /**
 161       * Returns a bitmap which is of the appropriate size to be displayed as an icon
 162       */
 163      static Bitmap createIconBitmap(Bitmap icon, Context context) {
 164          synchronized (sCanvas) { // we share the statics :-(
 165              if (sIconWidth == -1) {
 166                  initStatics(context);
 167              }
 168          }
 169          if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {
 170              return icon;
 171          }
 172          return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 173      }
 174  
 175      /**
 176       * Returns a bitmap suitable for the all apps view.
 177       */
 178      public static Bitmap createIconBitmap(Drawable icon, Context context) {
 179          synchronized (sCanvas) { // we share the statics :-(
 180              if (sIconWidth == -1) {
 181                  initStatics(context);
 182              }
 183  
 184              int width = sIconWidth;
 185              int height = sIconHeight;
 186  
 187              if (icon instanceof PaintDrawable) {
 188                  PaintDrawable painter = (PaintDrawable) icon;
 189                  painter.setIntrinsicWidth(width);
 190                  painter.setIntrinsicHeight(height);
 191              } else if (icon instanceof BitmapDrawable) {
 192                  // Ensure the bitmap has a density.
 193                  BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 194                  Bitmap bitmap = bitmapDrawable.getBitmap();
 195                  if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 196                      bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 197                  }
 198              }
 199              int sourceWidth = icon.getIntrinsicWidth();
 200              int sourceHeight = icon.getIntrinsicHeight();
 201              if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 202                  // Scale the icon proportionally to the icon dimensions
 203                  final float ratio = (float) sourceWidth / sourceHeight;
 204                  if (sourceWidth &gt; sourceHeight) {
 205                      height = (int) (width / ratio);
 206                  } else if (sourceHeight &gt; sourceWidth) {
 207                      width = (int) (height * ratio);
 208                  }
 209              }
 210  
 211              // no intrinsic size --&gt; use default size
 212              int textureWidth = sIconWidth;
 213              int textureHeight = sIconHeight;
 214  
 215              final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 216                      Bitmap.Config.ARGB_8888);
 217              final Canvas canvas = sCanvas;
 218              canvas.setBitmap(bitmap);
 219  
 220              final int left = (textureWidth-width) / 2;
 221              final int top = (textureHeight-height) / 2;
 222  
 223              @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 224              final boolean debug = false;
 225              if (debug) {
 226                  // draw a big box for the icon for debugging
 227                  canvas.drawColor(sColors[sColorIndex]);
 228                  if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 229                  Paint debugPaint = new Paint();
 230                  debugPaint.setColor(0xffcccc00);
 231                  canvas.drawRect(left, top, left+width, top+height, debugPaint);
 232              }
 233  
 234              sOldBounds.set(icon.getBounds());
 235              icon.setBounds(left, top, left+width, top+height);
 236              icon.draw(canvas);
 237              icon.setBounds(sOldBounds);
 238              canvas.setBitmap(null);
 239  
 240              return bitmap;
 241          }
 242      }
 243  
 244      /**
 245       * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 246       * coordinates.
 247       *
 248       * @param descendant The descendant to which the passed coordinate is relative.
 249       * @param root The root view to make the coordinates relative to.
 250       * @param coord The coordinate that we want mapped.
 251       * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 252       *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 253       * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 254       *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 255       *         assumption fails, we will need to return a pair of scale factors.
 256       */
 257      public static float getDescendantCoordRelativeToParent(View descendant, View root,
 258                                                             int[] coord, boolean includeRootScroll) {
 259          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 260  
 261          float[] pt = {coord[0], coord[1]};
 262  
 263          View v = descendant;
 264          while(v != root &amp;&amp; v != null) {
 265              ancestorChain.add(v);
 266              v = (View) v.getParent();
 267          }
 268          ancestorChain.add(root);
 269  
 270          float scale = 1.0f;
 271          int count = ancestorChain.size();
 272          for (int i = 0; i &lt; count; i++) {
 273              View v0 = ancestorChain.get(i);
 274              // For TextViews, scroll has a meaning which relates to the text position
 275              // which is very strange... ignore the scroll.
 276              if (v0 != descendant || includeRootScroll) {
 277                  pt[0] -= v0.getScrollX();
 278                  pt[1] -= v0.getScrollY();
 279              }
 280  
 281              v0.getMatrix().mapPoints(pt);
 282              pt[0] += v0.getLeft();
 283              pt[1] += v0.getTop();
 284              scale *= v0.getScaleX();
 285          }
 286  
 287          coord[0] = (int) Math.round(pt[0]);
 288          coord[1] = (int) Math.round(pt[1]);
 289          return scale;
 290      }
 291  
 292      /**
 293       * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 294       */
 295      public static float mapCoordInSelfToDescendent(View descendant, View root,
 296                                                     int[] coord) {
 297          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 298  
 299          float[] pt = {coord[0], coord[1]};
 300  
 301          View v = descendant;
 302          while(v != root) {
 303              ancestorChain.add(v);
 304              v = (View) v.getParent();
 305          }
 306          ancestorChain.add(root);
 307  
 308          float scale = 1.0f;
 309          Matrix inverse = new Matrix();
 310          int count = ancestorChain.size();
 311          for (int i = count - 1; i &gt;= 0; i--) {
 312              View ancestor = ancestorChain.get(i);
 313              View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 314  
 315              pt[0] += ancestor.getScrollX();
 316              pt[1] += ancestor.getScrollY();
 317  
 318              if (next != null) {
 319                  pt[0] -= next.getLeft();
 320                  pt[1] -= next.getTop();
 321                  next.getMatrix().invert(inverse);
 322                  inverse.mapPoints(pt);
 323                  scale *= next.getScaleX();
 324              }
 325          }
 326  
 327          coord[0] = (int) Math.round(pt[0]);
 328          coord[1] = (int) Math.round(pt[1]);
 329          return scale;
 330      }
 331  
 332      /**
 333       * Utility method to determine whether the given point, in local coordinates,
 334       * is inside the view, where the area of the view is expanded by the slop factor.
 335       * This method is called while processing touch-move events to determine if the event
 336       * is still within the view.
 337       */
 338      public static boolean pointInView(View v, float localX, float localY, float slop) {
 339          return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 340                  localY &lt; (v.getHeight() + slop);
 341      }
 342  
 343      private static void initStatics(Context context) {
 344          final Resources resources = context.getResources();
 345          sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 346      }
 347  
 348      public static void setIconSize(int widthPx) {
 349          sIconWidth = sIconHeight = widthPx;
 350      }
 351  
 352      public static void scaleRect(Rect r, float scale) {
 353          if (scale != 1.0f) {
 354              r.left = (int) (r.left * scale + 0.5f);
 355              r.top = (int) (r.top * scale + 0.5f);
 356              r.right = (int) (r.right * scale + 0.5f);
 357              r.bottom = (int) (r.bottom * scale + 0.5f);
 358          }
 359      }
 360  
 361      public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 362          v0.getLocationInWindow(sLoc0);
 363          v1.getLocationInWindow(sLoc1);
 364  
 365          sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 366          sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 367          sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 368          sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 369  
 370          if (delta == null) {
 371              delta = new int[2];
 372          }
 373  
 374          delta[0] = sLoc1[0] - sLoc0[0];
 375          delta[1] = sLoc1[1] - sLoc0[1];
 376  
 377          return delta;
 378      }
 379  
 380      public static void scaleRectAboutCenter(Rect r, float scale) {
 381          int cx = r.centerX();
 382          int cy = r.centerY();
 383          r.offset(-cx, -cy);
 384          Utilities.scaleRect(r, scale);
 385          r.offset(cx, cy);
 386      }
 387  
 388      public static void startActivityForResultSafely(
 389              Activity activity, Intent intent, int requestCode) {
 390          try {
 391              activity.startActivityForResult(intent, requestCode);
 392          } catch (ActivityNotFoundException e) {
 393              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 394          } catch (SecurityException e) {
 395              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 396              Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 397                      &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 398                      &quot;or use the exported attribute for this activity.&quot;, e);
 399          }
 400      }
 401  
 402      static boolean isSystemApp(Context context, Intent intent) {
 403          PackageManager pm = context.getPackageManager();
 404          ComponentName cn = intent.getComponent();
 405          String packageName = null;
 406          if (cn == null) {
 407              ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 408              if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 409                  packageName = info.activityInfo.packageName;
 410              }
 411          } else {
 412              packageName = cn.getPackageName();
 413          }
 414          if (packageName != null) {
 415              try {
 416                  PackageInfo info = pm.getPackageInfo(packageName, 0);
 417                  return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 418                          ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 419              } catch (NameNotFoundException e) {
 420                  return false;
 421              }
 422          } else {
 423              return false;
 424          }
 425      }
 426  
 427      /**
 428       * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 429       * @param bitmap The bitmap to scan
 430       * @param samples The approximate max number of samples to use.
 431       */
 432      static int findDominantColorByHue(Bitmap bitmap, int samples) {
 433          final int height = bitmap.getHeight();
 434          final int width = bitmap.getWidth();
 435          int sampleStride = (int) Math.sqrt((height * width) / samples);
 436          if (sampleStride &lt; 1) {
 437              sampleStride = 1;
 438          }
 439  
 440          // This is an out-param, for getting the hsv values for an rgb
 441          float[] hsv = new float[3];
 442  
 443          // First get the best hue, by creating a histogram over 360 hue buckets,
 444          // where each pixel contributes a score weighted by saturation, value, and alpha.
 445          float[] hueScoreHistogram = new float[360];
 446          float highScore = -1;
 447          int bestHue = -1;
 448  
 449          for (int y = 0; y &lt; height; y += sampleStride) {
 450              for (int x = 0; x &lt; width; x += sampleStride) {
 451                  int argb = bitmap.getPixel(x, y);
 452                  int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 453                  if (alpha &lt; 0x80) {
 454                      // Drop mostly-transparent pixels.
 455                      continue;
 456                  }
 457                  // Remove the alpha channel.
 458                  int rgb = argb | 0xFF000000;
 459                  Color.colorToHSV(rgb, hsv);
 460                  // Bucket colors by the 360 integer hues.
 461                  int hue = (int) hsv[0];
 462                  if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 463                      // Defensively avoid array bounds violations.
 464                      continue;
 465                  }
 466                  float score = hsv[1] * hsv[2];
 467                  hueScoreHistogram[hue] += score;
 468                  if (hueScoreHistogram[hue] &gt; highScore) {
 469                      highScore = hueScoreHistogram[hue];
 470                      bestHue = hue;
 471                  }
 472              }
 473          }
 474  
 475          SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 476          int bestColor = 0xff000000;
 477          highScore = -1;
 478          // Go back over the RGB colors that match the winning hue,
 479          // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 480          // The highest-scoring RGB color wins.
 481          for (int y = 0; y &lt; height; y += sampleStride) {
 482              for (int x = 0; x &lt; width; x += sampleStride) {
 483                  int rgb = bitmap.getPixel(x, y) | 0xff000000;
 484                  Color.colorToHSV(rgb, hsv);
 485                  int hue = (int) hsv[0];
 486                  if (hue == bestHue) {
 487                      float s = hsv[1];
 488                      float v = hsv[2];
 489                      int bucket = (int) (s * 100) + (int) (v * 10000);
 490                      // Score by cumulative saturation * value.
 491                      float score = s * v;
 492                      Float oldTotal = rgbScores.get(bucket);
 493                      float newTotal = oldTotal == null ? score : oldTotal + score;
 494                      rgbScores.put(bucket, newTotal);
 495                      if (newTotal &gt; highScore) {
 496                          highScore = newTotal;
 497                          // All the colors in the winning bucket are very similar. Last in wins.
 498                          bestColor = rgb;
 499                      }
 500                  }
 501              }
 502          }
 503          return bestColor;
 504      }
 505  
 506      /*
 507       * Finds a system apk which had a broadcast receiver listening to a particular action.
 508       * @param action intent action used to find the apk
 509       * @return a pair of apk package name and the resources.
 510       */
 511      static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 512          final Intent intent = new Intent(action);
 513          for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 514              if (info.activityInfo != null &amp;&amp;
 515                      (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 516                  final String packageName = info.activityInfo.packageName;
 517                  try {
 518                      final Resources res = pm.getResourcesForApplication(packageName);
 519                      return Pair.create(packageName, res);
 520                  } catch (NameNotFoundException e) {
 521                      Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 522                  }
 523              }
 524          }
 525          return null;
 526      }
 527  
 528      @TargetApi(Build.VERSION_CODES.KITKAT)
 529      public static boolean isViewAttachedToWindow(View v) {
 530          if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 531              return v.isAttachedToWindow();
 532          } else {
 533              // A proxy call which returns null, if the view is not attached to the window.
 534              return v.getKeyDispatcherState() != null;
 535          }
 536      }
 537  
 538      /**
 539       * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 540       * provided by the same package which is set to be global search activity.
 541       * If widgetCategory is not supported, or no such widget is found, returns the first widget
 542       * provided by the package.
 543       */
 544      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 545      public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 546          SearchManager searchManager =
 547                  (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 548          ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 549          if (searchComponent == null) return null;
 550          String providerPkg = searchComponent.getPackageName();
 551  
 552          AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 553  
 554          AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 555          for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 556              if (info.provider.getPackageName().equals(providerPkg)) {
 557                  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 558                      if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 559                          return info;
 560                      } else if (defaultWidgetForSearchPackage == null) {
 561                          defaultWidgetForSearchPackage = info;
 562                      }
 563                  } else {
 564                      return info;
 565                  }
 566              }
 567          }
 568          return defaultWidgetForSearchPackage;
 569      }
 570  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 571 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 572 +     * Compresses the bitmap to a byte array for serialization.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 573 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 574 +    public static byte[] flattenBitmap(Bitmap bitmap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +        // Try go guesstimate how much space the icon will take when serialized</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +        // to avoid unnecessary allocations/copies during the write.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +        int size = bitmap.getWidth() * bitmap.getHeight() * 4;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +        ByteArrayOutputStream out = new ByteArrayOutputStream(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +            out.flush();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +            out.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 583 +            return out.toByteArray();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 584 +        } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 585 +            Log.w(TAG, &quot;Could not write bitmap&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 586 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 587 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 588 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 589 +</span>
 590      public static final Comparator&lt;ItemInfo&gt; RANK_COMPARATOR = new Comparator&lt;ItemInfo&gt;() {
 591  
 592          @Override
 593          public int compare(ItemInfo lhs, ItemInfo rhs) {
 594              return lhs.rank - rhs.rank;
 595          }
 596      };
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 597 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 598 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +     * Find the first vacant cell, if there is one.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +     * @param vacant Holds the x and y coordinate of the vacant cell</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +     * @param spanX Horizontal cell span.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +     * @param spanY Vertical cell span.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +     * @return true if a vacant cell was found</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +    public static boolean findVacantCell(int[] vacant, int spanX, int spanY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +            int xCount, int yCount, boolean[][] occupied) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +        for (int y = 0; (y + spanY) &lt;= yCount; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +            for (int x = 0; (x + spanX) &lt;= xCount; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +                boolean available = !occupied[x][y];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 613 +                out:            for (int i = x; i &lt; x + spanX; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +                    for (int j = y; j &lt; y + spanY; j++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +                        available = available &amp;&amp; !occupied[i][j];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 616 +                        if (!available) break out;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +                if (available) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 621 +                    vacant[0] = x;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 622 +                    vacant[1] = y;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 623 +                    return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 624 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 626 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 627 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 628 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 631 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 632 +     * Trims the string, removing all whitespace at the beginning and end of the string.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 633 +     * Non-breaking whitespaces are also removed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +    public static String trim(CharSequence s) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +        if (s == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 639 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 640 +        // Just strip any sequence of whitespace or java space characters from the beginning and end</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +        Matcher m = sTrimPattern.matcher(s);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +        return m.replaceAll(&quot;$1&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 643 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 646 +    public static boolean isRtl(Resources res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 647 +        return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +    public static void assertWorkerThread() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +        if (LauncherAppState.isDogfoodBuild()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +            Assert.assertTrue(LauncherModel.sWorkerThread.getThreadId() == Process.myTid());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +     * Returns true if the intent is a valid launch intent for a launcher activity of an app.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +     * This is used to identify shortcuts which are different from the ones exposed by the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +     * applications&#x27; manifest file.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +     * @param launchIntent The intent that will be launched when the shortcut is clicked.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +    public static boolean isLauncherAppTarget(Intent launchIntent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +        return launchIntent != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                &amp;&amp; launchIntent.getComponent() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                &amp;&amp; launchIntent.getCategories() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                &amp;&amp; launchIntent.getCategories().size() == 1</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                &amp;&amp; launchIntent.getExtras() == null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +    public static float dpiFromPx(int size, DisplayMetrics metrics){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +        float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +        return (size / densityRatio);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 679 +    public static int pxFromDp(float size, DisplayMetrics metrics) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 680 +        return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +                size, metrics));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 682 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 683 +    public static int pxFromSp(float size, DisplayMetrics metrics) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 684 +        return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 685 +                size, metrics));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +    }</span>
 687  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.annotation.TargetApi;
  20  import android.app.Activity;
  21  import android.app.SearchManager;
  22  import android.appwidget.AppWidgetManager;
  23  import android.appwidget.AppWidgetProviderInfo;
  24  import android.content.ActivityNotFoundException;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.ApplicationInfo;
  29  import android.content.pm.PackageInfo;
  30  import android.content.pm.PackageManager;
  31  import android.content.pm.PackageManager.NameNotFoundException;
  32  import android.content.pm.ResolveInfo;
  33  import android.content.res.Resources;

  34  import android.graphics.Bitmap;

  35  import android.graphics.Canvas;
  36  import android.graphics.Color;
  37  import android.graphics.Matrix;
  38  import android.graphics.Paint;
  39  import android.graphics.PaintFlagsDrawFilter;
  40  import android.graphics.Rect;
  41  import android.graphics.drawable.BitmapDrawable;
  42  import android.graphics.drawable.Drawable;
  43  import android.graphics.drawable.PaintDrawable;
  44  import android.os.Build;



  45  import android.util.Log;
  46  import android.util.Pair;
  47  import android.util.SparseArray;

  48  import android.view.View;
  49  import android.widget.Toast;
  50  




  51  import java.util.ArrayList;
  52  import java.util.Comparator;


  53  
  54  /**
  55   * Various utilities shared amongst the Launcher&#x27;s classes.
  56   */
  57  public final class Utilities {
  58      private static final String TAG = &quot;Launcher.Utilities&quot;;
  59  
  60      private static int sIconWidth = -1;
  61      private static int sIconHeight = -1;
  62  
  63      private static final Rect sOldBounds = new Rect();
  64      private static final Canvas sCanvas = new Canvas();
  65  



  66      static {
  67          sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  68                  Paint.FILTER_BITMAP_FLAG));
  69      }
  70      static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  71      static int sColorIndex = 0;
  72  
  73      static int[] sLoc0 = new int[2];
  74      static int[] sLoc1 = new int[2];
  75  
  76      // To turn on these properties, type
  77      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  78      static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  79      public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  80  
  81      /**
  82       * Returns a FastBitmapDrawable with the icon, accurately sized.
  83       */
  84      public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
  85          FastBitmapDrawable d = new FastBitmapDrawable(icon);
  86          d.setFilterBitmap(true);
  87          resizeIconDrawable(d);
  88          return d;
  89      }
  90  
  91      /**
  92       * Resizes an icon drawable to the correct icon size.
  93       */
  94      static void resizeIconDrawable(Drawable icon) {
  95          icon.setBounds(0, 0, sIconWidth, sIconHeight);
  96      }
  97  
  98      public static boolean isPropertyEnabled(String propertyName) {
  99          return Log.isLoggable(propertyName, Log.VERBOSE);
 100      }
 101  
 102      public static boolean isRotationEnabled(Context c) {
 103          boolean enableRotation = sForceEnableRotation ||
 104                  c.getResources().getBoolean(R.bool.allow_rotation);
 105          return enableRotation;
 106      }
 107  
 108      /**
 109       * Indicates if the device is running LMP or higher.
 110       */
 111      public static boolean isLmpOrAbove() {
 112          return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;









 113      }
 114  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +    public static boolean isLmpMr1() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +        return Build.VERSION.SDK_INT == 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +</span>
 119      /**
 120       * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 121       * exist, it returns null.
 122       */
 123      static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,
 124              Context context) {
 125          PackageManager packageManager = context.getPackageManager();
 126          // the resource
 127          try {
 128              Resources resources = packageManager.getResourcesForApplication(packageName);
 129              if (resources != null) {
 130                  final int id = resources.getIdentifier(resourceName, null, null);
 131                  return createIconBitmap(
 132                          resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);
 133              }
 134          } catch (Exception e) {
 135              // Icon not found.
 136          }
 137          return null;
 138      }
 139  
 140      /**
 141       * Returns a bitmap which is of the appropriate size to be displayed as an icon
 142       */
 143      static Bitmap createIconBitmap(Bitmap icon, Context context) {
 144          synchronized (sCanvas) { // we share the statics :-(
 145              if (sIconWidth == -1) {
 146                  initStatics(context);
 147              }
 148          }
 149          if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {
 150              return icon;
 151          }
 152          return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 153      }
 154  
 155      /**
 156       * Returns a bitmap suitable for the all apps view.
 157       */
 158      public static Bitmap createIconBitmap(Drawable icon, Context context) {
 159          synchronized (sCanvas) { // we share the statics :-(
 160              if (sIconWidth == -1) {
 161                  initStatics(context);
 162              }
 163  
 164              int width = sIconWidth;
 165              int height = sIconHeight;
 166  
 167              if (icon instanceof PaintDrawable) {
 168                  PaintDrawable painter = (PaintDrawable) icon;
 169                  painter.setIntrinsicWidth(width);
 170                  painter.setIntrinsicHeight(height);
 171              } else if (icon instanceof BitmapDrawable) {
 172                  // Ensure the bitmap has a density.
 173                  BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 174                  Bitmap bitmap = bitmapDrawable.getBitmap();
 175                  if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 176                      bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 177                  }
 178              }
 179              int sourceWidth = icon.getIntrinsicWidth();
 180              int sourceHeight = icon.getIntrinsicHeight();
 181              if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 182                  // Scale the icon proportionally to the icon dimensions
 183                  final float ratio = (float) sourceWidth / sourceHeight;
 184                  if (sourceWidth &gt; sourceHeight) {
 185                      height = (int) (width / ratio);
 186                  } else if (sourceHeight &gt; sourceWidth) {
 187                      width = (int) (height * ratio);
 188                  }
 189              }
 190  
 191              // no intrinsic size --&gt; use default size
 192              int textureWidth = sIconWidth;
 193              int textureHeight = sIconHeight;
 194  
 195              final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 196                      Bitmap.Config.ARGB_8888);
 197              final Canvas canvas = sCanvas;
 198              canvas.setBitmap(bitmap);
 199  
 200              final int left = (textureWidth-width) / 2;
 201              final int top = (textureHeight-height) / 2;
 202  
 203              @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 204              final boolean debug = false;
 205              if (debug) {
 206                  // draw a big box for the icon for debugging
 207                  canvas.drawColor(sColors[sColorIndex]);
 208                  if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 209                  Paint debugPaint = new Paint();
 210                  debugPaint.setColor(0xffcccc00);
 211                  canvas.drawRect(left, top, left+width, top+height, debugPaint);
 212              }
 213  
 214              sOldBounds.set(icon.getBounds());
 215              icon.setBounds(left, top, left+width, top+height);
 216              icon.draw(canvas);
 217              icon.setBounds(sOldBounds);
 218              canvas.setBitmap(null);
 219  
 220              return bitmap;
 221          }
 222      }
 223  
 224      /**
 225       * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 226       * coordinates.
 227       *
 228       * @param descendant The descendant to which the passed coordinate is relative.
 229       * @param root The root view to make the coordinates relative to.
 230       * @param coord The coordinate that we want mapped.
 231       * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 232       *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 233       * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 234       *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 235       *         assumption fails, we will need to return a pair of scale factors.
 236       */
 237      public static float getDescendantCoordRelativeToParent(View descendant, View root,
 238                                                             int[] coord, boolean includeRootScroll) {
 239          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 240  
 241          float[] pt = {coord[0], coord[1]};
 242  
 243          View v = descendant;
 244          while(v != root &amp;&amp; v != null) {
 245              ancestorChain.add(v);
 246              v = (View) v.getParent();
 247          }
 248          ancestorChain.add(root);
 249  
 250          float scale = 1.0f;
 251          int count = ancestorChain.size();
 252          for (int i = 0; i &lt; count; i++) {
 253              View v0 = ancestorChain.get(i);
 254              // For TextViews, scroll has a meaning which relates to the text position
 255              // which is very strange... ignore the scroll.
 256              if (v0 != descendant || includeRootScroll) {
 257                  pt[0] -= v0.getScrollX();
 258                  pt[1] -= v0.getScrollY();
 259              }
 260  
 261              v0.getMatrix().mapPoints(pt);
 262              pt[0] += v0.getLeft();
 263              pt[1] += v0.getTop();
 264              scale *= v0.getScaleX();
 265          }
 266  
 267          coord[0] = (int) Math.round(pt[0]);
 268          coord[1] = (int) Math.round(pt[1]);
 269          return scale;
 270      }
 271  
 272      /**
 273       * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 274       */
 275      public static float mapCoordInSelfToDescendent(View descendant, View root,
 276                                                     int[] coord) {
 277          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 278  
 279          float[] pt = {coord[0], coord[1]};
 280  
 281          View v = descendant;
 282          while(v != root) {
 283              ancestorChain.add(v);
 284              v = (View) v.getParent();
 285          }
 286          ancestorChain.add(root);
 287  
 288          float scale = 1.0f;
 289          Matrix inverse = new Matrix();
 290          int count = ancestorChain.size();
 291          for (int i = count - 1; i &gt;= 0; i--) {
 292              View ancestor = ancestorChain.get(i);
 293              View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 294  
 295              pt[0] += ancestor.getScrollX();
 296              pt[1] += ancestor.getScrollY();
 297  
 298              if (next != null) {
 299                  pt[0] -= next.getLeft();
 300                  pt[1] -= next.getTop();
 301                  next.getMatrix().invert(inverse);
 302                  inverse.mapPoints(pt);
 303                  scale *= next.getScaleX();
 304              }
 305          }
 306  
 307          coord[0] = (int) Math.round(pt[0]);
 308          coord[1] = (int) Math.round(pt[1]);
 309          return scale;
 310      }
 311  
 312      /**
 313       * Utility method to determine whether the given point, in local coordinates,
 314       * is inside the view, where the area of the view is expanded by the slop factor.
 315       * This method is called while processing touch-move events to determine if the event
 316       * is still within the view.
 317       */
 318      public static boolean pointInView(View v, float localX, float localY, float slop) {
 319          return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 320                  localY &lt; (v.getHeight() + slop);
 321      }
 322  
 323      private static void initStatics(Context context) {
 324          final Resources resources = context.getResources();
 325          sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 326      }
 327  
 328      public static void setIconSize(int widthPx) {
 329          sIconWidth = sIconHeight = widthPx;
 330      }
 331  
 332      public static void scaleRect(Rect r, float scale) {
 333          if (scale != 1.0f) {
 334              r.left = (int) (r.left * scale + 0.5f);
 335              r.top = (int) (r.top * scale + 0.5f);
 336              r.right = (int) (r.right * scale + 0.5f);
 337              r.bottom = (int) (r.bottom * scale + 0.5f);
 338          }
 339      }
 340  
 341      public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 342          v0.getLocationInWindow(sLoc0);
 343          v1.getLocationInWindow(sLoc1);
 344  
 345          sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 346          sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 347          sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 348          sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 349  
 350          if (delta == null) {
 351              delta = new int[2];
 352          }
 353  
 354          delta[0] = sLoc1[0] - sLoc0[0];
 355          delta[1] = sLoc1[1] - sLoc0[1];
 356  
 357          return delta;
 358      }
 359  
 360      public static void scaleRectAboutCenter(Rect r, float scale) {
 361          int cx = r.centerX();
 362          int cy = r.centerY();
 363          r.offset(-cx, -cy);
 364          Utilities.scaleRect(r, scale);
 365          r.offset(cx, cy);
 366      }
 367  
 368      public static void startActivityForResultSafely(
 369              Activity activity, Intent intent, int requestCode) {
 370          try {
 371              activity.startActivityForResult(intent, requestCode);
 372          } catch (ActivityNotFoundException e) {
 373              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 374          } catch (SecurityException e) {
 375              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 376              Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 377                      &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 378                      &quot;or use the exported attribute for this activity.&quot;, e);
 379          }
 380      }
 381  
 382      static boolean isSystemApp(Context context, Intent intent) {
 383          PackageManager pm = context.getPackageManager();
 384          ComponentName cn = intent.getComponent();
 385          String packageName = null;
 386          if (cn == null) {
 387              ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 388              if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 389                  packageName = info.activityInfo.packageName;
 390              }
 391          } else {
 392              packageName = cn.getPackageName();
 393          }
 394          if (packageName != null) {
 395              try {
 396                  PackageInfo info = pm.getPackageInfo(packageName, 0);
 397                  return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 398                          ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 399              } catch (NameNotFoundException e) {
 400                  return false;
 401              }
 402          } else {
 403              return false;
 404          }
 405      }
 406  
 407      /**
 408       * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 409       * @param bitmap The bitmap to scan
 410       * @param samples The approximate max number of samples to use.
 411       */
 412      static int findDominantColorByHue(Bitmap bitmap, int samples) {
 413          final int height = bitmap.getHeight();
 414          final int width = bitmap.getWidth();
 415          int sampleStride = (int) Math.sqrt((height * width) / samples);
 416          if (sampleStride &lt; 1) {
 417              sampleStride = 1;
 418          }
 419  
 420          // This is an out-param, for getting the hsv values for an rgb
 421          float[] hsv = new float[3];
 422  
 423          // First get the best hue, by creating a histogram over 360 hue buckets,
 424          // where each pixel contributes a score weighted by saturation, value, and alpha.
 425          float[] hueScoreHistogram = new float[360];
 426          float highScore = -1;
 427          int bestHue = -1;
 428  
 429          for (int y = 0; y &lt; height; y += sampleStride) {
 430              for (int x = 0; x &lt; width; x += sampleStride) {
 431                  int argb = bitmap.getPixel(x, y);
 432                  int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 433                  if (alpha &lt; 0x80) {
 434                      // Drop mostly-transparent pixels.
 435                      continue;
 436                  }
 437                  // Remove the alpha channel.
 438                  int rgb = argb | 0xFF000000;
 439                  Color.colorToHSV(rgb, hsv);
 440                  // Bucket colors by the 360 integer hues.
 441                  int hue = (int) hsv[0];
 442                  if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 443                      // Defensively avoid array bounds violations.
 444                      continue;
 445                  }
 446                  float score = hsv[1] * hsv[2];
 447                  hueScoreHistogram[hue] += score;
 448                  if (hueScoreHistogram[hue] &gt; highScore) {
 449                      highScore = hueScoreHistogram[hue];
 450                      bestHue = hue;
 451                  }
 452              }
 453          }
 454  
 455          SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 456          int bestColor = 0xff000000;
 457          highScore = -1;
 458          // Go back over the RGB colors that match the winning hue,
 459          // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 460          // The highest-scoring RGB color wins.
 461          for (int y = 0; y &lt; height; y += sampleStride) {
 462              for (int x = 0; x &lt; width; x += sampleStride) {
 463                  int rgb = bitmap.getPixel(x, y) | 0xff000000;
 464                  Color.colorToHSV(rgb, hsv);
 465                  int hue = (int) hsv[0];
 466                  if (hue == bestHue) {
 467                      float s = hsv[1];
 468                      float v = hsv[2];
 469                      int bucket = (int) (s * 100) + (int) (v * 10000);
 470                      // Score by cumulative saturation * value.
 471                      float score = s * v;
 472                      Float oldTotal = rgbScores.get(bucket);
 473                      float newTotal = oldTotal == null ? score : oldTotal + score;
 474                      rgbScores.put(bucket, newTotal);
 475                      if (newTotal &gt; highScore) {
 476                          highScore = newTotal;
 477                          // All the colors in the winning bucket are very similar. Last in wins.
 478                          bestColor = rgb;
 479                      }
 480                  }
 481              }
 482          }
 483          return bestColor;
 484      }
 485  
 486      /*
 487       * Finds a system apk which had a broadcast receiver listening to a particular action.
 488       * @param action intent action used to find the apk
 489       * @return a pair of apk package name and the resources.
 490       */
 491      static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 492          final Intent intent = new Intent(action);
 493          for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 494              if (info.activityInfo != null &amp;&amp;
 495                      (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 496                  final String packageName = info.activityInfo.packageName;
 497                  try {
 498                      final Resources res = pm.getResourcesForApplication(packageName);
 499                      return Pair.create(packageName, res);
 500                  } catch (NameNotFoundException e) {
 501                      Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 502                  }
 503              }
 504          }
 505          return null;
 506      }
 507  
 508      @TargetApi(Build.VERSION_CODES.KITKAT)
 509      public static boolean isViewAttachedToWindow(View v) {
 510          if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 511              return v.isAttachedToWindow();
 512          } else {
 513              // A proxy call which returns null, if the view is not attached to the window.
 514              return v.getKeyDispatcherState() != null;
 515          }
 516      }
 517  
 518      /**
 519       * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 520       * provided by the same package which is set to be global search activity.
 521       * If widgetCategory is not supported, or no such widget is found, returns the first widget
 522       * provided by the package.
 523       */
 524      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 525      public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 526          SearchManager searchManager =
 527                  (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 528          ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 529          if (searchComponent == null) return null;
 530          String providerPkg = searchComponent.getPackageName();
 531  
 532          AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 533  
 534          AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 535          for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 536              if (info.provider.getPackageName().equals(providerPkg)) {
 537                  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 538                      if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 539                          return info;
 540                      } else if (defaultWidgetForSearchPackage == null) {
 541                          defaultWidgetForSearchPackage = info;
 542                      }
 543                  } else {
 544                      return info;
 545                  }
 546              }
 547          }
 548          return defaultWidgetForSearchPackage;
 549      }
 550  



















 551      public static final Comparator&lt;ItemInfo&gt; RANK_COMPARATOR = new Comparator&lt;ItemInfo&gt;() {
 552  
 553          @Override
 554          public int compare(ItemInfo lhs, ItemInfo rhs) {
 555              return lhs.rank - rhs.rank;
 556          }
 557      };


























































































 558  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            