<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>375</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    375
                    <a href="374.html">prev</a>
                    <a href="376.html">next</a>
                    <a href="375_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_29923f5082093b6211894f49edc653c29b28d99b_WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b:WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b^1:WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b^2:WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05:WallpaperPicker/src/com/android/launcher3/WallpaperPickerActivity.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.Animator;
  20 import android.animation.LayoutTransition;
  21 import android.annotation.TargetApi;
  22 import android.app.ActionBar;
  23 import android.app.Activity;
  24 import android.app.WallpaperInfo;
  25 import android.app.WallpaperManager;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.pm.ApplicationInfo;
  29 import android.content.pm.PackageManager;
  30 import android.content.res.Resources;
  31 import android.database.Cursor;
  32 import android.database.DataSetObserver;
  33 import android.graphics.Bitmap;
  34 import android.graphics.BitmapFactory;
  35 import android.graphics.Canvas;
  36 import android.graphics.Matrix;
  37 import android.graphics.Paint;
  38 import android.graphics.Point;
  39 import android.graphics.PorterDuff;
  40 import android.graphics.Rect;
  41 import android.graphics.RectF;
  42 import android.graphics.drawable.BitmapDrawable;
  43 import android.graphics.drawable.Drawable;
  44 import android.graphics.drawable.LevelListDrawable;
  45 import android.net.Uri;
  46 import android.os.AsyncTask;
  47 import android.os.Build;
  48 import android.os.Bundle;
  49 import android.provider.MediaStore;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import android.view.ActionMode;
  53 import android.view.LayoutInflater;
  54 import android.view.Menu;
  55 import android.view.MenuInflater;
  56 import android.view.MenuItem;
  57 import android.view.View;
  58 import android.view.View.OnClickListener;
  59 import android.view.View.OnLayoutChangeListener;
  60 import android.view.ViewGroup;
  61 import android.view.ViewPropertyAnimator;
  62 import android.view.ViewTreeObserver;
  63 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  64 import android.view.animation.AccelerateInterpolator;
  65 import android.view.animation.DecelerateInterpolator;
  66 import android.widget.ArrayAdapter;
  67 import android.widget.BaseAdapter;
  68 import android.widget.FrameLayout;
  69 import android.widget.HorizontalScrollView;
  70 import android.widget.ImageView;
  71 import android.widget.LinearLayout;
  72 import android.widget.Toast;
  73 
  74 import com.android.photos.BitmapRegionTileSource;
  75 import com.android.photos.BitmapRegionTileSource.BitmapSource;
  76 
  77 import java.io.File;
  78 import java.io.FileOutputStream;
  79 import java.io.IOException;
  80 import java.util.ArrayList;
  81 
  82 public class WallpaperPickerActivity extends WallpaperCropActivity {
  83     static final String TAG = &quot;Launcher.WallpaperPickerActivity&quot;;
  84 
  85     public static final int IMAGE_PICK = 5;
  86     public static final int PICK_WALLPAPER_THIRD_PARTY_ACTIVITY = 6;
  87     public static final int PICK_LIVE_WALLPAPER = 7;
  88     private static final String TEMP_WALLPAPER_TILES = &quot;TEMP_WALLPAPER_TILES&quot;;
  89     private static final String SELECTED_INDEX = &quot;SELECTED_INDEX&quot;;
  90     private static final String OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb.jpg&quot;;
  91     private static final String DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb2.jpg&quot;;
  92 
  93     private View mSelectedTile;
  94     private View mSetWallpaperButton;
  95     private boolean mIgnoreNextTap;
  96     private OnClickListener mThumbnailOnClickListener;
  97 
  98     private LinearLayout mWallpapersView;
  99     private View mWallpaperStrip;
 100 
 101     private ActionMode.Callback mActionModeCallback;
 102     private ActionMode mActionMode;
 103 
 104     private View.OnLongClickListener mLongClickListener;
 105 
 106     ArrayList&lt;Uri&gt; mTempWallpaperTiles = new ArrayList&lt;Uri&gt;();
 107     private SavedWallpaperImages mSavedImages;
 108     private WallpaperInfo mLiveWallpaperInfoOnPickerLaunch;
 109     private int mSelectedIndex;
 110 
 111     public static abstract class WallpaperTileInfo {
 112         protected View mView;
 113         public Drawable mThumb;
 114 
 115         public void setView(View v) {
 116             mView = v;
 117         }
 118         public void onClick(WallpaperPickerActivity a) {}
 119         public void onSave(WallpaperPickerActivity a) {}
 120         public void onDelete(WallpaperPickerActivity a) {}
 121         public boolean isSelectable() { return false; }
 122         public boolean isNamelessWallpaper() { return false; }
 123         public void onIndexUpdated(CharSequence label) {
 124             if (isNamelessWallpaper()) {
 125                 mView.setContentDescription(label);
 126             }
 127         }
 128     }
 129 
 130     public static class PickImageInfo extends WallpaperTileInfo {
 131         @Override
 132         public void onClick(WallpaperPickerActivity a) {
 133             Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
 134             intent.setType(&quot;image/*&quot;);
 135             a.startActivityForResultSafely(intent, IMAGE_PICK);
 136         }
 137     }
 138 
 139     public static class UriWallpaperInfo extends WallpaperTileInfo {
 140         private Uri mUri;
 141         private boolean mFirstClick = true;
 142         private BitmapRegionTileSource.UriBitmapSource mBitmapSource;
 143         public UriWallpaperInfo(Uri uri) {
 144             mUri = uri;
 145         }
 146         @Override
 147         public void onClick(final WallpaperPickerActivity a) {
 148             final Runnable onLoad;
 149             if (!mFirstClick) {
 150                 onLoad = null;
 151             } else {
 152                 mFirstClick = false;
 153                 a.mSetWallpaperButton.setVisibility(View.INVISIBLE);
 154                 onLoad = new Runnable() {
 155                     public void run() {
 156                         if (mBitmapSource != null &amp;&amp;
 157                                 mBitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
 158                             a.selectTile(mView);
 159                             a.mSetWallpaperButton.setVisibility(View.VISIBLE);
 160                         } else {
 161                             ViewGroup parent = (ViewGroup) mView.getParent();
 162                             if (parent != null) {
 163                                 parent.removeView(mView);
 164                                 Toast.makeText(a,
 165                                         a.getString(R.string.image_load_fail),
 166                                         Toast.LENGTH_SHORT).show();
 167                             }
 168                         }
 169                     }
 170                 };
 171             }
 172             mBitmapSource = new BitmapRegionTileSource.UriBitmapSource(
 173                     a, mUri, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 174             a.setCropViewTileSource(mBitmapSource, true, false, onLoad);
 175         }
 176         @Override
 177         public void onSave(final WallpaperPickerActivity a) {
 178             boolean finishActivityWhenDone = true;
 179             OnBitmapCroppedHandler h = new OnBitmapCroppedHandler() {
 180                 public void onBitmapCropped(byte[] imageBytes) {
 181                     Point thumbSize = getDefaultThumbnailSize(a.getResources());
 182                     // rotation is set to 0 since imageBytes has already been correctly rotated
 183                     Bitmap thumb = createThumbnail(
 184                             thumbSize, null, null, imageBytes, null, 0, 0, true);
 185                     a.getSavedImages().writeImage(thumb, imageBytes);
 186                 }
 187             };
 188             a.cropImageAndSetWallpaper(mUri, h, finishActivityWhenDone);
 189         }
 190         @Override
 191         public boolean isSelectable() {
 192             return true;
 193         }
 194         @Override
 195         public boolean isNamelessWallpaper() {
 196             return true;
 197         }
 198     }
 199 
 200     public static class FileWallpaperInfo extends WallpaperTileInfo {
 201         private File mFile;
 202 
 203         public FileWallpaperInfo(File target, Drawable thumb) {
 204             mFile = target;
 205             mThumb = thumb;
 206         }
 207         @Override
 208         public void onClick(WallpaperPickerActivity a) {
 209             BitmapRegionTileSource.UriBitmapSource bitmapSource =
 210                     new BitmapRegionTileSource.UriBitmapSource(a, Uri.fromFile(mFile), 1024);
 211             a.setCropViewTileSource(bitmapSource, false, true, null);
 212         }
 213         @Override
 214         public void onSave(WallpaperPickerActivity a) {
 215             a.setWallpaper(Uri.fromFile(mFile), true);
 216         }
 217         @Override
 218         public boolean isSelectable() {
 219             return true;
 220         }
 221         @Override
 222         public boolean isNamelessWallpaper() {
 223             return true;
 224         }
 225     }
 226 
 227     public static class ResourceWallpaperInfo extends WallpaperTileInfo {
 228         private Resources mResources;
 229         private int mResId;
 230 
 231         public ResourceWallpaperInfo(Resources res, int resId, Drawable thumb) {
 232             mResources = res;
 233             mResId = resId;
 234             mThumb = thumb;
 235         }
 236         @Override
 237         public void onClick(WallpaperPickerActivity a) {
 238             BitmapRegionTileSource.ResourceBitmapSource bitmapSource =
 239                     new BitmapRegionTileSource.ResourceBitmapSource(
 240                             mResources, mResId, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 241             bitmapSource.loadInBackground();
 242             BitmapRegionTileSource source = new BitmapRegionTileSource(a, bitmapSource);
 243             CropView v = a.getCropView();
 244             v.setTileSource(source, null);
 245             Point wallpaperSize = WallpaperCropActivity.getDefaultWallpaperSize(
 246                     a.getResources(), a.getWindowManager());
 247             RectF crop = WallpaperCropActivity.getMaxCropRect(
 248                     source.getImageWidth(), source.getImageHeight(),
 249                     wallpaperSize.x, wallpaperSize.y, false);
 250             v.setScale(wallpaperSize.x / crop.width());
 251             v.setTouchEnabled(false);
 252         }
 253         @Override
 254         public void onSave(WallpaperPickerActivity a) {
 255             boolean finishActivityWhenDone = true;
 256             a.cropImageAndSetWallpaper(mResources, mResId, finishActivityWhenDone);
 257         }
 258         @Override
 259         public boolean isSelectable() {
 260             return true;
 261         }
 262         @Override
 263         public boolean isNamelessWallpaper() {
 264             return true;
 265         }
 266     }
 267 
 268     @TargetApi(Build.VERSION_CODES.KITKAT)
 269     public static class DefaultWallpaperInfo extends WallpaperTileInfo {
 270         public DefaultWallpaperInfo(Drawable thumb) {
 271             mThumb = thumb;
 272         }
 273         @Override
 274         public void onClick(WallpaperPickerActivity a) {
 275             CropView c = a.getCropView();
 276 
 277             Drawable defaultWallpaper = WallpaperManager.getInstance(a).getBuiltInDrawable(
 278                     c.getWidth(), c.getHeight(), false, 0.5f, 0.5f);
 279 
 280             c.setTileSource(
<abbr title=" 281                     new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), null);"> 281                     new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), nulðŸ”µ</abbr>
 282             c.setScale(1f);
 283             c.setTouchEnabled(false);
 284         }
 285         @Override
 286         public void onSave(WallpaperPickerActivity a) {
 287             try {
 288                 WallpaperManager.getInstance(a).clear();
 289             } catch (IOException e) {
 290                 Log.w(&quot;Setting wallpaper to default threw exception&quot;, e);
 291             }
 292             a.finish();
 293         }
 294         @Override
 295         public boolean isSelectable() {
 296             return true;
 297         }
 298         @Override
 299         public boolean isNamelessWallpaper() {
 300             return true;
 301         }
 302     }
 303 
 304     public void setWallpaperStripYOffset(float offset) {
 305         mWallpaperStrip.setPadding(0, 0, 0, (int) offset);
 306     }
 307 
 308     // called by onCreate; this is subclassed to overwrite WallpaperCropActivity
 309     protected void init() {
 310         setContentView(R.layout.wallpaper_picker);
 311 
 312         mCropView = (CropView) findViewById(R.id.cropView);
 313         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 314         mCropView.setTouchCallback(new CropView.TouchCallback() {
 315             ViewPropertyAnimator mAnim;
 316             @Override
 317             public void onTouchDown() {
 318                 if (mAnim != null) {
 319                     mAnim.cancel();
 320                 }
 321                 if (mWallpaperStrip.getAlpha() == 1f) {
 322                     mIgnoreNextTap = true;
 323                 }
 324                 mAnim = mWallpaperStrip.animate();
 325                 mAnim.alpha(0f)
 326                     .setDuration(150)
 327                     .withEndAction(new Runnable() {
 328                         public void run() {
 329                             mWallpaperStrip.setVisibility(View.INVISIBLE);
 330                         }
 331                     });
 332                 mAnim.setInterpolator(new AccelerateInterpolator(0.75f));
 333                 mAnim.start();
 334             }
 335             @Override
 336             public void onTouchUp() {
 337                 mIgnoreNextTap = false;
 338             }
 339             @Override
 340             public void onTap() {
 341                 boolean ignoreTap = mIgnoreNextTap;
 342                 mIgnoreNextTap = false;
 343                 if (!ignoreTap) {
 344                     if (mAnim != null) {
 345                         mAnim.cancel();
 346                     }
 347                     mWallpaperStrip.setVisibility(View.VISIBLE);
 348                     mAnim = mWallpaperStrip.animate();
 349                     mAnim.alpha(1f)
 350                          .setDuration(150)
 351                          .setInterpolator(new DecelerateInterpolator(0.75f));
 352                     mAnim.start();
 353                 }
 354             }
 355         });
 356 
 357         mThumbnailOnClickListener = new OnClickListener() {
 358             public void onClick(View v) {
 359                 if (mActionMode != null) {
 360                     // When CAB is up, clicking toggles the item instead
 361                     if (v.isLongClickable()) {
 362                         mLongClickListener.onLongClick(v);
 363                     }
 364                     return;
 365                 }
 366                 WallpaperTileInfo info = (WallpaperTileInfo) v.getTag();
 367                 if (info.isSelectable() &amp;&amp; v.getVisibility() == View.VISIBLE) {
 368                     selectTile(v);
 369                 }
 370                 info.onClick(WallpaperPickerActivity.this);
 371             }
 372         };
 373         mLongClickListener = new View.OnLongClickListener() {
 374             // Called when the user long-clicks on someView
 375             public boolean onLongClick(View view) {
 376                 CheckableFrameLayout c = (CheckableFrameLayout) view;
 377                 c.toggle();
 378 
 379                 if (mActionMode != null) {
 380                     mActionMode.invalidate();
 381                 } else {
 382                     // Start the CAB using the ActionMode.Callback defined below
 383                     mActionMode = startActionMode(mActionModeCallback);
 384                     int childCount = mWallpapersView.getChildCount();
 385                     for (int i = 0; i &lt; childCount; i++) {
 386                         mWallpapersView.getChildAt(i).setSelected(false);
 387                     }
 388                 }
 389                 return true;
 390             }
 391         };
 392 
 393         // Populate the built-in wallpapers
 394         ArrayList&lt;WallpaperTileInfo&gt; wallpapers = findBundledWallpapers();
 395         mWallpapersView = (LinearLayout) findViewById(R.id.wallpaper_list);
 396         SimpleWallpapersAdapter ia = new SimpleWallpapersAdapter(this, wallpapers);
 397         populateWallpapersFromAdapter(mWallpapersView, ia, false);
 398 
 399         // Populate the saved wallpapers
 400         mSavedImages = new SavedWallpaperImages(this);
 401         mSavedImages.loadThumbnailsAndImageIdList();
 402         populateWallpapersFromAdapter(mWallpapersView, mSavedImages, true);
 403 
 404         // Populate the live wallpapers
 405         final LinearLayout liveWallpapersView =
 406                 (LinearLayout) findViewById(R.id.live_wallpaper_list);
 407         final LiveWallpaperListAdapter a = new LiveWallpaperListAdapter(this);
 408         a.registerDataSetObserver(new DataSetObserver() {
 409             public void onChanged() {
 410                 liveWallpapersView.removeAllViews();
 411                 populateWallpapersFromAdapter(liveWallpapersView, a, false);
 412                 initializeScrollForRtl();
 413                 updateTileIndices();
 414             }
 415         });
 416 
 417         // Populate the third-party wallpaper pickers
 418         final LinearLayout thirdPartyWallpapersView =
 419                 (LinearLayout) findViewById(R.id.third_party_wallpaper_list);
 420         final ThirdPartyWallpaperPickerListAdapter ta =
 421                 new ThirdPartyWallpaperPickerListAdapter(this);
 422         populateWallpapersFromAdapter(thirdPartyWallpapersView, ta, false);
 423 
 424         // Add a tile for the Gallery
 425         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 426         FrameLayout pickImageTile = (FrameLayout) getLayoutInflater().
 427                 inflate(R.layout.wallpaper_picker_image_picker_item, masterWallpaperList, false);
 428         setWallpaperItemPaddingToZero(pickImageTile);
 429         masterWallpaperList.addView(pickImageTile, 0);
 430 
 431         // Make its background the last photo taken on external storage
 432         Bitmap lastPhoto = getThumbnailOfLastPhoto();
 433         if (lastPhoto != null) {
 434             ImageView galleryThumbnailBg =
 435                     (ImageView) pickImageTile.findViewById(R.id.wallpaper_image);
 436             galleryThumbnailBg.setImageBitmap(getThumbnailOfLastPhoto());
 437             int colorOverlay = getResources().getColor(R.color.wallpaper_picker_translucent_gray);
 438             galleryThumbnailBg.setColorFilter(colorOverlay, PorterDuff.Mode.SRC_ATOP);
 439 
 440         }
 441 
 442         PickImageInfo pickImageInfo = new PickImageInfo();
 443         pickImageTile.setTag(pickImageInfo);
 444         pickImageInfo.setView(pickImageTile);
 445         pickImageTile.setOnClickListener(mThumbnailOnClickListener);
 446 
 447 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 448 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 449 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 450                 if (mActionMode != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 451                     mActionMode.invalidate();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 452                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 453                     // Start the CAB using the ActionMode.Callback defined below</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454                     mActionMode = startActionMode(mActionModeCallback);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 455                     int childCount = mWallpapersView.getChildCount();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456                     for (int i = 0; i &lt; childCount; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 457                         mWallpapersView.getChildAt(i).setSelected(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 458                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 459                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 460                 return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 461             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 462         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 463 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464         // Populate the built-in wallpapers</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 465         ArrayList&lt;ResourceWallpaperInfo&gt; wallpapers = findBundledWallpapers();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 466         mWallpapersView = (LinearLayout) findViewById(R.id.wallpaper_list);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467         BuiltInWallpapersAdapter ia = new BuiltInWallpapersAdapter(this, wallpapers);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468         populateWallpapersFromAdapter(mWallpapersView, ia, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470         // Populate the saved wallpapers</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471         mSavedImages = new SavedWallpaperImages(this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472         mSavedImages.loadThumbnailsAndImageIdList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473         populateWallpapersFromAdapter(mWallpapersView, mSavedImages, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475         // Populate the live wallpapers</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476         final LinearLayout liveWallpapersView =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477                 (LinearLayout) findViewById(R.id.live_wallpaper_list);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478         final LiveWallpaperListAdapter a = new LiveWallpaperListAdapter(this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479         a.registerDataSetObserver(new DataSetObserver() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             public void onChanged() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481                 liveWallpapersView.removeAllViews();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482                 populateWallpapersFromAdapter(liveWallpapersView, a, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483                 initializeScrollForRtl();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484                 updateTileIndices();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486         });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488         // Populate the third-party wallpaper pickers</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489         final LinearLayout thirdPartyWallpapersView =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490                 (LinearLayout) findViewById(R.id.third_party_wallpaper_list);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491         final ThirdPartyWallpaperPickerListAdapter ta =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 492                 new ThirdPartyWallpaperPickerListAdapter(this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 493         populateWallpapersFromAdapter(thirdPartyWallpapersView, ta, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 494 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 495         // Add a tile for the Gallery</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 496         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 497         FrameLayout pickImageTile = (FrameLayout) getLayoutInflater().</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 498                 inflate(R.layout.wallpaper_picker_image_picker_item, masterWallpaperList, false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 499         setWallpaperItemPaddingToZero(pickImageTile);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 500         masterWallpaperList.addView(pickImageTile, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 501 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 502         // Make its background the last photo taken on external storage</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 503         Bitmap lastPhoto = getThumbnailOfLastPhoto();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 504         if (lastPhoto != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 505             ImageView galleryThumbnailBg =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 506                     (ImageView) pickImageTile.findViewById(R.id.wallpaper_image);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 507             galleryThumbnailBg.setImageBitmap(getThumbnailOfLastPhoto());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508             int colorOverlay = getResources().getColor(R.color.wallpaper_picker_translucent_gray);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509             galleryThumbnailBg.setColorFilter(colorOverlay, PorterDuff.Mode.SRC_ATOP);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513         PickImageInfo pickImageInfo = new PickImageInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514         pickImageTile.setTag(pickImageInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 515         pickImageInfo.setView(pickImageTile);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516         pickImageTile.setOnClickListener(mThumbnailOnClickListener);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518         // Add a tile for the default wallpaper</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520             DefaultWallpaperInfo defaultWallpaperInfo = getDefaultWallpaper();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521             if (defaultWallpaperInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522                 FrameLayout defaultWallpaperTile = (FrameLayout) createImageTileView(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523                         getLayoutInflater(), 0, null, mWallpapersView, defaultWallpaperInfo.mThumb);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 524                 setWallpaperItemPaddingToZero(defaultWallpaperTile);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 525                 defaultWallpaperTile.setTag(defaultWallpaperInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 526                 mWallpapersView.addView(defaultWallpaperTile, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 527                 defaultWallpaperTile.setOnClickListener(mThumbnailOnClickListener);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 528                 defaultWallpaperInfo.setView(defaultWallpaperTile);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 529             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 530         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 531 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532         // Select the first item; wait for a layout pass so that we initialize the dimensions of</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533         // cropView or the defaultWallpaperView first</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534         mCropView.addOnLayoutChangeListener(new OnLayoutChangeListener() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536             public void onLayoutChange(View v, int left, int top, int right, int bottom,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537                     int oldLeft, int oldTop, int oldRight, int oldBottom) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538                 if ((right - left) &gt; 0 &amp;&amp; (bottom - top) &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539                     if (mSelectedIndex &gt;= 0 &amp;&amp; mSelectedIndex &lt; mWallpapersView.getChildCount()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540                         mThumbnailOnClickListener.onClick(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541                                 mWallpapersView.getChildAt(mSelectedIndex));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542                         setSystemWallpaperVisiblity(false);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 544                     v.removeOnLayoutChangeListener(this);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 545                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 546             }</span>
 547 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 548         // Add a tile for the default wallpaper</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 549         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 550             DefaultWallpaperInfo defaultWallpaperInfo = getDefaultWallpaper();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 551             FrameLayout defaultWallpaperTile = (FrameLayout) createImageTileView(</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 552                     getLayoutInflater(), 0, null, mWallpapersView, defaultWallpaperInfo.mThumb);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 553             setWallpaperItemPaddingToZero(defaultWallpaperTile);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 554             defaultWallpaperTile.setTag(defaultWallpaperInfo);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 555             mWallpapersView.addView(defaultWallpaperTile, 0);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 556             defaultWallpaperTile.setOnClickListener(mThumbnailOnClickListener);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 557             defaultWallpaperInfo.setView(defaultWallpaperTile);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 558         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 559 </span>
 560 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 561         // Select the first item; wait for a layout pass so that we initialize the dimensions of
 562         // cropView or the defaultWallpaperView first
 563         mCropView.addOnLayoutChangeListener(new OnLayoutChangeListener() {
 564             @Override
 565             public void onLayoutChange(View v, int left, int top, int right, int bottom,
 566                     int oldLeft, int oldTop, int oldRight, int oldBottom) {
 567                 if ((right - left) &gt; 0 &amp;&amp; (bottom - top) &gt; 0) {
 568                     if (mSelectedIndex &gt;= 0 &amp;&amp; mSelectedIndex &lt; mWallpapersView.getChildCount()) {
 569                         mThumbnailOnClickListener.onClick(
 570                                 mWallpapersView.getChildAt(mSelectedIndex));
 571                     }
 572                     v.removeOnLayoutChangeListener(this);
 573                 }
 574             }
 575         });
 576 
 577         updateTileIndices();
 578 
 579         // Update the scroll for RTL
 580         initializeScrollForRtl();
 581 
 582         // Create smooth layout transitions for when items are deleted
 583         final LayoutTransition transitioner = new LayoutTransition();
 584         transitioner.setDuration(200);
 585         transitioner.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 0);
 586         transitioner.setAnimator(LayoutTransition.DISAPPEARING, null);
 587         mWallpapersView.setLayoutTransition(transitioner);
 588 
 589         // Action bar
 590         // Show the custom action bar view
 591         final ActionBar actionBar = getActionBar();
 592         actionBar.setCustomView(R.layout.actionbar_set_wallpaper);
 593         actionBar.getCustomView().setOnClickListener(
 594                 new View.OnClickListener() {
 595                     @Override
 596                     public void onClick(View v) {
 597                         if (mSelectedTile != null) {
 598                             WallpaperTileInfo info = (WallpaperTileInfo) mSelectedTile.getTag();
 599                             info.onSave(WallpaperPickerActivity.this);
 600                         }
 601                     }
 602                 });
 603         mSetWallpaperButton = findViewById(R.id.set_wallpaper_button);
 604 
 605         // CAB for deleting items
 606         mActionModeCallback = new ActionMode.Callback() {
 607             // Called when the action mode is created; startActionMode() was called
 608             @Override
 609             public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 610                 // Inflate a menu resource providing context menu items
 611                 MenuInflater inflater = mode.getMenuInflater();
 612                 inflater.inflate(R.menu.cab_delete_wallpapers, menu);
 613                 return true;
 614             }
 615 
 616             private int numCheckedItems() {
 617                 int childCount = mWallpapersView.getChildCount();
 618                 int numCheckedItems = 0;
 619                 for (int i = 0; i &lt; childCount; i++) {
 620                     CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 621                     if (c.isChecked()) {
 622                         numCheckedItems++;
 623                     }
 624                 }
 625                 return numCheckedItems;
 626             }
 627 
 628             // Called each time the action mode is shown. Always called after onCreateActionMode,
 629             // but may be called multiple times if the mode is invalidated.
 630             @Override
 631             public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 632                 int numCheckedItems = numCheckedItems();
 633                 if (numCheckedItems == 0) {
 634                     mode.finish();
 635                     return true;
 636                 } else {
 637                     mode.setTitle(getResources().getQuantityString(
 638                             R.plurals.number_of_items_selected, numCheckedItems, numCheckedItems));
 639                     return true;
 640                 }
 641             }
 642 
 643             // Called when the user selects a contextual menu item
 644             @Override
 645             public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 646                 int itemId = item.getItemId();
 647                 if (itemId == R.id.menu_delete) {
 648                     int childCount = mWallpapersView.getChildCount();
 649                     ArrayList&lt;View&gt; viewsToRemove = new ArrayList&lt;View&gt;();
 650                     for (int i = 0; i &lt; childCount; i++) {
 651                         CheckableFrameLayout c =
 652                                 (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 653                         if (c.isChecked()) {
 654                             WallpaperTileInfo info = (WallpaperTileInfo) c.getTag();
 655                             info.onDelete(WallpaperPickerActivity.this);
 656                             viewsToRemove.add(c);
 657                         }
 658                     }
 659                     for (View v : viewsToRemove) {
 660                         mWallpapersView.removeView(v);
 661                     }
 662                     updateTileIndices();
 663                     mode.finish(); // Action picked, so close the CAB
 664                     return true;
 665                 } else {
 666                     return false;
 667                 }
 668             }
 669 
 670             // Called when the user exits the action mode
 671             @Override
 672             public void onDestroyActionMode(ActionMode mode) {
 673                 int childCount = mWallpapersView.getChildCount();
 674                 for (int i = 0; i &lt; childCount; i++) {
 675                     CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 676                     c.setChecked(false);
 677                 }
 678                 mSelectedTile.setSelected(true);
 679                 mActionMode = null;
 680             }
 681         };
 682     }
 683 
 684     private void selectTile(View v) {
 685         if (mSelectedTile != null) {
 686             mSelectedTile.setSelected(false);
 687             mSelectedTile = null;
 688         }
 689         mSelectedTile = v;
 690         v.setSelected(true);
 691         mSelectedIndex = mWallpapersView.indexOfChild(v);
 692         // TODO: Remove this once the accessibility framework and
 693         // services have better support for selection state.
 694         v.announceForAccessibility(
 695                 getString(R.string.announce_selection, v.getContentDescription()));
 696     }
 697 
 698     private void initializeScrollForRtl() {
 699         final HorizontalScrollView scroll =
 700                 (HorizontalScrollView) findViewById(R.id.wallpaper_scroll_container);
 701 
 702         if (scroll.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
 703             final ViewTreeObserver observer = scroll.getViewTreeObserver();
 704             observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
 705                 public void onGlobalLayout() {
 706                     LinearLayout masterWallpaperList =
 707                             (LinearLayout) findViewById(R.id.master_wallpaper_list);
 708                     scroll.scrollTo(masterWallpaperList.getWidth(), 0);
 709                     scroll.getViewTreeObserver().removeOnGlobalLayoutListener(this);
 710                 }
 711             });
 712         }
 713     }
 714 
 715     protected Bitmap getThumbnailOfLastPhoto() {
 716         Cursor cursor = MediaStore.Images.Media.query(getContentResolver(),
 717                 MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
 718                 new String[] { MediaStore.Images.ImageColumns._ID,
 719                     MediaStore.Images.ImageColumns.DATE_TAKEN},
 720                 null, null, MediaStore.Images.ImageColumns.DATE_TAKEN + &quot; DESC LIMIT 1&quot;);
 721 
 722         Bitmap thumb = null;
 723         if (cursor != null) {
 724             if (cursor.moveToNext()) {
 725                 int id = cursor.getInt(0);
 726                 thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(),
 727                         id, MediaStore.Images.Thumbnails.MINI_KIND, null);
 728             }
 729             cursor.close();
 730         }
 731         return thumb;
 732     }
 733 
 734     protected void onStop() {
 735         super.onStop();
 736         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 737         if (mWallpaperStrip.getAlpha() &lt; 1f) {
 738             mWallpaperStrip.setAlpha(1f);
 739             mWallpaperStrip.setVisibility(View.VISIBLE);
 740         }
 741     }
 742 
 743     protected void onSaveInstanceState(Bundle outState) {
 744         outState.putParcelableArrayList(TEMP_WALLPAPER_TILES, mTempWallpaperTiles);
 745         outState.putInt(SELECTED_INDEX, mSelectedIndex);
 746     }
 747 
 748     protected void onRestoreInstanceState(Bundle savedInstanceState) {
 749         ArrayList&lt;Uri&gt; uris = savedInstanceState.getParcelableArrayList(TEMP_WALLPAPER_TILES);
 750         for (Uri uri : uris) {
 751             addTemporaryWallpaperTile(uri, true);
 752         }
 753         mSelectedIndex = savedInstanceState.getInt(SELECTED_INDEX, 0);
 754     }
 755 
 756     private void populateWallpapersFromAdapter(ViewGroup parent, BaseAdapter adapter,
 757             boolean addLongPressHandler) {
 758         for (int i = 0; i &lt; adapter.getCount(); i++) {
 759             FrameLayout thumbnail = (FrameLayout) adapter.getView(i, null, parent);
 760             parent.addView(thumbnail, i);
 761             WallpaperTileInfo info = (WallpaperTileInfo) adapter.getItem(i);
 762             thumbnail.setTag(info);
 763             info.setView(thumbnail);
 764             if (addLongPressHandler) {
 765                 addLongPressHandler(thumbnail);
 766             }
 767             thumbnail.setOnClickListener(mThumbnailOnClickListener);
 768         }
 769     }
 770 
 771     private void updateTileIndices() {
 772         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 773         final int childCount = masterWallpaperList.getChildCount();
 774         final Resources res = getResources();
 775 
 776         // Do two passes; the first pass gets the total number of tiles
 777         int numTiles = 0;
 778         for (int passNum = 0; passNum &lt; 2; passNum++) {
 779             int tileIndex = 0;
 780             for (int i = 0; i &lt; childCount; i++) {
 781                 View child = masterWallpaperList.getChildAt(i);
 782                 LinearLayout subList;
 783 
 784                 int subListStart;
 785                 int subListEnd;
 786                 if (child.getTag() instanceof WallpaperTileInfo) {
 787                     subList = masterWallpaperList;
 788                     subListStart = i;
 789                     subListEnd = i + 1;
 790                 } else { // if (child instanceof LinearLayout) {
 791                     subList = (LinearLayout) child;
 792                     subListStart = 0;
 793                     subListEnd = subList.getChildCount();
 794                 }
 795 
 796                 for (int j = subListStart; j &lt; subListEnd; j++) {
 797                     WallpaperTileInfo info = (WallpaperTileInfo) subList.getChildAt(j).getTag();
 798                     if (info.isNamelessWallpaper()) {
 799                         if (passNum == 0) {
 800                             numTiles++;
 801                         } else {
 802                             CharSequence label = res.getString(
 803                                     R.string.wallpaper_accessibility_name, ++tileIndex, numTiles);
 804                             info.onIndexUpdated(label);
 805                         }
 806                     }
 807                 }
 808             }
 809         }
 810     }
 811 
 812     private static Point getDefaultThumbnailSize(Resources res) {
 813         return new Point(res.getDimensionPixelSize(R.dimen.wallpaperThumbnailWidth),
 814                 res.getDimensionPixelSize(R.dimen.wallpaperThumbnailHeight));
 815 
 816     }
 817 
 818     private static Bitmap createThumbnail(Point size, Context context, Uri uri, byte[] imageBytes,
 819             Resources res, int resId, int rotation, boolean leftAligned) {
 820         int width = size.x;
 821         int height = size.y;
 822 
 823         BitmapCropTask cropTask;
 824         if (uri != null) {
 825             cropTask = new BitmapCropTask(
 826                     context, uri, null, rotation, width, height, false, true, null);
 827         } else if (imageBytes != null) {
 828             cropTask = new BitmapCropTask(
 829                     imageBytes, null, rotation, width, height, false, true, null);
 830         }  else {
 831             cropTask = new BitmapCropTask(
 832                     context, res, resId, null, rotation, width, height, false, true, null);
 833         }
 834         Point bounds = cropTask.getImageBounds();
 835         if (bounds == null || bounds.x == 0 || bounds.y == 0) {
 836             return null;
 837         }
 838 
 839         Matrix rotateMatrix = new Matrix();
 840         rotateMatrix.setRotate(rotation);
 841         float[] rotatedBounds = new float[] { bounds.x, bounds.y };
 842         rotateMatrix.mapPoints(rotatedBounds);
 843         rotatedBounds[0] = Math.abs(rotatedBounds[0]);
 844         rotatedBounds[1] = Math.abs(rotatedBounds[1]);
 845 
 846         RectF cropRect = WallpaperCropActivity.getMaxCropRect(
 847                 (int) rotatedBounds[0], (int) rotatedBounds[1], width, height, leftAligned);
 848         cropTask.setCropBounds(cropRect);
 849 
 850         if (cropTask.cropBitmap()) {
 851             return cropTask.getCroppedBitmap();
 852         } else {
 853             return null;
 854         }
 855     }
 856 
 857     private void addTemporaryWallpaperTile(final Uri uri, boolean fromRestore) {
 858         mTempWallpaperTiles.add(uri);
 859         // Add a tile for the image picked from Gallery
 860         final FrameLayout pickedImageThumbnail = (FrameLayout) getLayoutInflater().
 861                 inflate(R.layout.wallpaper_picker_item, mWallpapersView, false);
 862         pickedImageThumbnail.setVisibility(View.GONE);
 863         setWallpaperItemPaddingToZero(pickedImageThumbnail);
 864         mWallpapersView.addView(pickedImageThumbnail, 0);
 865 
 866         // Load the thumbnail
 867         final ImageView image = (ImageView) pickedImageThumbnail.findViewById(R.id.wallpaper_image);
 868         final Point defaultSize = getDefaultThumbnailSize(this.getResources());
 869         final Context context = this;
 870         new AsyncTask&lt;Void, Bitmap, Bitmap&gt;() {
 871             protected Bitmap doInBackground(Void...args) {
 872                 try {
 873                     int rotation = WallpaperCropActivity.getRotationFromExif(context, uri);
 874                     return createThumbnail(defaultSize, context, uri, null, null, 0, rotation, false);
 875                 } catch (SecurityException securityException) {
 876                     if (isDestroyed()) {
 877                         // Temporarily granted permissions are revoked when the activity
 878                         // finishes, potentially resulting in a SecurityException here.
 879                         // Even though {@link #isDestroyed} might also return true in different
 880                         // situations where the configuration changes, we are fine with
 881                         // catching these cases here as well.
 882                         cancel(false);
 883                     } else {
 884                         // otherwise it had a different cause and we throw it further
 885                         throw securityException;
 886                     }
 887                     return null;
 888                 }
 889             }
 890             protected void onPostExecute(Bitmap thumb) {
 891                 if (!isCancelled() &amp;&amp; thumb != null) {
 892                     image.setImageBitmap(thumb);
 893                     Drawable thumbDrawable = image.getDrawable();
 894                     thumbDrawable.setDither(true);
 895                     pickedImageThumbnail.setVisibility(View.VISIBLE);
 896                 } else {
 897                     Log.e(TAG, &quot;Error loading thumbnail for uri=&quot; + uri);
 898                 }
 899             }
 900         }.execute();
 901 
 902         UriWallpaperInfo info = new UriWallpaperInfo(uri);
 903         pickedImageThumbnail.setTag(info);
 904         info.setView(pickedImageThumbnail);
 905         addLongPressHandler(pickedImageThumbnail);
 906         updateTileIndices();
 907         pickedImageThumbnail.setOnClickListener(mThumbnailOnClickListener);
 908         if (!fromRestore) {
 909             mThumbnailOnClickListener.onClick(pickedImageThumbnail);
 910         }
 911     }
 912 
 913     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 914         if (requestCode == IMAGE_PICK &amp;&amp; resultCode == RESULT_OK) {
 915             if (data != null &amp;&amp; data.getData() != null) {
 916                 Uri uri = data.getData();
 917                 addTemporaryWallpaperTile(uri, false);
 918             }
 919         } else if (requestCode == PICK_WALLPAPER_THIRD_PARTY_ACTIVITY) {
 920             setResult(RESULT_OK);
 921             finish();
 922         } else if (requestCode == PICK_LIVE_WALLPAPER) {
 923             WallpaperManager wm = WallpaperManager.getInstance(this);
 924             final WallpaperInfo oldLiveWallpaper = mLiveWallpaperInfoOnPickerLaunch;
 925             WallpaperInfo newLiveWallpaper = wm.getWallpaperInfo();
 926             // Try to figure out if a live wallpaper was set;
 927             if (newLiveWallpaper != null &amp;&amp;
 928                     (oldLiveWallpaper == null ||
 929                     !oldLiveWallpaper.getComponent().equals(newLiveWallpaper.getComponent()))) {
 930                 // Return if a live wallpaper was set
 931                 setResult(RESULT_OK);
 932                 finish();
 933             }
 934         }
 935     }
 936 
 937     static void setWallpaperItemPaddingToZero(FrameLayout frameLayout) {
 938         frameLayout.setPadding(0, 0, 0, 0);
 939         frameLayout.setForeground(new ZeroPaddingDrawable(frameLayout.getForeground()));
 940     }
 941 
 942     private void addLongPressHandler(View v) {
 943         v.setOnLongClickListener(mLongClickListener);
 944     }
 945 
 946     private ArrayList&lt;WallpaperTileInfo&gt; findBundledWallpapers() {
 947         final PackageManager pm = getPackageManager();
 948         final ArrayList&lt;WallpaperTileInfo&gt; bundled = new ArrayList&lt;WallpaperTileInfo&gt;(24);
 949 
 950         Partner partner = Partner.get(pm);
 951         if (partner != null) {
 952             final Resources partnerRes = partner.getResources();
 953             final int resId = partnerRes.getIdentifier(Partner.RES_WALLPAPERS, &quot;array&quot;,
 954                     partner.getPackageName());
 955             if (resId != 0) {
 956                 addWallpapers(bundled, partnerRes, partner.getPackageName(), resId);
 957             }
 958 
 959             // Add system wallpapers
 960             File systemDir = partner.getWallpaperDirectory();
 961             if (systemDir != null &amp;&amp; systemDir.isDirectory()) {
 962                 for (File file : systemDir.listFiles()) {
 963                     if (!file.isFile()) {
 964                         continue;
 965                     }
 966                     String name = file.getName();
 967                     int dotPos = name.lastIndexOf(&#x27;.&#x27;);
 968                     String extension = &quot;&quot;;
 969                     if (dotPos &gt;= -1) {
 970                         extension = name.substring(dotPos);
 971                         name = name.substring(0, dotPos);
 972                     }
 973 
 974                     if (name.endsWith(&quot;_small&quot;)) {
 975                         // it is a thumbnail
 976                         continue;
 977                     }
 978 
 979                     File thumbnail = new File(systemDir, name + &quot;_small&quot; + extension);
 980                     Bitmap thumb = BitmapFactory.decodeFile(thumbnail.getAbsolutePath());
 981                     if (thumb != null) {
 982                         bundled.add(new FileWallpaperInfo(file, new BitmapDrawable(thumb)));
 983                     }
 984                 }
 985             }
 986         }
 987 
 988         Pair&lt;ApplicationInfo, Integer&gt; r = getWallpaperArrayResourceId();
 989         if (r != null) {
 990             try {
 991                 Resources wallpaperRes = getPackageManager().getResourcesForApplication(r.first);
 992                 addWallpapers(bundled, wallpaperRes, r.first.packageName, r.second);
 993             } catch (PackageManager.NameNotFoundException e) {
 994             }
 995         }
 996 
 997         if (partner == null || !partner.hideDefaultWallpaper()) {
 998             // Add an entry for the default wallpaper (stored in system resources)
 999             WallpaperTileInfo defaultWallpaperInfo =
1000                     (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT)
1001                     ? getPreKKDefaultWallpaperInfo()
1002                     : getDefaultWallpaper();
1003             if (defaultWallpaperInfo != null) {
1004                 bundled.add(0, defaultWallpaperInfo);
1005             }
1006         }
1007         return bundled;
1008     }
1009 
1010     private boolean writeImageToFileAsJpeg(File f, Bitmap b) {
1011         try {
1012             f.createNewFile();
1013             FileOutputStream thumbFileStream =
1014                     openFileOutput(f.getName(), Context.MODE_PRIVATE);
1015             b.compress(Bitmap.CompressFormat.JPEG, 95, thumbFileStream);
1016             thumbFileStream.close();
1017             return true;
1018         } catch (IOException e) {
1019             Log.e(TAG, &quot;Error while writing bitmap to file &quot; + e);
1020             f.delete();
1021         }
1022         return false;
1023     }
1024 
1025     private File getDefaultThumbFile() {
1026         return new File(getFilesDir(), Build.VERSION.SDK_INT
1027                 + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);
1028     }
1029 
1030     private boolean saveDefaultWallpaperThumb(Bitmap b) {
1031         // Delete old thumbnails.
1032         new File(getFilesDir(), OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1033         new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1034 
1035         for (int i = Build.VERSION_CODES.JELLY_BEAN; i &lt; Build.VERSION.SDK_INT; i++) {
1036             new File(getFilesDir(), i + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1037         }
1038         return writeImageToFileAsJpeg(getDefaultThumbFile(), b);
1039     }
1040 
1041     private ResourceWallpaperInfo getPreKKDefaultWallpaperInfo() {
1042         Resources sysRes = Resources.getSystem();
1043         int resId = sysRes.getIdentifier(&quot;default_wallpaper&quot;, &quot;drawable&quot;, &quot;android&quot;);
1044 
1045         File defaultThumbFile = getDefaultThumbFile();
1046         Bitmap thumb = null;
1047         boolean defaultWallpaperExists = false;
1048         if (defaultThumbFile.exists()) {
1049             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1050             defaultWallpaperExists = true;
1051         } else {
1052             Resources res = getResources();
1053             Point defaultThumbSize = getDefaultThumbnailSize(res);
1054             int rotation = WallpaperCropActivity.getRotationFromExif(res, resId);
1055             thumb = createThumbnail(
1056                     defaultThumbSize, this, null, null, sysRes, resId, rotation, false);
1057             if (thumb != null) {
1058                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1059             }
1060         }
1061         if (defaultWallpaperExists) {
1062             return new ResourceWallpaperInfo(sysRes, resId, new BitmapDrawable(thumb));
1063         }
1064         return null;
1065     }
1066 
1067     @TargetApi(Build.VERSION_CODES.KITKAT)
1068     private DefaultWallpaperInfo getDefaultWallpaper() {
1069         File defaultThumbFile = getDefaultThumbFile();
1070         Bitmap thumb = null;
1071         boolean defaultWallpaperExists = false;
1072         if (defaultThumbFile.exists()) {
1073             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1074             defaultWallpaperExists = true;
1075         } else {
1076             Resources res = getResources();
1077             Point defaultThumbSize = getDefaultThumbnailSize(res);
1078             Drawable wallpaperDrawable = WallpaperManager.getInstance(this).getBuiltInDrawable(
1079                     defaultThumbSize.x, defaultThumbSize.y, true, 0.5f, 0.5f);
1080             if (wallpaperDrawable != null) {
1081                 thumb = Bitmap.createBitmap(
1082                         defaultThumbSize.x, defaultThumbSize.y, Bitmap.Config.ARGB_8888);
1083                 Canvas c = new Canvas(thumb);
1084                 wallpaperDrawable.setBounds(0, 0, defaultThumbSize.x, defaultThumbSize.y);
1085                 wallpaperDrawable.draw(c);
1086                 c.setBitmap(null);
1087             }
1088             if (thumb != null) {
1089                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1090             }
1091         }
1092         if (defaultWallpaperExists) {
1093             return new DefaultWallpaperInfo(new BitmapDrawable(thumb));
1094         }
1095         return null;
1096     }
1097 
1098     public Pair&lt;ApplicationInfo, Integer&gt; getWallpaperArrayResourceId() {
1099         // Context.getPackageName() may return the &quot;original&quot; package name,
1100         // com.android.launcher3; Resources needs the real package name,
1101         // com.android.launcher3. So we ask Resources for what it thinks the
1102         // package name should be.
1103         final String packageName = getResources().getResourcePackageName(R.array.wallpapers);
1104         try {
1105             ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, 0);
1106             return new Pair&lt;ApplicationInfo, Integer&gt;(info, R.array.wallpapers);
1107         } catch (PackageManager.NameNotFoundException e) {
1108             return null;
1109         }
1110     }
1111 
1112     private void addWallpapers(ArrayList&lt;WallpaperTileInfo&gt; known, Resources res,
1113             String packageName, int listResId) {
1114         final String[] extras = res.getStringArray(listResId);
1115         for (String extra : extras) {
1116             int resId = res.getIdentifier(extra, &quot;drawable&quot;, packageName);
1117             if (resId != 0) {
1118                 final int thumbRes = res.getIdentifier(extra + &quot;_small&quot;, &quot;drawable&quot;, packageName);
1119 
1120                 if (thumbRes != 0) {
1121                     ResourceWallpaperInfo wallpaperInfo =
1122                             new ResourceWallpaperInfo(res, resId, res.getDrawable(thumbRes));
1123                     known.add(wallpaperInfo);
1124                     // Log.d(TAG, &quot;add: [&quot; + packageName + &quot;]: &quot; + extra + &quot; (&quot; + res + &quot;)&quot;);
1125                 }
1126             } else {
1127                 Log.e(TAG, &quot;Couldn&#x27;t find wallpaper &quot; + extra);
1128             }
1129         }
1130     }
1131 
1132     public CropView getCropView() {
1133         return mCropView;
1134     }
1135 
1136     public SavedWallpaperImages getSavedImages() {
1137         return mSavedImages;
1138     }
1139 
1140     public void onLiveWallpaperPickerLaunch() {
1141         mLiveWallpaperInfoOnPickerLaunch = WallpaperManager.getInstance(this).getWallpaperInfo();
1142     }
1143 
1144     static class ZeroPaddingDrawable extends LevelListDrawable {
1145         public ZeroPaddingDrawable(Drawable d) {
1146             super();
1147             addLevel(0, 0, d);
1148             setLevel(0);
1149         }
1150 
1151         @Override
1152         public boolean getPadding(Rect padding) {
1153             padding.set(0, 0, 0, 0);
1154             return true;
1155         }
1156     }
1157 
1158     private static class SimpleWallpapersAdapter extends ArrayAdapter&lt;WallpaperTileInfo&gt; {
1159         private final LayoutInflater mLayoutInflater;
1160 
1161         SimpleWallpapersAdapter(Activity activity, ArrayList&lt;WallpaperTileInfo&gt; wallpapers) {
1162             super(activity, R.layout.wallpaper_picker_item, wallpapers);
1163             mLayoutInflater = activity.getLayoutInflater();
1164         }
1165 
1166         public View getView(int position, View convertView, ViewGroup parent) {
1167             Drawable thumb = getItem(position).mThumb;
1168             if (thumb == null) {
1169                 Log.e(TAG, &quot;Error decoding thumbnail for wallpaper #&quot; + position);
1170             }
1171             return createImageTileView(mLayoutInflater, convertView, parent, thumb);
1172         }
1173     }
1174 
1175     public static View createImageTileView(LayoutInflater layoutInflater,
1176             View convertView, ViewGroup parent, Drawable thumb) {
1177         View view;
1178 
1179         if (convertView == null) {
1180             view = layoutInflater.inflate(R.layout.wallpaper_picker_item, parent, false);
1181         } else {
1182             view = convertView;
1183         }
1184 
1185         setWallpaperItemPaddingToZero((FrameLayout) view);
1186 
1187         ImageView image = (ImageView) view.findViewById(R.id.wallpaper_image);
1188 
1189         if (thumb != null) {
1190             image.setImageDrawable(thumb);
1191             thumb.setDither(true);
1192         }
1193 
1194         return view;
1195     }
1196 
1197     // In Launcher3, we override this with a method that catches exceptions
1198     // from starting activities; didn&#x27;t want to copy and paste code into here
1199     public void startActivityForResultSafely(Intent intent, int requestCode) {
1200         startActivityForResult(intent, requestCode);
1201     }
1202 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.LayoutTransition;
  20 import android.annotation.TargetApi;
  21 import android.app.ActionBar;
  22 import android.app.Activity;
  23 import android.app.WallpaperInfo;
  24 import android.app.WallpaperManager;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.pm.ApplicationInfo;
  28 import android.content.pm.PackageManager;
  29 import android.content.res.Resources;
  30 import android.database.Cursor;
  31 import android.database.DataSetObserver;
  32 import android.graphics.Bitmap;
  33 import android.graphics.BitmapFactory;
  34 import android.graphics.Canvas;
  35 import android.graphics.Matrix;
  36 import android.graphics.Point;
  37 import android.graphics.PorterDuff;
  38 import android.graphics.Rect;
  39 import android.graphics.RectF;
  40 import android.graphics.drawable.BitmapDrawable;
  41 import android.graphics.drawable.Drawable;
  42 import android.graphics.drawable.LevelListDrawable;
  43 import android.net.Uri;
  44 import android.os.AsyncTask;
  45 import android.os.Build;
  46 import android.os.Bundle;
  47 import android.provider.MediaStore;
  48 import android.util.Log;
  49 import android.util.Pair;
  50 import android.view.ActionMode;
  51 import android.view.LayoutInflater;
  52 import android.view.Menu;
  53 import android.view.MenuInflater;
  54 import android.view.MenuItem;
  55 import android.view.View;
  56 import android.view.View.OnClickListener;
  57 import android.view.View.OnLayoutChangeListener;
  58 import android.view.ViewGroup;
  59 import android.view.ViewPropertyAnimator;
  60 import android.view.ViewTreeObserver;
  61 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  62 import android.view.WindowManager;
  63 import android.view.animation.AccelerateInterpolator;
  64 import android.view.animation.DecelerateInterpolator;
  65 import android.widget.ArrayAdapter;
  66 import android.widget.BaseAdapter;
  67 import android.widget.FrameLayout;
  68 import android.widget.HorizontalScrollView;
  69 import android.widget.ImageView;
  70 import android.widget.LinearLayout;
  71 import android.widget.Toast;
  72 
  73 import com.android.photos.BitmapRegionTileSource;
  74 import com.android.photos.BitmapRegionTileSource.BitmapSource;
  75 
  76 import java.io.File;
  77 import java.io.FileOutputStream;
  78 import java.io.IOException;
  79 import java.util.ArrayList;
  80 
  81 public class WallpaperPickerActivity extends WallpaperCropActivity {
  82     static final String TAG = &quot;Launcher.WallpaperPickerActivity&quot;;
  83 
  84     public static final int IMAGE_PICK = 5;
  85     public static final int PICK_WALLPAPER_THIRD_PARTY_ACTIVITY = 6;
  86     public static final int PICK_LIVE_WALLPAPER = 7;
  87     private static final String TEMP_WALLPAPER_TILES = &quot;TEMP_WALLPAPER_TILES&quot;;
  88     private static final String SELECTED_INDEX = &quot;SELECTED_INDEX&quot;;
  89     private static final String OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb.jpg&quot;;
  90     private static final String DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb2.jpg&quot;;
  91     private static final int FLAG_POST_DELAY_MILLIS = 200;
  92 
  93     private View mSelectedTile;
  94     private boolean mIgnoreNextTap;
  95     private OnClickListener mThumbnailOnClickListener;
  96 
  97     private LinearLayout mWallpapersView;
  98     private View mWallpaperStrip;
  99 
 100     private ActionMode.Callback mActionModeCallback;
 101     private ActionMode mActionMode;
 102 
 103     private View.OnLongClickListener mLongClickListener;
 104 
 105     ArrayList&lt;Uri&gt; mTempWallpaperTiles = new ArrayList&lt;Uri&gt;();
 106     private SavedWallpaperImages mSavedImages;
 107     private WallpaperInfo mLiveWallpaperInfoOnPickerLaunch;
 108     private int mSelectedIndex = -1;
 109     private WallpaperInfo mLastClickedLiveWallpaperInfo;
 110 
 111     public static abstract class WallpaperTileInfo {
 112         protected View mView;
 113         public Drawable mThumb;
 114 
 115         public void setView(View v) {
 116             mView = v;
 117         }
 118         public void onClick(WallpaperPickerActivity a) {}
 119         public void onSave(WallpaperPickerActivity a) {}
 120         public void onDelete(WallpaperPickerActivity a) {}
 121         public boolean isSelectable() { return false; }
 122         public boolean isNamelessWallpaper() { return false; }
 123         public void onIndexUpdated(CharSequence label) {
 124             if (isNamelessWallpaper()) {
 125                 mView.setContentDescription(label);
 126             }
 127         }
 128     }
 129 
 130     public static class PickImageInfo extends WallpaperTileInfo {
 131         @Override
 132         public void onClick(WallpaperPickerActivity a) {
 133             Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
 134             intent.setType(&quot;image/*&quot;);
 135             a.startActivityForResultSafely(intent, IMAGE_PICK);
 136         }
 137     }
 138 
 139     public static class UriWallpaperInfo extends WallpaperTileInfo {
 140         private Uri mUri;
 141         private boolean mFirstClick = true;
 142         private BitmapRegionTileSource.UriBitmapSource mBitmapSource;
 143         public UriWallpaperInfo(Uri uri) {
 144             mUri = uri;
 145         }
 146         @Override
 147         public void onClick(final WallpaperPickerActivity a) {
 148             final Runnable onLoad;
 149             if (!mFirstClick) {
 150                 onLoad = null;
 151             } else {
 152                 mFirstClick = false;
 153                 a.mSetWallpaperButton.setEnabled(false);
 154                 onLoad = new Runnable() {
 155                     public void run() {
 156                         if (mBitmapSource != null &amp;&amp;
 157                                 mBitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
 158                             a.selectTile(mView);
 159                             a.mSetWallpaperButton.setEnabled(true);
 160                         } else {
 161                             ViewGroup parent = (ViewGroup) mView.getParent();
 162                             if (parent != null) {
 163                                 parent.removeView(mView);
 164                                 Toast.makeText(a,
 165                                         a.getString(R.string.image_load_fail),
 166                                         Toast.LENGTH_SHORT).show();
 167                             }
 168                         }
 169                     }
 170                 };
 171             }
 172             mBitmapSource = new BitmapRegionTileSource.UriBitmapSource(
 173                     a, mUri, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 174             a.setCropViewTileSource(mBitmapSource, true, false, onLoad);
 175         }
 176         @Override
 177         public void onSave(final WallpaperPickerActivity a) {
 178             boolean finishActivityWhenDone = true;
 179             OnBitmapCroppedHandler h = new OnBitmapCroppedHandler() {
 180                 public void onBitmapCropped(byte[] imageBytes) {
 181                     Point thumbSize = getDefaultThumbnailSize(a.getResources());
 182                     // rotation is set to 0 since imageBytes has already been correctly rotated
 183                     Bitmap thumb = createThumbnail(
 184                             thumbSize, null, null, imageBytes, null, 0, 0, true);
 185                     a.getSavedImages().writeImage(thumb, imageBytes);
 186                 }
 187             };
 188             a.cropImageAndSetWallpaper(mUri, h, finishActivityWhenDone);
 189         }
 190         @Override
 191         public boolean isSelectable() {
 192             return true;
 193         }
 194         @Override
 195         public boolean isNamelessWallpaper() {
 196             return true;
 197         }
 198     }
 199 
 200     public static class FileWallpaperInfo extends WallpaperTileInfo {
 201         private File mFile;
 202 
 203         public FileWallpaperInfo(File target, Drawable thumb) {
 204             mFile = target;
 205             mThumb = thumb;
 206         }
 207         @Override
 208         public void onClick(WallpaperPickerActivity a) {
 209             BitmapRegionTileSource.UriBitmapSource bitmapSource =
 210                     new BitmapRegionTileSource.UriBitmapSource(a, Uri.fromFile(mFile), 1024);
 211             a.setCropViewTileSource(bitmapSource, false, true, null);
 212         }
 213         @Override
 214         public void onSave(WallpaperPickerActivity a) {
 215             a.setWallpaper(Uri.fromFile(mFile), true);
 216         }
 217         @Override
 218         public boolean isSelectable() {
 219             return true;
 220         }
 221         @Override
 222         public boolean isNamelessWallpaper() {
 223             return true;
 224         }
 225     }
 226 
 227     public static class ResourceWallpaperInfo extends WallpaperTileInfo {
 228         private Resources mResources;
 229         private int mResId;
 230 
 231         public ResourceWallpaperInfo(Resources res, int resId, Drawable thumb) {
 232             mResources = res;
 233             mResId = resId;
 234             mThumb = thumb;
 235         }
 236         @Override
 237         public void onClick(WallpaperPickerActivity a) {
 238             BitmapRegionTileSource.ResourceBitmapSource bitmapSource =
 239                     new BitmapRegionTileSource.ResourceBitmapSource(
 240                             mResources, mResId, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 241             bitmapSource.loadInBackground();
 242             BitmapRegionTileSource source = new BitmapRegionTileSource(a, bitmapSource);
 243             CropView v = a.getCropView();
 244             v.setTileSource(source, null);
 245             Point wallpaperSize = WallpaperCropActivity.getDefaultWallpaperSize(
 246                     a.getResources(), a.getWindowManager());
 247             RectF crop = WallpaperCropActivity.getMaxCropRect(
 248                     source.getImageWidth(), source.getImageHeight(),
 249                     wallpaperSize.x, wallpaperSize.y, false);
 250             v.setScale(wallpaperSize.x / crop.width());
 251             v.setTouchEnabled(false);
 252             a.setSystemWallpaperVisiblity(false);
 253         }
 254         @Override
 255         public void onSave(WallpaperPickerActivity a) {
 256             boolean finishActivityWhenDone = true;
 257             a.cropImageAndSetWallpaper(mResources, mResId, finishActivityWhenDone);
 258         }
 259         @Override
 260         public boolean isSelectable() {
 261             return true;
 262         }
 263         @Override
 264         public boolean isNamelessWallpaper() {
 265             return true;
 266         }
 267     }
 268 
 269     @TargetApi(Build.VERSION_CODES.KITKAT)
 270     public static class DefaultWallpaperInfo extends WallpaperTileInfo {
 271         public DefaultWallpaperInfo(Drawable thumb) {
 272             mThumb = thumb;
 273         }
 274         @Override
 275         public void onClick(WallpaperPickerActivity a) {
 276             CropView c = a.getCropView();
 277 
 278             Drawable defaultWallpaper = WallpaperManager.getInstance(a).getBuiltInDrawable(
 279                     c.getWidth(), c.getHeight(), false, 0.5f, 0.5f);
 280 
 281             if (defaultWallpaper == null) {
 282                 Log.w(TAG, &quot;Null default wallpaper encountered.&quot;);
 283                 c.setTileSource(null, null);
 284                 return;
 285             }
 286 
 287             c.setTileSource(
<abbr title=" 288                     new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), null);"> 288                     new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), nulðŸ”µ</abbr>
 289             c.setScale(1f);
 290             c.setTouchEnabled(false);
 291             a.setSystemWallpaperVisiblity(false);
 292         }
 293         @Override
 294         public void onSave(WallpaperPickerActivity a) {
 295             try {
 296                 WallpaperManager.getInstance(a).clear();
 297                 a.setResult(RESULT_OK);
 298             } catch (IOException e) {
 299                 Log.w(&quot;Setting wallpaper to default threw exception&quot;, e);
 300             }
 301             a.finish();
 302         }
 303         @Override
 304         public boolean isSelectable() {
 305             return true;
 306         }
 307         @Override
 308         public boolean isNamelessWallpaper() {
 309             return true;
 310         }
 311     }
 312 
 313     public void setWallpaperStripYOffset(float offset) {
 314         mWallpaperStrip.setPadding(0, 0, 0, (int) offset);
 315     }
 316 
 317     /**
 318      * shows the system wallpaper behind the window and hides the {@link
 319      * #mCropView} if visible
 320      * @param visible should the system wallpaper be shown
 321      */
 322     protected void setSystemWallpaperVisiblity(final boolean visible) {
 323         // hide our own wallpaper preview if necessary
 324         if(!visible) {
 325             mCropView.setVisibility(View.VISIBLE);
 326         } else {
 327             changeWallpaperFlags(visible);
 328         }
 329         // the change of the flag must be delayed in order to avoid flickering,
 330         // a simple post / double post does not suffice here
 331         mCropView.postDelayed(new Runnable() {
 332             @Override
 333             public void run() {
 334                 if(!visible) {
 335                     changeWallpaperFlags(visible);
 336                 } else {
 337                     mCropView.setVisibility(View.INVISIBLE);
 338                 }
 339             }
 340         }, FLAG_POST_DELAY_MILLIS);
 341     }
 342 
 343     private void changeWallpaperFlags(boolean visible) {
 344         int desiredWallpaperFlag = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
 345         int currentWallpaperFlag = getWindow().getAttributes().flags
 346                 &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
 347         if (desiredWallpaperFlag != currentWallpaperFlag) {
 348             getWindow().setFlags(desiredWallpaperFlag,
 349                     WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
 350         }
 351     }
 352 
 353     @Override
 354     public void setCropViewTileSource(BitmapSource bitmapSource,
 355                                       boolean touchEnabled,
 356                                       boolean moveToLeft,
 357                                       final Runnable postExecute) {
 358         // we also want to show our own wallpaper instead of the one in the background
 359         Runnable showPostExecuteRunnable = new Runnable() {
 360             @Override
 361             public void run() {
 362                 if(postExecute != null) {
 363                     postExecute.run();
 364                 }
 365                 setSystemWallpaperVisiblity(false);
 366             }
 367         };
 368         super.setCropViewTileSource(bitmapSource,
 369                 touchEnabled,
 370                 moveToLeft,
 371                 showPostExecuteRunnable);
 372     }
 373 
 374     // called by onCreate; this is subclassed to overwrite WallpaperCropActivity
 375     protected void init() {
 376         setContentView(R.layout.wallpaper_picker);
 377 
 378         mCropView = (CropView) findViewById(R.id.cropView);
 379         mCropView.setVisibility(View.INVISIBLE);
 380 
 381         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 382         mCropView.setTouchCallback(new CropView.TouchCallback() {
 383             ViewPropertyAnimator mAnim;
 384             @Override
 385             public void onTouchDown() {
 386                 if (mAnim != null) {
 387                     mAnim.cancel();
 388                 }
 389                 if (mWallpaperStrip.getAlpha() == 1f) {
 390                     mIgnoreNextTap = true;
 391                 }
 392                 mAnim = mWallpaperStrip.animate();
 393                 mAnim.alpha(0f)
 394                     .setDuration(150)
 395                     .withEndAction(new Runnable() {
 396                         public void run() {
 397                             mWallpaperStrip.setVisibility(View.INVISIBLE);
 398                         }
 399                     });
 400                 mAnim.setInterpolator(new AccelerateInterpolator(0.75f));
 401                 mAnim.start();
 402             }
 403             @Override
 404             public void onTouchUp() {
 405                 mIgnoreNextTap = false;
 406             }
 407             @Override
 408             public void onTap() {
 409                 boolean ignoreTap = mIgnoreNextTap;
 410                 mIgnoreNextTap = false;
 411                 if (!ignoreTap) {
 412                     if (mAnim != null) {
 413                         mAnim.cancel();
 414                     }
 415                     mWallpaperStrip.setVisibility(View.VISIBLE);
 416                     mAnim = mWallpaperStrip.animate();
 417                     mAnim.alpha(1f)
 418                          .setDuration(150)
 419                          .setInterpolator(new DecelerateInterpolator(0.75f));
 420                     mAnim.start();
 421                 }
 422             }
 423         });
 424 
 425         mThumbnailOnClickListener = new OnClickListener() {
 426             public void onClick(View v) {
 427                 if (mActionMode != null) {
 428                     // When CAB is up, clicking toggles the item instead
 429                     if (v.isLongClickable()) {
 430                         mLongClickListener.onLongClick(v);
 431                     }
 432                     return;
 433                 }
 434                 mSetWallpaperButton.setEnabled(true);
 435                 WallpaperTileInfo info = (WallpaperTileInfo) v.getTag();
 436                 if (info.isSelectable() &amp;&amp; v.getVisibility() == View.VISIBLE) {
 437                     selectTile(v);
 438                 }
 439                 info.onClick(WallpaperPickerActivity.this);
 440             }
 441         };
 442         mLongClickListener = new View.OnLongClickListener() {
 443             // Called when the user long-clicks on someView
 444             public boolean onLongClick(View view) {
 445                 CheckableFrameLayout c = (CheckableFrameLayout) view;
 446                 c.toggle();
 447 
 448                 if (mActionMode != null) {
 449                     mActionMode.invalidate();
 450                 } else {
 451                     // Start the CAB using the ActionMode.Callback defined below
 452                     mActionMode = startActionMode(mActionModeCallback);
 453                     int childCount = mWallpapersView.getChildCount();
 454                     for (int i = 0; i &lt; childCount; i++) {
 455                         mWallpapersView.getChildAt(i).setSelected(false);
 456                     }
 457                 }
 458                 return true;
 459             }
 460         };
 461 
 462         // Populate the built-in wallpapers
 463         ArrayList&lt;WallpaperTileInfo&gt; wallpapers = findBundledWallpapers();
 464         mWallpapersView = (LinearLayout) findViewById(R.id.wallpaper_list);
 465         SimpleWallpapersAdapter ia = new SimpleWallpapersAdapter(this, wallpapers);
 466         populateWallpapersFromAdapter(mWallpapersView, ia, false);
 467 
 468         // Populate the saved wallpapers
 469         mSavedImages = new SavedWallpaperImages(this);
 470         mSavedImages.loadThumbnailsAndImageIdList();
 471         populateWallpapersFromAdapter(mWallpapersView, mSavedImages, true);
 472 
 473         // Populate the live wallpapers
 474         final LinearLayout liveWallpapersView =
 475                 (LinearLayout) findViewById(R.id.live_wallpaper_list);
 476         final LiveWallpaperListAdapter a = new LiveWallpaperListAdapter(this);
 477         a.registerDataSetObserver(new DataSetObserver() {
 478             public void onChanged() {
 479                 liveWallpapersView.removeAllViews();
 480                 populateWallpapersFromAdapter(liveWallpapersView, a, false);
 481                 initializeScrollForRtl();
 482                 updateTileIndices();
 483             }
 484         });
 485 
 486         // Populate the third-party wallpaper pickers
 487         final LinearLayout thirdPartyWallpapersView =
 488                 (LinearLayout) findViewById(R.id.third_party_wallpaper_list);
 489         final ThirdPartyWallpaperPickerListAdapter ta =
 490                 new ThirdPartyWallpaperPickerListAdapter(this);
 491         populateWallpapersFromAdapter(thirdPartyWallpapersView, ta, false);
 492 
 493         // Add a tile for the Gallery
 494         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 495         FrameLayout pickImageTile = (FrameLayout) getLayoutInflater().
 496                 inflate(R.layout.wallpaper_picker_image_picker_item, masterWallpaperList, false);
 497         setWallpaperItemPaddingToZero(pickImageTile);
 498         masterWallpaperList.addView(pickImageTile, 0);
 499 
 500         // Make its background the last photo taken on external storage
 501         Bitmap lastPhoto = getThumbnailOfLastPhoto();
 502         if (lastPhoto != null) {
 503             ImageView galleryThumbnailBg =
 504                     (ImageView) pickImageTile.findViewById(R.id.wallpaper_image);
 505             galleryThumbnailBg.setImageBitmap(getThumbnailOfLastPhoto());
 506             int colorOverlay = getResources().getColor(R.color.wallpaper_picker_translucent_gray);
 507             galleryThumbnailBg.setColorFilter(colorOverlay, PorterDuff.Mode.SRC_ATOP);
 508 
 509         }
 510 
 511         PickImageInfo pickImageInfo = new PickImageInfo();
 512         pickImageTile.setTag(pickImageInfo);
 513         pickImageInfo.setView(pickImageTile);
 514         pickImageTile.setOnClickListener(mThumbnailOnClickListener);
 515 
 516         // Select the first item; wait for a layout pass so that we initialize the dimensions of
 517         // cropView or the defaultWallpaperView first
 518         mCropView.addOnLayoutChangeListener(new OnLayoutChangeListener() {
 519             @Override
 520             public void onLayoutChange(View v, int left, int top, int right, int bottom,
 521                     int oldLeft, int oldTop, int oldRight, int oldBottom) {
 522                 if ((right - left) &gt; 0 &amp;&amp; (bottom - top) &gt; 0) {
 523                     if (mSelectedIndex &gt;= 0 &amp;&amp; mSelectedIndex &lt; mWallpapersView.getChildCount()) {
 524                         mThumbnailOnClickListener.onClick(
 525                                 mWallpapersView.getChildAt(mSelectedIndex));
 526                         setSystemWallpaperVisiblity(false);
 527                     }
 528                     v.removeOnLayoutChangeListener(this);
 529                 }
 530             }
 531         });
 532 
 533         updateTileIndices();
 534 
 535         // Update the scroll for RTL
 536         initializeScrollForRtl();
 537 
 538         // Create smooth layout transitions for when items are deleted
 539         final LayoutTransition transitioner = new LayoutTransition();
 540         transitioner.setDuration(200);
 541         transitioner.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 0);
 542         transitioner.setAnimator(LayoutTransition.DISAPPEARING, null);
 543         mWallpapersView.setLayoutTransition(transitioner);
 544 
 545         // Action bar
 546         // Show the custom action bar view
 547         final ActionBar actionBar = getActionBar();
 548         actionBar.setCustomView(R.layout.actionbar_set_wallpaper);
 549         actionBar.getCustomView().setOnClickListener(
 550                 new View.OnClickListener() {
 551                     @Override
 552                     public void onClick(View v) {
 553                         if (mSelectedTile != null) {
 554                             WallpaperTileInfo info = (WallpaperTileInfo) mSelectedTile.getTag();
 555                             info.onSave(WallpaperPickerActivity.this);
 556                         } else {
 557                             // no tile was selected, so we just finish the activity and go back
 558                             setResult(Activity.RESULT_OK);
 559                             finish();
 560                         }
 561                     }
 562                 });
 563         mSetWallpaperButton = findViewById(R.id.set_wallpaper_button);
 564 
 565         // CAB for deleting items
 566         mActionModeCallback = new ActionMode.Callback() {
 567             // Called when the action mode is created; startActionMode() was called
 568             @Override
 569             public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 570                 // Inflate a menu resource providing context menu items
 571                 MenuInflater inflater = mode.getMenuInflater();
 572                 inflater.inflate(R.menu.cab_delete_wallpapers, menu);
 573                 return true;
 574             }
 575 
 576             private int numCheckedItems() {
 577                 int childCount = mWallpapersView.getChildCount();
 578                 int numCheckedItems = 0;
 579                 for (int i = 0; i &lt; childCount; i++) {
 580                     CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 581                     if (c.isChecked()) {
 582                         numCheckedItems++;
 583                     }
 584                 }
 585                 return numCheckedItems;
 586             }
 587 
 588             // Called each time the action mode is shown. Always called after onCreateActionMode,
 589             // but may be called multiple times if the mode is invalidated.
 590             @Override
 591             public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 592                 int numCheckedItems = numCheckedItems();
 593                 if (numCheckedItems == 0) {
 594                     mode.finish();
 595                     return true;
 596                 } else {
 597                     mode.setTitle(getResources().getQuantityString(
 598                             R.plurals.number_of_items_selected, numCheckedItems, numCheckedItems));
 599                     return true;
 600                 }
 601             }
 602 
 603             // Called when the user selects a contextual menu item
 604             @Override
 605             public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 606                 int itemId = item.getItemId();
 607                 if (itemId == R.id.menu_delete) {
 608                     int childCount = mWallpapersView.getChildCount();
 609                     ArrayList&lt;View&gt; viewsToRemove = new ArrayList&lt;View&gt;();
 610                     boolean selectedTileRemoved = false;
 611                     for (int i = 0; i &lt; childCount; i++) {
 612                         CheckableFrameLayout c =
 613                                 (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 614                         if (c.isChecked()) {
 615                             WallpaperTileInfo info = (WallpaperTileInfo) c.getTag();
 616                             info.onDelete(WallpaperPickerActivity.this);
 617                             viewsToRemove.add(c);
 618                             if (i == mSelectedIndex) {
 619                                 selectedTileRemoved = true;
 620                             }
 621                         }
 622                     }
 623                     for (View v : viewsToRemove) {
 624                         mWallpapersView.removeView(v);
 625                     }
 626                     if (selectedTileRemoved) {
 627                         mSelectedIndex = -1;
 628                         mSelectedTile = null;
 629                         setSystemWallpaperVisiblity(true);
 630                     }
 631                     updateTileIndices();
 632                     mode.finish(); // Action picked, so close the CAB
 633                     return true;
 634                 } else {
 635                     return false;
 636                 }
 637             }
 638 
 639             // Called when the user exits the action mode
 640             @Override
 641             public void onDestroyActionMode(ActionMode mode) {
 642                 int childCount = mWallpapersView.getChildCount();
 643                 for (int i = 0; i &lt; childCount; i++) {
 644                     CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 645                     c.setChecked(false);
 646                 }
 647                 if (mSelectedTile != null) {
 648                     mSelectedTile.setSelected(true);
 649                 }
 650                 mActionMode = null;
 651             }
 652         };
 653     }
 654 
 655     private void selectTile(View v) {
 656         if (mSelectedTile != null) {
 657             mSelectedTile.setSelected(false);
 658             mSelectedTile = null;
 659         }
 660         mSelectedTile = v;
 661         v.setSelected(true);
 662         mSelectedIndex = mWallpapersView.indexOfChild(v);
 663         // TODO: Remove this once the accessibility framework and
 664         // services have better support for selection state.
 665         v.announceForAccessibility(
 666                 getString(R.string.announce_selection, v.getContentDescription()));
 667     }
 668 
 669     private void initializeScrollForRtl() {
 670         final HorizontalScrollView scroll =
 671                 (HorizontalScrollView) findViewById(R.id.wallpaper_scroll_container);
 672 
 673         if (scroll.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
 674             final ViewTreeObserver observer = scroll.getViewTreeObserver();
 675             observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
 676                 public void onGlobalLayout() {
 677                     LinearLayout masterWallpaperList =
 678                             (LinearLayout) findViewById(R.id.master_wallpaper_list);
 679                     scroll.scrollTo(masterWallpaperList.getWidth(), 0);
 680                     scroll.getViewTreeObserver().removeOnGlobalLayoutListener(this);
 681                 }
 682             });
 683         }
 684     }
 685 
 686     protected Bitmap getThumbnailOfLastPhoto() {
 687         Cursor cursor = MediaStore.Images.Media.query(getContentResolver(),
 688                 MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
 689                 new String[] { MediaStore.Images.ImageColumns._ID,
 690                     MediaStore.Images.ImageColumns.DATE_TAKEN},
 691                 null, null, MediaStore.Images.ImageColumns.DATE_TAKEN + &quot; DESC LIMIT 1&quot;);
 692 
 693         Bitmap thumb = null;
 694         if (cursor != null) {
 695             if (cursor.moveToNext()) {
 696                 int id = cursor.getInt(0);
 697                 thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(),
 698                         id, MediaStore.Images.Thumbnails.MINI_KIND, null);
 699             }
 700             cursor.close();
 701         }
 702         return thumb;
 703     }
 704 
 705     protected void onStop() {
 706         super.onStop();
 707         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 708         if (mWallpaperStrip.getAlpha() &lt; 1f) {
 709             mWallpaperStrip.setAlpha(1f);
 710             mWallpaperStrip.setVisibility(View.VISIBLE);
 711         }
 712     }
 713 
 714     protected void onSaveInstanceState(Bundle outState) {
 715         outState.putParcelableArrayList(TEMP_WALLPAPER_TILES, mTempWallpaperTiles);
 716         outState.putInt(SELECTED_INDEX, mSelectedIndex);
 717     }
 718 
 719     protected void onRestoreInstanceState(Bundle savedInstanceState) {
 720         ArrayList&lt;Uri&gt; uris = savedInstanceState.getParcelableArrayList(TEMP_WALLPAPER_TILES);
 721         for (Uri uri : uris) {
 722             addTemporaryWallpaperTile(uri, true);
 723         }
 724         mSelectedIndex = savedInstanceState.getInt(SELECTED_INDEX, -1);
 725     }
 726 
 727     private void populateWallpapersFromAdapter(ViewGroup parent, BaseAdapter adapter,
 728             boolean addLongPressHandler) {
 729         for (int i = 0; i &lt; adapter.getCount(); i++) {
 730             FrameLayout thumbnail = (FrameLayout) adapter.getView(i, null, parent);
 731             parent.addView(thumbnail, i);
 732             WallpaperTileInfo info = (WallpaperTileInfo) adapter.getItem(i);
 733             thumbnail.setTag(info);
 734             info.setView(thumbnail);
 735             if (addLongPressHandler) {
 736                 addLongPressHandler(thumbnail);
 737             }
 738             thumbnail.setOnClickListener(mThumbnailOnClickListener);
 739         }
 740     }
 741 
 742     private void updateTileIndices() {
 743         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 744         final int childCount = masterWallpaperList.getChildCount();
 745         final Resources res = getResources();
 746 
 747         // Do two passes; the first pass gets the total number of tiles
 748         int numTiles = 0;
 749         for (int passNum = 0; passNum &lt; 2; passNum++) {
 750             int tileIndex = 0;
 751             for (int i = 0; i &lt; childCount; i++) {
 752                 View child = masterWallpaperList.getChildAt(i);
 753                 LinearLayout subList;
 754 
 755                 int subListStart;
 756                 int subListEnd;
 757                 if (child.getTag() instanceof WallpaperTileInfo) {
 758                     subList = masterWallpaperList;
 759                     subListStart = i;
 760                     subListEnd = i + 1;
 761                 } else { // if (child instanceof LinearLayout) {
 762                     subList = (LinearLayout) child;
 763                     subListStart = 0;
 764                     subListEnd = subList.getChildCount();
 765                 }
 766 
 767                 for (int j = subListStart; j &lt; subListEnd; j++) {
 768                     WallpaperTileInfo info = (WallpaperTileInfo) subList.getChildAt(j).getTag();
 769                     if (info.isNamelessWallpaper()) {
 770                         if (passNum == 0) {
 771                             numTiles++;
 772                         } else {
 773                             CharSequence label = res.getString(
 774                                     R.string.wallpaper_accessibility_name, ++tileIndex, numTiles);
 775                             info.onIndexUpdated(label);
 776                         }
 777                     }
 778                 }
 779             }
 780         }
 781     }
 782 
 783     private static Point getDefaultThumbnailSize(Resources res) {
 784         return new Point(res.getDimensionPixelSize(R.dimen.wallpaperThumbnailWidth),
 785                 res.getDimensionPixelSize(R.dimen.wallpaperThumbnailHeight));
 786 
 787     }
 788 
 789     private static Bitmap createThumbnail(Point size, Context context, Uri uri, byte[] imageBytes,
 790             Resources res, int resId, int rotation, boolean leftAligned) {
 791         int width = size.x;
 792         int height = size.y;
 793 
 794         BitmapCropTask cropTask;
 795         if (uri != null) {
 796             cropTask = new BitmapCropTask(
 797                     context, uri, null, rotation, width, height, false, true, null);
 798         } else if (imageBytes != null) {
 799             cropTask = new BitmapCropTask(
 800                     imageBytes, null, rotation, width, height, false, true, null);
 801         }  else {
 802             cropTask = new BitmapCropTask(
 803                     context, res, resId, null, rotation, width, height, false, true, null);
 804         }
 805         Point bounds = cropTask.getImageBounds();
 806         if (bounds == null || bounds.x == 0 || bounds.y == 0) {
 807             return null;
 808         }
 809 
 810         Matrix rotateMatrix = new Matrix();
 811         rotateMatrix.setRotate(rotation);
 812         float[] rotatedBounds = new float[] { bounds.x, bounds.y };
 813         rotateMatrix.mapPoints(rotatedBounds);
 814         rotatedBounds[0] = Math.abs(rotatedBounds[0]);
 815         rotatedBounds[1] = Math.abs(rotatedBounds[1]);
 816 
 817         RectF cropRect = WallpaperCropActivity.getMaxCropRect(
 818                 (int) rotatedBounds[0], (int) rotatedBounds[1], width, height, leftAligned);
 819         cropTask.setCropBounds(cropRect);
 820 
 821         if (cropTask.cropBitmap()) {
 822             return cropTask.getCroppedBitmap();
 823         } else {
 824             return null;
 825         }
 826     }
 827 
 828     private void addTemporaryWallpaperTile(final Uri uri, boolean fromRestore) {
 829         mTempWallpaperTiles.add(uri);
 830         // Add a tile for the image picked from Gallery
 831         final FrameLayout pickedImageThumbnail = (FrameLayout) getLayoutInflater().
 832                 inflate(R.layout.wallpaper_picker_item, mWallpapersView, false);
 833         pickedImageThumbnail.setVisibility(View.GONE);
 834         setWallpaperItemPaddingToZero(pickedImageThumbnail);
 835         mWallpapersView.addView(pickedImageThumbnail, 0);
 836 
 837         // Load the thumbnail
 838         final ImageView image = (ImageView) pickedImageThumbnail.findViewById(R.id.wallpaper_image);
 839         final Point defaultSize = getDefaultThumbnailSize(this.getResources());
 840         final Context context = this;
 841         new AsyncTask&lt;Void, Bitmap, Bitmap&gt;() {
 842             protected Bitmap doInBackground(Void...args) {
 843                 try {
 844                     int rotation = WallpaperCropActivity.getRotationFromExif(context, uri);
 845                     return createThumbnail(defaultSize, context, uri, null, null, 0, rotation, false);
 846                 } catch (SecurityException securityException) {
 847                     if (isDestroyed()) {
 848                         // Temporarily granted permissions are revoked when the activity
 849                         // finishes, potentially resulting in a SecurityException here.
 850                         // Even though {@link #isDestroyed} might also return true in different
 851                         // situations where the configuration changes, we are fine with
 852                         // catching these cases here as well.
 853                         cancel(false);
 854                     } else {
 855                         // otherwise it had a different cause and we throw it further
 856                         throw securityException;
 857                     }
 858                     return null;
 859                 }
 860             }
 861             protected void onPostExecute(Bitmap thumb) {
 862                 if (!isCancelled() &amp;&amp; thumb != null) {
 863                     image.setImageBitmap(thumb);
 864                     Drawable thumbDrawable = image.getDrawable();
 865                     thumbDrawable.setDither(true);
 866                     pickedImageThumbnail.setVisibility(View.VISIBLE);
 867                 } else {
 868                     Log.e(TAG, &quot;Error loading thumbnail for uri=&quot; + uri);
 869                 }
 870             }
 871         }.execute();
 872 
 873         UriWallpaperInfo info = new UriWallpaperInfo(uri);
 874         pickedImageThumbnail.setTag(info);
 875         info.setView(pickedImageThumbnail);
 876         addLongPressHandler(pickedImageThumbnail);
 877         updateTileIndices();
 878         pickedImageThumbnail.setOnClickListener(mThumbnailOnClickListener);
 879         if (!fromRestore) {
 880             mThumbnailOnClickListener.onClick(pickedImageThumbnail);
 881         }
 882     }
 883 
 884     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 885         if (requestCode == IMAGE_PICK &amp;&amp; resultCode == RESULT_OK) {
 886             if (data != null &amp;&amp; data.getData() != null) {
 887                 Uri uri = data.getData();
 888                 addTemporaryWallpaperTile(uri, false);
 889             }
 890         } else if (requestCode == PICK_WALLPAPER_THIRD_PARTY_ACTIVITY) {
 891             setResult(RESULT_OK);
 892             finish();
 893         } else if (requestCode == PICK_LIVE_WALLPAPER) {
 894             WallpaperManager wm = WallpaperManager.getInstance(this);
 895             final WallpaperInfo oldLiveWallpaper = mLiveWallpaperInfoOnPickerLaunch;
 896             final WallpaperInfo clickedWallpaper = mLastClickedLiveWallpaperInfo;
 897             WallpaperInfo newLiveWallpaper = wm.getWallpaperInfo();
 898             // Try to figure out if a live wallpaper was set;
 899             if (newLiveWallpaper != null &amp;&amp;
 900                     (oldLiveWallpaper == null
 901                             || !oldLiveWallpaper.getComponent()
 902                                     .equals(newLiveWallpaper.getComponent())
 903                             || clickedWallpaper.getComponent()
 904                                     .equals(oldLiveWallpaper.getComponent()))) {
 905                 // Return if a live wallpaper was set
 906                 setResult(RESULT_OK);
 907                 finish();
 908             }
 909         }
 910     }
 911 
 912     static void setWallpaperItemPaddingToZero(FrameLayout frameLayout) {
 913         frameLayout.setPadding(0, 0, 0, 0);
 914         frameLayout.setForeground(new ZeroPaddingDrawable(frameLayout.getForeground()));
 915     }
 916 
 917     private void addLongPressHandler(View v) {
 918         v.setOnLongClickListener(mLongClickListener);
 919     }
 920 
 921     private ArrayList&lt;WallpaperTileInfo&gt; findBundledWallpapers() {
 922         final PackageManager pm = getPackageManager();
 923         final ArrayList&lt;WallpaperTileInfo&gt; bundled = new ArrayList&lt;WallpaperTileInfo&gt;(24);
 924 
 925         Partner partner = Partner.get(pm);
 926         if (partner != null) {
 927             final Resources partnerRes = partner.getResources();
 928             final int resId = partnerRes.getIdentifier(Partner.RES_WALLPAPERS, &quot;array&quot;,
 929                     partner.getPackageName());
 930             if (resId != 0) {
 931                 addWallpapers(bundled, partnerRes, partner.getPackageName(), resId);
 932             }
 933 
 934             // Add system wallpapers
 935             File systemDir = partner.getWallpaperDirectory();
 936             if (systemDir != null &amp;&amp; systemDir.isDirectory()) {
 937                 for (File file : systemDir.listFiles()) {
 938                     if (!file.isFile()) {
 939                         continue;
 940                     }
 941                     String name = file.getName();
 942                     int dotPos = name.lastIndexOf(&#x27;.&#x27;);
 943                     String extension = &quot;&quot;;
 944                     if (dotPos &gt;= -1) {
 945                         extension = name.substring(dotPos);
 946                         name = name.substring(0, dotPos);
 947                     }
 948 
 949                     if (name.endsWith(&quot;_small&quot;)) {
 950                         // it is a thumbnail
 951                         continue;
 952                     }
 953 
 954                     File thumbnail = new File(systemDir, name + &quot;_small&quot; + extension);
 955                     Bitmap thumb = BitmapFactory.decodeFile(thumbnail.getAbsolutePath());
 956                     if (thumb != null) {
 957                         bundled.add(new FileWallpaperInfo(file, new BitmapDrawable(thumb)));
 958                     }
 959                 }
 960             }
 961         }
 962 
 963         Pair&lt;ApplicationInfo, Integer&gt; r = getWallpaperArrayResourceId();
 964         if (r != null) {
 965             try {
 966                 Resources wallpaperRes = getPackageManager().getResourcesForApplication(r.first);
 967                 addWallpapers(bundled, wallpaperRes, r.first.packageName, r.second);
 968             } catch (PackageManager.NameNotFoundException e) {
 969             }
 970         }
 971 
 972         if (partner == null || !partner.hideDefaultWallpaper()) {
 973             // Add an entry for the default wallpaper (stored in system resources)
 974             WallpaperTileInfo defaultWallpaperInfo =
 975                     (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT)
 976                     ? getPreKKDefaultWallpaperInfo()
 977                     : getDefaultWallpaper();
 978             if (defaultWallpaperInfo != null) {
 979                 bundled.add(0, defaultWallpaperInfo);
 980             }
 981         }
 982         return bundled;
 983     }
 984 
 985     private boolean writeImageToFileAsJpeg(File f, Bitmap b) {
 986         try {
 987             f.createNewFile();
 988             FileOutputStream thumbFileStream =
 989                     openFileOutput(f.getName(), Context.MODE_PRIVATE);
 990             b.compress(Bitmap.CompressFormat.JPEG, 95, thumbFileStream);
 991             thumbFileStream.close();
 992             return true;
 993         } catch (IOException e) {
 994             Log.e(TAG, &quot;Error while writing bitmap to file &quot; + e);
 995             f.delete();
 996         }
 997         return false;
 998     }
 999 
1000     private File getDefaultThumbFile() {
1001         return new File(getFilesDir(), Build.VERSION.SDK_INT
1002                 + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);
1003     }
1004 
1005     private boolean saveDefaultWallpaperThumb(Bitmap b) {
1006         // Delete old thumbnails.
1007         new File(getFilesDir(), OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1008         new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1009 
1010         for (int i = Build.VERSION_CODES.JELLY_BEAN; i &lt; Build.VERSION.SDK_INT; i++) {
1011             new File(getFilesDir(), i + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
1012         }
1013         return writeImageToFileAsJpeg(getDefaultThumbFile(), b);
1014     }
1015 
1016     private ResourceWallpaperInfo getPreKKDefaultWallpaperInfo() {
1017         Resources sysRes = Resources.getSystem();
1018         int resId = sysRes.getIdentifier(&quot;default_wallpaper&quot;, &quot;drawable&quot;, &quot;android&quot;);
1019 
1020         File defaultThumbFile = getDefaultThumbFile();
1021         Bitmap thumb = null;
1022         boolean defaultWallpaperExists = false;
1023         if (defaultThumbFile.exists()) {
1024             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1025             defaultWallpaperExists = true;
1026         } else {
1027             Resources res = getResources();
1028             Point defaultThumbSize = getDefaultThumbnailSize(res);
1029             int rotation = WallpaperCropActivity.getRotationFromExif(res, resId);
1030             thumb = createThumbnail(
1031                     defaultThumbSize, this, null, null, sysRes, resId, rotation, false);
1032             if (thumb != null) {
1033                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1034             }
1035         }
1036         if (defaultWallpaperExists) {
1037             return new ResourceWallpaperInfo(sysRes, resId, new BitmapDrawable(thumb));
1038         }
1039         return null;
1040     }
1041 
1042     @TargetApi(Build.VERSION_CODES.KITKAT)
1043     private DefaultWallpaperInfo getDefaultWallpaper() {
1044         File defaultThumbFile = getDefaultThumbFile();
1045         Bitmap thumb = null;
1046         boolean defaultWallpaperExists = false;
1047         if (defaultThumbFile.exists()) {
1048             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1049             defaultWallpaperExists = true;
1050         } else {
1051             Resources res = getResources();
1052             Point defaultThumbSize = getDefaultThumbnailSize(res);
1053             Drawable wallpaperDrawable = WallpaperManager.getInstance(this).getBuiltInDrawable(
1054                     defaultThumbSize.x, defaultThumbSize.y, true, 0.5f, 0.5f);
1055             if (wallpaperDrawable != null) {
1056                 thumb = Bitmap.createBitmap(
1057                         defaultThumbSize.x, defaultThumbSize.y, Bitmap.Config.ARGB_8888);
1058                 Canvas c = new Canvas(thumb);
1059                 wallpaperDrawable.setBounds(0, 0, defaultThumbSize.x, defaultThumbSize.y);
1060                 wallpaperDrawable.draw(c);
1061                 c.setBitmap(null);
1062             }
1063             if (thumb != null) {
1064                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1065             }
1066         }
1067         if (defaultWallpaperExists) {
1068             return new DefaultWallpaperInfo(new BitmapDrawable(thumb));
1069         }
1070         return null;
1071     }
1072 
1073     public Pair&lt;ApplicationInfo, Integer&gt; getWallpaperArrayResourceId() {
1074         // Context.getPackageName() may return the &quot;original&quot; package name,
1075         // com.android.launcher3; Resources needs the real package name,
1076         // com.android.launcher3. So we ask Resources for what it thinks the
1077         // package name should be.
1078         final String packageName = getResources().getResourcePackageName(R.array.wallpapers);
1079         try {
1080             ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, 0);
1081             return new Pair&lt;ApplicationInfo, Integer&gt;(info, R.array.wallpapers);
1082         } catch (PackageManager.NameNotFoundException e) {
1083             return null;
1084         }
1085     }
1086 
1087     private void addWallpapers(ArrayList&lt;WallpaperTileInfo&gt; known, Resources res,
1088             String packageName, int listResId) {
1089         final String[] extras = res.getStringArray(listResId);
1090         for (String extra : extras) {
1091             int resId = res.getIdentifier(extra, &quot;drawable&quot;, packageName);
1092             if (resId != 0) {
1093                 final int thumbRes = res.getIdentifier(extra + &quot;_small&quot;, &quot;drawable&quot;, packageName);
1094 
1095                 if (thumbRes != 0) {
1096                     ResourceWallpaperInfo wallpaperInfo =
1097                             new ResourceWallpaperInfo(res, resId, res.getDrawable(thumbRes));
1098                     known.add(wallpaperInfo);
1099                     // Log.d(TAG, &quot;add: [&quot; + packageName + &quot;]: &quot; + extra + &quot; (&quot; + res + &quot;)&quot;);
1100                 }
1101             } else {
1102                 Log.e(TAG, &quot;Couldn&#x27;t find wallpaper &quot; + extra);
1103             }
1104         }
1105     }
1106 
1107     public CropView getCropView() {
1108         return mCropView;
1109     }
1110 
1111     public SavedWallpaperImages getSavedImages() {
1112         return mSavedImages;
1113     }
1114 
1115     public void onLiveWallpaperPickerLaunch(WallpaperInfo info) {
1116         mLastClickedLiveWallpaperInfo = info;
1117         mLiveWallpaperInfoOnPickerLaunch = WallpaperManager.getInstance(this).getWallpaperInfo();
1118     }
1119 
1120     static class ZeroPaddingDrawable extends LevelListDrawable {
1121         public ZeroPaddingDrawable(Drawable d) {
1122             super();
1123             addLevel(0, 0, d);
1124             setLevel(0);
1125         }
1126 
1127         @Override
1128         public boolean getPadding(Rect padding) {
1129             padding.set(0, 0, 0, 0);
1130             return true;
1131         }
1132     }
1133 
1134     private static class SimpleWallpapersAdapter extends ArrayAdapter&lt;WallpaperTileInfo&gt; {
1135         private final LayoutInflater mLayoutInflater;
1136 
1137         SimpleWallpapersAdapter(Activity activity, ArrayList&lt;WallpaperTileInfo&gt; wallpapers) {
1138             super(activity, R.layout.wallpaper_picker_item, wallpapers);
1139             mLayoutInflater = activity.getLayoutInflater();
1140         }
1141 
1142         public View getView(int position, View convertView, ViewGroup parent) {
1143             Drawable thumb = getItem(position).mThumb;
1144             if (thumb == null) {
1145                 Log.e(TAG, &quot;Error decoding thumbnail for wallpaper #&quot; + position);
1146             }
1147             return createImageTileView(mLayoutInflater, convertView, parent, thumb);
1148         }
1149     }
1150 
1151     public static View createImageTileView(LayoutInflater layoutInflater,
1152             View convertView, ViewGroup parent, Drawable thumb) {
1153         View view;
1154 
1155         if (convertView == null) {
1156             view = layoutInflater.inflate(R.layout.wallpaper_picker_item, parent, false);
1157         } else {
1158             view = convertView;
1159         }
1160 
1161         setWallpaperItemPaddingToZero((FrameLayout) view);
1162 
1163         ImageView image = (ImageView) view.findViewById(R.id.wallpaper_image);
1164 
1165         if (thumb != null) {
1166             image.setImageDrawable(thumb);
1167             thumb.setDither(true);
1168         }
1169 
1170         return view;
1171     }
1172 
1173     // In Launcher3, we override this with a method that catches exceptions
1174     // from starting activities; didn&#x27;t want to copy and paste code into here
1175     public void startActivityForResultSafely(Intent intent, int requestCode) {
1176         startActivityForResult(intent, requestCode);
1177     }
1178 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.animation.LayoutTransition;
  19 import android.annotation.TargetApi;
  20 import android.app.ActionBar;
  21 import android.app.Activity;
  22 import android.app.WallpaperInfo;
  23 import android.app.WallpaperManager;
  24 import android.content.Context;
  25 import android.content.Intent;
  26 import android.content.pm.ApplicationInfo;
  27 import android.content.pm.PackageManager;
  28 import android.content.res.Resources;
  29 import android.database.Cursor;
  30 import android.database.DataSetObserver;
  31 import android.graphics.Bitmap;
  32 import android.graphics.BitmapFactory;
  33 import android.graphics.Canvas;
  34 import android.graphics.Matrix;
  35 import android.graphics.Point;
  36 import android.graphics.PorterDuff;
  37 import android.graphics.Rect;
  38 import android.graphics.RectF;
  39 import android.graphics.drawable.BitmapDrawable;
  40 import android.graphics.drawable.Drawable;
  41 import android.graphics.drawable.LevelListDrawable;
  42 import android.net.Uri;
  43 import android.os.AsyncTask;
  44 import android.os.Build;
  45 import android.os.Bundle;
  46 import android.provider.MediaStore;
  47 import android.util.Log;
  48 import android.util.Pair;
  49 import android.view.ActionMode;
  50 import android.view.LayoutInflater;
  51 import android.view.Menu;
  52 import android.view.MenuInflater;
  53 import android.view.MenuItem;
  54 import android.view.View.OnClickListener;
  55 import android.view.View.OnLayoutChangeListener;
  56 import android.view.View;
  57 import android.view.ViewGroup;
  58 import android.view.ViewPropertyAnimator;
  59 import android.view.ViewTreeObserver.OnGlobalLayoutListener;
  60 import android.view.ViewTreeObserver;
  61 import android.view.WindowManager;
  62 import android.view.animation.AccelerateInterpolator;
  63 import android.view.animation.DecelerateInterpolator;
  64 import android.widget.ArrayAdapter;
  65 import android.widget.BaseAdapter;
  66 import android.widget.FrameLayout;
  67 import android.widget.HorizontalScrollView;
  68 import android.widget.ImageView;
  69 import android.widget.LinearLayout;
  70 import android.widget.Toast;
  71 import com.android.photos.BitmapRegionTileSource.BitmapSource;
  72 import com.android.photos.BitmapRegionTileSource;
  73 import java.io.File;
  74 import java.io.FileOutputStream;
  75 import java.io.IOException;
  76 import java.util.ArrayList;
  77 
  78 
  79 public class WallpaperPickerActivity extends WallpaperCropActivity {
  80     static final String TAG = &quot;Launcher.WallpaperPickerActivity&quot;;
  81 
  82     public static final int IMAGE_PICK = 5;
  83 
  84     public static final int PICK_WALLPAPER_THIRD_PARTY_ACTIVITY = 6;
  85 
  86     public static final int PICK_LIVE_WALLPAPER = 7;
  87 
  88     private static final String TEMP_WALLPAPER_TILES = &quot;TEMP_WALLPAPER_TILES&quot;;
  89 
  90     private static final String SELECTED_INDEX = &quot;SELECTED_INDEX&quot;;
  91 
  92     private static final String OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb.jpg&quot;;
  93 
  94     private static final String DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb2.jpg&quot;;
  95 
  96     private static final int FLAG_POST_DELAY_MILLIS = 200;
  97 
  98     private View mSelectedTile;
  99 
 100     private boolean mIgnoreNextTap;
 101 
 102     private OnClickListener mThumbnailOnClickListener;
 103 
 104     private LinearLayout mWallpapersView;
 105 
 106     private View mWallpaperStrip;
 107 
 108     private ActionMode.Callback mActionModeCallback;
 109 
 110     private ActionMode mActionMode;
 111 
 112     private View.OnLongClickListener mLongClickListener;
 113 
 114     ArrayList&lt;Uri&gt; mTempWallpaperTiles = new ArrayList&lt;Uri&gt;();
 115 
 116     private SavedWallpaperImages mSavedImages;
 117 
 118     private WallpaperInfo mLiveWallpaperInfoOnPickerLaunch;
 119 
 120     private int mSelectedIndex = -1;
 121 
 122     private WallpaperInfo mLastClickedLiveWallpaperInfo;
 123 
 124     public abstract static class WallpaperTileInfo {
 125         protected View mView;
 126 
 127         public Drawable mThumb;
 128 
 129         public void setView(View v) {
 130             mView = v;
 131         }
 132 
 133         public void onClick(WallpaperPickerActivity a) {}
 134 
 135         public void onSave(WallpaperPickerActivity a) {}
 136 
 137         public void onDelete(WallpaperPickerActivity a) {}
 138 
 139         public boolean isSelectable() { return false; }
 140 
 141         public boolean isNamelessWallpaper() { return false; }
 142 
 143         public void onIndexUpdated(CharSequence label) {
 144             if (isNamelessWallpaper()) {
 145                 mView.setContentDescription(label);
 146             }
 147         }
 148     }
 149 
 150     public static class PickImageInfo extends WallpaperTileInfo {
 151         @Override
 152         public void onClick(WallpaperPickerActivity a) {
 153             Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
 154             intent.setType(&quot;image/*&quot;);
 155             a.startActivityForResultSafely(intent, IMAGE_PICK);
 156         }
 157     }
 158 
 159     public static class UriWallpaperInfo extends WallpaperTileInfo {
 160         private Uri mUri;
 161 
 162         private boolean mFirstClick = true;
 163 
 164         private BitmapRegionTileSource.UriBitmapSource mBitmapSource;
 165 
 166         public UriWallpaperInfo(Uri uri) {
 167             mUri = uri;
 168         }
 169 
 170         @Override
 171         public void onClick(final WallpaperPickerActivity a) {
 172             final Runnable onLoad;
 173             if (!mFirstClick) {
 174                 onLoad = null;
 175             } else {
 176                 mFirstClick = false;
 177                 a.mSetWallpaperButton.setEnabled(false);
 178                 onLoad = new Runnable() {
 179                     public void run() {
<abbr title=" 180                         if ((mBitmapSource != null) &amp;&amp; (mBitmapSource.getLoadingState() == BitmapSource.State.LOADED)) {"> 180                         if ((mBitmapSource != null) &amp;&amp; (mBitmapSource.getLoadingState() == BitmapSource.SðŸ”µ</abbr>
 181                             a.selectTile(mView);
 182                             a.mSetWallpaperButton.setEnabled(true);
 183                         } else {
 184                             ViewGroup parent = ((ViewGroup) (mView.getParent()));
 185                             if (parent != null) {
 186                                 parent.removeView(mView);
<abbr title=" 187                                 Toast.makeText(a, a.getString(R.string.image_load_fail), Toast.LENGTH_SHORT).show();"> 187                                 Toast.makeText(a, a.getString(R.string.image_load_fail), Toast.LENGTH_SHOðŸ”µ</abbr>
 188                             }
 189                         }
 190                     }
 191                 };
 192             }
<abbr title=" 193             mBitmapSource = new BitmapRegionTileSource.UriBitmapSource(a, mUri, BitmapRegionTileSource.MAX_PREVIEW_SIZE);"> 193             mBitmapSource = new BitmapRegionTileSource.UriBitmapSource(a, mUri, BitmapRegionTileSource.MAðŸ”µ</abbr>
 194             a.setCropViewTileSource(mBitmapSource, true, false, onLoad);
 195         }
 196 
 197         @Override
 198         public void onSave(final WallpaperPickerActivity a) {
 199             boolean finishActivityWhenDone = true;
 200             OnBitmapCroppedHandler h = new OnBitmapCroppedHandler() {
 201                 public void onBitmapCropped(byte[] imageBytes) {
 202                     Point thumbSize = getDefaultThumbnailSize(a.getResources());
 203                     // rotation is set to 0 since imageBytes has already been correctly rotated
 204                     Bitmap thumb = createThumbnail(
 205                             thumbSize, null, null, imageBytes, null, 0, 0, true);
 206                     a.getSavedImages().writeImage(thumb, imageBytes);
 207                 }
 208             };
 209             a.cropImageAndSetWallpaper(mUri, h, finishActivityWhenDone);
 210         }
 211 
 212         @Override
 213         public boolean isSelectable() {
 214             return true;
 215         }
 216 
 217         @Override
 218         public boolean isNamelessWallpaper() {
 219             return true;
 220         }
 221     }
 222 
 223     public static class FileWallpaperInfo extends WallpaperTileInfo {
 224         private File mFile;
 225 
 226         public FileWallpaperInfo(File target, Drawable thumb) {
 227             mFile = target;
 228             mThumb = thumb;
 229         }
 230 
 231         @Override
 232         public void onClick(WallpaperPickerActivity a) {
 233             BitmapRegionTileSource.UriBitmapSource bitmapSource =
 234                     new BitmapRegionTileSource.UriBitmapSource(a, Uri.fromFile(mFile), 1024);
 235             a.setCropViewTileSource(bitmapSource, false, true, null);
 236         }
 237 
 238         @Override
 239         public void onSave(WallpaperPickerActivity a) {
 240             a.setWallpaper(Uri.fromFile(mFile), true);
 241         }
 242 
 243         @Override
 244         public boolean isSelectable() {
 245             return true;
 246         }
 247 
 248         @Override
 249         public boolean isNamelessWallpaper() {
 250             return true;
 251         }
 252     }
 253 
 254     public static class ResourceWallpaperInfo extends WallpaperTileInfo {
 255         private Resources mResources;
 256 
 257         private int mResId;
 258 
 259         public ResourceWallpaperInfo(Resources res, int resId, Drawable thumb) {
 260             mResources = res;
 261             mResId = resId;
 262             mThumb = thumb;
 263         }
 264 
 265         @Override
 266         public void onClick(WallpaperPickerActivity a) {
<abbr title=" 267             BitmapRegionTileSource.ResourceBitmapSource bitmapSource = new BitmapRegionTileSource.ResourceBitmapSource(mResources, mResId, BitmapRegionTileSource.MAX_PREVIEW_SIZE);"> 267             BitmapRegionTileSource.ResourceBitmapSource bitmapSource = new BitmapRegionTileSource.ResourcðŸ”µ</abbr>
 268             bitmapSource.loadInBackground();
 269             BitmapRegionTileSource source = new BitmapRegionTileSource(a, bitmapSource);
 270             CropView v = a.getCropView();
 271             v.setTileSource(source, null);
<abbr title=" 272             Point wallpaperSize = WallpaperCropActivity.getDefaultWallpaperSize(a.getResources(), a.getWindowManager());"> 272             Point wallpaperSize = WallpaperCropActivity.getDefaultWallpaperSize(a.getResources(), a.getWiðŸ”µ</abbr>
<abbr title=" 273             RectF crop = WallpaperCropActivity.getMaxCropRect(source.getImageWidth(), source.getImageHeight(), wallpaperSize.x, wallpaperSize.y, false);"> 273             RectF crop = WallpaperCropActivity.getMaxCropRect(source.getImageWidth(), source.getImageHeigðŸ”µ</abbr>
 274             v.setScale(wallpaperSize.x / crop.width());
 275             v.setTouchEnabled(false);
 276             a.setSystemWallpaperVisiblity(false);
 277         }
 278 
 279         @Override
 280         public void onSave(WallpaperPickerActivity a) {
 281             boolean finishActivityWhenDone = true;
 282             a.cropImageAndSetWallpaper(mResources, mResId, finishActivityWhenDone);
 283         }
 284 
 285         @Override
 286         public boolean isSelectable() {
 287             return true;
 288         }
 289 
 290         @Override
 291         public boolean isNamelessWallpaper() {
 292             return true;
 293         }
 294     }
 295 
 296     @TargetApi(Build.VERSION_CODES.KITKAT)
 297     public static class DefaultWallpaperInfo extends WallpaperTileInfo {
 298         public DefaultWallpaperInfo(Drawable thumb) {
 299             mThumb = thumb;
 300         }
 301 
 302         @Override
 303         public void onClick(WallpaperPickerActivity a) {
 304             CropView c = a.getCropView();
<abbr title=" 305             Drawable defaultWallpaper = WallpaperManager.getInstance(a).getBuiltInDrawable(c.getWidth(), c.getHeight(), false, 0.5F, 0.5F);"> 305             Drawable defaultWallpaper = WallpaperManager.getInstance(a).getBuiltInDrawable(c.getWidth(), ðŸ”µ</abbr>
 306             if (defaultWallpaper == null) {
 307                 Log.w(TAG, &quot;Null default wallpaper encountered.&quot;);
 308                 c.setTileSource(null, null);
 309                 return;
 310             }
<abbr title=" 311             c.setTileSource(new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), null);"> 311             c.setTileSource(new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIðŸ”µ</abbr>
 312             c.setScale(1.0F);
 313             c.setTouchEnabled(false);
 314             a.setSystemWallpaperVisiblity(false);
 315         }
 316 
 317         @Override
 318         public void onSave(WallpaperPickerActivity a) {
 319             try {
 320                 WallpaperManager.getInstance(a).clear();
 321                 a.setResult(RESULT_OK);
 322             } catch (IOException e) {
 323                 Log.w(&quot;Setting wallpaper to default threw exception&quot;, e);
 324             }
 325             a.finish();
 326         }
 327 
 328         @Override
 329         public boolean isSelectable() {
 330             return true;
 331         }
 332 
 333         @Override
 334         public boolean isNamelessWallpaper() {
 335             return true;
 336         }
 337     }
 338 
 339     public void setWallpaperStripYOffset(float offset) {
 340         mWallpaperStrip.setPadding(0, 0, 0, (int) offset);
 341     }
 342 
 343     /**
 344      * shows the system wallpaper behind the window and hides the {@link
 345      * #mCropView} if visible
 346      * @param visible should the system wallpaper be shown
 347      */
 348     protected void setSystemWallpaperVisiblity(final boolean visible) {
 349         // hide our own wallpaper preview if necessary
 350         if(!visible) {
 351             mCropView.setVisibility(View.VISIBLE);
 352         } else {
 353             changeWallpaperFlags(visible);
 354         }
 355         // the change of the flag must be delayed in order to avoid flickering,
 356         // a simple post / double post does not suffice here
 357         mCropView.postDelayed(new Runnable() {
 358             @Override
 359             public void run() {
 360                 if(!visible) {
 361                     changeWallpaperFlags(visible);
 362                 } else {
 363                     mCropView.setVisibility(View.INVISIBLE);
 364                 }
 365             }
 366         }, FLAG_POST_DELAY_MILLIS);
 367     }
 368 
 369     private void changeWallpaperFlags(boolean visible) {
 370         int desiredWallpaperFlag = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;
 371         int currentWallpaperFlag = getWindow().getAttributes().flags
 372                 &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
 373         if (desiredWallpaperFlag != currentWallpaperFlag) {
 374             getWindow().setFlags(desiredWallpaperFlag,
 375                     WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
 376         }
 377     }
 378 
 379     @Override
 380     public void setCropViewTileSource(BitmapSource bitmapSource,
 381                                       boolean touchEnabled,
 382                                       boolean moveToLeft,
 383                                       final Runnable postExecute) {
 384         // we also want to show our own wallpaper instead of the one in the background
 385         Runnable showPostExecuteRunnable = new Runnable() {
 386             @Override
 387             public void run() {
 388                 if(postExecute != null) {
 389                     postExecute.run();
 390                 }
 391                 setSystemWallpaperVisiblity(false);
 392             }
 393         };
 394         super.setCropViewTileSource(bitmapSource,
 395                 touchEnabled,
 396                 moveToLeft,
 397                 showPostExecuteRunnable);
 398     }
 399 
 400     // called by onCreate; this is subclassed to overwrite WallpaperCropActivity
 401     protected void init() {
 402         setContentView(R.layout.wallpaper_picker);
 403         mCropView = ((CropView) (findViewById(R.id.cropView)));
 404         mCropView.setVisibility(View.INVISIBLE);
 405         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 406         mCropView.setTouchCallback(new CropView.TouchCallback() {
 407             ViewPropertyAnimator mAnim;
 408 
 409             @Override
 410             public void onTouchDown() {
 411                 if (mAnim != null) {
 412                     mAnim.cancel();
 413                 }
 414                 if (mWallpaperStrip.getAlpha() == 1.0F) {
 415                     mIgnoreNextTap = true;
 416                 }
 417                 mAnim = mWallpaperStrip.animate();
 418                 mAnim.alpha(0.0F).setDuration(150).withEndAction(new Runnable() {
 419                     public void run() {
 420                         mWallpaperStrip.setVisibility(View.INVISIBLE);
 421                     }
 422                 });
 423                 mAnim.setInterpolator(new AccelerateInterpolator(0.75F));
 424                 mAnim.start();
 425             }
 426 
 427             @Override
 428             public void onTouchUp() {
 429                 mIgnoreNextTap = false;
 430             }
 431 
 432             @Override
 433             public void onTap() {
 434                 boolean ignoreTap = mIgnoreNextTap;
 435                 mIgnoreNextTap = false;
 436                 if (!ignoreTap) {
 437                     if (mAnim != null) {
 438                         mAnim.cancel();
 439                     }
 440                     mWallpaperStrip.setVisibility(View.VISIBLE);
 441                     mAnim = mWallpaperStrip.animate();
<abbr title=" 442                     mAnim.alpha(1.0F).setDuration(150).setInterpolator(new DecelerateInterpolator(0.75F));"> 442                     mAnim.alpha(1.0F).setDuration(150).setInterpolator(new DecelerateInterpolator(0.75F))ðŸ”µ</abbr>
 443                     mAnim.start();
 444                 }
 445             }
 446         });
 447         mThumbnailOnClickListener = new OnClickListener() {
 448             public void onClick(View v) {
 449                 if (mActionMode != null) {
 450                     // When CAB is up, clicking toggles the item instead
 451                     if (v.isLongClickable()) {
 452                         mLongClickListener.onLongClick(v);
 453                     }
 454                     return;
 455                 }
 456                 mSetWallpaperButton.setEnabled(true);
 457                 WallpaperTileInfo info = ((WallpaperTileInfo) (v.getTag()));
 458                 if (info.isSelectable() &amp;&amp; (v.getVisibility() == View.VISIBLE)) {
 459                     selectTile(v);
 460                 }
 461                 info.onClick(WallpaperPickerActivity.this);
 462             }
 463         };
 464         mLongClickListener = new View.OnLongClickListener() {
 465             // Called when the user long-clicks on someView
 466             public boolean onLongClick(View view) {
 467                 CheckableFrameLayout c = ((CheckableFrameLayout) (view));
 468                 c.toggle();
 469                 if (mActionMode != null) {
 470                     mActionMode.invalidate();
 471                 } else {
 472                     // Start the CAB using the ActionMode.Callback defined below
 473                     mActionMode = startActionMode(mActionModeCallback);
 474                     int childCount = mWallpapersView.getChildCount();
 475                     for (int i = 0; i &lt; childCount; i++) {
 476                         mWallpapersView.getChildAt(i).setSelected(false);
 477                     }
 478                 }
 479                 return true;
 480             }
 481         };
 482         // Populate the built-in wallpapers
 483         ArrayList&lt;WallpaperTileInfo&gt; wallpapers = findBundledWallpapers();
 484         mWallpapersView = ((LinearLayout) (findViewById(R.id.wallpaper_list)));
 485         SimpleWallpapersAdapter ia = new SimpleWallpapersAdapter(this, wallpapers);
 486         populateWallpapersFromAdapter(mWallpapersView, ia, false);
 487         // Populate the saved wallpapers
 488         mSavedImages = new SavedWallpaperImages(this);
 489         mSavedImages.loadThumbnailsAndImageIdList();
 490         populateWallpapersFromAdapter(mWallpapersView, mSavedImages, true);
 491         // Populate the live wallpapers
<abbr title=" 492         final LinearLayout liveWallpapersView = ((LinearLayout) (findViewById(R.id.live_wallpaper_list)));"> 492         final LinearLayout liveWallpapersView = ((LinearLayout) (findViewById(R.id.live_wallpaper_list)))ðŸ”µ</abbr>
 493         final LiveWallpaperListAdapter a = new LiveWallpaperListAdapter(this);
 494         a.registerDataSetObserver(new DataSetObserver() {
 495             public void onChanged() {
 496                 liveWallpapersView.removeAllViews();
 497                 populateWallpapersFromAdapter(liveWallpapersView, a, false);
 498                 initializeScrollForRtl();
 499                 updateTileIndices();
 500             }
 501         });
 502         // Populate the third-party wallpaper pickers
<abbr title=" 503         final LinearLayout thirdPartyWallpapersView = ((LinearLayout) (findViewById(R.id.third_party_wallpaper_list)));"> 503         final LinearLayout thirdPartyWallpapersView = ((LinearLayout) (findViewById(R.id.third_party_wallðŸ”µ</abbr>
 504         final ThirdPartyWallpaperPickerListAdapter ta = new ThirdPartyWallpaperPickerListAdapter(this);
 505         populateWallpapersFromAdapter(thirdPartyWallpapersView, ta, false);
 506         // Add a tile for the Gallery
 507         LinearLayout masterWallpaperList = ((LinearLayout) (findViewById(R.id.master_wallpaper_list)));
<abbr title=" 508         FrameLayout pickImageTile = ((FrameLayout) (getLayoutInflater().inflate(R.layout.wallpaper_picker_image_picker_item, masterWallpaperList, false)));"> 508         FrameLayout pickImageTile = ((FrameLayout) (getLayoutInflater().inflate(R.layout.wallpaper_pickerðŸ”µ</abbr>
 509         setWallpaperItemPaddingToZero(pickImageTile);
 510         masterWallpaperList.addView(pickImageTile, 0);
 511         // Make its background the last photo taken on external storage
 512         Bitmap lastPhoto = getThumbnailOfLastPhoto();
 513         if (lastPhoto != null) {
<abbr title=" 514             ImageView galleryThumbnailBg = ((ImageView) (pickImageTile.findViewById(R.id.wallpaper_image)));"> 514             ImageView galleryThumbnailBg = ((ImageView) (pickImageTile.findViewById(R.id.wallpaper_image)ðŸ”µ</abbr>
 515             galleryThumbnailBg.setImageBitmap(getThumbnailOfLastPhoto());
 516             int colorOverlay = getResources().getColor(R.color.wallpaper_picker_translucent_gray);
 517             galleryThumbnailBg.setColorFilter(colorOverlay, PorterDuff.Mode.SRC_ATOP);
 518         }
 519         PickImageInfo pickImageInfo = new PickImageInfo();
 520         pickImageTile.setTag(pickImageInfo);
 521         pickImageInfo.setView(pickImageTile);
 522         pickImageTile.setOnClickListener(mThumbnailOnClickListener);
 523         // Select the first item; wait for a layout pass so that we initialize the dimensions of
 524         // cropView or the defaultWallpaperView first
 525         mCropView.addOnLayoutChangeListener(new OnLayoutChangeListener() {
 526             @Override
<abbr title=" 527             public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {"> 527             public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, intðŸ”µ</abbr>
 528                 if (((right - left) &gt; 0) &amp;&amp; ((bottom - top) &gt; 0)) {
 529                     if ((mSelectedIndex &gt;= 0) &amp;&amp; (mSelectedIndex &lt; mWallpapersView.getChildCount())) {
 530                         mThumbnailOnClickListener.onClick(mWallpapersView.getChildAt(mSelectedIndex));
 531                         setSystemWallpaperVisiblity(false);
 532                     }
 533                     v.removeOnLayoutChangeListener(this);
 534                 }
 535             }
 536         });
 537         updateTileIndices();
 538         // Update the scroll for RTL
 539         initializeScrollForRtl();
 540         // Create smooth layout transitions for when items are deleted
 541         final LayoutTransition transitioner = new LayoutTransition();
 542         transitioner.setDuration(200);
 543         transitioner.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 0);
 544         transitioner.setAnimator(LayoutTransition.DISAPPEARING, null);
 545         mWallpapersView.setLayoutTransition(transitioner);
 546         // Action bar
 547         // Show the custom action bar view
 548         final ActionBar actionBar = getActionBar();
 549         actionBar.setCustomView(R.layout.actionbar_set_wallpaper);
 550         actionBar.getCustomView().setOnClickListener(new View.OnClickListener() {
 551             @Override
 552             public void onClick(View v) {
 553                 if (mSelectedTile != null) {
 554                     WallpaperTileInfo info = ((WallpaperTileInfo) (mSelectedTile.getTag()));
 555                     info.onSave(WallpaperPickerActivity.this);
 556                 } else {
 557                     // no tile was selected, so we just finish the activity and go back
 558                     setResult(Activity.RESULT_OK);
 559                     finish();
 560                 }
 561             }
 562         });
 563         mSetWallpaperButton = findViewById(R.id.set_wallpaper_button);
 564         // CAB for deleting items
 565         mActionModeCallback = new ActionMode.Callback() {
 566             // Called when the action mode is created; startActionMode() was called
 567             @Override
 568             public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 569                 // Inflate a menu resource providing context menu items
 570                 MenuInflater inflater = mode.getMenuInflater();
 571                 inflater.inflate(R.menu.cab_delete_wallpapers, menu);
 572                 return true;
 573             }
 574 
 575             private int numCheckedItems() {
 576                 int childCount = mWallpapersView.getChildCount();
 577                 int numCheckedItems = 0;
 578                 for (int i = 0; i &lt; childCount; i++) {
 579                     CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 580                     if (c.isChecked()) {
 581                         numCheckedItems++;
 582                     }
 583                 }
 584                 return numCheckedItems;
 585             }
 586 
 587             // Called each time the action mode is shown. Always called after onCreateActionMode,
 588             // but may be called multiple times if the mode is invalidated.
 589             @Override
 590             public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 591                 int numCheckedItems = numCheckedItems();
 592                 if (numCheckedItems == 0) {
 593                     mode.finish();
 594                     return true;
 595                 } else {
 596                     mode.setTitle(getResources().getQuantityString(
 597                             R.plurals.number_of_items_selected, numCheckedItems, numCheckedItems));
 598                     return true;
 599                 }
 600             }
 601 
 602             // Called when the user selects a contextual menu item
 603             @Override
 604             public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 605                 int itemId = item.getItemId();
 606                 if (itemId == R.id.menu_delete) {
 607                     int childCount = mWallpapersView.getChildCount();
 608                     ArrayList&lt;View&gt; viewsToRemove = new ArrayList&lt;View&gt;();
 609                     boolean selectedTileRemoved = false;
 610                     for (int i = 0; i &lt; childCount; i++) {
<abbr title=" 611                         CheckableFrameLayout c = ((CheckableFrameLayout) (mWallpapersView.getChildAt(i)));"> 611                         CheckableFrameLayout c = ((CheckableFrameLayout) (mWallpapersView.getChildAt(i)))ðŸ”µ</abbr>
 612                         if (c.isChecked()) {
 613                             WallpaperTileInfo info = ((WallpaperTileInfo) (c.getTag()));
 614                             info.onDelete(WallpaperPickerActivity.this);
 615                             viewsToRemove.add(c);
 616                             if (i == mSelectedIndex) {
 617                                 selectedTileRemoved = true;
 618                             }
 619                         }
 620                     }
 621                     for (View v : viewsToRemove) {
 622                         mWallpapersView.removeView(v);
 623                     }
 624                     if (selectedTileRemoved) {
 625                         mSelectedIndex = -1;
 626                         mSelectedTile = null;
 627                         setSystemWallpaperVisiblity(true);
 628                     }
 629                     updateTileIndices();
 630                     mode.finish();// Action picked, so close the CAB
 631 
 632                     return true;
 633                 } else {
 634                     return false;
 635                 }
 636             }
 637 
 638             // Called when the user exits the action mode
 639             @Override
 640             public void onDestroyActionMode(ActionMode mode) {
 641                 int childCount = mWallpapersView.getChildCount();
 642                 for (int i = 0; i &lt; childCount; i++) {
 643                     CheckableFrameLayout c = ((CheckableFrameLayout) (mWallpapersView.getChildAt(i)));
 644                     c.setChecked(false);
 645                 }
 646                 if (mSelectedTile != null) {
 647                     mSelectedTile.setSelected(true);
 648                 }
 649                 mActionMode = null;
 650             }
 651         };
 652     }
 653 
 654     private void selectTile(View v) {
 655         if (mSelectedTile != null) {
 656             mSelectedTile.setSelected(false);
 657             mSelectedTile = null;
 658         }
 659         mSelectedTile = v;
 660         v.setSelected(true);
 661         mSelectedIndex = mWallpapersView.indexOfChild(v);
 662         // TODO: Remove this once the accessibility framework and
 663         // services have better support for selection state.
 664         v.announceForAccessibility(
 665                 getString(R.string.announce_selection, v.getContentDescription()));
 666     }
 667 
 668     private void initializeScrollForRtl() {
 669         final HorizontalScrollView scroll =
 670                 (HorizontalScrollView) findViewById(R.id.wallpaper_scroll_container);
 671 
 672         if (scroll.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
 673             final ViewTreeObserver observer = scroll.getViewTreeObserver();
 674             observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
 675                 public void onGlobalLayout() {
 676                     LinearLayout masterWallpaperList =
 677                             (LinearLayout) findViewById(R.id.master_wallpaper_list);
 678                     scroll.scrollTo(masterWallpaperList.getWidth(), 0);
 679                     scroll.getViewTreeObserver().removeOnGlobalLayoutListener(this);
 680                 }
 681             });
 682         }
 683     }
 684 
 685     protected Bitmap getThumbnailOfLastPhoto() {
<abbr title=" 686         Cursor cursor = MediaStore.Images.Media.query(getContentResolver(), MediaStore.Images.Media.EXTERNAL_CONTENT_URI, new String[]{ MediaStore.Images.ImageColumns._ID, MediaStore.Images.ImageColumns.DATE_TAKEN }, null, null, MediaStore.Images.ImageColumns.DATE_TAKEN + &quot; DESC LIMIT 1&quot;);"> 686         Cursor cursor = MediaStore.Images.Media.query(getContentResolver(), MediaStore.Images.Media.EXTERðŸ”µ</abbr>
 687         Bitmap thumb = null;
 688         if (cursor != null) {
 689             if (cursor.moveToNext()) {
 690                 int id = cursor.getInt(0);
<abbr title=" 691                 thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(), id, MediaStore.Images.Thumbnails.MINI_KIND, null);"> 691                 thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(), id, MediaStore.ImðŸ”µ</abbr>
 692             }
 693             cursor.close();
 694         }
 695         return thumb;
 696     }
 697 
 698     protected void onStop() {
 699         super.onStop();
 700         mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 701         if (mWallpaperStrip.getAlpha() &lt; 1f) {
 702             mWallpaperStrip.setAlpha(1f);
 703             mWallpaperStrip.setVisibility(View.VISIBLE);
 704         }
 705     }
 706 
 707     protected void onSaveInstanceState(Bundle outState) {
 708         outState.putParcelableArrayList(TEMP_WALLPAPER_TILES, mTempWallpaperTiles);
 709         outState.putInt(SELECTED_INDEX, mSelectedIndex);
 710     }
 711 
 712     protected void onRestoreInstanceState(Bundle savedInstanceState) {
 713         ArrayList&lt;Uri&gt; uris = savedInstanceState.getParcelableArrayList(TEMP_WALLPAPER_TILES);
 714         for (Uri uri : uris) {
 715             addTemporaryWallpaperTile(uri, true);
 716         }
 717         mSelectedIndex = savedInstanceState.getInt(SELECTED_INDEX, -1);
 718     }
 719 
 720     private void populateWallpapersFromAdapter(ViewGroup parent, BaseAdapter adapter,
 721             boolean addLongPressHandler) {
 722         for (int i = 0; i &lt; adapter.getCount(); i++) {
 723             FrameLayout thumbnail = (FrameLayout) adapter.getView(i, null, parent);
 724             parent.addView(thumbnail, i);
 725             WallpaperTileInfo info = (WallpaperTileInfo) adapter.getItem(i);
 726             thumbnail.setTag(info);
 727             info.setView(thumbnail);
 728             if (addLongPressHandler) {
 729                 addLongPressHandler(thumbnail);
 730             }
 731             thumbnail.setOnClickListener(mThumbnailOnClickListener);
 732         }
 733     }
 734 
 735     private void updateTileIndices() {
 736         LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 737         final int childCount = masterWallpaperList.getChildCount();
 738         final Resources res = getResources();
 739 
 740         // Do two passes; the first pass gets the total number of tiles
 741         int numTiles = 0;
 742         for (int passNum = 0; passNum &lt; 2; passNum++) {
 743             int tileIndex = 0;
 744             for (int i = 0; i &lt; childCount; i++) {
 745                 View child = masterWallpaperList.getChildAt(i);
 746                 LinearLayout subList;
 747 
 748                 int subListStart;
 749                 int subListEnd;
 750                 if (child.getTag() instanceof WallpaperTileInfo) {
 751                     subList = masterWallpaperList;
 752                     subListStart = i;
 753                     subListEnd = i + 1;
 754                 } else { // if (child instanceof LinearLayout) {
 755                     subList = (LinearLayout) child;
 756                     subListStart = 0;
 757                     subListEnd = subList.getChildCount();
 758                 }
 759 
 760                 for (int j = subListStart; j &lt; subListEnd; j++) {
 761                     WallpaperTileInfo info = (WallpaperTileInfo) subList.getChildAt(j).getTag();
 762                     if (info.isNamelessWallpaper()) {
 763                         if (passNum == 0) {
 764                             numTiles++;
 765                         } else {
 766                             CharSequence label = res.getString(
 767                                     R.string.wallpaper_accessibility_name, ++tileIndex, numTiles);
 768                             info.onIndexUpdated(label);
 769                         }
 770                     }
 771                 }
 772             }
 773         }
 774     }
 775 
 776     private static Point getDefaultThumbnailSize(Resources res) {
 777         return new Point(res.getDimensionPixelSize(R.dimen.wallpaperThumbnailWidth),
 778                 res.getDimensionPixelSize(R.dimen.wallpaperThumbnailHeight));
 779 
 780     }
 781 
 782     private static Bitmap createThumbnail(Point size, Context context, Uri uri, byte[] imageBytes,
 783             Resources res, int resId, int rotation, boolean leftAligned) {
 784         int width = size.x;
 785         int height = size.y;
 786 
 787         BitmapCropTask cropTask;
 788         if (uri != null) {
 789             cropTask = new BitmapCropTask(
 790                     context, uri, null, rotation, width, height, false, true, null);
 791         } else if (imageBytes != null) {
 792             cropTask = new BitmapCropTask(
 793                     imageBytes, null, rotation, width, height, false, true, null);
 794         }  else {
 795             cropTask = new BitmapCropTask(
 796                     context, res, resId, null, rotation, width, height, false, true, null);
 797         }
 798         Point bounds = cropTask.getImageBounds();
 799         if (bounds == null || bounds.x == 0 || bounds.y == 0) {
 800             return null;
 801         }
 802 
 803         Matrix rotateMatrix = new Matrix();
 804         rotateMatrix.setRotate(rotation);
 805         float[] rotatedBounds = new float[] { bounds.x, bounds.y };
 806         rotateMatrix.mapPoints(rotatedBounds);
 807         rotatedBounds[0] = Math.abs(rotatedBounds[0]);
 808         rotatedBounds[1] = Math.abs(rotatedBounds[1]);
 809 
 810         RectF cropRect = WallpaperCropActivity.getMaxCropRect(
 811                 (int) rotatedBounds[0], (int) rotatedBounds[1], width, height, leftAligned);
 812         cropTask.setCropBounds(cropRect);
 813 
 814         if (cropTask.cropBitmap()) {
 815             return cropTask.getCroppedBitmap();
 816         } else {
 817             return null;
 818         }
 819     }
 820 
 821     private void addTemporaryWallpaperTile(final Uri uri, boolean fromRestore) {
 822         mTempWallpaperTiles.add(uri);
 823         // Add a tile for the image picked from Gallery
<abbr title=" 824         final FrameLayout pickedImageThumbnail = ((FrameLayout) (getLayoutInflater().inflate(R.layout.wallpaper_picker_item, mWallpapersView, false)));"> 824         final FrameLayout pickedImageThumbnail = ((FrameLayout) (getLayoutInflater().inflate(R.layout.walðŸ”µ</abbr>
 825         pickedImageThumbnail.setVisibility(View.GONE);
 826         setWallpaperItemPaddingToZero(pickedImageThumbnail);
 827         mWallpapersView.addView(pickedImageThumbnail, 0);
 828         // Load the thumbnail
 829         final ImageView image = ((ImageView) (pickedImageThumbnail.findViewById(R.id.wallpaper_image)));
 830         final Point defaultSize = getDefaultThumbnailSize(this.getResources());
 831         final Context context = this;
 832         new AsyncTask&lt;Void, Bitmap, Bitmap&gt;() {
 833             protected Bitmap doInBackground(Void... args) {
 834                 try {
 835                     int rotation = WallpaperCropActivity.getRotationFromExif(context, uri);
 836                     return createThumbnail(defaultSize, context, uri, null, null, 0, rotation, false);
 837                 } catch (java.lang.SecurityException securityException) {
 838                     if (isDestroyed()) {
 839                         // Temporarily granted permissions are revoked when the activity
 840                         // finishes, potentially resulting in a SecurityException here.
 841                         // Even though {@link #isDestroyed} might also return true in different
 842                         // situations where the configuration changes, we are fine with
 843                         // catching these cases here as well.
 844                         cancel(false);
 845                     } else {
 846                         // otherwise it had a different cause and we throw it further
 847                         throw securityException;
 848                     }
 849                     return null;
 850                 }
 851             }
 852 
 853             protected void onPostExecute(Bitmap thumb) {
 854                 if ((!isCancelled()) &amp;&amp; (thumb != null)) {
 855                     image.setImageBitmap(thumb);
 856                     Drawable thumbDrawable = image.getDrawable();
 857                     thumbDrawable.setDither(true);
 858                     pickedImageThumbnail.setVisibility(View.VISIBLE);
 859                 } else {
 860                     Log.e(TAG, &quot;Error loading thumbnail for uri=&quot; + uri);
 861                 }
 862             }
 863         }.execute();
 864         UriWallpaperInfo info = new UriWallpaperInfo(uri);
 865         pickedImageThumbnail.setTag(info);
 866         info.setView(pickedImageThumbnail);
 867         addLongPressHandler(pickedImageThumbnail);
 868         updateTileIndices();
 869         pickedImageThumbnail.setOnClickListener(mThumbnailOnClickListener);
 870         if (!fromRestore) {
 871             mThumbnailOnClickListener.onClick(pickedImageThumbnail);
 872         }
 873     }
 874 
 875     protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 876         if ((requestCode == IMAGE_PICK) &amp;&amp; (resultCode == RESULT_OK)) {
 877             if ((data != null) &amp;&amp; (data.getData() != null)) {
 878                 Uri uri = data.getData();
 879                 addTemporaryWallpaperTile(uri, false);
 880             }
 881         } else if (requestCode == PICK_WALLPAPER_THIRD_PARTY_ACTIVITY) {
 882             setResult(RESULT_OK);
 883             finish();
 884         } else if (requestCode == PICK_LIVE_WALLPAPER) {
 885             WallpaperManager wm = WallpaperManager.getInstance(this);
 886             final WallpaperInfo oldLiveWallpaper = mLiveWallpaperInfoOnPickerLaunch;
 887             final WallpaperInfo clickedWallpaper = mLastClickedLiveWallpaperInfo;
 888             WallpaperInfo newLiveWallpaper = wm.getWallpaperInfo();
 889             // Try to figure out if a live wallpaper was set;
<abbr title=" 890             if ((newLiveWallpaper != null) &amp;&amp; (((oldLiveWallpaper == null) || (!oldLiveWallpaper.getComponent().equals(newLiveWallpaper.getComponent()))) || clickedWallpaper.getComponent().equals(oldLiveWallpaper.getComponent()))) {"> 890             if ((newLiveWallpaper != null) &amp;&amp; (((oldLiveWallpaper == null) || (!oldLiveWallpaper.getCompoðŸ”µ</abbr>
 891                 // Return if a live wallpaper was set
 892                 setResult(RESULT_OK);
 893                 finish();
 894             }
 895         }
 896     }
 897 
 898     static void setWallpaperItemPaddingToZero(FrameLayout frameLayout) {
 899         frameLayout.setPadding(0, 0, 0, 0);
 900         frameLayout.setForeground(new ZeroPaddingDrawable(frameLayout.getForeground()));
 901     }
 902 
 903     private void addLongPressHandler(View v) {
 904         v.setOnLongClickListener(mLongClickListener);
 905     }
 906 
 907     private ArrayList&lt;WallpaperTileInfo&gt; findBundledWallpapers() {
 908         final PackageManager pm = getPackageManager();
 909         final ArrayList&lt;WallpaperTileInfo&gt; bundled = new ArrayList&lt;WallpaperTileInfo&gt;(24);
 910         Partner partner = Partner.get(pm);
 911         if (partner != null) {
 912             final Resources partnerRes = partner.getResources();
<abbr title=" 913             final int resId = partnerRes.getIdentifier(Partner.RES_WALLPAPERS, &quot;array&quot;, partner.getPackageName());"> 913             final int resId = partnerRes.getIdentifier(Partner.RES_WALLPAPERS, &quot;array&quot;, partner.getPackagðŸ”µ</abbr>
 914             if (resId != 0) {
 915                 addWallpapers(bundled, partnerRes, partner.getPackageName(), resId);
 916             }
 917             // Add system wallpapers
 918             File systemDir = partner.getWallpaperDirectory();
 919             if ((systemDir != null) &amp;&amp; systemDir.isDirectory()) {
 920                 for (File file : systemDir.listFiles()) {
 921                     if (!file.isFile()) {
 922                         continue;
 923                     }
 924                     String name = file.getName();
 925                     int dotPos = name.lastIndexOf(&#x27;.&#x27;);
 926                     String extension = &quot;&quot;;
 927                     if (dotPos &gt;= (-1)) {
 928                         extension = name.substring(dotPos);
 929                         name = name.substring(0, dotPos);
 930                     }
 931                     if (name.endsWith(&quot;_small&quot;)) {
 932                         // it is a thumbnail
 933                         continue;
 934                     }
 935                     File thumbnail = new File(systemDir, (name + &quot;_small&quot;) + extension);
 936                     Bitmap thumb = BitmapFactory.decodeFile(thumbnail.getAbsolutePath());
 937                     if (thumb != null) {
 938                         bundled.add(new FileWallpaperInfo(file, new BitmapDrawable(thumb)));
 939                     }
 940                 }
 941             }
 942         }
 943         Pair&lt;ApplicationInfo, Integer&gt; r = getWallpaperArrayResourceId();
 944         if (r != null) {
 945             try {
 946                 Resources wallpaperRes = getPackageManager().getResourcesForApplication(r.first);
 947                 addWallpapers(bundled, wallpaperRes, r.first.packageName, r.second);
 948             } catch (PackageManager e) {
 949             }
 950         }
 951         if ((partner == null) || (!partner.hideDefaultWallpaper())) {
 952             // Add an entry for the default wallpaper (stored in system resources)
<abbr title=" 953             WallpaperTileInfo defaultWallpaperInfo = (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) ? getPreKKDefaultWallpaperInfo() : getDefaultWallpaper();"> 953             WallpaperTileInfo defaultWallpaperInfo = (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT)ðŸ”µ</abbr>
 954             if (defaultWallpaperInfo != null) {
 955                 bundled.add(0, defaultWallpaperInfo);
 956             }
 957         }
 958         return bundled;
 959     }
 960 
 961     private boolean writeImageToFileAsJpeg(File f, Bitmap b) {
 962         try {
 963             f.createNewFile();
 964             FileOutputStream thumbFileStream =
 965                     openFileOutput(f.getName(), Context.MODE_PRIVATE);
 966             b.compress(Bitmap.CompressFormat.JPEG, 95, thumbFileStream);
 967             thumbFileStream.close();
 968             return true;
 969         } catch (IOException e) {
 970             Log.e(TAG, &quot;Error while writing bitmap to file &quot; + e);
 971             f.delete();
 972         }
 973         return false;
 974     }
 975 
 976     private File getDefaultThumbFile() {
<abbr title=" 977         return new File(getFilesDir(), (Build.VERSION.SDK_INT + &quot;_&quot;) + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);"> 977         return new File(getFilesDir(), (Build.VERSION.SDK_INT + &quot;_&quot;) + DEFAULT_WALLPAPER_THUMBNAIL_FILENAðŸ”µ</abbr>
 978     }
 979 
 980     private boolean saveDefaultWallpaperThumb(Bitmap b) {
 981         // Delete old thumbnails.
 982         new File(getFilesDir(), OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
 983         new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
 984         for (int i = Build.VERSION_CODES.JELLY_BEAN; i &lt; Build.VERSION.SDK_INT; i++) {
 985             new File(getFilesDir(), (i + &quot;_&quot;) + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();
 986         }
 987         return writeImageToFileAsJpeg(getDefaultThumbFile(), b);
 988     }
 989 
 990     private ResourceWallpaperInfo getPreKKDefaultWallpaperInfo() {
 991         Resources sysRes = Resources.getSystem();
 992         int resId = sysRes.getIdentifier(&quot;default_wallpaper&quot;, &quot;drawable&quot;, &quot;android&quot;);
 993         File defaultThumbFile = getDefaultThumbFile();
 994         Bitmap thumb = null;
 995         boolean defaultWallpaperExists = false;
 996         if (defaultThumbFile.exists()) {
 997             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
 998             defaultWallpaperExists = true;
 999         } else {
1000             Resources res = getResources();
1001             Point defaultThumbSize = getDefaultThumbnailSize(res);
1002             int rotation = WallpaperCropActivity.getRotationFromExif(res, resId);
1003             thumb = createThumbnail(defaultThumbSize, this, null, null, sysRes, resId, rotation, false);
1004             if (thumb != null) {
1005                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1006             }
1007         }
1008         if (defaultWallpaperExists) {
1009             return new ResourceWallpaperInfo(sysRes, resId, new BitmapDrawable(thumb));
1010         }
1011         return null;
1012     }
1013 
1014     @TargetApi(Build.VERSION_CODES.KITKAT)
1015     private DefaultWallpaperInfo getDefaultWallpaper() {
1016         File defaultThumbFile = getDefaultThumbFile();
1017         Bitmap thumb = null;
1018         boolean defaultWallpaperExists = false;
1019         if (defaultThumbFile.exists()) {
1020             thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1021             defaultWallpaperExists = true;
1022         } else {
1023             Resources res = getResources();
1024             Point defaultThumbSize = getDefaultThumbnailSize(res);
<abbr title="1025             Drawable wallpaperDrawable = WallpaperManager.getInstance(this).getBuiltInDrawable(defaultThumbSize.x, defaultThumbSize.y, true, 0.5F, 0.5F);">1025             Drawable wallpaperDrawable = WallpaperManager.getInstance(this).getBuiltInDrawable(defaultThuðŸ”µ</abbr>
1026             if (wallpaperDrawable != null) {
<abbr title="1027                 thumb = Bitmap.createBitmap(defaultThumbSize.x, defaultThumbSize.y, Bitmap.Config.ARGB_8888);">1027                 thumb = Bitmap.createBitmap(defaultThumbSize.x, defaultThumbSize.y, Bitmap.Config.ARGB_88ðŸ”µ</abbr>
1028                 Canvas c = new Canvas(thumb);
1029                 wallpaperDrawable.setBounds(0, 0, defaultThumbSize.x, defaultThumbSize.y);
1030                 wallpaperDrawable.draw(c);
1031                 c.setBitmap(null);
1032             }
1033             if (thumb != null) {
1034                 defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);
1035             }
1036         }
1037         if (defaultWallpaperExists) {
1038             return new DefaultWallpaperInfo(new BitmapDrawable(thumb));
1039         }
1040         return null;
1041     }
1042 
1043     public Pair&lt;ApplicationInfo, Integer&gt; getWallpaperArrayResourceId() {
1044         // Context.getPackageName() may return the &quot;original&quot; package name,
1045         // com.android.launcher3; Resources needs the real package name,
1046         // com.android.launcher3. So we ask Resources for what it thinks the
1047         // package name should be.
1048         final String packageName = getResources().getResourcePackageName(R.array.wallpapers);
1049         try {
1050             ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, 0);
1051             return new Pair&lt;ApplicationInfo, Integer&gt;(info, R.array.wallpapers);
1052         } catch (PackageManager.NameNotFoundException e) {
1053             return null;
1054         }
1055     }
1056 
<abbr title="1057     private void addWallpapers(ArrayList&lt;WallpaperTileInfo&gt; known, Resources res, String packageName, int listResId) {">1057     private void addWallpapers(ArrayList&lt;WallpaperTileInfo&gt; known, Resources res, String packageName, intðŸ”µ</abbr>
1058         final String[] extras = res.getStringArray(listResId);
1059         for (String extra : extras) {
1060             int resId = res.getIdentifier(extra, &quot;drawable&quot;, packageName);
1061             if (resId != 0) {
1062                 final int thumbRes = res.getIdentifier(extra + &quot;_small&quot;, &quot;drawable&quot;, packageName);
1063                 if (thumbRes != 0) {
<abbr title="1064                     ResourceWallpaperInfo wallpaperInfo = new ResourceWallpaperInfo(res, resId, res.getDrawable(thumbRes));">1064                     ResourceWallpaperInfo wallpaperInfo = new ResourceWallpaperInfo(res, resId, res.getDrðŸ”µ</abbr>
1065                     known.add(wallpaperInfo);
1066                     // Log.d(TAG, &quot;add: [&quot; + packageName + &quot;]: &quot; + extra + &quot; (&quot; + res + &quot;)&quot;);
1067                 }
1068             } else {
1069                 Log.e(TAG, &quot;Couldn&#x27;t find wallpaper &quot; + extra);
1070             }
1071         }
1072     }
1073 
1074     public CropView getCropView() {
1075         return mCropView;
1076     }
1077 
1078     public SavedWallpaperImages getSavedImages() {
1079         return mSavedImages;
1080     }
1081 
1082     public void onLiveWallpaperPickerLaunch(WallpaperInfo info) {
1083         mLastClickedLiveWallpaperInfo = info;
1084         mLiveWallpaperInfoOnPickerLaunch = WallpaperManager.getInstance(this).getWallpaperInfo();
1085     }
1086 
1087     static class ZeroPaddingDrawable extends LevelListDrawable {
1088         public ZeroPaddingDrawable(Drawable d) {
1089             super();
1090             addLevel(0, 0, d);
1091             setLevel(0);
1092         }
1093 
1094         @Override
1095         public boolean getPadding(Rect padding) {
1096             padding.set(0, 0, 0, 0);
1097             return true;
1098         }
1099     }
1100 
1101     private static class SimpleWallpapersAdapter extends ArrayAdapter&lt;WallpaperTileInfo&gt; {
1102         private final LayoutInflater mLayoutInflater;
1103 
1104         SimpleWallpapersAdapter(Activity activity, ArrayList&lt;WallpaperTileInfo&gt; wallpapers) {
1105             super(activity, R.layout.wallpaper_picker_item, wallpapers);
1106             mLayoutInflater = activity.getLayoutInflater();
1107         }
1108 
1109         public View getView(int position, View convertView, ViewGroup parent) {
1110             Drawable thumb = getItem(position).mThumb;
1111             if (thumb == null) {
1112                 Log.e(TAG, &quot;Error decoding thumbnail for wallpaper #&quot; + position);
1113             }
1114             return createImageTileView(mLayoutInflater, convertView, parent, thumb);
1115         }
1116     }
1117 
<abbr title="1118     public static View createImageTileView(LayoutInflater layoutInflater, View convertView, ViewGroup parent, Drawable thumb) {">1118     public static View createImageTileView(LayoutInflater layoutInflater, View convertView, ViewGroup parðŸ”µ</abbr>
1119         View view;
1120         if (convertView == null) {
1121             view = layoutInflater.inflate(R.layout.wallpaper_picker_item, parent, false);
1122         } else {
1123             view = convertView;
1124         }
1125         setWallpaperItemPaddingToZero(((FrameLayout) (view)));
1126         ImageView image = ((ImageView) (view.findViewById(R.id.wallpaper_image)));
1127         if (thumb != null) {
1128             image.setImageDrawable(thumb);
1129             thumb.setDither(true);
1130         }
1131         return view;
1132     }
1133 
1134     // In Launcher3, we override this with a method that catches exceptions
1135     // from starting activities; didn&#x27;t want to copy and paste code into here
1136     public void startActivityForResultSafely(Intent intent, int requestCode) {
1137         startActivityForResult(intent, requestCode);
1138     }
1139 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -import android.animation.Animator;</span>
  20  import android.animation.LayoutTransition;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import android.annotation.TargetApi;</span>
  22  import android.app.ActionBar;
  23  import android.app.Activity;
  24  import android.app.WallpaperInfo;
  25  import android.app.WallpaperManager;
  26  import android.content.Context;
  27  import android.content.Intent;
  28  import android.content.pm.ApplicationInfo;
  29  import android.content.pm.PackageManager;
  30  import android.content.res.Resources;
  31  import android.database.Cursor;
  32  import android.database.DataSetObserver;
  33  import android.graphics.Bitmap;
  34  import android.graphics.BitmapFactory;
  35  import android.graphics.Canvas;
  36  import android.graphics.Matrix;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import android.graphics.Paint;</span>
  38  import android.graphics.Point;
  39  import android.graphics.PorterDuff;
  40  import android.graphics.Rect;
  41  import android.graphics.RectF;
  42  import android.graphics.drawable.BitmapDrawable;
  43  import android.graphics.drawable.Drawable;
  44  import android.graphics.drawable.LevelListDrawable;
  45  import android.net.Uri;
  46  import android.os.AsyncTask;
  47  import android.os.Build;
  48  import android.os.Bundle;
  49  import android.provider.MediaStore;
  50  import android.util.Log;
  51  import android.util.Pair;
  52  import android.view.ActionMode;
  53  import android.view.LayoutInflater;
  54  import android.view.Menu;
  55  import android.view.MenuInflater;
  56  import android.view.MenuItem;
  57  import android.view.View;
  58  import android.view.View.OnClickListener;
  59  import android.view.View.OnLayoutChangeListener;
  60  import android.view.ViewGroup;
  61  import android.view.ViewPropertyAnimator;
  62  import android.view.ViewTreeObserver;
  63  import android.view.ViewTreeObserver.OnGlobalLayoutListener;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import android.view.WindowManager;</span>
  65  import android.view.animation.AccelerateInterpolator;
  66  import android.view.animation.DecelerateInterpolator;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +import android.widget.ArrayAdapter;</span>
  68  import android.widget.BaseAdapter;
  69  import android.widget.FrameLayout;
  70  import android.widget.HorizontalScrollView;
  71  import android.widget.ImageView;
  72  import android.widget.LinearLayout;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -import android.widget.ListAdapter;</span>
  74  import android.widget.Toast;
  75  
  76  import com.android.photos.BitmapRegionTileSource;
  77  import com.android.photos.BitmapRegionTileSource.BitmapSource;
  78  
  79  import java.io.File;
  80  import java.io.FileOutputStream;
  81  import java.io.IOException;
  82  import java.util.ArrayList;
  83  
  84  public class WallpaperPickerActivity extends WallpaperCropActivity {
  85      static final String TAG = &quot;Launcher.WallpaperPickerActivity&quot;;
  86  
  87      public static final int IMAGE_PICK = 5;
  88      public static final int PICK_WALLPAPER_THIRD_PARTY_ACTIVITY = 6;
  89      public static final int PICK_LIVE_WALLPAPER = 7;
  90      private static final String TEMP_WALLPAPER_TILES = &quot;TEMP_WALLPAPER_TILES&quot;;
  91      private static final String SELECTED_INDEX = &quot;SELECTED_INDEX&quot;;
  92      private static final String OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb.jpg&quot;;
  93      private static final String DEFAULT_WALLPAPER_THUMBNAIL_FILENAME = &quot;default_thumb2.jpg&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +    private static final int FLAG_POST_DELAY_MILLIS = 200;</span>
  95  
  96      private View mSelectedTile;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    private View mSetWallpaperButton;</span>
  98      private boolean mIgnoreNextTap;
  99      private OnClickListener mThumbnailOnClickListener;
 100  
 101      private LinearLayout mWallpapersView;
 102      private View mWallpaperStrip;
 103  
 104      private ActionMode.Callback mActionModeCallback;
 105      private ActionMode mActionMode;
 106  
 107      private View.OnLongClickListener mLongClickListener;
 108  
 109      ArrayList&lt;Uri&gt; mTempWallpaperTiles = new ArrayList&lt;Uri&gt;();
 110      private SavedWallpaperImages mSavedImages;
 111      private WallpaperInfo mLiveWallpaperInfoOnPickerLaunch;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -    private int mSelectedIndex;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    private int mSelectedIndex = -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +    private WallpaperInfo mLastClickedLiveWallpaperInfo;</span>
 115  
 116      public static abstract class WallpaperTileInfo {
 117          protected View mView;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +        public Drawable mThumb;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +</span>
 120          public void setView(View v) {
 121              mView = v;
 122          }
 123          public void onClick(WallpaperPickerActivity a) {}
 124          public void onSave(WallpaperPickerActivity a) {}
 125          public void onDelete(WallpaperPickerActivity a) {}
 126          public boolean isSelectable() { return false; }
 127          public boolean isNamelessWallpaper() { return false; }
 128          public void onIndexUpdated(CharSequence label) {
 129              if (isNamelessWallpaper()) {
 130                  mView.setContentDescription(label);
 131              }
 132          }
 133      }
 134  
 135      public static class PickImageInfo extends WallpaperTileInfo {
 136          @Override
 137          public void onClick(WallpaperPickerActivity a) {
 138              Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
 139              intent.setType(&quot;image/*&quot;);
 140              a.startActivityForResultSafely(intent, IMAGE_PICK);
 141          }
 142      }
 143  
 144      public static class UriWallpaperInfo extends WallpaperTileInfo {
 145          private Uri mUri;
 146          private boolean mFirstClick = true;
 147          private BitmapRegionTileSource.UriBitmapSource mBitmapSource;
 148          public UriWallpaperInfo(Uri uri) {
 149              mUri = uri;
 150          }
 151          @Override
 152          public void onClick(final WallpaperPickerActivity a) {
 153              final Runnable onLoad;
 154              if (!mFirstClick) {
 155                  onLoad = null;
 156              } else {
 157                  mFirstClick = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -                a.mSetWallpaperButton.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +                a.mSetWallpaperButton.setEnabled(false);</span>
 160                  onLoad = new Runnable() {
 161                      public void run() {
 162                          if (mBitmapSource != null &amp;&amp;
 163                                  mBitmapSource.getLoadingState() == BitmapSource.State.LOADED) {
 164                              a.selectTile(mView);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -                            a.mSetWallpaperButton.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +                            a.mSetWallpaperButton.setEnabled(true);</span>
 167                          } else {
 168                              ViewGroup parent = (ViewGroup) mView.getParent();
 169                              if (parent != null) {
 170                                  parent.removeView(mView);
 171                                  Toast.makeText(a,
 172                                          a.getString(R.string.image_load_fail),
 173                                          Toast.LENGTH_SHORT).show();
 174                              }
 175                          }
 176                      }
 177                  };
 178              }
 179              mBitmapSource = new BitmapRegionTileSource.UriBitmapSource(
 180                      a, mUri, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 181              a.setCropViewTileSource(mBitmapSource, true, false, onLoad);
 182          }
 183          @Override
 184          public void onSave(final WallpaperPickerActivity a) {
 185              boolean finishActivityWhenDone = true;
 186              OnBitmapCroppedHandler h = new OnBitmapCroppedHandler() {
 187                  public void onBitmapCropped(byte[] imageBytes) {
 188                      Point thumbSize = getDefaultThumbnailSize(a.getResources());
 189                      // rotation is set to 0 since imageBytes has already been correctly rotated
 190                      Bitmap thumb = createThumbnail(
 191                              thumbSize, null, null, imageBytes, null, 0, 0, true);
 192                      a.getSavedImages().writeImage(thumb, imageBytes);
 193                  }
 194              };
 195              a.cropImageAndSetWallpaper(mUri, h, finishActivityWhenDone);
 196          }
 197          @Override
 198          public boolean isSelectable() {
 199              return true;
 200          }
 201          @Override
 202          public boolean isNamelessWallpaper() {
 203              return true;
 204          }
 205      }
 206  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +    public static class FileWallpaperInfo extends WallpaperTileInfo {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +        private File mFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +        public FileWallpaperInfo(File target, Drawable thumb) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +            mFile = target;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +            mThumb = thumb;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +        public void onClick(WallpaperPickerActivity a) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +            BitmapRegionTileSource.UriBitmapSource bitmapSource =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +                    new BitmapRegionTileSource.UriBitmapSource(a, Uri.fromFile(mFile), 1024);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +            a.setCropViewTileSource(bitmapSource, false, true, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +        public void onSave(WallpaperPickerActivity a) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +            a.setWallpaper(Uri.fromFile(mFile), true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        public boolean isSelectable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +        public boolean isNamelessWallpaper() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +</span>
 234      public static class ResourceWallpaperInfo extends WallpaperTileInfo {
 235          private Resources mResources;
 236          private int mResId;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        private Drawable mThumb;</span>
 238  
 239          public ResourceWallpaperInfo(Resources res, int resId, Drawable thumb) {
 240              mResources = res;
 241              mResId = resId;
 242              mThumb = thumb;
 243          }
 244          @Override
 245          public void onClick(WallpaperPickerActivity a) {
 246              BitmapRegionTileSource.ResourceBitmapSource bitmapSource =
 247                      new BitmapRegionTileSource.ResourceBitmapSource(
 248                              mResources, mResId, BitmapRegionTileSource.MAX_PREVIEW_SIZE);
 249              bitmapSource.loadInBackground();
 250              BitmapRegionTileSource source = new BitmapRegionTileSource(a, bitmapSource);
 251              CropView v = a.getCropView();
 252              v.setTileSource(source, null);
 253              Point wallpaperSize = WallpaperCropActivity.getDefaultWallpaperSize(
 254                      a.getResources(), a.getWindowManager());
 255              RectF crop = WallpaperCropActivity.getMaxCropRect(
 256                      source.getImageWidth(), source.getImageHeight(),
 257                      wallpaperSize.x, wallpaperSize.y, false);
 258              v.setScale(wallpaperSize.x / crop.width());
 259              v.setTouchEnabled(false);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +            a.setSystemWallpaperVisiblity(false);</span>
 261          }
 262          @Override
 263          public void onSave(WallpaperPickerActivity a) {
 264              boolean finishActivityWhenDone = true;
 265              a.cropImageAndSetWallpaper(mResources, mResId, finishActivityWhenDone);
 266          }
 267          @Override
 268          public boolean isSelectable() {
 269              return true;
 270          }
 271          @Override
 272          public boolean isNamelessWallpaper() {
 273              return true;
 274          }
 275      }
 276  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +    @TargetApi(Build.VERSION_CODES.KITKAT)</span>
 278      public static class DefaultWallpaperInfo extends WallpaperTileInfo {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -        public Drawable mThumb;</span>
 280          public DefaultWallpaperInfo(Drawable thumb) {
 281              mThumb = thumb;
 282          }
 283          @Override
 284          public void onClick(WallpaperPickerActivity a) {
 285              CropView c = a.getCropView();
 286  
 287              Drawable defaultWallpaper = WallpaperManager.getInstance(a).getBuiltInDrawable(
 288                      c.getWidth(), c.getHeight(), false, 0.5f, 0.5f);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +            if (defaultWallpaper == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +                Log.w(TAG, &quot;Null default wallpaper encountered.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +                c.setTileSource(null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +                return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +            }</span>
 295  
 296              c.setTileSource(
 297                      new DrawableTileSource(a, defaultWallpaper, DrawableTileSource.MAX_PREVIEW_SIZE), null);
 298              c.setScale(1f);
 299              c.setTouchEnabled(false);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +            a.setSystemWallpaperVisiblity(false);</span>
 301          }
 302          @Override
 303          public void onSave(WallpaperPickerActivity a) {
 304              try {
 305                  WallpaperManager.getInstance(a).clear();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +                a.setResult(RESULT_OK);</span>
 307              } catch (IOException e) {
 308                  Log.w(&quot;Setting wallpaper to default threw exception&quot;, e);
 309              }
 310              a.finish();
 311          }
 312          @Override
 313          public boolean isSelectable() {
 314              return true;
 315          }
 316          @Override
 317          public boolean isNamelessWallpaper() {
 318              return true;
 319          }
 320      }
 321  
 322      public void setWallpaperStripYOffset(float offset) {
 323          mWallpaperStrip.setPadding(0, 0, 0, (int) offset);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +     * shows the system wallpaper behind the window and hides the {@link</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +     * #mCropView} if visible</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +     * @param visible should the system wallpaper be shown</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +    protected void setSystemWallpaperVisiblity(final boolean visible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 332 +        // hide our own wallpaper preview if necessary</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +        if(!visible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 334 +            mCropView.setVisibility(View.VISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +            changeWallpaperFlags(visible);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +        // the change of the flag must be delayed in order to avoid flickering,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +        // a simple post / double post does not suffice here</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +        mCropView.postDelayed(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +                if(!visible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +                    changeWallpaperFlags(visible);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +                    mCropView.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +        }, FLAG_POST_DELAY_MILLIS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +    private void changeWallpaperFlags(boolean visible) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +        int desiredWallpaperFlag = visible ? WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER : 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +        int currentWallpaperFlag = getWindow().getAttributes().flags</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +                &amp; WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +        if (desiredWallpaperFlag != currentWallpaperFlag) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +            getWindow().setFlags(desiredWallpaperFlag,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +                    WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +    public void setCropViewTileSource(BitmapSource bitmapSource,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +                                      boolean touchEnabled,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +                                      boolean moveToLeft,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +                                      final Runnable postExecute) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +        // we also want to show our own wallpaper instead of the one in the background</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +        Runnable showPostExecuteRunnable = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +                if(postExecute != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +                    postExecute.run();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +                setSystemWallpaperVisiblity(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +        super.setCropViewTileSource(bitmapSource,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +                touchEnabled,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +                moveToLeft,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +                showPostExecuteRunnable);</span>
 381      }
 382  
 383      // called by onCreate; this is subclassed to overwrite WallpaperCropActivity
 384      protected void init() {
 385          setContentView(R.layout.wallpaper_picker);
 386  
 387          mCropView = (CropView) findViewById(R.id.cropView);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +        mCropView.setVisibility(View.INVISIBLE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +</span>
 390          mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 391          mCropView.setTouchCallback(new CropView.TouchCallback() {
 392              ViewPropertyAnimator mAnim;
 393              @Override
 394              public void onTouchDown() {
 395                  if (mAnim != null) {
 396                      mAnim.cancel();
 397                  }
 398                  if (mWallpaperStrip.getAlpha() == 1f) {
 399                      mIgnoreNextTap = true;
 400                  }
 401                  mAnim = mWallpaperStrip.animate();
 402                  mAnim.alpha(0f)
 403                      .setDuration(150)
 404                      .withEndAction(new Runnable() {
 405                          public void run() {
 406                              mWallpaperStrip.setVisibility(View.INVISIBLE);
 407                          }
 408                      });
 409                  mAnim.setInterpolator(new AccelerateInterpolator(0.75f));
 410                  mAnim.start();
 411              }
 412              @Override
 413              public void onTouchUp() {
 414                  mIgnoreNextTap = false;
 415              }
 416              @Override
 417              public void onTap() {
 418                  boolean ignoreTap = mIgnoreNextTap;
 419                  mIgnoreNextTap = false;
 420                  if (!ignoreTap) {
 421                      if (mAnim != null) {
 422                          mAnim.cancel();
 423                      }
 424                      mWallpaperStrip.setVisibility(View.VISIBLE);
 425                      mAnim = mWallpaperStrip.animate();
 426                      mAnim.alpha(1f)
 427                           .setDuration(150)
 428                           .setInterpolator(new DecelerateInterpolator(0.75f));
 429                      mAnim.start();
 430                  }
 431              }
 432          });
 433  
 434          mThumbnailOnClickListener = new OnClickListener() {
 435              public void onClick(View v) {
 436                  if (mActionMode != null) {
 437                      // When CAB is up, clicking toggles the item instead
 438                      if (v.isLongClickable()) {
 439                          mLongClickListener.onLongClick(v);
 440                      }
 441                      return;
 442                  }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +                mSetWallpaperButton.setEnabled(true);</span>
 444                  WallpaperTileInfo info = (WallpaperTileInfo) v.getTag();
 445                  if (info.isSelectable() &amp;&amp; v.getVisibility() == View.VISIBLE) {
 446                      selectTile(v);
 447                  }
 448                  info.onClick(WallpaperPickerActivity.this);
 449              }
 450          };
 451          mLongClickListener = new View.OnLongClickListener() {
 452              // Called when the user long-clicks on someView
 453              public boolean onLongClick(View view) {
 454                  CheckableFrameLayout c = (CheckableFrameLayout) view;
 455                  c.toggle();
 456  
 457                  if (mActionMode != null) {
 458                      mActionMode.invalidate();
 459                  } else {
 460                      // Start the CAB using the ActionMode.Callback defined below
 461                      mActionMode = startActionMode(mActionModeCallback);
 462                      int childCount = mWallpapersView.getChildCount();
 463                      for (int i = 0; i &lt; childCount; i++) {
 464                          mWallpapersView.getChildAt(i).setSelected(false);
 465                      }
 466                  }
 467                  return true;
 468              }
 469          };
 470  
 471          // Populate the built-in wallpapers
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -        ArrayList&lt;ResourceWallpaperInfo&gt; wallpapers = findBundledWallpapers();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +        ArrayList&lt;WallpaperTileInfo&gt; wallpapers = findBundledWallpapers();</span>
 474          mWallpapersView = (LinearLayout) findViewById(R.id.wallpaper_list);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -        BuiltInWallpapersAdapter ia = new BuiltInWallpapersAdapter(this, wallpapers);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 476 +        SimpleWallpapersAdapter ia = new SimpleWallpapersAdapter(this, wallpapers);</span>
 477          populateWallpapersFromAdapter(mWallpapersView, ia, false);
 478  
 479          // Populate the saved wallpapers
 480          mSavedImages = new SavedWallpaperImages(this);
 481          mSavedImages.loadThumbnailsAndImageIdList();
 482          populateWallpapersFromAdapter(mWallpapersView, mSavedImages, true);
 483  
 484          // Populate the live wallpapers
 485          final LinearLayout liveWallpapersView =
 486                  (LinearLayout) findViewById(R.id.live_wallpaper_list);
 487          final LiveWallpaperListAdapter a = new LiveWallpaperListAdapter(this);
 488          a.registerDataSetObserver(new DataSetObserver() {
 489              public void onChanged() {
 490                  liveWallpapersView.removeAllViews();
 491                  populateWallpapersFromAdapter(liveWallpapersView, a, false);
 492                  initializeScrollForRtl();
 493                  updateTileIndices();
 494              }
 495          });
 496  
 497          // Populate the third-party wallpaper pickers
 498          final LinearLayout thirdPartyWallpapersView =
 499                  (LinearLayout) findViewById(R.id.third_party_wallpaper_list);
 500          final ThirdPartyWallpaperPickerListAdapter ta =
 501                  new ThirdPartyWallpaperPickerListAdapter(this);
 502          populateWallpapersFromAdapter(thirdPartyWallpapersView, ta, false);
 503  
 504          // Add a tile for the Gallery
 505          LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 506          FrameLayout pickImageTile = (FrameLayout) getLayoutInflater().
 507                  inflate(R.layout.wallpaper_picker_image_picker_item, masterWallpaperList, false);
 508          setWallpaperItemPaddingToZero(pickImageTile);
 509          masterWallpaperList.addView(pickImageTile, 0);
 510  
 511          // Make its background the last photo taken on external storage
 512          Bitmap lastPhoto = getThumbnailOfLastPhoto();
 513          if (lastPhoto != null) {
 514              ImageView galleryThumbnailBg =
 515                      (ImageView) pickImageTile.findViewById(R.id.wallpaper_image);
 516              galleryThumbnailBg.setImageBitmap(getThumbnailOfLastPhoto());
 517              int colorOverlay = getResources().getColor(R.color.wallpaper_picker_translucent_gray);
 518              galleryThumbnailBg.setColorFilter(colorOverlay, PorterDuff.Mode.SRC_ATOP);
 519  
 520          }
 521  
 522          PickImageInfo pickImageInfo = new PickImageInfo();
 523          pickImageTile.setTag(pickImageInfo);
 524          pickImageInfo.setView(pickImageTile);
 525          pickImageTile.setOnClickListener(mThumbnailOnClickListener);
 526  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -        // Add a tile for the default wallpaper</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 529 -            DefaultWallpaperInfo defaultWallpaperInfo = getDefaultWallpaper();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -            FrameLayout defaultWallpaperTile = (FrameLayout) createImageTileView(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -                    getLayoutInflater(), 0, null, mWallpapersView, defaultWallpaperInfo.mThumb);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -            setWallpaperItemPaddingToZero(defaultWallpaperTile);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 533 -            defaultWallpaperTile.setTag(defaultWallpaperInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 534 -            mWallpapersView.addView(defaultWallpaperTile, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 535 -            defaultWallpaperTile.setOnClickListener(mThumbnailOnClickListener);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -            defaultWallpaperInfo.setView(defaultWallpaperTile);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -</span>
 539          // Select the first item; wait for a layout pass so that we initialize the dimensions of
 540          // cropView or the defaultWallpaperView first
 541          mCropView.addOnLayoutChangeListener(new OnLayoutChangeListener() {
 542              @Override
 543              public void onLayoutChange(View v, int left, int top, int right, int bottom,
 544                      int oldLeft, int oldTop, int oldRight, int oldBottom) {
 545                  if ((right - left) &gt; 0 &amp;&amp; (bottom - top) &gt; 0) {
 546                      if (mSelectedIndex &gt;= 0 &amp;&amp; mSelectedIndex &lt; mWallpapersView.getChildCount()) {
 547                          mThumbnailOnClickListener.onClick(
 548                                  mWallpapersView.getChildAt(mSelectedIndex));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                        setSystemWallpaperVisiblity(false);</span>
 550                      }
 551                      v.removeOnLayoutChangeListener(this);
 552                  }
 553              }
 554          });
 555  
 556          updateTileIndices();
 557  
 558          // Update the scroll for RTL
 559          initializeScrollForRtl();
 560  
 561          // Create smooth layout transitions for when items are deleted
 562          final LayoutTransition transitioner = new LayoutTransition();
 563          transitioner.setDuration(200);
 564          transitioner.setStartDelay(LayoutTransition.CHANGE_DISAPPEARING, 0);
 565          transitioner.setAnimator(LayoutTransition.DISAPPEARING, null);
 566          mWallpapersView.setLayoutTransition(transitioner);
 567  
 568          // Action bar
 569          // Show the custom action bar view
 570          final ActionBar actionBar = getActionBar();
 571          actionBar.setCustomView(R.layout.actionbar_set_wallpaper);
 572          actionBar.getCustomView().setOnClickListener(
 573                  new View.OnClickListener() {
 574                      @Override
 575                      public void onClick(View v) {
 576                          if (mSelectedTile != null) {
 577                              WallpaperTileInfo info = (WallpaperTileInfo) mSelectedTile.getTag();
 578                              info.onSave(WallpaperPickerActivity.this);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +                        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +                            // no tile was selected, so we just finish the activity and go back</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +                            setResult(Activity.RESULT_OK);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +                            finish();</span>
 583                          }
 584                      }
 585                  });
 586          mSetWallpaperButton = findViewById(R.id.set_wallpaper_button);
 587  
 588          // CAB for deleting items
 589          mActionModeCallback = new ActionMode.Callback() {
 590              // Called when the action mode is created; startActionMode() was called
 591              @Override
 592              public boolean onCreateActionMode(ActionMode mode, Menu menu) {
 593                  // Inflate a menu resource providing context menu items
 594                  MenuInflater inflater = mode.getMenuInflater();
 595                  inflater.inflate(R.menu.cab_delete_wallpapers, menu);
 596                  return true;
 597              }
 598  
 599              private int numCheckedItems() {
 600                  int childCount = mWallpapersView.getChildCount();
 601                  int numCheckedItems = 0;
 602                  for (int i = 0; i &lt; childCount; i++) {
 603                      CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 604                      if (c.isChecked()) {
 605                          numCheckedItems++;
 606                      }
 607                  }
 608                  return numCheckedItems;
 609              }
 610  
 611              // Called each time the action mode is shown. Always called after onCreateActionMode,
 612              // but may be called multiple times if the mode is invalidated.
 613              @Override
 614              public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
 615                  int numCheckedItems = numCheckedItems();
 616                  if (numCheckedItems == 0) {
 617                      mode.finish();
 618                      return true;
 619                  } else {
 620                      mode.setTitle(getResources().getQuantityString(
 621                              R.plurals.number_of_items_selected, numCheckedItems, numCheckedItems));
 622                      return true;
 623                  }
 624              }
 625  
 626              // Called when the user selects a contextual menu item
 627              @Override
 628              public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 629                  int itemId = item.getItemId();
 630                  if (itemId == R.id.menu_delete) {
 631                      int childCount = mWallpapersView.getChildCount();
 632                      ArrayList&lt;View&gt; viewsToRemove = new ArrayList&lt;View&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 633 +                    boolean selectedTileRemoved = false;</span>
 634                      for (int i = 0; i &lt; childCount; i++) {
 635                          CheckableFrameLayout c =
 636                                  (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 637                          if (c.isChecked()) {
 638                              WallpaperTileInfo info = (WallpaperTileInfo) c.getTag();
 639                              info.onDelete(WallpaperPickerActivity.this);
 640                              viewsToRemove.add(c);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +                            if (i == mSelectedIndex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +                                selectedTileRemoved = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 643 +                            }</span>
 644                          }
 645                      }
 646                      for (View v : viewsToRemove) {
 647                          mWallpapersView.removeView(v);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                    if (selectedTileRemoved) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                        mSelectedIndex = -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                        mSelectedTile = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                        setSystemWallpaperVisiblity(true);</span>
 653                      }
 654                      updateTileIndices();
 655                      mode.finish(); // Action picked, so close the CAB
 656                      return true;
 657                  } else {
 658                      return false;
 659                  }
 660              }
 661  
 662              // Called when the user exits the action mode
 663              @Override
 664              public void onDestroyActionMode(ActionMode mode) {
 665                  int childCount = mWallpapersView.getChildCount();
 666                  for (int i = 0; i &lt; childCount; i++) {
 667                      CheckableFrameLayout c = (CheckableFrameLayout) mWallpapersView.getChildAt(i);
 668                      c.setChecked(false);
 669                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -                mSelectedTile.setSelected(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                if (mSelectedTile != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                    mSelectedTile.setSelected(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +                }</span>
 674                  mActionMode = null;
 675              }
 676          };
 677      }
 678  
 679      private void selectTile(View v) {
 680          if (mSelectedTile != null) {
 681              mSelectedTile.setSelected(false);
 682              mSelectedTile = null;
 683          }
 684          mSelectedTile = v;
 685          v.setSelected(true);
 686          mSelectedIndex = mWallpapersView.indexOfChild(v);
 687          // TODO: Remove this once the accessibility framework and
 688          // services have better support for selection state.
 689          v.announceForAccessibility(
 690                  getString(R.string.announce_selection, v.getContentDescription()));
 691      }
 692  
 693      private void initializeScrollForRtl() {
 694          final HorizontalScrollView scroll =
 695                  (HorizontalScrollView) findViewById(R.id.wallpaper_scroll_container);
 696  
 697          if (scroll.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
 698              final ViewTreeObserver observer = scroll.getViewTreeObserver();
 699              observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
 700                  public void onGlobalLayout() {
 701                      LinearLayout masterWallpaperList =
 702                              (LinearLayout) findViewById(R.id.master_wallpaper_list);
 703                      scroll.scrollTo(masterWallpaperList.getWidth(), 0);
 704                      scroll.getViewTreeObserver().removeOnGlobalLayoutListener(this);
 705                  }
 706              });
 707          }
 708      }
 709  
 710      protected Bitmap getThumbnailOfLastPhoto() {
 711          Cursor cursor = MediaStore.Images.Media.query(getContentResolver(),
 712                  MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
 713                  new String[] { MediaStore.Images.ImageColumns._ID,
 714                      MediaStore.Images.ImageColumns.DATE_TAKEN},
 715                  null, null, MediaStore.Images.ImageColumns.DATE_TAKEN + &quot; DESC LIMIT 1&quot;);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 716 +</span>
 717          Bitmap thumb = null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 718 -        if (cursor.moveToNext()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 719 -            int id = cursor.getInt(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 720 -            thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 721 -                    id, MediaStore.Images.Thumbnails.MINI_KIND, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 722 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 723 -        cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 724 +        if (cursor != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 725 +            if (cursor.moveToNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 726 +                int id = cursor.getInt(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +                thumb = MediaStore.Images.Thumbnails.getThumbnail(getContentResolver(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 728 +                        id, MediaStore.Images.Thumbnails.MINI_KIND, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 729 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 730 +            cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 731 +        }</span>
 732          return thumb;
 733      }
 734  
 735      protected void onStop() {
 736          super.onStop();
 737          mWallpaperStrip = findViewById(R.id.wallpaper_strip);
 738          if (mWallpaperStrip.getAlpha() &lt; 1f) {
 739              mWallpaperStrip.setAlpha(1f);
 740              mWallpaperStrip.setVisibility(View.VISIBLE);
 741          }
 742      }
 743  
 744      protected void onSaveInstanceState(Bundle outState) {
 745          outState.putParcelableArrayList(TEMP_WALLPAPER_TILES, mTempWallpaperTiles);
 746          outState.putInt(SELECTED_INDEX, mSelectedIndex);
 747      }
 748  
 749      protected void onRestoreInstanceState(Bundle savedInstanceState) {
 750          ArrayList&lt;Uri&gt; uris = savedInstanceState.getParcelableArrayList(TEMP_WALLPAPER_TILES);
 751          for (Uri uri : uris) {
 752              addTemporaryWallpaperTile(uri, true);
 753          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 754 -        mSelectedIndex = savedInstanceState.getInt(SELECTED_INDEX, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +        mSelectedIndex = savedInstanceState.getInt(SELECTED_INDEX, -1);</span>
 756      }
 757  
 758      private void populateWallpapersFromAdapter(ViewGroup parent, BaseAdapter adapter,
 759              boolean addLongPressHandler) {
 760          for (int i = 0; i &lt; adapter.getCount(); i++) {
 761              FrameLayout thumbnail = (FrameLayout) adapter.getView(i, null, parent);
 762              parent.addView(thumbnail, i);
 763              WallpaperTileInfo info = (WallpaperTileInfo) adapter.getItem(i);
 764              thumbnail.setTag(info);
 765              info.setView(thumbnail);
 766              if (addLongPressHandler) {
 767                  addLongPressHandler(thumbnail);
 768              }
 769              thumbnail.setOnClickListener(mThumbnailOnClickListener);
 770          }
 771      }
 772  
 773      private void updateTileIndices() {
 774          LinearLayout masterWallpaperList = (LinearLayout) findViewById(R.id.master_wallpaper_list);
 775          final int childCount = masterWallpaperList.getChildCount();
 776          final Resources res = getResources();
 777  
 778          // Do two passes; the first pass gets the total number of tiles
 779          int numTiles = 0;
 780          for (int passNum = 0; passNum &lt; 2; passNum++) {
 781              int tileIndex = 0;
 782              for (int i = 0; i &lt; childCount; i++) {
 783                  View child = masterWallpaperList.getChildAt(i);
 784                  LinearLayout subList;
 785  
 786                  int subListStart;
 787                  int subListEnd;
 788                  if (child.getTag() instanceof WallpaperTileInfo) {
 789                      subList = masterWallpaperList;
 790                      subListStart = i;
 791                      subListEnd = i + 1;
 792                  } else { // if (child instanceof LinearLayout) {
 793                      subList = (LinearLayout) child;
 794                      subListStart = 0;
 795                      subListEnd = subList.getChildCount();
 796                  }
 797  
 798                  for (int j = subListStart; j &lt; subListEnd; j++) {
 799                      WallpaperTileInfo info = (WallpaperTileInfo) subList.getChildAt(j).getTag();
 800                      if (info.isNamelessWallpaper()) {
 801                          if (passNum == 0) {
 802                              numTiles++;
 803                          } else {
 804                              CharSequence label = res.getString(
 805                                      R.string.wallpaper_accessibility_name, ++tileIndex, numTiles);
 806                              info.onIndexUpdated(label);
 807                          }
 808                      }
 809                  }
 810              }
 811          }
 812      }
 813  
 814      private static Point getDefaultThumbnailSize(Resources res) {
 815          return new Point(res.getDimensionPixelSize(R.dimen.wallpaperThumbnailWidth),
 816                  res.getDimensionPixelSize(R.dimen.wallpaperThumbnailHeight));
 817  
 818      }
 819  
 820      private static Bitmap createThumbnail(Point size, Context context, Uri uri, byte[] imageBytes,
 821              Resources res, int resId, int rotation, boolean leftAligned) {
 822          int width = size.x;
 823          int height = size.y;
 824  
 825          BitmapCropTask cropTask;
 826          if (uri != null) {
 827              cropTask = new BitmapCropTask(
 828                      context, uri, null, rotation, width, height, false, true, null);
 829          } else if (imageBytes != null) {
 830              cropTask = new BitmapCropTask(
 831                      imageBytes, null, rotation, width, height, false, true, null);
 832          }  else {
 833              cropTask = new BitmapCropTask(
 834                      context, res, resId, null, rotation, width, height, false, true, null);
 835          }
 836          Point bounds = cropTask.getImageBounds();
 837          if (bounds == null || bounds.x == 0 || bounds.y == 0) {
 838              return null;
 839          }
 840  
 841          Matrix rotateMatrix = new Matrix();
 842          rotateMatrix.setRotate(rotation);
 843          float[] rotatedBounds = new float[] { bounds.x, bounds.y };
 844          rotateMatrix.mapPoints(rotatedBounds);
 845          rotatedBounds[0] = Math.abs(rotatedBounds[0]);
 846          rotatedBounds[1] = Math.abs(rotatedBounds[1]);
 847  
 848          RectF cropRect = WallpaperCropActivity.getMaxCropRect(
 849                  (int) rotatedBounds[0], (int) rotatedBounds[1], width, height, leftAligned);
 850          cropTask.setCropBounds(cropRect);
 851  
 852          if (cropTask.cropBitmap()) {
 853              return cropTask.getCroppedBitmap();
 854          } else {
 855              return null;
 856          }
 857      }
 858  
 859      private void addTemporaryWallpaperTile(final Uri uri, boolean fromRestore) {
 860          mTempWallpaperTiles.add(uri);
 861          // Add a tile for the image picked from Gallery
 862          final FrameLayout pickedImageThumbnail = (FrameLayout) getLayoutInflater().
 863                  inflate(R.layout.wallpaper_picker_item, mWallpapersView, false);
 864          pickedImageThumbnail.setVisibility(View.GONE);
 865          setWallpaperItemPaddingToZero(pickedImageThumbnail);
 866          mWallpapersView.addView(pickedImageThumbnail, 0);
 867  
 868          // Load the thumbnail
 869          final ImageView image = (ImageView) pickedImageThumbnail.findViewById(R.id.wallpaper_image);
 870          final Point defaultSize = getDefaultThumbnailSize(this.getResources());
 871          final Context context = this;
 872          new AsyncTask&lt;Void, Bitmap, Bitmap&gt;() {
 873              protected Bitmap doInBackground(Void...args) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 874 -                int rotation = WallpaperCropActivity.getRotationFromExif(context, uri);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 875 -                return createThumbnail(defaultSize, context, uri, null, null, 0, rotation, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 876 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 877 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 878 +                    int rotation = WallpaperCropActivity.getRotationFromExif(context, uri);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 879 +                    return createThumbnail(defaultSize, context, uri, null, null, 0, rotation, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 880 +                } catch (SecurityException securityException) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +                    if (isDestroyed()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +                        // Temporarily granted permissions are revoked when the activity</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 883 +                        // finishes, potentially resulting in a SecurityException here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 884 +                        // Even though {@link #isDestroyed} might also return true in different</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 885 +                        // situations where the configuration changes, we are fine with</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 886 +                        // catching these cases here as well.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 887 +                        cancel(false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 888 +                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 889 +                        // otherwise it had a different cause and we throw it further</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 890 +                        throw securityException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +                    return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +                }</span>
 894              }
 895              protected void onPostExecute(Bitmap thumb) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 896 -                if (thumb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +                if (!isCancelled() &amp;&amp; thumb != null) {</span>
 898                      image.setImageBitmap(thumb);
 899                      Drawable thumbDrawable = image.getDrawable();
 900                      thumbDrawable.setDither(true);
 901                      pickedImageThumbnail.setVisibility(View.VISIBLE);
 902                  } else {
 903                      Log.e(TAG, &quot;Error loading thumbnail for uri=&quot; + uri);
 904                  }
 905              }
 906          }.execute();
 907  
 908          UriWallpaperInfo info = new UriWallpaperInfo(uri);
 909          pickedImageThumbnail.setTag(info);
 910          info.setView(pickedImageThumbnail);
 911          addLongPressHandler(pickedImageThumbnail);
 912          updateTileIndices();
 913          pickedImageThumbnail.setOnClickListener(mThumbnailOnClickListener);
 914          if (!fromRestore) {
 915              mThumbnailOnClickListener.onClick(pickedImageThumbnail);
 916          }
 917      }
 918  
 919      protected void onActivityResult(int requestCode, int resultCode, Intent data) {
 920          if (requestCode == IMAGE_PICK &amp;&amp; resultCode == RESULT_OK) {
 921              if (data != null &amp;&amp; data.getData() != null) {
 922                  Uri uri = data.getData();
 923                  addTemporaryWallpaperTile(uri, false);
 924              }
 925          } else if (requestCode == PICK_WALLPAPER_THIRD_PARTY_ACTIVITY) {
 926              setResult(RESULT_OK);
 927              finish();
 928          } else if (requestCode == PICK_LIVE_WALLPAPER) {
 929              WallpaperManager wm = WallpaperManager.getInstance(this);
 930              final WallpaperInfo oldLiveWallpaper = mLiveWallpaperInfoOnPickerLaunch;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 931 +            final WallpaperInfo clickedWallpaper = mLastClickedLiveWallpaperInfo;</span>
 932              WallpaperInfo newLiveWallpaper = wm.getWallpaperInfo();
 933              // Try to figure out if a live wallpaper was set;
 934              if (newLiveWallpaper != null &amp;&amp;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 935 -                    (oldLiveWallpaper == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 936 -                    !oldLiveWallpaper.getComponent().equals(newLiveWallpaper.getComponent()))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 937 +                    (oldLiveWallpaper == null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 938 +                            || !oldLiveWallpaper.getComponent()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +                                    .equals(newLiveWallpaper.getComponent())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +                            || clickedWallpaper.getComponent()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +                                    .equals(oldLiveWallpaper.getComponent()))) {</span>
 942                  // Return if a live wallpaper was set
 943                  setResult(RESULT_OK);
 944                  finish();
 945              }
 946          }
 947      }
 948  
 949      static void setWallpaperItemPaddingToZero(FrameLayout frameLayout) {
 950          frameLayout.setPadding(0, 0, 0, 0);
 951          frameLayout.setForeground(new ZeroPaddingDrawable(frameLayout.getForeground()));
 952      }
 953  
 954      private void addLongPressHandler(View v) {
 955          v.setOnLongClickListener(mLongClickListener);
 956      }
 957  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 958 -    private ArrayList&lt;ResourceWallpaperInfo&gt; findBundledWallpapers() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 959 -        ArrayList&lt;ResourceWallpaperInfo&gt; bundledWallpapers =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 960 -                new ArrayList&lt;ResourceWallpaperInfo&gt;(24);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +    private ArrayList&lt;WallpaperTileInfo&gt; findBundledWallpapers() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +        final PackageManager pm = getPackageManager();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +        final ArrayList&lt;WallpaperTileInfo&gt; bundled = new ArrayList&lt;WallpaperTileInfo&gt;(24);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +        Partner partner = Partner.get(pm);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 966 +        if (partner != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 967 +            final Resources partnerRes = partner.getResources();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 968 +            final int resId = partnerRes.getIdentifier(Partner.RES_WALLPAPERS, &quot;array&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 969 +                    partner.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +            if (resId != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 971 +                addWallpapers(bundled, partnerRes, partner.getPackageName(), resId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 972 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 973 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 974 +            // Add system wallpapers</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +            File systemDir = partner.getWallpaperDirectory();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +            if (systemDir != null &amp;&amp; systemDir.isDirectory()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 977 +                for (File file : systemDir.listFiles()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 978 +                    if (!file.isFile()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 979 +                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +                    String name = file.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +                    int dotPos = name.lastIndexOf(&#x27;.&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +                    String extension = &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +                    if (dotPos &gt;= -1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +                        extension = name.substring(dotPos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 986 +                        name = name.substring(0, dotPos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 987 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 988 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +                    if (name.endsWith(&quot;_small&quot;)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +                        // it is a thumbnail</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 991 +                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 992 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +                    File thumbnail = new File(systemDir, name + &quot;_small&quot; + extension);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 995 +                    Bitmap thumb = BitmapFactory.decodeFile(thumbnail.getAbsolutePath());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 996 +                    if (thumb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +                        bundled.add(new FileWallpaperInfo(file, new BitmapDrawable(thumb)));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 998 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 999 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1000 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1001 +        }</span>
1002  
1003          Pair&lt;ApplicationInfo, Integer&gt; r = getWallpaperArrayResourceId();
1004          if (r != null) {
1005              try {
1006                  Resources wallpaperRes = getPackageManager().getResourcesForApplication(r.first);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1007 -                bundledWallpapers = addWallpapers(wallpaperRes, r.first.packageName, r.second);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1008 +                addWallpapers(bundled, wallpaperRes, r.first.packageName, r.second);</span>
1009              } catch (PackageManager.NameNotFoundException e) {
1010              }
1011          }
1012  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1013 -        // Add an entry for the default wallpaper (stored in system resources)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1014 -        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1015 -            ResourceWallpaperInfo defaultWallpaperInfo = getPreKKDefaultWallpaperInfo();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1016 +        if (partner == null || !partner.hideDefaultWallpaper()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1017 +            // Add an entry for the default wallpaper (stored in system resources)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1018 +            WallpaperTileInfo defaultWallpaperInfo =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1019 +                    (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1020 +                    ? getPreKKDefaultWallpaperInfo()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1021 +                    : getDefaultWallpaper();</span>
1022              if (defaultWallpaperInfo != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1023 -                bundledWallpapers.add(0, defaultWallpaperInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1024 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1025 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1026 -        return bundledWallpapers;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1027 +                bundled.add(0, defaultWallpaperInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1028 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1029 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1030 +        return bundled;</span>
1031      }
1032  
1033      private boolean writeImageToFileAsJpeg(File f, Bitmap b) {
1034          try {
1035              f.createNewFile();
1036              FileOutputStream thumbFileStream =
1037                      openFileOutput(f.getName(), Context.MODE_PRIVATE);
1038              b.compress(Bitmap.CompressFormat.JPEG, 95, thumbFileStream);
1039              thumbFileStream.close();
1040              return true;
1041          } catch (IOException e) {
1042              Log.e(TAG, &quot;Error while writing bitmap to file &quot; + e);
1043              f.delete();
1044          }
1045          return false;
1046      }
1047  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1048 +    private File getDefaultThumbFile() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1049 +        return new File(getFilesDir(), Build.VERSION.SDK_INT</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1050 +                + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1051 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1052 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1053 +    private boolean saveDefaultWallpaperThumb(Bitmap b) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1054 +        // Delete old thumbnails.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1055 +        new File(getFilesDir(), OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1056 +        new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1057 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1058 +        for (int i = Build.VERSION_CODES.JELLY_BEAN; i &lt; Build.VERSION.SDK_INT; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1059 +            new File(getFilesDir(), i + &quot;_&quot; + DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1060 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1061 +        return writeImageToFileAsJpeg(getDefaultThumbFile(), b);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1062 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1063 +</span>
1064      private ResourceWallpaperInfo getPreKKDefaultWallpaperInfo() {
1065          Resources sysRes = Resources.getSystem();
1066          int resId = sysRes.getIdentifier(&quot;default_wallpaper&quot;, &quot;drawable&quot;, &quot;android&quot;);
1067  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1068 -        File defaultThumbFile = new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1069 +        File defaultThumbFile = getDefaultThumbFile();</span>
1070          Bitmap thumb = null;
1071          boolean defaultWallpaperExists = false;
1072          if (defaultThumbFile.exists()) {
1073              thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1074              defaultWallpaperExists = true;
1075          } else {
1076              Resources res = getResources();
1077              Point defaultThumbSize = getDefaultThumbnailSize(res);
1078              int rotation = WallpaperCropActivity.getRotationFromExif(res, resId);
1079              thumb = createThumbnail(
1080                      defaultThumbSize, this, null, null, sysRes, resId, rotation, false);
1081              if (thumb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1082 -                defaultWallpaperExists = writeImageToFileAsJpeg(defaultThumbFile, thumb);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1083 +                defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);</span>
1084              }
1085          }
1086          if (defaultWallpaperExists) {
1087              return new ResourceWallpaperInfo(sysRes, resId, new BitmapDrawable(thumb));
1088          }
1089          return null;
1090      }
1091  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1092 +    @TargetApi(Build.VERSION_CODES.KITKAT)</span>
1093      private DefaultWallpaperInfo getDefaultWallpaper() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1094 -        File defaultThumbFile = new File(getFilesDir(), DEFAULT_WALLPAPER_THUMBNAIL_FILENAME);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1095 +        File defaultThumbFile = getDefaultThumbFile();</span>
1096          Bitmap thumb = null;
1097          boolean defaultWallpaperExists = false;
1098          if (defaultThumbFile.exists()) {
1099              thumb = BitmapFactory.decodeFile(defaultThumbFile.getAbsolutePath());
1100              defaultWallpaperExists = true;
1101          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1102 -            // Delete old thumbnail file, since we had a bug where the thumbnail wasn&#x27;t being drawn</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1103 -            // before</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1104 -            new File(getFilesDir(), OLD_DEFAULT_WALLPAPER_THUMBNAIL_FILENAME).delete();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1105 -</span>
1106              Resources res = getResources();
1107              Point defaultThumbSize = getDefaultThumbnailSize(res);
1108              Drawable wallpaperDrawable = WallpaperManager.getInstance(this).getBuiltInDrawable(
1109                      defaultThumbSize.x, defaultThumbSize.y, true, 0.5f, 0.5f);
1110              if (wallpaperDrawable != null) {
1111                  thumb = Bitmap.createBitmap(
1112                          defaultThumbSize.x, defaultThumbSize.y, Bitmap.Config.ARGB_8888);
1113                  Canvas c = new Canvas(thumb);
1114                  wallpaperDrawable.setBounds(0, 0, defaultThumbSize.x, defaultThumbSize.y);
1115                  wallpaperDrawable.draw(c);
1116                  c.setBitmap(null);
1117              }
1118              if (thumb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1119 -                defaultWallpaperExists = writeImageToFileAsJpeg(defaultThumbFile, thumb);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1120 +                defaultWallpaperExists = saveDefaultWallpaperThumb(thumb);</span>
1121              }
1122          }
1123          if (defaultWallpaperExists) {
1124              return new DefaultWallpaperInfo(new BitmapDrawable(thumb));
1125          }
1126          return null;
1127      }
1128  
1129      public Pair&lt;ApplicationInfo, Integer&gt; getWallpaperArrayResourceId() {
1130          // Context.getPackageName() may return the &quot;original&quot; package name,
1131          // com.android.launcher3; Resources needs the real package name,
1132          // com.android.launcher3. So we ask Resources for what it thinks the
1133          // package name should be.
1134          final String packageName = getResources().getResourcePackageName(R.array.wallpapers);
1135          try {
1136              ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, 0);
1137              return new Pair&lt;ApplicationInfo, Integer&gt;(info, R.array.wallpapers);
1138          } catch (PackageManager.NameNotFoundException e) {
1139              return null;
1140          }
1141      }
1142  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1143 -    private ArrayList&lt;ResourceWallpaperInfo&gt; addWallpapers(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1144 -            Resources res, String packageName, int listResId) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1145 -        ArrayList&lt;ResourceWallpaperInfo&gt; bundledWallpapers =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1146 -                new ArrayList&lt;ResourceWallpaperInfo&gt;(24);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1147 +    private void addWallpapers(ArrayList&lt;WallpaperTileInfo&gt; known, Resources res,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1148 +            String packageName, int listResId) {</span>
1149          final String[] extras = res.getStringArray(listResId);
1150          for (String extra : extras) {
1151              int resId = res.getIdentifier(extra, &quot;drawable&quot;, packageName);
1152              if (resId != 0) {
1153                  final int thumbRes = res.getIdentifier(extra + &quot;_small&quot;, &quot;drawable&quot;, packageName);
1154  
1155                  if (thumbRes != 0) {
1156                      ResourceWallpaperInfo wallpaperInfo =
1157                              new ResourceWallpaperInfo(res, resId, res.getDrawable(thumbRes));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1158 -                    bundledWallpapers.add(wallpaperInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1159 +                    known.add(wallpaperInfo);</span>
1160                      // Log.d(TAG, &quot;add: [&quot; + packageName + &quot;]: &quot; + extra + &quot; (&quot; + res + &quot;)&quot;);
1161                  }
1162              } else {
1163                  Log.e(TAG, &quot;Couldn&#x27;t find wallpaper &quot; + extra);
1164              }
1165          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1166 -        return bundledWallpapers;</span>
1167      }
1168  
1169      public CropView getCropView() {
1170          return mCropView;
1171      }
1172  
1173      public SavedWallpaperImages getSavedImages() {
1174          return mSavedImages;
1175      }
1176  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1177 -    public void onLiveWallpaperPickerLaunch() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1178 +    public void onLiveWallpaperPickerLaunch(WallpaperInfo info) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1179 +        mLastClickedLiveWallpaperInfo = info;</span>
1180          mLiveWallpaperInfoOnPickerLaunch = WallpaperManager.getInstance(this).getWallpaperInfo();
1181      }
1182  
1183      static class ZeroPaddingDrawable extends LevelListDrawable {
1184          public ZeroPaddingDrawable(Drawable d) {
1185              super();
1186              addLevel(0, 0, d);
1187              setLevel(0);
1188          }
1189  
1190          @Override
1191          public boolean getPadding(Rect padding) {
1192              padding.set(0, 0, 0, 0);
1193              return true;
1194          }
1195      }
1196  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1197 -    private static class BuiltInWallpapersAdapter extends BaseAdapter implements ListAdapter {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1198 -        private LayoutInflater mLayoutInflater;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1199 -        private ArrayList&lt;ResourceWallpaperInfo&gt; mWallpapers;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1200 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1201 -        BuiltInWallpapersAdapter(Activity activity, ArrayList&lt;ResourceWallpaperInfo&gt; wallpapers) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1202 +    private static class SimpleWallpapersAdapter extends ArrayAdapter&lt;WallpaperTileInfo&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1203 +        private final LayoutInflater mLayoutInflater;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1204 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1205 +        SimpleWallpapersAdapter(Activity activity, ArrayList&lt;WallpaperTileInfo&gt; wallpapers) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1206 +            super(activity, R.layout.wallpaper_picker_item, wallpapers);</span>
1207              mLayoutInflater = activity.getLayoutInflater();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1208 -            mWallpapers = wallpapers;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1209 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1210 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1211 -        public int getCount() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1212 -            return mWallpapers.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1213 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1214 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1215 -        public ResourceWallpaperInfo getItem(int position) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1216 -            return mWallpapers.get(position);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1217 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1218 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1219 -        public long getItemId(int position) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1220 -            return position;</span>
1221          }
1222  
1223          public View getView(int position, View convertView, ViewGroup parent) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1224 -            Drawable thumb = mWallpapers.get(position).mThumb;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1225 +            Drawable thumb = getItem(position).mThumb;</span>
1226              if (thumb == null) {
1227                  Log.e(TAG, &quot;Error decoding thumbnail for wallpaper #&quot; + position);
1228              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1229 -            return createImageTileView(mLayoutInflater, position, convertView, parent, thumb);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1230 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1231 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1232 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1233 -    public static View createImageTileView(LayoutInflater layoutInflater, int position,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1234 +            return createImageTileView(mLayoutInflater, convertView, parent, thumb);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1235 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1236 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1237 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1238 +    public static View createImageTileView(LayoutInflater layoutInflater,</span>
1239              View convertView, ViewGroup parent, Drawable thumb) {
1240          View view;
1241  
1242          if (convertView == null) {
1243              view = layoutInflater.inflate(R.layout.wallpaper_picker_item, parent, false);
1244          } else {
1245              view = convertView;
1246          }
1247  
1248          setWallpaperItemPaddingToZero((FrameLayout) view);
1249  
1250          ImageView image = (ImageView) view.findViewById(R.id.wallpaper_image);
1251  
1252          if (thumb != null) {
1253              image.setImageDrawable(thumb);
1254              thumb.setDither(true);
1255          }
1256  
1257          return view;
1258      }
1259  
1260      // In Launcher3, we override this with a method that catches exceptions
1261      // from starting activities; didn&#x27;t want to copy and paste code into here
1262      public void startActivityForResultSafely(Intent intent, int requestCode) {
1263          startActivityForResult(intent, requestCode);
1264      }
1265  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            