<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>132 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}], &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public final class EventLogger implements &#x27;
                         &#x27;Player.EventListener, MetadataOutput,\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public final class EventLogger implements &#x27;
                           &#x27;Player.Listener, MetadataOutput,\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onCues(List&lt;Cue&gt; cues) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPlaybackStateChanged(int state) {\n&#x27;
                         &#x27;        boolean playWhenReady = state == &#x27;
                         &#x27;Player.STATE_READY;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPlaybackStateChanged(@Player.State int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString()  + &quot;, &quot;\n&#x27;
                           &#x27;                + getStateString(state) + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPlayWhenReadyChanged(boolean &#x27;
                           &#x27;playWhenReady, int state) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static String &#x27;
                         &#x27;getDiscontinuityReasonString(@Player.DiscontinuityReason &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        switch (reason) {\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_AUTO_TRANSITION:\n&#x27;
                         &#x27;                return &quot;AUTO_TRANSITION&quot;;\n&#x27;
                         &#x27;            case Player.DISCONTINUITY_REASON_SEEK:\n&#x27;
                         &#x27;                return &quot;SEEK&quot;;\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:\n&#x27;
                         &#x27;                return &quot;SEEK_ADJUSTMENT&quot;;\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_INTERNAL:\n&#x27;
                         &#x27;                return &quot;INTERNAL&quot;;\n&#x27;
                         &#x27;            default:\n&#x27;
                         &#x27;                return &quot;?&quot;;\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onPositionDiscontinuity(Player.PositionInfo &#x27;
                           &#x27;oldPosition, Player.PositionInfo newPosition, &#x27;
                           &#x27;@Player.DiscontinuityReason int reason) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;positionDiscontinuity [&quot; + &#x27;
                           &#x27;getDiscontinuityReasonString(reason) + &quot;]&quot;);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPositionDiscontinuity(\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition,\n&#x27;
                         &#x27;            @Player.DiscontinuityReason int reason\n&#x27;
                         &#x27;    ) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;positionDiscontinuity [&quot; + &#x27;
                         &#x27;getDiscontinuityReasonString(reason) + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoSizeChanged(VideoSize &#x27;
                           &#x27;videoSize) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                           &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &#x27;
                           &#x27;&quot;]&quot;);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoSizeChanged(VideoSize &#x27;
                         &#x27;videoSize) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                         &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onRenderedFirstFrame(Object &#x27;
                           &#x27;output, long renderTimeMs) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;renderedFirstFrame [&quot; + output &#x27;
                           &#x27;+ &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onSkipSilenceEnabledChanged(boolean &#x27;
                           &#x27;skipSilenceEnabled) {\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    // Internal methods\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onRenderedFirstFrame(Object output, &#x27;
                         &#x27;long renderTimeMs) {\n&#x27;
                         &#x27;        if (output instanceof Surface) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;renderedFirstFrame [&quot; + &#x27;
                         &#x27;(Surface) output + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private static String &#x27;
                           &#x27;getDiscontinuityReasonString(@Player.DiscontinuityReason &#x27;
                           &#x27;int reason) {\n&#x27;
                           &#x27;        switch (reason) {\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_AUTO_TRANSITION:\n&#x27;
                           &#x27;                return &quot;PERIOD_TRANSITION&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SEEK:\n&#x27;
                           &#x27;                return &quot;SEEK&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:\n&#x27;
                           &#x27;                return &quot;SEEK_ADJUSTMENT&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_INTERNAL:\n&#x27;
                           &#x27;                return &quot;INTERNAL&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_REMOVE:\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SKIP:\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                return &quot;?&quot;;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPlaybackStateChanged(int state) {\n&#x27;
                         &#x27;        boolean playWhenReady = state == &#x27;
                         &#x27;Player.STATE_READY;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                         &#x27;getSessionTimeString() + &quot;, &quot; + playWhenReady + &quot;, &#x27;
                         &#x27;&quot;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPlaybackStateChanged(@Player.State int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString()  + &quot;, &quot;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void onPlayWhenReadyChanged(boolean &#x27;
                           &#x27;playWhenReady, int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString() + &quot;, &quot; + playWhenReady + &quot;, &#x27;
                           &#x27;&quot;\n&#x27;
                           &#x27;                + getStateString(state) + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPositionDiscontinuity(\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition,\n&#x27;
                         &#x27;            @Player.DiscontinuityReason int reason\n&#x27;
                         &#x27;    ) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPositionDiscontinuity(Player.PositionInfo &#x27;
                           &#x27;oldPosition, Player.PositionInfo newPosition, &#x27;
                           &#x27;@Player.DiscontinuityReason int reason) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void onRenderedFirstFrame(Object &#x27;
                           &#x27;output, long renderTimeMs) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;renderedFirstFrame [&quot; + output &#x27;
                           &#x27;+ &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                return &quot;AUTO_TRANSITION&quot;;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                return &quot;PERIOD_TRANSITION&quot;;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onSkipSilenceEnabledChanged(boolean &#x27;
                           &#x27;skipSilenceEnabled) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;@Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nDecoderReuseEvaluation decoderReuseEvaluation\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;@Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;DecoderReuseEvaluation decoderReuseEvaluation\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;Player.PositionInfo oldPosition, &#x27;
                           &#x27;Player.PositionInfo newPosition\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&quot;state [&quot; + getSessionTimeString() + &quot;, &quot; + &#x27;
                         &#x27;playWhenReady + &quot;, &quot;\n&#x27;
                         &#x27;                + getStateString(state) + &quot;]&quot;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;&quot;internalError [&quot; + getSessionTimeString() + &quot;, &quot; &#x27;
                           &#x27;+ type + &quot;]&quot;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                         &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + width + &#x27;
                           &#x27;&quot;, &quot; + height + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;, &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public final class EventLogger implements &#x27;
                         &#x27;Player.EventListener, MetadataOutput,\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public final class EventLogger implements &#x27;
                           &#x27;Player.Listener, MetadataOutput,\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onCues(List&lt;Cue&gt; cues) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPlaybackStateChanged(int state) {\n&#x27;
                         &#x27;        boolean playWhenReady = state == &#x27;
                         &#x27;Player.STATE_READY;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPlaybackStateChanged(@Player.State int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString()  + &quot;, &quot;\n&#x27;
                           &#x27;                + getStateString(state) + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void onPlayWhenReadyChanged(boolean &#x27;
                           &#x27;playWhenReady, int state) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    private static String &#x27;
                         &#x27;getDiscontinuityReasonString(@Player.DiscontinuityReason &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        switch (reason) {\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_AUTO_TRANSITION:\n&#x27;
                         &#x27;                return &quot;AUTO_TRANSITION&quot;;\n&#x27;
                         &#x27;            case Player.DISCONTINUITY_REASON_SEEK:\n&#x27;
                         &#x27;                return &quot;SEEK&quot;;\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:\n&#x27;
                         &#x27;                return &quot;SEEK_ADJUSTMENT&quot;;\n&#x27;
                         &#x27;            case &#x27;
                         &#x27;Player.DISCONTINUITY_REASON_INTERNAL:\n&#x27;
                         &#x27;                return &quot;INTERNAL&quot;;\n&#x27;
                         &#x27;            default:\n&#x27;
                         &#x27;                return &quot;?&quot;;\n&#x27;
                         &#x27;        }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onPositionDiscontinuity(Player.PositionInfo &#x27;
                           &#x27;oldPosition, Player.PositionInfo newPosition, &#x27;
                           &#x27;@Player.DiscontinuityReason int reason) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;positionDiscontinuity [&quot; + &#x27;
                           &#x27;getDiscontinuityReasonString(reason) + &quot;]&quot;);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPositionDiscontinuity(\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition,\n&#x27;
                         &#x27;            @Player.DiscontinuityReason int reason\n&#x27;
                         &#x27;    ) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;positionDiscontinuity [&quot; + &#x27;
                         &#x27;getDiscontinuityReasonString(reason) + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoSizeChanged(VideoSize &#x27;
                           &#x27;videoSize) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                           &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &#x27;
                           &#x27;&quot;]&quot;);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoSizeChanged(VideoSize &#x27;
                         &#x27;videoSize) {\n&#x27;
                         &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                         &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onRenderedFirstFrame(Object &#x27;
                           &#x27;output, long renderTimeMs) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;renderedFirstFrame [&quot; + output &#x27;
                           &#x27;+ &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onSkipSilenceEnabledChanged(boolean &#x27;
                           &#x27;skipSilenceEnabled) {\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    // Internal methods\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onRenderedFirstFrame(Object output, &#x27;
                         &#x27;long renderTimeMs) {\n&#x27;
                         &#x27;        if (output instanceof Surface) {\n&#x27;
                         &#x27;            Log.d(TAG, &quot;renderedFirstFrame [&quot; + &#x27;
                         &#x27;(Surface) output + &quot;]&quot;);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private static String &#x27;
                           &#x27;getDiscontinuityReasonString(@Player.DiscontinuityReason &#x27;
                           &#x27;int reason) {\n&#x27;
                           &#x27;        switch (reason) {\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_AUTO_TRANSITION:\n&#x27;
                           &#x27;                return &quot;PERIOD_TRANSITION&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SEEK:\n&#x27;
                           &#x27;                return &quot;SEEK&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SEEK_ADJUSTMENT:\n&#x27;
                           &#x27;                return &quot;SEEK_ADJUSTMENT&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_INTERNAL:\n&#x27;
                           &#x27;                return &quot;INTERNAL&quot;;\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_REMOVE:\n&#x27;
                           &#x27;            case &#x27;
                           &#x27;Player.DISCONTINUITY_REASON_SKIP:\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                return &quot;?&quot;;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPlaybackStateChanged(int state) {\n&#x27;
                         &#x27;        boolean playWhenReady = state == &#x27;
                         &#x27;Player.STATE_READY;\n&#x27;
                         &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                         &#x27;getSessionTimeString() + &quot;, &quot; + playWhenReady + &quot;, &#x27;
                         &#x27;&quot;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPlaybackStateChanged(@Player.State int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString()  + &quot;, &quot;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void onPlayWhenReadyChanged(boolean &#x27;
                           &#x27;playWhenReady, int state) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;state [&quot; + &#x27;
                           &#x27;getSessionTimeString() + &quot;, &quot; + playWhenReady + &quot;, &#x27;
                           &#x27;&quot;\n&#x27;
                           &#x27;                + getStateString(state) + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onPositionDiscontinuity(\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition,\n&#x27;
                         &#x27;            @Player.DiscontinuityReason int reason\n&#x27;
                         &#x27;    ) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void &#x27;
                           &#x27;onPositionDiscontinuity(Player.PositionInfo &#x27;
                           &#x27;oldPosition, Player.PositionInfo newPosition, &#x27;
                           &#x27;@Player.DiscontinuityReason int reason) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onAudioInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                         &#x27;format, @Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void onVideoInputFormatChanged(Format &#x27;
                           &#x27;format, DecoderReuseEvaluation &#x27;
                           &#x27;decoderReuseEvaluation) {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    @Override\n&#x27;
                         &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Override\n&#x27;
                           &#x27;    public void onRenderedFirstFrame(Object &#x27;
                           &#x27;output, long renderTimeMs) {\n&#x27;
                           &#x27;        Log.d(TAG, &quot;renderedFirstFrame [&quot; + output &#x27;
                           &#x27;+ &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                return &quot;AUTO_TRANSITION&quot;;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                return &quot;PERIOD_TRANSITION&quot;;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public void onTimelineChanged(Timeline timeline, &#x27;
                         &#x27;int reason) {\n&#x27;
                         &#x27;        int periodCount = &#x27;
                         &#x27;timeline.getPeriodCount();\n&#x27;
                         &#x27;        int windowCount = &#x27;
                         &#x27;timeline.getWindowCount();\n&#x27;
                         &#x27;        Log.d(TAG, &quot;sourceInfo [periodCount=&quot; + &#x27;
                         &#x27;periodCount + &quot;, windowCount=&quot; + windowCount);\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(periodCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getPeriod(i, period);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;period [&quot; + &#x27;
                         &#x27;getTimeString(period.getDurationMs()) + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (periodCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        for (int i = 0; i &lt; Math.min(windowCount, &#x27;
                         &#x27;MAX_TIMELINE_ITEM_LINES); i++) {\n&#x27;
                         &#x27;            timeline.getWindow(i, window);\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  &quot; + &quot;window [&quot; + &#x27;
                         &#x27;getTimeString(window.getDurationMs()) + &quot;, &quot;\n&#x27;
                         &#x27;                    + window.isSeekable + &quot;, &quot; + &#x27;
                         &#x27;window.isDynamic + &quot;]&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (windowCount &gt; MAX_TIMELINE_ITEM_LINES) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            Log.d(TAG, &quot;  ...&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        Log.d(TAG, &quot;]&quot;);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;onSkipSilenceEnabledChanged(boolean &#x27;
                           &#x27;skipSilenceEnabled) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;@Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nDecoderReuseEvaluation decoderReuseEvaluation\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;@Nullable DecoderReuseEvaluation &#x27;
                         &#x27;decoderReuseEvaluation\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\nDecoderReuseEvaluation decoderReuseEvaluation\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;oldPosition,\n&#x27;
                         &#x27;            @NonNull Player.PositionInfo &#x27;
                         &#x27;newPosition\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;Player.PositionInfo oldPosition, &#x27;
                           &#x27;Player.PositionInfo newPosition\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&quot;state [&quot; + getSessionTimeString() + &quot;, &quot; + &#x27;
                         &#x27;playWhenReady + &quot;, &quot;\n&#x27;
                         &#x27;                + getStateString(state) + &quot;]&quot;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;&quot;internalError [&quot; + getSessionTimeString() + &quot;, &quot; &#x27;
                           &#x27;+ type + &quot;]&quot;\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;{\n&#x27;
                         &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + &#x27;
                         &#x27;videoSize.width + &quot;, &quot; + videoSize.height + &quot;]&quot;);\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;{\n&#x27;
                           &#x27;        Log.d(TAG, &quot;videoSizeChanged [&quot; + width + &#x27;
                           &#x27;&quot;, &quot; + height + &quot;]&quot;);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        