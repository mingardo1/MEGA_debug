<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>255</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    255
                    <a href="254.html">prev</a>
                    <a href="256.html">next</a>
                    <a href="255_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_522131259c6f69ad7467dfcaf422c74f0f4c667c_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;522131259c6f69ad7467dfcaf422c74f0f4c667c^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;f5f52a0a63fcbc018b0183c6fbb4fa4c84da7d26:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/service/persistence/module/BasicPersistenceModule.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bs], [bs], [j]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20 
  21 import org.apache.commons.beanutils.PropertyUtils;
  22 import org.apache.commons.collections.CollectionUtils;
  23 import org.apache.commons.lang.ArrayUtils;
  24 import org.apache.commons.lang.StringUtils;
  25 import org.apache.commons.lang3.BooleanUtils;
  26 import org.apache.commons.lang3.reflect.FieldUtils;
  27 import org.apache.commons.lang3.reflect.MethodUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31 import org.broadleafcommerce.common.exception.ExceptionHelper;
  32 import org.broadleafcommerce.common.exception.SecurityServiceException;
  33 import org.broadleafcommerce.common.exception.ServiceException;
  34 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35 import org.broadleafcommerce.common.money.Money;
  36 import org.broadleafcommerce.common.presentation.client.OperationType;
  37 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  38 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  39 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  40 import org.broadleafcommerce.common.util.FormatUtil;
  41 import org.broadleafcommerce.common.util.StringUtil;
  42 import org.broadleafcommerce.common.util.ValidationUtil;
  43 import org.broadleafcommerce.common.util.dao.TQJoin;
  44 import org.broadleafcommerce.common.util.dao.TQOrder;
  45 import org.broadleafcommerce.common.util.dao.TQRestriction;
  46 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  47 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  48 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  50 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  51 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  52 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  53 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  54 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;
<abbr title="  55 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  55 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  56 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  56 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  57 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  57 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  59 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  59 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title="  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;">  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
  65 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title="  66 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;">  66 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
  67 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  68 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  69 import org.hibernate.FlushMode;
  70 import org.hibernate.Session;
  71 import org.springframework.beans.BeansException;
  72 import org.springframework.context.ApplicationContext;
  73 import org.springframework.context.ApplicationContextAware;
  74 import org.springframework.context.annotation.Primary;
  75 import org.springframework.context.annotation.Scope;
  76 import org.springframework.stereotype.Component;
  77 import org.springframework.util.Assert;
  78 
  79 import javax.annotation.PostConstruct;
  80 import javax.annotation.Resource;
  81 import java.io.Serializable;
  82 import java.lang.reflect.Field;
  83 import java.lang.reflect.InvocationTargetException;
  84 import java.lang.reflect.Method;
  85 import java.lang.reflect.ParameterizedType;
  86 import java.math.BigDecimal;
  87 import java.sql.Timestamp;
  88 import java.text.DecimalFormat;
  89 import java.text.NumberFormat;
  90 import java.text.SimpleDateFormat;
  91 import java.util.*;
  92 import java.util.Map.Entry;
  93 
  94 /**
  95  * @author jfischer
  96  */
  97 @Primary
  98 @Component(&quot;blBasicPersistenceModule&quot;)
  99 @Scope(&quot;prototype&quot;)
 100 public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 101 
 102     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 103 
 104     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 105     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 106 
 107     protected ApplicationContext applicationContext;
 108     protected PersistenceManager persistenceManager;
 109 
 110     @Resource(name = &quot;blEntityValidatorService&quot;)
 111     protected EntityValidatorService entityValidatorService;
 112 
 113     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 115 
 116     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 117     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 118 
 119     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 120     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 121 
 122     @Resource(name = &quot;blCriteriaTranslator&quot;)
 123     protected CriteriaTranslator criteriaTranslator;
 124 
 125     @Resource(name = &quot;blRestrictionFactory&quot;)
 126     protected RestrictionFactory restrictionFactory;
 127 
 128     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 129     protected BasicPersistenceModuleExtensionManager extensionManager;
 130 
 131     @Resource(name = &quot;blFetchWrapper&quot;)
 132     protected FetchWrapper fetchWrapper;
 133 
 134     @PostConstruct
 135     public void init() {
 136         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 137 
 138             @Override
 139             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 140                 return Integer.compare(o1.getOrder(), o2.getOrder());
 141             }
 142         });
 143         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 144 
 145             @Override
 146             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 147                 return Integer.compare(o1.getOrder(), o2.getOrder());
 148             }
 149         });
 150     }
 151 
 152     @Override
 153     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 154         this.applicationContext = applicationContext;
 155     }
 156 
 157     @Override
 158     public boolean isCompatible(OperationType operationType) {
<abbr title=" 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 160     }
 161 
 162     @Override
 163     public FieldManager getFieldManager() {
 164         return persistenceManager.getDynamicEntityDao().getFieldManager();
 165     }
 166 
 167     @Override
 168     public DecimalFormat getDecimalFormatter() {
 169         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 170         Locale locale = brc.getJavaLocale();
 171         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 172         format.applyPattern(&quot;0.########&quot;);
 173         format.setGroupingUsed(false);
 174         return format;
 175     }
 176 
 177     @Override
 178     public SimpleDateFormat getSimpleDateFormatter() {
 179         return FormatUtil.getDateFormat();
 180     }
 181 
<abbr title=" 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 183         if (metadata == null) {
 184             return null;
 185         }
 186         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 187         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 188             String fieldName = entry.getKey();
 189             FieldMetadata md = entry.getValue();
<abbr title=" 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 192             // can appropriate handle filtration and population
 193             if (entry.getValue() instanceof BasicFieldMetadata) {
 194                 newMap.put(fieldName, md);
<abbr title=" 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
 196                 newMap.put(fieldName,
<abbr title=" 197                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 197                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadaðŸ”µ</abbr>
 198             }
 199         }
 200 
 201         return newMap;
 202     }
 203 
 204     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 205         Class&lt;?&gt; response;
 206         switch (fieldType) {
 207             case BOOLEAN:
 208                 response = Boolean.TYPE;
 209                 break;
 210             case DATE:
 211                 response = Date.class;
 212                 break;
 213             case DECIMAL:
 214                 response = BigDecimal.class;
 215                 break;
 216             case MONEY:
 217                 response = Money.class;
 218                 break;
 219             case INTEGER:
 220                 response = Integer.TYPE;
 221                 break;
 222             case UNKNOWN:
 223                 response = null;
 224                 break;
 225             default:
 226                 response = String.class;
 227                 break;
 228         }
 229 
 230         return response;
 231     }
 232 
 233     @Override
 234     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 235             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 236         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 237     }
 238 
 239     @Override
 240     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 241             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 241             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedPrðŸ”µ</abbr>
<abbr title=" 242         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 242         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 243         FieldManager fieldManager = getFieldManager();
 244         boolean handled = false;
 245         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 246             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 246             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 247             if (MetadataProviderResponse.NOT_HANDLED != response) {
 248                 handled = true;
 249             }
 250             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 251                 break;
 252             }
 253         }
 254         if (!handled) {
<abbr title=" 255             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 255             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 256         }
<abbr title=" 257         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 257         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 258         Property[] sortedProperties = entity.getProperties();
 259         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 260 
 261             @Override
 262             public int compare(Property o1, Property o2) {
 263                 BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 264                 BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 265                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 265                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 266                         SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 267                         SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 268                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 268                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManageðŸ”µ</abbr>
<abbr title=" 269                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 269                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 270                         SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 271                         SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 272                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 272                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManageðŸ”µ</abbr>
 273                 if (isLate1 &amp;&amp; !isLate2) {
 274                     return 1;
 275                 } else if (!isLate1 &amp;&amp; isLate2) {
 276                     return -1;
 277                 }
 278                 return 0;
 279             }
 280         });
<abbr title=" 281         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 281         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 282         FlushMode originalFlushMode = session.getHibernateFlushMode();
 283         try {
 284             session.setHibernateFlushMode(FlushMode.MANUAL);
 285             RuntimeException entityPersistenceException = null;
 286             for (Property property : sortedProperties) {
<abbr title=" 287                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());"> 287                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName(ðŸ”µ</abbr>
 288                 Class&lt;?&gt; returnType;
<abbr title=" 289                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 289                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().sðŸ”µ</abbr>
 290                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 291                     if (field == null) {
<abbr title=" 292                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 292                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtðŸ”µ</abbr>
 293                         continue;
 294                     }
 295                     returnType = field.getType();
 296                 } else {
 297                     if (metadata == null) {
<abbr title=" 298                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 298                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StriðŸ”µ</abbr>
 299                         continue;
 300                     }
 301                     returnType = getMapFieldType(instance, fieldManager, property);
 302                     if (returnType == null) {
 303                         returnType = getBasicBroadleafType(metadata.getFieldType());
 304                     }
 305                 }
 306                 if (returnType == null) {
<abbr title=" 307                     throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 307                     throw new IllegalAccessException(&quot;Unable to determine the value type for the propertyðŸ”µ</abbr>
 308                 }
 309                 String value = property.getValue();
 310                 if (metadata != null) {
 311 
 312                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 313                         if (value == null) {
 314                             String defaultValue = metadata.getDefaultValue();
 315                             value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;
 316                         }
 317                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 318                         if (StringUtils.isEmpty(value)) {
 319                             value = null;
 320                         }
 321                     }
 322 
<abbr title=" 323                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 323                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 324                         boolean isValid = true;
<abbr title=" 325                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 325                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 326                         handled = false;
 327                         if (value != null) {
 328                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 329                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 329                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 330                                 if (!validationResult.isValid()) {
<abbr title=" 331                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 331                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 332                                     isValid = false;
 333                                 }
 334                             }
 335                         }
 336                         if (isValid) {
 337                             try {
 338                                 boolean isBreakDetected = false;
<abbr title=" 339                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 339                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 340                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 340                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (vaðŸ”µ</abbr>
<abbr title=" 341                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 341                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 342                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 343                                             handled = true;
 344                                         }
 345                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 346                                             isBreakDetected = true;
 347                                         }
 348                                     }
 349                                 }
 350                                 if (!handled) {
 351                                     if (value == null) {
 352                                         property.setIsDirty(true);
 353                                     }
<abbr title=" 354                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 354                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 355                                     if (value == null) {
 356                                         fieldManager.setFieldValue(instance, property.getName(), null);
 357                                     }
 358                                 }
<abbr title=" 359                             } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {"> 359                             } catch (ParentEntityPersistenceException | javax.validation.ValidationExceptðŸ”µ</abbr>
 360                                 entityPersistenceException = e;
 361                                 cleanupFailedPersistenceAttempt(instance);
 362                                 break;
 363                             }
 364                         }
 365                     }
 366                 }
 367             }
 368             // Only check validation if not the initial add
 369             if (!entity.isPreAdd()) {
 370                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 371             }
<abbr title=" 372             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 372             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 373             if (entity.isValidationFailure()) {
 374                 //only refresh the instance if it was managed to begin with
<abbr title=" 375                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 375                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 376                     persistenceManager.getDynamicEntityDao().refresh(instance);
 377                 }
 378 
<abbr title=" 379                 //re-initialize the valid properties for the entity in order to deal with the potential of not"> 379                 //re-initialize the valid properties for the entity in order to deal with the potential oðŸ”µ</abbr>
 380                 //completely sending over all checkbox/radio fields
 381                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 382                 entityList.add(instance);
 383                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 384                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 385                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 386                 invalid.overridePropertyValues(entity);
 387 
<abbr title=" 388                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 388                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 389                 throw new ValidationException(invalid, message);
 390             } else if (entityPersistenceException != null) {
 391                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 392             } else {
 393                 fieldManager.persistMiddleEntities();
 394             }
 395         } catch (IllegalAccessException e) {
 396             throw new PersistenceException(e);
 397         } catch (InstantiationException e) {
 398             throw new PersistenceException(e);
 399         } finally {
 400             session.setHibernateFlushMode(originalFlushMode);
 401         }
 402         return instance;
 403     }
 404 
<abbr title=" 405     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,"> 405     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
<abbr title=" 406                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 406                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, SðŸ”µ</abbr>
 407         Boolean mutable = metadata.getMutable();
 408         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 409         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 409         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp;ðŸ”µ</abbr>
 410 
 411         if (generalConditionsMet &amp;&amp; value == null) {
 412             boolean currentValueIsNotNull = false;
 413             try {
 414                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 415             } catch (FieldNotAvailableException e) {
 416                 throw new IllegalArgumentException(e);
 417             }
 418 
 419             boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 420             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 421 
 422             return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 423         }
 424         return generalConditionsMet;
 425     }
 426 
 427     @Override
<abbr title=" 428     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 428     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 429         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 430         records.add(record);
<abbr title=" 431         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 431         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 432         return productEntities[0];
 433     }
 434 
 435     @Override
<abbr title=" 436     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 436     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 437         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 437         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 438         return getRecord(mergedProperties, record, null, null);
 439     }
 440 
 441     @Override
<abbr title=" 442     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 442     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 443         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 443         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 444         return getRecords(mergedProperties, records, null, null, null);
 445     }
 446 
 447     @Override
<abbr title=" 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 449         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 449         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 450     }
 451 
 452     @Override
<abbr title=" 453     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 453     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 454         return getRecords(primaryMergedProperties, records, null, null, null);
 455     }
 456 
 457     @Override
 458     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 459                                List&lt;? extends Serializable&gt; records,
 460                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 461                                String pathToTargetObject) {
<abbr title=" 462         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 462         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 463     }
 464 
 465     @Override
 466     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 467                                List&lt;? extends Serializable&gt; records,
 468                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 469                                String pathToTargetObject,
 470                                String[] customCriteria) {
<abbr title=" 471         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 471         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 472         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 472         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 473         Entity[] entities = new Entity[records.size()];
 474         int j = 0;
 475         for (Serializable recordEntity : records) {
 476             Serializable entity;
 477             if (pathToTargetObject != null) {
 478                 try {
<abbr title=" 479                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);"> 479                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObjðŸ”µ</abbr>
 480                 } catch (Exception e) {
 481                     throw new PersistenceException(e);
 482                 }
 483             } else {
 484                 entity = recordEntity;
 485             }
 486             Entity entityItem = new Entity();
 487             entityItem.setType(new String[] { entity.getClass().getName() });
 488             entities[j] = entityItem;
 489 
 490             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 491             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 491             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 492             if (alternateMergedProperties != null) {
<abbr title=" 493                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 493                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 494             }
 495 
 496             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 497             try {
 498                 Property p = new Property();
 499                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
 500                 String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 501                 p.setValue(mainEntityName);
 502                 props.add(p);
 503             } catch (Exception e) {
 504                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 505                         entity.getClass().getName()), e);
 506             }
 507 
 508             // Try to add the alternate id property if available
 509             if (alternateMergedProperties != null) {
 510                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 511                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 512                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {"> 512                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ðŸ”µ</abbr>
<abbr title=" 513                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 513                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 514                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 515                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 516                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 516                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 517                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 518                             for (Property prop : props2) {
 519                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 520                                     filtered.add(prop);
 521                                 }
 522                             }
 523                             if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 524                                 Property alternateIdProp = filtered.get(0);
 525                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 526                                 props.add(alternateIdProp);
 527                             }
 528                         }
 529                     }
 530                 }
 531             }
 532 
 533             Property[] properties = new Property[props.size()];
 534             properties = props.toArray(properties);
 535             entityItem.setProperties(properties);
 536             j++;
 537         }
 538 
 539         return entities;
 540     }
 541 
 542     @Override
 543     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 544         return fetchWrapper.getRecords(fetchExtractionRequest);
 545     }
 546 
 547     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 548                                                          Serializable entity,
 549                                                          List&lt;Property&gt; props,
 550                                                          String[] customCriteria) {
 551         FieldManager fieldManager = getFieldManager();
 552         try {
 553             if (entity instanceof AdminMainEntity) {
 554                 //Create an invisible property for the admin main entity name, if applicable.
 555                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 556                 //its display name.
 557                 try {
 558                     Property propertyItem = new Property();
 559                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 560                     propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 561                     props.add(propertyItem);
 562                 } catch (Exception e) {
<abbr title=" 563                     //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 563                     //do nothing here except for not add the property. Exceptions could occur when there ðŸ”µ</abbr>
<abbr title=" 564                     //issue and some properties/relationships that are used for gleaning the main entity name end up"> 564                     //issue and some properties/relationships that are used for gleaning the main entity ðŸ”µ</abbr>
 565                     //not being set
 566                 }
 567             }
 568             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 569                 String property = entry.getKey();
 570                 BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 571                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 571                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 572                     boolean proceed = true;
 573                     if (property.contains(&quot;.&quot;)) {
 574                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 575                         Object testObject = entity;
 576                         while (tokens.hasMoreTokens()) {
 577                             String token = tokens.nextToken();
 578                             if (tokens.hasMoreTokens()) {
 579                                 try {
 580                                     testObject = fieldManager.getFieldValue(testObject, token);
 581                                 } catch (FieldNotAvailableException e) {
 582                                     proceed = false;
 583                                     break;
 584                                 }
 585                                 if (testObject == null) {
 586                                     Property propertyItem = new Property();
 587                                     propertyItem.setName(property);
 588                                     if (props.contains(propertyItem)) {
 589                                         proceed = false;
 590                                         break;
 591                                     }
 592                                     propertyItem.setValue(null);
 593                                     props.add(propertyItem);
 594                                     proceed = false;
 595                                     break;
 596                                 }
 597                             }
 598                         }
 599                     }
 600                     if (!proceed) {
 601                         continue;
 602                     }
 603 
 604                     boolean isFieldAccessible = true;
 605                     Object value = null;
 606                     try {
 607                         value = fieldManager.getFieldValue(entity, property);
 608                     } catch (FieldNotAvailableException e) {
 609                         isFieldAccessible = false;
 610                     }
 611                     checkField:
 612                     {
 613                         if (isFieldAccessible) {
 614                             Property propertyItem = new Property();
 615                             propertyItem.setName(property);
 616                             if (props.contains(propertyItem)) {
 617                                 continue;
 618                             }
 619                             props.add(propertyItem);
 620                             String displayVal = propertyItem.getDisplayValue();
 621                             boolean handled = false;
<abbr title=" 622                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 622                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 623                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue("> 623                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
<abbr title=" 624                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 624                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 625                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 625                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 626                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 627                                     handled = true;
 628                                 }
 629                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 630                                     break;
 631                                 }
 632                             }
 633                             if (!handled) {
 634                                 defaultFieldPersistenceProvider.extractValue(
<abbr title=" 635                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 635                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 636                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 636                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 637                             }
 638                             break checkField;
 639                         }
 640                         //try a direct property acquisition via reflection
 641                         try {
 642                             String strVal = null;
 643                             Method method;
 644                             try {
 645                                 //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 646                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 646                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.sðŸ”µ</abbr>
 647                                 method = entity.getClass().getMethod(temp, new Class[] {});
 648                             } catch (NoSuchMethodException e) {
 649                                 method = entity.getClass().getMethod(property, new Class[] {});
 650                             }
 651                             value = method.invoke(entity, new String[] {});
 652                             Property propertyItem = new Property();
 653                             propertyItem.setName(property);
 654                             if (props.contains(propertyItem)) {
 655                                 continue;
 656                             }
 657                             props.add(propertyItem);
 658                             if (value == null) {
 659                                 strVal = null;
 660                             } else {
 661                                 if (Date.class.isAssignableFrom(value.getClass())) {
 662                                     strVal = getSimpleDateFormatter().format((Date) value);
 663                                 } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 664                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 664                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value)ðŸ”µ</abbr>
 665                                 } else if (Calendar.class.isAssignableFrom(value.getClass())) {
<abbr title=" 666                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());"> 666                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime()ðŸ”µ</abbr>
 667                                 } else if (Double.class.isAssignableFrom(value.getClass())) {
 668                                     strVal = getDecimalFormatter().format(value);
 669                                 } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 670                                     strVal = getDecimalFormatter().format(value);
 671                                 } else {
 672                                     strVal = value.toString();
 673                                 }
 674                             }
 675                             propertyItem.setValue(strVal);
 676                         } catch (NoSuchMethodException e) {
<abbr title=" 677                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 677                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 678                             //do nothing - this property is simply not in the bean
 679                         }
 680                     }
 681                 }
 682             }
 683         } catch (ClassNotFoundException e) {
 684             throw new PersistenceException(e);
 685         } catch (IllegalAccessException e) {
 686             throw new PersistenceException(e);
 687         } catch (InvocationTargetException e) {
 688             throw new PersistenceException(e);
 689         }
 690     }
 691 
 692     @Override
 693     public String getStringValueFromGetter(Serializable instance, String propertyName)
 694             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 695         Object value = PropertyUtils.getProperty(instance, propertyName);
 696         return formatValue(value);
 697     }
 698 
 699     @Override
 700     public String formatValue(Object value) {
 701         String strVal;
 702         if (value == null) {
 703             strVal = null;
 704         } else {
 705             if (Date.class.isAssignableFrom(value.getClass())) {
 706                 strVal = getSimpleDateFormatter().format((Date) value);
 707             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 708                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 709             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 710                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 711             } else if (Double.class.isAssignableFrom(value.getClass())) {
 712                 strVal = getDecimalFormatter().format(value);
 713             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 714                 strVal = getDecimalFormatter().format(value);
 715             } else {
 716                 strVal = value.toString();
 717             }
 718         }
 719         return strVal;
 720     }
 721 
<abbr title=" 722     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 722     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 723         EntityResult entityResult = new EntityResult();
 724         Entity entity = persistencePackage.getEntity();
 725         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 726         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 726         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 727         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 728             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 729         }
 730         try {
<abbr title=" 731             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 731             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 732             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 732             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 733                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 734                     entities,
 735                     foreignKey,
 736                     persistencePerspective.getAdditionalNonPersistentProperties(),
 737                     persistencePerspective.getAdditionalForeignKeys(),
 738                     MergedPropertyType.PRIMARY,
 739                     persistencePerspective.getPopulateToOneFields(),
 740                     persistencePerspective.getIncludeFields(),
 741                     persistencePerspective.getExcludeFields(),
 742                     persistencePerspective.getConfigurationKey(),
 743                     &quot;&quot;
 744                     );
 745             if (primaryKey == null) {
 746                 primaryKey = getPrimaryKey(entity, mergedProperties);
 747             }
<abbr title=" 748             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 748             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 749 
 750             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 751 
 752             if (!entity.isValidationFailure()) {
 753                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 754                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 755                         entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 756                         entity.findProperty(foreignKey.getSortField()).getValue() != null) {
<abbr title=" 757                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 757                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
 758                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 759                             mergedProperties, primaryKey, result);
 760                     instance = result.getResult();
 761                 } else {
<abbr title=" 762                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 762                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 763                 }
 764 
 765                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 766                 if (includeRealEntity) {
 767                     entityResult.setEntityBackingObject(instance);
 768                 }
 769 
 770                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 771                 entityList.add(instance);
 772 
 773                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 774                 entityResult.setEntity(entity);
 775                 return entityResult;
 776             } else {
 777                 entityResult.setEntity(entity);
 778                 return entityResult;
 779             }
 780         } catch (Exception e) {
 781             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 782         }
 783     }
 784 
 785     @Override
 786     public String getIdPropertyName(String entityClass) {
 787         return persistenceManager.getIdPropertyName(entityClass);
 788     }
 789 
 790     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 791         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 791         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 792         for (String property : mergedProperties.keySet()) {
 793             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 794             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 795                 return property;
 796             }
 797         }
 798 
<abbr title=" 799         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 799         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 800     }
 801 
 802     @Override
 803     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 804         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 804         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 805         Object primaryKey = null;
 806         String idPropertyName = null;
 807         BasicFieldMetadata metaData = null;
 808         for (String property : mergedProperties.keySet()) {
 809             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 810             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 811                 idPropertyName = property;
 812                 metaData = temp;
 813                 break;
 814             }
 815         }
 816         if (idPropertyName == null) {
<abbr title=" 817             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 817             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 818         }
 819         for (Property property : entity.getProperties()) {
 820             if (property.getName().equals(idPropertyName)) {
 821                 switch (metaData.getSecondaryType()) {
 822                     case INTEGER:
<abbr title=" 823                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 823                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 824                         break;
 825                     case STRING:
 826                         primaryKey = property.getValue();
 827                         break;
 828                 }
 829                 break;
 830             }
 831         }
 832         if (primaryKey == null) {
<abbr title=" 833             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 833             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) ðŸ”µ</abbr>
 834         }
 835         return primaryKey;
 836     }
 837 
 838     @Override
 839     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 840             CriteriaTransferObject cto,
 841             String ceilingEntityFullyQualifiedClassname,
 842             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 843             RestrictionFactory customRestrictionFactory) {
<abbr title=" 844         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 844         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 845         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 846 
 847         for (String propertyId : cto.getCriteriaMap().keySet()) {
 848             if (mergedProperties.containsKey(propertyId)) {
 849                 boolean handled = false;
 850                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 851                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 852                             new AddSearchMappingRequest(persistencePerspective, cto,
 853                                     ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 854                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 854                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==ðŸ”µ</abbr>
 855                                     :customRestrictionFactory), filterMappings);
 856                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 857                         handled = true;
 858                     }
 859                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 860                         break;
 861                     }
 862                 }
 863                 if (!handled) {
 864                     defaultFieldPersistenceProvider.addSearchMapping(
 865                             new AddSearchMappingRequest(persistencePerspective, cto,
 866                                     ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 867                                     getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 867                                     getFieldManager(), this, this, customRestrictionFactory == null ? resðŸ”µ</abbr>
 868                                             : customRestrictionFactory), filterMappings);
 869                 }
 870             }
 871         }
 872         return filterMappings;
 873     }
 874 
 875     @Override
 876     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 877             CriteriaTransferObject cto,
 878             String ceilingEntityFullyQualifiedClassname,
 879             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 880         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 880         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
 881     }
 882 
 883     @Override
<abbr title=" 884     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 884     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 885         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 885         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
 886     }
 887 
<abbr title=" 888     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 888     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
 889         Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 890 
 891             @Override
 892             public int compare(Property o1, Property o2) {
 893                 return o1.getName().compareTo(o2.getName());
 894             }
 895         };
 896 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 897         properties.sort(comparator);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 898 </span>
 899 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 900                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 901             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 902         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 903         return filterMappings;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 904     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 905 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 906     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 907     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 908             CriteriaTransferObject cto,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 909             String ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 910             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 911         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 911         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 912     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 913 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 914     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 915     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 915     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 916         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 916         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 917     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 918 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 919     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 919     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 920         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 921             String property = entry.getKey();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 922             Property prop = new Property();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 923             FieldMetadata metadata = mergedProperties.get(property);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 924             prop.setName(property);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 925             Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 926 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 927                 @Override</span>
 928 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 929         Collections.sort(properties, comparator);</span>
 930 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 931         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 932             String property = entry.getKey();
 933             Property prop = new Property();
 934             FieldMetadata metadata = mergedProperties.get(property);
 935             prop.setName(property);
 936 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 937 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 938     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 939             CriteriaTransferObject cto,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 940             String ceilingEntityFullyQualifiedClassname,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 941             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 942         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 942         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 943     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 944 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 945     @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 946     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 946     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 947         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 947         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 948     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 949 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 950     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 950     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 951         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 952             String property = entry.getKey();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 953             Property prop = new Property();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 954             FieldMetadata metadata = mergedProperties.get(property);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 955             prop.setName(property);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 956             Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 957 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 958                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 959                 public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 960                     return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 961                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 962             };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 963             Collections.sort(properties, comparator);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 964             int pos = Collections.binarySearch(properties, prop, comparator);</span>
 965 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 966  </span>
 967 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 968             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 969             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 969             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREðŸ”µ</abbr>
 970                 logWarn: {
<abbr title=" 971                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 971                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
 972                         //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 973                         break logWarn;
 974                     }
<abbr title=" 975                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 975                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
 976                 }
 977                 continue;
 978             } else if (pos &lt; 0) {
 979                 pos = -pos - 1; // calculate position to insert
 980             }
 981             properties.add(pos, prop);
 982             prop.setMetadata(metadata);
 983             if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 984                 //this only makes sense for non collection types
 985                 ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 986             }
 987         }
 988     }
 989 
 990     @Override
<abbr title=" 991     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 991     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title=" 992         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 992         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 993         try {
<abbr title=" 994             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 994             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 995             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);"> 995             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title=" 996             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 996             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 997                     ceilingEntityFullyQualifiedClassname,
 998                     entities,
<abbr title=" 999                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 999                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1000                     persistencePerspective.getAdditionalNonPersistentProperties(),
1001                     persistencePerspective.getAdditionalForeignKeys(),
1002                     MergedPropertyType.PRIMARY,
1003                     persistencePerspective.getPopulateToOneFields(),
1004                     persistencePerspective.getIncludeFields(),
1005                     persistencePerspective.getExcludeFields(),
1006                     persistencePerspective.getConfigurationKey(),
1007                     &quot;&quot;
1008                     );
1009             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
1010         } catch (Exception e) {
<abbr title="1011             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1011             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1012         }
1013     }
1014 
1015     @Override
<abbr title="1016     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1016     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
1017         return update(persistencePackage, null, true);
1018     }
1019 
1020     @Override
1021     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
1022         EntityResult er = update(persistencePackage, null, false);
1023         return er.getEntity();
1024     }
1025 
1026     @Override
1027     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1028         EntityResult entityResult = add(persistencePackage, false);
1029         return entityResult.getEntity();
1030     }
1031 
1032     @Override
<abbr title="1033     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1033     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
1034         EntityResult entityResult = new EntityResult();
1035         Entity entity = persistencePackage.getEntity();
1036         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1037         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1037         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1038         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1039             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1040         }
1041         try {
<abbr title="1042             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1042             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1043             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1043             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1044                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1045                     entities,
1046                     foreignKey,
1047                     persistencePerspective.getAdditionalNonPersistentProperties(),
1048                     persistencePerspective.getAdditionalForeignKeys(),
1049                     MergedPropertyType.PRIMARY,
1050                     persistencePerspective.getPopulateToOneFields(),
1051                     persistencePerspective.getIncludeFields(),
1052                     persistencePerspective.getExcludeFields(),
1053                     persistencePerspective.getConfigurationKey(),
1054                     &quot;&quot;
1055                     );
<abbr title="1056             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1056             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1057 
1058             String idProperty = null;
1059             for (String property : mergedProperties.keySet()) {
<abbr title="1060                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1060                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFielðŸ”µ</abbr>
1061                     idProperty = property;
1062                     break;
1063                 }
1064             }
1065             if (idProperty == null) {
<abbr title="1066                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1066                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
1067             }
1068             Object primaryKey = null;
1069             try {
1070                 primaryKey = getPrimaryKey(entity, mergedProperties);
1071             } catch (Exception e) {
1072                 //don&#x27;t do anything - this is a valid case
1073             }
1074             if (primaryKey == null) {
1075 
1076                 Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1077 
1078                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1079 
1080                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
<abbr title="1081                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();">1081                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title="1082                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1082                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
1083                     instance = result.getResult();
1084                 }
1085 
1086                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
1087                 if (includeRealEntityObject) {
1088                     entityResult.setEntityBackingObject(instance);
1089                 }
1090                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1091                 entityList.add(instance);
1092 
1093                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1094                 entityResult.setEntity(entity);
1095                 return entityResult;
1096             } else {
1097                 return update(persistencePackage, primaryKey, includeRealEntityObject);
1098             }
1099         } catch (Exception e) {
1100             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1101         }
1102     }
1103 
1104     @Override
1105     public void remove(PersistencePackage persistencePackage) throws ServiceException {
1106         Entity entity = persistencePackage.getEntity();
1107         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1108         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1108         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1109         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1110             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1111         }
1112         try {
<abbr title="1113             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1113             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1114             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1114             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1115                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1116                     entities,
1117                     foreignKey,
1118                     persistencePerspective.getAdditionalNonPersistentProperties(),
1119                     persistencePerspective.getAdditionalForeignKeys(),
1120                     MergedPropertyType.PRIMARY,
1121                     persistencePerspective.getPopulateToOneFields(),
1122                     persistencePerspective.getIncludeFields(),
1123                     persistencePerspective.getExcludeFields(),
1124                     persistencePerspective.getConfigurationKey(),
1125                     &quot;&quot;
1126                     );
<abbr title="1127             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1127             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1128             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1129             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1129             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
1130 
1131             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1132 
1133             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1134                 case NONDESTRUCTIVEREMOVE:
1135                     FieldManager fieldManager = getFieldManager();
<abbr title="1136                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1136                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title="1137                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();">1137                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
1138                     try {
1139                         foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1140                     } catch (NumberFormatException e) {
<abbr title="1141                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);">1141                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
1142                     }
<abbr title="1143                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1143                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title="1144                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1144                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreðŸ”µ</abbr>
1145                     collection.remove(instance);
<abbr title="1146                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1146                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title="1147                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly">1147                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
1148                     // set the manyTo field to null so that subsequent lookups will not find it
1149                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1150                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {">1150                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())ðŸ”µ</abbr>
<abbr title="1151                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1151                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
<abbr title="1152                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1152                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in tðŸ”µ</abbr>
1153                                     + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1154                         }
<abbr title="1155                         //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1155                         //Since this is occuring on a remove persistence package, merge up-front (before ðŸ”µ</abbr>
1156                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1157                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1157                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
1158                         Object manyToObject = manyToField.get(instance);
<abbr title="1159                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1159                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObjeðŸ”µ</abbr>
1160                             manyToField.set(instance, null);
1161                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
1162                         }
1163                     }
1164                     break;
1165                 case BASIC:
1166                     persistenceManager.getDynamicEntityDao().remove(instance);
1167                     break;
1168             }
1169         } catch (Exception e) {
1170             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1171         }
1172     }
1173 
1174     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1175             CriteriaTransferObject cto) throws ServiceException {
1176         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1177         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1177         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1178 
1179         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1180             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1181         }
1182 
1183         try {
<abbr title="1184             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1184             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1185 
<abbr title="1186             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1186             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1187                     ceilingEntityFullyQualifiedClassname,
1188                     entities,
<abbr title="1189                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1189                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1190                     persistencePerspective.getAdditionalNonPersistentProperties(),
1191                     persistencePerspective.getAdditionalForeignKeys(),
1192                     MergedPropertyType.PRIMARY,
1193                     persistencePerspective.getPopulateToOneFields(),
1194                     persistencePerspective.getIncludeFields(),
1195                     persistencePerspective.getExcludeFields(),
1196                     persistencePerspective.getConfigurationKey(),
1197                     &quot;&quot;
1198                     );
1199 
1200             return mergedProperties;
1201         } catch (Exception e) {
<abbr title="1202             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1202             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1203         }
1204     }
1205 
1206     @Override
<abbr title="1207     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1207     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1208         Entity[] payload;
1209         int totalRecords;
1210         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1211         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1211         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1212         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1212         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1213 
1214         try {
1215             if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1216                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1217                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1218             }
1219 
1220             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1221 
<abbr title="1222             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage">1222             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1223                     .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1224             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1225             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1226                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1227             }
1228             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1229                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1230             }
1231 
1232             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1233                     persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1234             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1235 
1236             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1237             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1238                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1239             }
1240             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1241                     persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1242             totalRecords = getTotalRecords(countFetchRequest);
1243 
<abbr title="1244             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,">1244             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1245                     persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1246             payload = getRecords(fetchExtractionRequest);
1247         } catch (Exception e) {
<abbr title="1248             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1248             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1249         }
1250 
1251         return new DynamicResultSet(null, payload, totalRecords);
1252     }
1253 
1254     @Override
1255     public Integer getTotalRecords(FetchRequest fetchRequest) {
1256         return fetchWrapper.getTotalRecords(fetchRequest);
1257     }
1258 
1259     @Override
1260     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1261         try {
<abbr title="1262             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),">1262             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(ðŸ”µ</abbr>
1263                     ceilingEntity, filterMappings).getSingleResult()).intValue();
1264         } catch (CriteriaConversionException e) {
<abbr title="1265             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1265             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1266             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1266             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardðŸ”µ</abbr>
1267         }
1268     }
1269 
1270     @Override
<abbr title="1271     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1271     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
1272         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1273                 ceilingEntity, filterMappings, maxField).getSingleResult();
1274     }
1275 
1276     @Override
1277     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1278         return fetchWrapper.getPersistentRecords(fetchRequest);
1279     }
1280 
1281     @Override
<abbr title="1282     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1282     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1283         try {
<abbr title="1284             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1284             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1285         } catch (CriteriaConversionException e) {
<abbr title="1286             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1286             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1287             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1287             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1288         }
1289     }
1290 
1291     @Override
<abbr title="1292     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1292     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1293         return validate(entity, populatedInstance, mergedProperties, true);
1294     }
1295 
1296     @Override
<abbr title="1297     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1297     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1298             boolean validateUnsubmittedProperties) {
<abbr title="1299         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1299         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1300         return !entity.isValidationFailure();
1301     }
1302 
1303     @Override
1304     public void setPersistenceManager(PersistenceManager persistenceManager) {
1305         this.persistenceManager = persistenceManager;
1306     }
1307 
1308     @Override
1309     public PersistenceModule getCompatibleModule(OperationType operationType) {
1310         return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1311     }
1312 
1313     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1314         return defaultFieldPersistenceProvider;
1315     }
1316 
<abbr title="1317     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1317     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1318         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1319     }
1320 
1321     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1322         return fieldPersistenceProviders;
1323     }
1324 
1325     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1326         this.fieldPersistenceProviders = fieldPersistenceProviders;
1327     }
1328 
1329     public CriteriaTranslator getCriteriaTranslator() {
1330         return criteriaTranslator;
1331     }
1332 
1333     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1334         this.criteriaTranslator = criteriaTranslator;
1335     }
1336 
1337     public EntityValidatorService getEntityValidatorService() {
1338         return entityValidatorService;
1339     }
1340 
1341     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1342         this.entityValidatorService = entityValidatorService;
1343     }
1344 
1345     public RestrictionFactory getRestrictionFactory() {
1346         return restrictionFactory;
1347     }
1348 
1349     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1350         this.restrictionFactory = restrictionFactory;
1351     }
1352 
1353     public PersistenceManager getPersistenceManager() {
1354         return persistenceManager;
1355     }
1356 
1357     /**
<abbr title="1358      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1358      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1359      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1359      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1360      * which seems to alleviate the problem.
1361      *
1362      * @param embeddedCollectionPath the path to the collection field itself
1363      * @param filterMappings all the fetch restrictions for this request
1364      * @param collectionClass the type of the collection members
1365      * @return the builder capable of generating an appropriate HQL query
1366      */
<abbr title="1367     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1367     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1368         String specialPath = embeddedCollectionPath.getTargetProperty();
1369         String[] pieces = specialPath.split(&quot;\\.&quot;);
1370         if (pieces.length != 3) {
<abbr title="1371             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1371             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1372         }
1373         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1374         TypedQueryBuilder builder;
1375         try {
1376             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1377                     .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1378         } catch (Exception e) {
1379             throw ExceptionHelper.refineException(e);
1380         }
1381         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1382             builder = builder.addRestriction(restriction);
1383         }
<abbr title="1384         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1384         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1385             builder = builder.addRestriction(restriction);
1386         }
1387         for (FilterMapping mapping : filterMappings) {
1388             if (mapping.getSortDirection() != null) {
<abbr title="1389                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1389                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1390                 if (StringUtils.isEmpty(mappingProperty)) {
1391                     mappingProperty = mapping.getFullPropertyName();
1392                 }
<abbr title="1393                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1393                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1394             }
1395         }
1396 
1397         return builder;
1398     }
1399 
1400     /**
<abbr title="1401      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1401      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1402      *
<abbr title="1403      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1403      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1404      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1404      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1405      * @param filterMappings all the fetch restrictions for this request
1406      * @return the list of restrictions on the root entity
1407      */
<abbr title="1408     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1408     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1409         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1409         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1410         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1411         for (FilterMapping mapping : filterMappings) {
1412             checkProperty: {
<abbr title="1413                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1413                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1414                 if (StringUtils.isEmpty(mappingProperty)) {
1415                     mappingProperty = mapping.getFullPropertyName();
1416                 }
<abbr title="1417                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1417                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.iðŸ”µ</abbr>
<abbr title="1418                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1418                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1419                     if (predicateProvider != null) {
<abbr title="1420                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1420                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
1421                         if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1422                             Object val = converter.convert(mapping.getFilterValues().get(0));
1423                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1424                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1424                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1425                                 break checkProperty;
1426                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1427                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1427                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1428                                 break checkProperty;
1429                             }
1430                         }
1431                     }
<abbr title="1432                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1432                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1433                             StringUtil.sanitize(expression),
1434                             StringUtil.sanitize(mappingProperty)));
1435                 }
1436             }
1437         }
1438 
1439         return restrictions;
1440     }
1441 
1442     /**
<abbr title="1443      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1443      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1444      *
<abbr title="1445      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1445      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1446      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1446      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1447      * @param filterMappings all the fetch restrictions for this request
1448      * @return the list of restrictions on the collection in the @Embeddable object
1449      */
<abbr title="1450     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1450     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1451         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1452         for (FilterMapping mapping : filterMappings) {
<abbr title="1453             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1453             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mðŸ”µ</abbr>
1454                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1455                 if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1456                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1457                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1457                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1458                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1459                 }
1460             }
1461         }
1462         return restrictions;
1463     }
1464 
1465     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1466         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1467         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1467         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1468             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1469         }
1470         //Remove the id field value, if it&#x27;s set
<abbr title="1471         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1471         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1472         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1473         if (idField == null) {
<abbr title="1474             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1474             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1475         }
1476         idField.setAccessible(true);
1477         if (idField.get(instance) != null) {
1478             idField.set(instance, null);
1479         }
1480     }
1481 
<abbr title="1482     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1482     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1483         Class&lt;?&gt; returnType = null;
<abbr title="1484         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1484         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1485         java.lang.reflect.Type type = field.getGenericType();
1486         if (type instanceof ParameterizedType) {
1487             ParameterizedType pType = (ParameterizedType) type;
1488             Class&lt;?&gt; clazz;
1489             if (pType.getActualTypeArguments().length &lt; 2) {
1490                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1491             } else {
1492                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1493             }
<abbr title="1494             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1494             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1495             if (!ArrayUtils.isEmpty(entities)) {
1496                 returnType = entities[entities.length - 1];
1497             }
1498         }
1499         return returnType;
1500     }
1501 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 
  19 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20 
  21 import org.apache.commons.beanutils.PropertyUtils;
  22 import org.apache.commons.collections.CollectionUtils;
  23 import org.apache.commons.lang.ArrayUtils;
  24 import org.apache.commons.lang.StringUtils;
  25 import org.apache.commons.lang3.BooleanUtils;
  26 import org.apache.commons.lang3.reflect.FieldUtils;
  27 import org.apache.commons.lang3.reflect.MethodUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31 import org.broadleafcommerce.common.exception.ExceptionHelper;
  32 import org.broadleafcommerce.common.exception.SecurityServiceException;
  33 import org.broadleafcommerce.common.exception.ServiceException;
  34 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35 import org.broadleafcommerce.common.money.Money;
  36 import org.broadleafcommerce.common.presentation.client.OperationType;
  37 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  38 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  39 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  40 import org.broadleafcommerce.common.util.FormatUtil;
  41 import org.broadleafcommerce.common.util.StringUtil;
  42 import org.broadleafcommerce.common.util.ValidationUtil;
  43 import org.broadleafcommerce.common.util.dao.TQJoin;
  44 import org.broadleafcommerce.common.util.dao.TQOrder;
  45 import org.broadleafcommerce.common.util.dao.TQRestriction;
  46 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  47 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  48 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  50 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  51 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  52 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  53 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  54 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;
<abbr title="  55 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  55 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  56 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  56 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  57 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  57 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  58 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  59 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  59 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  60 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  61 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  62 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  63 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title="  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;">  64 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
  65 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title="  66 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;">  66 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
  67 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  68 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  69 import org.hibernate.FlushMode;
  70 import org.hibernate.Session;
  71 import org.springframework.beans.BeansException;
  72 import org.springframework.context.ApplicationContext;
  73 import org.springframework.context.ApplicationContextAware;
  74 import org.springframework.context.annotation.Primary;
  75 import org.springframework.context.annotation.Scope;
  76 import org.springframework.stereotype.Component;
  77 import org.springframework.util.Assert;
  78 import java.io.Serializable;
  79 import java.lang.reflect.Field;
  80 import java.lang.reflect.InvocationTargetException;
  81 import java.lang.reflect.Method;
  82 import java.lang.reflect.ParameterizedType;
  83 import java.math.BigDecimal;
  84 import java.sql.Timestamp;
  85 import java.text.DecimalFormat;
  86 import java.text.NumberFormat;
  87 import java.text.SimpleDateFormat;
  88 import java.util.*;
  89 import java.util.Map.Entry;
  90 
  91 import javax.annotation.PostConstruct;
  92 import javax.annotation.Resource;
  93 
  94 /**
  95  * @author jfischer
  96  */
  97 @Primary
  98 @Component(&quot;blBasicPersistenceModule&quot;)
  99 @Scope(&quot;prototype&quot;)
 100 public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 101 
 102     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 103 
 104     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 105     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 106 
 107     protected ApplicationContext applicationContext;
 108     protected PersistenceManager persistenceManager;
 109 
 110     @Resource(name = &quot;blEntityValidatorService&quot;)
 111     protected EntityValidatorService entityValidatorService;
 112 
 113     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 115 
 116     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 117     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 118 
 119     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 120     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 121 
 122     @Resource(name = &quot;blCriteriaTranslator&quot;)
 123     protected CriteriaTranslator criteriaTranslator;
 124 
 125     @Resource(name = &quot;blRestrictionFactory&quot;)
 126     protected RestrictionFactory restrictionFactory;
 127 
 128     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 129     protected BasicPersistenceModuleExtensionManager extensionManager;
 130 
 131     @Resource(name = &quot;blFetchWrapper&quot;)
 132     protected FetchWrapper fetchWrapper;
 133 
 134     @PostConstruct
 135     public void init() {
 136         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 137 
 138             @Override
 139             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 140                 return Integer.compare(o1.getOrder(), o2.getOrder());
 141             }
 142         });
 143         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 144 
 145             @Override
 146             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 147                 return Integer.compare(o1.getOrder(), o2.getOrder());
 148             }
 149         });
 150     }
 151 
 152     @Override
 153     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 154         this.applicationContext = applicationContext;
 155     }
 156 
 157     @Override
 158     public boolean isCompatible(OperationType operationType) {
<abbr title=" 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 160     }
 161 
 162     @Override
 163     public FieldManager getFieldManager() {
 164         return persistenceManager.getDynamicEntityDao().getFieldManager();
 165     }
 166 
 167     @Override
 168     public DecimalFormat getDecimalFormatter() {
 169         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 170         Locale locale = brc.getJavaLocale();
 171         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 172         format.applyPattern(&quot;0.########&quot;);
 173         format.setGroupingUsed(false);
 174         return format;
 175     }
 176 
 177     @Override
 178     public SimpleDateFormat getSimpleDateFormatter() {
 179         return FormatUtil.getDateFormat();
 180     }
 181 
<abbr title=" 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 183         if (metadata == null) {
 184             return null;
 185         }
 186         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 187         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 188             String fieldName = entry.getKey();
 189             FieldMetadata md = entry.getValue();
<abbr title=" 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 192             // can appropriate handle filtration and population
 193             if (entry.getValue() instanceof BasicFieldMetadata) {
 194                 newMap.put(fieldName, md);
<abbr title=" 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
 196                 newMap.put(fieldName,
<abbr title=" 197                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 197                         (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadaðŸ”µ</abbr>
 198             }
 199         }
 200 
 201         return newMap;
 202     }
 203 
 204     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 205         Class&lt;?&gt; response;
 206         switch (fieldType) {
 207             case BOOLEAN:
 208                 response = Boolean.TYPE;
 209                 break;
 210             case DATE:
 211                 response = Date.class;
 212                 break;
 213             case DECIMAL:
 214                 response = BigDecimal.class;
 215                 break;
 216             case MONEY:
 217                 response = Money.class;
 218                 break;
 219             case INTEGER:
 220                 response = Integer.TYPE;
 221                 break;
 222             case UNKNOWN:
 223                 response = null;
 224                 break;
 225             default:
 226                 response = String.class;
 227                 break;
 228         }
 229 
 230         return response;
 231     }
 232 
 233     @Override
 234     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 235             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 236         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 237     }
 238 
 239     @Override
 240     public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 241             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 241             Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedPrðŸ”µ</abbr>
<abbr title=" 242         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 242         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 243         FieldManager fieldManager = getFieldManager();
 244         boolean handled = false;
 245         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 246             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 246             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 247             if (MetadataProviderResponse.NOT_HANDLED != response) {
 248                 handled = true;
 249             }
 250             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 251                 break;
 252             }
 253         }
 254         if (!handled) {
<abbr title=" 255             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 255             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 256         }
<abbr title=" 257         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 257         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 258         Property[] sortedProperties = entity.getProperties();
 259         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 260 
 261             @Override
 262             public int compare(Property o1, Property o2) {
 263                 BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 264                 BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 265                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 265                 boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 266                         SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 267                         SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 268                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 268                         SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManageðŸ”µ</abbr>
<abbr title=" 269                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 269                 boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (ðŸ”µ</abbr>
 270                         SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 271                         SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 272                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 272                         SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManageðŸ”µ</abbr>
 273                 if (isLate1 &amp;&amp; !isLate2) {
 274                     return 1;
 275                 } else if (!isLate1 &amp;&amp; isLate2) {
 276                     return -1;
 277                 }
 278                 return 0;
 279             }
 280         });
<abbr title=" 281         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 281         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 282         FlushMode originalFlushMode = session.getHibernateFlushMode();
 283         try {
 284             session.setHibernateFlushMode(FlushMode.MANUAL);
 285             RuntimeException entityPersistenceException = null;
 286             for (Property property : sortedProperties) {
<abbr title=" 287                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());"> 287                 BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName(ðŸ”µ</abbr>
 288                 Class&lt;?&gt; returnType;
<abbr title=" 289                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 289                 if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().sðŸ”µ</abbr>
 290                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 291                     if (field == null) {
<abbr title=" 292                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 292                         LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtðŸ”µ</abbr>
 293                         continue;
 294                     }
 295                     returnType = field.getType();
 296                 } else {
 297                     if (metadata == null) {
<abbr title=" 298                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 298                         LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StriðŸ”µ</abbr>
 299                         continue;
 300                     }
 301                     returnType = getMapFieldType(instance, fieldManager, property);
 302                     if (returnType == null) {
 303                         returnType = getBasicBroadleafType(metadata.getFieldType());
 304                     }
 305                 }
 306                 if (returnType == null) {
<abbr title=" 307                     throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 307                     throw new IllegalAccessException(&quot;Unable to determine the value type for the propertyðŸ”µ</abbr>
 308                 }
 309                 String value = property.getValue();
 310                 if (metadata != null) {
 311 
 312                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 313                         if (value == null) {
 314                             String defaultValue = metadata.getDefaultValue();
 315                             value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;
 316                         }
 317                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 318                         if (StringUtils.isEmpty(value)) {
 319                             value = null;
 320                         }
 321                     }
 322 
<abbr title=" 323                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 323                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 324                         boolean isValid = true;
<abbr title=" 325                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 325                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 326                         handled = false;
 327                         if (value != null) {
 328                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 329                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 329                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 330                                 if (!validationResult.isValid()) {
<abbr title=" 331                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 331                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 332                                     isValid = false;
 333                                 }
 334                             }
 335                         }
 336                         if (isValid) {
 337                             try {
 338                                 boolean isBreakDetected = false;
<abbr title=" 339                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 339                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 340                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 340                                     if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (vaðŸ”µ</abbr>
<abbr title=" 341                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 341                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 342                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 343                                             handled = true;
 344                                         }
 345                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 346                                             isBreakDetected = true;
 347                                         }
 348                                     }
 349                                 }
 350                                 if (!handled) {
 351                                     if (value == null) {
 352                                         property.setIsDirty(true);
 353                                     }
<abbr title=" 354                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 354                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 355                                     if (value == null) {
 356                                         fieldManager.setFieldValue(instance, property.getName(), null);
 357                                     }
 358                                 }
<abbr title=" 359                             } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {"> 359                             } catch (ParentEntityPersistenceException | javax.validation.ValidationExceptðŸ”µ</abbr>
 360                                 entityPersistenceException = e;
 361                                 cleanupFailedPersistenceAttempt(instance);
 362                                 break;
 363                             }
 364                         }
 365                     }
 366                 }
 367             }
 368             // Only check validation if not the initial add
 369             if (!entity.isPreAdd()) {
 370                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 371             }
<abbr title=" 372             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 372             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 373             if (entity.isValidationFailure()) {
 374                 //only refresh the instance if it was managed to begin with
<abbr title=" 375                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 375                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 376                     persistenceManager.getDynamicEntityDao().refresh(instance);
 377                 }
 378 
<abbr title=" 379                 //re-initialize the valid properties for the entity in order to deal with the potential of not"> 379                 //re-initialize the valid properties for the entity in order to deal with the potential oðŸ”µ</abbr>
 380                 //completely sending over all checkbox/radio fields
 381                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 382                 entityList.add(instance);
 383                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 384                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 385                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 386                 invalid.overridePropertyValues(entity);
 387 
<abbr title=" 388                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 388                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 389                 throw new ValidationException(invalid, message);
 390             } else if (entityPersistenceException != null) {
 391                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 392             } else {
 393                 fieldManager.persistMiddleEntities();
 394             }
 395         } catch (IllegalAccessException e) {
 396             throw new PersistenceException(e);
 397         } catch (InstantiationException e) {
 398             throw new PersistenceException(e);
 399         } finally {
 400             session.setHibernateFlushMode(originalFlushMode);
 401         }
 402         return instance;
 403     }
 404 
<abbr title=" 405     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,"> 405     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
<abbr title=" 406                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 406                                              Boolean setId, BasicFieldMetadata metadata, Entity entity, SðŸ”µ</abbr>
 407         Boolean mutable = metadata.getMutable();
 408         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 409         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 409         boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp;ðŸ”µ</abbr>
 410 
 411         if (generalConditionsMet &amp;&amp; value == null) {
 412             boolean currentValueIsNotNull = false;
 413             try {
 414                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 415             } catch (FieldNotAvailableException e) {
 416                 throw new IllegalArgumentException(e);
 417             }
 418 
 419             boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 420             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 421 
 422             return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 423         }
 424         return generalConditionsMet;
 425     }
 426 
 427     @Override
<abbr title=" 428     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 428     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 429         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 430         records.add(record);
<abbr title=" 431         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 431         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 432         return productEntities[0];
 433     }
 434 
 435     @Override
<abbr title=" 436     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 436     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 437         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 437         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 438         return getRecord(mergedProperties, record, null, null);
 439     }
 440 
 441     @Override
<abbr title=" 442     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 442     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 443         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 443         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 444         return getRecords(mergedProperties, records, null, null, null);
 445     }
 446 
 447     @Override
<abbr title=" 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 448     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 449         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 449         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 450     }
 451 
 452     @Override
<abbr title=" 453     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 453     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 454         return getRecords(primaryMergedProperties, records, null, null, null);
 455     }
 456 
 457     @Override
 458     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 459                                List&lt;? extends Serializable&gt; records,
 460                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 461                                String pathToTargetObject) {
<abbr title=" 462         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 462         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 463     }
 464 
 465     @Override
 466     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 467                                List&lt;? extends Serializable&gt; records,
 468                                Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 469                                String pathToTargetObject,
 470                                String[] customCriteria) {
<abbr title=" 471         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 471         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 472         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 472         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 473         Entity[] entities = new Entity[records.size()];
 474         int j = 0;
 475         for (Serializable recordEntity : records) {
 476             Serializable entity;
 477             if (pathToTargetObject != null) {
 478                 try {
<abbr title=" 479                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);"> 479                     entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObjðŸ”µ</abbr>
 480                 } catch (Exception e) {
 481                     throw new PersistenceException(e);
 482                 }
 483             } else {
 484                 entity = recordEntity;
 485             }
 486             Entity entityItem = new Entity();
 487             entityItem.setType(new String[] { entity.getClass().getName() });
 488             entities[j] = entityItem;
 489 
 490             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 491             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 491             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 492             if (alternateMergedProperties != null) {
<abbr title=" 493                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 493                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 494             }
 495 
 496             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 497             try {
 498                 Property p = new Property();
 499                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
 500                 String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 501                 p.setValue(mainEntityName);
 502                 props.add(p);
 503             } catch (Exception e) {
 504                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 505                         entity.getClass().getName()), e);
 506             }
 507 
 508             // Try to add the alternate id property if available
 509             if (alternateMergedProperties != null) {
 510                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 511                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 512                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {"> 512                         if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ðŸ”µ</abbr>
<abbr title=" 513                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 513                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 514                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 515                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 516                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 516                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 517                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 518                             for (Property prop : props2) {
 519                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 520                                     filtered.add(prop);
 521                                 }
 522                             }
 523                             if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 524                                 Property alternateIdProp = filtered.get(0);
 525                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 526                                 props.add(alternateIdProp);
 527                             }
 528                         }
 529                     }
 530                 }
 531             }
 532 
 533             Property[] properties = new Property[props.size()];
 534             properties = props.toArray(properties);
 535             entityItem.setProperties(properties);
 536             j++;
 537         }
 538 
 539         return entities;
 540     }
 541 
 542     @Override
 543     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 544         return fetchWrapper.getRecords(fetchExtractionRequest);
 545     }
 546 
 547     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 548                                                          Serializable entity,
 549                                                          List&lt;Property&gt; props,
 550                                                          String[] customCriteria) {
 551         FieldManager fieldManager = getFieldManager();
 552         try {
 553             if (entity instanceof AdminMainEntity) {
 554                 //Create an invisible property for the admin main entity name, if applicable.
 555                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 556                 //its display name.
 557                 try {
 558                     Property propertyItem = new Property();
 559                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 560                     propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 561                     props.add(propertyItem);
 562                 } catch (Exception e) {
<abbr title=" 563                     //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 563                     //do nothing here except for not add the property. Exceptions could occur when there ðŸ”µ</abbr>
<abbr title=" 564                     //issue and some properties/relationships that are used for gleaning the main entity name end up"> 564                     //issue and some properties/relationships that are used for gleaning the main entity ðŸ”µ</abbr>
 565                     //not being set
 566                 }
 567             }
 568             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 569                 String property = entry.getKey();
 570                 BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 571                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 571                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 572                     boolean proceed = true;
 573                     if (property.contains(&quot;.&quot;)) {
 574                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 575                         Object testObject = entity;
 576                         while (tokens.hasMoreTokens()) {
 577                             String token = tokens.nextToken();
 578                             if (tokens.hasMoreTokens()) {
 579                                 try {
 580                                     testObject = fieldManager.getFieldValue(testObject, token);
 581                                 } catch (FieldNotAvailableException e) {
 582                                     proceed = false;
 583                                     break;
 584                                 }
 585                                 if (testObject == null) {
 586                                     Property propertyItem = new Property();
 587                                     propertyItem.setName(property);
 588                                     if (props.contains(propertyItem)) {
 589                                         proceed = false;
 590                                         break;
 591                                     }
 592                                     propertyItem.setValue(null);
 593                                     props.add(propertyItem);
 594                                     proceed = false;
 595                                     break;
 596                                 }
 597                             }
 598                         }
 599                     }
 600                     if (!proceed) {
 601                         continue;
 602                     }
 603 
 604                     boolean isFieldAccessible = true;
 605                     Object value = null;
 606                     try {
 607                         value = fieldManager.getFieldValue(entity, property);
 608                     } catch (FieldNotAvailableException e) {
 609                         isFieldAccessible = false;
 610                     }
 611                     checkField:
 612                     {
 613                         if (isFieldAccessible) {
 614                             Property propertyItem = new Property();
 615                             propertyItem.setName(property);
 616                             if (props.contains(propertyItem)) {
 617                                 continue;
 618                             }
 619                             props.add(propertyItem);
 620                             String displayVal = propertyItem.getDisplayValue();
 621                             boolean handled = false;
<abbr title=" 622                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 622                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 623                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue("> 623                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
<abbr title=" 624                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 624                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 625                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 625                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 626                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 627                                     handled = true;
 628                                 }
 629                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 630                                     break;
 631                                 }
 632                             }
 633                             if (!handled) {
 634                                 defaultFieldPersistenceProvider.extractValue(
<abbr title=" 635                                         new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,"> 635                                         new ExtractValueRequest(props, fieldManager, metadata, value, disðŸ”µ</abbr>
<abbr title=" 636                                                 persistenceManager, this, entity, customCriteria), propertyItem);"> 636                                                 persistenceManager, this, entity, customCriteria), properðŸ”µ</abbr>
 637                             }
 638                             break checkField;
 639                         }
 640                         //try a direct property acquisition via reflection
 641                         try {
 642                             String strVal = null;
 643                             Method method;
 644                             try {
 645                                 //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 646                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 646                                 String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.sðŸ”µ</abbr>
 647                                 method = entity.getClass().getMethod(temp, new Class[] {});
 648                             } catch (NoSuchMethodException e) {
 649                                 method = entity.getClass().getMethod(property, new Class[] {});
 650                             }
 651                             value = method.invoke(entity, new String[] {});
 652                             Property propertyItem = new Property();
 653                             propertyItem.setName(property);
 654                             if (props.contains(propertyItem)) {
 655                                 continue;
 656                             }
 657                             props.add(propertyItem);
 658                             if (value == null) {
 659                                 strVal = null;
 660                             } else {
 661                                 if (Date.class.isAssignableFrom(value.getClass())) {
 662                                     strVal = getSimpleDateFormatter().format((Date) value);
 663                                 } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 664                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 664                                     strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value)ðŸ”µ</abbr>
 665                                 } else if (Calendar.class.isAssignableFrom(value.getClass())) {
<abbr title=" 666                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());"> 666                                     strVal = getSimpleDateFormatter().format(((Calendar) value).getTime()ðŸ”µ</abbr>
 667                                 } else if (Double.class.isAssignableFrom(value.getClass())) {
 668                                     strVal = getDecimalFormatter().format(value);
 669                                 } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 670                                     strVal = getDecimalFormatter().format(value);
 671                                 } else {
 672                                     strVal = value.toString();
 673                                 }
 674                             }
 675                             propertyItem.setValue(strVal);
 676                         } catch (NoSuchMethodException e) {
<abbr title=" 677                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 677                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 678                             //do nothing - this property is simply not in the bean
 679                         }
 680                     }
 681                 }
 682             }
 683         } catch (ClassNotFoundException e) {
 684             throw new PersistenceException(e);
 685         } catch (IllegalAccessException e) {
 686             throw new PersistenceException(e);
 687         } catch (InvocationTargetException e) {
 688             throw new PersistenceException(e);
 689         }
 690     }
 691 
 692     @Override
 693     public String getStringValueFromGetter(Serializable instance, String propertyName)
 694             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 695         Object value = PropertyUtils.getProperty(instance, propertyName);
 696         return formatValue(value);
 697     }
 698 
 699     @Override
 700     public String formatValue(Object value) {
 701         String strVal;
 702         if (value == null) {
 703             strVal = null;
 704         } else {
 705             if (Date.class.isAssignableFrom(value.getClass())) {
 706                 strVal = getSimpleDateFormatter().format((Date) value);
 707             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 708                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 709             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 710                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 711             } else if (Double.class.isAssignableFrom(value.getClass())) {
 712                 strVal = getDecimalFormatter().format(value);
 713             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 714                 strVal = getDecimalFormatter().format(value);
 715             } else {
 716                 strVal = value.toString();
 717             }
 718         }
 719         return strVal;
 720     }
 721 
<abbr title=" 722     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 722     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 723         EntityResult entityResult = new EntityResult();
 724         Entity entity = persistencePackage.getEntity();
 725         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 726         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 726         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 727         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 728             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 729         }
 730         try {
<abbr title=" 731             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 731             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 732             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 732             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 733                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 734                     entities,
 735                     foreignKey,
 736                     persistencePerspective.getAdditionalNonPersistentProperties(),
 737                     persistencePerspective.getAdditionalForeignKeys(),
 738                     MergedPropertyType.PRIMARY,
 739                     persistencePerspective.getPopulateToOneFields(),
 740                     persistencePerspective.getIncludeFields(),
 741                     persistencePerspective.getExcludeFields(),
 742                     persistencePerspective.getConfigurationKey(),
 743                     &quot;&quot;
 744                     );
 745             if (primaryKey == null) {
 746                 primaryKey = getPrimaryKey(entity, mergedProperties);
 747             }
<abbr title=" 748             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 748             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 749 
 750             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 751 
 752             if (!entity.isValidationFailure()) {
 753                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 754                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 755                         entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 756                         entity.findProperty(foreignKey.getSortField()).getValue() != null) {
<abbr title=" 757                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 757                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
 758                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 759                             mergedProperties, primaryKey, result);
 760                     instance = result.getResult();
 761                 } else {
<abbr title=" 762                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 762                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 763                 }
 764 
 765                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 766                 if (includeRealEntity) {
 767                     entityResult.setEntityBackingObject(instance);
 768                 }
 769 
 770                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 771                 entityList.add(instance);
 772 
 773                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 774                 entityResult.setEntity(entity);
 775                 return entityResult;
 776             } else {
 777                 entityResult.setEntity(entity);
 778                 return entityResult;
 779             }
 780         } catch (Exception e) {
 781             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 782         }
 783     }
 784 
 785     @Override
 786     public String getIdPropertyName(String entityClass) {
 787         return persistenceManager.getIdPropertyName(entityClass);
 788     }
 789 
 790     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 791         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 791         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 792         for (String property : mergedProperties.keySet()) {
 793             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 794             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 795                 return property;
 796             }
 797         }
 798 
<abbr title=" 799         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 799         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 800     }
 801 
 802     @Override
 803     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 804         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 804         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 805         Object primaryKey = null;
 806         String idPropertyName = null;
 807         BasicFieldMetadata metaData = null;
 808         for (String property : mergedProperties.keySet()) {
 809             BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 810             if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 811                 idPropertyName = property;
 812                 metaData = temp;
 813                 break;
 814             }
 815         }
 816         if (idPropertyName == null) {
<abbr title=" 817             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 817             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 818         }
 819         for (Property property : entity.getProperties()) {
 820             if (property.getName().equals(idPropertyName)) {
 821                 switch (metaData.getSecondaryType()) {
 822                     case INTEGER:
<abbr title=" 823                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 823                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 824                         break;
 825                     case STRING:
 826                         primaryKey = property.getValue();
 827                         break;
 828                 }
 829                 break;
 830             }
 831         }
 832         if (primaryKey == null) {
<abbr title=" 833             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 833             throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) ðŸ”µ</abbr>
 834         }
 835         return primaryKey;
 836     }
 837 
 838     @Override
 839     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 840             CriteriaTransferObject cto,
 841             String ceilingEntityFullyQualifiedClassname,
 842             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 843             RestrictionFactory customRestrictionFactory) {
<abbr title=" 844         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 844         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 845         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 846 
 847         for (String propertyId : cto.getCriteriaMap().keySet()) {
 848             if (mergedProperties.containsKey(propertyId)) {
 849                 boolean handled = false;
 850                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 851                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 852                             new AddSearchMappingRequest(persistencePerspective, cto,
 853                                     ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 854                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 854                                     propertyId, getFieldManager(), this, this, customRestrictionFactory==ðŸ”µ</abbr>
 855                                     :customRestrictionFactory), filterMappings);
 856                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 857                         handled = true;
 858                     }
 859                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 860                         break;
 861                     }
 862                 }
 863                 if (!handled) {
 864                     defaultFieldPersistenceProvider.addSearchMapping(
 865                             new AddSearchMappingRequest(persistencePerspective, cto,
 866                                     ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 867                                     getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 867                                     getFieldManager(), this, this, customRestrictionFactory == null ? resðŸ”µ</abbr>
 868                                             : customRestrictionFactory), filterMappings);
 869                 }
 870             }
 871         }
 872         return filterMappings;
 873     }
 874 
 875     @Override
 876     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 877             CriteriaTransferObject cto,
 878             String ceilingEntityFullyQualifiedClassname,
 879             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 880         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 880         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
 881     }
 882 
 883     @Override
<abbr title=" 884     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 884     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 885         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 885         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
 886     }
 887 
<abbr title=" 888     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 888     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
 889             Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 890 
 891                 @Override
 892                 public int compare(Property o1, Property o2) {
 893                     return o1.getName().compareTo(o2.getName());
 894                 }
 895             };
 896 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 897         properties.sort(comparator);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 898 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 899         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 900             String property = entry.getKey();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 901             Property prop = new Property();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 902             FieldMetadata metadata = mergedProperties.get(property);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 903             prop.setName(property);</span>
 904 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 905                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 906                 public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 907                     return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 908                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 909             };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 910             Collections.sort(properties, comparator);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 911             int pos = Collections.binarySearch(properties, prop, comparator);</span>
 912 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 913         Collections.sort(properties, comparator);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 914         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 915             String property = entry.getKey();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 916             Property prop = new Property();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 917             FieldMetadata metadata = mergedProperties.get(property);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 918             prop.setName(property);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 919 </span>
 920 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 921             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 922             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 922             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREðŸ”µ</abbr>
 923                 logWarn: {
<abbr title=" 924                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 924                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
 925                         //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 926                         break logWarn;
 927                     }
<abbr title=" 928                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 928                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
 929                 }
 930                 continue;
 931             } else if (pos &lt; 0) {
 932                 pos = -pos - 1; // calculate position to insert
 933             }
 934             properties.add(pos, prop);
 935             prop.setMetadata(metadata);
 936             if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 937                 //this only makes sense for non collection types
 938                 ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 939             }
 940         }
 941     }
 942 
 943     @Override
<abbr title=" 944     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 944     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title=" 945         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 945         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 946         try {
<abbr title=" 947             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 947             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 948             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);"> 948             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title=" 949             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 949             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 950                     ceilingEntityFullyQualifiedClassname,
 951                     entities,
<abbr title=" 952                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 952                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 953                     persistencePerspective.getAdditionalNonPersistentProperties(),
 954                     persistencePerspective.getAdditionalForeignKeys(),
 955                     MergedPropertyType.PRIMARY,
 956                     persistencePerspective.getPopulateToOneFields(),
 957                     persistencePerspective.getIncludeFields(),
 958                     persistencePerspective.getExcludeFields(),
 959                     persistencePerspective.getConfigurationKey(),
 960                     &quot;&quot;
 961                     );
 962             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 963         } catch (Exception e) {
<abbr title=" 964             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);"> 964             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
 965         }
 966     }
 967 
 968     @Override
<abbr title=" 969     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 969     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
 970         return update(persistencePackage, null, true);
 971     }
 972 
 973     @Override
 974     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 975         EntityResult er = update(persistencePackage, null, false);
 976         return er.getEntity();
 977     }
 978 
 979     @Override
 980     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
 981         EntityResult entityResult = add(persistencePackage, false);
 982         return entityResult.getEntity();
 983     }
 984 
 985     @Override
<abbr title=" 986     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 986     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
 987         EntityResult entityResult = new EntityResult();
 988         Entity entity = persistencePackage.getEntity();
 989         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 990         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 990         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
 991         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 992             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 993         }
 994         try {
<abbr title=" 995             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 995             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 996             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 996             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
 997                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 998                     entities,
 999                     foreignKey,
1000                     persistencePerspective.getAdditionalNonPersistentProperties(),
1001                     persistencePerspective.getAdditionalForeignKeys(),
1002                     MergedPropertyType.PRIMARY,
1003                     persistencePerspective.getPopulateToOneFields(),
1004                     persistencePerspective.getIncludeFields(),
1005                     persistencePerspective.getExcludeFields(),
1006                     persistencePerspective.getConfigurationKey(),
1007                     &quot;&quot;
1008                     );
<abbr title="1009             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1009             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1010 
1011             String idProperty = null;
1012             for (String property : mergedProperties.keySet()) {
<abbr title="1013                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1013                 if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFielðŸ”µ</abbr>
1014                     idProperty = property;
1015                     break;
1016                 }
1017             }
1018             if (idProperty == null) {
<abbr title="1019                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1019                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
1020             }
1021             Object primaryKey = null;
1022             try {
1023                 primaryKey = getPrimaryKey(entity, mergedProperties);
1024             } catch (Exception e) {
1025                 //don&#x27;t do anything - this is a valid case
1026             }
1027             if (primaryKey == null) {
1028 
1029                 Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1030 
1031                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1032 
1033                 if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
<abbr title="1034                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();">1034                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title="1035                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1035                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
1036                     instance = result.getResult();
1037                 }
1038 
1039                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
1040                 if (includeRealEntityObject) {
1041                     entityResult.setEntityBackingObject(instance);
1042                 }
1043                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1044                 entityList.add(instance);
1045 
1046                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1047                 entityResult.setEntity(entity);
1048                 return entityResult;
1049             } else {
1050                 return update(persistencePackage, primaryKey, includeRealEntityObject);
1051             }
1052         } catch (Exception e) {
1053             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1054         }
1055     }
1056 
1057     @Override
1058     public void remove(PersistencePackage persistencePackage) throws ServiceException {
1059         Entity entity = persistencePackage.getEntity();
1060         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1061         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1061         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1062         if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1063             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1064         }
1065         try {
<abbr title="1066             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1066             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title="1067             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1067             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
1068                     persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1069                     entities,
1070                     foreignKey,
1071                     persistencePerspective.getAdditionalNonPersistentProperties(),
1072                     persistencePerspective.getAdditionalForeignKeys(),
1073                     MergedPropertyType.PRIMARY,
1074                     persistencePerspective.getPopulateToOneFields(),
1075                     persistencePerspective.getIncludeFields(),
1076                     persistencePerspective.getExcludeFields(),
1077                     persistencePerspective.getConfigurationKey(),
1078                     &quot;&quot;
1079                     );
<abbr title="1080             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);">1080             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
1081             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1082             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1082             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
1083 
1084             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1085 
1086             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1087                 case NONDESTRUCTIVEREMOVE:
1088                     FieldManager fieldManager = getFieldManager();
<abbr title="1089                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1089                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title="1090                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();">1090                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
1091                     try {
1092                         foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1093                     } catch (NumberFormatException e) {
<abbr title="1094                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);">1094                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
1095                     }
<abbr title="1096                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1096                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title="1097                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1097                     Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreðŸ”µ</abbr>
1098                     collection.remove(instance);
<abbr title="1099                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1099                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title="1100                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly">1100                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
1101                     // set the manyTo field to null so that subsequent lookups will not find it
1102                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1103                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {">1103                         if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())ðŸ”µ</abbr>
<abbr title="1104                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1104                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
<abbr title="1105                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1105                                     + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in tðŸ”µ</abbr>
1106                                     + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1107                         }
<abbr title="1108                         //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1108                         //Since this is occuring on a remove persistence package, merge up-front (before ðŸ”µ</abbr>
1109                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1110                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1110                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
1111                         Object manyToObject = manyToField.get(instance);
<abbr title="1112                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1112                         if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObjeðŸ”µ</abbr>
1113                             manyToField.set(instance, null);
1114                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
1115                         }
1116                     }
1117                     break;
1118                 case BASIC:
1119                     persistenceManager.getDynamicEntityDao().remove(instance);
1120                     break;
1121             }
1122         } catch (Exception e) {
1123             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1124         }
1125     }
1126 
1127     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1128             CriteriaTransferObject cto) throws ServiceException {
1129         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1130         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1130         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1131 
1132         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1133             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1134         }
1135 
1136         try {
<abbr title="1137             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1137             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1138 
<abbr title="1139             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1139             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1140                     ceilingEntityFullyQualifiedClassname,
1141                     entities,
<abbr title="1142                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1142                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
1143                     persistencePerspective.getAdditionalNonPersistentProperties(),
1144                     persistencePerspective.getAdditionalForeignKeys(),
1145                     MergedPropertyType.PRIMARY,
1146                     persistencePerspective.getPopulateToOneFields(),
1147                     persistencePerspective.getIncludeFields(),
1148                     persistencePerspective.getExcludeFields(),
1149                     persistencePerspective.getConfigurationKey(),
1150                     &quot;&quot;
1151                     );
1152 
1153             return mergedProperties;
1154         } catch (Exception e) {
<abbr title="1155             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1155             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1156         }
1157     }
1158 
1159     @Override
<abbr title="1160     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1160     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1161         Entity[] payload;
1162         int totalRecords;
1163         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1164         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1164         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1165         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1165         ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(ðŸ”µ</abbr>
1166 
1167         try {
1168             if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1169                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1170                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1171             }
1172 
1173             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1174 
<abbr title="1175             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage">1175             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1176                     .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1177             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1178             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1179                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1180             }
1181             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1182                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1183             }
1184 
1185             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1186                     persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1187             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1188 
1189             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1190             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1191                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1192             }
1193             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1194                     persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1195             totalRecords = getTotalRecords(countFetchRequest);
1196 
<abbr title="1197             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,">1197             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1198                     persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1199             payload = getRecords(fetchExtractionRequest);
1200         } catch (Exception e) {
<abbr title="1201             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1201             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1202         }
1203 
1204         return new DynamicResultSet(null, payload, totalRecords);
1205     }
1206 
1207     @Override
1208     public Integer getTotalRecords(FetchRequest fetchRequest) {
1209         return fetchWrapper.getTotalRecords(fetchRequest);
1210     }
1211 
1212     @Override
1213     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1214         try {
<abbr title="1215             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),">1215             return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(ðŸ”µ</abbr>
1216                     ceilingEntity, filterMappings).getSingleResult()).intValue();
1217         } catch (CriteriaConversionException e) {
<abbr title="1218             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1218             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1219             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1219             return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardðŸ”µ</abbr>
1220         }
1221     }
1222 
1223     @Override
<abbr title="1224     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1224     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
1225         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1226                 ceilingEntity, filterMappings, maxField).getSingleResult();
1227     }
1228 
1229     @Override
1230     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1231         return fetchWrapper.getPersistentRecords(fetchRequest);
1232     }
1233 
1234     @Override
<abbr title="1235     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1235     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1236         try {
<abbr title="1237             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1237             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1238         } catch (CriteriaConversionException e) {
<abbr title="1239             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1239             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1240             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1240             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1241         }
1242     }
1243 
1244     @Override
<abbr title="1245     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1245     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1246         return validate(entity, populatedInstance, mergedProperties, true);
1247     }
1248 
1249     @Override
<abbr title="1250     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1250     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1251             boolean validateUnsubmittedProperties) {
<abbr title="1252         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1252         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1253         return !entity.isValidationFailure();
1254     }
1255 
1256     @Override
1257     public void setPersistenceManager(PersistenceManager persistenceManager) {
1258         this.persistenceManager = persistenceManager;
1259     }
1260 
1261     @Override
1262     public PersistenceModule getCompatibleModule(OperationType operationType) {
1263         return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1264     }
1265 
1266     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1267         return defaultFieldPersistenceProvider;
1268     }
1269 
<abbr title="1270     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1270     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1271         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1272     }
1273 
1274     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1275         return fieldPersistenceProviders;
1276     }
1277 
1278     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1279         this.fieldPersistenceProviders = fieldPersistenceProviders;
1280     }
1281 
1282     public CriteriaTranslator getCriteriaTranslator() {
1283         return criteriaTranslator;
1284     }
1285 
1286     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1287         this.criteriaTranslator = criteriaTranslator;
1288     }
1289 
1290     public EntityValidatorService getEntityValidatorService() {
1291         return entityValidatorService;
1292     }
1293 
1294     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1295         this.entityValidatorService = entityValidatorService;
1296     }
1297 
1298     public RestrictionFactory getRestrictionFactory() {
1299         return restrictionFactory;
1300     }
1301 
1302     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1303         this.restrictionFactory = restrictionFactory;
1304     }
1305 
1306     public PersistenceManager getPersistenceManager() {
1307         return persistenceManager;
1308     }
1309 
1310     /**
<abbr title="1311      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1311      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1312      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1312      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1313      * which seems to alleviate the problem.
1314      *
1315      * @param embeddedCollectionPath the path to the collection field itself
1316      * @param filterMappings all the fetch restrictions for this request
1317      * @param collectionClass the type of the collection members
1318      * @return the builder capable of generating an appropriate HQL query
1319      */
<abbr title="1320     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1320     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1321         String specialPath = embeddedCollectionPath.getTargetProperty();
1322         String[] pieces = specialPath.split(&quot;\\.&quot;);
1323         if (pieces.length != 3) {
<abbr title="1324             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1324             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1325         }
1326         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1327         TypedQueryBuilder builder;
1328         try {
1329             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1330                     .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1331         } catch (Exception e) {
1332             throw ExceptionHelper.refineException(e);
1333         }
1334         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1335             builder = builder.addRestriction(restriction);
1336         }
<abbr title="1337         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1337         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1338             builder = builder.addRestriction(restriction);
1339         }
1340         for (FilterMapping mapping : filterMappings) {
1341             if (mapping.getSortDirection() != null) {
<abbr title="1342                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1342                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1343                 if (StringUtils.isEmpty(mappingProperty)) {
1344                     mappingProperty = mapping.getFullPropertyName();
1345                 }
<abbr title="1346                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1346                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1347             }
1348         }
1349 
1350         return builder;
1351     }
1352 
1353     /**
<abbr title="1354      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1354      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1355      *
<abbr title="1356      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1356      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1357      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1357      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1358      * @param filterMappings all the fetch restrictions for this request
1359      * @return the list of restrictions on the root entity
1360      */
<abbr title="1361     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1361     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1362         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1362         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1363         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1364         for (FilterMapping mapping : filterMappings) {
1365             checkProperty: {
<abbr title="1366                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1366                 String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().gðŸ”µ</abbr>
1367                 if (StringUtils.isEmpty(mappingProperty)) {
1368                     mappingProperty = mapping.getFullPropertyName();
1369                 }
<abbr title="1370                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1370                 if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.iðŸ”µ</abbr>
<abbr title="1371                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1371                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1372                     if (predicateProvider != null) {
<abbr title="1373                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1373                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
1374                         if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1375                             Object val = converter.convert(mapping.getFilterValues().get(0));
1376                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1377                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1377                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1378                                 break checkProperty;
1379                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1380                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1380                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1381                                 break checkProperty;
1382                             }
1383                         }
1384                     }
<abbr title="1385                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1385                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1386                             StringUtil.sanitize(expression),
1387                             StringUtil.sanitize(mappingProperty)));
1388                 }
1389             }
1390         }
1391 
1392         return restrictions;
1393     }
1394 
1395     /**
<abbr title="1396      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1396      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1397      *
<abbr title="1398      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1398      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1399      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1399      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1400      * @param filterMappings all the fetch restrictions for this request
1401      * @return the list of restrictions on the collection in the @Embeddable object
1402      */
<abbr title="1403     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1403     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1404         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1405         for (FilterMapping mapping : filterMappings) {
<abbr title="1406             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1406             if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mðŸ”µ</abbr>
1407                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1408                 if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1409                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1410                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1410                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1411                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1412                 }
1413             }
1414         }
1415         return restrictions;
1416     }
1417 
1418     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1419         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1420         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1420         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1421             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1422         }
1423         //Remove the id field value, if it&#x27;s set
<abbr title="1424         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1424         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1425         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1426         if (idField == null) {
<abbr title="1427             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1427             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1428         }
1429         idField.setAccessible(true);
1430         if (idField.get(instance) != null) {
1431             idField.set(instance, null);
1432         }
1433     }
1434 
<abbr title="1435     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1435     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1436         Class&lt;?&gt; returnType = null;
<abbr title="1437         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1437         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1438         java.lang.reflect.Type type = field.getGenericType();
1439         if (type instanceof ParameterizedType) {
1440             ParameterizedType pType = (ParameterizedType) type;
1441             Class&lt;?&gt; clazz;
1442             if (pType.getActualTypeArguments().length &lt; 2) {
1443                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1444             } else {
1445                 clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1446             }
<abbr title="1447             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1447             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1448             if (!ArrayUtils.isEmpty(entities)) {
1449                 returnType = entities[entities.length - 1];
1450             }
1451         }
1452         return returnType;
1453     }
1454 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.service.persistence.module;
  19 
  20 import java.io.Serializable;
  21 import java.lang.reflect.Field;
  22 import java.lang.reflect.InvocationTargetException;
  23 import java.lang.reflect.Method;
  24 import java.lang.reflect.ParameterizedType;
  25 import java.math.BigDecimal;
  26 import java.sql.Timestamp;
  27 import java.text.DecimalFormat;
  28 import java.text.NumberFormat;
  29 import java.text.SimpleDateFormat;
  30 import java.util.*;
  31 import java.util.Map.Entry;
  32 import javax.annotation.PostConstruct;
  33 import javax.annotation.Resource;
  34 import org.apache.commons.beanutils.PropertyUtils;
  35 import org.apache.commons.collections.CollectionUtils;
  36 import org.apache.commons.lang.ArrayUtils;
  37 import org.apache.commons.lang.StringUtils;
  38 import org.apache.commons.lang3.BooleanUtils;
  39 import org.apache.commons.lang3.reflect.FieldUtils;
  40 import org.apache.commons.lang3.reflect.MethodUtils;
  41 import org.apache.commons.logging.Log;
  42 import org.apache.commons.logging.LogFactory;
  43 import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  44 import org.broadleafcommerce.common.exception.ExceptionHelper;
  45 import org.broadleafcommerce.common.exception.SecurityServiceException;
  46 import org.broadleafcommerce.common.exception.ServiceException;
  47 import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  48 import org.broadleafcommerce.common.money.Money;
  49 import org.broadleafcommerce.common.presentation.client.OperationType;
  50 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  51 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  52 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  53 import org.broadleafcommerce.common.util.FormatUtil;
  54 import org.broadleafcommerce.common.util.StringUtil;
  55 import org.broadleafcommerce.common.util.ValidationUtil;
  56 import org.broadleafcommerce.common.util.dao.TQJoin;
  57 import org.broadleafcommerce.common.util.dao.TQOrder;
  58 import org.broadleafcommerce.common.util.dao.TQRestriction;
  59 import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  60 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  61 import org.broadleafcommerce.openadmin.dto.*;
<abbr title="  62 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;">  62 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvidðŸ”µ</abbr>
  63 import org.broadleafcommerce.openadmin.server.service.ValidationException;
  64 import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  65 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  66 import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  67 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;
<abbr title="  68 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;">  68 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueCoðŸ”µ</abbr>
<abbr title="  69 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;">  69 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicatePrðŸ”µ</abbr>
<abbr title="  70 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;">  70 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateðŸ”µ</abbr>
<abbr title="  71 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;">  71 import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvðŸ”µ</abbr>
<abbr title="  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  72 import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleðŸ”µ</abbr>
<abbr title="  73 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;">  73 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvideðŸ”µ</abbr>
<abbr title="  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  74 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterProperðŸ”µ</abbr>
<abbr title="  75 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;">  75 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappinðŸ”µ</abbr>
<abbr title="  76 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;">  76 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueReqðŸ”µ</abbr>
<abbr title="  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;">  77 import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueReðŸ”µ</abbr>
  78 import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
<abbr title="  79 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;">  79 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidatoðŸ”µ</abbr>
  80 import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  81 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  82 import org.hibernate.FlushMode;
  83 import org.hibernate.Session;
  84 import org.springframework.beans.BeansException;
  85 import org.springframework.context.ApplicationContext;
  86 import org.springframework.context.ApplicationContextAware;
  87 import org.springframework.context.annotation.Primary;
  88 import org.springframework.context.annotation.Scope;
  89 import org.springframework.stereotype.Component;
  90 import org.springframework.util.Assert;
  91 
  92 
  93 /**
  94  * @author jfischer
  95  */
  96 @Primary
  97 @Component(&quot;blBasicPersistenceModule&quot;)
  98 @Scope(&quot;prototype&quot;)
<abbr title="  99 public class BasicPersistenceModule implements PersistenceModule , RecordHelper , ApplicationContextAware {">  99 public class BasicPersistenceModule implements PersistenceModule , RecordHelper , ApplicationContextAwareðŸ”µ</abbr>
 100     private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 101 
 102     public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 103 
 104     public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 105 
 106     protected ApplicationContext applicationContext;
 107 
 108     protected PersistenceManager persistenceManager;
 109 
 110     @Resource(name = &quot;blEntityValidatorService&quot;)
 111     protected EntityValidatorService entityValidatorService;
 112 
 113     @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 114     protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistencePrðŸ”µ</abbr>
 115 
 116     @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 117     protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 118 
 119     @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 120     protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 121 
 122     @Resource(name = &quot;blCriteriaTranslator&quot;)
 123     protected CriteriaTranslator criteriaTranslator;
 124 
 125     @Resource(name = &quot;blRestrictionFactory&quot;)
 126     protected RestrictionFactory restrictionFactory;
 127 
 128     @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 129     protected BasicPersistenceModuleExtensionManager extensionManager;
 130 
 131     @Resource(name = &quot;blFetchWrapper&quot;)
 132     protected FetchWrapper fetchWrapper;
 133 
 134     @PostConstruct
 135     public void init() {
 136         Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 137 
 138             @Override
 139             public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 140                 return Integer.compare(o1.getOrder(), o2.getOrder());
 141             }
 142         });
 143         Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 144 
 145             @Override
 146             public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 147                 return Integer.compare(o1.getOrder(), o2.getOrder());
 148             }
 149         });
 150     }
 151 
 152     @Override
 153     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 154         this.applicationContext = applicationContext;
 155     }
 156 
 157     @Override
 158     public boolean isCompatible(OperationType operationType) {
<abbr title=" 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;"> 159         return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationTypðŸ”µ</abbr>
 160     }
 161 
 162     @Override
 163     public FieldManager getFieldManager() {
 164         return persistenceManager.getDynamicEntityDao().getFieldManager();
 165     }
 166 
 167     @Override
 168     public DecimalFormat getDecimalFormatter() {
 169         BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 170         Locale locale = brc.getJavaLocale();
 171         DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 172         format.applyPattern(&quot;0.########&quot;);
 173         format.setGroupingUsed(false);
 174         return format;
 175     }
 176 
 177     @Override
 178     public SimpleDateFormat getSimpleDateFormatter() {
 179         return FormatUtil.getDateFormat();
 180     }
 181 
<abbr title=" 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {"> 182     protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata)ðŸ”µ</abbr>
 183         if (metadata == null) {
 184             return null;
 185         }
 186         Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 187         for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 188             String fieldName = entry.getKey();
 189             FieldMetadata md = entry.getValue();
<abbr title=" 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 190             // Detect instances where the actual metadata for the field is some sort of CollectionMetadatðŸ”µ</abbr>
<abbr title=" 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 191             // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasðŸ”µ</abbr>
 192             // can appropriate handle filtration and population
 193             if (entry.getValue() instanceof BasicFieldMetadata) {
 194                 newMap.put(fieldName, md);
<abbr title=" 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 195             } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FORðŸ”µ</abbr>
<abbr title=" 196                 newMap.put(fieldName, ((BasicFieldMetadata) (md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY))));"> 196                 newMap.put(fieldName, ((BasicFieldMetadata) (md.getAdditionalMetadata().get(AdvancedColleðŸ”µ</abbr>
 197             }
 198         }
 199         return newMap;
 200     }
 201 
 202     protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 203         Class&lt;?&gt; response;
 204         switch (fieldType) {
 205             case BOOLEAN:
 206                 response = Boolean.TYPE;
 207                 break;
 208             case DATE:
 209                 response = Date.class;
 210                 break;
 211             case DECIMAL:
 212                 response = BigDecimal.class;
 213                 break;
 214             case MONEY:
 215                 response = Money.class;
 216                 break;
 217             case INTEGER:
 218                 response = Integer.TYPE;
 219                 break;
 220             case UNKNOWN:
 221                 response = null;
 222                 break;
 223             default:
 224                 response = String.class;
 225                 break;
 226         }
 227 
 228         return response;
 229     }
 230 
 231     @Override
<abbr title=" 232     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {"> 232     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMeðŸ”µ</abbr>
 233         return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 234     }
 235 
 236     @Override
<abbr title=" 237     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 237     public Serializable createPopulatedInstance(Serializable instance, Entity entity, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 238         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);"> 238         final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredPropertðŸ”µ</abbr>
 239         FieldManager fieldManager = getFieldManager();
 240         boolean handled = false;
 241         for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 242             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 242             MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPrðŸ”µ</abbr>
 243             if (MetadataProviderResponse.NOT_HANDLED != response) {
 244                 handled = true;
 245             }
 246             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 247                 break;
 248             }
 249         }
 250         if (!handled) {
<abbr title=" 251             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 251             defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfiðŸ”µ</abbr>
 252         }
<abbr title=" 253         //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 253         //Order media field, map field and rule builder fields last, as they will have some validation coðŸ”µ</abbr>
 254         Property[] sortedProperties = entity.getProperties();
 255         Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 256             @Override
 257             public int compare(Property o1, Property o2) {
 258                 BasicFieldMetadata mo1 = ((BasicFieldMetadata) (mergedProperties.get(o1.getName())));
 259                 BasicFieldMetadata mo2 = ((BasicFieldMetadata) (mergedProperties.get(o2.getName())));
<abbr title=" 260                 boolean isLate1 = (((mo1 != null) &amp;&amp; (mo1.getFieldType() != null)) &amp;&amp; (mo1.getName() != null)) &amp;&amp; (((((SupportedFieldType.RULE_SIMPLE == mo1.getFieldType()) || (SupportedFieldType.RULE_WITH_QUANTITY == mo1.getFieldType())) || (SupportedFieldType.RULE_SIMPLE_TIME == mo1.getFieldType())) || (SupportedFieldType.MEDIA == mo1.getFieldType())) || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 260                 boolean isLate1 = (((mo1 != null) &amp;&amp; (mo1.getFieldType() != null)) &amp;&amp; (mo1.getName() != nðŸ”µ</abbr>
<abbr title=" 261                 boolean isLate2 = (((mo2 != null) &amp;&amp; (mo2.getFieldType() != null)) &amp;&amp; (mo2.getName() != null)) &amp;&amp; (((((SupportedFieldType.RULE_SIMPLE == mo2.getFieldType()) || (SupportedFieldType.RULE_WITH_QUANTITY == mo2.getFieldType())) || (SupportedFieldType.RULE_SIMPLE_TIME == mo2.getFieldType())) || (SupportedFieldType.MEDIA == mo2.getFieldType())) || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 261                 boolean isLate2 = (((mo2 != null) &amp;&amp; (mo2.getFieldType() != null)) &amp;&amp; (mo2.getName() != nðŸ”µ</abbr>
 262                 if (isLate1 &amp;&amp; (!isLate2)) {
 263                     return 1;
 264                 } else if ((!isLate1) &amp;&amp; isLate2) {
 265                     return -1;
 266                 }
 267                 return 0;
 268             }
 269         });
<abbr title=" 270         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 270         Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrapðŸ”µ</abbr>
 271         FlushMode originalFlushMode = session.getHibernateFlushMode();
 272         try {
 273             session.setHibernateFlushMode(FlushMode.MANUAL);
 274             RuntimeException entityPersistenceException = null;
 275             for (Property property : sortedProperties) {
<abbr title=" 276                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (mergedProperties.get(property.getName())));"> 276                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (mergedProperties.get(property.getNamðŸ”µ</abbr>
 277                 Class&lt;?&gt; returnType;
<abbr title=" 278                 if ((!property.getName().contains(FieldManager.MAPFIELDSEPARATOR)) &amp;&amp; (!property.getName().startsWith(&quot;__&quot;))) {"> 278                 if ((!property.getName().contains(FieldManager.MAPFIELDSEPARATOR)) &amp;&amp; (!property.getName(ðŸ”µ</abbr>
 279                     Field field = fieldManager.getField(instance.getClass(), property.getName());
 280                     if (field == null) {
<abbr title=" 281                         LOG.debug((&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName())) + &quot;. Ignoring property.&quot;);"> 281                         LOG.debug((&quot;Unable to find a bean property for the reported property: &quot; + StringUðŸ”µ</abbr>
 282                         continue;
 283                     }
 284                     returnType = field.getType();
 285                 } else {
 286                     if (metadata == null) {
<abbr title=" 287                         LOG.debug((&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName())) + &quot;. Ignoring property.&quot;);"> 287                         LOG.debug((&quot;Unable to find a metadata property for the reported property: &quot; + StrðŸ”µ</abbr>
 288                         continue;
 289                     }
 290                     returnType = getMapFieldType(instance, fieldManager, property);
 291                     if (returnType == null) {
 292                         returnType = getBasicBroadleafType(metadata.getFieldType());
 293                     }
 294                 }
 295                 if (returnType == null) {
<abbr title=" 296                     throw new IllegalAccessException((&quot;Unable to determine the value type for the property (&quot; + property.getName()) + &quot;)&quot;);"> 296                     throw new IllegalAccessException((&quot;Unable to determine the value type for the propertðŸ”µ</abbr>
 297                 }
 298                 String value = property.getValue();
 299                 if (metadata != null) {
 300                     if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 301                         if (value == null) {
 302                             String defaultValue = metadata.getDefaultValue();
 303                             value = (StringUtils.isBlank(defaultValue)) ? &quot;false&quot; : defaultValue;
 304                         }
 305                     } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 306                         if (StringUtils.isEmpty(value)) {
 307                             value = null;
 308                         }
 309                     }
<abbr title=" 310                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 310                     if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity,ðŸ”µ</abbr>
 311                         boolean isValid = true;
<abbr title=" 312                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 312                         PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, propðŸ”µ</abbr>
 313                         handled = false;
 314                         if (value != null) {
 315                             for (PopulateValueRequestValidator validator : populateValidators) {
<abbr title=" 316                                 PropertyValidationResult validationResult = validator.validate(request, instance);"> 316                                 PropertyValidationResult validationResult = validator.validate(request, iðŸ”µ</abbr>
 317                                 if (!validationResult.isValid()) {
<abbr title=" 318                                     entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 318                                     entity.addValidationError(property.getName(), validationResult.getErrðŸ”µ</abbr>
 319                                     isValid = false;
 320                                 }
 321                             }
 322                         }
 323                         if (isValid) {
 324                             try {
 325                                 boolean isBreakDetected = false;
<abbr title=" 326                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 326                                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceðŸ”µ</abbr>
<abbr title=" 327                                     if (((!isBreakDetected) || fieldPersistenceProvider.alwaysRun()) &amp;&amp; ((value != null) || fieldPersistenceProvider.canHandlePopulateNull())) {"> 327                                     if (((!isBreakDetected) || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (ðŸ”µ</abbr>
<abbr title=" 328                                         MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 328                                         MetadataProviderResponse response = fieldPersistenceProvider.popuðŸ”µ</abbr>
 329                                         if (MetadataProviderResponse.NOT_HANDLED != response) {
 330                                             handled = true;
 331                                         }
 332                                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
 333                                             isBreakDetected = true;
 334                                         }
 335                                     }
 336                                 }
 337                                 if (!handled) {
 338                                     if (value == null) {
 339                                         property.setIsDirty(true);
 340                                     }
<abbr title=" 341                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 341                                     defaultFieldPersistenceProvider.populateValue(new PopulateValueRequesðŸ”µ</abbr>
 342                                     if (value == null) {
 343                                         fieldManager.setFieldValue(instance, property.getName(), null);
 344                                     }
 345                                 }
 346                             } catch (ParentEntityPersistenceException | validation e) {
 347                                 entityPersistenceException = e;
 348                                 cleanupFailedPersistenceAttempt(instance);
 349                                 break;
 350                             }
 351                         }
 352                     }
 353                 }
 354             }
 355             // Only check validation if not the initial add
 356             if (!entity.isPreAdd()) {
 357                 validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 358             }
<abbr title=" 359             //if validation failed, refresh the current instance so that none of the changes will be persisted"> 359             //if validation failed, refresh the current instance so that none of the changes will be persðŸ”µ</abbr>
 360             if (entity.isValidationFailure()) {
 361                 // only refresh the instance if it was managed to begin with
<abbr title=" 362                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {"> 362                 if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instanceðŸ”µ</abbr>
 363                     persistenceManager.getDynamicEntityDao().refresh(instance);
 364                 }
<abbr title=" 365                 // re-initialize the valid properties for the entity in order to deal with the potential of not"> 365                 // re-initialize the valid properties for the entity in order to deal with the potential ðŸ”µ</abbr>
 366                 // completely sending over all checkbox/radio fields
 367                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 368                 entityList.add(instance);
 369                 Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 370                 invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 371                 invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 372                 invalid.overridePropertyValues(entity);
<abbr title=" 373                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 373                 String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), ðŸ”µ</abbr>
 374                 throw new ValidationException(invalid, message);
 375             } else if (entityPersistenceException != null) {
 376                 throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 377             } else {
 378                 fieldManager.persistMiddleEntities();
 379             }
 380         } catch (java.lang.IllegalAccessException e) {
 381             throw new PersistenceException(e);
 382         } catch (java.lang.InstantiationException e) {
 383             throw new PersistenceException(e);
 384         } finally {
 385             session.setHibernateFlushMode(originalFlushMode);
 386         }
 387         return instance;
 388     }
 389 
<abbr title=" 390     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance, Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 390     protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable iðŸ”µ</abbr>
 391         Boolean mutable = metadata.getMutable();
 392         Boolean readOnly = metadata.getReadOnly();
<abbr title=" 393         boolean generalConditionsMet = (((mutable == null) || mutable) &amp;&amp; ((readOnly == null) || (!readOnly))) &amp;&amp; property.getEnabled();"> 393         boolean generalConditionsMet = (((mutable == null) || mutable) &amp;&amp; ((readOnly == null) || (!readOnðŸ”µ</abbr>
 394         if (generalConditionsMet &amp;&amp; (value == null)) {
 395             boolean currentValueIsNotNull = false;
 396             try {
 397                 currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 398             } catch (FieldNotAvailableException e) {
 399                 throw new IllegalArgumentException(e);
 400             }
 401             boolean valueIsNotNullId = (metadata.getFieldType() != SupportedFieldType.ID) || setId;
 402             boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
<abbr title=" 403             return ((currentValueIsNotNull &amp;&amp; (!entity.isPreAdd())) &amp;&amp; valueIsNotNullId) &amp;&amp; valueIsNotPassword;"> 403             return ((currentValueIsNotNull &amp;&amp; (!entity.isPreAdd())) &amp;&amp; valueIsNotNullId) &amp;&amp; valueIsNotPasðŸ”µ</abbr>
 404         }
 405         return generalConditionsMet;
 406     }
 407 
 408     @Override
<abbr title=" 409     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 409     public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;ðŸ”µ</abbr>
 410         List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 411         records.add(record);
<abbr title=" 412         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 412         Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedPropertiesðŸ”µ</abbr>
 413         return productEntities[0];
 414     }
 415 
 416     @Override
<abbr title=" 417     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 417     public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SðŸ”µ</abbr>
<abbr title=" 418         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 418         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 419         return getRecord(mergedProperties, record, null, null);
 420     }
 421 
 422     @Override
<abbr title=" 423     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 423     public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspectiveðŸ”µ</abbr>
<abbr title=" 424         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 424         Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getNamðŸ”µ</abbr>
 425         return getRecords(mergedProperties, records, null, null, null);
 426     }
 427 
 428     @Override
<abbr title=" 429     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 429     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
<abbr title=" 430         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 430         return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistenceðŸ”µ</abbr>
 431     }
 432 
 433     @Override
<abbr title=" 434     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 434     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends SerialiðŸ”µ</abbr>
 435         return getRecords(primaryMergedProperties, records, null, null, null);
 436     }
 437 
 438     @Override
<abbr title=" 439     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extends Serializable&gt; records, Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties, String pathToTargetObject) {"> 439     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extenðŸ”µ</abbr>
<abbr title=" 440         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 440         return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedPropertiesðŸ”µ</abbr>
 441     }
 442 
 443     @Override
<abbr title=" 444     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extends Serializable&gt; records, Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties, String pathToTargetObject, String[] customCriteria) {"> 444     public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties, List&lt;? extenðŸ”µ</abbr>
<abbr title=" 445         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 445         Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfiltereðŸ”µ</abbr>
<abbr title=" 446         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 446         Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilðŸ”µ</abbr>
 447         Entity[] entities = new Entity[records.size()];
 448         int j = 0;
 449         for (Serializable recordEntity : records) {
 450             Serializable entity;
 451             if (pathToTargetObject != null) {
 452                 try {
<abbr title=" 453                     entity = ((Serializable) (getFieldManager().getFieldValue(recordEntity, pathToTargetObject)));"> 453                     entity = ((Serializable) (getFieldManager().getFieldValue(recordEntity, pathToTargetOðŸ”µ</abbr>
 454                 } catch (java.lang.Exception e) {
 455                     throw new PersistenceException(e);
 456                 }
 457             } else {
 458                 entity = recordEntity;
 459             }
 460             Entity entityItem = new Entity();
 461             entityItem.setType(new String[]{ entity.getClass().getName() });
 462             entities[j] = entityItem;
 463             List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
<abbr title=" 464             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);"> 464             extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria)ðŸ”µ</abbr>
 465             if (alternateMergedProperties != null) {
<abbr title=" 466                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 466                 extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, cusðŸ”µ</abbr>
 467             }
 468             // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 469             try {
 470                 Property p = new Property();
 471                 p.setName(MAIN_ENTITY_NAME_PROPERTY);
<abbr title=" 472                 String mainEntityName = ((String) (MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;)));"> 472                 String mainEntityName = ((String) (MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;))ðŸ”µ</abbr>
 473                 p.setValue(mainEntityName);
 474                 props.add(p);
 475             } catch (java.lang.Exception e) {
<abbr title=" 476                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;, entity.getClass().getName()), e);"> 476                 LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;, entiðŸ”µ</abbr>
 477             }
 478             // Try to add the alternate id property if available
 479             if (alternateMergedProperties != null) {
 480                 for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 481                     if (entry.getValue() instanceof BasicFieldMetadata) {
<abbr title=" 482                         if (((BasicFieldMetadata) (entry.getValue())).getFieldType() == SupportedFieldType.ID) {"> 482                         if (((BasicFieldMetadata) (entry.getValue())).getFieldType() == SupportedFieldTypðŸ”µ</abbr>
<abbr title=" 483                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();"> 483                             Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadðŸ”µ</abbr>
 484                             alternateOnEntity.put(entry.getKey(), entry.getValue());
 485                             List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 486                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 486                             extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2ðŸ”µ</abbr>
 487                             List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 488                             for (Property prop : props2) {
 489                                 if (!prop.getName().startsWith(&quot;__&quot;)) {
 490                                     filtered.add(prop);
 491                                 }
 492                             }
 493                             if ((filtered.size() == 1) &amp;&amp; (!filtered.get(0).getName().contains(&quot;.&quot;))) {
 494                                 Property alternateIdProp = filtered.get(0);
 495                                 alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 496                                 props.add(alternateIdProp);
 497                             }
 498                         }
 499                     }
 500                 }
 501             }
 502             Property[] properties = new Property[props.size()];
 503             properties = props.toArray(properties);
 504             entityItem.setProperties(properties);
 505             j++;
 506         }
 507         return entities;
 508     }
 509 
 510     @Override
 511     public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 512         return fetchWrapper.getRecords(fetchExtractionRequest);
 513     }
 514 
<abbr title=" 515     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties, Serializable entity, List&lt;Property&gt; props, String[] customCriteria) {"> 515     protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties, SerðŸ”µ</abbr>
 516         FieldManager fieldManager = getFieldManager();
 517         try {
 518             if (entity instanceof AdminMainEntity) {
 519                 //Create an invisible property for the admin main entity name, if applicable.
 520                 //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 521                 //its display name.
 522                 try {
 523                     Property propertyItem = new Property();
 524                     propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 525                     propertyItem.setValue(((AdminMainEntity) (entity)).getMainEntityName());
 526                     props.add(propertyItem);
 527                 } catch (java.lang.Exception e) {
<abbr title=" 528                     // do nothing here except for not add the property. Exceptions could occur when there is a validation"> 528                     // do nothing here except for not add the property. Exceptions could occur when thereðŸ”µ</abbr>
<abbr title=" 529                     // issue and some properties/relationships that are used for gleaning the main entity name end up"> 529                     // issue and some properties/relationships that are used for gleaning the main entityðŸ”µ</abbr>
 530                     // not being set
 531                 }
 532             }
 533             for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 534                 String property = entry.getKey();
 535                 BasicFieldMetadata metadata = ((BasicFieldMetadata) (entry.getValue()));
<abbr title=" 536                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 536                 if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) ||ðŸ”µ</abbr>
 537                     boolean proceed = true;
 538                     if (property.contains(&quot;.&quot;)) {
 539                         StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 540                         Object testObject = entity;
 541                         while (tokens.hasMoreTokens()) {
 542                             String token = tokens.nextToken();
 543                             if (tokens.hasMoreTokens()) {
 544                                 try {
 545                                     testObject = fieldManager.getFieldValue(testObject, token);
 546                                 } catch (FieldNotAvailableException e) {
 547                                     proceed = false;
 548                                     break;
 549                                 }
 550                                 if (testObject == null) {
 551                                     Property propertyItem = new Property();
 552                                     propertyItem.setName(property);
 553                                     if (props.contains(propertyItem)) {
 554                                         proceed = false;
 555                                         break;
 556                                     }
 557                                     propertyItem.setValue(null);
 558                                     props.add(propertyItem);
 559                                     proceed = false;
 560                                     break;
 561                                 }
 562                             }
 563                         }
 564                     }
 565                     if (!proceed) {
 566                         continue;
 567                     }
 568                     boolean isFieldAccessible = true;
 569                     Object value = null;
 570                     try {
 571                         value = fieldManager.getFieldValue(entity, property);
 572                     } catch (FieldNotAvailableException e) {
 573                         isFieldAccessible = false;
 574                     }
 575                     checkField : {
 576                         if (isFieldAccessible) {
 577                             Property propertyItem = new Property();
 578                             propertyItem.setName(property);
 579                             if (props.contains(propertyItem)) {
 580                                 continue;
 581                             }
 582                             props.add(propertyItem);
 583                             String displayVal = propertyItem.getDisplayValue();
 584                             boolean handled = false;
<abbr title=" 585                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 585                             for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvðŸ”µ</abbr>
<abbr title=" 586                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValue(new ExtractValueRequest(props, fieldManager, metadata, value, displayVal, persistenceManager, this, entity, customCriteria), propertyItem);"> 586                                 MetadataProviderResponse response = fieldPersistenceProvider.extractValueðŸ”µ</abbr>
 587                                 if (MetadataProviderResponse.NOT_HANDLED != response) {
 588                                     handled = true;
 589                                 }
 590                                 if (MetadataProviderResponse.HANDLED_BREAK == response) {
 591                                     break;
 592                                 }
 593                             }
 594                             if (!handled) {
<abbr title=" 595                                 defaultFieldPersistenceProvider.extractValue(new ExtractValueRequest(props, fieldManager, metadata, value, displayVal, persistenceManager, this, entity, customCriteria), propertyItem);"> 595                                 defaultFieldPersistenceProvider.extractValue(new ExtractValueRequest(propðŸ”µ</abbr>
 596                             }
 597                             break checkField;
 598                         }
 599                         //try a direct property acquisition via reflection
 600                         try {
 601                             String strVal = null;
 602                             Method method;
 603                             try {
 604                                 // try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 605                                 String temp = (&quot;get&quot; + property.substring(0, 1).toUpperCase()) + property.substring(1, property.length());"> 605                                 String temp = (&quot;get&quot; + property.substring(0, 1).toUpperCase()) + propertyðŸ”µ</abbr>
 606                                 method = entity.getClass().getMethod(temp, new Class[]{  });
 607                             } catch (java.lang.NoSuchMethodException e) {
 608                                 method = entity.getClass().getMethod(property, new Class[]{  });
 609                             }
 610                             value = method.invoke(entity, new String[]{  });
 611                             Property propertyItem = new Property();
 612                             propertyItem.setName(property);
 613                             if (props.contains(propertyItem)) {
 614                                 continue;
 615                             }
 616                             props.add(propertyItem);
 617                             if (value == null) {
 618                                 strVal = null;
 619                             } else if (Date.class.isAssignableFrom(value.getClass())) {
 620                                 strVal = getSimpleDateFormatter().format(((Date) (value)));
 621                             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 622                                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) (value)).getTime()));"> 622                                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) (value)).gðŸ”µ</abbr>
 623                             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 624                                 strVal = getSimpleDateFormatter().format(((Calendar) (value)).getTime());
 625                             } else if (java.lang.Double.class.isAssignableFrom(value.getClass())) {
 626                                 strVal = getDecimalFormatter().format(value);
 627                             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 628                                 strVal = getDecimalFormatter().format(value);
 629                             } else {
 630                                 strVal = value.toString();
 631                             }
 632                             propertyItem.setValue(strVal);
 633                         } catch (java.lang.NoSuchMethodException e) {
<abbr title=" 634                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 634                             LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.ðŸ”µ</abbr>
 635                             // do nothing - this property is simply not in the bean
 636                         }
 637                     }
 638                 }
 639             }
 640         } catch (java.lang.ClassNotFoundException e) {
 641             throw new PersistenceException(e);
 642         } catch (java.lang.IllegalAccessException e) {
 643             throw new PersistenceException(e);
 644         } catch (InvocationTargetException e) {
 645             throw new PersistenceException(e);
 646         }
 647     }
 648 
 649     @Override
 650     public String getStringValueFromGetter(Serializable instance, String propertyName)
 651             throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 652         Object value = PropertyUtils.getProperty(instance, propertyName);
 653         return formatValue(value);
 654     }
 655 
 656     @Override
 657     public String formatValue(Object value) {
 658         String strVal;
 659         if (value == null) {
 660             strVal = null;
 661         } else {
 662             if (Date.class.isAssignableFrom(value.getClass())) {
 663                 strVal = getSimpleDateFormatter().format((Date) value);
 664             } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 665                 strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 666             } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 667                 strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 668             } else if (Double.class.isAssignableFrom(value.getClass())) {
 669                 strVal = getDecimalFormatter().format(value);
 670             } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 671                 strVal = getDecimalFormatter().format(value);
 672             } else {
 673                 strVal = value.toString();
 674             }
 675         }
 676         return strVal;
 677     }
 678 
<abbr title=" 679     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 679     protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean incluðŸ”µ</abbr>
 680         EntityResult entityResult = new EntityResult();
 681         Entity entity = persistencePackage.getEntity();
 682         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 683         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 683         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 684         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 685             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 686         }
 687         try {
<abbr title=" 688             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 688             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 689             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 689             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 690             if (primaryKey == null) {
 691                 primaryKey = getPrimaryKey(entity, mergedProperties);
 692             }
<abbr title=" 693             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 693             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 694             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 695             if (!entity.isValidationFailure()) {
 696                 //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
<abbr title=" 697                 if ((((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) &amp;&amp; (entity.findProperty(foreignKey.getSortField()) != null)) &amp;&amp; (entity.findProperty(foreignKey.getSortField()).getValue() != null)) {"> 697                 if ((((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) &amp;&amp; (entity.findPropertðŸ”µ</abbr>
<abbr title=" 698                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 698                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title=" 699                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance, mergedProperties, primaryKey, result);"> 699                     extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance, meðŸ”µ</abbr>
 700                     instance = result.getResult();
 701                 } else {
<abbr title=" 702                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 702                     instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistðŸ”µ</abbr>
 703                 }
 704                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 705                 if (includeRealEntity) {
 706                     entityResult.setEntityBackingObject(instance);
 707                 }
 708                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 709                 entityList.add(instance);
 710                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 711                 entityResult.setEntity(entity);
 712                 return entityResult;
 713             } else {
 714                 entityResult.setEntity(entity);
 715                 return entityResult;
 716             }
 717         } catch (java.lang.Exception e) {
 718             throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 719         }
 720     }
 721 
 722     @Override
 723     public String getIdPropertyName(String entityClass) {
 724         return persistenceManager.getIdPropertyName(entityClass);
 725     }
 726 
 727     public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 728         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 728         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 729         for (String property : mergedProperties.keySet()) {
 730             BasicFieldMetadata temp = ((BasicFieldMetadata) (mergedProperties.get(property)));
 731             if ((temp.getFieldType() == SupportedFieldType.ID) &amp;&amp; (!property.contains(&quot;.&quot;))) {
 732                 return property;
 733             }
 734         }
<abbr title=" 735         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);"> 735         throw new RuntimeException(&quot;Could not find a primary key property in the passed merged propertiesðŸ”µ</abbr>
 736     }
 737 
 738     @Override
 739     public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 740         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 740         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 741         Object primaryKey = null;
 742         String idPropertyName = null;
 743         BasicFieldMetadata metaData = null;
 744         for (String property : mergedProperties.keySet()) {
 745             BasicFieldMetadata temp = ((BasicFieldMetadata) (mergedProperties.get(property)));
 746             if ((temp.getFieldType() == SupportedFieldType.ID) &amp;&amp; (!property.contains(&quot;.&quot;))) {
 747                 idPropertyName = property;
 748                 metaData = temp;
 749                 break;
 750             }
 751         }
 752         if (idPropertyName == null) {
<abbr title=" 753             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 753             throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with tðŸ”µ</abbr>
 754         }
 755         for (Property property : entity.getProperties()) {
 756             if (property.getName().equals(idPropertyName)) {
 757                 switch (metaData.getSecondaryType()) {
 758                     case INTEGER :
<abbr title=" 759                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());"> 759                         primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValuðŸ”µ</abbr>
 760                         break;
 761                     case STRING :
 762                         primaryKey = property.getValue();
 763                         break;
 764                 }
 765                 break;
 766             }
 767         }
 768         if (primaryKey == null) {
<abbr title=" 769             throw new RuntimeException(((&quot;Could not find the primary key property (&quot; + idPropertyName) + &quot;) in the passed entity with type: &quot;) + entity.getType()[0]);"> 769             throw new RuntimeException(((&quot;Could not find the primary key property (&quot; + idPropertyName) + ðŸ”µ</abbr>
 770         }
 771         return primaryKey;
 772     }
 773 
 774     @Override
<abbr title=" 775     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTransferObject cto, String ceilingEntityFullyQualifiedClassname, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties, RestrictionFactory customRestrictionFactory) {"> 775     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTðŸ”µ</abbr>
<abbr title=" 776         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 776         Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredPropertðŸ”µ</abbr>
 777         List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 778         for (String propertyId : cto.getCriteriaMap().keySet()) {
 779             if (mergedProperties.containsKey(propertyId)) {
 780                 boolean handled = false;
 781                 for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 782                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId, getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory : customRestrictionFactory), filterMappings);"> 782                     MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(new AddðŸ”µ</abbr>
 783                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 784                         handled = true;
 785                     }
 786                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 787                         break;
 788                     }
 789                 }
 790                 if (!handled) {
<abbr title=" 791                     defaultFieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId, getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory : customRestrictionFactory), filterMappings);"> 791                     defaultFieldPersistenceProvider.addSearchMapping(new AddSearchMappingRequest(persisteðŸ”µ</abbr>
 792                 }
 793             }
 794         }
 795         return filterMappings;
 796     }
 797 
 798     @Override
<abbr title=" 799     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTransferObject cto, String ceilingEntityFullyQualifiedClassname, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {"> 799     public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective, CriteriaTðŸ”µ</abbr>
<abbr title=" 800         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 800         return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergeðŸ”µ</abbr>
 801     }
 802 
 803     @Override
<abbr title=" 804     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 804     public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMeðŸ”µ</abbr>
<abbr title=" 805         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 805         extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), ðŸ”µ</abbr>
 806     }
 807 
<abbr title=" 808     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 808     protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mðŸ”µ</abbr>
 809         Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {
 810 
 811             @Override
 812             public int compare(Property o1, Property o2) {
 813                 return o1.getName().compareTo(o2.getName());
 814             }
 815         };
 816 
 817 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 818         properties.sort(comparator);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 819 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 820 </span>
 821 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 822 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 822 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 823 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 824 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 825         Collections.sort(properties, comparator);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 826 </span>
 827 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 828         for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 829             String property = entry.getKey();
 830             Property prop = new Property();
 831             FieldMetadata metadata = mergedProperties.get(property);
 832             prop.setName(property);
 833 
 834 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 835 </span>
 836 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 837 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 837 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 838 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 839 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 840 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 841 </span>
 842 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 843             int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 844             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 844             if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREðŸ”µ</abbr>
 845                 logWarn: {
<abbr title=" 846                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 846                     if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFðŸ”µ</abbr>
 847                         //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 848                         break logWarn;
 849                     }
<abbr title=" 850                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 850                     //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + prðŸ”µ</abbr>
 851                 }
 852                 continue;
 853             } else if (pos &lt; 0) {
 854                 pos = -pos - 1; // calculate position to insert
 855             }
 856             properties.add(pos, prop);
 857             prop.setMetadata(metadata);
 858             if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 859                 //this only makes sense for non collection types
 860                 ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 861             }
 862         }
 863     }
 864 
 865     @Override
<abbr title=" 866     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 866     public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, MapðŸ”µ</abbr>
<abbr title=" 867         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 867         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
 868         try {
<abbr title=" 869             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();"> 869             PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective(ðŸ”µ</abbr>
<abbr title=" 870             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);"> 870             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title=" 871             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(ceilingEntityFullyQualifiedClassname, entities, ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY))), persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 871             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
 872             allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 873         } catch (java.lang.Exception e) {
<abbr title=" 874             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);"> 874             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
 875         }
 876     }
 877 
 878     @Override
<abbr title=" 879     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 879     public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) thðŸ”µ</abbr>
 880         return update(persistencePackage, null, true);
 881     }
 882 
 883     @Override
 884     public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 885         EntityResult er = update(persistencePackage, null, false);
 886         return er.getEntity();
 887     }
 888 
 889     @Override
 890     public Entity add(PersistencePackage persistencePackage) throws ServiceException {
 891         EntityResult entityResult = add(persistencePackage, false);
 892         return entityResult.getEntity();
 893     }
 894 
 895     @Override
<abbr title=" 896     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 896     public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throwðŸ”µ</abbr>
 897         EntityResult entityResult = new EntityResult();
 898         Entity entity = persistencePackage.getEntity();
 899         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 900         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 900         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 901         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 902             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 903         }
 904         try {
<abbr title=" 905             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 905             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 906             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 906             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
<abbr title=" 907             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 907             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
 908             String idProperty = null;
 909             for (String property : mergedProperties.keySet()) {
<abbr title=" 910                 if (((BasicFieldMetadata) (mergedProperties.get(property))).getFieldType() == SupportedFieldType.ID) {"> 910                 if (((BasicFieldMetadata) (mergedProperties.get(property))).getFieldType() == SupportedFiðŸ”µ</abbr>
 911                     idProperty = property;
 912                     break;
 913                 }
 914             }
 915             if (idProperty == null) {
<abbr title=" 916                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 916                 throw new RuntimeException(&quot;Could not find a primary key property in the passed entity wiðŸ”µ</abbr>
 917             }
 918             Object primaryKey = null;
 919             try {
 920                 primaryKey = getPrimaryKey(entity, mergedProperties);
 921             } catch (java.lang.Exception e) {
 922                 // don&#x27;t do anything - this is a valid case
 923             }
 924             if (primaryKey == null) {
<abbr title=" 925                 Serializable instance = ((Serializable) (Class.forName(entity.getType()[0]).newInstance()));"> 925                 Serializable instance = ((Serializable) (Class.forName(entity.getType()[0]).newInstance()ðŸ”µ</abbr>
 926                 instance = createPopulatedInstance(instance, entity, mergedProperties, false);
 927                 if ((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) {
<abbr title=" 928                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();"> 928                     ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;(ðŸ”µ</abbr>
<abbr title=" 929                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);"> 929                     extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergeðŸ”µ</abbr>
 930                     instance = result.getResult();
 931                 }
 932                 instance = persistenceManager.getDynamicEntityDao().merge(instance);
 933                 if (includeRealEntityObject) {
 934                     entityResult.setEntityBackingObject(instance);
 935                 }
 936                 List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 937                 entityList.add(instance);
 938                 entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 939                 entityResult.setEntity(entity);
 940                 return entityResult;
 941             } else {
 942                 return update(persistencePackage, primaryKey, includeRealEntityObject);
 943             }
 944         } catch (java.lang.Exception e) {
 945             throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
 946         }
 947     }
 948 
 949     @Override
 950     public void remove(PersistencePackage persistencePackage) throws ServiceException {
 951         Entity entity = persistencePackage.getEntity();
 952         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 953         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));"> 953         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
 954         if ((foreignKey != null) &amp;&amp; (!foreignKey.getMutable())) {
 955             throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 956         }
 957         try {
<abbr title=" 958             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 958             Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingðŸ”µ</abbr>
<abbr title=" 959             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(persistencePackage.getCeilingEntityFullyQualifiedClassname(), entities, foreignKey, persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);"> 959             Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDaðŸ”µ</abbr>
<abbr title=" 960             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);"> 960             Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProðŸ”µ</abbr>
 961             Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title=" 962             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 962             Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entitðŸ”µ</abbr>
 963             Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 964             switch (persistencePerspective.getOperationTypes().getRemoveType()) {
 965                 case NONDESTRUCTIVEREMOVE :
 966                     FieldManager fieldManager = getFieldManager();
<abbr title=" 967                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());"> 967                     FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyðŸ”µ</abbr>
<abbr title=" 968                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();"> 968                     Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue()ðŸ”µ</abbr>
 969                     try {
 970                         foreignKeyValue = Long.valueOf(((String) (foreignKeyValue)));
 971                     } catch (java.lang.NumberFormatException e) {
<abbr title=" 972                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);"> 972                         LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove looðŸ”µ</abbr>
 973                     }
<abbr title=" 974                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);"> 974                     Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(ClasðŸ”µ</abbr>
<abbr title=" 975                     Collection collection = ((Collection) (fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField())));"> 975                     Collection collection = ((Collection) (fieldManager.getFieldValue(foreignInstance, foðŸ”µ</abbr>
 976                     collection.remove(instance);
<abbr title=" 977                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on"> 977                     // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (justðŸ”µ</abbr>
<abbr title=" 978                     // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly"> 978                     // the @ManyToOne side) then it will not be updated. In that instance, we have to expðŸ”µ</abbr>
 979                     // set the manyTo field to null so that subsequent lookups will not find it
 980                     if (manyToFieldMetadata instanceof BasicFieldMetadata) {
<abbr title=" 981                         if (BooleanUtils.isTrue(((BasicFieldMetadata) (manyToFieldMetadata)).getRequired())) {"> 981                         if (BooleanUtils.isTrue(((BasicFieldMetadata) (manyToFieldMetadata)).getRequired(ðŸ”µ</abbr>
<abbr title=" 982                             throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot; + (&quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot; + &quot; or nullable=true within the @JoinColumn annotation&quot;));"> 982                             throw new ServiceException(&quot;Could not remove from the collection as the ManyTðŸ”µ</abbr>
 983                         }
<abbr title=" 984                         // Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module"> 984                         // Since this is occuring on a remove persistence package, merge up-front (beforeðŸ”µ</abbr>
 985                         instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title=" 986                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());"> 986                         Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyðŸ”µ</abbr>
 987                         Object manyToObject = manyToField.get(instance);
<abbr title=" 988                         if (((manyToObject != null) &amp;&amp; (!(manyToObject instanceof Collection))) &amp;&amp; (!(manyToObject instanceof Map))) {"> 988                         if (((manyToObject != null) &amp;&amp; (!(manyToObject instanceof Collection))) &amp;&amp; (!(manðŸ”µ</abbr>
 989                             manyToField.set(instance, null);
 990                             instance = persistenceManager.getDynamicEntityDao().merge(instance);
 991                         }
 992                     }
 993                     break;
 994                 case BASIC :
 995                     persistenceManager.getDynamicEntityDao().remove(instance);
 996                     break;
 997             }
 998         } catch (java.lang.Exception e) {
 999             throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1000         }
1001     }
1002 
<abbr title="1003     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1003     public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage, CriteriaðŸ”µ</abbr>
1004         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1005         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1005         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
1006         if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1007             persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1008         }
1009         try {
<abbr title="1010             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1010             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
<abbr title="1011             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(ceilingEntityFullyQualifiedClassname, entities, ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY))), persistencePerspective.getAdditionalNonPersistentProperties(), persistencePerspective.getAdditionalForeignKeys(), MergedPropertyType.PRIMARY, persistencePerspective.getPopulateToOneFields(), persistencePerspective.getIncludeFields(), persistencePerspective.getExcludeFields(), persistencePerspective.getConfigurationKey(), &quot;&quot;);">1011             Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMerðŸ”µ</abbr>
1012             return mergedProperties;
1013         } catch (java.lang.Exception e) {
<abbr title="1014             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1014             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1015         }
1016     }
1017 
1018     @Override
<abbr title="1019     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1019     public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throðŸ”µ</abbr>
1020         Entity[] payload;
1021         int totalRecords;
1022         PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1023         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1023         String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClðŸ”µ</abbr>
<abbr title="1024         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY)));">1024         ForeignKey foreignKey = ((ForeignKey) (persistencePerspective.getPersistencePerspectiveItems().geðŸ”µ</abbr>
1025         try {
1026             if ((foreignKey != null) &amp;&amp; (foreignKey.getSortField() != null)) {
1027                 FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1028                 sortCriteria.setSortAscending(foreignKey.getSortAscending());
1029             }
1030             Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
<abbr title="1031             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties);">1031             List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistenðŸ”µ</abbr>
1032             List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1033             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1034                 standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1035             }
1036             if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1037                 standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1038             }
<abbr title="1039             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);">1039             FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFðŸ”µ</abbr>
1040             List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1041             List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1042             if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1043                 countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1044             }
<abbr title="1045             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);">1045             FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto, persistencePackageðŸ”µ</abbr>
1046             totalRecords = getTotalRecords(countFetchRequest);
<abbr title="1047             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto, persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);">1047             FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackageðŸ”µ</abbr>
1048             payload = getRecords(fetchExtractionRequest);
1049         } catch (java.lang.Exception e) {
<abbr title="1050             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);">1050             throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassnðŸ”µ</abbr>
1051         }
1052         return new DynamicResultSet(null, payload, totalRecords);
1053     }
1054 
1055     @Override
1056     public Integer getTotalRecords(FetchRequest fetchRequest) {
1057         return fetchWrapper.getTotalRecords(fetchRequest);
1058     }
1059 
1060     @Override
1061     public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1062         try {
<abbr title="1063             return ((Long) (criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings).getSingleResult())).intValue();">1063             return ((Long) (criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDaoðŸ”µ</abbr>
1064         } catch (CriteriaConversionException e) {
<abbr title="1065             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1065             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1066             return ((Long) (builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult())).intValue();">1066             return ((Long) (builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandarðŸ”µ</abbr>
1067         }
1068     }
1069 
1070     @Override
<abbr title="1071     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {">1071     public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxFðŸ”µ</abbr>
<abbr title="1072         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, maxField).getSingleResult();">1072         return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(), ceilingEntiðŸ”µ</abbr>
1073     }
1074 
1075     @Override
1076     public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1077         return fetchWrapper.getPersistentRecords(fetchRequest);
1078     }
1079 
1080     @Override
<abbr title="1081     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1081     public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappinðŸ”µ</abbr>
1082         try {
<abbr title="1083             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1083             return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntðŸ”µ</abbr>
1084         } catch (CriteriaConversionException e) {
<abbr title="1085             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1085             TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilðŸ”µ</abbr>
<abbr title="1086             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1086             return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManagerðŸ”µ</abbr>
1087         }
1088     }
1089 
1090     @Override
<abbr title="1091     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1091     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
1092         return validate(entity, populatedInstance, mergedProperties, true);
1093     }
1094 
1095     @Override
<abbr title="1096     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties, boolean validateUnsubmittedProperties) {">1096     public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; merðŸ”µ</abbr>
<abbr title="1097         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1097         entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmðŸ”µ</abbr>
1098         return !entity.isValidationFailure();
1099     }
1100 
1101     @Override
1102     public void setPersistenceManager(PersistenceManager persistenceManager) {
1103         this.persistenceManager = persistenceManager;
1104     }
1105 
1106     @Override
1107     public PersistenceModule getCompatibleModule(OperationType operationType) {
1108         return ((InspectHelper) (persistenceManager)).getCompatibleModule(operationType);
1109     }
1110 
1111     public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1112         return defaultFieldPersistenceProvider;
1113     }
1114 
<abbr title="1115     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {">1115     public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvidðŸ”µ</abbr>
1116         this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1117     }
1118 
1119     public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1120         return fieldPersistenceProviders;
1121     }
1122 
1123     public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1124         this.fieldPersistenceProviders = fieldPersistenceProviders;
1125     }
1126 
1127     public CriteriaTranslator getCriteriaTranslator() {
1128         return criteriaTranslator;
1129     }
1130 
1131     public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1132         this.criteriaTranslator = criteriaTranslator;
1133     }
1134 
1135     public EntityValidatorService getEntityValidatorService() {
1136         return entityValidatorService;
1137     }
1138 
1139     public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1140         this.entityValidatorService = entityValidatorService;
1141     }
1142 
1143     public RestrictionFactory getRestrictionFactory() {
1144         return restrictionFactory;
1145     }
1146 
1147     public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1148         this.restrictionFactory = restrictionFactory;
1149     }
1150 
1151     public PersistenceManager getPersistenceManager() {
1152         return persistenceManager;
1153     }
1154 
1155     /**
<abbr title="1156      * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1156      * Use an alternate approach to generating a fetch query for a collection located inside of an @EmbedðŸ”µ</abbr>
<abbr title="1157      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1157      * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather thðŸ”µ</abbr>
1158      * which seems to alleviate the problem.
1159      *
1160      * @param embeddedCollectionPath the path to the collection field itself
1161      * @param filterMappings all the fetch restrictions for this request
1162      * @param collectionClass the type of the collection members
1163      * @return the builder capable of generating an appropriate HQL query
1164      */
<abbr title="1165     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1165     protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMðŸ”µ</abbr>
1166         String specialPath = embeddedCollectionPath.getTargetProperty();
1167         String[] pieces = specialPath.split(&quot;\\.&quot;);
1168         if (pieces.length != 3) {
<abbr title="1169             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1169             throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of foðŸ”µ</abbr>
1170         }
1171         String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1172         TypedQueryBuilder builder;
1173         try {
<abbr title="1174             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;).addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));">1174             builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;).addJoin(new ðŸ”µ</abbr>
1175         } catch (java.lang.Exception e) {
1176             throw ExceptionHelper.refineException(e);
1177         }
1178         for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1179             builder = builder.addRestriction(restriction);
1180         }
<abbr title="1181         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {">1181         for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappingsðŸ”µ</abbr>
1182             builder = builder.addRestriction(restriction);
1183         }
1184         for (FilterMapping mapping : filterMappings) {
1185             if (mapping.getSortDirection() != null) {
<abbr title="1186                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath().getTargetProperty();">1186                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath()ðŸ”µ</abbr>
1187                 if (StringUtils.isEmpty(mappingProperty)) {
1188                     mappingProperty = mapping.getFullPropertyName();
1189                 }
<abbr title="1190                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1190                 builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ðŸ”µ</abbr>
1191             }
1192         }
1193         return builder;
1194     }
1195 
1196     /**
<abbr title="1197      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1197      * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not theðŸ”µ</abbr>
1198      *
<abbr title="1199      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1199      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1200      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1200      * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this iðŸ”µ</abbr>
1201      * @param filterMappings all the fetch restrictions for this request
1202      * @return the list of restrictions on the root entity
1203      */
<abbr title="1204     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1204     protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterðŸ”µ</abbr>
<abbr title="1205         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1205         String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPatðŸ”µ</abbr>
1206         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1207         for (FilterMapping mapping : filterMappings) {
1208             checkProperty : {
<abbr title="1209                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath().getTargetProperty();">1209                 String mappingProperty = (mapping.getFieldPath() == null) ? null : mapping.getFieldPath()ðŸ”µ</abbr>
1210                 if (StringUtils.isEmpty(mappingProperty)) {
1211                     mappingProperty = mapping.getFullPropertyName();
1212                 }
<abbr title="1213                 if ((!embeddedCollectionPath.getTargetProperty().equals(mappingProperty)) &amp;&amp; (!StringUtils.isEmpty(mappingProperty))) {">1213                 if ((!embeddedCollectionPath.getTargetProperty().equals(mappingProperty)) &amp;&amp; (!StringUtilðŸ”µ</abbr>
<abbr title="1214                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();">1214                     PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider()ðŸ”µ</abbr>
1215                     if (predicateProvider != null) {
<abbr title="1216                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();">1216                         FilterValueConverter converter = mapping.getRestriction().getFilterValueConverterðŸ”µ</abbr>
<abbr title="1217                         if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {">1217                         if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues()))ðŸ”µ</abbr>
1218                             Object val = converter.convert(mapping.getFilterValues().get(0));
1219                             if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1220                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1220                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LðŸ”µ</abbr>
1221                                 break checkProperty;
1222                             } else if (predicateProvider instanceof EqPredicateProvider) {
<abbr title="1223                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));">1223                                 restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=ðŸ”µ</abbr>
1224                                 break checkProperty;
1225                             }
1226                         }
1227                     }
<abbr title="1228                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;, StringUtil.sanitize(expression), StringUtil.sanitize(mappingProperty)));">1228                     LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additionaðŸ”µ</abbr>
1229                 }
1230             }
1231         }
1232         return restrictions;
1233     }
1234 
1235     /**
<abbr title="1236      * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1236      * Generate EQUALS restrictions for any filter property specified on the entity member of the collectðŸ”µ</abbr>
1237      *
<abbr title="1238      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1238      * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.moduleðŸ”µ</abbr>
<abbr title="1239      * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1239      * @param specialExpression the String representation of the path for the collection field in the @EmðŸ”µ</abbr>
1240      * @param filterMappings all the fetch restrictions for this request
1241      * @return the list of restrictions on the collection in the @Embeddable object
1242      */
<abbr title="1243     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1243     protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
1244         List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1245         for (FilterMapping mapping : filterMappings) {
<abbr title="1246             if (((mapping.getFieldPath() != null) &amp;&amp; (mapping.getFieldPath().getTargetProperty() != null)) &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1246             if (((mapping.getFieldPath() != null) &amp;&amp; (mapping.getFieldPath().getTargetProperty() != null)ðŸ”µ</abbr>
1247                 FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1248                 if ((converter != null) &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1249                     Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1250                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1250                     String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieðŸ”µ</abbr>
1251                     restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1252                 }
1253             }
1254         }
1255         return restrictions;
1256     }
1257 
1258     protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1259         //Remove the entity from ORM management - no further attempts to persist
<abbr title="1260         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {">1260         if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) ðŸ”µ</abbr>
1261             getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1262         }
1263         //Remove the id field value, if it&#x27;s set
<abbr title="1264         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1264         String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instancðŸ”µ</abbr>
1265         Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1266         if (idField == null) {
<abbr title="1267             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1267             throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass(ðŸ”µ</abbr>
1268         }
1269         idField.setAccessible(true);
1270         if (idField.get(instance) != null) {
1271             idField.set(instance, null);
1272         }
1273     }
1274 
<abbr title="1275     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {">1275     protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property propertðŸ”µ</abbr>
1276         Class&lt;?&gt; returnType = null;
<abbr title="1277         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1277         Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, propertyðŸ”µ</abbr>
1278         java.lang.reflect.Type type = field.getGenericType();
1279         if (type instanceof ParameterizedType) {
1280             ParameterizedType pType = ((ParameterizedType) (type));
1281             Class&lt;?&gt; clazz;
1282             if (pType.getActualTypeArguments().length &lt; 2) {
1283                 clazz = ((Class&lt;?&gt;) (pType.getActualTypeArguments()[0]));
1284             } else {
1285                 clazz = ((Class&lt;?&gt;) (pType.getActualTypeArguments()[1]));
1286             }
<abbr title="1287             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1287             Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCðŸ”µ</abbr>
1288             if (!ArrayUtils.isEmpty(entities)) {
1289                 returnType = entities[entities.length - 1];
1290             }
1291         }
1292         return returnType;
1293     }
1294 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20  
  21  import org.apache.commons.beanutils.PropertyUtils;
  22  import org.apache.commons.collections.CollectionUtils;
  23  import org.apache.commons.lang.ArrayUtils;
  24  import org.apache.commons.lang.StringUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.reflect.FieldUtils;
  27  import org.apache.commons.lang3.reflect.MethodUtils;
  28  import org.apache.commons.logging.Log;
  29  import org.apache.commons.logging.LogFactory;
  30  import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31  import org.broadleafcommerce.common.exception.ExceptionHelper;
  32  import org.broadleafcommerce.common.exception.SecurityServiceException;
  33  import org.broadleafcommerce.common.exception.ServiceException;
  34  import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35  import org.broadleafcommerce.common.money.Money;
  36  import org.broadleafcommerce.common.presentation.client.OperationType;
  37  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  38  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  39  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  40  import org.broadleafcommerce.common.util.FormatUtil;
  41  import org.broadleafcommerce.common.util.StringUtil;
  42  import org.broadleafcommerce.common.util.ValidationUtil;
  43  import org.broadleafcommerce.common.util.dao.TQJoin;
  44  import org.broadleafcommerce.common.util.dao.TQOrder;
  45  import org.broadleafcommerce.common.util.dao.TQRestriction;
  46  import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  47  import org.broadleafcommerce.common.web.BroadleafRequestContext;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.broadleafcommerce.openadmin.dto.DynamicResultSet;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -import org.broadleafcommerce.openadmin.dto.Entity;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.broadleafcommerce.openadmin.dto.EntityResult;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -import org.broadleafcommerce.openadmin.dto.FieldMetadata;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.broadleafcommerce.openadmin.dto.ForeignKey;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  56 -import org.broadleafcommerce.openadmin.dto.MergedPropertyType;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.broadleafcommerce.openadmin.dto.PersistencePackage;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import org.broadleafcommerce.openadmin.dto.PersistencePerspective;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import org.broadleafcommerce.openadmin.dto.Property;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import org.broadleafcommerce.openadmin.dto.SortDirection;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import org.broadleafcommerce.openadmin.dto.*;</span>
  62  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;
  63  import org.broadleafcommerce.openadmin.server.service.ValidationException;
  64  import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  65  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  66  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.*;</span>
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;
  74  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;
  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;
  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
<abbr title="  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionðŸ”µ</abbr>
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;
<abbr title="  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequeðŸ”µ</abbr>
  80  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;
  81  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;
  82  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;
  83  import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
  84  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;
  85  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  86  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  87  import org.hibernate.FlushMode;
  88  import org.hibernate.Session;
  89  import org.springframework.beans.BeansException;
  90  import org.springframework.context.ApplicationContext;
  91  import org.springframework.context.ApplicationContextAware;
  92  import org.springframework.context.annotation.Primary;
  93  import org.springframework.context.annotation.Scope;
  94  import org.springframework.stereotype.Component;
  95  import org.springframework.util.Assert;
  96  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +import javax.annotation.Resource;</span>
  99  import java.io.Serializable;
 100  import java.lang.reflect.Field;
 101  import java.lang.reflect.InvocationTargetException;
 102  import java.lang.reflect.Method;
 103  import java.lang.reflect.ParameterizedType;
 104  import java.math.BigDecimal;
 105  import java.sql.Timestamp;
 106  import java.text.DecimalFormat;
 107  import java.text.NumberFormat;
 108  import java.text.SimpleDateFormat;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -import java.util.ArrayList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -import java.util.Arrays;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -import java.util.Calendar;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -import java.util.Collection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -import java.util.Collections;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -import java.util.Comparator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -import java.util.Date;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 116 -import java.util.HashMap;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 117 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 118 -import java.util.Locale;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -import java.util.Map;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +import java.util.*;</span>
 121  import java.util.Map.Entry;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 122 -import java.util.StringTokenizer;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 123 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -import javax.annotation.PostConstruct;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -import javax.annotation.Resource;</span>
 126  
 127  /**
 128   * @author jfischer
 129   */
 130  @Primary
 131  @Component(&quot;blBasicPersistenceModule&quot;)
 132  @Scope(&quot;prototype&quot;)
 133  public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 134  
 135      private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 136  
 137      public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 138      public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 139  
 140      protected ApplicationContext applicationContext;
 141      protected PersistenceManager persistenceManager;
 142  
 143      @Resource(name = &quot;blEntityValidatorService&quot;)
 144      protected EntityValidatorService entityValidatorService;
 145  
 146      @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 147      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 147      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;()ðŸ”µ</abbr>
 148  
 149      @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 150      protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 151  
 152      @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 153      protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 154  
 155      @Resource(name = &quot;blCriteriaTranslator&quot;)
 156      protected CriteriaTranslator criteriaTranslator;
 157  
 158      @Resource(name = &quot;blRestrictionFactory&quot;)
 159      protected RestrictionFactory restrictionFactory;
 160  
 161      @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 162      protected BasicPersistenceModuleExtensionManager extensionManager;
 163  
 164      @Resource(name = &quot;blFetchWrapper&quot;)
 165      protected FetchWrapper fetchWrapper;
 166  
 167      @PostConstruct
 168      public void init() {
 169          Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 170  
 171              @Override
 172              public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 173                  return Integer.compare(o1.getOrder(), o2.getOrder());
 174              }
 175          });
 176          Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 177  
 178              @Override
 179              public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 180                  return Integer.compare(o1.getOrder(), o2.getOrder());
 181              }
 182          });
 183      }
 184  
 185      @Override
 186      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 187          this.applicationContext = applicationContext;
 188      }
 189  
 190      @Override
 191      public boolean isCompatible(OperationType operationType) {
 192          return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;
 193      }
 194  
 195      @Override
 196      public FieldManager getFieldManager() {
 197          return persistenceManager.getDynamicEntityDao().getFieldManager();
 198      }
 199  
 200      @Override
 201      public DecimalFormat getDecimalFormatter() {
 202          BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 203          Locale locale = brc.getJavaLocale();
 204          DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 205          format.applyPattern(&quot;0.########&quot;);
 206          format.setGroupingUsed(false);
 207          return format;
 208      }
 209  
 210      @Override
 211      public SimpleDateFormat getSimpleDateFormatter() {
 212          return FormatUtil.getDateFormat();
 213      }
 214  
 215      protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {
 216          if (metadata == null) {
 217              return null;
 218          }
 219          Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 220          for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 221              String fieldName = entry.getKey();
 222              FieldMetadata md = entry.getValue();
<abbr title=" 223              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 223              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but alsðŸ”µ</abbr>
<abbr title=" 224              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 224              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistðŸ”µ</abbr>
 225              // can appropriate handle filtration and population
 226              if (entry.getValue() instanceof BasicFieldMetadata) {
 227                  newMap.put(fieldName, md);
<abbr title=" 228              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 228              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ðŸ”µ</abbr>
 229                  newMap.put(fieldName,
<abbr title=" 230                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 230                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvideðŸ”µ</abbr>
 231              }
 232          }
 233  
 234          return newMap;
 235      }
 236  
 237      protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 238          Class&lt;?&gt; response;
 239          switch (fieldType) {
 240              case BOOLEAN:
 241                  response = Boolean.TYPE;
 242                  break;
 243              case DATE:
 244                  response = Date.class;
 245                  break;
 246              case DECIMAL:
 247                  response = BigDecimal.class;
 248                  break;
 249              case MONEY:
 250                  response = Money.class;
 251                  break;
 252              case INTEGER:
 253                  response = Integer.TYPE;
 254                  break;
 255              case UNKNOWN:
 256                  response = null;
 257                  break;
 258              default:
 259                  response = String.class;
 260                  break;
 261          }
 262  
 263          return response;
 264      }
 265  
 266      @Override
 267      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 268              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 269          return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 270      }
 271  
 272      @Override
 273      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 274              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 274              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties)ðŸ”µ</abbr>
 275          final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);
 276          FieldManager fieldManager = getFieldManager();
 277          boolean handled = false;
 278          for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 279              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 279              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRðŸ”µ</abbr>
 280              if (MetadataProviderResponse.NOT_HANDLED != response) {
 281                  handled = true;
 282              }
 283              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 284                  break;
 285              }
 286          }
 287          if (!handled) {
<abbr title=" 288              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 288              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProðŸ”µ</abbr>
 289          }
<abbr title=" 290          //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 290          //Order media field, map field and rule builder fields last, as they will have some validation components ðŸ”µ</abbr>
 291          Property[] sortedProperties = entity.getProperties();
 292          Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 293  
 294              @Override
 295              public int compare(Property o1, Property o2) {
 296                  BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 297                  BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 298                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 298                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 299                          SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 300                          SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 301                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 301                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
<abbr title=" 302                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 302                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 303                          SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 304                          SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 305                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 305                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
 306                  if (isLate1 &amp;&amp; !isLate2) {
 307                      return 1;
 308                  } else if (!isLate1 &amp;&amp; isLate2) {
 309                      return -1;
 310                  }
 311                  return 0;
 312              }
 313          });
<abbr title=" 314          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 314          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.ðŸ”µ</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 315 -        FlushMode originalFlushMode = session.getFlushMode();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +        FlushMode originalFlushMode = session.getHibernateFlushMode();</span>
 317          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 318 -            session.setFlushMode(FlushMode.MANUAL);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +            session.setHibernateFlushMode(FlushMode.MANUAL);</span>
 320              RuntimeException entityPersistenceException = null;
 321              for (Property property : sortedProperties) {
 322                  BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());
 323                  Class&lt;?&gt; returnType;
<abbr title=" 324                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 324                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWithðŸ”µ</abbr>
 325                      Field field = fieldManager.getField(instance.getClass(), property.getName());
 326                      if (field == null) {
<abbr title=" 327                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 327                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitiðŸ”µ</abbr>
 328                          continue;
 329                      }
 330                      returnType = field.getType();
 331                  } else {
 332                      if (metadata == null) {
<abbr title=" 333                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 333                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.saðŸ”µ</abbr>
 334                          continue;
 335                      }
 336                      returnType = getMapFieldType(instance, fieldManager, property);
 337                      if (returnType == null) {
 338                          returnType = getBasicBroadleafType(metadata.getFieldType());
 339                      }
 340                  }
 341                  if (returnType == null) {
<abbr title=" 342                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 342                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + proðŸ”µ</abbr>
 343                  }
 344                  String value = property.getValue();
 345                  if (metadata != null) {
 346  
 347                      if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 348                          if (value == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 349 -                            value = &quot;false&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +                            String defaultValue = metadata.getDefaultValue();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +                            value = StringUtils.isBlank(defaultValue)? &quot;false&quot; : defaultValue;</span>
 352                          }
 353                      } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 354                          if (StringUtils.isEmpty(value)) {
 355                              value = null;
 356                          }
 357                      }
 358  
<abbr title=" 359                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 359                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) ðŸ”µ</abbr>
 360                          boolean isValid = true;
<abbr title=" 361                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 361                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metðŸ”µ</abbr>
 362                          handled = false;
 363                          if (value != null) {
 364                              for (PopulateValueRequestValidator validator : populateValidators) {
 365                                  PropertyValidationResult validationResult = validator.validate(request, instance);
 366                                  if (!validationResult.isValid()) {
<abbr title=" 367                                      entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 367                                      entity.addValidationError(property.getName(), validationResult.getErrorMessageðŸ”µ</abbr>
 368                                      isValid = false;
 369                                  }
 370                              }
 371                          }
 372                          if (isValid) {
 373                              try {
 374                                  boolean isBreakDetected = false;
<abbr title=" 375                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 375                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvidersðŸ”µ</abbr>
<abbr title=" 376                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 376                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != nuðŸ”µ</abbr>
<abbr title=" 377                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 377                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValueðŸ”µ</abbr>
 378                                          if (MetadataProviderResponse.NOT_HANDLED != response) {
 379                                              handled = true;
 380                                          }
 381                                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
 382                                              isBreakDetected = true;
 383                                          }
 384                                      }
 385                                  }
 386                                  if (!handled) {
 387                                      if (value == null) {
 388                                          property.setIsDirty(true);
 389                                      }
<abbr title=" 390                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 390                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, ðŸ”µ</abbr>
 391                                      if (value == null) {
 392                                          fieldManager.setFieldValue(instance, property.getName(), null);
 393                                      }
 394                                  }
 395                              } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {
 396                                  entityPersistenceException = e;
 397                                  cleanupFailedPersistenceAttempt(instance);
 398                                  break;
 399                              }
 400                          }
 401                      }
 402                  }
 403              }
 404              // Only check validation if not the initial add
 405              if (!entity.isPreAdd()) {
 406                  validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 407              }
 408              //if validation failed, refresh the current instance so that none of the changes will be persisted
 409              if (entity.isValidationFailure()) {
 410                  //only refresh the instance if it was managed to begin with
 411                  if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
 412                      persistenceManager.getDynamicEntityDao().refresh(instance);
 413                  }
 414  
 415                  //re-initialize the valid properties for the entity in order to deal with the potential of not
 416                  //completely sending over all checkbox/radio fields
 417                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 418                  entityList.add(instance);
 419                  Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 420                  invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 421                  invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 422                  invalid.overridePropertyValues(entity);
 423  
<abbr title=" 424                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 424                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.gðŸ”µ</abbr>
 425                  throw new ValidationException(invalid, message);
 426              } else if (entityPersistenceException != null) {
 427                  throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 428              } else {
 429                  fieldManager.persistMiddleEntities();
 430              }
 431          } catch (IllegalAccessException e) {
 432              throw new PersistenceException(e);
 433          } catch (InstantiationException e) {
 434              throw new PersistenceException(e);
 435          } finally {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -            session.setFlushMode(originalFlushMode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +            session.setHibernateFlushMode(originalFlushMode);</span>
 438          }
 439          return instance;
 440      }
 441  
 442      protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,
<abbr title=" 443                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 443                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String valðŸ”µ</abbr>
 444          Boolean mutable = metadata.getMutable();
 445          Boolean readOnly = metadata.getReadOnly();
<abbr title=" 446          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 446          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; propertyðŸ”µ</abbr>
 447  
 448          if (generalConditionsMet &amp;&amp; value == null) {
 449              boolean currentValueIsNotNull = false;
 450              try {
 451                  currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 452              } catch (FieldNotAvailableException e) {
 453                  throw new IllegalArgumentException(e);
 454              }
 455  
 456              boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 457              boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 458  
 459              return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 460          }
 461          return generalConditionsMet;
 462      }
 463  
 464      @Override
<abbr title=" 465      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 465      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FðŸ”µ</abbr>
 466          List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 467          records.add(record);
<abbr title=" 468          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 468          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTðŸ”µ</abbr>
 469          return productEntities[0];
 470      }
 471  
 472      @Override
<abbr title=" 473      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 473      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SerializabðŸ”µ</abbr>
<abbr title=" 474          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 474          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 475          return getRecord(mergedProperties, record, null, null);
 476      }
 477  
 478      @Override
<abbr title=" 479      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 479      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? ðŸ”µ</abbr>
<abbr title=" 480          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 480          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 481          return getRecords(mergedProperties, records, null, null, null);
 482      }
 483  
 484      @Override
<abbr title=" 485      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 485      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
<abbr title=" 486          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 486          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspectiðŸ”µ</abbr>
 487      }
 488  
 489      @Override
<abbr title=" 490      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 490      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; reðŸ”µ</abbr>
 491          return getRecords(primaryMergedProperties, records, null, null, null);
 492      }
 493  
 494      @Override
 495      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 496                                 List&lt;? extends Serializable&gt; records,
 497                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 498                                 String pathToTargetObject) {
<abbr title=" 499          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 499          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTðŸ”µ</abbr>
 500      }
 501  
 502      @Override
 503      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 504                                 List&lt;? extends Serializable&gt; records,
 505                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 506                                 String pathToTargetObject,
 507                                 String[] customCriteria) {
<abbr title=" 508          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 508          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedPrðŸ”µ</abbr>
<abbr title=" 509          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 509          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergðŸ”µ</abbr>
 510          Entity[] entities = new Entity[records.size()];
 511          int j = 0;
 512          for (Serializable recordEntity : records) {
 513              Serializable entity;
 514              if (pathToTargetObject != null) {
 515                  try {
 516                      entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);
 517                  } catch (Exception e) {
 518                      throw new PersistenceException(e);
 519                  }
 520              } else {
 521                  entity = recordEntity;
 522              }
 523              Entity entityItem = new Entity();
 524              entityItem.setType(new String[] { entity.getClass().getName() });
 525              entities[j] = entityItem;
 526  
 527              List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
 528              extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);
 529              if (alternateMergedProperties != null) {
<abbr title=" 530                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 530                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriterðŸ”µ</abbr>
 531              }
 532  
 533              // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 534              try {
 535                  Property p = new Property();
 536                  p.setName(MAIN_ENTITY_NAME_PROPERTY);
 537                  String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 538                  p.setValue(mainEntityName);
 539                  props.add(p);
 540              } catch (Exception e) {
 541                  LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 542                          entity.getClass().getName()), e);
 543              }
 544  
 545              // Try to add the alternate id property if available
 546              if (alternateMergedProperties != null) {
 547                  for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 548                      if (entry.getValue() instanceof BasicFieldMetadata) {
 549                          if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {
 550                              Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();
 551                              alternateOnEntity.put(entry.getKey(), entry.getValue());
 552                              List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 553                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 553                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCðŸ”µ</abbr>
 554                              List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 555                              for (Property prop : props2) {
 556                                  if (!prop.getName().startsWith(&quot;__&quot;)) {
 557                                      filtered.add(prop);
 558                                  }
 559                              }
 560                              if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 561                                  Property alternateIdProp = filtered.get(0);
 562                                  alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 563                                  props.add(alternateIdProp);
 564                              }
 565                          }
 566                      }
 567                  }
 568              }
 569  
 570              Property[] properties = new Property[props.size()];
 571              properties = props.toArray(properties);
 572              entityItem.setProperties(properties);
 573              j++;
 574          }
 575  
 576          return entities;
 577      }
 578  
 579      @Override
 580      public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 581          return fetchWrapper.getRecords(fetchExtractionRequest);
 582      }
 583  
 584      protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 585                                                           Serializable entity,
 586                                                           List&lt;Property&gt; props,
 587                                                           String[] customCriteria) {
 588          FieldManager fieldManager = getFieldManager();
 589          try {
 590              if (entity instanceof AdminMainEntity) {
 591                  //Create an invisible property for the admin main entity name, if applicable.
 592                  //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 593                  //its display name.
 594                  try {
 595                      Property propertyItem = new Property();
 596                      propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 597                      propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 598                      props.add(propertyItem);
 599                  } catch (Exception e) {
<abbr title=" 600                      //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 600                      //do nothing here except for not add the property. Exceptions could occur when there is a valiðŸ”µ</abbr>
<abbr title=" 601                      //issue and some properties/relationships that are used for gleaning the main entity name end up"> 601                      //issue and some properties/relationships that are used for gleaning the main entity name end ðŸ”µ</abbr>
 602                      //not being set
 603                  }
 604              }
 605              for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 606                  String property = entry.getKey();
 607                  BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 608                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 608                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.gðŸ”µ</abbr>
 609                      boolean proceed = true;
 610                      if (property.contains(&quot;.&quot;)) {
 611                          StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 612                          Object testObject = entity;
 613                          while (tokens.hasMoreTokens()) {
 614                              String token = tokens.nextToken();
 615                              if (tokens.hasMoreTokens()) {
 616                                  try {
 617                                      testObject = fieldManager.getFieldValue(testObject, token);
 618                                  } catch (FieldNotAvailableException e) {
 619                                      proceed = false;
 620                                      break;
 621                                  }
 622                                  if (testObject == null) {
 623                                      Property propertyItem = new Property();
 624                                      propertyItem.setName(property);
 625                                      if (props.contains(propertyItem)) {
 626                                          proceed = false;
 627                                          break;
 628                                      }
 629                                      propertyItem.setValue(null);
 630                                      props.add(propertyItem);
 631                                      proceed = false;
 632                                      break;
 633                                  }
 634                              }
 635                          }
 636                      }
 637                      if (!proceed) {
 638                          continue;
 639                      }
 640  
 641                      boolean isFieldAccessible = true;
 642                      Object value = null;
 643                      try {
 644                          value = fieldManager.getFieldValue(entity, property);
 645                      } catch (FieldNotAvailableException e) {
 646                          isFieldAccessible = false;
 647                      }
 648                      checkField:
 649                      {
 650                          if (isFieldAccessible) {
 651                              Property propertyItem = new Property();
 652                              propertyItem.setName(property);
 653                              if (props.contains(propertyItem)) {
 654                                  continue;
 655                              }
 656                              props.add(propertyItem);
 657                              String displayVal = propertyItem.getDisplayValue();
 658                              boolean handled = false;
 659                              for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 660                                  MetadataProviderResponse response = fieldPersistenceProvider.extractValue(
 661                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 662                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 663                                  if (MetadataProviderResponse.NOT_HANDLED != response) {
 664                                      handled = true;
 665                                  }
 666                                  if (MetadataProviderResponse.HANDLED_BREAK == response) {
 667                                      break;
 668                                  }
 669                              }
 670                              if (!handled) {
 671                                  defaultFieldPersistenceProvider.extractValue(
 672                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 673                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 674                              }
 675                              break checkField;
 676                          }
 677                          //try a direct property acquisition via reflection
 678                          try {
 679                              String strVal = null;
 680                              Method method;
 681                              try {
 682                                  //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 683                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 683                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(ðŸ”µ</abbr>
 684                                  method = entity.getClass().getMethod(temp, new Class[] {});
 685                              } catch (NoSuchMethodException e) {
 686                                  method = entity.getClass().getMethod(property, new Class[] {});
 687                              }
 688                              value = method.invoke(entity, new String[] {});
 689                              Property propertyItem = new Property();
 690                              propertyItem.setName(property);
 691                              if (props.contains(propertyItem)) {
 692                                  continue;
 693                              }
 694                              props.add(propertyItem);
 695                              if (value == null) {
 696                                  strVal = null;
 697                              } else {
 698                                  if (Date.class.isAssignableFrom(value.getClass())) {
 699                                      strVal = getSimpleDateFormatter().format((Date) value);
 700                                  } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 701                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 701                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime(ðŸ”µ</abbr>
 702                                  } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 703                                      strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 704                                  } else if (Double.class.isAssignableFrom(value.getClass())) {
 705                                      strVal = getDecimalFormatter().format(value);
 706                                  } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 707                                      strVal = getDecimalFormatter().format(value);
 708                                  } else {
 709                                      strVal = value.toString();
 710                                  }
 711                              }
 712                              propertyItem.setValue(strVal);
 713                          } catch (NoSuchMethodException e) {
<abbr title=" 714                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 714                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(ðŸ”µ</abbr>
 715                              //do nothing - this property is simply not in the bean
 716                          }
 717                      }
 718                  }
 719              }
 720          } catch (ClassNotFoundException e) {
 721              throw new PersistenceException(e);
 722          } catch (IllegalAccessException e) {
 723              throw new PersistenceException(e);
 724          } catch (InvocationTargetException e) {
 725              throw new PersistenceException(e);
 726          }
 727      }
 728  
 729      @Override
 730      public String getStringValueFromGetter(Serializable instance, String propertyName)
 731              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 732          Object value = PropertyUtils.getProperty(instance, propertyName);
 733          return formatValue(value);
 734      }
 735  
 736      @Override
 737      public String formatValue(Object value) {
 738          String strVal;
 739          if (value == null) {
 740              strVal = null;
 741          } else {
 742              if (Date.class.isAssignableFrom(value.getClass())) {
 743                  strVal = getSimpleDateFormatter().format((Date) value);
 744              } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 745                  strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 746              } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 747                  strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 748              } else if (Double.class.isAssignableFrom(value.getClass())) {
 749                  strVal = getDecimalFormatter().format(value);
 750              } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 751                  strVal = getDecimalFormatter().format(value);
 752              } else {
 753                  strVal = value.toString();
 754              }
 755          }
 756          return strVal;
 757      }
 758  
<abbr title=" 759      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 759      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntðŸ”µ</abbr>
 760          EntityResult entityResult = new EntityResult();
 761          Entity entity = persistencePackage.getEntity();
 762          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 763          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 763          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 764          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 765              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 766          }
 767          try {
<abbr title=" 768              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 768              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title=" 769              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 769              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 770                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 771                      entities,
 772                      foreignKey,
 773                      persistencePerspective.getAdditionalNonPersistentProperties(),
 774                      persistencePerspective.getAdditionalForeignKeys(),
 775                      MergedPropertyType.PRIMARY,
 776                      persistencePerspective.getPopulateToOneFields(),
 777                      persistencePerspective.getIncludeFields(),
 778                      persistencePerspective.getExcludeFields(),
 779                      persistencePerspective.getConfigurationKey(),
 780                      &quot;&quot;
 781                      );
 782              if (primaryKey == null) {
 783                  primaryKey = getPrimaryKey(entity, mergedProperties);
 784              }
<abbr title=" 785              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 785              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
 786  
 787              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 788  
 789              if (!entity.isValidationFailure()) {
 790                  //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 791                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 792                          entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 793                          entity.findProperty(foreignKey.getSortField()).getValue() != null) {
 794                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
 795                      extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 796                              mergedProperties, primaryKey, result);
 797                      instance = result.getResult();
 798                  } else {
<abbr title=" 799                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 799                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackaðŸ”µ</abbr>
 800                  }
 801  
 802                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
 803                  if (includeRealEntity) {
 804                      entityResult.setEntityBackingObject(instance);
 805                  }
 806  
 807                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 808                  entityList.add(instance);
 809  
 810                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 811                  entityResult.setEntity(entity);
 812                  return entityResult;
 813              } else {
 814                  entityResult.setEntity(entity);
 815                  return entityResult;
 816              }
 817          } catch (Exception e) {
 818              throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 819          }
 820      }
 821  
 822      @Override
 823      public String getIdPropertyName(String entityClass) {
 824          return persistenceManager.getIdPropertyName(entityClass);
 825      }
 826  
 827      public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 828          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 829          for (String property : mergedProperties.keySet()) {
 830              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 831              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 832                  return property;
 833              }
 834          }
 835  
 836          throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);
 837      }
 838  
 839      @Override
 840      public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 841          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 842          Object primaryKey = null;
 843          String idPropertyName = null;
 844          BasicFieldMetadata metaData = null;
 845          for (String property : mergedProperties.keySet()) {
 846              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 847              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 848                  idPropertyName = property;
 849                  metaData = temp;
 850                  break;
 851              }
 852          }
 853          if (idPropertyName == null) {
<abbr title=" 854              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 854              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + ðŸ”µ</abbr>
 855          }
 856          for (Property property : entity.getProperties()) {
 857              if (property.getName().equals(idPropertyName)) {
 858                  switch (metaData.getSecondaryType()) {
 859                      case INTEGER:
 860                          primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());
 861                          break;
 862                      case STRING:
 863                          primaryKey = property.getValue();
 864                          break;
 865                  }
 866                  break;
 867              }
 868          }
 869          if (primaryKey == null) {
<abbr title=" 870              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 870              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the paðŸ”µ</abbr>
 871          }
 872          return primaryKey;
 873      }
 874  
 875      @Override
 876      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 877              CriteriaTransferObject cto,
 878              String ceilingEntityFullyQualifiedClassname,
 879              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 880              RestrictionFactory customRestrictionFactory) {
 881          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 882          List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 883  
 884          for (String propertyId : cto.getCriteriaMap().keySet()) {
 885              if (mergedProperties.containsKey(propertyId)) {
 886                  boolean handled = false;
 887                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 888                      MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 889                              new AddSearchMappingRequest(persistencePerspective, cto,
 890                                      ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 891                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 891                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restðŸ”µ</abbr>
 892                                      :customRestrictionFactory), filterMappings);
 893                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 894                          handled = true;
 895                      }
 896                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 897                          break;
 898                      }
 899                  }
 900                  if (!handled) {
 901                      defaultFieldPersistenceProvider.addSearchMapping(
 902                              new AddSearchMappingRequest(persistencePerspective, cto,
 903                                      ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 904                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 904                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFðŸ”µ</abbr>
 905                                              : customRestrictionFactory), filterMappings);
 906                  }
 907              }
 908          }
 909          return filterMappings;
 910      }
 911  
 912      @Override
 913      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 914              CriteriaTransferObject cto,
 915              String ceilingEntityFullyQualifiedClassname,
 916              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 917          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 917          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilterðŸ”µ</abbr>
 918      }
 919  
 920      @Override
<abbr title=" 921      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 921      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; ðŸ”µ</abbr>
<abbr title=" 922          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 922          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), propertieðŸ”µ</abbr>
 923      }
 924  
<abbr title=" 925      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 925      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedPropðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +        Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +                return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 931 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 932 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 933 +        properties.sort(comparator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 934 +</span>
 935          for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 936              String property = entry.getKey();
 937              Property prop = new Property();
 938              FieldMetadata metadata = mergedProperties.get(property);
 939              prop.setName(property);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 940 -            Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 941 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 942 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 943 -                public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 944 -                    return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 945 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 946 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 947 -            Collections.sort(properties, comparator);</span>

 948              int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 949              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 949              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != ðŸ”µ</abbr>
 950                  logWarn: {
<abbr title=" 951                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 951                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadðŸ”µ</abbr>
 952                          //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 953                          break logWarn;
 954                      }
<abbr title=" 955                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 955                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + ðŸ”µ</abbr>
 956                  }
 957                  continue;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 958 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 959 -            properties.add(prop);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 960 +            } else if (pos &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 961 +                pos = -pos - 1; // calculate position to insert</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +            properties.add(pos, prop);</span>
 964              prop.setMetadata(metadata);
 965              if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 966                  //this only makes sense for non collection types
 967                  ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 968              }
 969          }
 970      }
 971  
 972      @Override
<abbr title=" 973      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 973      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, ðŸ”µ</abbr>
<abbr title=" 974          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 974          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 975          try {
 976              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 977              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);
<abbr title=" 978              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 978              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 979                      ceilingEntityFullyQualifiedClassname,
 980                      entities,
<abbr title=" 981                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 981                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 982                      persistencePerspective.getAdditionalNonPersistentProperties(),
 983                      persistencePerspective.getAdditionalForeignKeys(),
 984                      MergedPropertyType.PRIMARY,
 985                      persistencePerspective.getPopulateToOneFields(),
 986                      persistencePerspective.getIncludeFields(),
 987                      persistencePerspective.getExcludeFields(),
 988                      persistencePerspective.getConfigurationKey(),
 989                      &quot;&quot;
 990                      );
 991              allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 992          } catch (Exception e) {
 993              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
 994          }
 995      }
 996  
 997      @Override
<abbr title=" 998      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 998      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServðŸ”µ</abbr>
 999          return update(persistencePackage, null, true);
1000      }
1001  
1002      @Override
1003      public Entity update(PersistencePackage persistencePackage) throws ServiceException {
1004          EntityResult er = update(persistencePackage, null, false);
1005          return er.getEntity();
1006      }
1007  
1008      @Override
1009      public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1010          EntityResult entityResult = add(persistencePackage, false);
1011          return entityResult.getEntity();
1012      }
1013  
1014      @Override
<abbr title="1015      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1015      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceðŸ”µ</abbr>
1016          EntityResult entityResult = new EntityResult();
1017          Entity entity = persistencePackage.getEntity();
1018          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1019          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1019          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1020          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1021              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1022          }
1023          try {
<abbr title="1024              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1024              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1025              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1025              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1026                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1027                      entities,
1028                      foreignKey,
1029                      persistencePerspective.getAdditionalNonPersistentProperties(),
1030                      persistencePerspective.getAdditionalForeignKeys(),
1031                      MergedPropertyType.PRIMARY,
1032                      persistencePerspective.getPopulateToOneFields(),
1033                      persistencePerspective.getIncludeFields(),
1034                      persistencePerspective.getExcludeFields(),
1035                      persistencePerspective.getConfigurationKey(),
1036                      &quot;&quot;
1037                      );
1038              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1039  
1040              String idProperty = null;
1041              for (String property : mergedProperties.keySet()) {
<abbr title="1042                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1042                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID)ðŸ”µ</abbr>
1043                      idProperty = property;
1044                      break;
1045                  }
1046              }
1047              if (idProperty == null) {
<abbr title="1048                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1048                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: ðŸ”µ</abbr>
1049              }
1050              Object primaryKey = null;
1051              try {
1052                  primaryKey = getPrimaryKey(entity, mergedProperties);
1053              } catch (Exception e) {
1054                  //don&#x27;t do anything - this is a valid case
1055              }
1056              if (primaryKey == null) {
1057  
1058                  Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1059  
1060                  instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1061  
1062                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1063                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
<abbr title="1064                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1064                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedPropertiðŸ”µ</abbr>
1065                      instance = result.getResult();
1066                  }
1067  
1068                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
1069                  if (includeRealEntityObject) {
1070                      entityResult.setEntityBackingObject(instance);
1071                  }
1072                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1073                  entityList.add(instance);
1074  
1075                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1076                  entityResult.setEntity(entity);
1077                  return entityResult;
1078              } else {
1079                  return update(persistencePackage, primaryKey, includeRealEntityObject);
1080              }
1081          } catch (Exception e) {
1082              throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1083          }
1084      }
1085  
1086      @Override
1087      public void remove(PersistencePackage persistencePackage) throws ServiceException {
1088          Entity entity = persistencePackage.getEntity();
1089          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1090          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1090          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1091          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1092              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1093          }
1094          try {
<abbr title="1095              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1095              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1096              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1096              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1097                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1098                      entities,
1099                      foreignKey,
1100                      persistencePerspective.getAdditionalNonPersistentProperties(),
1101                      persistencePerspective.getAdditionalForeignKeys(),
1102                      MergedPropertyType.PRIMARY,
1103                      persistencePerspective.getPopulateToOneFields(),
1104                      persistencePerspective.getIncludeFields(),
1105                      persistencePerspective.getExcludeFields(),
1106                      persistencePerspective.getConfigurationKey(),
1107                      &quot;&quot;
1108                      );
1109              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1110              Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1111              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1111              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
1112  
1113              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1114  
1115              switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1116                  case NONDESTRUCTIVEREMOVE:
1117                      FieldManager fieldManager = getFieldManager();
<abbr title="1118                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1118                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField()ðŸ”µ</abbr>
1119                      Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();
1120                      try {
1121                          foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1122                      } catch (NumberFormatException e) {
1123                          LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);
1124                      }
<abbr title="1125                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1125                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forNameðŸ”µ</abbr>
<abbr title="1126                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1126                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.geðŸ”µ</abbr>
1127                      collection.remove(instance);
<abbr title="1128                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1128                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreigðŸ”µ</abbr>
1129                      // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly
1130                      // set the manyTo field to null so that subsequent lookups will not find it
1131                      if (manyToFieldMetadata instanceof BasicFieldMetadata) {
1132                          if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {
<abbr title="1133                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1133                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne sideðŸ”µ</abbr>
<abbr title="1134                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1134                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyTðŸ”µ</abbr>
1135                                      + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1136                          }
<abbr title="1137                          //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1137                          //Since this is occuring on a remove persistence package, merge up-front (before making a ðŸ”µ</abbr>
1138                          instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1139                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1139                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField()ðŸ”µ</abbr>
1140                          Object manyToObject = manyToField.get(instance);
<abbr title="1141                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1141                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanðŸ”µ</abbr>
1142                              manyToField.set(instance, null);
1143                              instance = persistenceManager.getDynamicEntityDao().merge(instance);
1144                          }
1145                      }
1146                      break;
1147                  case BASIC:
1148                      persistenceManager.getDynamicEntityDao().remove(instance);
1149                      break;
1150              }
1151          } catch (Exception e) {
1152              throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1153          }
1154      }
1155  
1156      public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1157              CriteriaTransferObject cto) throws ServiceException {
1158          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1159          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1159          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
1160  
1161          if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1162              persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1163          }
1164  
1165          try {
<abbr title="1166              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1166              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(ClðŸ”µ</abbr>
1167  
<abbr title="1168              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1168              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
1169                      ceilingEntityFullyQualifiedClassname,
1170                      entities,
<abbr title="1171                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1171                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
1172                      persistencePerspective.getAdditionalNonPersistentProperties(),
1173                      persistencePerspective.getAdditionalForeignKeys(),
1174                      MergedPropertyType.PRIMARY,
1175                      persistencePerspective.getPopulateToOneFields(),
1176                      persistencePerspective.getIncludeFields(),
1177                      persistencePerspective.getExcludeFields(),
1178                      persistencePerspective.getConfigurationKey(),
1179                      &quot;&quot;
1180                      );
1181  
1182              return mergedProperties;
1183          } catch (Exception e) {
1184              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1185          }
1186      }
1187  
1188      @Override
<abbr title="1189      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1189      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServicðŸ”µ</abbr>
1190          Entity[] payload;
1191          int totalRecords;
1192          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1193          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1193          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
<abbr title="1194          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1194          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1195  
1196          try {
1197              if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1198                  FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1199                  sortCriteria.setSortAscending(foreignKey.getSortAscending());
1200              }
1201  
1202              Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1203  
1204              List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage
1205                      .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1206              List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1207              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1208                  standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1209              }
1210              if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1211                  standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1212              }
1213  
1214              FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1215                      persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1216              List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1217  
1218              List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1219              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1220                  countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1221              }
1222              FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1223                      persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1224              totalRecords = getTotalRecords(countFetchRequest);
1225  
1226              FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,
1227                      persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1228              payload = getRecords(fetchExtractionRequest);
1229          } catch (Exception e) {
1230              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1231          }
1232  
1233          return new DynamicResultSet(null, payload, totalRecords);
1234      }
1235  
1236      @Override
1237      public Integer getTotalRecords(FetchRequest fetchRequest) {
1238          return fetchWrapper.getTotalRecords(fetchRequest);
1239      }
1240  
1241      @Override
1242      public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1243          try {
1244              return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),
1245                      ceilingEntity, filterMappings).getSingleResult()).intValue();
1246          } catch (CriteriaConversionException e) {
<abbr title="1247              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1247              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1248              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1248              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManðŸ”µ</abbr>
1249          }
1250      }
1251  
1252      @Override
1253      public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {
1254          return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1255                  ceilingEntity, filterMappings, maxField).getSingleResult();
1256      }
1257  
1258      @Override
1259      public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1260          return fetchWrapper.getPersistentRecords(fetchRequest);
1261      }
1262  
1263      @Override
<abbr title="1264      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1264      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, IntegðŸ”µ</abbr>
1265          try {
<abbr title="1266              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1266              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filtðŸ”µ</abbr>
1267          } catch (CriteriaConversionException e) {
<abbr title="1268              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1268              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1269              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1269              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getReðŸ”µ</abbr>
1270          }
1271      }
1272  
1273      @Override
<abbr title="1274      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1274      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1275          return validate(entity, populatedInstance, mergedProperties, true);
1276      }
1277  
1278      @Override
<abbr title="1279      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1279      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1280              boolean validateUnsubmittedProperties) {
<abbr title="1281          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1281          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedPropðŸ”µ</abbr>
1282          return !entity.isValidationFailure();
1283      }
1284  
1285      @Override
1286      public void setPersistenceManager(PersistenceManager persistenceManager) {
1287          this.persistenceManager = persistenceManager;
1288      }
1289  
1290      @Override
1291      public PersistenceModule getCompatibleModule(OperationType operationType) {
1292          return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1293      }
1294  
1295      public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1296          return defaultFieldPersistenceProvider;
1297      }
1298  
1299      public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {
1300          this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1301      }
1302  
1303      public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1304          return fieldPersistenceProviders;
1305      }
1306  
1307      public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1308          this.fieldPersistenceProviders = fieldPersistenceProviders;
1309      }
1310  
1311      public CriteriaTranslator getCriteriaTranslator() {
1312          return criteriaTranslator;
1313      }
1314  
1315      public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1316          this.criteriaTranslator = criteriaTranslator;
1317      }
1318  
1319      public EntityValidatorService getEntityValidatorService() {
1320          return entityValidatorService;
1321      }
1322  
1323      public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1324          this.entityValidatorService = entityValidatorService;
1325      }
1326  
1327      public RestrictionFactory getRestrictionFactory() {
1328          return restrictionFactory;
1329      }
1330  
1331      public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1332          this.restrictionFactory = restrictionFactory;
1333      }
1334  
1335      public PersistenceManager getPersistenceManager() {
1336          return persistenceManager;
1337      }
1338  
1339      /**
<abbr title="1340       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1340       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable objðŸ”µ</abbr>
<abbr title="1341       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1341       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA crðŸ”µ</abbr>
1342       * which seems to alleviate the problem.
1343       *
1344       * @param embeddedCollectionPath the path to the collection field itself
1345       * @param filterMappings all the fetch restrictions for this request
1346       * @param collectionClass the type of the collection members
1347       * @return the builder capable of generating an appropriate HQL query
1348       */
<abbr title="1349      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1349      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; fðŸ”µ</abbr>
1350          String specialPath = embeddedCollectionPath.getTargetProperty();
1351          String[] pieces = specialPath.split(&quot;\\.&quot;);
1352          if (pieces.length != 3) {
<abbr title="1353              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1353              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embðŸ”µ</abbr>
1354          }
1355          String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1356          TypedQueryBuilder builder;
1357          try {
1358              builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1359                      .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1360          } catch (Exception e) {
1361              throw ExceptionHelper.refineException(e);
1362          }
1363          for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1364              builder = builder.addRestriction(restriction);
1365          }
1366          for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {
1367              builder = builder.addRestriction(restriction);
1368          }
1369          for (FilterMapping mapping : filterMappings) {
1370              if (mapping.getSortDirection() != null) {
<abbr title="1371                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1371                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1372                  if (StringUtils.isEmpty(mappingProperty)) {
1373                      mappingProperty = mapping.getFullPropertyName();
1374                  }
<abbr title="1375                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1375                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDINGðŸ”µ</abbr>
1376              }
1377          }
1378  
1379          return builder;
1380      }
1381  
1382      /**
<abbr title="1383       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1383       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collectiðŸ”µ</abbr>
1384       *
<abbr title="1385       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1385       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1386       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1386       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caðŸ”µ</abbr>
1387       * @param filterMappings all the fetch restrictions for this request
1388       * @return the list of restrictions on the root entity
1389       */
<abbr title="1390      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1390      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
<abbr title="1391          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1391          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargðŸ”µ</abbr>
1392          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1393          for (FilterMapping mapping : filterMappings) {
1394              checkProperty: {
<abbr title="1395                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1395                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1396                  if (StringUtils.isEmpty(mappingProperty)) {
1397                      mappingProperty = mapping.getFullPropertyName();
1398                  }
<abbr title="1399                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1399                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(maðŸ”µ</abbr>
1400                      PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();
1401                      if (predicateProvider != null) {
1402                          FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1403                          if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1404                              Object val = converter.convert(mapping.getFilterValues().get(0));
1405                              if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1406                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1406                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, valðŸ”µ</abbr>
1407                                  break checkProperty;
1408                              } else if (predicateProvider instanceof EqPredicateProvider) {
1409                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));
1410                                  break checkProperty;
1411                              }
1412                          }
1413                      }
<abbr title="1414                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1414                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional propertðŸ”µ</abbr>
1415                              StringUtil.sanitize(expression),
1416                              StringUtil.sanitize(mappingProperty)));
1417                  }
1418              }
1419          }
1420  
1421          return restrictions;
1422      }
1423  
1424      /**
<abbr title="1425       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1425       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection fieldðŸ”µ</abbr>
1426       *
<abbr title="1427       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1427       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1428       * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1428       * @param specialExpression the String representation of the path for the collection field in the @Embeddable ðŸ”µ</abbr>
1429       * @param filterMappings all the fetch restrictions for this request
1430       * @return the list of restrictions on the collection in the @Embeddable object
1431       */
<abbr title="1432      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1432      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMapðŸ”µ</abbr>
1433          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1434          for (FilterMapping mapping : filterMappings) {
<abbr title="1435              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1435              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.geðŸ”µ</abbr>
1436                  FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1437                  if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1438                      Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1439                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1439                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().ðŸ”µ</abbr>
1440                      restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1441                  }
1442              }
1443          }
1444          return restrictions;
1445      }
1446  
1447      protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1448          //Remove the entity from ORM management - no further attempts to persist
1449          if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
1450              getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1451          }
1452          //Remove the id field value, if it&#x27;s set
<abbr title="1453          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1453          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClasðŸ”µ</abbr>
1454          Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1455          if (idField == null) {
<abbr title="1456              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1456              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getNameðŸ”µ</abbr>
1457          }
1458          idField.setAccessible(true);
1459          if (idField.get(instance) != null) {
1460              idField.set(instance, null);
1461          }
1462      }
1463  
1464      protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {
1465          Class&lt;?&gt; returnType = null;
<abbr title="1466          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1466          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName(ðŸ”µ</abbr>
1467          java.lang.reflect.Type type = field.getGenericType();
1468          if (type instanceof ParameterizedType) {
1469              ParameterizedType pType = (ParameterizedType) type;
1470              Class&lt;?&gt; clazz;
1471              if (pType.getActualTypeArguments().length &lt; 2) {
1472                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1473              } else {
1474                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1475              }
<abbr title="1476              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1476              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clðŸ”µ</abbr>
1477              if (!ArrayUtils.isEmpty(entities)) {
1478                  returnType = entities[entities.length - 1];
1479              }
1480          }
1481          return returnType;
1482      }
1483  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  
  19  package org.broadleafcommerce.openadmin.server.service.persistence.module;
  20  
  21  import org.apache.commons.beanutils.PropertyUtils;
  22  import org.apache.commons.collections.CollectionUtils;
  23  import org.apache.commons.lang.ArrayUtils;
  24  import org.apache.commons.lang.StringUtils;
  25  import org.apache.commons.lang3.BooleanUtils;
  26  import org.apache.commons.lang3.reflect.FieldUtils;
  27  import org.apache.commons.lang3.reflect.MethodUtils;
  28  import org.apache.commons.logging.Log;
  29  import org.apache.commons.logging.LogFactory;
  30  import org.broadleafcommerce.common.admin.domain.AdminMainEntity;
  31  import org.broadleafcommerce.common.exception.ExceptionHelper;
  32  import org.broadleafcommerce.common.exception.SecurityServiceException;
  33  import org.broadleafcommerce.common.exception.ServiceException;
  34  import org.broadleafcommerce.common.extension.ExtensionResultHolder;
  35  import org.broadleafcommerce.common.money.Money;
  36  import org.broadleafcommerce.common.presentation.client.OperationType;
  37  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  38  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  39  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  40  import org.broadleafcommerce.common.util.FormatUtil;
  41  import org.broadleafcommerce.common.util.StringUtil;
  42  import org.broadleafcommerce.common.util.ValidationUtil;
  43  import org.broadleafcommerce.common.util.dao.TQJoin;
  44  import org.broadleafcommerce.common.util.dao.TQOrder;
  45  import org.broadleafcommerce.common.util.dao.TQRestriction;
  46  import org.broadleafcommerce.common.util.dao.TypedQueryBuilder;
  47  import org.broadleafcommerce.common.web.BroadleafRequestContext;
  48  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  49  import org.broadleafcommerce.openadmin.dto.CriteriaTransferObject;
  50  import org.broadleafcommerce.openadmin.dto.DynamicResultSet;
  51  import org.broadleafcommerce.openadmin.dto.Entity;
  52  import org.broadleafcommerce.openadmin.dto.EntityResult;
  53  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  54  import org.broadleafcommerce.openadmin.dto.FilterAndSortCriteria;
  55  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  56  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  57  import org.broadleafcommerce.openadmin.dto.PersistencePackage;
  58  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  59  import org.broadleafcommerce.openadmin.dto.Property;
  60  import org.broadleafcommerce.openadmin.dto.SortDirection;

  61  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.AdvancedCollectionFieldMetadataProvider;
  62  import org.broadleafcommerce.openadmin.server.service.ValidationException;
  63  import org.broadleafcommerce.openadmin.server.service.persistence.ParentEntityPersistenceException;
  64  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceException;
  65  import org.broadleafcommerce.openadmin.server.service.persistence.PersistenceManager;
  66  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaConversionException;
  67  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.CriteriaTranslator;
  68  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath;
  69  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FilterMapping;
  70  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.RestrictionFactory;

  71  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.converter.FilterValueConverter;
  72  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.EqPredicateProvider;
  73  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.LikePredicateProvider;
  74  import org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.predicate.PredicateProvider;
<abbr title="  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionManager;">  75  import org.broadleafcommerce.openadmin.server.service.persistence.module.extension.BasicPersistenceModuleExtensionðŸ”µ</abbr>
  76  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.FieldPersistenceProvider;
<abbr title="  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequest;">  77  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddFilterPropertiesRequeðŸ”µ</abbr>
  78  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.AddSearchMappingRequest;
  79  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.ExtractValueRequest;
  80  import org.broadleafcommerce.openadmin.server.service.persistence.module.provider.request.PopulateValueRequest;
  81  import org.broadleafcommerce.openadmin.server.service.persistence.validation.EntityValidatorService;
  82  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PopulateValueRequestValidator;
  83  import org.broadleafcommerce.openadmin.server.service.persistence.validation.PropertyValidationResult;
  84  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  85  import org.hibernate.FlushMode;
  86  import org.hibernate.Session;
  87  import org.springframework.beans.BeansException;
  88  import org.springframework.context.ApplicationContext;
  89  import org.springframework.context.ApplicationContextAware;
  90  import org.springframework.context.annotation.Primary;
  91  import org.springframework.context.annotation.Scope;
  92  import org.springframework.stereotype.Component;
  93  import org.springframework.util.Assert;
  94  


  95  import java.io.Serializable;
  96  import java.lang.reflect.Field;
  97  import java.lang.reflect.InvocationTargetException;
  98  import java.lang.reflect.Method;
  99  import java.lang.reflect.ParameterizedType;
 100  import java.math.BigDecimal;
 101  import java.sql.Timestamp;
 102  import java.text.DecimalFormat;
 103  import java.text.NumberFormat;
 104  import java.text.SimpleDateFormat;
 105  import java.util.ArrayList;
 106  import java.util.Arrays;
 107  import java.util.Calendar;
 108  import java.util.Collection;
 109  import java.util.Collections;
 110  import java.util.Comparator;
 111  import java.util.Date;
 112  import java.util.HashMap;
 113  import java.util.List;
 114  import java.util.Locale;
 115  import java.util.Map;

 116  import java.util.Map.Entry;
 117  import java.util.StringTokenizer;
 118  
 119  import javax.annotation.PostConstruct;
 120  import javax.annotation.Resource;
 121  
 122  /**
 123   * @author jfischer
 124   */
 125  @Primary
 126  @Component(&quot;blBasicPersistenceModule&quot;)
 127  @Scope(&quot;prototype&quot;)
 128  public class BasicPersistenceModule implements PersistenceModule, RecordHelper, ApplicationContextAware {
 129  
 130      private static final Log LOG = LogFactory.getLog(BasicPersistenceModule.class);
 131  
 132      public static final String MAIN_ENTITY_NAME_PROPERTY = &quot;MAIN_ENTITY_NAME&quot;;
 133      public static final String ALTERNATE_ID_PROPERTY = &quot;ALTERNATE_ID&quot;;
 134  
 135      protected ApplicationContext applicationContext;
 136      protected PersistenceManager persistenceManager;
 137  
 138      @Resource(name = &quot;blEntityValidatorService&quot;)
 139      protected EntityValidatorService entityValidatorService;
 140  
 141      @Resource(name = &quot;blPersistenceProviders&quot;)
<abbr title=" 142      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;();"> 142      protected List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders = new ArrayList&lt;FieldPersistenceProvider&gt;()ðŸ”µ</abbr>
 143  
 144      @Resource(name = &quot;blPopulateValueRequestValidators&quot;)
 145      protected List&lt;PopulateValueRequestValidator&gt; populateValidators;
 146  
 147      @Resource(name = &quot;blDefaultFieldPersistenceProvider&quot;)
 148      protected FieldPersistenceProvider defaultFieldPersistenceProvider;
 149  
 150      @Resource(name = &quot;blCriteriaTranslator&quot;)
 151      protected CriteriaTranslator criteriaTranslator;
 152  
 153      @Resource(name = &quot;blRestrictionFactory&quot;)
 154      protected RestrictionFactory restrictionFactory;
 155  
 156      @Resource(name = &quot;blBasicPersistenceModuleExtensionManager&quot;)
 157      protected BasicPersistenceModuleExtensionManager extensionManager;
 158  
 159      @Resource(name = &quot;blFetchWrapper&quot;)
 160      protected FetchWrapper fetchWrapper;
 161  
 162      @PostConstruct
 163      public void init() {
 164          Collections.sort(fieldPersistenceProviders, new Comparator&lt;FieldPersistenceProvider&gt;() {
 165  
 166              @Override
 167              public int compare(FieldPersistenceProvider o1, FieldPersistenceProvider o2) {
 168                  return Integer.compare(o1.getOrder(), o2.getOrder());
 169              }
 170          });
 171          Collections.sort(populateValidators, new Comparator&lt;PopulateValueRequestValidator&gt;() {
 172  
 173              @Override
 174              public int compare(PopulateValueRequestValidator o1, PopulateValueRequestValidator o2) {
 175                  return Integer.compare(o1.getOrder(), o2.getOrder());
 176              }
 177          });
 178      }
 179  
 180      @Override
 181      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 182          this.applicationContext = applicationContext;
 183      }
 184  
 185      @Override
 186      public boolean isCompatible(OperationType operationType) {
 187          return OperationType.BASIC == operationType || OperationType.NONDESTRUCTIVEREMOVE == operationType;
 188      }
 189  
 190      @Override
 191      public FieldManager getFieldManager() {
 192          return persistenceManager.getDynamicEntityDao().getFieldManager();
 193      }
 194  
 195      @Override
 196      public DecimalFormat getDecimalFormatter() {
 197          BroadleafRequestContext brc = BroadleafRequestContext.getBroadleafRequestContext();
 198          Locale locale = brc.getJavaLocale();
 199          DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(locale);
 200          format.applyPattern(&quot;0.########&quot;);
 201          format.setGroupingUsed(false);
 202          return format;
 203      }
 204  
 205      @Override
 206      public SimpleDateFormat getSimpleDateFormatter() {
 207          return FormatUtil.getDateFormat();
 208      }
 209  
 210      protected Map&lt;String, FieldMetadata&gt; filterOutCollectionMetadata(Map&lt;String, FieldMetadata&gt; metadata) {
 211          if (metadata == null) {
 212              return null;
 213          }
 214          Map&lt;String, FieldMetadata&gt; newMap = new HashMap&lt;String, FieldMetadata&gt;();
 215          for (Map.Entry&lt;String, FieldMetadata&gt; entry : metadata.entrySet()) {
 216              String fieldName = entry.getKey();
 217              FieldMetadata md = entry.getValue();
<abbr title=" 218              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but also corresponds"> 218              // Detect instances where the actual metadata for the field is some sort of CollectionMetadata but alsðŸ”µ</abbr>
<abbr title=" 219              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistenceModule}"> 219              // to a ForeignKey and ensure that gets included in the filtered map. That way the {@link BasicPersistðŸ”µ</abbr>
 220              // can appropriate handle filtration and population
 221              if (entry.getValue() instanceof BasicFieldMetadata) {
 222                  newMap.put(fieldName, md);
<abbr title=" 223              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY)) {"> 223              } else if (md.getAdditionalMetadata().containsKey(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ðŸ”µ</abbr>
 224                  newMap.put(fieldName,
<abbr title=" 225                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvider.FOREIGN_KEY_ADDITIONAL_METADATA_KEY));"> 225                          (BasicFieldMetadata) md.getAdditionalMetadata().get(AdvancedCollectionFieldMetadataProvideðŸ”µ</abbr>
 226              }
 227          }
 228  
 229          return newMap;
 230      }
 231  
 232      protected Class&lt;?&gt; getBasicBroadleafType(SupportedFieldType fieldType) {
 233          Class&lt;?&gt; response;
 234          switch (fieldType) {
 235              case BOOLEAN:
 236                  response = Boolean.TYPE;
 237                  break;
 238              case DATE:
 239                  response = Date.class;
 240                  break;
 241              case DECIMAL:
 242                  response = BigDecimal.class;
 243                  break;
 244              case MONEY:
 245                  response = Money.class;
 246                  break;
 247              case INTEGER:
 248                  response = Integer.TYPE;
 249                  break;
 250              case UNKNOWN:
 251                  response = null;
 252                  break;
 253              default:
 254                  response = String.class;
 255                  break;
 256          }
 257  
 258          return response;
 259      }
 260  
 261      @Override
 262      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
 263              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId) throws ValidationException {
 264          return createPopulatedInstance(instance, entity, unfilteredProperties, setId, true);
 265      }
 266  
 267      @Override
 268      public Serializable createPopulatedInstance(Serializable instance, Entity entity,
<abbr title=" 269              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties) throws ValidationException {"> 269              Map&lt;String, FieldMetadata&gt; unfilteredProperties, Boolean setId, Boolean validateUnsubmittedProperties)ðŸ”µ</abbr>
 270          final Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(unfilteredProperties);
 271          FieldManager fieldManager = getFieldManager();
 272          boolean handled = false;
 273          for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
<abbr title=" 274              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 274              MetadataProviderResponse response = fieldPersistenceProvider.filterProperties(new AddFilterPropertiesRðŸ”µ</abbr>
 275              if (MetadataProviderResponse.NOT_HANDLED != response) {
 276                  handled = true;
 277              }
 278              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 279                  break;
 280              }
 281          }
 282          if (!handled) {
<abbr title=" 283              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProperties);"> 283              defaultFieldPersistenceProvider.filterProperties(new AddFilterPropertiesRequest(entity), unfilteredProðŸ”µ</abbr>
 284          }
<abbr title=" 285          //Order media field, map field and rule builder fields last, as they will have some validation components that depend on previous values"> 285          //Order media field, map field and rule builder fields last, as they will have some validation components ðŸ”µ</abbr>
 286          Property[] sortedProperties = entity.getProperties();
 287          Arrays.sort(sortedProperties, new Comparator&lt;Property&gt;() {
 288  
 289              @Override
 290              public int compare(Property o1, Property o2) {
 291                  BasicFieldMetadata mo1 = (BasicFieldMetadata) mergedProperties.get(o1.getName());
 292                  BasicFieldMetadata mo2 = (BasicFieldMetadata) mergedProperties.get(o2.getName());
<abbr title=" 293                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo1.getFieldType() ||"> 293                  boolean isLate1 = mo1 != null &amp;&amp; mo1.getFieldType() != null &amp;&amp; mo1.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 294                          SupportedFieldType.RULE_WITH_QUANTITY==mo1.getFieldType() ||
 295                          SupportedFieldType.RULE_SIMPLE_TIME==mo1.getFieldType() ||
<abbr title=" 296                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 296                          SupportedFieldType.MEDIA==mo1.getFieldType() || o1.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
<abbr title=" 297                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedFieldType.RULE_SIMPLE==mo2.getFieldType() ||"> 297                  boolean isLate2 = mo2 != null &amp;&amp; mo2.getFieldType() != null &amp;&amp; mo2.getName() != null &amp;&amp; (SupportedðŸ”µ</abbr>
 298                          SupportedFieldType.RULE_WITH_QUANTITY==mo2.getFieldType() ||
 299                          SupportedFieldType.RULE_SIMPLE_TIME==mo2.getFieldType() ||
<abbr title=" 300                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELDSEPARATOR));"> 300                          SupportedFieldType.MEDIA==mo2.getFieldType() || o2.getName().contains(FieldManager.MAPFIELðŸ”µ</abbr>
 301                  if (isLate1 &amp;&amp; !isLate2) {
 302                      return 1;
 303                  } else if (!isLate1 &amp;&amp; isLate2) {
 304                      return -1;
 305                  }
 306                  return 0;
 307              }
 308          });
<abbr title=" 309          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.class);"> 309          Session session = getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().unwrap(Session.ðŸ”µ</abbr>
 310          FlushMode originalFlushMode = session.getFlushMode();

 311          try {
 312              session.setFlushMode(FlushMode.MANUAL);

 313              RuntimeException entityPersistenceException = null;
 314              for (Property property : sortedProperties) {
 315                  BasicFieldMetadata metadata = (BasicFieldMetadata) mergedProperties.get(property.getName());
 316                  Class&lt;?&gt; returnType;
<abbr title=" 317                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWith(&quot;__&quot;)) {"> 317                  if (!property.getName().contains(FieldManager.MAPFIELDSEPARATOR) &amp;&amp; !property.getName().startsWithðŸ”µ</abbr>
 318                      Field field = fieldManager.getField(instance.getClass(), property.getName());
 319                      if (field == null) {
<abbr title=" 320                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 320                          LOG.debug(&quot;Unable to find a bean property for the reported property: &quot; + StringUtil.sanitiðŸ”µ</abbr>
 321                          continue;
 322                      }
 323                      returnType = field.getType();
 324                  } else {
 325                      if (metadata == null) {
<abbr title=" 326                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.sanitize(property.getName()) + &quot;. Ignoring property.&quot;);"> 326                          LOG.debug(&quot;Unable to find a metadata property for the reported property: &quot; + StringUtil.saðŸ”µ</abbr>
 327                          continue;
 328                      }
 329                      returnType = getMapFieldType(instance, fieldManager, property);
 330                      if (returnType == null) {
 331                          returnType = getBasicBroadleafType(metadata.getFieldType());
 332                      }
 333                  }
 334                  if (returnType == null) {
<abbr title=" 335                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + property.getName() + &quot;)&quot;);"> 335                      throw new IllegalAccessException(&quot;Unable to determine the value type for the property (&quot; + proðŸ”µ</abbr>
 336                  }
 337                  String value = property.getValue();
 338                  if (metadata != null) {
 339  
 340                      if (metadata.getFieldType().equals(SupportedFieldType.BOOLEAN)) {
 341                          if (value == null) {
 342                              value = &quot;false&quot;;


 343                          }
 344                      } else if (metadata.getFieldType().equals(SupportedFieldType.DATE)) {
 345                          if (StringUtils.isEmpty(value)) {
 346                              value = null;
 347                          }
 348                      }
 349  
<abbr title=" 350                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) {"> 350                      if (attemptToPopulateValue(property, fieldManager, instance, setId, metadata, entity, value)) ðŸ”µ</abbr>
 351                          boolean isValid = true;
<abbr title=" 352                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd());"> 352                          PopulateValueRequest request = new PopulateValueRequest(setId, fieldManager, property, metðŸ”µ</abbr>
 353                          handled = false;
 354                          if (value != null) {
 355                              for (PopulateValueRequestValidator validator : populateValidators) {
 356                                  PropertyValidationResult validationResult = validator.validate(request, instance);
 357                                  if (!validationResult.isValid()) {
<abbr title=" 358                                      entity.addValidationError(property.getName(), validationResult.getErrorMessage());"> 358                                      entity.addValidationError(property.getName(), validationResult.getErrorMessageðŸ”µ</abbr>
 359                                      isValid = false;
 360                                  }
 361                              }
 362                          }
 363                          if (isValid) {
 364                              try {
 365                                  boolean isBreakDetected = false;
<abbr title=" 366                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {"> 366                                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProvidersðŸ”µ</abbr>
<abbr title=" 367                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != null || fieldPersistenceProvider.canHandlePopulateNull())) {"> 367                                      if ((!isBreakDetected || fieldPersistenceProvider.alwaysRun()) &amp;&amp; (value != nuðŸ”µ</abbr>
<abbr title=" 368                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValue(request, instance);"> 368                                          MetadataProviderResponse response = fieldPersistenceProvider.populateValueðŸ”µ</abbr>
 369                                          if (MetadataProviderResponse.NOT_HANDLED != response) {
 370                                              handled = true;
 371                                          }
 372                                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
 373                                              isBreakDetected = true;
 374                                          }
 375                                      }
 376                                  }
 377                                  if (!handled) {
 378                                      if (value == null) {
 379                                          property.setIsDirty(true);
 380                                      }
<abbr title=" 381                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, fieldManager, property, metadata, returnType, value, persistenceManager, this, entity.isPreAdd()), instance);"> 381                                      defaultFieldPersistenceProvider.populateValue(new PopulateValueRequest(setId, ðŸ”µ</abbr>
 382                                      if (value == null) {
 383                                          fieldManager.setFieldValue(instance, property.getName(), null);
 384                                      }
 385                                  }
 386                              } catch (ParentEntityPersistenceException | javax.validation.ValidationException e) {
 387                                  entityPersistenceException = e;
 388                                  cleanupFailedPersistenceAttempt(instance);
 389                                  break;
 390                              }
 391                          }
 392                      }
 393                  }
 394              }
 395              // Only check validation if not the initial add
 396              if (!entity.isPreAdd()) {
 397                  validate(entity, instance, mergedProperties, validateUnsubmittedProperties);
 398              }
 399              //if validation failed, refresh the current instance so that none of the changes will be persisted
 400              if (entity.isValidationFailure()) {
 401                  //only refresh the instance if it was managed to begin with
 402                  if (persistenceManager.getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
 403                      persistenceManager.getDynamicEntityDao().refresh(instance);
 404                  }
 405  
 406                  //re-initialize the valid properties for the entity in order to deal with the potential of not
 407                  //completely sending over all checkbox/radio fields
 408                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 409                  entityList.add(instance);
 410                  Entity invalid = getRecords(mergedProperties, entityList, null, null, null)[0];
 411                  invalid.setPropertyValidationErrors(entity.getPropertyValidationErrors());
 412                  invalid.setGlobalValidationErrors(entity.getGlobalValidationErrors());
 413                  invalid.overridePropertyValues(entity);
 414  
<abbr title=" 415                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.getGlobalValidationErrors());"> 415                  String message = ValidationUtil.buildErrorMessage(invalid.getPropertyValidationErrors(), invalid.gðŸ”µ</abbr>
 416                  throw new ValidationException(invalid, message);
 417              } else if (entityPersistenceException != null) {
 418                  throw ExceptionHelper.refineException(entityPersistenceException.getCause());
 419              } else {
 420                  fieldManager.persistMiddleEntities();
 421              }
 422          } catch (IllegalAccessException e) {
 423              throw new PersistenceException(e);
 424          } catch (InstantiationException e) {
 425              throw new PersistenceException(e);
 426          } finally {
 427              session.setFlushMode(originalFlushMode);

 428          }
 429          return instance;
 430      }
 431  
 432      protected boolean attemptToPopulateValue(Property property, FieldManager fieldManager, Serializable instance,
<abbr title=" 433                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String value) throws IllegalAccessException {"> 433                                               Boolean setId, BasicFieldMetadata metadata, Entity entity, String valðŸ”µ</abbr>
 434          Boolean mutable = metadata.getMutable();
 435          Boolean readOnly = metadata.getReadOnly();
<abbr title=" 436          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; property.getEnabled();"> 436          boolean generalConditionsMet = (mutable == null || mutable) &amp;&amp; (readOnly == null || !readOnly) &amp;&amp; propertyðŸ”µ</abbr>
 437  
 438          if (generalConditionsMet &amp;&amp; value == null) {
 439              boolean currentValueIsNotNull = false;
 440              try {
 441                  currentValueIsNotNull = fieldManager.getFieldValue(instance, property.getName()) != null;
 442              } catch (FieldNotAvailableException e) {
 443                  throw new IllegalArgumentException(e);
 444              }
 445  
 446              boolean valueIsNotNullId = metadata.getFieldType() != SupportedFieldType.ID || setId;
 447              boolean valueIsNotPassword = metadata.getFieldType() != SupportedFieldType.PASSWORD;
 448  
 449              return currentValueIsNotNull &amp;&amp; !entity.isPreAdd() &amp;&amp; valueIsNotNullId &amp;&amp; valueIsNotPassword;
 450          }
 451          return generalConditionsMet;
 452      }
 453  
 454      @Override
<abbr title=" 455      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FieldMetadata&gt; alternateMergedProperties, String pathToTargetObject) {"> 455      public Entity getRecord(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, Serializable record, Map&lt;String, FðŸ”µ</abbr>
 456          List&lt;Serializable&gt; records = new ArrayList&lt;Serializable&gt;(1);
 457          records.add(record);
<abbr title=" 458          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTargetObject, null);"> 458          Entity[] productEntities = getRecords(primaryMergedProperties, records, alternateMergedProperties, pathToTðŸ”µ</abbr>
 459          return productEntities[0];
 460      }
 461  
 462      @Override
<abbr title=" 463      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, Serializable record) {"> 463      public Entity getRecord(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, SerializabðŸ”µ</abbr>
<abbr title=" 464          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 464          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 465          return getRecord(mergedProperties, record, null, null);
 466      }
 467  
 468      @Override
<abbr title=" 469      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? extends Serializable&gt; records) {"> 469      public Entity[] getRecords(Class&lt;?&gt; ceilingEntityClass, PersistencePerspective persistencePerspective, List&lt;? ðŸ”µ</abbr>
<abbr title=" 470          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persistencePerspective);"> 470          Map&lt;String, FieldMetadata&gt; mergedProperties = getSimpleMergedProperties(ceilingEntityClass.getName(), persðŸ”µ</abbr>
 471          return getRecords(mergedProperties, records, null, null, null);
 472      }
 473  
 474      @Override
<abbr title=" 475      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 475      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
<abbr title=" 476          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspective);"> 476          return persistenceManager.getDynamicEntityDao().getSimpleMergedProperties(entityName, persistencePerspectiðŸ”µ</abbr>
 477      }
 478  
 479      @Override
<abbr title=" 480      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; records) {"> 480      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryMergedProperties, List&lt;? extends Serializable&gt; reðŸ”µ</abbr>
 481          return getRecords(primaryMergedProperties, records, null, null, null);
 482      }
 483  
 484      @Override
 485      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 486                                 List&lt;? extends Serializable&gt; records,
 487                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 488                                 String pathToTargetObject) {
<abbr title=" 489          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTargetObject, null);"> 489          return getRecords(primaryUnfilteredMergedProperties, records, alternateUnfilteredMergedProperties, pathToTðŸ”µ</abbr>
 490      }
 491  
 492      @Override
 493      public Entity[] getRecords(Map&lt;String, FieldMetadata&gt; primaryUnfilteredMergedProperties,
 494                                 List&lt;? extends Serializable&gt; records,
 495                                 Map&lt;String, FieldMetadata&gt; alternateUnfilteredMergedProperties,
 496                                 String pathToTargetObject,
 497                                 String[] customCriteria) {
<abbr title=" 498          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedProperties);"> 498          Map&lt;String, FieldMetadata&gt; primaryMergedProperties = filterOutCollectionMetadata(primaryUnfilteredMergedPrðŸ”µ</abbr>
<abbr title=" 499          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergedProperties);"> 499          Map&lt;String, FieldMetadata&gt; alternateMergedProperties = filterOutCollectionMetadata(alternateUnfilteredMergðŸ”µ</abbr>
 500          Entity[] entities = new Entity[records.size()];
 501          int j = 0;
 502          for (Serializable recordEntity : records) {
 503              Serializable entity;
 504              if (pathToTargetObject != null) {
 505                  try {
 506                      entity = (Serializable) getFieldManager().getFieldValue(recordEntity, pathToTargetObject);
 507                  } catch (Exception e) {
 508                      throw new PersistenceException(e);
 509                  }
 510              } else {
 511                  entity = recordEntity;
 512              }
 513              Entity entityItem = new Entity();
 514              entityItem.setType(new String[] { entity.getClass().getName() });
 515              entities[j] = entityItem;
 516  
 517              List&lt;Property&gt; props = new ArrayList&lt;Property&gt;(primaryMergedProperties.size());
 518              extractPropertiesFromPersistentEntity(primaryMergedProperties, entity, props, customCriteria);
 519              if (alternateMergedProperties != null) {
<abbr title=" 520                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriteria);"> 520                  extractPropertiesFromPersistentEntity(alternateMergedProperties, recordEntity, props, customCriterðŸ”µ</abbr>
 521              }
 522  
 523              // Try to add the &quot;main name&quot; property. Log a debug message if we can&#x27;t
 524              try {
 525                  Property p = new Property();
 526                  p.setName(MAIN_ENTITY_NAME_PROPERTY);
 527                  String mainEntityName = (String) MethodUtils.invokeMethod(entity, &quot;getMainEntityName&quot;);
 528                  p.setValue(mainEntityName);
 529                  props.add(p);
 530              } catch (Exception e) {
 531                  LOG.debug(String.format(&quot;Could not execute the getMainEntityName() method for [%s]&quot;,
 532                          entity.getClass().getName()), e);
 533              }
 534  
 535              // Try to add the alternate id property if available
 536              if (alternateMergedProperties != null) {
 537                  for (Entry&lt;String, FieldMetadata&gt; entry : alternateMergedProperties.entrySet()) {
 538                      if (entry.getValue() instanceof BasicFieldMetadata) {
 539                          if (((BasicFieldMetadata) entry.getValue()).getFieldType() == SupportedFieldType.ID) {
 540                              Map&lt;String, FieldMetadata&gt; alternateOnEntity = new HashMap&lt;String, FieldMetadata&gt;();
 541                              alternateOnEntity.put(entry.getKey(), entry.getValue());
 542                              List&lt;Property&gt; props2 = new ArrayList&lt;Property&gt;();
<abbr title=" 543                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCriteria);"> 543                              extractPropertiesFromPersistentEntity(alternateOnEntity, recordEntity, props2, customCðŸ”µ</abbr>
 544                              List&lt;Property&gt; filtered = new ArrayList&lt;Property&gt;();
 545                              for (Property prop : props2) {
 546                                  if (!prop.getName().startsWith(&quot;__&quot;)) {
 547                                      filtered.add(prop);
 548                                  }
 549                              }
 550                              if (filtered.size() == 1 &amp;&amp; !filtered.get(0).getName().contains(&quot;.&quot;)) {
 551                                  Property alternateIdProp = filtered.get(0);
 552                                  alternateIdProp.setName(ALTERNATE_ID_PROPERTY);
 553                                  props.add(alternateIdProp);
 554                              }
 555                          }
 556                      }
 557                  }
 558              }
 559  
 560              Property[] properties = new Property[props.size()];
 561              properties = props.toArray(properties);
 562              entityItem.setProperties(properties);
 563              j++;
 564          }
 565  
 566          return entities;
 567      }
 568  
 569      @Override
 570      public Entity[] getRecords(FetchExtractionRequest fetchExtractionRequest) {
 571          return fetchWrapper.getRecords(fetchExtractionRequest);
 572      }
 573  
 574      protected void extractPropertiesFromPersistentEntity(Map&lt;String, FieldMetadata&gt; mergedProperties,
 575                                                           Serializable entity,
 576                                                           List&lt;Property&gt; props,
 577                                                           String[] customCriteria) {
 578          FieldManager fieldManager = getFieldManager();
 579          try {
 580              if (entity instanceof AdminMainEntity) {
 581                  //Create an invisible property for the admin main entity name, if applicable.
 582                  //This is useful for ToOneLookups if that ToOneLookup uses AdminMainEntity to drive
 583                  //its display name.
 584                  try {
 585                      Property propertyItem = new Property();
 586                      propertyItem.setName(AdminMainEntity.MAIN_ENTITY_NAME_PROPERTY);
 587                      propertyItem.setValue(((AdminMainEntity) entity).getMainEntityName());
 588                      props.add(propertyItem);
 589                  } catch (Exception e) {
<abbr title=" 590                      //do nothing here except for not add the property. Exceptions could occur when there is a validation"> 590                      //do nothing here except for not add the property. Exceptions could occur when there is a valiðŸ”µ</abbr>
<abbr title=" 591                      //issue and some properties/relationships that are used for gleaning the main entity name end up"> 591                      //issue and some properties/relationships that are used for gleaning the main entity name end ðŸ”µ</abbr>
 592                      //not being set
 593                  }
 594              }
 595              for (Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 596                  String property = entry.getKey();
 597                  BasicFieldMetadata metadata = (BasicFieldMetadata) entry.getValue();
<abbr title=" 598                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.getClass().isAssignableFrom(Class.forName(metadata.getInheritedFromType()))) {"> 598                  if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(entity.getClass()) || entity.gðŸ”µ</abbr>
 599                      boolean proceed = true;
 600                      if (property.contains(&quot;.&quot;)) {
 601                          StringTokenizer tokens = new StringTokenizer(property, &quot;.&quot;);
 602                          Object testObject = entity;
 603                          while (tokens.hasMoreTokens()) {
 604                              String token = tokens.nextToken();
 605                              if (tokens.hasMoreTokens()) {
 606                                  try {
 607                                      testObject = fieldManager.getFieldValue(testObject, token);
 608                                  } catch (FieldNotAvailableException e) {
 609                                      proceed = false;
 610                                      break;
 611                                  }
 612                                  if (testObject == null) {
 613                                      Property propertyItem = new Property();
 614                                      propertyItem.setName(property);
 615                                      if (props.contains(propertyItem)) {
 616                                          proceed = false;
 617                                          break;
 618                                      }
 619                                      propertyItem.setValue(null);
 620                                      props.add(propertyItem);
 621                                      proceed = false;
 622                                      break;
 623                                  }
 624                              }
 625                          }
 626                      }
 627                      if (!proceed) {
 628                          continue;
 629                      }
 630  
 631                      boolean isFieldAccessible = true;
 632                      Object value = null;
 633                      try {
 634                          value = fieldManager.getFieldValue(entity, property);
 635                      } catch (FieldNotAvailableException e) {
 636                          isFieldAccessible = false;
 637                      }
 638                      checkField:
 639                      {
 640                          if (isFieldAccessible) {
 641                              Property propertyItem = new Property();
 642                              propertyItem.setName(property);
 643                              if (props.contains(propertyItem)) {
 644                                  continue;
 645                              }
 646                              props.add(propertyItem);
 647                              String displayVal = propertyItem.getDisplayValue();
 648                              boolean handled = false;
 649                              for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 650                                  MetadataProviderResponse response = fieldPersistenceProvider.extractValue(
 651                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 652                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 653                                  if (MetadataProviderResponse.NOT_HANDLED != response) {
 654                                      handled = true;
 655                                  }
 656                                  if (MetadataProviderResponse.HANDLED_BREAK == response) {
 657                                      break;
 658                                  }
 659                              }
 660                              if (!handled) {
 661                                  defaultFieldPersistenceProvider.extractValue(
 662                                          new ExtractValueRequest(props, fieldManager, metadata, value, displayVal,
 663                                                  persistenceManager, this, entity, customCriteria), propertyItem);
 664                              }
 665                              break checkField;
 666                          }
 667                          //try a direct property acquisition via reflection
 668                          try {
 669                              String strVal = null;
 670                              Method method;
 671                              try {
 672                                  //try a &#x27;get&#x27; prefixed mutator first
<abbr title=" 673                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(1, property.length());"> 673                                  String temp = &quot;get&quot; + property.substring(0, 1).toUpperCase() + property.substring(ðŸ”µ</abbr>
 674                                  method = entity.getClass().getMethod(temp, new Class[] {});
 675                              } catch (NoSuchMethodException e) {
 676                                  method = entity.getClass().getMethod(property, new Class[] {});
 677                              }
 678                              value = method.invoke(entity, new String[] {});
 679                              Property propertyItem = new Property();
 680                              propertyItem.setName(property);
 681                              if (props.contains(propertyItem)) {
 682                                  continue;
 683                              }
 684                              props.add(propertyItem);
 685                              if (value == null) {
 686                                  strVal = null;
 687                              } else {
 688                                  if (Date.class.isAssignableFrom(value.getClass())) {
 689                                      strVal = getSimpleDateFormatter().format((Date) value);
 690                                  } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
<abbr title=" 691                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));"> 691                                      strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime(ðŸ”µ</abbr>
 692                                  } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 693                                      strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 694                                  } else if (Double.class.isAssignableFrom(value.getClass())) {
 695                                      strVal = getDecimalFormatter().format(value);
 696                                  } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 697                                      strVal = getDecimalFormatter().format(value);
 698                                  } else {
 699                                      strVal = value.toString();
 700                                  }
 701                              }
 702                              propertyItem.setValue(strVal);
 703                          } catch (NoSuchMethodException e) {
<abbr title=" 704                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(property));"> 704                              LOG.debug(&quot;Unable to find a specified property in the entity: &quot; + StringUtil.sanitize(ðŸ”µ</abbr>
 705                              //do nothing - this property is simply not in the bean
 706                          }
 707                      }
 708                  }
 709              }
 710          } catch (ClassNotFoundException e) {
 711              throw new PersistenceException(e);
 712          } catch (IllegalAccessException e) {
 713              throw new PersistenceException(e);
 714          } catch (InvocationTargetException e) {
 715              throw new PersistenceException(e);
 716          }
 717      }
 718  
 719      @Override
 720      public String getStringValueFromGetter(Serializable instance, String propertyName)
 721              throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
 722          Object value = PropertyUtils.getProperty(instance, propertyName);
 723          return formatValue(value);
 724      }
 725  
 726      @Override
 727      public String formatValue(Object value) {
 728          String strVal;
 729          if (value == null) {
 730              strVal = null;
 731          } else {
 732              if (Date.class.isAssignableFrom(value.getClass())) {
 733                  strVal = getSimpleDateFormatter().format((Date) value);
 734              } else if (Timestamp.class.isAssignableFrom(value.getClass())) {
 735                  strVal = getSimpleDateFormatter().format(new Date(((Timestamp) value).getTime()));
 736              } else if (Calendar.class.isAssignableFrom(value.getClass())) {
 737                  strVal = getSimpleDateFormatter().format(((Calendar) value).getTime());
 738              } else if (Double.class.isAssignableFrom(value.getClass())) {
 739                  strVal = getDecimalFormatter().format(value);
 740              } else if (BigDecimal.class.isAssignableFrom(value.getClass())) {
 741                  strVal = getDecimalFormatter().format(value);
 742              } else {
 743                  strVal = value.toString();
 744              }
 745          }
 746          return strVal;
 747      }
 748  
<abbr title=" 749      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntity) throws ServiceException {"> 749      protected EntityResult update(PersistencePackage persistencePackage, Object primaryKey, boolean includeRealEntðŸ”µ</abbr>
 750          EntityResult entityResult = new EntityResult();
 751          Entity entity = persistencePackage.getEntity();
 752          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title=" 753          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);"> 753          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
 754          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
 755              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
 756          }
 757          try {
<abbr title=" 758              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());"> 758              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title=" 759              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 759              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 760                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
 761                      entities,
 762                      foreignKey,
 763                      persistencePerspective.getAdditionalNonPersistentProperties(),
 764                      persistencePerspective.getAdditionalForeignKeys(),
 765                      MergedPropertyType.PRIMARY,
 766                      persistencePerspective.getPopulateToOneFields(),
 767                      persistencePerspective.getIncludeFields(),
 768                      persistencePerspective.getExcludeFields(),
 769                      persistencePerspective.getConfigurationKey(),
 770                      &quot;&quot;
 771                      );
 772              if (primaryKey == null) {
 773                  primaryKey = getPrimaryKey(entity, mergedProperties);
 774              }
<abbr title=" 775              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);"> 775              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
 776  
 777              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
 778  
 779              if (!entity.isValidationFailure()) {
 780                  //Re-Balance the list if it is a Foreign Key toMany collection with a sort field property
 781                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null &amp;&amp;
 782                          entity.findProperty(foreignKey.getSortField()) != null &amp;&amp;
 783                          entity.findProperty(foreignKey.getSortField()).getValue() != null) {
 784                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
 785                      extensionManager.getProxy().rebalanceForUpdate(this, persistencePackage, instance,
 786                              mergedProperties, primaryKey, result);
 787                      instance = result.getResult();
 788                  } else {
<abbr title=" 789                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackage.isValidateUnsubmittedProperties());"> 789                      instance = createPopulatedInstance(instance, entity, mergedProperties, false, persistencePackaðŸ”µ</abbr>
 790                  }
 791  
 792                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
 793                  if (includeRealEntity) {
 794                      entityResult.setEntityBackingObject(instance);
 795                  }
 796  
 797                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
 798                  entityList.add(instance);
 799  
 800                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
 801                  entityResult.setEntity(entity);
 802                  return entityResult;
 803              } else {
 804                  entityResult.setEntity(entity);
 805                  return entityResult;
 806              }
 807          } catch (Exception e) {
 808              throw new ServiceException(&quot;Problem updating entity : &quot; + e.getMessage(), e);
 809          }
 810      }
 811  
 812      @Override
 813      public String getIdPropertyName(String entityClass) {
 814          return persistenceManager.getIdPropertyName(entityClass);
 815      }
 816  
 817      public String getIdPropertyName(Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 818          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 819          for (String property : mergedProperties.keySet()) {
 820              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 821              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 822                  return property;
 823              }
 824          }
 825  
 826          throw new RuntimeException(&quot;Could not find a primary key property in the passed merged properties list&quot;);
 827      }
 828  
 829      @Override
 830      public Object getPrimaryKey(Entity entity, Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
 831          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 832          Object primaryKey = null;
 833          String idPropertyName = null;
 834          BasicFieldMetadata metaData = null;
 835          for (String property : mergedProperties.keySet()) {
 836              BasicFieldMetadata temp = (BasicFieldMetadata) mergedProperties.get(property);
 837              if (temp.getFieldType() == SupportedFieldType.ID &amp;&amp; !property.contains(&quot;.&quot;)) {
 838                  idPropertyName = property;
 839                  metaData = temp;
 840                  break;
 841              }
 842          }
 843          if (idPropertyName == null) {
<abbr title=" 844              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);"> 844              throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + ðŸ”µ</abbr>
 845          }
 846          for (Property property : entity.getProperties()) {
 847              if (property.getName().equals(idPropertyName)) {
 848                  switch (metaData.getSecondaryType()) {
 849                      case INTEGER:
 850                          primaryKey = (property.getValue() == null) ? null : Long.valueOf(property.getValue());
 851                          break;
 852                      case STRING:
 853                          primaryKey = property.getValue();
 854                          break;
 855                  }
 856                  break;
 857              }
 858          }
 859          if (primaryKey == null) {
<abbr title=" 860              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the passed entity with type: &quot; + entity.getType()[0]);"> 860              throw new RuntimeException(&quot;Could not find the primary key property (&quot; + idPropertyName + &quot;) in the paðŸ”µ</abbr>
 861          }
 862          return primaryKey;
 863      }
 864  
 865      @Override
 866      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 867              CriteriaTransferObject cto,
 868              String ceilingEntityFullyQualifiedClassname,
 869              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties,
 870              RestrictionFactory customRestrictionFactory) {
 871          Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
 872          List&lt;FilterMapping&gt; filterMappings = new ArrayList&lt;FilterMapping&gt;();
 873  
 874          for (String propertyId : cto.getCriteriaMap().keySet()) {
 875              if (mergedProperties.containsKey(propertyId)) {
 876                  boolean handled = false;
 877                  for (FieldPersistenceProvider fieldPersistenceProvider : fieldPersistenceProviders) {
 878                      MetadataProviderResponse response = fieldPersistenceProvider.addSearchMapping(
 879                              new AddSearchMappingRequest(persistencePerspective, cto,
 880                                      ceilingEntityFullyQualifiedClassname, mergedProperties,
<abbr title=" 881                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restrictionFactory"> 881                                      propertyId, getFieldManager(), this, this, customRestrictionFactory==null?restðŸ”µ</abbr>
 882                                      :customRestrictionFactory), filterMappings);
 883                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 884                          handled = true;
 885                      }
 886                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 887                          break;
 888                      }
 889                  }
 890                  if (!handled) {
 891                      defaultFieldPersistenceProvider.addSearchMapping(
 892                              new AddSearchMappingRequest(persistencePerspective, cto,
 893                                      ceilingEntityFullyQualifiedClassname, mergedProperties, propertyId,
<abbr title=" 894                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFactory"> 894                                      getFieldManager(), this, this, customRestrictionFactory == null ? restrictionFðŸ”µ</abbr>
 895                                              : customRestrictionFactory), filterMappings);
 896                  }
 897              }
 898          }
 899          return filterMappings;
 900      }
 901  
 902      @Override
 903      public List&lt;FilterMapping&gt; getFilterMappings(PersistencePerspective persistencePerspective,
 904              CriteriaTransferObject cto,
 905              String ceilingEntityFullyQualifiedClassname,
 906              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties) {
<abbr title=" 907          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilteredProperties, null);"> 907          return getFilterMappings(persistencePerspective, cto, ceilingEntityFullyQualifiedClassname, mergedUnfilterðŸ”µ</abbr>
 908      }
 909  
 910      @Override
<abbr title=" 911      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; mergedProperties, List&lt;Property&gt; properties) {"> 911      public void extractProperties(Class&lt;?&gt;[] inheritanceLine, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; ðŸ”µ</abbr>
<abbr title=" 912          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), properties, false, MergedPropertyType.PRIMARY);"> 912          extractPropertiesFromMetadata(inheritanceLine, mergedProperties.get(MergedPropertyType.PRIMARY), propertieðŸ”µ</abbr>
 913      }
 914  
<abbr title=" 915      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Property&gt; properties, Boolean isHiddenOverride, MergedPropertyType type) {"> 915      protected void extractPropertiesFromMetadata(Class&lt;?&gt;[] inheritanceLine, Map&lt;String, FieldMetadata&gt; mergedPropðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +        Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +            public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +                return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +        Collections.sort(properties, comparator);</span>

 924          for (Map.Entry&lt;String, FieldMetadata&gt; entry : mergedProperties.entrySet()) {
 925              String property = entry.getKey();
 926              Property prop = new Property();
 927              FieldMetadata metadata = mergedProperties.get(property);
 928              prop.setName(property);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 929 -            Comparator&lt;Property&gt; comparator = new Comparator&lt;Property&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 930 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 931 -                @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 932 -                public int compare(Property o1, Property o2) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 933 -                    return o1.getName().compareTo(o2.getName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 934 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 935 -            };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 936 -            Collections.sort(properties, comparator);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 937 +</span>
 938              int pos = Collections.binarySearch(properties, prop, comparator);
<abbr title=" 939              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != type) {"> 939              if (pos &gt;= 0 &amp;&amp; MergedPropertyType.MAPSTRUCTUREKEY != type &amp;&amp; MergedPropertyType.MAPSTRUCTUREVALUE != ðŸ”µ</abbr>
 940                  logWarn: {
<abbr title=" 941                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadata) metadata).getFieldType())) {"> 941                      if ((metadata instanceof BasicFieldMetadata) &amp;&amp; SupportedFieldType.ID.equals(((BasicFieldMetadðŸ”µ</abbr>
 942                          //don&#x27;t warn for id field collisions, but still ignore the colliding fields
 943                          break logWarn;
 944                      }
<abbr title=" 945                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + &quot;) during inspection for the inheritance line starting with (&quot; + inheritanceLine[0].getName() + &quot;). Ignoring the additional field. This can occur most commonly when using the @AdminPresentationAdornedTargetCollection and the collection type and target class have field names in common. This situation should be avoided, as the system will strip the repeated fields, which can cause unpredictable behavior.&quot;);"> 945                      //LOG.warn(&quot;Detected a field name collision (&quot; + metadata.getTargetClass() + &quot;.&quot; + property + ðŸ”µ</abbr>
 946                  }
 947                  continue;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 948 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 949 -            properties.add(prop);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 950 +            } else if (pos &lt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 951 +                pos = -pos - 1; // calculate position to insert</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 952 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +            properties.add(pos, prop);</span>
 954              prop.setMetadata(metadata);
 955              if (isHiddenOverride &amp;&amp; prop.getMetadata() instanceof BasicFieldMetadata) {
 956                  //this only makes sense for non collection types
 957                  ((BasicFieldMetadata) prop.getMetadata()).setVisibility(VisibilityEnum.HIDDEN_ALL);
 958              }
 959          }
 960      }
 961  
 962      @Override
<abbr title=" 963      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, FieldMetadata&gt;&gt; allMergedProperties) throws ServiceException {"> 963      public void updateMergedProperties(PersistencePackage persistencePackage, Map&lt;MergedPropertyType, Map&lt;String, ðŸ”µ</abbr>
<abbr title=" 964          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();"> 964          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
 965          try {
 966              PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
 967              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(ceilingEntityFullyQualifiedClassname);
<abbr title=" 968              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties("> 968              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
 969                      ceilingEntityFullyQualifiedClassname,
 970                      entities,
<abbr title=" 971                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 971                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 972                      persistencePerspective.getAdditionalNonPersistentProperties(),
 973                      persistencePerspective.getAdditionalForeignKeys(),
 974                      MergedPropertyType.PRIMARY,
 975                      persistencePerspective.getPopulateToOneFields(),
 976                      persistencePerspective.getIncludeFields(),
 977                      persistencePerspective.getExcludeFields(),
 978                      persistencePerspective.getConfigurationKey(),
 979                      &quot;&quot;
 980                      );
 981              allMergedProperties.put(MergedPropertyType.PRIMARY, mergedProperties);
 982          } catch (Exception e) {
 983              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
 984          }
 985      }
 986  
 987      @Override
<abbr title=" 988      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {"> 988      public EntityResult update(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServðŸ”µ</abbr>
 989          return update(persistencePackage, null, true);
 990      }
 991  
 992      @Override
 993      public Entity update(PersistencePackage persistencePackage) throws ServiceException {
 994          EntityResult er = update(persistencePackage, null, false);
 995          return er.getEntity();
 996      }
 997  
 998      @Override
 999      public Entity add(PersistencePackage persistencePackage) throws ServiceException {
1000          EntityResult entityResult = add(persistencePackage, false);
1001          return entityResult.getEntity();
1002      }
1003  
1004      @Override
<abbr title="1005      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceException {">1005      public EntityResult add(PersistencePackage persistencePackage, boolean includeRealEntityObject) throws ServiceðŸ”µ</abbr>
1006          EntityResult entityResult = new EntityResult();
1007          Entity entity = persistencePackage.getEntity();
1008          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1009          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1009          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1010          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1011              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1012          }
1013          try {
<abbr title="1014              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1014              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1015              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1015              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1016                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1017                      entities,
1018                      foreignKey,
1019                      persistencePerspective.getAdditionalNonPersistentProperties(),
1020                      persistencePerspective.getAdditionalForeignKeys(),
1021                      MergedPropertyType.PRIMARY,
1022                      persistencePerspective.getPopulateToOneFields(),
1023                      persistencePerspective.getIncludeFields(),
1024                      persistencePerspective.getExcludeFields(),
1025                      persistencePerspective.getConfigurationKey(),
1026                      &quot;&quot;
1027                      );
1028              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1029  
1030              String idProperty = null;
1031              for (String property : mergedProperties.keySet()) {
<abbr title="1032                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID) {">1032                  if (((BasicFieldMetadata) mergedProperties.get(property)).getFieldType() == SupportedFieldType.ID)ðŸ”µ</abbr>
1033                      idProperty = property;
1034                      break;
1035                  }
1036              }
1037              if (idProperty == null) {
<abbr title="1038                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: &quot; + entity.getType()[0]);">1038                  throw new RuntimeException(&quot;Could not find a primary key property in the passed entity with type: ðŸ”µ</abbr>
1039              }
1040              Object primaryKey = null;
1041              try {
1042                  primaryKey = getPrimaryKey(entity, mergedProperties);
1043              } catch (Exception e) {
1044                  //don&#x27;t do anything - this is a valid case
1045              }
1046              if (primaryKey == null) {
1047  
1048                  Serializable instance = (Serializable) Class.forName(entity.getType()[0]).newInstance();
1049  
1050                  instance = createPopulatedInstance(instance, entity, mergedProperties, false);
1051  
1052                  if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1053                      ExtensionResultHolder&lt;Serializable&gt; result = new ExtensionResultHolder&lt;Serializable&gt;();
<abbr title="1054                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedProperties, result);">1054                      extensionManager.getProxy().rebalanceForAdd(this, persistencePackage, instance, mergedPropertiðŸ”µ</abbr>
1055                      instance = result.getResult();
1056                  }
1057  
1058                  instance = persistenceManager.getDynamicEntityDao().merge(instance);
1059                  if (includeRealEntityObject) {
1060                      entityResult.setEntityBackingObject(instance);
1061                  }
1062                  List&lt;Serializable&gt; entityList = new ArrayList&lt;Serializable&gt;(1);
1063                  entityList.add(instance);
1064  
1065                  entity = getRecords(mergedProperties, entityList, null, null, null)[0];
1066                  entityResult.setEntity(entity);
1067                  return entityResult;
1068              } else {
1069                  return update(persistencePackage, primaryKey, includeRealEntityObject);
1070              }
1071          } catch (Exception e) {
1072              throw new ServiceException(&quot;Problem adding new entity : &quot; + e.getMessage(), e);
1073          }
1074      }
1075  
1076      @Override
1077      public void remove(PersistencePackage persistencePackage) throws ServiceException {
1078          Entity entity = persistencePackage.getEntity();
1079          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1080          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1080          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1081          if (foreignKey != null &amp;&amp; !foreignKey.getMutable()) {
1082              throw new SecurityServiceException(&quot;Entity not mutable&quot;);
1083          }
1084          try {
<abbr title="1085              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFullyQualifiedClassname());">1085              Class&lt;?&gt;[] entities = persistenceManager.getPolymorphicEntities(persistencePackage.getCeilingEntityFulðŸ”µ</abbr>
<abbr title="1086              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1086              Map&lt;String, FieldMetadata&gt; mergedUnfilteredProperties = persistenceManager.getDynamicEntityDao().getMeðŸ”µ</abbr>
1087                      persistencePackage.getCeilingEntityFullyQualifiedClassname(),
1088                      entities,
1089                      foreignKey,
1090                      persistencePerspective.getAdditionalNonPersistentProperties(),
1091                      persistencePerspective.getAdditionalForeignKeys(),
1092                      MergedPropertyType.PRIMARY,
1093                      persistencePerspective.getPopulateToOneFields(),
1094                      persistencePerspective.getIncludeFields(),
1095                      persistencePerspective.getExcludeFields(),
1096                      persistencePerspective.getConfigurationKey(),
1097                      &quot;&quot;
1098                      );
1099              Map&lt;String, FieldMetadata&gt; mergedProperties = filterOutCollectionMetadata(mergedUnfilteredProperties);
1100              Object primaryKey = getPrimaryKey(entity, mergedProperties);
<abbr title="1101              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getType()[0]), primaryKey);">1101              Serializable instance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(entity.getTypeðŸ”µ</abbr>
1102  
1103              Assert.isTrue(instance != null, &quot;Entity not found&quot;);
1104  
1105              switch (persistencePerspective.getOperationTypes().getRemoveType()) {
1106                  case NONDESTRUCTIVEREMOVE:
1107                      FieldManager fieldManager = getFieldManager();
<abbr title="1108                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField());">1108                      FieldMetadata manyToFieldMetadata = mergedUnfilteredProperties.get(foreignKey.getManyToField()ðŸ”µ</abbr>
1109                      Object foreignKeyValue = entity.getPMap().get(foreignKey.getManyToField()).getValue();
1110                      try {
1111                          foreignKeyValue = Long.valueOf((String) foreignKeyValue);
1112                      } catch (NumberFormatException e) {
1113                          LOG.warn(&quot;Foreign primary key is not of type Long, assuming String for remove lookup&quot;);
1114                      }
<abbr title="1115                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forName(foreignKey.getForeignKeyClass()), foreignKeyValue);">1115                      Serializable foreignInstance = persistenceManager.getDynamicEntityDao().retrieve(Class.forNameðŸ”µ</abbr>
<abbr title="1116                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.getOriginatingField());">1116                      Collection collection = (Collection) fieldManager.getFieldValue(foreignInstance, foreignKey.geðŸ”µ</abbr>
1117                      collection.remove(instance);
<abbr title="1118                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreign key on">1118                      // if this is a bi-directional @OneToMany/@ManyToOne and there is no @JoinTable (just a foreigðŸ”µ</abbr>
1119                      // the @ManyToOne side) then it will not be updated. In that instance, we have to explicitly
1120                      // set the manyTo field to null so that subsequent lookups will not find it
1121                      if (manyToFieldMetadata instanceof BasicFieldMetadata) {
1122                          if (BooleanUtils.isTrue(((BasicFieldMetadata) manyToFieldMetadata).getRequired())) {
<abbr title="1123                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne side is a&quot;">1123                              throw new ServiceException(&quot;Could not remove from the collection as the ManyToOne sideðŸ”µ</abbr>
<abbr title="1124                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyToOne annotation&quot;">1124                                      + &quot; non-optional relationship. Consider changing &#x27;optional=true&#x27; in the @ManyTðŸ”µ</abbr>
1125                                      + &quot; or nullable=true within the @JoinColumn annotation&quot;);
1126                          }
<abbr title="1127                          //Since this is occuring on a remove persistence package, merge up-front (before making a change) for proper operation in the presence of the enterprise module">1127                          //Since this is occuring on a remove persistence package, merge up-front (before making a ðŸ”µ</abbr>
1128                          instance = persistenceManager.getDynamicEntityDao().merge(instance);
<abbr title="1129                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField());">1129                          Field manyToField = fieldManager.getField(instance.getClass(), foreignKey.getManyToField()ðŸ”µ</abbr>
1130                          Object manyToObject = manyToField.get(instance);
<abbr title="1131                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanceof Map)) {">1131                          if (manyToObject != null &amp;&amp; !(manyToObject instanceof Collection) &amp;&amp; !(manyToObject instanðŸ”µ</abbr>
1132                              manyToField.set(instance, null);
1133                              instance = persistenceManager.getDynamicEntityDao().merge(instance);
1134                          }
1135                      }
1136                      break;
1137                  case BASIC:
1138                      persistenceManager.getDynamicEntityDao().remove(instance);
1139                      break;
1140              }
1141          } catch (Exception e) {
1142              throw new ServiceException(&quot;Problem removing entity : &quot; + e.getMessage(), e);
1143          }
1144      }
1145  
1146      public Map&lt;String, FieldMetadata&gt; getMergedProperties(PersistencePackage persistencePackage,
1147              CriteriaTransferObject cto) throws ServiceException {
1148          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1149          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1149          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
1150  
1151          if (StringUtils.isEmpty(persistencePackage.getFetchTypeFullyQualifiedClassname())) {
1152              persistencePackage.setFetchTypeFullyQualifiedClassname(ceilingEntityFullyQualifiedClassname);
1153          }
1154  
1155          try {
<abbr title="1156              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1156              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(ClðŸ”µ</abbr>
1157  
<abbr title="1158              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperties(">1158              Map&lt;String, FieldMetadata&gt; mergedProperties = persistenceManager.getDynamicEntityDao().getMergedProperðŸ”µ</abbr>
1159                      ceilingEntityFullyQualifiedClassname,
1160                      entities,
<abbr title="1161                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),">1161                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
1162                      persistencePerspective.getAdditionalNonPersistentProperties(),
1163                      persistencePerspective.getAdditionalForeignKeys(),
1164                      MergedPropertyType.PRIMARY,
1165                      persistencePerspective.getPopulateToOneFields(),
1166                      persistencePerspective.getIncludeFields(),
1167                      persistencePerspective.getExcludeFields(),
1168                      persistencePerspective.getConfigurationKey(),
1169                      &quot;&quot;
1170                      );
1171  
1172              return mergedProperties;
1173          } catch (Exception e) {
1174              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1175          }
1176      }
1177  
1178      @Override
<abbr title="1179      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServiceException {">1179      public DynamicResultSet fetch(PersistencePackage persistencePackage, CriteriaTransferObject cto) throws ServicðŸ”µ</abbr>
1180          Entity[] payload;
1181          int totalRecords;
1182          PersistencePerspective persistencePerspective = persistencePackage.getPersistencePerspective();
<abbr title="1183          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname();">1183          String ceilingEntityFullyQualifiedClassname = persistencePackage.getCeilingEntityFullyQualifiedClassname()ðŸ”µ</abbr>
<abbr title="1184          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1184          ForeignKey foreignKey = (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistenðŸ”µ</abbr>
1185  
1186          try {
1187              if (foreignKey != null &amp;&amp; foreignKey.getSortField() != null) {
1188                  FilterAndSortCriteria sortCriteria = cto.get(foreignKey.getSortField());
1189                  sortCriteria.setSortAscending(foreignKey.getSortAscending());
1190              }
1191  
1192              Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedProperties(persistencePackage, cto);
1193  
1194              List&lt;FilterMapping&gt; filterMappings = getFilterMappings(persistencePerspective, cto, persistencePackage
1195                      .getFetchTypeFullyQualifiedClassname(), mergedProperties);
1196              List&lt;FilterMapping&gt; standardFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1197              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1198                  standardFilterMappings.addAll(cto.getAdditionalFilterMappings());
1199              }
1200              if (CollectionUtils.isNotEmpty(cto.getNonCountAdditionalFilterMappings())) {
1201                  standardFilterMappings.addAll(cto.getNonCountAdditionalFilterMappings());
1202              }
1203  
1204              FetchRequest fetchRequest = new FetchRequest(persistencePackage, cto,
1205                      persistencePackage.getFetchTypeFullyQualifiedClassname(), standardFilterMappings);
1206              List&lt;Serializable&gt; records = getPersistentRecords(fetchRequest);
1207  
1208              List&lt;FilterMapping&gt; countFilterMappings = new ArrayList&lt;FilterMapping&gt;(filterMappings);
1209              if (CollectionUtils.isNotEmpty(cto.getAdditionalFilterMappings())) {
1210                  countFilterMappings.addAll(cto.getAdditionalFilterMappings());
1211              }
1212              FetchRequest countFetchRequest = new FetchRequest(persistencePackage, cto,
1213                      persistencePackage.getFetchTypeFullyQualifiedClassname(), countFilterMappings);
1214              totalRecords = getTotalRecords(countFetchRequest);
1215  
1216              FetchExtractionRequest fetchExtractionRequest = new FetchExtractionRequest(persistencePackage, cto,
1217                      persistencePackage.getFetchTypeFullyQualifiedClassname(), mergedProperties, records);
1218              payload = getRecords(fetchExtractionRequest);
1219          } catch (Exception e) {
1220              throw new ServiceException(&quot;Unable to fetch results for &quot; + ceilingEntityFullyQualifiedClassname, e);
1221          }
1222  
1223          return new DynamicResultSet(null, payload, totalRecords);
1224      }
1225  
1226      @Override
1227      public Integer getTotalRecords(FetchRequest fetchRequest) {
1228          return fetchWrapper.getTotalRecords(fetchRequest);
1229      }
1230  
1231      @Override
1232      public Integer getTotalRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings) {
1233          try {
1234              return ((Long) criteriaTranslator.translateCountQuery(persistenceManager.getDynamicEntityDao(),
1235                      ceilingEntity, filterMappings).getSingleResult()).intValue();
1236          } catch (CriteriaConversionException e) {
<abbr title="1237              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1237              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1238              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getSingleResult()).intValue();">1238              return ((Long) builder.toCountQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManðŸ”µ</abbr>
1239          }
1240      }
1241  
1242      @Override
1243      public Serializable getMaxValue(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, String maxField) {
1244          return criteriaTranslator.translateMaxQuery(persistenceManager.getDynamicEntityDao(),
1245                  ceilingEntity, filterMappings, maxField).getSingleResult();
1246      }
1247  
1248      @Override
1249      public List&lt;Serializable&gt; getPersistentRecords(FetchRequest fetchRequest) {
1250          return fetchWrapper.getPersistentRecords(fetchRequest);
1251      }
1252  
1253      @Override
<abbr title="1254      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, Integer firstResult, Integer maxResults) {">1254      public List&lt;Serializable&gt; getPersistentRecords(String ceilingEntity, List&lt;FilterMapping&gt; filterMappings, IntegðŸ”µ</abbr>
1255          try {
<abbr title="1256              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filterMappings, firstResult, maxResults).getResultList();">1256              return criteriaTranslator.translateQuery(persistenceManager.getDynamicEntityDao(), ceilingEntity, filtðŸ”µ</abbr>
1257          } catch (CriteriaConversionException e) {
<abbr title="1258              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntity);">1258              TypedQueryBuilder builder = getSpecialCaseQueryBuilder(e.getFieldPath(), filterMappings, ceilingEntityðŸ”µ</abbr>
<abbr title="1259              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getResultList();">1259              return builder.toQuery(getPersistenceManager().getDynamicEntityDao().getStandardEntityManager()).getReðŸ”µ</abbr>
1260          }
1261      }
1262  
1263      @Override
<abbr title="1264      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties) {">1264      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1265          return validate(entity, populatedInstance, mergedProperties, true);
1266      }
1267  
1268      @Override
<abbr title="1269      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperties,">1269      public boolean validate(Entity entity, Serializable populatedInstance, Map&lt;String, FieldMetadata&gt; mergedProperðŸ”µ</abbr>
1270              boolean validateUnsubmittedProperties) {
<abbr title="1271          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedProperties);">1271          entityValidatorService.validate(entity, populatedInstance, mergedProperties, this, validateUnsubmittedPropðŸ”µ</abbr>
1272          return !entity.isValidationFailure();
1273      }
1274  
1275      @Override
1276      public void setPersistenceManager(PersistenceManager persistenceManager) {
1277          this.persistenceManager = persistenceManager;
1278      }
1279  
1280      @Override
1281      public PersistenceModule getCompatibleModule(OperationType operationType) {
1282          return ((InspectHelper) persistenceManager).getCompatibleModule(operationType);
1283      }
1284  
1285      public FieldPersistenceProvider getDefaultFieldPersistenceProvider() {
1286          return defaultFieldPersistenceProvider;
1287      }
1288  
1289      public void setDefaultFieldPersistenceProvider(FieldPersistenceProvider defaultFieldPersistenceProvider) {
1290          this.defaultFieldPersistenceProvider = defaultFieldPersistenceProvider;
1291      }
1292  
1293      public List&lt;FieldPersistenceProvider&gt; getFieldPersistenceProviders() {
1294          return fieldPersistenceProviders;
1295      }
1296  
1297      public void setFieldPersistenceProviders(List&lt;FieldPersistenceProvider&gt; fieldPersistenceProviders) {
1298          this.fieldPersistenceProviders = fieldPersistenceProviders;
1299      }
1300  
1301      public CriteriaTranslator getCriteriaTranslator() {
1302          return criteriaTranslator;
1303      }
1304  
1305      public void setCriteriaTranslator(CriteriaTranslator criteriaTranslator) {
1306          this.criteriaTranslator = criteriaTranslator;
1307      }
1308  
1309      public EntityValidatorService getEntityValidatorService() {
1310          return entityValidatorService;
1311      }
1312  
1313      public void setEntityValidatorService(EntityValidatorService entityValidatorService) {
1314          this.entityValidatorService = entityValidatorService;
1315      }
1316  
1317      public RestrictionFactory getRestrictionFactory() {
1318          return restrictionFactory;
1319      }
1320  
1321      public void setRestrictionFactory(RestrictionFactory restrictionFactory) {
1322          this.restrictionFactory = restrictionFactory;
1323      }
1324  
1325      public PersistenceManager getPersistenceManager() {
1326          return persistenceManager;
1327      }
1328  
1329      /**
<abbr title="1330       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable object. Related">1330       * Use an alternate approach to generating a fetch query for a collection located inside of an @Embeddable objðŸ”µ</abbr>
<abbr title="1331       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA criteria,">1331       * to https://hibernate.atlassian.net/browse/HHH-8802. The alternate approach leverages HQL rather than JPA crðŸ”µ</abbr>
1332       * which seems to alleviate the problem.
1333       *
1334       * @param embeddedCollectionPath the path to the collection field itself
1335       * @param filterMappings all the fetch restrictions for this request
1336       * @param collectionClass the type of the collection members
1337       * @return the builder capable of generating an appropriate HQL query
1338       */
<abbr title="1339      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings, String collectionClass) {">1339      protected TypedQueryBuilder getSpecialCaseQueryBuilder(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; fðŸ”µ</abbr>
1340          String specialPath = embeddedCollectionPath.getTargetProperty();
1341          String[] pieces = specialPath.split(&quot;\\.&quot;);
1342          if (pieces.length != 3) {
<abbr title="1343              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embedded field].[collection field].[property] for the embedded collection path (%s)&quot;, specialPath), embeddedCollectionPath);">1343              throw new CriteriaConversionException(String.format(&quot;Expected to find a target property of format [embðŸ”µ</abbr>
1344          }
1345          String expression = specialPath.substring(0, specialPath.lastIndexOf(&quot;.&quot;));
1346          TypedQueryBuilder builder;
1347          try {
1348              builder = new TypedQueryBuilder(Class.forName(collectionClass), &quot;specialEntity&quot;)
1349                      .addJoin(new TQJoin(&quot;specialEntity.&quot; + expression, &quot;embeddedCollection&quot;));
1350          } catch (Exception e) {
1351              throw ExceptionHelper.refineException(e);
1352          }
1353          for (TQRestriction restriction : buildSpecialRestrictions(expression, filterMappings)) {
1354              builder = builder.addRestriction(restriction);
1355          }
1356          for (TQRestriction restriction : buildStandardRestrictions(embeddedCollectionPath, filterMappings)) {
1357              builder = builder.addRestriction(restriction);
1358          }
1359          for (FilterMapping mapping : filterMappings) {
1360              if (mapping.getSortDirection() != null) {
<abbr title="1361                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1361                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1362                  if (StringUtils.isEmpty(mappingProperty)) {
1363                      mappingProperty = mapping.getFullPropertyName();
1364                  }
<abbr title="1365                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDING == mapping.getSortDirection()));">1365                  builder = builder.addOrder(new TQOrder(&quot;specialEntity.&quot; + mappingProperty, SortDirection.ASCENDINGðŸ”µ</abbr>
1366              }
1367          }
1368  
1369          return builder;
1370      }
1371  
1372      /**
<abbr title="1373       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collection field in the @Embeddable object)">1373       * Generate LIKE or EQUALS restrictions for any filter property specified on the root entity (not the collectiðŸ”µ</abbr>
1374       *
<abbr title="1375       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1375       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1376       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caused the whole thing">1376       * @param embeddedCollectionPath the path for the collection field in the @Embeddable object - this is what caðŸ”µ</abbr>
1377       * @param filterMappings all the fetch restrictions for this request
1378       * @return the list of restrictions on the root entity
1379       */
<abbr title="1380      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; filterMappings) {">1380      protected List&lt;TQRestriction&gt; buildStandardRestrictions(FieldPath embeddedCollectionPath, List&lt;FilterMapping&gt; ðŸ”µ</abbr>
<abbr title="1381          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargetProperty().lastIndexOf(&quot;.&quot;));">1381          String expression = embeddedCollectionPath.getTargetProperty().substring(0, embeddedCollectionPath.getTargðŸ”µ</abbr>
1382          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1383          for (FilterMapping mapping : filterMappings) {
1384              checkProperty: {
<abbr title="1385                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetProperty();">1385                  String mappingProperty = mapping.getFieldPath() == null ? null : mapping.getFieldPath().getTargetPðŸ”µ</abbr>
1386                  if (StringUtils.isEmpty(mappingProperty)) {
1387                      mappingProperty = mapping.getFullPropertyName();
1388                  }
<abbr title="1389                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(mappingProperty)) {">1389                  if (!embeddedCollectionPath.getTargetProperty().equals(mappingProperty) &amp;&amp; !StringUtils.isEmpty(maðŸ”µ</abbr>
1390                      PredicateProvider predicateProvider = mapping.getRestriction().getPredicateProvider();
1391                      if (predicateProvider != null) {
1392                          FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1393                          if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1394                              Object val = converter.convert(mapping.getFilterValues().get(0));
1395                              if (predicateProvider instanceof LikePredicateProvider) {
<abbr title="1396                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, val + &quot;%&quot;));">1396                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;LIKE&quot;, valðŸ”µ</abbr>
1397                                  break checkProperty;
1398                              } else if (predicateProvider instanceof EqPredicateProvider) {
1399                                  restrictions.add(new TQRestriction(&quot;specialEntity.&quot; + mappingProperty, &quot;=&quot;, val));
1400                                  break checkProperty;
1401                              }
1402                          }
1403                      }
<abbr title="1404                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional property (%s)&quot;,">1404                      LOG.warn(String.format(&quot;Unable to filter the embedded collection (%s) on an additional propertðŸ”µ</abbr>
1405                              StringUtil.sanitize(expression),
1406                              StringUtil.sanitize(mappingProperty)));
1407                  }
1408              }
1409          }
1410  
1411          return restrictions;
1412      }
1413  
1414      /**
<abbr title="1415       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection field in the @Embeddable object">1415       * Generate EQUALS restrictions for any filter property specified on the entity member of the collection fieldðŸ”µ</abbr>
1416       *
<abbr title="1417       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteria.FieldPath, java.util.List, String)">1417       * @see #getSpecialCaseQueryBuilder(org.broadleafcommerce.openadmin.server.service.persistence.module.criteriaðŸ”µ</abbr>
<abbr title="1418       * @param specialExpression the String representation of the path for the collection field in the @Embeddable object">1418       * @param specialExpression the String representation of the path for the collection field in the @Embeddable ðŸ”µ</abbr>
1419       * @param filterMappings all the fetch restrictions for this request
1420       * @return the list of restrictions on the collection in the @Embeddable object
1421       */
<abbr title="1422      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMappings) {">1422      protected List&lt;TQRestriction&gt; buildSpecialRestrictions(String specialExpression, List&lt;FilterMapping&gt; filterMapðŸ”µ</abbr>
1423          List&lt;TQRestriction&gt; restrictions = new ArrayList&lt;TQRestriction&gt;();
1424          for (FilterMapping mapping : filterMappings) {
<abbr title="1425              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.getFieldPath().getTargetProperty().startsWith(specialExpression)) {">1425              if (mapping.getFieldPath() != null &amp;&amp; mapping.getFieldPath().getTargetProperty() != null &amp;&amp; mapping.geðŸ”µ</abbr>
1426                  FilterValueConverter converter = mapping.getRestriction().getFilterValueConverter();
1427                  if (converter != null &amp;&amp; CollectionUtils.isNotEmpty(mapping.getFilterValues())) {
1428                      Object val = converter.convert(mapping.getFilterValues().get(0));
<abbr title="1429                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().getTargetProperty().lastIndexOf(&quot;.&quot;) + 1, mapping.getFieldPath().getTargetProperty().length());">1429                      String property = mapping.getFieldPath().getTargetProperty().substring(mapping.getFieldPath().ðŸ”µ</abbr>
1430                      restrictions.add(new TQRestriction(&quot;embeddedCollection.&quot; + property, &quot;=&quot;, val));
1431                  }
1432              }
1433          }
1434          return restrictions;
1435      }
1436  
1437      protected void cleanupFailedPersistenceAttempt(Serializable instance) throws IllegalAccessException {
1438          //Remove the entity from ORM management - no further attempts to persist
1439          if (getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().contains(instance)) {
1440              getPersistenceManager().getDynamicEntityDao().getStandardEntityManager().detach(instance);
1441          }
1442          //Remove the id field value, if it&#x27;s set
<abbr title="1443          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClass()).get(&quot;name&quot;);">1443          String idFieldName = (String) getPersistenceManager().getDynamicEntityDao().getIdMetadata(instance.getClasðŸ”µ</abbr>
1444          Field idField = FieldUtils.getField(instance.getClass(), idFieldName, true);
1445          if (idField == null) {
<abbr title="1446              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getName() + &quot; does not contain id field &quot; + idFieldName));">1446              throw ExceptionHelper.refineException(new NoSuchFieldException(&quot;Entity &quot; + instance.getClass().getNameðŸ”µ</abbr>
1447          }
1448          idField.setAccessible(true);
1449          if (idField.get(instance) != null) {
1450              idField.set(instance, null);
1451          }
1452      }
1453  
1454      protected Class&lt;?&gt; getMapFieldType(Serializable instance, FieldManager fieldManager, Property property) {
1455          Class&lt;?&gt; returnType = null;
<abbr title="1456          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName().indexOf(FieldManager.MAPFIELDSEPARATOR)));">1456          Field field = fieldManager.getField(instance.getClass(), property.getName().substring(0, property.getName(ðŸ”µ</abbr>
1457          java.lang.reflect.Type type = field.getGenericType();
1458          if (type instanceof ParameterizedType) {
1459              ParameterizedType pType = (ParameterizedType) type;
1460              Class&lt;?&gt; clazz;
1461              if (pType.getActualTypeArguments().length &lt; 2) {
1462                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[0];
1463              } else {
1464                  clazz = (Class&lt;?&gt;) pType.getActualTypeArguments()[1];
1465              }
<abbr title="1466              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clazz);">1466              Class&lt;?&gt;[] entities = persistenceManager.getDynamicEntityDao().getAllPolymorphicEntitiesFromCeiling(clðŸ”µ</abbr>
1467              if (!ArrayUtils.isEmpty(entities)) {
1468                  returnType = entities[entities.length - 1];
1469              }
1470          }
1471          return returnType;
1472      }
1473  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            