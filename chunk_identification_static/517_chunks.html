<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>517 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void setPackageState(final &#x27;
                         &#x27;ArrayList&lt;PackageInstallInfo&gt; installInfo) {\n&#x27;
                         &#x27;        // Process the updated package state\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                if (callbacks != null) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;callbacks.updatePackageState(installInfo);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        mHandler.post(r);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void updatePackageBadge(final String &#x27;
                         &#x27;packageName) {\n&#x27;
                         &#x27;        // Process the updated package badge\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                if (callbacks != null) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;callbacks.updatePackageBadge(packageName);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        mHandler.post(r);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void addAppsToAllApps(final Context ctx, &#x27;
                         &#x27;final ArrayList&lt;AppInfo&gt; allAppsApps) {\n&#x27;
                         &#x27;        final Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (allAppsApps == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;allAppsApps &#x27;
                         &#x27;must not be null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (allAppsApps.isEmpty()) {\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        final ArrayList&lt;AppInfo&gt; restoredAppsFinal = &#x27;
                         &#x27;new ArrayList&lt;AppInfo&gt;();\n&#x27;
                         &#x27;        Iterator&lt;AppInfo&gt; iter = &#x27;
                         &#x27;allAppsApps.iterator();\n&#x27;
                         &#x27;        while (iter.hasNext()) {\n&#x27;
                         &#x27;            ItemInfo a = iter.next();\n&#x27;
                         &#x27;            if (LauncherModel.appWasPromise(ctx, &#x27;
                         &#x27;a.getIntent(), a.user)) {\n&#x27;
                         &#x27;                restoredAppsFinal.add((AppInfo) a);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        // Process the newly added applications and &#x27;
                         &#x27;add them to the database first\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                runOnMainThread(new Runnable() {\n&#x27;
                         &#x27;                    public void run() {\n&#x27;
                         &#x27;                        Callbacks cb = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                        if (callbacks == cb &amp;&amp; cb != &#x27;
                         &#x27;null) {\n&#x27;
                         &#x27;                            if &#x27;
                         &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                         &#x27;                                for (AppInfo info : &#x27;
                         &#x27;restoredAppsFinal) {\n&#x27;
                         &#x27;                                    final Intent &#x27;
                         &#x27;intent = info.getIntent();\n&#x27;
                         &#x27;                                    if (intent != &#x27;
                         &#x27;null) {\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;mIconCache.deletePreloadedIcon(intent.getComponent(),\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;info.user);\n&#x27;
                         &#x27;                                    }\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                         &#x27;                            }\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;callbacks.bindAppsAdded(null, null, null, &#x27;
                         &#x27;allAppsApps);\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                });\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        runOnWorkerThread(r);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void addAppsToAllApps(final Context &#x27;
                           &#x27;ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {\n&#x27;
                           &#x27;        final Callbacks callbacks = mCallbacks != &#x27;
                           &#x27;null ? mCallbacks.get() : null;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (allAppsApps == null) {\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(&quot;allAppsApps must not be null&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (allAppsApps.isEmpty()) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final ArrayList&lt;AppInfo&gt; restoredAppsFinal &#x27;
                           &#x27;= new ArrayList&lt;AppInfo&gt;();\n&#x27;
                           &#x27;        Iterator&lt;AppInfo&gt; iter = &#x27;
                           &#x27;allAppsApps.iterator();\n&#x27;
                           &#x27;        while (iter.hasNext()) {\n&#x27;
                           &#x27;            ItemInfo a = iter.next();\n&#x27;
                           &#x27;            if (LauncherModel.appWasRestored(ctx, &#x27;
                           &#x27;a.getIntent())) {\n&#x27;
                           &#x27;                restoredAppsFinal.add((AppInfo) &#x27;
                           &#x27;a);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Process the newly added applications &#x27;
                           &#x27;and add them to the database first\n&#x27;
                           &#x27;        Runnable r = new Runnable() {\n&#x27;
                           &#x27;            public void run() {\n&#x27;
                           &#x27;                runOnMainThread(new Runnable() {\n&#x27;
                           &#x27;                    public void run() {\n&#x27;
                           &#x27;                        Callbacks cb = mCallbacks &#x27;
                           &#x27;!= null ? mCallbacks.get() : null;\n&#x27;
                           &#x27;                        if (callbacks == cb &amp;&amp; cb &#x27;
                           &#x27;!= null) {\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;callbacks.bindAppsAdded(null, null, null, &#x27;
                           &#x27;allAppsApps);\n&#x27;
                           &#x27;                            if &#x27;
                           &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        };\n&#x27;
                           &#x27;        runOnWorkerThread(r);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                            // Only &#x27;
                         &#x27;InstallShortcutReceiver sends us shortcutInfos, &#x27;
                         &#x27;ignore them\n&#x27;
                         &#x27;                            if (a instanceof AppInfo &#x27;
                         &#x27;&amp;&amp;\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;LauncherModel.appWasPromise(context, launchIntent, &#x27;
                         &#x27;a.user)) {\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;restoredAppsFinal.add((AppInfo) a);\n&#x27;
                         &#x27;                            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                                        &#x27;
                         &#x27;addNotAnimated, addAnimated, null);\n&#x27;
                         &#x27;                                if &#x27;
                         &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                         &#x27;                                }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                                        &#x27;
                           &#x27;addNotAnimated, addAnimated, null);\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                           &#x27;                                }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;     * Returns true if the promise shortcuts with &#x27;
                         &#x27;the same package name exists on the workspace.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    static boolean appWasPromise(Context context, &#x27;
                         &#x27;Intent intent, UserHandleCompat user) {\n&#x27;
                         &#x27;        final ComponentName component = &#x27;
                         &#x27;intent.getComponent();\n&#x27;
                         &#x27;        if (component == null) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;!getItemsByPackageName(component.getPackageName(), &#x27;
                         &#x27;user).isEmpty();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                                    if &#x27;
                         &#x27;(user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;Launcher.addDumpLog(TAG,\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;&quot;constructing info for partially restored package&quot;,\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;                                        info = &#x27;
                         &#x27;getRestoredItemInfo(c, titleIndex, intent, &#x27;
                         &#x27;promiseType);\n&#x27;
                         &#x27;                                        intent = &#x27;
                         &#x27;getRestoredItemIntent(c, context, intent);\n&#x27;
                         &#x27;                                    } else {\n&#x27;
                         &quot;                                        // Don&#x27;t &quot;
                         &#x27;restore items for other profiles.\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;itemsToRemove.add(id);\n&#x27;
                         &#x27;                                        continue;\n&#x27;
                         &#x27;                                    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                                    &#x27;
                           &#x27;Launcher.addDumpLog(TAG,\n&#x27;
                           &#x27;                                            &#x27;
                           &#x27;&quot;constructing info for partially restored &#x27;
                           &#x27;package&quot;,\n&#x27;
                           &#x27;                                            &#x27;
                           &#x27;true);\n&#x27;
                           &#x27;                                    info = &#x27;
                           &#x27;getRestoredItemInfo(c, titleIndex);\n&#x27;
                           &#x27;                                    intent = &#x27;
                           &#x27;getRestoredItemIntent(c, context, intent);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public ShortcutInfo getRestoredItemInfo(Cursor &#x27;
                         &#x27;cursor, int titleIndex, Intent intent,\n&#x27;
                         &#x27;            int promiseType) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public ShortcutInfo getRestoredItemInfo(Cursor &#x27;
                           &#x27;cursor, int titleIndex) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        info.promisedIntent = intent;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                .appendQueryParameter(&quot;id&quot;, &#x27;
                         &#x27;packageName)\n&#x27;
                         &#x27;                .build());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                .appendQueryParameter(&quot;id&quot;, &#x27;
                           &#x27;componentName.getPackageName())\n&#x27;
                           &#x27;                .build();\n&#x27;
                           &#x27;        Log.d(TAG, &quot;manufactured intent uri: &quot; + &#x27;
                           &#x27;marketUri.toString());\n&#x27;
                           &#x27;        marketIntent.setData(marketUri);\n&#x27;
                           &#x27;        return marketIntent;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            // placeholder shortcuts get special &#x27;
                         &#x27;treatment, let them through too.\n&#x27;
                         &#x27;            if (info.isPromise()) {\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void setPackageState(final &#x27;
                         &#x27;ArrayList&lt;PackageInstallInfo&gt; installInfo) {\n&#x27;
                         &#x27;        // Process the updated package state\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                if (callbacks != null) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;callbacks.updatePackageState(installInfo);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        mHandler.post(r);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void updatePackageBadge(final String &#x27;
                         &#x27;packageName) {\n&#x27;
                         &#x27;        // Process the updated package badge\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                if (callbacks != null) {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;callbacks.updatePackageBadge(packageName);\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        mHandler.post(r);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public void addAppsToAllApps(final Context ctx, &#x27;
                         &#x27;final ArrayList&lt;AppInfo&gt; allAppsApps) {\n&#x27;
                         &#x27;        final Callbacks callbacks = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if (allAppsApps == null) {\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;allAppsApps &#x27;
                         &#x27;must not be null&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (allAppsApps.isEmpty()) {\n&#x27;
                         &#x27;            return;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        final ArrayList&lt;AppInfo&gt; restoredAppsFinal = &#x27;
                         &#x27;new ArrayList&lt;AppInfo&gt;();\n&#x27;
                         &#x27;        Iterator&lt;AppInfo&gt; iter = &#x27;
                         &#x27;allAppsApps.iterator();\n&#x27;
                         &#x27;        while (iter.hasNext()) {\n&#x27;
                         &#x27;            ItemInfo a = iter.next();\n&#x27;
                         &#x27;            if (LauncherModel.appWasPromise(ctx, &#x27;
                         &#x27;a.getIntent(), a.user)) {\n&#x27;
                         &#x27;                restoredAppsFinal.add((AppInfo) a);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        // Process the newly added applications and &#x27;
                         &#x27;add them to the database first\n&#x27;
                         &#x27;        Runnable r = new Runnable() {\n&#x27;
                         &#x27;            public void run() {\n&#x27;
                         &#x27;                runOnMainThread(new Runnable() {\n&#x27;
                         &#x27;                    public void run() {\n&#x27;
                         &#x27;                        Callbacks cb = mCallbacks != &#x27;
                         &#x27;null ? mCallbacks.get() : null;\n&#x27;
                         &#x27;                        if (callbacks == cb &amp;&amp; cb != &#x27;
                         &#x27;null) {\n&#x27;
                         &#x27;                            if &#x27;
                         &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                         &#x27;                                for (AppInfo info : &#x27;
                         &#x27;restoredAppsFinal) {\n&#x27;
                         &#x27;                                    final Intent &#x27;
                         &#x27;intent = info.getIntent();\n&#x27;
                         &#x27;                                    if (intent != &#x27;
                         &#x27;null) {\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;mIconCache.deletePreloadedIcon(intent.getComponent(),\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;info.user);\n&#x27;
                         &#x27;                                    }\n&#x27;
                         &#x27;                                }\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                         &#x27;                            }\n&#x27;
                         &#x27;                            &#x27;
                         &#x27;callbacks.bindAppsAdded(null, null, null, &#x27;
                         &#x27;allAppsApps);\n&#x27;
                         &#x27;                        }\n&#x27;
                         &#x27;                    }\n&#x27;
                         &#x27;                });\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        };\n&#x27;
                         &#x27;        runOnWorkerThread(r);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void addAppsToAllApps(final Context &#x27;
                           &#x27;ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {\n&#x27;
                           &#x27;        final Callbacks callbacks = mCallbacks != &#x27;
                           &#x27;null ? mCallbacks.get() : null;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (allAppsApps == null) {\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(&quot;allAppsApps must not be null&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (allAppsApps.isEmpty()) {\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final ArrayList&lt;AppInfo&gt; restoredAppsFinal &#x27;
                           &#x27;= new ArrayList&lt;AppInfo&gt;();\n&#x27;
                           &#x27;        Iterator&lt;AppInfo&gt; iter = &#x27;
                           &#x27;allAppsApps.iterator();\n&#x27;
                           &#x27;        while (iter.hasNext()) {\n&#x27;
                           &#x27;            ItemInfo a = iter.next();\n&#x27;
                           &#x27;            if (LauncherModel.appWasRestored(ctx, &#x27;
                           &#x27;a.getIntent())) {\n&#x27;
                           &#x27;                restoredAppsFinal.add((AppInfo) &#x27;
                           &#x27;a);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // Process the newly added applications &#x27;
                           &#x27;and add them to the database first\n&#x27;
                           &#x27;        Runnable r = new Runnable() {\n&#x27;
                           &#x27;            public void run() {\n&#x27;
                           &#x27;                runOnMainThread(new Runnable() {\n&#x27;
                           &#x27;                    public void run() {\n&#x27;
                           &#x27;                        Callbacks cb = mCallbacks &#x27;
                           &#x27;!= null ? mCallbacks.get() : null;\n&#x27;
                           &#x27;                        if (callbacks == cb &amp;&amp; cb &#x27;
                           &#x27;!= null) {\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;callbacks.bindAppsAdded(null, null, null, &#x27;
                           &#x27;allAppsApps);\n&#x27;
                           &#x27;                            if &#x27;
                           &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        };\n&#x27;
                           &#x27;        runOnWorkerThread(r);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                            // Only &#x27;
                         &#x27;InstallShortcutReceiver sends us shortcutInfos, &#x27;
                         &#x27;ignore them\n&#x27;
                         &#x27;                            if (a instanceof AppInfo &#x27;
                         &#x27;&amp;&amp;\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;LauncherModel.appWasPromise(context, launchIntent, &#x27;
                         &#x27;a.user)) {\n&#x27;
                         &#x27;                                &#x27;
                         &#x27;restoredAppsFinal.add((AppInfo) a);\n&#x27;
                         &#x27;                            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                                        &#x27;
                         &#x27;addNotAnimated, addAnimated, null);\n&#x27;
                         &#x27;                                if &#x27;
                         &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                         &#x27;                                    &#x27;
                         &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                         &#x27;                                }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                                        &#x27;
                           &#x27;addNotAnimated, addAnimated, null);\n&#x27;
                           &#x27;                                if &#x27;
                           &#x27;(!restoredAppsFinal.isEmpty()) {\n&#x27;
                           &#x27;                                    &#x27;
                           &#x27;callbacks.bindAppsUpdated(restoredAppsFinal);\n&#x27;
                           &#x27;                                }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;     * Returns true if the promise shortcuts with &#x27;
                         &#x27;the same package name exists on the workspace.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    static boolean appWasPromise(Context context, &#x27;
                         &#x27;Intent intent, UserHandleCompat user) {\n&#x27;
                         &#x27;        final ComponentName component = &#x27;
                         &#x27;intent.getComponent();\n&#x27;
                         &#x27;        if (component == null) {\n&#x27;
                         &#x27;            return false;\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;!getItemsByPackageName(component.getPackageName(), &#x27;
                         &#x27;user).isEmpty();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                                    if &#x27;
                         &#x27;(user.equals(UserHandleCompat.myUserHandle())) {\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;Launcher.addDumpLog(TAG,\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;&quot;constructing info for partially restored package&quot;,\n&#x27;
                         &#x27;                                                &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;                                        info = &#x27;
                         &#x27;getRestoredItemInfo(c, titleIndex, intent, &#x27;
                         &#x27;promiseType);\n&#x27;
                         &#x27;                                        intent = &#x27;
                         &#x27;getRestoredItemIntent(c, context, intent);\n&#x27;
                         &#x27;                                    } else {\n&#x27;
                         &quot;                                        // Don&#x27;t &quot;
                         &#x27;restore items for other profiles.\n&#x27;
                         &#x27;                                        &#x27;
                         &#x27;itemsToRemove.add(id);\n&#x27;
                         &#x27;                                        continue;\n&#x27;
                         &#x27;                                    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                                    &#x27;
                           &#x27;Launcher.addDumpLog(TAG,\n&#x27;
                           &#x27;                                            &#x27;
                           &#x27;&quot;constructing info for partially restored &#x27;
                           &#x27;package&quot;,\n&#x27;
                           &#x27;                                            &#x27;
                           &#x27;true);\n&#x27;
                           &#x27;                                    info = &#x27;
                           &#x27;getRestoredItemInfo(c, titleIndex);\n&#x27;
                           &#x27;                                    intent = &#x27;
                           &#x27;getRestoredItemIntent(c, context, intent);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public ShortcutInfo getRestoredItemInfo(Cursor &#x27;
                         &#x27;cursor, int titleIndex, Intent intent,\n&#x27;
                         &#x27;            int promiseType) {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public ShortcutInfo getRestoredItemInfo(Cursor &#x27;
                           &#x27;cursor, int titleIndex) {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        info.promisedIntent = intent;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                .appendQueryParameter(&quot;id&quot;, &#x27;
                         &#x27;packageName)\n&#x27;
                         &#x27;                .build());\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                .appendQueryParameter(&quot;id&quot;, &#x27;
                           &#x27;componentName.getPackageName())\n&#x27;
                           &#x27;                .build();\n&#x27;
                           &#x27;        Log.d(TAG, &quot;manufactured intent uri: &quot; + &#x27;
                           &#x27;marketUri.toString());\n&#x27;
                           &#x27;        marketIntent.setData(marketUri);\n&#x27;
                           &#x27;        return marketIntent;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            // placeholder shortcuts get special &#x27;
                         &#x27;treatment, let them through too.\n&#x27;
                         &#x27;            if (info.isPromise()) {\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        