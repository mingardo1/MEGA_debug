<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>441</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    441
                    <a href="440.html">prev</a>
                    <a href="442.html">next</a>
                    <a href="441_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_d3f904d1d764e0acb7127ddbeb050c2b3ff060b3_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d3f904d1d764e0acb7127ddbeb050c2b3ff060b3^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d124305ffe07b66f8eee430b3c0ac1072281dc14:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.common.typeinfo.Types;
  25 import org.apache.flink.api.java.tuple.Tuple2;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  28 import org.apache.flink.streaming.api.datastream.DataStream;
  29 import org.apache.flink.table.api.Table;
  30 import org.apache.flink.table.api.TableSchema;
  31 import org.apache.flink.table.api.java.StreamTableEnvironment;
  32 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  33 import org.apache.flink.types.Row;
  34 
  35 import com.dtstack.flink.sql.enums.ECacheType;
  36 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  37 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  38 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  39 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  40 import com.dtstack.flink.sql.util.ClassUtil;
  41 import com.dtstack.flink.sql.util.ParseUtils;
  42 import com.dtstack.flink.sql.util.TableUtils;
  43 import com.google.common.base.Preconditions;
  44 import com.google.common.collect.HashBasedTable;
  45 import com.google.common.collect.Lists;
  46 import com.google.common.collect.Maps;
  47 import com.google.common.collect.Sets;
  48 import org.apache.calcite.sql.SqlAsOperator;
  49 import org.apache.calcite.sql.SqlBasicCall;
  50 import org.apache.calcite.sql.SqlDataTypeSpec;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlInsert;
  53 import org.apache.calcite.sql.SqlJoin;
  54 import org.apache.calcite.sql.SqlKind;
  55 import org.apache.calcite.sql.SqlLiteral;
  56 import org.apache.calcite.sql.SqlNode;
  57 import org.apache.calcite.sql.SqlNodeList;
  58 import org.apache.calcite.sql.SqlOperator;
  59 import org.apache.calcite.sql.SqlOrderBy;
  60 import org.apache.calcite.sql.SqlSelect;
  61 import org.apache.calcite.sql.SqlWithItem;
  62 import org.apache.calcite.sql.fun.SqlCase;
  63 import org.apache.calcite.sql.parser.SqlParseException;
  64 import org.apache.calcite.sql.parser.SqlParserPos;
  65 import org.apache.commons.collections.CollectionUtils;
  66 import org.apache.commons.lang3.StringUtils;
  67 import org.slf4j.Logger;
  68 import org.slf4j.LoggerFactory;
  69 
  70 import java.sql.Timestamp;
  71 import java.time.LocalDateTime;
  72 import java.util.Arrays;
  73 import java.util.Collection;
  74 import java.util.LinkedList;
  75 import java.util.List;
  76 import java.util.Map;
  77 import java.util.Queue;
  78 import java.util.Set;
  79 
  80 import static org.apache.calcite.sql.SqlKind.*;
  81 
  82 /**
  83  * Reason:
  84  * Date: 2018/7/24
  85  * Company: www.dtstack.com
  86  * @author xuchao
  87  */
  88 
  89 public class SideSqlExec {
  90 
  91     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  92 
  93     private String localSqlPluginPath = null;
  94 
  95     private String tmpFields = null;
  96 
  97     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  98 
  99     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 100 
<abbr title=" 101     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 101     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
<abbr title=" 102                      Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 102                      Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) thro🔵</abbr>
 103         if(localSqlPluginPath == null){
 104             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 105         }
 106 
 107         localTableCache.putAll(tableCache);
 108         try {
 109             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 110         } catch (Exception e) {
 111             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 112         }
 113 
 114         if(createView != null){
 115             LOG.warn(&quot;create view info\n&quot;);
 116             LOG.warn(createView.getExecSql());
 117             LOG.warn(&quot;-----------------&quot;);
 118         }
 119 
 120         SideSQLParser sideSQLParser = new SideSQLParser();
 121         sideSQLParser.setLocalTableCache(localTableCache);
 122         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 123         Object pollObj = null;
 124 
 125         //need clean
 126         boolean preIsSideJoin = false;
 127         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 128 
 129         while((pollObj = exeQueue.poll()) != null){
 130 
 131             if(pollObj instanceof SqlNode){
 132                 SqlNode pollSqlNode = (SqlNode) pollObj;
 133 
 134                 if(preIsSideJoin){
 135                     preIsSideJoin = false;
 136                     List&lt;String&gt; fieldNames = null;
 137                     for(FieldReplaceInfo replaceInfo : replaceInfoList){
 138                         fieldNames = Lists.newArrayList();
 139                         replaceFieldName(pollSqlNode, replaceInfo);
 140                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 141                     }
 142                 }
 143 
 144                 if(pollSqlNode.getKind() == INSERT){
 145 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                     System.out.println(pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
 149 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150                 if(pollSqlNode.getKind() == INSERT){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152                     System.out.println(pollSqlNode.toString());</span>
 153 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
 155 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 156                     if(LOG.isInfoEnabled()){
 157                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 158                     }
 159 
 160                 }else if(pollSqlNode.getKind() == AS){
 161                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 162 
 163                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 164                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 165                     String TableAlias = sqlWithItem.name.toString();
 166                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 167                     tableEnv.registerTable(TableAlias, table);
 168 
 169                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 170                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 170                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 171                     Table table = tableEnv.sqlQuery(pollObj.toString());
 172 
 173                     if (createView.getFieldsInfoStr() == null){
 174                         tableEnv.registerTable(createView.getTableName(), table);
 175                     } else {
 176                         if (checkFieldsInfo(createView, table)){
 177                             table = table.as(tmpFields);
 178                             tableEnv.registerTable(createView.getTableName(), table);
 179                         } else {
 180                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 181                         }
 182                     }
 183 
 184                     localTableCache.put(createView.getTableName(), table);
 185                 }
 186 
 187             }else if (pollObj instanceof JoinInfo){
 188                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 189                 preIsSideJoin = true;
 190                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 191             }
 192         }
 193 
 194     }
 195 
 196 
 197     /**
 198      * 解析出as查询的表和字段的关系
 199      * @param asSqlNode
 200      * @param tableCache
 201      * @return
 202      */
 203     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 204         SqlNode info = asSqlNode.getOperands()[0];
 205         SqlNode alias = asSqlNode.getOperands()[1];
 206 
 207         SqlKind infoKind = info.getKind();
 208         if(infoKind != SELECT){
 209             return null;
 210         }
 211 
 212         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 213 
 214         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 215         for (FieldInfo fieldInfo : extractFieldList) {
 216             String tableName = fieldInfo.getTable();
 217             String fieldName = fieldInfo.getFieldName();
 218             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 219             mappingTable.put(tableName, fieldName, mappingFieldName);
 220         }
 221 
 222         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 223         replaceInfo.setMappingTable(mappingTable);
 224         replaceInfo.setTargetTableName(alias.toString());
 225         replaceInfo.setTargetTableAlias(alias.toString());
 226         return replaceInfo;
 227     }
 228 
 229 
 230     /**
 231      * 添加字段别名
 232      * @param pollSqlNode
 233      * @param fieldList
 234      * @param mappingTable
 235      */
<abbr title=" 236     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 236     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 237         SqlKind sqlKind = pollSqlNode.getKind();
 238         switch (sqlKind) {
 239             case INSERT:
 240                 SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 241                 addAliasForFieldNode(source, fieldList, mappingTable);
 242                 break;
 243             case AS:
<abbr title=" 244                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);"> 244                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTab🔵</abbr>
 245                 break;
 246             case SELECT:
 247                 SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 248                 selectList.getList().forEach(node -&gt; {
 249                     if (node.getKind() == IDENTIFIER) {
 250                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 251                         if (sqlIdentifier.names.size() == 1) {
 252                             return;
 253                         }
 254                         // save real field
 255                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 256                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 256                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap🔵</abbr>
 257                             fieldList.add(fieldName);
 258                         }
 259 
 260                     }
 261                 });
 262                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 263                     SqlNode node = selectList.get(i);
 264                     if (node.getKind() == IDENTIFIER) {
 265                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 266                         if (sqlIdentifier.names.size() == 1) {
 267                             return;
 268                         }
 269                         String name = sqlIdentifier.names.get(1);
 270                         // avoid real field pv0 convert pv
<abbr title=" 271                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 271                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.🔵</abbr>
 272                             SqlOperator operator = new SqlAsOperator();
 273                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 274 
<abbr title=" 275                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 275                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 276                             SqlNode[] sqlNodes = new SqlNode[2];
 277                             sqlNodes[0] = sqlIdentifier;
 278                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 279                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 279                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 280 
 281                             selectList.set(i, sqlBasicCall);
 282                         }
 283                     }
 284                 }
 285                 break;
 286             default:
 287                 break;
 288         }
 289     }
 290 
 291 
 292     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 293         SqlKind sqlKind = sqlNode.getKind();
 294         if(sqlKind != AS){
 295             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 296         }
 297 
 298         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 299         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 300 
 301         AliasInfo aliasInfo = new AliasInfo();
 302         aliasInfo.setName(info.toString());
 303         aliasInfo.setAlias(alias.toString());
 304 
 305         return aliasInfo;
 306     }
 307 
<abbr title=" 308     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 308     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 309         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 310         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 311         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 312             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 313             String tableName = fieldInfo.getTable();
 314             String fieldName = fieldInfo.getFieldName();
 315             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 316             mappingTable.put(tableName, fieldName, mappingFieldName);
 317 
 318             sideOutTypes[i] = fieldInfo.getTypeInformation();
 319             sideOutNames[i] = mappingFieldName;
 320         }
 321         return new RowTypeInfo(sideOutTypes, sideOutNames);
 322     }
 323 
 324 
 325 
 326     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 327         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 328             return TypeInformation.of(LocalDateTime.class);
 329         }
 330         return typeInformation;
 331     }
 332 
 333     //需要考虑更多的情况
 334     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 335         SqlKind sqlKind = sqlNode.getKind();
 336         switch (sqlKind) {
 337             case INSERT:
 338                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 339                 replaceFieldName(sqlSource, replaceInfo);
 340                 break;
 341             case AS:
 342                 SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 343                 replaceFieldName(asNode, replaceInfo);
 344                 break;
 345             case SELECT:
<abbr title=" 346                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 346                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTarget🔵</abbr>
 347                 if(sqlSelect == null){
 348                     return;
 349                 }
 350 
 351                 SqlNode sqlSource1 = sqlSelect.getFrom();
 352                 if(sqlSource1.getKind() == AS){
 353                     String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 354                     if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 355                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 356                         SqlNode whereNode = sqlSelect.getWhere();
 357                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 358 
 359                         //TODO 暂时不处理having
 360                         SqlNode sqlHaving = sqlSelect.getHaving();
 361 
 362                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 363                         for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 364                             SqlNode selectNode = sqlSelectList.getList().get(i);
 365                             //特殊处理 isStar的标识
<abbr title=" 366                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){"> 366                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar(🔵</abbr>
<abbr title=" 367                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 367                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 368                                 newSelectNodeList.addAll(replaceNodeList);
 369                                 continue;
 370                             }
 371 
 372                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 373                             if(replaceNode == null){
 374                                 continue;
 375                             }
 376 
 377                             //sqlSelectList.set(i, replaceNode);
 378                             newSelectNodeList.add(replaceNode);
 379                         }
 380 
<abbr title=" 381                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 381                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 382                         sqlSelect.setSelectList(newSelectList);
 383 
 384                         //where
 385                         if(whereNode != null){
 386                             SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 387                             for(int i =0; i&lt;sqlNodeList.length; i++) {
 388                                 SqlNode whereSqlNode = sqlNodeList[i];
 389                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 390                                 sqlNodeList[i] = replaceNode;
 391                             }
 392                         }
 393                         if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 394                             for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 395                                 SqlNode selectNode = sqlGroup.getList().get(i);
 396                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 397                                 sqlGroup.set(i, replaceNode);
 398                             }
 399                         }
 400                     }
 401                 }else{
 402                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 403                 }
 404 
 405                 break;
 406             case UNION:
 407                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 408                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 409                 replaceFieldName(unionLeft, replaceInfo);
 410                 replaceFieldName(unionRight, replaceInfo);
 411 
 412                 break;
 413             case ORDER_BY:
 414                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 415                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 416                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 417                 for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 418                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 418                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 419                     orderFiledList.set(i, replaceNode);
 420                 }
 421 
 422             default:
 423                 break;
 424         }
 425     }
 426 
 427     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 428         if(orderNode.getKind() == IDENTIFIER){
 429             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 430             if (sqlIdentifier.names.size() == 1) {
 431                 return orderNode;
 432             }
 433             return sqlIdentifier.setName(0, tableAlias);
 434         } else if (orderNode instanceof  SqlBasicCall) {
 435             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 436             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 437                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 438                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 439             }
 440             return sqlBasicCall;
 441         } else {
 442             return orderNode;
 443         }
 444     }
 445 
 446     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 447         if(groupNode.getKind() == IDENTIFIER){
 448             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 449             if(sqlIdentifier.names.size() == 1){
 450                 return sqlIdentifier;
 451             }
 452 
<abbr title=" 453             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 453             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 454             if(mappingFieldName == null){
 455                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 456             }
 457 
 458             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 459             return sqlIdentifier.setName(1, mappingFieldName);
 460         }else if(groupNode instanceof  SqlBasicCall){
 461             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 462             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 463                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 464                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 465                 sqlBasicCall.getOperands()[i] = replaceNode;
 466             }
 467 
 468             return sqlBasicCall;
 469         }else{
 470             return groupNode;
 471         }
 472     }
 473 
 474     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 475 
 476         SqlKind sqlKind = sqlNode.getKind();
 477         switch (sqlKind){
 478             case SELECT:
 479                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
<abbr title=" 480                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 480                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr>
<abbr title=" 481                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 481                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr>
 482                         return sqlNode;
 483                     }else{
 484                         return null;
 485                     }
 486                 }else{
 487                     return filterNodeWithTargetName(fromNode, targetTableName);
 488                 }
 489             case AS:
 490                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 491                 return filterNodeWithTargetName(childNode, targetTableName);
 492             case JOIN:
 493                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 494                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 495                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 496                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 497 
 498                 if(leftReturnNode != null) {
 499                     return leftReturnNode;
 500                 }else if(rightReturnNode != null){
 501                     return rightReturnNode;
 502                 }else{
 503                     return null;
 504                 }
 505             default:
 506                 break;
 507         }
 508 
 509         return null;
 510     }
 511 
 512 
 513     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 514         this.localSqlPluginPath = localSqlPluginPath;
 515     }
 516 
<abbr title=" 517     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 517     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 518         Table table = localTableCache.get(tableAlias);
 519         if(table == null){
 520             table = localTableCache.get(tableName);
 521         }
 522 
 523         if(table == null){
 524             throw new RuntimeException(&quot;not register table &quot; + tableName);
 525         }
 526 
 527         return table;
 528     }
 529 
 530     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 531         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 532         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 533         if(sqlIdentifier.isStar()){//处理 [* or table.*]
 534             int identifierSize = sqlIdentifier.names.size();
 535             Collection&lt;String&gt; columns = null;
 536             if(identifierSize == 1){
 537                 columns = replaceInfo.getMappingTable().values();
 538             }else{
 539                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 540             }
 541 
 542             for(String colAlias : columns){
 543                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 544                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 545                 columnInfo.add(replaceInfo.getTargetTableAlias());
 546                 columnInfo.add(colAlias);
 547                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 548                 sqlNodes.add(sqlIdentifierAlias);
 549             }
 550 
 551             return sqlNodes;
 552         }else{
 553             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 554         }
 555     }
 556 
 557     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 558         if (selectNode.getKind() == AS) {
 559             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 560             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 561             if (replaceNode != null) {
 562                 ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 563             }
 564 
 565             return selectNode;
 566         }else if(selectNode.getKind() == IDENTIFIER){
 567             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 568 
 569             if(sqlIdentifier.names.size() == 1){
 570                 return selectNode;
 571             }
 572 
 573             //Same level mappingTable
<abbr title=" 574             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 574             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 575             if (mappingFieldName == null) {
 576                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 577             }
 578 
 579             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 580             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 581             return sqlIdentifier;
 582         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 583             return selectNode;
 584         }else if(  AGGREGATE.contains(selectNode.getKind())
 585                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 586                 || COMPARISON.contains(selectNode.getKind())
 587                 || selectNode.getKind() == OTHER_FUNCTION
 588                 || selectNode.getKind() == DIVIDE
 589                 || selectNode.getKind() == CAST
 590                 || selectNode.getKind() == TRIM
 591                 || selectNode.getKind() == TIMES
 592                 || selectNode.getKind() == PLUS
 593                 || selectNode.getKind() == NOT_IN
 594                 || selectNode.getKind() == OR
 595                 || selectNode.getKind() == AND
 596                 || selectNode.getKind() == MINUS
 597                 || selectNode.getKind() == TUMBLE
 598                 || selectNode.getKind() == TUMBLE_START
 599                 || selectNode.getKind() == TUMBLE_END
 600                 || selectNode.getKind() == SESSION
 601                 || selectNode.getKind() == SESSION_START
 602                 || selectNode.getKind() == SESSION_END
 603                 || selectNode.getKind() == HOP
 604                 || selectNode.getKind() == HOP_START
 605                 || selectNode.getKind() == HOP_END
 606                 || selectNode.getKind() == BETWEEN
 607                 || selectNode.getKind() == IS_NULL
 608                 || selectNode.getKind() == IS_NOT_NULL
 609                 || selectNode.getKind() == CONTAINS
 610                 || selectNode.getKind() == TIMESTAMP_ADD
 611                 || selectNode.getKind() == TIMESTAMP_DIFF
 612                 || selectNode.getKind() == LIKE
 613 
 614                 ){
 615             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 616             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 617                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 618                 if(sqlNode instanceof SqlLiteral){
 619                     continue;
 620                 }
 621 
 622                 if(sqlNode instanceof SqlDataTypeSpec){
 623                     continue;
 624                 }
 625 
 626                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 627                 if(replaceNode == null){
 628                     continue;
 629                 }
 630 
 631                 sqlBasicCall.getOperands()[i] = replaceNode;
 632             }
 633 
 634             return selectNode;
 635         }else if(selectNode.getKind() == CASE){
 636             SqlCase sqlCase = (SqlCase) selectNode;
 637             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 638             SqlNodeList thenOperands = sqlCase.getThenOperands();
 639             SqlNode elseNode = sqlCase.getElseOperand();
 640 
 641             for(int i=0; i&lt;whenOperands.size(); i++){
 642                 SqlNode oneOperand = whenOperands.get(i);
 643                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 644                 if (replaceNode != null) {
 645                     whenOperands.set(i, replaceNode);
 646                 }
 647             }
 648 
 649             for(int i=0; i&lt;thenOperands.size(); i++){
 650                 SqlNode oneOperand = thenOperands.get(i);
 651                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 652                 if (replaceNode != null) {
 653                     thenOperands.set(i, replaceNode);
 654                 }
 655             }
 656 
 657             ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 658             return selectNode;
 659         }else if(selectNode.getKind() == OTHER){
 660             //不处理
 661             return selectNode;
 662         }else{
<abbr title=" 663             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 663             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 664         }
 665     }
 666 
 667     /**
<abbr title=" 668      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 668      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 669      *
 670      * @return
 671      */
<abbr title=" 672     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 672     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 673         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 674         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 675             return true;
 676         }
 677         return false;
 678     }
 679 
 680     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 681         List&lt;String&gt; res = Lists.newArrayList();
 682         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 683             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 684         });
 685         return res;
 686     }
 687 
<abbr title=" 688     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 688     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 689         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 690         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 691         List&lt;String&gt; conditionFields = Lists.newArrayList();
 692         for(SqlNode sqlNode : sqlNodeList){
 693             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 694                 throw new RuntimeException(&quot;not compare operator.&quot;);
 695             }
 696 
 697             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 698             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 699 
 700             String leftTableName = left.getComponent(0).getSimple();
 701             String rightTableName = right.getComponent(0).getSimple();
 702 
 703             String tableCol = &quot;&quot;;
 704             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 705                 tableCol = left.getComponent(1).getSimple();
 706             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 707                 tableCol = right.getComponent(1).getSimple();
 708             }else{
<abbr title=" 709                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 709                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 710             }
 711             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 712             conditionFields.add(tableCol);
 713         }
 714 
 715         return conditionFields;
 716     }
 717 
 718     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 719                                      SqlNode pollSqlNode,
 720                                      Map&lt;String, Table&gt; tableCache,
 721                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 722 
 723         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 724         if (localTableCache.containsKey(aliasInfo.getName())) {
 725             return;
 726         }
 727 
 728         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 729         tableEnv.registerTable(aliasInfo.getAlias(), table);
 730         localTableCache.put(aliasInfo.getAlias(), table);
 731 
 732         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 733 
 734         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 735         if(fieldReplaceInfo == null){
 736            return;
 737         }
 738 
 739         //as 的源表
 740         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 741         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 742         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 743         for(FieldReplaceInfo tmp : replaceInfoList){
 744             if(fromTableNameSet.contains(tmp.getTargetTableName())
 745                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 746                 fieldReplaceInfo.setPreNode(tmp);
 747                 break;
 748             }
 749         }
 750         replaceInfoList.add(fieldReplaceInfo);
 751     }
 752 
 753     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
<abbr title=" 754                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 754                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr>
 755                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 756         JoinInfo joinInfo = (JoinInfo) pollObj;
 757 
 758         JoinScope joinScope = new JoinScope();
 759         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 760         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 761         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 762 
 763         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 764         if(sqlKind == AS){
 765             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 766         }
 767 
<abbr title=" 768         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 768         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 769 
<abbr title=" 770         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 770         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 771         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 772 
 773         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 774         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 775         rightScopeChild.setTableName(joinInfo.getRightTableName());
 776         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 777         if(sideTableInfo == null){
 778             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 779         }
 780 
 781         if(sideTableInfo == null){
 782             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 783         }
 784 
 785 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 786 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 787 //        }
 788 
 789         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 790 
 791         joinScope.addScope(leftScopeChild);
 792         joinScope.addScope(rightScopeChild);
 793 
 794         //获取两个表的所有字段
<abbr title=" 795         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 795         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 796 
 797         String leftTableAlias = joinInfo.getLeftTableAlias();
 798         Table targetTable = localTableCache.get(leftTableAlias);
 799         if(targetTable == null){
 800             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 801         }
 802 
<abbr title=" 803         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 803         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 804 
 805         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 806 
 807         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 808         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 809             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 809             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 810             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 811             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 812             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 812             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 813         }
 814 
 815         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 816         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 817             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 817             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 818         }else{
<abbr title=" 819             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 819             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 820         }
 821 
 822         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 823         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 824 
 825         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 826         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 827 
 828         String targetTableName = joinInfo.getNewTableName();
 829         String targetTableAlias = joinInfo.getNewTableAlias();
 830 
 831         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 832         replaceInfo.setMappingTable(mappingTable);
 833         replaceInfo.setTargetTableName(targetTableName);
 834         replaceInfo.setTargetTableAlias(targetTableAlias);
 835 
 836         //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 837         for(FieldReplaceInfo tmp : replaceInfoList){
 838             if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 839             ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 840                 replaceInfo.setPreNode(tmp);
 841                 break;
 842             }
 843         }
 844 
 845         replaceInfoList.add(replaceInfo);
 846 
 847         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());
 848         if (!registeredTableName.contains(joinInfo.getNewTableName())){
 849             Table joinTable = tableEnv.fromDataStream(dsOut);
 850             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 851             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 852         }
 853     }
 854 
 855     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 856         String[] fieldNames = schema.getFieldNames();
 857         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 858 
<abbr title=" 859         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 859         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 860         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 860         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 861         return new RowTypeInfo(projectedTypes, projectedNames);
 862     }
 863 
 864 
 865     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 866         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 867         String fieldsInfo = result.getFieldsInfoStr();
 868         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 869         for (int i = 0; i &lt; fields.length; i++) {
 870             String[] filed = fields[i].split(&quot;\\s&quot;);
 871             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 872                 return false;
 873             } else {
 874                 String[] filedNameArr = new String[filed.length - 1];
 875                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 876                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 877                 fieldNames.add(fieldName);
 878                 String fieldType = filed[filed.length - 1 ].trim();
 879                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 880                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 881                 if (fieldClass == tableField){
 882                     continue;
 883                 } else {
 884                     return false;
 885                 }
 886             }
 887         }
 888         tmpFields = String.join(&quot;,&quot;, fieldNames);
 889         return true;
 890     }
 891 
 892 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.common.typeinfo.Types;
  25 import org.apache.flink.api.java.tuple.Tuple2;
  26 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  27 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  28 import org.apache.flink.streaming.api.datastream.DataStream;
  29 import org.apache.flink.table.api.Table;
  30 import org.apache.flink.table.api.TableSchema;
  31 import org.apache.flink.table.api.java.StreamTableEnvironment;
  32 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  33 import org.apache.flink.types.Row;
  34 
  35 import com.dtstack.flink.sql.enums.ECacheType;
  36 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  37 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  38 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  39 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  40 import com.dtstack.flink.sql.util.ClassUtil;
  41 import com.dtstack.flink.sql.util.ParseUtils;
  42 import com.dtstack.flink.sql.util.TableUtils;
  43 import com.google.common.base.Preconditions;
  44 import com.google.common.collect.HashBasedTable;
  45 import com.google.common.collect.Lists;
  46 import com.google.common.collect.Maps;
  47 import com.google.common.collect.Sets;
  48 import org.apache.calcite.sql.SqlAsOperator;
  49 import org.apache.calcite.sql.SqlBasicCall;
  50 import org.apache.calcite.sql.SqlDataTypeSpec;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlInsert;
  53 import org.apache.calcite.sql.SqlJoin;
  54 import org.apache.calcite.sql.SqlKind;
  55 import org.apache.calcite.sql.SqlLiteral;
  56 import org.apache.calcite.sql.SqlNode;
  57 import org.apache.calcite.sql.SqlNodeList;
  58 import org.apache.calcite.sql.SqlOperator;
  59 import org.apache.calcite.sql.SqlOrderBy;
  60 import org.apache.calcite.sql.SqlSelect;
  61 import org.apache.calcite.sql.SqlWithItem;
  62 import org.apache.calcite.sql.fun.SqlCase;
  63 import org.apache.calcite.sql.parser.SqlParseException;
  64 import org.apache.calcite.sql.parser.SqlParserPos;
  65 import org.apache.commons.collections.CollectionUtils;
  66 import org.apache.commons.lang3.StringUtils;
  67 import org.slf4j.Logger;
  68 import org.slf4j.LoggerFactory;
  69 
  70 import java.sql.Timestamp;
  71 import java.time.LocalDateTime;
  72 import java.util.Arrays;
  73 import java.util.Collection;
  74 import java.util.LinkedList;
  75 import java.util.List;
  76 import java.util.Map;
  77 import java.util.Queue;
  78 import java.util.Set;
  79 
  80 import static org.apache.calcite.sql.SqlKind.*;
  81 
  82 /**
  83  * Reason:
  84  * Date: 2018/7/24
  85  * Company: www.dtstack.com
  86  * @author xuchao
  87  */
  88 
  89 public class SideSqlExec {
  90 
  91     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  92 
  93     private String localSqlPluginPath = null;
  94 
  95     private String tmpFields = null;
  96 
  97     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  98 
  99     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 100 
<abbr title=" 101     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 101     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
<abbr title=" 102                      Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 102                      Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) thro🔵</abbr>
 103         if(localSqlPluginPath == null){
 104             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 105         }
 106 
 107         localTableCache.putAll(tableCache);
 108         try {
 109             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 110         } catch (Exception e) {
 111             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 112         }
 113 
 114         if(createView != null){
 115             LOG.warn(&quot;create view info\n&quot;);
 116             LOG.warn(createView.getExecSql());
 117             LOG.warn(&quot;-----------------&quot;);
 118         }
 119 
 120         SideSQLParser sideSQLParser = new SideSQLParser();
 121         sideSQLParser.setLocalTableCache(localTableCache);
 122         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 123         Object pollObj = null;
 124 
 125         //need clean
 126         boolean preIsSideJoin = false;
 127         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 128 
 129         while((pollObj = exeQueue.poll()) != null){
 130 
 131             if(pollObj instanceof SqlNode){
 132                 SqlNode pollSqlNode = (SqlNode) pollObj;
 133 
 134                 if(preIsSideJoin){
 135                     preIsSideJoin = false;
 136                     List&lt;String&gt; fieldNames = null;
 137                     for(FieldReplaceInfo replaceInfo : replaceInfoList){
 138                         fieldNames = Lists.newArrayList();
 139                         replaceFieldName(pollSqlNode, replaceInfo);
 140                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 141                     }
 142                 }
 143 
 144                 if(pollSqlNode.getKind() == INSERT){
 145 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 146                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 147                     System.out.println(pollSqlNode.toString());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 148                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
 149 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 150                     System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 151                     System.out.println(pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 152                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
 153 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
 155 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 156                     if(LOG.isInfoEnabled()){
 157                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 158                     }
 159 
 160                 }else if(pollSqlNode.getKind() == AS){
 161                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 162 
 163                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 164                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 165                     String TableAlias = sqlWithItem.name.toString();
 166                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 167                     tableEnv.registerTable(TableAlias, table);
 168 
 169                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 170                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 170                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 171                     Table table = tableEnv.sqlQuery(pollObj.toString());
 172 
 173                     if (createView.getFieldsInfoStr() == null){
 174                         tableEnv.registerTable(createView.getTableName(), table);
 175                     } else {
 176                         if (checkFieldsInfo(createView, table)){
 177                             table = table.as(tmpFields);
 178                             tableEnv.registerTable(createView.getTableName(), table);
 179                         } else {
 180                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 181                         }
 182                     }
 183 
 184                     localTableCache.put(createView.getTableName(), table);
 185                 }
 186 
 187             }else if (pollObj instanceof JoinInfo){
 188                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 189                 preIsSideJoin = true;
 190                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 191             }
 192         }
 193 
 194     }
 195 
 196 
 197     /**
 198      * 解析出as查询的表和字段的关系
 199      * @param asSqlNode
 200      * @param tableCache
 201      * @return
 202      */
 203     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 204         SqlNode info = asSqlNode.getOperands()[0];
 205         SqlNode alias = asSqlNode.getOperands()[1];
 206 
 207         SqlKind infoKind = info.getKind();
 208         if(infoKind != SELECT){
 209             return null;
 210         }
 211 
 212         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 213 
 214         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 215         for (FieldInfo fieldInfo : extractFieldList) {
 216             String tableName = fieldInfo.getTable();
 217             String fieldName = fieldInfo.getFieldName();
 218             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 219             mappingTable.put(tableName, fieldName, mappingFieldName);
 220         }
 221 
 222         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 223         replaceInfo.setMappingTable(mappingTable);
 224         replaceInfo.setTargetTableName(alias.toString());
 225         replaceInfo.setTargetTableAlias(alias.toString());
 226         return replaceInfo;
 227     }
 228 
 229 
 230     /**
 231      * 添加字段别名
 232      * @param pollSqlNode
 233      * @param fieldList
 234      * @param mappingTable
 235      */
<abbr title=" 236     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 236     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 237         SqlKind sqlKind = pollSqlNode.getKind();
 238         switch (sqlKind) {
 239             case INSERT:
 240                 SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 241                 addAliasForFieldNode(source, fieldList, mappingTable);
 242                 break;
 243             case AS:
<abbr title=" 244                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);"> 244                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTab🔵</abbr>
 245                 break;
 246             case SELECT:
 247                 SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 248                 selectList.getList().forEach(node -&gt; {
 249                     if (node.getKind() == IDENTIFIER) {
 250                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 251                         if (sqlIdentifier.names.size() == 1) {
 252                             return;
 253                         }
 254                         // save real field
 255                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 256                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 256                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap🔵</abbr>
 257                             fieldList.add(fieldName);
 258                         }
 259 
 260                     }
 261                 });
 262                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 263                     SqlNode node = selectList.get(i);
 264                     if (node.getKind() == IDENTIFIER) {
 265                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 266                         if (sqlIdentifier.names.size() == 1) {
 267                             return;
 268                         }
 269                         String name = sqlIdentifier.names.get(1);
 270                         // avoid real field pv0 convert pv
<abbr title=" 271                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 271                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.🔵</abbr>
 272                             SqlOperator operator = new SqlAsOperator();
 273                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 274 
<abbr title=" 275                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 275                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 276                             SqlNode[] sqlNodes = new SqlNode[2];
 277                             sqlNodes[0] = sqlIdentifier;
 278                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 279                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 279                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 280 
 281                             selectList.set(i, sqlBasicCall);
 282                         }
 283                     }
 284                 }
 285                 break;
 286             default:
 287                 break;
 288         }
 289     }
 290 
 291 
 292     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 293         SqlKind sqlKind = sqlNode.getKind();
 294         if(sqlKind != AS){
 295             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 296         }
 297 
 298         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 299         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 300 
 301         AliasInfo aliasInfo = new AliasInfo();
 302         aliasInfo.setName(info.toString());
 303         aliasInfo.setAlias(alias.toString());
 304 
 305         return aliasInfo;
 306     }
 307 
<abbr title=" 308     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 308     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 309         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 310         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 311         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 312             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 313             String tableName = fieldInfo.getTable();
 314             String fieldName = fieldInfo.getFieldName();
 315             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 316             mappingTable.put(tableName, fieldName, mappingFieldName);
 317 
 318             sideOutTypes[i] = fieldInfo.getTypeInformation();
 319             sideOutNames[i] = mappingFieldName;
 320         }
 321         return new RowTypeInfo(sideOutTypes, sideOutNames);
 322     }
 323 
 324 
 325 
 326     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 327         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 328             return TypeInformation.of(LocalDateTime.class);
 329         }
 330         return typeInformation;
 331     }
 332 
 333     //需要考虑更多的情况
 334     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 335         SqlKind sqlKind = sqlNode.getKind();
 336         switch (sqlKind) {
 337             case INSERT:
 338                 SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 339                 replaceFieldName(sqlSource, replaceInfo);
 340                 break;
 341             case AS:
 342                 SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 343                 replaceFieldName(asNode, replaceInfo);
 344                 break;
 345             case SELECT:
<abbr title=" 346                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 346                 SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTarget🔵</abbr>
 347                 if(sqlSelect == null){
 348                     return;
 349                 }
 350 
 351                 SqlNode sqlSource1 = sqlSelect.getFrom();
 352                 if(sqlSource1.getKind() == AS){
 353                     String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 354                     if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 355                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 356                         SqlNode whereNode = sqlSelect.getWhere();
 357                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 358 
 359                         //TODO 暂时不处理having
 360                         SqlNode sqlHaving = sqlSelect.getHaving();
 361 
 362                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 363                         for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 364                             SqlNode selectNode = sqlSelectList.getList().get(i);
 365                             //特殊处理 isStar的标识
<abbr title=" 366                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){"> 366                             if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar(🔵</abbr>
<abbr title=" 367                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 367                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 368                                 newSelectNodeList.addAll(replaceNodeList);
 369                                 continue;
 370                             }
 371 
 372                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 373                             if(replaceNode == null){
 374                                 continue;
 375                             }
 376 
 377                             //sqlSelectList.set(i, replaceNode);
 378                             newSelectNodeList.add(replaceNode);
 379                         }
 380 
<abbr title=" 381                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 381                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 382                         sqlSelect.setSelectList(newSelectList);
 383 
 384                         //where
 385                         if(whereNode != null){
 386                             SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 387                             for(int i =0; i&lt;sqlNodeList.length; i++) {
 388                                 SqlNode whereSqlNode = sqlNodeList[i];
 389                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 390                                 sqlNodeList[i] = replaceNode;
 391                             }
 392                         }
 393                         if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 394                             for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 395                                 SqlNode selectNode = sqlGroup.getList().get(i);
 396                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 397                                 sqlGroup.set(i, replaceNode);
 398                             }
 399                         }
 400                     }
 401                 }else{
 402                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 403                 }
 404 
 405                 break;
 406             case UNION:
 407                 SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 408                 SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 409                 replaceFieldName(unionLeft, replaceInfo);
 410                 replaceFieldName(unionRight, replaceInfo);
 411 
 412                 break;
 413             case ORDER_BY:
 414                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 415                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 416                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 417                 for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 418                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 418                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 419                     orderFiledList.set(i, replaceNode);
 420                 }
 421 
 422             default:
 423                 break;
 424         }
 425     }
 426 
 427     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 428         if(orderNode.getKind() == IDENTIFIER){
 429             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 430             if (sqlIdentifier.names.size() == 1) {
 431                 return orderNode;
 432             }
 433             return sqlIdentifier.setName(0, tableAlias);
 434         } else if (orderNode instanceof  SqlBasicCall) {
 435             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 436             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 437                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 438                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 439             }
 440             return sqlBasicCall;
 441         } else {
 442             return orderNode;
 443         }
 444     }
 445 
 446     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 447         if(groupNode.getKind() == IDENTIFIER){
 448             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 449             if(sqlIdentifier.names.size() == 1){
 450                 return sqlIdentifier;
 451             }
 452 
<abbr title=" 453             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 453             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 454             if(mappingFieldName == null){
 455                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 456             }
 457 
 458             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 459             return sqlIdentifier.setName(1, mappingFieldName);
 460         }else if(groupNode instanceof  SqlBasicCall){
 461             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 462             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 463                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 464                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 465                 sqlBasicCall.getOperands()[i] = replaceNode;
 466             }
 467 
 468             return sqlBasicCall;
 469         }else{
 470             return groupNode;
 471         }
 472     }
 473 
 474     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 475 
 476         SqlKind sqlKind = sqlNode.getKind();
 477         switch (sqlKind){
 478             case SELECT:
 479                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
<abbr title=" 480                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 480                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr>
<abbr title=" 481                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 481                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr>
 482                         return sqlNode;
 483                     }else{
 484                         return null;
 485                     }
 486                 }else{
 487                     return filterNodeWithTargetName(fromNode, targetTableName);
 488                 }
 489             case AS:
 490                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 491                 return filterNodeWithTargetName(childNode, targetTableName);
 492             case JOIN:
 493                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 494                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 495                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 496                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 497 
 498                 if(leftReturnNode != null) {
 499                     return leftReturnNode;
 500                 }else if(rightReturnNode != null){
 501                     return rightReturnNode;
 502                 }else{
 503                     return null;
 504                 }
 505             default:
 506                 break;
 507         }
 508 
 509         return null;
 510     }
 511 
 512 
 513     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 514         this.localSqlPluginPath = localSqlPluginPath;
 515     }
 516 
<abbr title=" 517     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 517     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 518         Table table = localTableCache.get(tableAlias);
 519         if(table == null){
 520             table = localTableCache.get(tableName);
 521         }
 522 
 523         if(table == null){
 524             throw new RuntimeException(&quot;not register table &quot; + tableName);
 525         }
 526 
 527         return table;
 528     }
 529 
 530     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 531         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 532         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 533         if(sqlIdentifier.isStar()){//处理 [* or table.*]
 534             int identifierSize = sqlIdentifier.names.size();
 535             Collection&lt;String&gt; columns = null;
 536             if(identifierSize == 1){
 537                 columns = replaceInfo.getMappingTable().values();
 538             }else{
 539                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 540             }
 541 
 542             for(String colAlias : columns){
 543                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 544                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 545                 columnInfo.add(replaceInfo.getTargetTableAlias());
 546                 columnInfo.add(colAlias);
 547                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 548                 sqlNodes.add(sqlIdentifierAlias);
 549             }
 550 
 551             return sqlNodes;
 552         }else{
 553             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 554         }
 555     }
 556 
 557     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 558         if (selectNode.getKind() == AS) {
 559             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 560             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 561             if (replaceNode != null) {
 562                 ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 563             }
 564 
 565             return selectNode;
 566         }else if(selectNode.getKind() == IDENTIFIER){
 567             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 568 
 569             if(sqlIdentifier.names.size() == 1){
 570                 return selectNode;
 571             }
 572 
 573             //Same level mappingTable
<abbr title=" 574             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 574             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 575             if (mappingFieldName == null) {
 576                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 577             }
 578 
 579             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 580             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 581             return sqlIdentifier;
 582         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 583             return selectNode;
 584         }else if(  AGGREGATE.contains(selectNode.getKind())
 585                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 586                 || COMPARISON.contains(selectNode.getKind())
 587                 || selectNode.getKind() == OTHER_FUNCTION
 588                 || selectNode.getKind() == DIVIDE
 589                 || selectNode.getKind() == CAST
 590                 || selectNode.getKind() == TRIM
 591                 || selectNode.getKind() == TIMES
 592                 || selectNode.getKind() == PLUS
 593                 || selectNode.getKind() == NOT_IN
 594                 || selectNode.getKind() == OR
 595                 || selectNode.getKind() == AND
 596                 || selectNode.getKind() == MINUS
 597                 || selectNode.getKind() == TUMBLE
 598                 || selectNode.getKind() == TUMBLE_START
 599                 || selectNode.getKind() == TUMBLE_END
 600                 || selectNode.getKind() == SESSION
 601                 || selectNode.getKind() == SESSION_START
 602                 || selectNode.getKind() == SESSION_END
 603                 || selectNode.getKind() == HOP
 604                 || selectNode.getKind() == HOP_START
 605                 || selectNode.getKind() == HOP_END
 606                 || selectNode.getKind() == BETWEEN
 607                 || selectNode.getKind() == IS_NULL
 608                 || selectNode.getKind() == IS_NOT_NULL
 609                 || selectNode.getKind() == CONTAINS
 610                 || selectNode.getKind() == TIMESTAMP_ADD
 611                 || selectNode.getKind() == TIMESTAMP_DIFF
 612                 || selectNode.getKind() == LIKE
 613 
 614                 ){
 615             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 616             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 617                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 618                 if(sqlNode instanceof SqlLiteral){
 619                     continue;
 620                 }
 621 
 622                 if(sqlNode instanceof SqlDataTypeSpec){
 623                     continue;
 624                 }
 625 
 626                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 627                 if(replaceNode == null){
 628                     continue;
 629                 }
 630 
 631                 sqlBasicCall.getOperands()[i] = replaceNode;
 632             }
 633 
 634             return selectNode;
 635         }else if(selectNode.getKind() == CASE){
 636             SqlCase sqlCase = (SqlCase) selectNode;
 637             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 638             SqlNodeList thenOperands = sqlCase.getThenOperands();
 639             SqlNode elseNode = sqlCase.getElseOperand();
 640 
 641             for(int i=0; i&lt;whenOperands.size(); i++){
 642                 SqlNode oneOperand = whenOperands.get(i);
 643                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 644                 if (replaceNode != null) {
 645                     whenOperands.set(i, replaceNode);
 646                 }
 647             }
 648 
 649             for(int i=0; i&lt;thenOperands.size(); i++){
 650                 SqlNode oneOperand = thenOperands.get(i);
 651                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 652                 if (replaceNode != null) {
 653                     thenOperands.set(i, replaceNode);
 654                 }
 655             }
 656 
 657             ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 658             return selectNode;
 659         }else if(selectNode.getKind() == OTHER){
 660             //不处理
 661             return selectNode;
 662         }else{
<abbr title=" 663             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 663             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 664         }
 665     }
 666 
 667     /**
<abbr title=" 668      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 668      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 669      *
 670      * @return
 671      */
<abbr title=" 672     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 672     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 673         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 674         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 675             return true;
 676         }
 677         return false;
 678     }
 679 
 680     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 681         List&lt;String&gt; res = Lists.newArrayList();
 682         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 683             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 684         });
 685         return res;
 686     }
 687 
<abbr title=" 688     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 688     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 689         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 690         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 691         List&lt;String&gt; conditionFields = Lists.newArrayList();
 692         for(SqlNode sqlNode : sqlNodeList){
 693             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 694                 throw new RuntimeException(&quot;not compare operator.&quot;);
 695             }
 696 
 697             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 698             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 699 
 700             String leftTableName = left.getComponent(0).getSimple();
 701             String rightTableName = right.getComponent(0).getSimple();
 702 
 703             String tableCol = &quot;&quot;;
 704             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 705                 tableCol = left.getComponent(1).getSimple();
 706             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 707                 tableCol = right.getComponent(1).getSimple();
 708             }else{
<abbr title=" 709                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 709                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 710             }
 711             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 712             conditionFields.add(tableCol);
 713         }
 714 
 715         return conditionFields;
 716     }
 717 
 718     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 719                                      SqlNode pollSqlNode,
 720                                      Map&lt;String, Table&gt; tableCache,
 721                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 722 
 723         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 724         if (localTableCache.containsKey(aliasInfo.getName())) {
 725             return;
 726         }
 727 
 728         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 729         tableEnv.registerTable(aliasInfo.getAlias(), table);
 730         localTableCache.put(aliasInfo.getAlias(), table);
 731 
 732         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 733 
 734         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 735         if(fieldReplaceInfo == null){
 736            return;
 737         }
 738 
 739         //as 的源表
 740         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 741         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 742         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 743         for(FieldReplaceInfo tmp : replaceInfoList){
 744             if(fromTableNameSet.contains(tmp.getTargetTableName())
 745                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 746                 fieldReplaceInfo.setPreNode(tmp);
 747                 break;
 748             }
 749         }
 750         replaceInfoList.add(fieldReplaceInfo);
 751     }
 752 
 753     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
<abbr title=" 754                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,"> 754                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr>
 755                          List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 756         JoinInfo joinInfo = (JoinInfo) pollObj;
 757 
 758         JoinScope joinScope = new JoinScope();
 759         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 760         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 761         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 762 
 763         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 764         if(sqlKind == AS){
 765             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 766         }
 767 
<abbr title=" 768         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 768         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
 769 
<abbr title=" 770         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 770         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 771         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 772 
 773         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 774         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 775         rightScopeChild.setTableName(joinInfo.getRightTableName());
 776         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 777         if(sideTableInfo == null){
 778             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 779         }
 780 
 781         if(sideTableInfo == null){
 782             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 783         }
 784 
 785 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 786 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 787 //        }
 788 
 789         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 790 
 791         joinScope.addScope(leftScopeChild);
 792         joinScope.addScope(rightScopeChild);
 793 
 794         //获取两个表的所有字段
<abbr title=" 795         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 795         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 796 
 797         String leftTableAlias = joinInfo.getLeftTableAlias();
 798         Table targetTable = localTableCache.get(leftTableAlias);
 799         if(targetTable == null){
 800             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 801         }
 802 
<abbr title=" 803         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 803         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 804 
 805         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 806 
 807         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 808         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 809             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 809             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 810             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 811             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 812             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 812             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 813         }
 814 
 815         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 816         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 817             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 817             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 818         }else{
<abbr title=" 819             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 819             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 820         }
 821 
 822         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 823         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 824 
 825         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 826         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 827 
 828         String targetTableName = joinInfo.getNewTableName();
 829         String targetTableAlias = joinInfo.getNewTableAlias();
 830 
 831         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 832         replaceInfo.setMappingTable(mappingTable);
 833         replaceInfo.setTargetTableName(targetTableName);
 834         replaceInfo.setTargetTableAlias(targetTableAlias);
 835 
 836         //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 837         for(FieldReplaceInfo tmp : replaceInfoList){
 838             if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 839             ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 840                 replaceInfo.setPreNode(tmp);
 841                 break;
 842             }
 843         }
 844 
 845         replaceInfoList.add(replaceInfo);
 846 
 847         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());
 848         if (!registeredTableName.contains(joinInfo.getNewTableName())){
 849             Table joinTable = tableEnv.fromDataStream(dsOut);
 850             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 851             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 852         }
 853     }
 854 
 855     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 856         String[] fieldNames = schema.getFieldNames();
 857         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 858 
<abbr title=" 859         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 859         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 860         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 860         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 861         return new RowTypeInfo(projectedTypes, projectedNames);
 862     }
 863 
 864 
 865     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 866         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 867         String fieldsInfo = result.getFieldsInfoStr();
 868         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 869         for (int i = 0; i &lt; fields.length; i++) {
 870             String[] filed = fields[i].split(&quot;\\s&quot;);
 871             if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){
 872                 return false;
 873             } else {
 874                 String[] filedNameArr = new String[filed.length - 1];
 875                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 876                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 877                 fieldNames.add(fieldName);
 878                 String fieldType = filed[filed.length - 1 ].trim();
 879                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 880                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 881                 if (fieldClass == tableField){
 882                     continue;
 883                 } else {
 884                     return false;
 885                 }
 886             }
 887         }
 888         tmpFields = String.join(&quot;,&quot;, fieldNames);
 889         return true;
 890     }
 891 
 892 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.sql.Timestamp;
  34 import java.time.LocalDateTime;
  35 import java.util.Arrays;
  36 import java.util.Collection;
  37 import java.util.LinkedList;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Queue;
  41 import java.util.Set;
  42 import org.apache.calcite.sql.SqlAsOperator;
  43 import org.apache.calcite.sql.SqlBasicCall;
  44 import org.apache.calcite.sql.SqlDataTypeSpec;
  45 import org.apache.calcite.sql.SqlIdentifier;
  46 import org.apache.calcite.sql.SqlInsert;
  47 import org.apache.calcite.sql.SqlJoin;
  48 import org.apache.calcite.sql.SqlKind;
  49 import org.apache.calcite.sql.SqlLiteral;
  50 import org.apache.calcite.sql.SqlNode;
  51 import org.apache.calcite.sql.SqlNodeList;
  52 import org.apache.calcite.sql.SqlOperator;
  53 import org.apache.calcite.sql.SqlOrderBy;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.fun.SqlCase;
  57 import org.apache.calcite.sql.parser.SqlParseException;
  58 import org.apache.calcite.sql.parser.SqlParserPos;
  59 import org.apache.commons.collections.CollectionUtils;
  60 import org.apache.commons.lang3.StringUtils;
  61 import org.apache.flink.api.common.typeinfo.TypeInformation;
  62 import org.apache.flink.api.common.typeinfo.Types;
  63 import org.apache.flink.api.java.tuple.Tuple2;
  64 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  65 import org.apache.flink.api.java.typeutils.TupleTypeInfo;
  66 import org.apache.flink.streaming.api.datastream.DataStream;
  67 import org.apache.flink.table.api.Table;
  68 import org.apache.flink.table.api.TableSchema;
  69 import org.apache.flink.table.api.java.StreamTableEnvironment;
  70 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  71 import org.apache.flink.types.Row;
  72 import org.slf4j.Logger;
  73 import org.slf4j.LoggerFactory;
  74 import static org.apache.calcite.sql.SqlKind.*;
  75 
  76 
  77 /**
  78  * Reason:
  79  * Date: 2018/7/24
  80  * Company: www.dtstack.com
  81  * @author xuchao
  82  */
  83 public class SideSqlExec {
  84     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  85 
  86     private String localSqlPluginPath = null;
  87 
  88     private String tmpFields = null;
  89 
  90     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  91 
  92     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  93 
<abbr title="  94     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) throws Exception {">  94     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  95         if (localSqlPluginPath == null) {
  96             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  97         }
  98         localTableCache.putAll(tableCache);
  99         try {
 100             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 101         } catch (java.lang.Exception e) {
 102             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 103         }
 104         if (createView != null) {
 105             LOG.warn(&quot;create view info\n&quot;);
 106             LOG.warn(createView.getExecSql());
 107             LOG.warn(&quot;-----------------&quot;);
 108         }
 109         SideSQLParser sideSQLParser = new SideSQLParser();
 110         sideSQLParser.setLocalTableCache(localTableCache);
 111         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 112         Object pollObj = null;
 113         // need clean
 114         boolean preIsSideJoin = false;
 115         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 116         while ((pollObj = exeQueue.poll()) != null) {
 117             if (pollObj instanceof SqlNode) {
 118                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 119                 if (preIsSideJoin) {
 120                     preIsSideJoin = false;
 121                     List&lt;String&gt; fieldNames = null;
 122                     for (FieldReplaceInfo replaceInfo : replaceInfoList) {
 123                         fieldNames = Lists.newArrayList();
 124                         replaceFieldName(pollSqlNode, replaceInfo);
 125                         addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 126                     }
 127                 }
 128                 if (pollSqlNode.getKind() == INSERT) {
 129                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());
 130                     if (LOG.isInfoEnabled()) {
 131                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 132                     }
 133                 } else if (pollSqlNode.getKind() == AS) {
 134                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 135                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 136                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 137                     String TableAlias = sqlWithItem.name.toString();
 138                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 139                     tableEnv.registerTable(TableAlias, table);
 140                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 141                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 142                     Table table = tableEnv.sqlQuery(pollObj.toString());
 143                     if (createView.getFieldsInfoStr() == null) {
 144                         tableEnv.registerTable(createView.getTableName(), table);
 145                     } else if (checkFieldsInfo(createView, table)) {
 146                         table = table.as(tmpFields);
 147                         tableEnv.registerTable(createView.getTableName(), table);
 148                     } else {
 149                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 150                     }
 151                     localTableCache.put(createView.getTableName(), table);
 152                 }
 153             } else if (pollObj instanceof JoinInfo) {
 154                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 155                 preIsSideJoin = true;
 156                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 157             }
 158         }
 159     }
 160 
 161     /**
 162      * 解析出as查询的表和字段的关系
 163      * @param asSqlNode
 164      * @param tableCache
 165      * @return
 166      */
 167     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 168         SqlNode info = asSqlNode.getOperands()[0];
 169         SqlNode alias = asSqlNode.getOperands()[1];
 170 
 171         SqlKind infoKind = info.getKind();
 172         if(infoKind != SELECT){
 173             return null;
 174         }
 175 
 176         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 177 
 178         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 179         for (FieldInfo fieldInfo : extractFieldList) {
 180             String tableName = fieldInfo.getTable();
 181             String fieldName = fieldInfo.getFieldName();
 182             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 183             mappingTable.put(tableName, fieldName, mappingFieldName);
 184         }
 185 
 186         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 187         replaceInfo.setMappingTable(mappingTable);
 188         replaceInfo.setTargetTableName(alias.toString());
 189         replaceInfo.setTargetTableAlias(alias.toString());
 190         return replaceInfo;
 191     }
 192 
 193     /**
 194      * 添加字段别名
 195      * @param pollSqlNode
 196      * @param fieldList
 197      * @param mappingTable
 198      */
<abbr title=" 199     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 199     private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String,🔵</abbr>
 200         SqlKind sqlKind = pollSqlNode.getKind();
 201         switch (sqlKind) {
 202             case INSERT:
 203                 SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 204                 addAliasForFieldNode(source, fieldList, mappingTable);
 205                 break;
 206             case AS:
<abbr title=" 207                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);"> 207                 addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTab🔵</abbr>
 208                 break;
 209             case SELECT:
 210                 SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 211                 selectList.getList().forEach(node -&gt; {
 212                     if (node.getKind() == IDENTIFIER) {
 213                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 214                         if (sqlIdentifier.names.size() == 1) {
 215                             return;
 216                         }
 217                         // save real field
 218                         String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 219                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 219                         if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap🔵</abbr>
 220                             fieldList.add(fieldName);
 221                         }
 222 
 223                     }
 224                 });
 225                 for (int i = 0; i &lt; selectList.getList().size(); i++) {
 226                     SqlNode node = selectList.get(i);
 227                     if (node.getKind() == IDENTIFIER) {
 228                         SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 229                         if (sqlIdentifier.names.size() == 1) {
 230                             return;
 231                         }
 232                         String name = sqlIdentifier.names.get(1);
 233                         // avoid real field pv0 convert pv
<abbr title=" 234                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 234                         if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.🔵</abbr>
 235                             SqlOperator operator = new SqlAsOperator();
 236                             SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 237 
<abbr title=" 238                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 238                             SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.l🔵</abbr>
 239                             SqlNode[] sqlNodes = new SqlNode[2];
 240                             sqlNodes[0] = sqlIdentifier;
 241                             sqlNodes[1] = sqlIdentifierAlias;
<abbr title=" 242                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);"> 242                             SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos🔵</abbr>
 243 
 244                             selectList.set(i, sqlBasicCall);
 245                         }
 246                     }
 247                 }
 248                 break;
 249             default:
 250                 break;
 251         }
 252     }
 253 
 254     public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 255         SqlKind sqlKind = sqlNode.getKind();
 256         if(sqlKind != AS){
 257             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 258         }
 259 
 260         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 261         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 262 
 263         AliasInfo aliasInfo = new AliasInfo();
 264         aliasInfo.setName(info.toString());
 265         aliasInfo.setAlias(alias.toString());
 266 
 267         return aliasInfo;
 268     }
 269 
<abbr title=" 270     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 270     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 271         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 272         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 273         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 274             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 275             String tableName = fieldInfo.getTable();
 276             String fieldName = fieldInfo.getFieldName();
 277             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 278             mappingTable.put(tableName, fieldName, mappingFieldName);
 279 
 280             sideOutTypes[i] = fieldInfo.getTypeInformation();
 281             sideOutNames[i] = mappingFieldName;
 282         }
 283         return new RowTypeInfo(sideOutTypes, sideOutNames);
 284     }
 285 
 286     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 287         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 288             return TypeInformation.of(LocalDateTime.class);
 289         }
 290         return typeInformation;
 291     }
 292 
 293     //需要考虑更多的情况
 294     private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 295         SqlKind sqlKind = sqlNode.getKind();
 296         switch (sqlKind) {
 297             case INSERT :
 298                 SqlNode sqlSource = ((SqlInsert) (sqlNode)).getSource();
 299                 replaceFieldName(sqlSource, replaceInfo);
 300                 break;
 301             case AS :
 302                 SqlNode asNode = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 303                 replaceFieldName(asNode, replaceInfo);
 304                 break;
 305             case SELECT :
<abbr title=" 306                 SqlSelect sqlSelect = ((SqlSelect) (filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName())));"> 306                 SqlSelect sqlSelect = ((SqlSelect) (filterNodeWithTargetName(sqlNode, replaceInfo.getTarg🔵</abbr>
 307                 if (sqlSelect == null) {
 308                     return;
 309                 }
 310                 SqlNode sqlSource1 = sqlSelect.getFrom();
 311                 if (sqlSource1.getKind() == AS) {
 312                     String tableName = ((SqlBasicCall) (sqlSource1)).getOperands()[0].toString();
 313                     if (tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())) {
 314                         SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 315                         SqlNode whereNode = sqlSelect.getWhere();
 316                         SqlNodeList sqlGroup = sqlSelect.getGroup();
 317                         // TODO 暂时不处理having
 318                         SqlNode sqlHaving = sqlSelect.getHaving();
 319                         List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 320                         for (int i = 0; i &lt; sqlSelectList.getList().size(); i++) {
 321                             SqlNode selectNode = sqlSelectList.getList().get(i);
 322                             // 特殊处理 isStar的标识
<abbr title=" 323                             if ((selectNode.getKind() == IDENTIFIER) &amp;&amp; ((SqlIdentifier) (selectNode)).isStar()) {"> 323                             if ((selectNode.getKind() == IDENTIFIER) &amp;&amp; ((SqlIdentifier) (selectNode)).is🔵</abbr>
<abbr title=" 324                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 324                                 List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, re🔵</abbr>
 325                                 newSelectNodeList.addAll(replaceNodeList);
 326                                 continue;
 327                             }
 328                             SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 329                             if (replaceNode == null) {
 330                                 continue;
 331                             }
 332                             // sqlSelectList.set(i, replaceNode);
 333                             newSelectNodeList.add(replaceNode);
 334                         }
<abbr title=" 335                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 335                         SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getP🔵</abbr>
 336                         sqlSelect.setSelectList(newSelectList);
 337                         // where
 338                         if (whereNode != null) {
 339                             SqlNode[] sqlNodeList = ((SqlBasicCall) (whereNode)).getOperands();
 340                             for (int i = 0; i &lt; sqlNodeList.length; i++) {
 341                                 SqlNode whereSqlNode = sqlNodeList[i];
 342                                 SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 343                                 sqlNodeList[i] = replaceNode;
 344                             }
 345                         }
 346                         if ((sqlGroup != null) &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())) {
 347                             for (int i = 0; i &lt; sqlGroup.getList().size(); i++) {
 348                                 SqlNode selectNode = sqlGroup.getList().get(i);
 349                                 SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 350                                 sqlGroup.set(i, replaceNode);
 351                             }
 352                         }
 353                     }
 354                 } else {
 355                     throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 356                 }
 357                 break;
 358             case UNION :
 359                 SqlNode unionLeft = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 360                 SqlNode unionRight = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 361                 replaceFieldName(unionLeft, replaceInfo);
 362                 replaceFieldName(unionRight, replaceInfo);
 363                 break;
 364             case ORDER_BY :
 365                 SqlOrderBy sqlOrderBy = ((SqlOrderBy) (sqlNode));
 366                 replaceFieldName(sqlOrderBy.query, replaceInfo);
 367                 SqlNodeList orderFiledList = sqlOrderBy.orderList;
 368                 for (int i = 0; i &lt; orderFiledList.size(); i++) {
<abbr title=" 369                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 369                     SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getT🔵</abbr>
 370                     orderFiledList.set(i, replaceNode);
 371                 }
 372             default :
 373                 break;
 374         }
 375     }
 376 
 377     private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 378         if(orderNode.getKind() == IDENTIFIER){
 379             SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 380             if (sqlIdentifier.names.size() == 1) {
 381                 return orderNode;
 382             }
 383             return sqlIdentifier.setName(0, tableAlias);
 384         } else if (orderNode instanceof  SqlBasicCall) {
 385             SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 386             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 387                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 388                 sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 389             }
 390             return sqlBasicCall;
 391         } else {
 392             return orderNode;
 393         }
 394     }
 395 
 396     private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 397         if(groupNode.getKind() == IDENTIFIER){
 398             SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 399             if(sqlIdentifier.names.size() == 1){
 400                 return sqlIdentifier;
 401             }
 402 
<abbr title=" 403             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 403             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 404             if(mappingFieldName == null){
 405                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 406             }
 407 
 408             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 409             return sqlIdentifier.setName(1, mappingFieldName);
 410         }else if(groupNode instanceof  SqlBasicCall){
 411             SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 412             for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 413                 SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 414                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 415                 sqlBasicCall.getOperands()[i] = replaceNode;
 416             }
 417 
 418             return sqlBasicCall;
 419         }else{
 420             return groupNode;
 421         }
 422     }
 423 
 424     public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 425 
 426         SqlKind sqlKind = sqlNode.getKind();
 427         switch (sqlKind){
 428             case SELECT:
 429                 SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
<abbr title=" 430                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){"> 430                 if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDE🔵</abbr>
<abbr title=" 431                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){"> 431                     if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableN🔵</abbr>
 432                         return sqlNode;
 433                     }else{
 434                         return null;
 435                     }
 436                 }else{
 437                     return filterNodeWithTargetName(fromNode, targetTableName);
 438                 }
 439             case AS:
 440                 SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 441                 return filterNodeWithTargetName(childNode, targetTableName);
 442             case JOIN:
 443                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 444                 SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 445                 SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 446                 SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 447 
 448                 if(leftReturnNode != null) {
 449                     return leftReturnNode;
 450                 }else if(rightReturnNode != null){
 451                     return rightReturnNode;
 452                 }else{
 453                     return null;
 454                 }
 455             default:
 456                 break;
 457         }
 458 
 459         return null;
 460     }
 461 
 462     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 463         this.localSqlPluginPath = localSqlPluginPath;
 464     }
 465 
<abbr title=" 466     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 466     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 467         Table table = localTableCache.get(tableAlias);
 468         if(table == null){
 469             table = localTableCache.get(tableName);
 470         }
 471 
 472         if(table == null){
 473             throw new RuntimeException(&quot;not register table &quot; + tableName);
 474         }
 475 
 476         return table;
 477     }
 478 
 479     private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 480         SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 481         List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 482         if(sqlIdentifier.isStar()){//处理 [* or table.*]
 483             int identifierSize = sqlIdentifier.names.size();
 484             Collection&lt;String&gt; columns = null;
 485             if(identifierSize == 1){
 486                 columns = replaceInfo.getMappingTable().values();
 487             }else{
 488                 columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 489             }
 490 
 491             for(String colAlias : columns){
 492                 SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 493                 List&lt;String&gt; columnInfo = Lists.newArrayList();
 494                 columnInfo.add(replaceInfo.getTargetTableAlias());
 495                 columnInfo.add(colAlias);
 496                 SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 497                 sqlNodes.add(sqlIdentifierAlias);
 498             }
 499 
 500             return sqlNodes;
 501         }else{
 502             throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 503         }
 504     }
 505 
 506     private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 507         if (selectNode.getKind() == AS) {
 508             SqlNode leftNode = ((SqlBasicCall) (selectNode)).getOperands()[0];
 509             SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 510             if (replaceNode != null) {
 511                 ((SqlBasicCall) (selectNode)).getOperands()[0] = replaceNode;
 512             }
 513             return selectNode;
 514         } else if (selectNode.getKind() == IDENTIFIER) {
 515             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (selectNode));
 516             if (sqlIdentifier.names.size() == 1) {
 517                 return selectNode;
 518             }
 519             // Same level mappingTable
<abbr title=" 520             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 520             String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSim🔵</abbr>
 521             if (mappingFieldName == null) {
 522                 throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString());
 523             }
 524             sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 525             sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 526             return sqlIdentifier;
 527         } else if ((selectNode.getKind() == LITERAL) || (selectNode.getKind() == LITERAL_CHAIN)) {
 528             // 字面含义
 529             return selectNode;
<abbr title=" 530         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())) || COMPARISON.contains(selectNode.getKind())) || (selectNode.getKind() == OTHER_FUNCTION)) || (selectNode.getKind() == DIVIDE)) || (selectNode.getKind() == CAST)) || (selectNode.getKind() == TRIM)) || (selectNode.getKind() == TIMES)) || (selectNode.getKind() == PLUS)) || (selectNode.getKind() == NOT_IN)) || (selectNode.getKind() == OR)) || (selectNode.getKind() == AND)) || (selectNode.getKind() == MINUS)) || (selectNode.getKind() == TUMBLE)) || (selectNode.getKind() == TUMBLE_START)) || (selectNode.getKind() == TUMBLE_END)) || (selectNode.getKind() == SESSION)) || (selectNode.getKind() == SESSION_START)) || (selectNode.getKind() == SESSION_END)) || (selectNode.getKind() == HOP)) || (selectNode.getKind() == HOP_START)) || (selectNode.getKind() == HOP_END)) || (selectNode.getKind() == BETWEEN)) || (selectNode.getKind() == IS_NULL)) || (selectNode.getKind() == IS_NOT_NULL)) || (selectNode.getKind() == CONTAINS)) || (selectNode.getKind() == TIMESTAMP_ADD)) || (selectNode.getKind() == TIMESTAMP_DIFF)) || (selectNode.getKind() == LIKE)) {"> 530         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIO🔵</abbr>
 531             SqlBasicCall sqlBasicCall = ((SqlBasicCall) (selectNode));
 532             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 533                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 534                 if (sqlNode instanceof SqlLiteral) {
 535                     continue;
 536                 }
 537                 if (sqlNode instanceof SqlDataTypeSpec) {
 538                     continue;
 539                 }
 540                 SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 541                 if (replaceNode == null) {
 542                     continue;
 543                 }
 544                 sqlBasicCall.getOperands()[i] = replaceNode;
 545             }
 546             return selectNode;
 547         } else if (selectNode.getKind() == CASE) {
 548             SqlCase sqlCase = ((SqlCase) (selectNode));
 549             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 550             SqlNodeList thenOperands = sqlCase.getThenOperands();
 551             SqlNode elseNode = sqlCase.getElseOperand();
 552             for (int i = 0; i &lt; whenOperands.size(); i++) {
 553                 SqlNode oneOperand = whenOperands.get(i);
 554                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 555                 if (replaceNode != null) {
 556                     whenOperands.set(i, replaceNode);
 557                 }
 558             }
 559             for (int i = 0; i &lt; thenOperands.size(); i++) {
 560                 SqlNode oneOperand = thenOperands.get(i);
 561                 SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 562                 if (replaceNode != null) {
 563                     thenOperands.set(i, replaceNode);
 564                 }
 565             }
 566             ((SqlCase) (selectNode)).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 567             return selectNode;
 568         } else if (selectNode.getKind() == OTHER) {
 569             // 不处理
 570             return selectNode;
 571         } else {
<abbr title=" 572             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 572             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, 🔵</abbr>
 573         }
 574     }
 575 
 576     /**
<abbr title=" 577      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 577      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 578      *
 579      * @return
 580      */
<abbr title=" 581     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 581     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 582         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 583         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 584             return true;
 585         }
 586         return false;
 587     }
 588 
 589     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 590         List&lt;String&gt; res = Lists.newArrayList();
 591         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 592             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 593         });
 594         return res;
 595     }
 596 
<abbr title=" 597     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 597     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 598         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 599         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 600         List&lt;String&gt; conditionFields = Lists.newArrayList();
 601         for(SqlNode sqlNode : sqlNodeList){
 602             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 603                 throw new RuntimeException(&quot;not compare operator.&quot;);
 604             }
 605 
 606             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 607             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 608 
 609             String leftTableName = left.getComponent(0).getSimple();
 610             String rightTableName = right.getComponent(0).getSimple();
 611 
 612             String tableCol = &quot;&quot;;
 613             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 614                 tableCol = left.getComponent(1).getSimple();
 615             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 616                 tableCol = right.getComponent(1).getSimple();
 617             }else{
<abbr title=" 618                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 618                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 619             }
 620             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 621             conditionFields.add(tableCol);
 622         }
 623 
 624         return conditionFields;
 625     }
 626 
 627     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 628                                      SqlNode pollSqlNode,
 629                                      Map&lt;String, Table&gt; tableCache,
 630                                      List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 631 
 632         AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 633         if (localTableCache.containsKey(aliasInfo.getName())) {
 634             return;
 635         }
 636 
 637         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 638         tableEnv.registerTable(aliasInfo.getAlias(), table);
 639         localTableCache.put(aliasInfo.getAlias(), table);
 640 
 641         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 642 
 643         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 644         if(fieldReplaceInfo == null){
 645            return;
 646         }
 647 
 648         //as 的源表
 649         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 650         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 651         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 652         for(FieldReplaceInfo tmp : replaceInfoList){
 653             if(fromTableNameSet.contains(tmp.getTargetTableName())
 654                     || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 655                 fieldReplaceInfo.setPreNode(tmp);
 656                 break;
 657             }
 658         }
 659         replaceInfoList.add(fieldReplaceInfo);
 660     }
 661 
<abbr title=" 662     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception {"> 662     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 663         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 664         JoinScope joinScope = new JoinScope();
 665         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 666         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 667         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 668         SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 669         if (sqlKind == AS) {
 670             dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 671         }
<abbr title=" 672         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 672         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 673         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 673         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSc🔵</abbr>
 674         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 675         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 676         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 677         rightScopeChild.setTableName(joinInfo.getRightTableName());
 678         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 679         if (sideTableInfo == null) {
 680             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 681         }
 682         if (sideTableInfo == null) {
 683             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 684         }
 685 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 686 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 687 //        }
 688         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 689         joinScope.addScope(leftScopeChild);
 690         joinScope.addScope(rightScopeChild);
 691         // 获取两个表的所有字段
<abbr title=" 692         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 692         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 693         String leftTableAlias = joinInfo.getLeftTableAlias();
 694         Table targetTable = localTableCache.get(leftTableAlias);
 695         if (targetTable == null) {
 696             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 697         }
<abbr title=" 698         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 698         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSc🔵</abbr>
 699         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);
 700         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 701         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 702             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 702             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 703             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 704             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 705             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 705             adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, ta🔵</abbr>
 706         }
 707         DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;
 708         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 709             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 709             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 710         } else {
<abbr title=" 711             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 711             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 712         }
 713         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 714         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 715         TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);
 716         dsOut.getTransformation().setOutputType(tupleTypeInfo);
 717         String targetTableName = joinInfo.getNewTableName();
 718         String targetTableAlias = joinInfo.getNewTableAlias();
 719         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 720         replaceInfo.setMappingTable(mappingTable);
 721         replaceInfo.setTargetTableName(targetTableName);
 722         replaceInfo.setTargetTableAlias(targetTableAlias);
 723         // 判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 724         for (FieldReplaceInfo tmp : replaceInfoList) {
<abbr title=" 725             if (tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName()) || tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())) {"> 725             if (tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName()) || tmp.getTargetTa🔵</abbr>
 726                 replaceInfo.setPreNode(tmp);
 727                 break;
 728             }
 729         }
 730         replaceInfoList.add(replaceInfo);
 731         List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());
 732         if (!registeredTableName.contains(joinInfo.getNewTableName())) {
 733             Table joinTable = tableEnv.fromDataStream(dsOut);
 734             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 735             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 736         }
 737     }
 738 
 739     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 740         String[] fieldNames = schema.getFieldNames();
 741         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
<abbr title=" 742         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]::new);"> 742         String[] projectedNames = Arrays.stream(fields).mapToObj(( i) -&gt; fieldNames[i]).toArray(String[]:🔵</abbr>
<abbr title=" 743         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 743         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(( i) -&gt; fieldTypes[i]).toArray(🔵</abbr>
 744         return new RowTypeInfo(projectedTypes, projectedNames);
 745     }
 746 
 747     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 748         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 749         String fieldsInfo = result.getFieldsInfoStr();
 750         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 751         for (int i = 0; i &lt; fields.length; i++) {
 752             String[] filed = fields[i].split(&quot;\\s&quot;);
 753             if ((filed.length &lt; 2) || (fields.length != table.getSchema().getFieldCount())) {
 754                 return false;
 755             } else {
 756                 String[] filedNameArr = new String[filed.length - 1];
 757                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 758                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 759                 fieldNames.add(fieldName);
 760                 String fieldType = filed[filed.length - 1].trim();
 761                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 762                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 763                 if (fieldClass == tableField) {
 764                     continue;
 765                 } else {
 766                     return false;
 767                 }
 768             }
 769         }
 770         tmpFields = String.join(&quot;,&quot;, fieldNames);
 771         return true;
 772     }
 773 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import org.apache.flink.api.common.typeinfo.Types;</span>
  25  import org.apache.flink.api.java.tuple.Tuple2;
  26  import org.apache.flink.api.java.typeutils.RowTypeInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.api.java.typeutils.TupleTypeInfo;</span>
  28  import org.apache.flink.streaming.api.datastream.DataStream;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import org.apache.flink.table.api.StreamQueryConfig;</span>
  30  import org.apache.flink.table.api.Table;
  31  import org.apache.flink.table.api.TableSchema;
  32  import org.apache.flink.table.api.java.StreamTableEnvironment;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.flink.table.runtime.CRowKeySelector;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import org.apache.flink.table.runtime.types.CRowTypeInfo;</span>
  36  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  37  import org.apache.flink.types.Row;
  38  
  39  import com.dtstack.flink.sql.enums.ECacheType;
  40  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  41  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  42  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  43  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  44  import com.dtstack.flink.sql.util.ClassUtil;
  45  import com.dtstack.flink.sql.util.ParseUtils;
  46  import com.dtstack.flink.sql.util.TableUtils;
  47  import com.google.common.base.Preconditions;
  48  import com.google.common.collect.HashBasedTable;
  49  import com.google.common.collect.Lists;
  50  import com.google.common.collect.Maps;
  51  import com.google.common.collect.Sets;
  52  import org.apache.calcite.sql.SqlAsOperator;
  53  import org.apache.calcite.sql.SqlBasicCall;
  54  import org.apache.calcite.sql.SqlDataTypeSpec;
  55  import org.apache.calcite.sql.SqlIdentifier;
  56  import org.apache.calcite.sql.SqlInsert;
  57  import org.apache.calcite.sql.SqlJoin;
  58  import org.apache.calcite.sql.SqlKind;
  59  import org.apache.calcite.sql.SqlLiteral;
  60  import org.apache.calcite.sql.SqlNode;
  61  import org.apache.calcite.sql.SqlNodeList;
  62  import org.apache.calcite.sql.SqlOperator;
  63  import org.apache.calcite.sql.SqlOrderBy;
  64  import org.apache.calcite.sql.SqlSelect;
  65  import org.apache.calcite.sql.SqlWithItem;
  66  import org.apache.calcite.sql.fun.SqlCase;
  67  import org.apache.calcite.sql.parser.SqlParseException;
  68  import org.apache.calcite.sql.parser.SqlParserPos;
  69  import org.apache.commons.collections.CollectionUtils;
  70  import org.apache.commons.lang3.StringUtils;
  71  import org.slf4j.Logger;
  72  import org.slf4j.LoggerFactory;
  73  
  74  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +import java.time.LocalDateTime;</span>
  76  import java.util.Arrays;
  77  import java.util.Collection;
  78  import java.util.LinkedList;
  79  import java.util.List;
  80  import java.util.Map;
  81  import java.util.Queue;
  82  import java.util.Set;
  83  
  84  import static org.apache.calcite.sql.SqlKind.*;
  85  
  86  /**
  87   * Reason:
  88   * Date: 2018/7/24
  89   * Company: www.dtstack.com
  90   * @author xuchao
  91   */
  92  
  93  public class SideSqlExec {
  94  
  95      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  96  
  97      private String localSqlPluginPath = null;
  98  
  99      private String tmpFields = null;
 100  
 101      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 102  
 103      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 104  
 105      public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 106 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 106 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 107 +                     Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 107 +                     Map&lt;String, Table&gt; tableCache, CreateTmpTableParser.SqlParserResult createView) throws Except🔵</abbr></span>
 108          if(localSqlPluginPath == null){
 109              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 110          }
 111  
 112          localTableCache.putAll(tableCache);
 113          try {
 114              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 115          } catch (Exception e) {
 116              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 117          }
 118  
 119          if(createView != null){
 120              LOG.warn(&quot;create view info\n&quot;);
 121              LOG.warn(createView.getExecSql());
 122              LOG.warn(&quot;-----------------&quot;);
 123          }
 124  
 125          SideSQLParser sideSQLParser = new SideSQLParser();
 126          sideSQLParser.setLocalTableCache(localTableCache);
 127          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 128          Object pollObj = null;
 129  
 130          //need clean
 131          boolean preIsSideJoin = false;
 132          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 133  
 134          while((pollObj = exeQueue.poll()) != null){
 135  
 136              if(pollObj instanceof SqlNode){
 137                  SqlNode pollSqlNode = (SqlNode) pollObj;
 138  
 139                  if(preIsSideJoin){
 140                      preIsSideJoin = false;
 141                      List&lt;String&gt; fieldNames = null;
 142                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 143                          fieldNames = Lists.newArrayList();
 144                          replaceFieldName(pollSqlNode, replaceInfo);
 145                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 146                      }
 147                  }
 148  
 149                  if(pollSqlNode.getKind() == INSERT){
 150                      System.out.println(&quot;----------real exec sql-----------&quot; );
 151                      System.out.println(pollSqlNode.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +                    FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString());</span>
 154                      if(LOG.isInfoEnabled()){
 155                          LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());

 156                      }
 157  
 158                  }else if(pollSqlNode.getKind() == AS){
 159                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 160  
 161                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 162                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 163                      String TableAlias = sqlWithItem.name.toString();
 164                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 165                      tableEnv.registerTable(TableAlias, table);
 166  
 167                  } else if (pollSqlNode.getKind() == SELECT){
 168                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 169                      Table table = tableEnv.sqlQuery(pollObj.toString());
 170  
 171                      if (createView.getFieldsInfoStr() == null){
 172                          tableEnv.registerTable(createView.getTableName(), table);
 173                      } else {
 174                          if (checkFieldsInfo(createView, table)){
 175                              table = table.as(tmpFields);
 176                              tableEnv.registerTable(createView.getTableName(), table);
 177                          } else {
 178                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 179                          }
 180                      }
 181  
 182                      localTableCache.put(createView.getTableName(), table);
 183                  }
 184  
 185              }else if (pollObj instanceof JoinInfo){
 186                  System.out.println(&quot;----------exec join info----------&quot;);
 187                  System.out.println(pollObj.toString());

 188                  preIsSideJoin = true;
 189                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 190              }
 191          }
 192  
 193      }
 194  
 195  
 196      /**
 197       * 解析出as查询的表和字段的关系
 198       * @param asSqlNode
 199       * @param tableCache
 200       * @return
 201       */
 202      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 203          SqlNode info = asSqlNode.getOperands()[0];
 204          SqlNode alias = asSqlNode.getOperands()[1];
 205  
 206          SqlKind infoKind = info.getKind();
 207          if(infoKind != SELECT){
 208              return null;
 209          }
 210  
 211          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 212  
 213          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 214          for (FieldInfo fieldInfo : extractFieldList) {
 215              String tableName = fieldInfo.getTable();
 216              String fieldName = fieldInfo.getFieldName();
 217              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 218              mappingTable.put(tableName, fieldName, mappingFieldName);
 219          }
 220  
 221          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 222          replaceInfo.setMappingTable(mappingTable);
 223          replaceInfo.setTargetTableName(alias.toString());
 224          replaceInfo.setTargetTableAlias(alias.toString());
 225          return replaceInfo;
 226      }
 227  
 228  
 229      /**
 230       * 添加字段别名
 231       * @param pollSqlNode
 232       * @param fieldList
 233       * @param mappingTable
 234       */
<abbr title=" 235      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 235      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 236          SqlKind sqlKind = pollSqlNode.getKind();
 237          switch (sqlKind) {
 238              case INSERT:
 239                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 240                  addAliasForFieldNode(source, fieldList, mappingTable);
 241                  break;
 242              case AS:
 243                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 244                  break;
 245              case SELECT:
 246                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 247                  selectList.getList().forEach(node -&gt; {
 248                      if (node.getKind() == IDENTIFIER) {
 249                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 250                          if (sqlIdentifier.names.size() == 1) {
 251                              return;
 252                          }
 253                          // save real field
 254                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 255                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 255                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 256                              fieldList.add(fieldName);
 257                          }
 258  
 259                      }
 260                  });
 261                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 262                      SqlNode node = selectList.get(i);
 263                      if (node.getKind() == IDENTIFIER) {
 264                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 265                          if (sqlIdentifier.names.size() == 1) {
 266                              return;
 267                          }
 268                          String name = sqlIdentifier.names.get(1);
 269                          // avoid real field pv0 convert pv
<abbr title=" 270                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 270                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 271                              SqlOperator operator = new SqlAsOperator();
 272                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 273  
<abbr title=" 274                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 274                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 275                              SqlNode[] sqlNodes = new SqlNode[2];
 276                              sqlNodes[0] = sqlIdentifier;
 277                              sqlNodes[1] = sqlIdentifierAlias;
 278                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 279  
 280                              selectList.set(i, sqlBasicCall);
 281                          }
 282                      }
 283                  }
 284                  break;
 285              default:
 286                  break;
 287          }
 288      }
 289  
 290  
 291      public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 292          SqlKind sqlKind = sqlNode.getKind();
 293          if(sqlKind != AS){
 294              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 295          }
 296  
 297          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 298          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 299  
 300          AliasInfo aliasInfo = new AliasInfo();
 301          aliasInfo.setName(info.toString());
 302          aliasInfo.setAlias(alias.toString());
 303  
 304          return aliasInfo;
 305      }
 306  
<abbr title=" 307      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 307      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>
 308          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 309          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 310          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 311              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 312              String tableName = fieldInfo.getTable();
 313              String fieldName = fieldInfo.getFieldName();
 314              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 315              mappingTable.put(tableName, fieldName, mappingFieldName);
 316  
 317              sideOutTypes[i] = fieldInfo.getTypeInformation();
 318              sideOutNames[i] = mappingFieldName;
 319          }
 320          return new RowTypeInfo(sideOutTypes, sideOutNames);
 321      }
 322  
 323  
 324  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 325 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 326 -     *  对时间类型进行类型转换</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 327 -     * @param leftTypeInfo</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 328 -     * @return</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 329 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 330 -    private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 331 -        TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 332 -        TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 333 -        for (int i = 0; i &lt; sideOutTypes.length; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 334 -            sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 335 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 336 -        RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 337 -        return rowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 338 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 339 -</span>
 340      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 341          if (typeInformation instanceof TimeIndicatorTypeInfo) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 342 -            return TypeInformation.of(Timestamp.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +            return TypeInformation.of(LocalDateTime.class);</span>
 344          }
 345          return typeInformation;
 346      }
 347  
 348      //需要考虑更多的情况
 349      private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 350          SqlKind sqlKind = sqlNode.getKind();
 351          switch (sqlKind) {
 352              case INSERT:
 353                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 354                  replaceFieldName(sqlSource, replaceInfo);
 355                  break;
 356              case AS:
 357                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 358                  replaceFieldName(asNode, replaceInfo);
 359                  break;
 360              case SELECT:
<abbr title=" 361                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 361                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr>
 362                  if(sqlSelect == null){
 363                      return;
 364                  }
 365  
 366                  SqlNode sqlSource1 = sqlSelect.getFrom();
 367                  if(sqlSource1.getKind() == AS){
 368                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 369                      if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 370                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 371                          SqlNode whereNode = sqlSelect.getWhere();
 372                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 373  
 374                          //TODO 暂时不处理having
 375                          SqlNode sqlHaving = sqlSelect.getHaving();
 376  
 377                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 378                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 379                              SqlNode selectNode = sqlSelectList.getList().get(i);
 380                              //特殊处理 isStar的标识
 381                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 382                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 382                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr>
 383                                  newSelectNodeList.addAll(replaceNodeList);
 384                                  continue;
 385                              }
 386  
 387                              SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 388                              if(replaceNode == null){
 389                                  continue;
 390                              }
 391  
 392                              //sqlSelectList.set(i, replaceNode);
 393                              newSelectNodeList.add(replaceNode);
 394                          }
 395  
<abbr title=" 396                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 396                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 397                          sqlSelect.setSelectList(newSelectList);
 398  
 399                          //where
 400                          if(whereNode != null){
 401                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 402                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 403                                  SqlNode whereSqlNode = sqlNodeList[i];
 404                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 405                                  sqlNodeList[i] = replaceNode;
 406                              }
 407                          }
 408                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 409                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 410                                  SqlNode selectNode = sqlGroup.getList().get(i);
 411                                  SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 412                                  sqlGroup.set(i, replaceNode);
 413                              }
 414                          }
 415                      }
 416                  }else{
 417                      //TODO
 418                      System.out.println(sqlNode);
 419                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 420                  }
 421  
 422                  break;
 423              case UNION:
 424                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 425                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 426                  replaceFieldName(unionLeft, replaceInfo);
 427                  replaceFieldName(unionRight, replaceInfo);
 428  
 429                  break;
 430              case ORDER_BY:
 431                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 432                  replaceFieldName(sqlOrderBy.query, replaceInfo);
 433                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 434                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 435                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 435                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr>
 436                      orderFiledList.set(i, replaceNode);
 437                  }
 438  
 439              default:
 440                  break;
 441          }
 442      }
 443  
 444      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 445          if(orderNode.getKind() == IDENTIFIER){
 446              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 447              if (sqlIdentifier.names.size() == 1) {
 448                  return orderNode;
 449              }
 450              return sqlIdentifier.setName(0, tableAlias);
 451          } else if (orderNode instanceof  SqlBasicCall) {
 452              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 453              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 454                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 455                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 456              }
 457              return sqlBasicCall;
 458          } else {
 459              return orderNode;
 460          }
 461      }
 462  
 463      private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 464          if(groupNode.getKind() == IDENTIFIER){
 465              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 466              if(sqlIdentifier.names.size() == 1){
 467                  return sqlIdentifier;
 468              }
 469  
<abbr title=" 470              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 470              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 471              if(mappingFieldName == null){
 472                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 473              }
 474  
 475              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 476              return sqlIdentifier.setName(1, mappingFieldName);
 477          }else if(groupNode instanceof  SqlBasicCall){
 478              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 479              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 480                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 481                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 482                  sqlBasicCall.getOperands()[i] = replaceNode;
 483              }
 484  
 485              return sqlBasicCall;
 486          }else{
 487              return groupNode;
 488          }
 489      }
 490  
 491      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 492  
 493          SqlKind sqlKind = sqlNode.getKind();
 494          switch (sqlKind){
 495              case SELECT:
 496                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 497                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 498                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 499                          return sqlNode;
 500                      }else{
 501                          return null;
 502                      }
 503                  }else{
 504                      return filterNodeWithTargetName(fromNode, targetTableName);
 505                  }
 506              case AS:
 507                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 508                  return filterNodeWithTargetName(childNode, targetTableName);
 509              case JOIN:
 510                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 511                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 512                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 513                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 514  
 515                  if(leftReturnNode != null) {
 516                      return leftReturnNode;
 517                  }else if(rightReturnNode != null){
 518                      return rightReturnNode;
 519                  }else{
 520                      return null;
 521                  }
 522              default:
 523                  break;
 524          }
 525  
 526          return null;
 527      }
 528  
 529  
 530      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 531          this.localSqlPluginPath = localSqlPluginPath;
 532      }
 533  
 534      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 535          Table table = localTableCache.get(tableAlias);
 536          if(table == null){
 537              table = localTableCache.get(tableName);
 538          }
 539  
 540          if(table == null){
 541              throw new RuntimeException(&quot;not register table &quot; + tableName);
 542          }
 543  
 544          return table;
 545      }
 546  
 547      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 548          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 549          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 550          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 551              int identifierSize = sqlIdentifier.names.size();
 552              Collection&lt;String&gt; columns = null;
 553              if(identifierSize == 1){
 554                  columns = replaceInfo.getMappingTable().values();
 555              }else{
 556                  columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 557              }
 558  
 559              for(String colAlias : columns){
 560                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 561                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 562                  columnInfo.add(replaceInfo.getTargetTableAlias());
 563                  columnInfo.add(colAlias);
 564                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 565                  sqlNodes.add(sqlIdentifierAlias);
 566              }
 567  
 568              return sqlNodes;
 569          }else{
 570              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 571          }
 572      }
 573  
 574      private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 575          if (selectNode.getKind() == AS) {
 576              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 577              SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 578              if (replaceNode != null) {
 579                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 580              }
 581  
 582              return selectNode;
 583          }else if(selectNode.getKind() == IDENTIFIER){
 584              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 585  
 586              if(sqlIdentifier.names.size() == 1){
 587                  return selectNode;
 588              }
 589  
 590              //Same level mappingTable
<abbr title=" 591              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 591              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 592              if (mappingFieldName == null) {
 593                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 594              }
 595  
 596              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 597              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 598              return sqlIdentifier;
 599          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 600              return selectNode;
 601          }else if(  AGGREGATE.contains(selectNode.getKind())
 602                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 603                  || COMPARISON.contains(selectNode.getKind())
 604                  || selectNode.getKind() == OTHER_FUNCTION
 605                  || selectNode.getKind() == DIVIDE
 606                  || selectNode.getKind() == CAST
 607                  || selectNode.getKind() == TRIM
 608                  || selectNode.getKind() == TIMES
 609                  || selectNode.getKind() == PLUS
 610                  || selectNode.getKind() == NOT_IN
 611                  || selectNode.getKind() == OR
 612                  || selectNode.getKind() == AND
 613                  || selectNode.getKind() == MINUS
 614                  || selectNode.getKind() == TUMBLE
 615                  || selectNode.getKind() == TUMBLE_START
 616                  || selectNode.getKind() == TUMBLE_END
 617                  || selectNode.getKind() == SESSION
 618                  || selectNode.getKind() == SESSION_START
 619                  || selectNode.getKind() == SESSION_END
 620                  || selectNode.getKind() == HOP
 621                  || selectNode.getKind() == HOP_START
 622                  || selectNode.getKind() == HOP_END
 623                  || selectNode.getKind() == BETWEEN
 624                  || selectNode.getKind() == IS_NULL
 625                  || selectNode.getKind() == IS_NOT_NULL
 626                  || selectNode.getKind() == CONTAINS
 627                  || selectNode.getKind() == TIMESTAMP_ADD
 628                  || selectNode.getKind() == TIMESTAMP_DIFF
 629                  || selectNode.getKind() == LIKE
 630  
 631                  ){
 632              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 633              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 634                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 635                  if(sqlNode instanceof SqlLiteral){
 636                      continue;
 637                  }
 638  
 639                  if(sqlNode instanceof SqlDataTypeSpec){
 640                      continue;
 641                  }
 642  
 643                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 644                  if(replaceNode == null){
 645                      continue;
 646                  }
 647  
 648                  sqlBasicCall.getOperands()[i] = replaceNode;
 649              }
 650  
 651              return selectNode;
 652          }else if(selectNode.getKind() == CASE){
 653              System.out.println(&quot;selectNode&quot;);
 654              SqlCase sqlCase = (SqlCase) selectNode;
 655              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 656              SqlNodeList thenOperands = sqlCase.getThenOperands();
 657              SqlNode elseNode = sqlCase.getElseOperand();
 658  
 659              for(int i=0; i&lt;whenOperands.size(); i++){
 660                  SqlNode oneOperand = whenOperands.get(i);
 661                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 662                  if (replaceNode != null) {
 663                      whenOperands.set(i, replaceNode);
 664                  }
 665              }
 666  
 667              for(int i=0; i&lt;thenOperands.size(); i++){
 668                  SqlNode oneOperand = thenOperands.get(i);
 669                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 670                  if (replaceNode != null) {
 671                      thenOperands.set(i, replaceNode);
 672                  }
 673              }
 674  
 675              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 676              return selectNode;
 677          }else if(selectNode.getKind() == OTHER){
 678              //不处理
 679              return selectNode;
 680          }else{
<abbr title=" 681              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 681              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 682          }
 683      }
 684  
 685      /**
<abbr title=" 686       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 686       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 687       *
 688       * @return
 689       */
<abbr title=" 690      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 690      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 691          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 692          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 693              return true;
 694          }
 695          return false;
 696      }
 697  
 698      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 699          List&lt;String&gt; res = Lists.newArrayList();
 700          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 701              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 702          });
 703          return res;
 704      }
 705  
<abbr title=" 706      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 706      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 707          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 708          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 709          List&lt;String&gt; conditionFields = Lists.newArrayList();
 710          for(SqlNode sqlNode : sqlNodeList){
 711              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 712                  throw new RuntimeException(&quot;not compare operator.&quot;);
 713              }
 714  
 715              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 716              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 717  
 718              String leftTableName = left.getComponent(0).getSimple();
 719              String rightTableName = right.getComponent(0).getSimple();
 720  
 721              String tableCol = &quot;&quot;;
 722              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 723                  tableCol = left.getComponent(1).getSimple();
 724              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 725                  tableCol = right.getComponent(1).getSimple();
 726              }else{
<abbr title=" 727                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 727                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 728              }
 729              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 730              conditionFields.add(tableCol);
 731          }
 732  
 733          return conditionFields;
 734      }
 735  
 736      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 737                                       SqlNode pollSqlNode,
 738                                       Map&lt;String, Table&gt; tableCache,
 739                                       List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 740  
 741          AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 742          if (localTableCache.containsKey(aliasInfo.getName())) {
 743              return;
 744          }
 745  
 746          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 747          tableEnv.registerTable(aliasInfo.getAlias(), table);
 748          localTableCache.put(aliasInfo.getAlias(), table);
 749  
 750          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 751  
 752          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 753          if(fieldReplaceInfo == null){
 754             return;
 755          }
 756  
 757          //as 的源表
 758          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 759          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 760          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 761          for(FieldReplaceInfo tmp : replaceInfoList){
 762              if(fromTableNameSet.contains(tmp.getTargetTableName())
 763                      || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 764                  fieldReplaceInfo.setPreNode(tmp);
 765                  break;
 766              }
 767          }
 768          replaceInfoList.add(fieldReplaceInfo);
 769      }
 770  
 771      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 772                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 773                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 774          JoinInfo joinInfo = (JoinInfo) pollObj;
 775  
 776          JoinScope joinScope = new JoinScope();
 777          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 778          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 779          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 780  
 781          SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 782          if(sqlKind == AS){
 783              dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 784          }
 785  
<abbr title=" 786          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 786          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 787 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 787 -        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 789 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().getFieldNames());"> 789 +        RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getFieldTypes(), leftTable.getSchema().ge🔵</abbr></span>
 790          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 791  
 792          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 793          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 794          rightScopeChild.setTableName(joinInfo.getRightTableName());
 795          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 796          if(sideTableInfo == null){
 797              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 798          }
 799  
 800          if(sideTableInfo == null){
 801              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 802          }
 803  
 804          if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 805              throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 806          }



 807  
 808          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 809  
 810          joinScope.addScope(leftScopeChild);
 811          joinScope.addScope(rightScopeChild);
 812  
 813          //获取两个表的所有字段
<abbr title=" 814          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 814          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 815  
 816          String leftTableAlias = joinInfo.getLeftTableAlias();
 817          Table targetTable = localTableCache.get(leftTableAlias);
 818          if(targetTable == null){
 819              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 820          }
 821  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 822 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 822 -        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 823 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -        DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -                    return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -                }).returns(CRow.class);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 828 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 829 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().getFieldNames());"> 829 +        RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getFieldTypes(), targetTable.getSchema().ge🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +        DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class);</span>
 832  
 833          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 834          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 835              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 835              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 836              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 837              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 838 -            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 838 -            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 839 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -        DataStream&lt;CRow&gt; dsOut = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 842 +            adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 842 +            adaptStream = adaptStream.keyBy(new TupleKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 843 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 844 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +        DataStream&lt;Tuple2&lt;Boolean, Row&gt;&gt; dsOut = null;</span>
 846          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 847              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 847              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 848          }else{
<abbr title=" 849              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 849              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 850          }
 851  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 852 -        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime</span>
 853          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 854          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 855  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 856 -        CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 857 -        dsOut.getTransformation().setOutputType(cRowTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +        TupleTypeInfo tupleTypeInfo = new TupleTypeInfo(Types.BOOLEAN, sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +        dsOut.getTransformation().setOutputType(tupleTypeInfo);</span>
 860  
 861          String targetTableName = joinInfo.getNewTableName();
 862          String targetTableAlias = joinInfo.getNewTableAlias();
 863  
 864          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 865          replaceInfo.setMappingTable(mappingTable);
 866          replaceInfo.setTargetTableName(targetTableName);
 867          replaceInfo.setTargetTableAlias(targetTableAlias);
 868  
 869          //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 870          for(FieldReplaceInfo tmp : replaceInfoList){
 871              if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 872              ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 873                  replaceInfo.setPreNode(tmp);
 874                  break;
 875              }
 876          }
 877  
 878          replaceInfoList.add(replaceInfo);
 879  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 880 -        if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 881 +        List&lt;String&gt; registeredTableName = Arrays.asList(tableEnv.listTables());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 882 +        if (!registeredTableName.contains(joinInfo.getNewTableName())){</span>
 883              Table joinTable = tableEnv.fromDataStream(dsOut);
 884              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 885              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 886          }
 887      }
 888  
 889      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 890          String[] fieldNames = schema.getFieldNames();
 891          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 892  
 893          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 894          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 894          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 895          return new RowTypeInfo(projectedTypes, projectedNames);
 896      }
 897  
 898  
 899      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 900          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 901          String fieldsInfo = result.getFieldsInfoStr();
 902          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 903          for (int i = 0; i &lt; fields.length; i++) {
 904              String[] filed = fields[i].split(&quot;\\s&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 905 -            if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +            if (filed.length &lt; 2 || fields.length != table.getSchema().getFieldCount()){</span>
 907                  return false;
 908              } else {
 909                  String[] filedNameArr = new String[filed.length - 1];
 910                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 911                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 912                  fieldNames.add(fieldName);
 913                  String fieldType = filed[filed.length - 1 ].trim();
 914                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 915                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 916                  if (fieldClass == tableField){
 917                      continue;
 918                  } else {
 919                      return false;
 920                  }
 921              }
 922          }
 923          tmpFields = String.join(&quot;,&quot;, fieldNames);
 924          return true;
 925      }
 926  
 927  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;

  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;

  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;
  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
  50  import org.apache.calcite.sql.SqlAsOperator;
  51  import org.apache.calcite.sql.SqlBasicCall;
  52  import org.apache.calcite.sql.SqlDataTypeSpec;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlJoin;
  56  import org.apache.calcite.sql.SqlKind;
  57  import org.apache.calcite.sql.SqlLiteral;
  58  import org.apache.calcite.sql.SqlNode;
  59  import org.apache.calcite.sql.SqlNodeList;
  60  import org.apache.calcite.sql.SqlOperator;
  61  import org.apache.calcite.sql.SqlOrderBy;
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
  64  import org.apache.calcite.sql.fun.SqlCase;
  65  import org.apache.calcite.sql.parser.SqlParseException;
  66  import org.apache.calcite.sql.parser.SqlParserPos;
  67  import org.apache.commons.collections.CollectionUtils;
  68  import org.apache.commons.lang3.StringUtils;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.sql.Timestamp;

  73  import java.util.Arrays;
  74  import java.util.Collection;
  75  import java.util.LinkedList;
  76  import java.util.List;
  77  import java.util.Map;
  78  import java.util.Queue;
  79  import java.util.Set;
  80  
  81  import static org.apache.calcite.sql.SqlKind.*;
  82  
  83  /**
  84   * Reason:
  85   * Date: 2018/7/24
  86   * Company: www.dtstack.com
  87   * @author xuchao
  88   */
  89  
  90  public class SideSqlExec {
  91  
  92      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93  
  94      private String localSqlPluginPath = null;
  95  
  96      private String tmpFields = null;
  97  
  98      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99  
 100      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101  
 102      public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<abbr title=" 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr>

 104          if(localSqlPluginPath == null){
 105              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 106          }
 107  
 108          localTableCache.putAll(tableCache);
 109          try {
 110              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 111          } catch (Exception e) {
 112              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 113          }
 114  
 115          if(createView != null){
 116              LOG.warn(&quot;create view info\n&quot;);
 117              LOG.warn(createView.getExecSql());
 118              LOG.warn(&quot;-----------------&quot;);
 119          }
 120  
 121          SideSQLParser sideSQLParser = new SideSQLParser();
 122          sideSQLParser.setLocalTableCache(localTableCache);
 123          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 124          Object pollObj = null;
 125  
 126          //need clean
 127          boolean preIsSideJoin = false;
 128          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 129  
 130          while((pollObj = exeQueue.poll()) != null){
 131  
 132              if(pollObj instanceof SqlNode){
 133                  SqlNode pollSqlNode = (SqlNode) pollObj;
 134  
 135                  if(preIsSideJoin){
 136                      preIsSideJoin = false;
 137                      List&lt;String&gt; fieldNames = null;
 138                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 139                          fieldNames = Lists.newArrayList();
 140                          replaceFieldName(pollSqlNode, replaceInfo);
 141                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 142                      }
 143                  }
 144  
 145                  if(pollSqlNode.getKind() == INSERT){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                    System.out.println(&quot;----------real exec sql-----------&quot; );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                    System.out.println(pollSqlNode.toString());</span>
 148                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);

 149                      if(LOG.isInfoEnabled()){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -                        LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +                        LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());</span>
 152                      }
 153  
 154                  }else if(pollSqlNode.getKind() == AS){
 155                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);
 156  
 157                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 158                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 159                      String TableAlias = sqlWithItem.name.toString();
 160                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 161                      tableEnv.registerTable(TableAlias, table);
 162  
 163                  } else if (pollSqlNode.getKind() == SELECT){
 164                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 165                      Table table = tableEnv.sqlQuery(pollObj.toString());
 166  
 167                      if (createView.getFieldsInfoStr() == null){
 168                          tableEnv.registerTable(createView.getTableName(), table);
 169                      } else {
 170                          if (checkFieldsInfo(createView, table)){
 171                              table = table.as(tmpFields);
 172                              tableEnv.registerTable(createView.getTableName(), table);
 173                          } else {
 174                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 175                          }
 176                      }
 177  
 178                      localTableCache.put(createView.getTableName(), table);
 179                  }
 180  
 181              }else if (pollObj instanceof JoinInfo){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                System.out.println(&quot;----------exec join info----------&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -                System.out.println(pollObj.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());</span>
 185                  preIsSideJoin = true;
 186                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);
 187              }
 188          }
 189  
 190      }
 191  
 192  
 193      /**
 194       * 解析出as查询的表和字段的关系
 195       * @param asSqlNode
 196       * @param tableCache
 197       * @return
 198       */
 199      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 200          SqlNode info = asSqlNode.getOperands()[0];
 201          SqlNode alias = asSqlNode.getOperands()[1];
 202  
 203          SqlKind infoKind = info.getKind();
 204          if(infoKind != SELECT){
 205              return null;
 206          }
 207  
 208          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 209  
 210          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 211          for (FieldInfo fieldInfo : extractFieldList) {
 212              String tableName = fieldInfo.getTable();
 213              String fieldName = fieldInfo.getFieldName();
 214              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 215              mappingTable.put(tableName, fieldName, mappingFieldName);
 216          }
 217  
 218          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 219          replaceInfo.setMappingTable(mappingTable);
 220          replaceInfo.setTargetTableName(alias.toString());
 221          replaceInfo.setTargetTableAlias(alias.toString());
 222          return replaceInfo;
 223      }
 224  
 225  
 226      /**
 227       * 添加字段别名
 228       * @param pollSqlNode
 229       * @param fieldList
 230       * @param mappingTable
 231       */
<abbr title=" 232      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 232      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 233          SqlKind sqlKind = pollSqlNode.getKind();
 234          switch (sqlKind) {
 235              case INSERT:
 236                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 237                  addAliasForFieldNode(source, fieldList, mappingTable);
 238                  break;
 239              case AS:
 240                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 241                  break;
 242              case SELECT:
 243                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 244                  selectList.getList().forEach(node -&gt; {
 245                      if (node.getKind() == IDENTIFIER) {
 246                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 247                          if (sqlIdentifier.names.size() == 1) {
 248                              return;
 249                          }
 250                          // save real field
 251                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 252                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 252                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 253                              fieldList.add(fieldName);
 254                          }
 255  
 256                      }
 257                  });
 258                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 259                      SqlNode node = selectList.get(i);
 260                      if (node.getKind() == IDENTIFIER) {
 261                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 262                          if (sqlIdentifier.names.size() == 1) {
 263                              return;
 264                          }
 265                          String name = sqlIdentifier.names.get(1);
 266                          // avoid real field pv0 convert pv
<abbr title=" 267                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 267                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 268                              SqlOperator operator = new SqlAsOperator();
 269                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 270  
<abbr title=" 271                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 271                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 272                              SqlNode[] sqlNodes = new SqlNode[2];
 273                              sqlNodes[0] = sqlIdentifier;
 274                              sqlNodes[1] = sqlIdentifierAlias;
 275                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 276  
 277                              selectList.set(i, sqlBasicCall);
 278                          }
 279                      }
 280                  }
 281                  break;
 282              default:
 283                  break;
 284          }
 285      }
 286  
 287  
 288      public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {
 289          SqlKind sqlKind = sqlNode.getKind();
 290          if(sqlKind != AS){
 291              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 292          }
 293  
 294          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 295          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 296  
 297          AliasInfo aliasInfo = new AliasInfo();
 298          aliasInfo.setName(info.toString());
 299          aliasInfo.setAlias(alias.toString());
 300  
 301          return aliasInfo;
 302      }
 303  
<abbr title=" 304      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 304      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>
 305          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 306          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 307          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 308              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 309              String tableName = fieldInfo.getTable();
 310              String fieldName = fieldInfo.getFieldName();
 311              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 312              mappingTable.put(tableName, fieldName, mappingFieldName);
 313  
 314              sideOutTypes[i] = fieldInfo.getTypeInformation();
 315              sideOutNames[i] = mappingFieldName;
 316          }
 317          return new RowTypeInfo(sideOutTypes, sideOutNames);
 318      }
 319  
 320  
 321  
 322      /**
 323       *  对时间类型进行类型转换
 324       * @param leftTypeInfo
 325       * @return
 326       */
 327      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 328          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 329          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 330          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 331              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 332          }
 333          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 334          return rowTypeInfo;
 335      }
 336  
 337      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 338          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 339              return TypeInformation.of(Timestamp.class);

 340          }
 341          return typeInformation;
 342      }
 343  
 344      //需要考虑更多的情况
 345      private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 346          SqlKind sqlKind = sqlNode.getKind();
 347          switch (sqlKind) {
 348              case INSERT:
 349                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 350                  replaceFieldName(sqlSource, replaceInfo);
 351                  break;
 352              case AS:
 353                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 354                  replaceFieldName(asNode, replaceInfo);
 355                  break;
 356              case SELECT:
<abbr title=" 357                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 357                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr>
 358                  if(sqlSelect == null){
 359                      return;
 360                  }
 361  
 362                  SqlNode sqlSource1 = sqlSelect.getFrom();
 363                  if(sqlSource1.getKind() == AS){
 364                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 365                      if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 366                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 367                          SqlNode whereNode = sqlSelect.getWhere();
 368                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 369  
 370                          //TODO 暂时不处理having
 371                          SqlNode sqlHaving = sqlSelect.getHaving();
 372  
 373                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 374                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 375                              SqlNode selectNode = sqlSelectList.getList().get(i);
 376                              //特殊处理 isStar的标识
 377                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 378                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 378                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr>
 379                                  newSelectNodeList.addAll(replaceNodeList);
 380                                  continue;
 381                              }
 382  
 383                              SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 384                              if(replaceNode == null){
 385                                  continue;
 386                              }
 387  
 388                              //sqlSelectList.set(i, replaceNode);
 389                              newSelectNodeList.add(replaceNode);
 390                          }
 391  
<abbr title=" 392                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 392                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 393                          sqlSelect.setSelectList(newSelectList);
 394  
 395                          //where
 396                          if(whereNode != null){
 397                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 398                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 399                                  SqlNode whereSqlNode = sqlNodeList[i];
 400                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 401                                  sqlNodeList[i] = replaceNode;
 402                              }
 403                          }
 404                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 405                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 406                                  SqlNode selectNode = sqlGroup.getList().get(i);
 407                                  SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 408                                  sqlGroup.set(i, replaceNode);
 409                              }
 410                          }
 411                      }
 412                  }else{
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -                    //TODO</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -                    System.out.println(sqlNode);</span>
 415                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 416                  }
 417  
 418                  break;
 419              case UNION:
 420                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 421                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 422                  replaceFieldName(unionLeft, replaceInfo);
 423                  replaceFieldName(unionRight, replaceInfo);
 424  
 425                  break;
 426              case ORDER_BY:
 427                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 428                  replaceFieldName(sqlOrderBy.query, replaceInfo);
 429                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 430                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 431                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 431                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr>
 432                      orderFiledList.set(i, replaceNode);
 433                  }
 434  
 435              default:
 436                  break;
 437          }
 438      }
 439  
 440      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 441          if(orderNode.getKind() == IDENTIFIER){
 442              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 443              if (sqlIdentifier.names.size() == 1) {
 444                  return orderNode;
 445              }
 446              return sqlIdentifier.setName(0, tableAlias);
 447          } else if (orderNode instanceof  SqlBasicCall) {
 448              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 449              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 450                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 451                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 452              }
 453              return sqlBasicCall;
 454          } else {
 455              return orderNode;
 456          }
 457      }
 458  
 459      private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 460          if(groupNode.getKind() == IDENTIFIER){
 461              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 462              if(sqlIdentifier.names.size() == 1){
 463                  return sqlIdentifier;
 464              }
 465  
<abbr title=" 466              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 466              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 467              if(mappingFieldName == null){
 468                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 469              }
 470  
 471              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 472              return sqlIdentifier.setName(1, mappingFieldName);
 473          }else if(groupNode instanceof  SqlBasicCall){
 474              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 475              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 476                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 477                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 478                  sqlBasicCall.getOperands()[i] = replaceNode;
 479              }
 480  
 481              return sqlBasicCall;
 482          }else{
 483              return groupNode;
 484          }
 485      }
 486  
 487      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 488  
 489          SqlKind sqlKind = sqlNode.getKind();
 490          switch (sqlKind){
 491              case SELECT:
 492                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 493                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 494                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 495                          return sqlNode;
 496                      }else{
 497                          return null;
 498                      }
 499                  }else{
 500                      return filterNodeWithTargetName(fromNode, targetTableName);
 501                  }
 502              case AS:
 503                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 504                  return filterNodeWithTargetName(childNode, targetTableName);
 505              case JOIN:
 506                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 507                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 508                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 509                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 510  
 511                  if(leftReturnNode != null) {
 512                      return leftReturnNode;
 513                  }else if(rightReturnNode != null){
 514                      return rightReturnNode;
 515                  }else{
 516                      return null;
 517                  }
 518              default:
 519                  break;
 520          }
 521  
 522          return null;
 523      }
 524  
 525  
 526      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 527          this.localSqlPluginPath = localSqlPluginPath;
 528      }
 529  
 530      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 531          Table table = localTableCache.get(tableAlias);
 532          if(table == null){
 533              table = localTableCache.get(tableName);
 534          }
 535  
 536          if(table == null){
 537              throw new RuntimeException(&quot;not register table &quot; + tableName);
 538          }
 539  
 540          return table;
 541      }
 542  
 543      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 544          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 545          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 546          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 547              int identifierSize = sqlIdentifier.names.size();
 548              Collection&lt;String&gt; columns = null;
 549              if(identifierSize == 1){
 550                  columns = replaceInfo.getMappingTable().values();
 551              }else{
 552                  columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 553              }
 554  
 555              for(String colAlias : columns){
 556                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 557                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 558                  columnInfo.add(replaceInfo.getTargetTableAlias());
 559                  columnInfo.add(colAlias);
 560                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 561                  sqlNodes.add(sqlIdentifierAlias);
 562              }
 563  
 564              return sqlNodes;
 565          }else{
 566              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 567          }
 568      }
 569  
 570      private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 571          if (selectNode.getKind() == AS) {
 572              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 573              SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 574              if (replaceNode != null) {
 575                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 576              }
 577  
 578              return selectNode;
 579          }else if(selectNode.getKind() == IDENTIFIER){
 580              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 581  
 582              if(sqlIdentifier.names.size() == 1){
 583                  return selectNode;
 584              }
 585  
 586              //Same level mappingTable
<abbr title=" 587              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 587              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 588              if (mappingFieldName == null) {
 589                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 590              }
 591  
 592              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 593              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 594              return sqlIdentifier;
 595          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 596              return selectNode;
 597          }else if(  AGGREGATE.contains(selectNode.getKind())
 598                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 599                  || COMPARISON.contains(selectNode.getKind())
 600                  || selectNode.getKind() == OTHER_FUNCTION
 601                  || selectNode.getKind() == DIVIDE
 602                  || selectNode.getKind() == CAST
 603                  || selectNode.getKind() == TRIM
 604                  || selectNode.getKind() == TIMES
 605                  || selectNode.getKind() == PLUS
 606                  || selectNode.getKind() == NOT_IN
 607                  || selectNode.getKind() == OR
 608                  || selectNode.getKind() == AND
 609                  || selectNode.getKind() == MINUS
 610                  || selectNode.getKind() == TUMBLE
 611                  || selectNode.getKind() == TUMBLE_START
 612                  || selectNode.getKind() == TUMBLE_END
 613                  || selectNode.getKind() == SESSION
 614                  || selectNode.getKind() == SESSION_START
 615                  || selectNode.getKind() == SESSION_END
 616                  || selectNode.getKind() == HOP
 617                  || selectNode.getKind() == HOP_START
 618                  || selectNode.getKind() == HOP_END
 619                  || selectNode.getKind() == BETWEEN
 620                  || selectNode.getKind() == IS_NULL
 621                  || selectNode.getKind() == IS_NOT_NULL
 622                  || selectNode.getKind() == CONTAINS
 623                  || selectNode.getKind() == TIMESTAMP_ADD
 624                  || selectNode.getKind() == TIMESTAMP_DIFF
 625                  || selectNode.getKind() == LIKE
 626  
 627                  ){
 628              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 629              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 630                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 631                  if(sqlNode instanceof SqlLiteral){
 632                      continue;
 633                  }
 634  
 635                  if(sqlNode instanceof SqlDataTypeSpec){
 636                      continue;
 637                  }
 638  
 639                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 640                  if(replaceNode == null){
 641                      continue;
 642                  }
 643  
 644                  sqlBasicCall.getOperands()[i] = replaceNode;
 645              }
 646  
 647              return selectNode;
 648          }else if(selectNode.getKind() == CASE){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -            System.out.println(&quot;selectNode&quot;);</span>
 650              SqlCase sqlCase = (SqlCase) selectNode;
 651              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 652              SqlNodeList thenOperands = sqlCase.getThenOperands();
 653              SqlNode elseNode = sqlCase.getElseOperand();
 654  
 655              for(int i=0; i&lt;whenOperands.size(); i++){
 656                  SqlNode oneOperand = whenOperands.get(i);
 657                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 658                  if (replaceNode != null) {
 659                      whenOperands.set(i, replaceNode);
 660                  }
 661              }
 662  
 663              for(int i=0; i&lt;thenOperands.size(); i++){
 664                  SqlNode oneOperand = thenOperands.get(i);
 665                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 666                  if (replaceNode != null) {
 667                      thenOperands.set(i, replaceNode);
 668                  }
 669              }
 670  
 671              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 672              return selectNode;
 673          }else if(selectNode.getKind() == OTHER){
 674              //不处理
 675              return selectNode;
 676          }else{
<abbr title=" 677              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 677              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 678          }
 679      }
 680  
 681      /**
<abbr title=" 682       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 682       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 683       *
 684       * @return
 685       */
<abbr title=" 686      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 686      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 687          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 688          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 689              return true;
 690          }
 691          return false;
 692      }
 693  
 694      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 695          List&lt;String&gt; res = Lists.newArrayList();
 696          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 697              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 698          });
 699          return res;
 700      }
 701  
<abbr title=" 702      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 702      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 703          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 704          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 705          List&lt;String&gt; conditionFields = Lists.newArrayList();
 706          for(SqlNode sqlNode : sqlNodeList){
 707              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 708                  throw new RuntimeException(&quot;not compare operator.&quot;);
 709              }
 710  
 711              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 712              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 713  
 714              String leftTableName = left.getComponent(0).getSimple();
 715              String rightTableName = right.getComponent(0).getSimple();
 716  
 717              String tableCol = &quot;&quot;;
 718              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 719                  tableCol = left.getComponent(1).getSimple();
 720              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 721                  tableCol = right.getComponent(1).getSimple();
 722              }else{
<abbr title=" 723                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 723                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 724              }
 725              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 726              conditionFields.add(tableCol);
 727          }
 728  
 729          return conditionFields;
 730      }
 731  
 732      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 733                                       SqlNode pollSqlNode,
 734                                       Map&lt;String, Table&gt; tableCache,
 735                                       List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 736  
 737          AliasInfo aliasInfo = parseAsNode(pollSqlNode);
 738          if (localTableCache.containsKey(aliasInfo.getName())) {
 739              return;
 740          }
 741  
 742          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 743          tableEnv.registerTable(aliasInfo.getAlias(), table);
 744          localTableCache.put(aliasInfo.getAlias(), table);
 745  
 746          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 747  
 748          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 749          if(fieldReplaceInfo == null){
 750             return;
 751          }
 752  
 753          //as 的源表
 754          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 755          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 756          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 757          for(FieldReplaceInfo tmp : replaceInfoList){
 758              if(fromTableNameSet.contains(tmp.getTargetTableName())
 759                      || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 760                  fieldReplaceInfo.setPreNode(tmp);
 761                  break;
 762              }
 763          }
 764          replaceInfoList.add(fieldReplaceInfo);
 765      }
 766  
 767      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 768                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 769                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{
 770          JoinInfo joinInfo = (JoinInfo) pollObj;
 771  
 772          JoinScope joinScope = new JoinScope();
 773          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 774          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 775          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 776  
 777          SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 778          if(sqlKind == AS){
 779              dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 780          }
 781  
<abbr title=" 782          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 782          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 783          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 783          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>


 784          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 785  
 786          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 787          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 788          rightScopeChild.setTableName(joinInfo.getRightTableName());
 789          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 790          if(sideTableInfo == null){
 791              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 792          }
 793  
 794          if(sideTableInfo == null){
 795              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 796          }
 797  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 798 -        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 799 -            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 800 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 801 +//        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 802 +//            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +//        }</span>
 804  
 805          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 806  
 807          joinScope.addScope(leftScopeChild);
 808          joinScope.addScope(rightScopeChild);
 809  
 810          //获取两个表的所有字段
<abbr title=" 811          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 811          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
 812  
 813          String leftTableAlias = joinInfo.getLeftTableAlias();
 814          Table targetTable = localTableCache.get(leftTableAlias);
 815          if(targetTable == null){
 816              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 817          }
 818  
<abbr title=" 819          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 819          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 820  
 821          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 822                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 823                      return new CRow(tp2.f1, tp2.f0);
 824                  }).returns(CRow.class);
 825  



 826  
 827          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 828          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 829              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 829              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 830              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 831              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 832              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 832              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 833          }
 834  
 835          DataStream&lt;CRow&gt; dsOut = null;




 836          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 837              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 837              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 838          }else{
<abbr title=" 839              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 839              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 840          }
 841  
 842          // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
 843          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 844          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 845  
 846          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 847          dsOut.getTransformation().setOutputType(cRowTypeInfo);


 848  
 849          String targetTableName = joinInfo.getNewTableName();
 850          String targetTableAlias = joinInfo.getNewTableAlias();
 851  
 852          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 853          replaceInfo.setMappingTable(mappingTable);
 854          replaceInfo.setTargetTableName(targetTableName);
 855          replaceInfo.setTargetTableAlias(targetTableAlias);
 856  
 857          //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 858          for(FieldReplaceInfo tmp : replaceInfoList){
 859              if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 860              ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 861                  replaceInfo.setPreNode(tmp);
 862                  break;
 863              }
 864          }
 865  
 866          replaceInfoList.add(replaceInfo);
 867  
 868          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){


 869              Table joinTable = tableEnv.fromDataStream(dsOut);
 870              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 871              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 872          }
 873      }
 874  
 875      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 876          String[] fieldNames = schema.getFieldNames();
 877          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 878  
 879          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 880          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 880          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 881          return new RowTypeInfo(projectedTypes, projectedNames);
 882      }
 883  
 884  
 885      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 886          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 887          String fieldsInfo = result.getFieldsInfoStr();
 888          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 889          for (int i = 0; i &lt; fields.length; i++) {
 890              String[] filed = fields[i].split(&quot;\\s&quot;);
 891              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){

 892                  return false;
 893              } else {
 894                  String[] filedNameArr = new String[filed.length - 1];
 895                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 896                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 897                  fieldNames.add(fieldName);
 898                  String fieldType = filed[filed.length - 1 ].trim();
 899                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 900                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 901                  if (fieldClass == tableField){
 902                      continue;
 903                  } else {
 904                      return false;
 905                  }
 906              }
 907          }
 908          tmpFields = String.join(&quot;,&quot;, fieldNames);
 909          return true;
 910      }
 911  
 912  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            