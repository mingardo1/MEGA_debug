<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>11</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    11
                    <a href="10.html">prev</a>
                    <a href="12.html">next</a>
                    <a href="11_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    AriaLyy/Aria_202e6645300cc1a327e9c972c3f61f099631169e_Aria/src/main/java/com/arialyy/aria/core/download/group/AbsGroupUtil.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;202e6645300cc1a327e9c972c3f61f099631169e:Aria/src/main/java/com/arialyy/aria/core/download/group/AbsGroupUtil.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;202e6645300cc1a327e9c972c3f61f099631169e^1:Aria/src/main/java/com/arialyy/aria/core/download/group/AbsGroupUtil.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;202e6645300cc1a327e9c972c3f61f099631169e^2:Aria/src/main/java/com/arialyy/aria/core/download/group/AbsGroupUtil.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;a5fc5d0bcfacb42139b088f746beb7394c90a8c0:Aria/src/main/java/com/arialyy/aria/core/download/group/AbsGroupUtil.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [j], [j], [j]], subset: [[bj], [b], [j], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.download.group;
  17 
  18 import android.os.Handler;
  19 import android.os.Looper;
  20 import com.arialyy.aria.core.common.IUtil;
  21 import com.arialyy.aria.core.config.Configuration;
  22 import com.arialyy.aria.core.download.DGTaskWrapper;
  23 import com.arialyy.aria.core.download.DTaskWrapper;
  24 import com.arialyy.aria.core.inf.IEntity;
  25 import com.arialyy.aria.util.ALog;
  26 import java.util.Map;
  27 import java.util.WeakHashMap;
  28 import java.util.concurrent.ScheduledThreadPoolExecutor;
  29 import java.util.concurrent.TimeUnit;
  30 
  31 /**
  32  * Created by AriaL on 2017/6/30.
  33  * 任务组核心逻辑
  34  */
  35 public abstract class AbsGroupUtil implements IUtil {
  36   private final String TAG = &quot;AbsGroupUtil&quot;;
  37   /**
  38    * FTP文件夹
  39    */
  40   int FTP_DIR = 0xa1;
  41   /**
  42    * D_HTTP 任务组
  43    */
  44   int HTTP_GROUP = 0xa2;
  45 
  46   private long mCurrentLocation = 0;
  47   protected IDGroupListener mListener;
  48   private ScheduledThreadPoolExecutor mTimer;
  49   private long mUpdateInterval;
  50   private boolean isStop = false, isCancel = false;
  51   private Handler mScheduler;
  52   private SimpleSubQueue mSubQueue = SimpleSubQueue.newInstance();
  53   private Map&lt;String, SubDLoadUtil&gt; mExeLoader = new WeakHashMap&lt;&gt;();
  54   private Map&lt;String, DTaskWrapper&gt; mCache = new WeakHashMap&lt;&gt;();
  55   DGTaskWrapper mGTWrapper;
  56   GroupRunState mState;
  57 
  58   AbsGroupUtil(IDGroupListener listener, DGTaskWrapper groupWrapper) {
  59     mListener = listener;
  60     mGTWrapper = groupWrapper;
  61     mUpdateInterval = Configuration.getInstance().downloadCfg.getUpdateInterval();
  62   }
  63 
  64   /**
  65    * 初始化组合任务状态
  66    */
  67   void initState() {
  68     mState =
  69         new GroupRunState(mGTWrapper.getKey(), mListener, mGTWrapper.getSubTaskWrapper().size(),
  70             mSubQueue);
  71     mScheduler = new Handler(Looper.getMainLooper(), SimpleSchedulers.newInstance(mState));
  72     for (DTaskWrapper wrapper : mGTWrapper.getSubTaskWrapper()) {
  73       if (wrapper.getEntity().getState() == IEntity.STATE_COMPLETE) {
  74         mState.updateCompleteNum();
  75         mCurrentLocation += wrapper.getEntity().getFileSize();
  76       } else {
  77         mCache.put(wrapper.getKey(), wrapper);
  78         mCurrentLocation += wrapper.getEntity().getCurrentProgress();
  79       }
  80     }
  81     mState.updateProgress(mCurrentLocation);
  82   }
  83 
  84   @Override public String getKey() {
  85     return mGTWrapper.getKey();
  86   }
  87 
  88   /**
  89    * 获取任务类型
  90    *
  91    * @return {@link #FTP_DIR}、{@link #HTTP_GROUP}
  92    */
  93   abstract int getTaskType();
  94 
  95   /**
  96    * 启动子任务下载
  97    *
  98    * @param url 子任务下载地址
  99    */
 100   public void startSubTask(String url) {
 101     if (!checkSubTask(url, &quot;开始&quot;)) return;
 102     if (!mState.isRunning) {
 103       startTimer();
 104     }
 105     SubDLoadUtil d = getDownloader(url);
 106     if (d != null &amp;&amp; !d.isRunning()) {
 107       mSubQueue.startTask(d);
 108     }
 109   }
 110 
 111   /**
 112    * 停止子任务下载
 113    *
 114    * @param url 子任务下载地址
 115    */
 116   public void stopSubTask(String url) {
 117     if (!checkSubTask(url, &quot;停止&quot;)) return;
 118     SubDLoadUtil d = getDownloader(url);
 119     if (d != null &amp;&amp; d.isRunning()) {
 120       mSubQueue.stopTask(d);
 121     }
 122   }
 123 
 124   /**
 125    * 检查子任务
 126    *
 127    * @param url 子任务url
 128    * @param type 任务类型
 129    * @return {@code true} 任务可以下载
 130    */
 131   private boolean checkSubTask(String url, String type) {
 132     DTaskWrapper wrapper = mCache.get(url);
 133     if (wrapper != null) {
 134       if (wrapper.getState() == IEntity.STATE_COMPLETE) {
 135         ALog.w(TAG, &quot;任务【&quot; + url + &quot;】已完成，&quot; + type + &quot;失败&quot;);
 136         return false;
 137       }
 138     } else {
 139       ALog.w(TAG, &quot;任务组中没有该任务【&quot; + url + &quot;】，&quot; + type + &quot;失败&quot;);
 140       return false;
 141     }
 142     return true;
 143   }
 144 
 145   /**
 146    * 通过地址获取下载器
 147    *
 148    * @param url 子任务下载地址
 149    */
 150   private SubDLoadUtil getDownloader(String url) {
 151     SubDLoadUtil d = mExeLoader.get(url);
 152     if (d == null) {
 153       return createAndStartSubLoader(mCache.get(url));
 154     }
 155     return d;
 156   }
 157 
 158   @Override public long getFileSize() {
 159     return mGTWrapper.getEntity().getFileSize();
 160   }
 161 
 162   @Override public long getCurrentLocation() {
 163     return mCurrentLocation;
 164   }
 165 
 166   @Override public boolean isRunning() {
 167     return mState != null &amp;&amp; mState.isRunning;
 168   }
 169 
 170   @Override public void cancel() {
 171     isCancel = true;
 172     closeTimer();
 173     onPreCancel();
 174 
 175     mSubQueue.removeAllTask();
 176     mListener.onCancel();
 177   }
 178 
 179   /**
 180    * onCancel前的操作
 181    */
 182   public void onPreCancel() {
 183 
 184   }
 185 
 186   @Override public void stop() {
 187     isStop = true;
 188     closeTimer();
 189     if (onPreStop()) {
 190       return;
 191     }
 192     mSubQueue.stopAllTask();
 193   }
 194 
 195   /**
 196    * onStop前的操作
 197    *
 198    * @return 返回{@code true}，直接回调{@link IDGroupListener#onStop(long)}
 199    */
 200   protected boolean onPreStop() {
 201 
 202     return false;
 203   }
 204 
 205   @Override public void start() {
 206     if (isStop || isCancel) {
 207       closeTimer();
 208       return;
 209     }
 210 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 211     onPreStart();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 212     startRunningFlow();</span>
 213 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 214     if (isStop || isCancel) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 215       closeTimer();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 216       return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 217     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 218     onStart();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 219     startRunningFlow();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 220   }</span>
 221 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 222     if (onStart()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 223       startRunningFlow();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 224     }</span>
 225 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 226   }
 227 
 228 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 229   protected void onPreStart() {</span>
 230 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 231     onStart();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 232     startRunningFlow();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 233   }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 234 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 235   protected void onStart() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 236 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 237   }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 238 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 239   synchronized void closeTimer() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 240     if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 241       mTimer.shutdown();</span>
 242 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 243   /**</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 244    * 处理启动前的检查：获取组合任务大小</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 245    *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 246    * @return {@code false} 将不再走后续流程，任务介绍</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 247    */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 248   protected boolean onStart() {</span>
 249 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 250 
 251     return false;
 252   }
 253 
 254   synchronized void closeTimer() {
 255     if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {
 256       mTimer.shutdown();
 257     }
 258   }
 259 
 260   /**
 261    * 开始进度流程
 262    */
 263   private void startRunningFlow() {
 264     closeTimer();
 265     mListener.onPostPre(mGTWrapper.getEntity().getFileSize());
 266     if (mCurrentLocation &gt; 0) {
 267       mListener.onResume(mCurrentLocation);
 268     } else {
 269       mListener.onStart(mCurrentLocation);
 270     }
 271     startTimer();
 272   }
 273 
 274   private synchronized void startTimer() {
 275     mState.isRunning = true;
 276     mTimer = new ScheduledThreadPoolExecutor(1);
 277     mTimer.scheduleWithFixedDelay(new Runnable() {
 278       @Override public void run() {
 279         if (!mState.isRunning) {
 280           closeTimer();
 281         } else if (mCurrentLocation &gt;= 0) {
 282           long t = 0;
 283           for (DTaskWrapper te : mGTWrapper.getSubTaskWrapper()) {
 284             if (te.getState() == IEntity.STATE_COMPLETE) {
 285               t += te.getEntity().getFileSize();
 286             } else {
 287               t += te.getEntity().getCurrentProgress();
 288             }
 289           }
 290           mCurrentLocation = t;
 291           mState.updateProgress(mCurrentLocation);
 292           mListener.onProgress(t);
 293         }
 294       }
 295     }, 0, mUpdateInterval, TimeUnit.MILLISECONDS);
 296   }
 297 
 298   /**
 299    * 创建并启动子任务下载器
 300    */
 301   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper) {
 302     return createAndStartSubLoader(taskWrapper, true);
 303   }
 304 
 305   /**
 306    * 创建并启动子任务下载器
 307    *
 308    * @param needGetFileInfo {@code true} 需要获取文件信息。{@code false} 不需要获取文件信息
 309    */
 310   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper, boolean needGetFileInfo) {
 311     SubDLoadUtil loader = new SubDLoadUtil(mScheduler, taskWrapper, needGetFileInfo);
 312     mExeLoader.put(loader.getKey(), loader);
 313     mSubQueue.startTask(loader);
 314     return loader;
 315   }
 316 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.download.group;
  17 
  18 import android.os.Handler;
  19 import android.os.Looper;
  20 import com.arialyy.aria.core.common.IUtil;
  21 import com.arialyy.aria.core.config.Configuration;
  22 import com.arialyy.aria.core.download.DGTaskWrapper;
  23 import com.arialyy.aria.core.download.DTaskWrapper;
  24 import com.arialyy.aria.core.inf.IEntity;
  25 import com.arialyy.aria.util.ALog;
  26 import java.util.Map;
  27 import java.util.WeakHashMap;
  28 import java.util.concurrent.ScheduledThreadPoolExecutor;
  29 import java.util.concurrent.TimeUnit;
  30 
  31 /**
  32  * Created by AriaL on 2017/6/30.
  33  * 任务组核心逻辑
  34  */
  35 public abstract class AbsGroupUtil implements IUtil {
  36   private final String TAG = &quot;AbsGroupUtil&quot;;
  37   /**
  38    * FTP文件夹
  39    */
  40   int FTP_DIR = 0xa1;
  41   /**
  42    * D_HTTP 任务组
  43    */
  44   int HTTP_GROUP = 0xa2;
  45 
  46   private long mCurrentLocation = 0;
  47   protected IDGroupListener mListener;
  48   private ScheduledThreadPoolExecutor mTimer;
  49   private long mUpdateInterval;
  50   private boolean isStop = false, isCancel = false;
  51   private Handler mScheduler;
  52   private SimpleSubQueue mSubQueue = SimpleSubQueue.newInstance();
  53   private Map&lt;String, SubDLoadUtil&gt; mExeLoader = new WeakHashMap&lt;&gt;();
  54   private Map&lt;String, DTaskWrapper&gt; mCache = new WeakHashMap&lt;&gt;();
  55   DGTaskWrapper mGTWrapper;
  56   GroupRunState mState;
  57 
  58   AbsGroupUtil(IDGroupListener listener, DGTaskWrapper groupWrapper) {
  59     mListener = listener;
  60     mGTWrapper = groupWrapper;
  61     mUpdateInterval = Configuration.getInstance().downloadCfg.getUpdateInterval();
  62   }
  63 
  64   /**
  65    * 初始化组合任务状态
  66    */
  67   void initState() {
  68     mState =
  69         new GroupRunState(mGTWrapper.getKey(), mListener, mGTWrapper.getSubTaskWrapper().size(),
  70             mSubQueue);
  71     mScheduler = new Handler(Looper.getMainLooper(), SimpleSchedulers.newInstance(mState));
  72     for (DTaskWrapper wrapper : mGTWrapper.getSubTaskWrapper()) {
  73       if (wrapper.getEntity().getState() == IEntity.STATE_COMPLETE) {
  74         mState.updateCompleteNum();
  75         mCurrentLocation += wrapper.getEntity().getFileSize();
  76       } else {
  77         mCache.put(wrapper.getKey(), wrapper);
  78         mCurrentLocation += wrapper.getEntity().getCurrentProgress();
  79       }
  80     }
  81     mState.updateProgress(mCurrentLocation);
  82   }
  83 
  84   @Override public String getKey() {
  85     return mGTWrapper.getKey();
  86   }
  87 
  88   /**
  89    * 获取任务类型
  90    *
  91    * @return {@link #FTP_DIR}、{@link #HTTP_GROUP}
  92    */
  93   abstract int getTaskType();
  94 
  95   /**
  96    * 启动子任务下载
  97    *
  98    * @param url 子任务下载地址
  99    */
 100   public void startSubTask(String url) {
 101     if (!checkSubTask(url, &quot;开始&quot;)) return;
 102     if (!mState.isRunning) {
 103       startTimer();
 104     }
 105     SubDLoadUtil d = getDownloader(url);
 106     if (d != null &amp;&amp; !d.isRunning()) {
 107       mSubQueue.startTask(d);
 108     }
 109   }
 110 
 111   /**
 112    * 停止子任务下载
 113    *
 114    * @param url 子任务下载地址
 115    */
 116   public void stopSubTask(String url) {
 117     if (!checkSubTask(url, &quot;停止&quot;)) return;
 118     SubDLoadUtil d = getDownloader(url);
 119     if (d != null &amp;&amp; d.isRunning()) {
 120       mSubQueue.stopTask(d);
 121     }
 122   }
 123 
 124   /**
 125    * 检查子任务
 126    *
 127    * @param url 子任务url
 128    * @param type 任务类型
 129    * @return {@code true} 任务可以下载
 130    */
 131   private boolean checkSubTask(String url, String type) {
 132     DTaskWrapper wrapper = mCache.get(url);
 133     if (wrapper != null) {
 134       if (wrapper.getState() == IEntity.STATE_COMPLETE) {
 135         ALog.w(TAG, &quot;任务【&quot; + url + &quot;】已完成，&quot; + type + &quot;失败&quot;);
 136         return false;
 137       }
 138     } else {
 139       ALog.w(TAG, &quot;任务组中没有该任务【&quot; + url + &quot;】，&quot; + type + &quot;失败&quot;);
 140       return false;
 141     }
 142     return true;
 143   }
 144 
 145   /**
 146    * 通过地址获取下载器
 147    *
 148    * @param url 子任务下载地址
 149    */
 150   private SubDLoadUtil getDownloader(String url) {
 151     SubDLoadUtil d = mExeLoader.get(url);
 152     if (d == null) {
 153       return createAndStartSubLoader(mCache.get(url));
 154     }
 155     return d;
 156   }
 157 
 158   @Override public long getFileSize() {
 159     return mGTWrapper.getEntity().getFileSize();
 160   }
 161 
 162   @Override public long getCurrentLocation() {
 163     return mCurrentLocation;
 164   }
 165 
 166   @Override public boolean isRunning() {
 167     return mState != null &amp;&amp; mState.isRunning;
 168   }
 169 
 170   @Override public void cancel() {
 171     isCancel = true;
 172     closeTimer();
 173     onPreCancel();
 174 
 175     mSubQueue.removeAllTask();
 176     mListener.onCancel();
 177   }
 178 
 179   /**
 180 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 181    * onCancel前的操作</span>
 182 ||||||| BASE
 183 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 184    * 处理启动前的检查：获取组合任务大小</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 185    *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 186    * @return {@code false} 将不再走后续流程，任务介绍</span>
 187 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 188    */
 189 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 190 public void onPreCancel() {</span>
 191 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 192 protected void onStart() {</span>
 193 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 194 protected boolean onStart() {</span>
 195 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 196 
 197     return false;
 198   }
 199 
 200   @Override public void stop() {
 201     isStop = true;
 202     closeTimer();
 203     if (onPreStop()) {
 204       return;
 205     }
 206     mSubQueue.stopAllTask();
 207   }
 208 
 209   /**
 210    * onStop前的操作
 211    *
 212    * @return 返回{@code true}，直接回调{@link IDGroupListener#onStop(long)}
 213    */
 214   protected boolean onPreStop() {
 215 
 216     return false;
 217   }
 218 
 219   @Override public void start() {
 220     if (isStop || isCancel) {
 221       closeTimer();
 222       return;
 223     }
 224 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 225     onPreStart();</span>
 226 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 227     onStart();</span>
 228 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 229     if (onStart()) {</span>
 230 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 231     startRunningFlow();
 232   }
 233   }
 234 
 235   protected void onPreStart() {
 236 
 237   }
 238 
 239   synchronized void closeTimer() {
 240     if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {
 241       mTimer.shutdown();
 242     }
 243   }
 244 
 245   /**
 246    * 开始进度流程
 247    */
 248   private void startRunningFlow() {
 249     closeTimer();
 250     mListener.onPostPre(mGTWrapper.getEntity().getFileSize());
 251     if (mCurrentLocation &gt; 0) {
 252       mListener.onResume(mCurrentLocation);
 253     } else {
 254       mListener.onStart(mCurrentLocation);
 255     }
 256     startTimer();
 257   }
 258 
 259   private synchronized void startTimer() {
 260     mState.isRunning = true;
 261     mTimer = new ScheduledThreadPoolExecutor(1);
 262     mTimer.scheduleWithFixedDelay(new Runnable() {
 263       @Override public void run() {
 264         if (!mState.isRunning) {
 265           closeTimer();
 266         } else if (mCurrentLocation &gt;= 0) {
 267           long t = 0;
 268           for (DTaskWrapper te : mGTWrapper.getSubTaskWrapper()) {
 269             if (te.getState() == IEntity.STATE_COMPLETE) {
 270               t += te.getEntity().getFileSize();
 271             } else {
 272               t += te.getEntity().getCurrentProgress();
 273             }
 274           }
 275           mCurrentLocation = t;
 276           mState.updateProgress(mCurrentLocation);
 277           mListener.onProgress(t);
 278         }
 279       }
 280     }, 0, mUpdateInterval, TimeUnit.MILLISECONDS);
 281   }
 282 
 283   /**
 284    * 创建并启动子任务下载器
 285    */
 286   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper) {
 287     return createAndStartSubLoader(taskWrapper, true);
 288   }
 289 
 290   /**
 291    * 创建并启动子任务下载器
 292    *
 293    * @param needGetFileInfo {@code true} 需要获取文件信息。{@code false} 不需要获取文件信息
 294    */
 295   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper, boolean needGetFileInfo) {
 296     SubDLoadUtil loader = new SubDLoadUtil(mScheduler, taskWrapper, needGetFileInfo);
 297     mExeLoader.put(loader.getKey(), loader);
 298     mSubQueue.startTask(loader);
 299     return loader;
 300   }
 301 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.arialyy.aria.core.download.group;
  17 
  18 import android.os.Handler;
  19 import android.os.Looper;
  20 import com.arialyy.aria.core.common.IUtil;
  21 import com.arialyy.aria.core.config.Configuration;
  22 import com.arialyy.aria.core.download.DGTaskWrapper;
  23 import com.arialyy.aria.core.download.DTaskWrapper;
  24 import com.arialyy.aria.core.inf.IEntity;
  25 import com.arialyy.aria.util.ALog;
  26 import java.util.Map;
  27 import java.util.WeakHashMap;
  28 import java.util.concurrent.ScheduledThreadPoolExecutor;
  29 import java.util.concurrent.TimeUnit;
  30 
  31 
  32 /**
  33  * Created by AriaL on 2017/6/30.
  34  * 任务组核心逻辑
  35  */
  36 public abstract class AbsGroupUtil implements IUtil {
  37   private final String TAG = &quot;AbsGroupUtil&quot;;
  38 
  39   /**
  40    * FTP文件夹
  41    */
  42   int FTP_DIR = 0xa1;
  43 
  44   /**
  45    * D_HTTP 任务组
  46    */
  47   int HTTP_GROUP = 0xa2;
  48 
  49   private long mCurrentLocation = 0;
  50 
  51   protected IDGroupListener mListener;
  52 
  53   private ScheduledThreadPoolExecutor mTimer;
  54 
  55   private long mUpdateInterval;
  56 
  57   private boolean isStop = false;
  58 
  59   private boolean isCancel = false;
  60 
  61   private Handler mScheduler;
  62 
  63   private SimpleSubQueue mSubQueue = SimpleSubQueue.newInstance();
  64 
  65   private Map&lt;String, SubDLoadUtil&gt; mExeLoader = new WeakHashMap&lt;&gt;();
  66 
  67   private Map&lt;String, DTaskWrapper&gt; mCache = new WeakHashMap&lt;&gt;();
  68 
  69   DGTaskWrapper mGTWrapper;
  70 
  71   GroupRunState mState;
  72 
  73   AbsGroupUtil(IDGroupListener listener, DGTaskWrapper groupWrapper) {
  74     mListener = listener;
  75     mGTWrapper = groupWrapper;
  76     mUpdateInterval = Configuration.getInstance().downloadCfg.getUpdateInterval();
  77   }
  78 
  79   /**
  80    * 初始化组合任务状态
  81    */
  82   void initState() {
<abbr title="  83     mState = new GroupRunState(mGTWrapper.getKey(), mListener, mGTWrapper.getSubTaskWrapper().size(), mSubQueue);">  83     mState = new GroupRunState(mGTWrapper.getKey(), mListener, mGTWrapper.getSubTaskWrapper().size(), mSu🔵</abbr>
  84     mScheduler = new Handler(Looper.getMainLooper(), SimpleSchedulers.newInstance(mState));
  85     for (DTaskWrapper wrapper : mGTWrapper.getSubTaskWrapper()) {
  86       if (wrapper.getEntity().getState() == IEntity.STATE_COMPLETE) {
  87         mState.updateCompleteNum();
  88         mCurrentLocation += wrapper.getEntity().getFileSize();
  89       } else {
  90         mCache.put(wrapper.getKey(), wrapper);
  91         mCurrentLocation += wrapper.getEntity().getCurrentProgress();
  92       }
  93     }
  94     mState.updateProgress(mCurrentLocation);
  95   }
  96 
  97   @Override public String getKey() {
  98     return mGTWrapper.getKey();
  99   }
 100 
 101   /**
 102    * 获取任务类型
 103    *
 104    * @return {@link #FTP_DIR}、{@link #HTTP_GROUP}
 105    */
 106   abstract int getTaskType();
 107 
 108   /**
 109    * 启动子任务下载
 110    *
 111    * @param url 子任务下载地址
 112    */
 113   public void startSubTask(String url) {
 114     if (!checkSubTask(url, &quot;开始&quot;)) return;
 115     if (!mState.isRunning) {
 116       startTimer();
 117     }
 118     SubDLoadUtil d = getDownloader(url);
 119     if (d != null &amp;&amp; !d.isRunning()) {
 120       mSubQueue.startTask(d);
 121     }
 122   }
 123 
 124   /**
 125    * 停止子任务下载
 126    *
 127    * @param url 子任务下载地址
 128    */
 129   public void stopSubTask(String url) {
 130     if (!checkSubTask(url, &quot;停止&quot;)) return;
 131     SubDLoadUtil d = getDownloader(url);
 132     if (d != null &amp;&amp; d.isRunning()) {
 133       mSubQueue.stopTask(d);
 134     }
 135   }
 136 
 137   /**
 138    * 检查子任务
 139    *
 140    * @param url 子任务url
 141    * @param type 任务类型
 142    * @return {@code true} 任务可以下载
 143    */
 144   private boolean checkSubTask(String url, String type) {
 145     DTaskWrapper wrapper = mCache.get(url);
 146     if (wrapper != null) {
 147       if (wrapper.getState() == IEntity.STATE_COMPLETE) {
 148         ALog.w(TAG, &quot;任务【&quot; + url + &quot;】已完成，&quot; + type + &quot;失败&quot;);
 149         return false;
 150       }
 151     } else {
 152       ALog.w(TAG, &quot;任务组中没有该任务【&quot; + url + &quot;】，&quot; + type + &quot;失败&quot;);
 153       return false;
 154     }
 155     return true;
 156   }
 157 
 158   /**
 159    * 通过地址获取下载器
 160    *
 161    * @param url 子任务下载地址
 162    */
 163   private SubDLoadUtil getDownloader(String url) {
 164     SubDLoadUtil d = mExeLoader.get(url);
 165     if (d == null) {
 166       return createAndStartSubLoader(mCache.get(url));
 167     }
 168     return d;
 169   }
 170 
 171   @Override public long getFileSize() {
 172     return mGTWrapper.getEntity().getFileSize();
 173   }
 174 
 175   @Override public long getCurrentLocation() {
 176     return mCurrentLocation;
 177   }
 178 
 179   @Override
 180   public boolean isRunning() {
 181     return (mState != null) &amp;&amp; mState.isRunning;
 182   }
 183 
 184   @Override public void cancel() {
 185     isCancel = true;
 186     closeTimer();
 187     onPreCancel();
 188 
 189     mSubQueue.removeAllTask();
 190     mListener.onCancel();
 191   }
 192 
 193   /**
 194    * onCancel前的操作
 195    */
 196   public void onPreCancel() {
 197 
 198   }
 199 
 200   @Override public void stop() {
 201     isStop = true;
 202     closeTimer();
 203     if (onPreStop()) {
 204       return;
 205     }
 206     mSubQueue.stopAllTask();
 207   }
 208 
 209   /**
 210    * onStop前的操作
 211    *
 212    * @return 返回{@code true}，直接回调{@link IDGroupListener#onStop(long)}
 213    */
 214   protected boolean onPreStop() {
 215 
 216     return false;
 217   }
 218 
 219   @Override
 220   public void start() {
 221     if (isStop || isCancel) {
 222       closeTimer();
 223       return;
 224     }
 225     if (onPreStart()) {
 226       startRunningFlow();
 227     }
 228   }
 229 
 230   /**
 231    * 处理启动前的检查：获取组合任务大小
 232    *
 233    * @return {@code false} 将不再走后续流程，任务介绍
 234    */
 235   protected boolean onPreStart() {
 236     return false;
 237   }
 238 
 239   synchronized void closeTimer() {
 240     if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {
 241       mTimer.shutdown();
 242     }
 243   }
 244 
 245   /**
 246    * 开始进度流程
 247    */
 248   private void startRunningFlow() {
 249     closeTimer();
 250     mListener.onPostPre(mGTWrapper.getEntity().getFileSize());
 251     if (mCurrentLocation &gt; 0) {
 252       mListener.onResume(mCurrentLocation);
 253     } else {
 254       mListener.onStart(mCurrentLocation);
 255     }
 256     startTimer();
 257   }
 258 
 259   private synchronized void startTimer() {
 260     mState.isRunning = true;
 261     mTimer = new ScheduledThreadPoolExecutor(1);
 262     mTimer.scheduleWithFixedDelay(new Runnable() {
 263       @Override public void run() {
 264         if (!mState.isRunning) {
 265           closeTimer();
 266         } else if (mCurrentLocation &gt;= 0) {
 267           long t = 0;
 268           for (DTaskWrapper te : mGTWrapper.getSubTaskWrapper()) {
 269             if (te.getState() == IEntity.STATE_COMPLETE) {
 270               t += te.getEntity().getFileSize();
 271             } else {
 272               t += te.getEntity().getCurrentProgress();
 273             }
 274           }
 275           mCurrentLocation = t;
 276           mState.updateProgress(mCurrentLocation);
 277           mListener.onProgress(t);
 278         }
 279       }
 280     }, 0, mUpdateInterval, TimeUnit.MILLISECONDS);
 281   }
 282 
 283   /**
 284    * 创建并启动子任务下载器
 285    */
 286   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper) {
 287     return createAndStartSubLoader(taskWrapper, true);
 288   }
 289 
 290   /**
 291    * 创建并启动子任务下载器
 292    *
 293    * @param needGetFileInfo {@code true} 需要获取文件信息。{@code false} 不需要获取文件信息
 294    */
 295   SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper, boolean needGetFileInfo) {
 296     SubDLoadUtil loader = new SubDLoadUtil(mScheduler, taskWrapper, needGetFileInfo);
 297     mExeLoader.put(loader.getKey(), loader);
 298     mSubQueue.startTask(loader);
 299     return loader;
 300   }
 301 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.download.group;
  17  
  18  import android.os.Handler;
  19  import android.os.Looper;
  20  import com.arialyy.aria.core.common.IUtil;
  21  import com.arialyy.aria.core.config.Configuration;
  22  import com.arialyy.aria.core.download.DGTaskWrapper;
  23  import com.arialyy.aria.core.download.DTaskWrapper;
  24  import com.arialyy.aria.core.inf.IEntity;
  25  import com.arialyy.aria.util.ALog;
  26  import java.util.Map;
  27  import java.util.WeakHashMap;
  28  import java.util.concurrent.ScheduledThreadPoolExecutor;
  29  import java.util.concurrent.TimeUnit;
  30  
  31  /**
  32   * Created by AriaL on 2017/6/30.
  33   * 任务组核心逻辑
  34   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -public abstract class AbsGroupUtil implements IUtil, Runnable {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +public abstract class AbsGroupUtil implements IUtil {</span>
  37    private final String TAG = &quot;AbsGroupUtil&quot;;
  38    /**
  39     * FTP文件夹
  40     */
  41    int FTP_DIR = 0xa1;
  42    /**
  43     * D_HTTP 任务组
  44     */
  45    int HTTP_GROUP = 0xa2;
  46  
  47    private long mCurrentLocation = 0;
  48    protected IDGroupListener mListener;
  49    private ScheduledThreadPoolExecutor mTimer;
  50    private long mUpdateInterval;
  51    private boolean isStop = false, isCancel = false;
  52    private Handler mScheduler;
  53    private SimpleSubQueue mSubQueue = SimpleSubQueue.newInstance();
  54    private Map&lt;String, SubDLoadUtil&gt; mExeLoader = new WeakHashMap&lt;&gt;();
  55    private Map&lt;String, DTaskWrapper&gt; mCache = new WeakHashMap&lt;&gt;();
  56    DGTaskWrapper mGTWrapper;
  57    GroupRunState mState;
  58  
  59    AbsGroupUtil(IDGroupListener listener, DGTaskWrapper groupWrapper) {
  60      mListener = listener;
  61      mGTWrapper = groupWrapper;
  62      mUpdateInterval = Configuration.getInstance().downloadCfg.getUpdateInterval();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  63 -    mState = new GroupRunState(groupWrapper.getKey(), mListener,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  64 -        groupWrapper.getSubTaskWrapper().size(), mSubQueue);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +   * 初始化组合任务状态</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +  void initState() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +    mState =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +        new GroupRunState(mGTWrapper.getKey(), mListener, mGTWrapper.getSubTaskWrapper().size(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +            mSubQueue);</span>
  74      mScheduler = new Handler(Looper.getMainLooper(), SimpleSchedulers.newInstance(mState));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -    initState();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -  /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -   * 初始化组合任务状态</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -   */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -  private void initState() {</span>
  82      for (DTaskWrapper wrapper : mGTWrapper.getSubTaskWrapper()) {
  83        if (wrapper.getEntity().getState() == IEntity.STATE_COMPLETE) {
  84          mState.updateCompleteNum();
  85          mCurrentLocation += wrapper.getEntity().getFileSize();
  86        } else {
  87          mCache.put(wrapper.getKey(), wrapper);
  88          mCurrentLocation += wrapper.getEntity().getCurrentProgress();
  89        }
  90      }
  91      mState.updateProgress(mCurrentLocation);
  92    }
  93  
  94    @Override public String getKey() {
  95      return mGTWrapper.getKey();
  96    }
  97  
  98    /**
  99     * 获取任务类型
 100     *
 101     * @return {@link #FTP_DIR}、{@link #HTTP_GROUP}
 102     */
 103    abstract int getTaskType();
 104  
 105    /**
 106     * 启动子任务下载
 107     *
 108     * @param url 子任务下载地址
 109     */
 110    public void startSubTask(String url) {
 111      if (!checkSubTask(url, &quot;开始&quot;)) return;
 112      if (!mState.isRunning) {
 113        startTimer();
 114      }
 115      SubDLoadUtil d = getDownloader(url);
 116      if (d != null &amp;&amp; !d.isRunning()) {
 117        mSubQueue.startTask(d);
 118      }
 119    }
 120  
 121    /**
 122     * 停止子任务下载
 123     *
 124     * @param url 子任务下载地址
 125     */
 126    public void stopSubTask(String url) {
 127      if (!checkSubTask(url, &quot;停止&quot;)) return;
 128      SubDLoadUtil d = getDownloader(url);
 129      if (d != null &amp;&amp; d.isRunning()) {
 130        mSubQueue.stopTask(d);
 131      }
 132    }
 133  
 134    /**
 135     * 检查子任务
 136     *
 137     * @param url 子任务url
 138     * @param type 任务类型
 139     * @return {@code true} 任务可以下载
 140     */
 141    private boolean checkSubTask(String url, String type) {
 142      DTaskWrapper wrapper = mCache.get(url);
 143      if (wrapper != null) {
 144        if (wrapper.getState() == IEntity.STATE_COMPLETE) {
 145          ALog.w(TAG, &quot;任务【&quot; + url + &quot;】已完成，&quot; + type + &quot;失败&quot;);
 146          return false;
 147        }
 148      } else {
 149        ALog.w(TAG, &quot;任务组中没有该任务【&quot; + url + &quot;】，&quot; + type + &quot;失败&quot;);
 150        return false;
 151      }
 152      return true;
 153    }
 154  
 155    /**
 156     * 通过地址获取下载器
 157     *
 158     * @param url 子任务下载地址
 159     */
 160    private SubDLoadUtil getDownloader(String url) {
 161      SubDLoadUtil d = mExeLoader.get(url);
 162      if (d == null) {
 163        return createAndStartSubLoader(mCache.get(url));
 164      }
 165      return d;
 166    }
 167  
 168    @Override public long getFileSize() {
 169      return mGTWrapper.getEntity().getFileSize();
 170    }
 171  
 172    @Override public long getCurrentLocation() {
 173      return mCurrentLocation;
 174    }
 175  
 176    @Override public boolean isRunning() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 177 -    return mState.isRunning;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +    return mState != null &amp;&amp; mState.isRunning;</span>
 179    }
 180  
 181    @Override public void cancel() {
 182      isCancel = true;
 183      closeTimer();
 184      onPreCancel();
 185  
 186      mSubQueue.removeAllTask();
 187      mListener.onCancel();
 188    }
 189  
 190    /**
 191     * onCancel前的操作
 192     */
 193    public void onPreCancel() {
 194  
 195    }
 196  
 197    @Override public void stop() {
 198      isStop = true;
 199      closeTimer();
 200      if (onPreStop()) {
 201        return;
 202      }
 203      mSubQueue.stopAllTask();
 204    }
 205  
 206    /**
 207     * onStop前的操作
 208     *
 209     * @return 返回{@code true}，直接回调{@link IDGroupListener#onStop(long)}
 210     */
 211    protected boolean onPreStop() {
 212  
 213      return false;
 214    }
 215  
 216    @Override public void start() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -    new Thread(this).start();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -  @Override public void run() {</span>
 221      if (isStop || isCancel) {
 222        closeTimer();
 223        return;
 224      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 225 -    onStart();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +    onPreStart();</span>
 227      startRunningFlow();
 228    }
 229  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -  protected void onStart() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +  protected void onPreStart() {</span>
 232  













 233    }
 234  
 235    synchronized void closeTimer() {
 236      if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {
 237        mTimer.shutdown();
 238      }
 239    }
 240  
 241    /**
 242     * 开始进度流程
 243     */
 244    private void startRunningFlow() {
 245      closeTimer();
 246      mListener.onPostPre(mGTWrapper.getEntity().getFileSize());
 247      if (mCurrentLocation &gt; 0) {
 248        mListener.onResume(mCurrentLocation);
 249      } else {
 250        mListener.onStart(mCurrentLocation);
 251      }
 252      startTimer();
 253    }
 254  
 255    private synchronized void startTimer() {
 256      mState.isRunning = true;
 257      mTimer = new ScheduledThreadPoolExecutor(1);
 258      mTimer.scheduleWithFixedDelay(new Runnable() {
 259        @Override public void run() {
 260          if (!mState.isRunning) {
 261            closeTimer();
 262          } else if (mCurrentLocation &gt;= 0) {
 263            long t = 0;
 264            for (DTaskWrapper te : mGTWrapper.getSubTaskWrapper()) {
 265              if (te.getState() == IEntity.STATE_COMPLETE) {
 266                t += te.getEntity().getFileSize();
 267              } else {
 268                t += te.getEntity().getCurrentProgress();
 269              }
 270            }
 271            mCurrentLocation = t;
 272            mState.updateProgress(mCurrentLocation);
 273            mListener.onProgress(t);
 274          }
 275        }
 276      }, 0, mUpdateInterval, TimeUnit.MILLISECONDS);
 277    }
 278  
 279    /**
 280     * 创建并启动子任务下载器
 281     */
 282    SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper) {
 283      return createAndStartSubLoader(taskWrapper, true);
 284    }
 285  
 286    /**
 287     * 创建并启动子任务下载器
 288     *
 289     * @param needGetFileInfo {@code true} 需要获取文件信息。{@code false} 不需要获取文件信息
 290     */
 291    SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper, boolean needGetFileInfo) {
 292      SubDLoadUtil loader = new SubDLoadUtil(mScheduler, taskWrapper, needGetFileInfo);
 293      mExeLoader.put(loader.getKey(), loader);
 294      mSubQueue.startTask(loader);
 295      return loader;
 296    }
 297  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2016 AriaLyy(https://github.com/AriaLyy/Aria)
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.arialyy.aria.core.download.group;
  17  
  18  import android.os.Handler;
  19  import android.os.Looper;
  20  import com.arialyy.aria.core.common.IUtil;
  21  import com.arialyy.aria.core.config.Configuration;
  22  import com.arialyy.aria.core.download.DGTaskWrapper;
  23  import com.arialyy.aria.core.download.DTaskWrapper;
  24  import com.arialyy.aria.core.inf.IEntity;
  25  import com.arialyy.aria.util.ALog;
  26  import java.util.Map;
  27  import java.util.WeakHashMap;
  28  import java.util.concurrent.ScheduledThreadPoolExecutor;
  29  import java.util.concurrent.TimeUnit;
  30  
  31  /**
  32   * Created by AriaL on 2017/6/30.
  33   * 任务组核心逻辑
  34   */
  35  public abstract class AbsGroupUtil implements IUtil, Runnable {

  36    private final String TAG = &quot;AbsGroupUtil&quot;;
  37    /**
  38     * FTP文件夹
  39     */
  40    int FTP_DIR = 0xa1;
  41    /**
  42     * D_HTTP 任务组
  43     */
  44    int HTTP_GROUP = 0xa2;
  45  
  46    private long mCurrentLocation = 0;
  47    protected IDGroupListener mListener;
  48    private ScheduledThreadPoolExecutor mTimer;
  49    private long mUpdateInterval;
  50    private boolean isStop = false, isCancel = false;
  51    private Handler mScheduler;
  52    private SimpleSubQueue mSubQueue = SimpleSubQueue.newInstance();
  53    private Map&lt;String, SubDLoadUtil&gt; mExeLoader = new WeakHashMap&lt;&gt;();
  54    private Map&lt;String, DTaskWrapper&gt; mCache = new WeakHashMap&lt;&gt;();
  55    DGTaskWrapper mGTWrapper;
  56    GroupRunState mState;
  57  
  58    AbsGroupUtil(IDGroupListener listener, DGTaskWrapper groupWrapper) {
  59      mListener = listener;
  60      mGTWrapper = groupWrapper;
  61      mUpdateInterval = Configuration.getInstance().downloadCfg.getUpdateInterval();
  62      mState = new GroupRunState(groupWrapper.getKey(), mListener,
  63          groupWrapper.getSubTaskWrapper().size(), mSubQueue);









  64      mScheduler = new Handler(Looper.getMainLooper(), SimpleSchedulers.newInstance(mState));
  65      initState();
  66    }
  67  
  68    /**
  69     * 初始化组合任务状态
  70     */
  71    private void initState() {
  72      for (DTaskWrapper wrapper : mGTWrapper.getSubTaskWrapper()) {
  73        if (wrapper.getEntity().getState() == IEntity.STATE_COMPLETE) {
  74          mState.updateCompleteNum();
  75          mCurrentLocation += wrapper.getEntity().getFileSize();
  76        } else {
  77          mCache.put(wrapper.getKey(), wrapper);
  78          mCurrentLocation += wrapper.getEntity().getCurrentProgress();
  79        }
  80      }
  81      mState.updateProgress(mCurrentLocation);
  82    }
  83  
  84    @Override public String getKey() {
  85      return mGTWrapper.getKey();
  86    }
  87  
  88    /**
  89     * 获取任务类型
  90     *
  91     * @return {@link #FTP_DIR}、{@link #HTTP_GROUP}
  92     */
  93    abstract int getTaskType();
  94  
  95    /**
  96     * 启动子任务下载
  97     *
  98     * @param url 子任务下载地址
  99     */
 100    public void startSubTask(String url) {
 101      if (!checkSubTask(url, &quot;开始&quot;)) return;
 102      if (!mState.isRunning) {
 103        startTimer();
 104      }
 105      SubDLoadUtil d = getDownloader(url);
 106      if (d != null &amp;&amp; !d.isRunning()) {
 107        mSubQueue.startTask(d);
 108      }
 109    }
 110  
 111    /**
 112     * 停止子任务下载
 113     *
 114     * @param url 子任务下载地址
 115     */
 116    public void stopSubTask(String url) {
 117      if (!checkSubTask(url, &quot;停止&quot;)) return;
 118      SubDLoadUtil d = getDownloader(url);
 119      if (d != null &amp;&amp; d.isRunning()) {
 120        mSubQueue.stopTask(d);
 121      }
 122    }
 123  
 124    /**
 125     * 检查子任务
 126     *
 127     * @param url 子任务url
 128     * @param type 任务类型
 129     * @return {@code true} 任务可以下载
 130     */
 131    private boolean checkSubTask(String url, String type) {
 132      DTaskWrapper wrapper = mCache.get(url);
 133      if (wrapper != null) {
 134        if (wrapper.getState() == IEntity.STATE_COMPLETE) {
 135          ALog.w(TAG, &quot;任务【&quot; + url + &quot;】已完成，&quot; + type + &quot;失败&quot;);
 136          return false;
 137        }
 138      } else {
 139        ALog.w(TAG, &quot;任务组中没有该任务【&quot; + url + &quot;】，&quot; + type + &quot;失败&quot;);
 140        return false;
 141      }
 142      return true;
 143    }
 144  
 145    /**
 146     * 通过地址获取下载器
 147     *
 148     * @param url 子任务下载地址
 149     */
 150    private SubDLoadUtil getDownloader(String url) {
 151      SubDLoadUtil d = mExeLoader.get(url);
 152      if (d == null) {
 153        return createAndStartSubLoader(mCache.get(url));
 154      }
 155      return d;
 156    }
 157  
 158    @Override public long getFileSize() {
 159      return mGTWrapper.getEntity().getFileSize();
 160    }
 161  
 162    @Override public long getCurrentLocation() {
 163      return mCurrentLocation;
 164    }
 165  
 166    @Override public boolean isRunning() {
 167      return mState.isRunning;

 168    }
 169  
 170    @Override public void cancel() {
 171      isCancel = true;
 172      closeTimer();
 173      onPreCancel();
 174  
 175      mSubQueue.removeAllTask();
 176      mListener.onCancel();
 177    }
 178  
 179    /**
 180     * onCancel前的操作
 181     */
 182    public void onPreCancel() {
 183  
 184    }
 185  
 186    @Override public void stop() {
 187      isStop = true;
 188      closeTimer();
 189      if (onPreStop()) {
 190        return;
 191      }
 192      mSubQueue.stopAllTask();
 193    }
 194  
 195    /**
 196     * onStop前的操作
 197     *
 198     * @return 返回{@code true}，直接回调{@link IDGroupListener#onStop(long)}
 199     */
 200    protected boolean onPreStop() {
 201  
 202      return false;
 203    }
 204  
 205    @Override public void start() {
 206      new Thread(this).start();
 207    }
 208  
 209    @Override public void run() {
 210      if (isStop || isCancel) {
 211        closeTimer();
 212        return;
 213      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -    onStart();</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -    startRunningFlow();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 216 -  }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 217 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -  protected void onStart() {</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +    if (onStart()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +      startRunningFlow();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +   * 处理启动前的检查：获取组合任务大小</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +   * @return {@code false} 将不再走后续流程，任务介绍</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +  protected boolean onStart() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +    return false;</span>
 233    }
 234  
 235    synchronized void closeTimer() {
 236      if (mTimer != null &amp;&amp; !mTimer.isShutdown()) {
 237        mTimer.shutdown();
 238      }
 239    }
 240  
 241    /**
 242     * 开始进度流程
 243     */
 244    private void startRunningFlow() {
 245      closeTimer();
 246      mListener.onPostPre(mGTWrapper.getEntity().getFileSize());
 247      if (mCurrentLocation &gt; 0) {
 248        mListener.onResume(mCurrentLocation);
 249      } else {
 250        mListener.onStart(mCurrentLocation);
 251      }
 252      startTimer();
 253    }
 254  
 255    private synchronized void startTimer() {
 256      mState.isRunning = true;
 257      mTimer = new ScheduledThreadPoolExecutor(1);
 258      mTimer.scheduleWithFixedDelay(new Runnable() {
 259        @Override public void run() {
 260          if (!mState.isRunning) {
 261            closeTimer();
 262          } else if (mCurrentLocation &gt;= 0) {
 263            long t = 0;
 264            for (DTaskWrapper te : mGTWrapper.getSubTaskWrapper()) {
 265              if (te.getState() == IEntity.STATE_COMPLETE) {
 266                t += te.getEntity().getFileSize();
 267              } else {
 268                t += te.getEntity().getCurrentProgress();
 269              }
 270            }
 271            mCurrentLocation = t;
 272            mState.updateProgress(mCurrentLocation);
 273            mListener.onProgress(t);
 274          }
 275        }
 276      }, 0, mUpdateInterval, TimeUnit.MILLISECONDS);
 277    }
 278  
 279    /**
 280     * 创建并启动子任务下载器
 281     */
 282    SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper) {
 283      return createAndStartSubLoader(taskWrapper, true);
 284    }
 285  
 286    /**
 287     * 创建并启动子任务下载器
 288     *
 289     * @param needGetFileInfo {@code true} 需要获取文件信息。{@code false} 不需要获取文件信息
 290     */
 291    SubDLoadUtil createAndStartSubLoader(DTaskWrapper taskWrapper, boolean needGetFileInfo) {
 292      SubDLoadUtil loader = new SubDLoadUtil(mScheduler, taskWrapper, needGetFileInfo);
 293      mExeLoader.put(loader.getKey(), loader);
 294      mSubQueue.startTask(loader);
 295      return loader;
 296    }
 297  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            