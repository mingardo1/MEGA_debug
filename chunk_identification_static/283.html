<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>283</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    283
                    <a href="282.html">prev</a>
                    <a href="284.html">next</a>
                    <a href="283_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_d8a2b0a1df51c97c8057f7ac31193483bf157965_core/src/main/java/com/dtstack/flink/sql/table/AbstractTableInfo.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d8a2b0a1df51c97c8057f7ac31193483bf157965:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableInfo.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d8a2b0a1df51c97c8057f7ac31193483bf157965^1:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableInfo.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;d8a2b0a1df51c97c8057f7ac31193483bf157965^2:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableInfo.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f4aebe772f34c17807c0a576f083f2dd41aaa0c6:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableInfo.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.table;
  20 
  21 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22 import com.dtstack.flink.sql.dirtyManager.manager.DirtyKeys;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  23 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;</span>
  24 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  25 import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  26 import com.google.common.collect.Maps;</span>
  27 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  28 import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
  29 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 
  33 import java.io.Serializable;
  34 import java.util.List;
  35 import java.util.Map;
  36 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  37 import java.util.Properties;</span>
  38 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  39 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  40  * Reason:</span>
  41 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42 import java.util.Objects;</span>
  43 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  44 
  45 /**
  46  * Reason:
  47  * Date: 2018/6/22
  48  * Company: www.dtstack.com
  49  *
  50  * @author xuchao
  51  */
  52 
  53 public abstract class AbstractTableInfo implements Serializable {
  54 
  55     public static final String PARALLELISM_KEY = &quot;parallelism&quot;;
  56     public static final String ERROR_LIMIT = &quot;errorLimit&quot;;
  57     private final List&lt;String&gt; fieldList = Lists.newArrayList();
  58     private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();
  59     private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();
  60     private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();
  61     private String name;
  62     private String type;
  63     private String[] fields;
  64     private String[] fieldTypes;
  65     private Class&lt;?&gt;[] fieldClasses;
  66     /**
  67      * key:别名, value: realField
  68      */
  69     private Map&lt;String, String&gt; physicalFields = Maps.newLinkedHashMap();
  70     private List&lt;String&gt; primaryKeys;
  71 
  72     private Integer parallelism = -1;
  73     private Map&lt;String, String&gt; checkProperties;
  74 
  75     /**
  76      * 构建脏数据插件的相关信息
  77      */
  78     private Map&lt;String, Object&gt; dirtyProperties;
  79 
  80     /**
  81      * error data limit. Task will failed once {@link AbstractDtRichOutputFormat#outDirtyRecords}
  82      * count over limit. Default 1000L;
  83      */
  84     private Long errorLimit = 0L;
  85 
  86     public String[] getFieldTypes() {
  87         return fieldTypes;
  88     }
  89 
  90     public void setFieldTypes(String[] fieldTypes) {
  91         this.fieldTypes = fieldTypes;
  92     }
  93 
  94     public abstract boolean check();
  95 
  96     public String getType() {
  97         return type;
  98     }
  99 
 100     public void setType(String type) {
 101         this.type = type;
 102     }
 103 
 104     public String[] getFields() {
 105         return fields;
 106     }
 107 
 108     public void setFields(String[] fields) {
 109         this.fields = fields;
 110     }
 111 
 112     public Class&lt;?&gt;[] getFieldClasses() {
 113         return fieldClasses;
 114     }
 115 
 116     public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {
 117         this.fieldClasses = fieldClasses;
 118     }
 119 
 120     public List&lt;String&gt; getPrimaryKeys() {
 121         if (this instanceof AbstractSideTableInfo &amp;&amp;
 122             Objects.isNull(primaryKeys)) {
 123             throw new IllegalArgumentException(&quot;Side table must contain [primary key]!&quot;);
 124         }
 125         return primaryKeys;
 126     }
 127 
 128     public void setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 129         this.primaryKeys = primaryKeys;
 130     }
 131 
 132     public String getName() {
 133         return name;
 134     }
 135 
 136     public void setName(String name) {
 137         this.name = name;
 138     }
 139 
 140     public Integer getParallelism() {
 141         return parallelism;
 142     }
 143 
 144     public void setParallelism(Integer parallelism) {
 145         if (parallelism == null) {
 146             return;
 147         }
 148 
 149         if (parallelism &lt;= 0) {
 150             throw new RuntimeException(&quot;Abnormal parameter settings: parallelism &gt; 0&quot;);
 151         }
 152 
 153         this.parallelism = parallelism;
 154     }
 155 
 156     public void addField(String fieldName) {
 157         if (fieldList.contains(fieldName)) {
 158             throw new RuntimeException(&quot;redundancy field name &quot; + fieldName + &quot; in table &quot; + getName());
 159         }
 160 
 161         fieldList.add(fieldName);
 162     }
 163 
 164     public void addPhysicalMappings(String aliasName, String physicalFieldName) {
 165         physicalFields.put(aliasName, physicalFieldName);
 166     }
 167 
 168     public void addFieldClass(Class fieldClass) {
 169         fieldClassList.add(fieldClass);
 170     }
 171 
 172     public void addFieldType(String fieldType) {
 173         fieldTypeList.add(fieldType);
 174     }
 175 
 176     public void addFieldExtraInfo(FieldExtraInfo extraInfo) {
 177         fieldExtraInfoList.add(extraInfo);
 178     }
 179 
 180     public List&lt;String&gt; getFieldList() {
 181         return fieldList;
 182     }
 183 
 184     public List&lt;String&gt; getFieldTypeList() {
 185         return fieldTypeList;
 186     }
 187 
 188     public List&lt;Class&gt; getFieldClassList() {
 189         return fieldClassList;
 190     }
 191 
 192     public Map&lt;String, String&gt; getPhysicalFields() {
 193         return physicalFields;
 194     }
 195 
 196     public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {
 197         this.physicalFields = physicalFields;
 198     }
 199 
 200     public List&lt;FieldExtraInfo&gt; getFieldExtraInfoList() {
 201         return fieldExtraInfoList;
 202     }
 203 
 204     public Map&lt;String, String&gt; getCheckProperties() {
 205         return checkProperties;
 206     }
 207 
 208     public void setCheckProperties() {
 209         this.checkProperties = buildCheckProperties();
 210     }
 211 
 212     public Map&lt;String, String&gt; buildCheckProperties() {
 213         return Maps.newHashMap();
 214     }
 215 
 216     public Map&lt;String, Object&gt; getDirtyProperties() {
 217         dirtyProperties.put(DirtyKeys.TABLE_NAME, this.name);
 218         return dirtyProperties;
 219     }
 220 
 221     public void setDirtyProperties(Map&lt;String, Object&gt; dirtyProperties) {
 222         this.dirtyProperties = dirtyProperties;
 223     }
 224 
 225     public Long getErrorLimit() {
 226         return errorLimit;
 227     }
 228 
 229     public void setErrorLimit(Long errorLimit) {
 230         this.errorLimit = errorLimit;
 231     }
 232 
 233     public void finish() {
 234         this.fields = fieldList.toArray(new String[0]);
 235         this.fieldClasses = fieldClassList.toArray(new Class[0]);
 236         this.fieldTypes = fieldTypeList.toArray(new String[0]);
 237     }
 238 
 239     /**
 240      * field extra info，used to store `not null` `default 0`...，
 241      * &lt;p&gt;
 242      * now, only support not null
 243      */
 244     public static class FieldExtraInfo implements Serializable {
 245 
 246         /**
 247          * default false：allow field is null
 248          */
 249         boolean notNull = false;
 250         /**
 251          * field length,eg.char(4)
 252          */
 253         int length;
 254 
 255         public int getLength() {
 256             return length;
 257         }
 258 
 259         public void setLength(int length) {
 260             this.length = length;
 261         }
 262 
 263         public boolean getNotNull() {
 264             return notNull;
 265         }
 266 
 267         public void setNotNull(boolean notNull) {
 268             this.notNull = notNull;
 269         }
 270 
 271         @Override
 272         public String toString() {
 273             return &quot;FieldExtraInfo{&quot; +
 274                     &quot;notNull=&quot; + notNull +
 275                     &quot;, length=&quot; + length +
 276                     &#x27;}&#x27;;
 277         }
 278     }
 279 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.table;
  20 
  21 import com.dtstack.flink.sql.dirtyManager.manager.DirtyKeys;
  22 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  23 
  24 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  25 import com.google.common.collect.Lists;
  26 import com.google.common.collect.Maps;
  27 
  28 import java.io.Serializable;
  29 import java.util.List;
  30 import java.util.Map;
  31 import java.util.Properties;
  32 import java.util.Objects;
  33 
  34 /**
  35  * Reason:
  36  * Date: 2018/6/22
  37  * Company: www.dtstack.com
  38  *
  39  * @author xuchao
  40  */
  41 
  42 public abstract class AbstractTableInfo implements Serializable {
  43 
  44     public static final String PARALLELISM_KEY = &quot;parallelism&quot;;
  45     public static final String ERROR_LIMIT = &quot;errorLimit&quot;;
  46     private String name;
  47     private String type;
  48     private String[] fields;
  49     private String[] fieldTypes;
  50     private Class&lt;?&gt;[] fieldClasses;
  51     private final List&lt;String&gt; fieldList = Lists.newArrayList();
  52     /**
  53      * key:别名, value: realField
  54      */
  55     private Map&lt;String, String&gt; physicalFields = Maps.newLinkedHashMap();
  56     private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();
  57     private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();
  58     private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();
  59     private List&lt;String&gt; primaryKeys;
  60 
  61     private Integer parallelism = -1;
  62     private Map&lt;String, String&gt; checkProperties;
  63 
  64     /**
  65      * 构建脏数据插件的相关信息
  66      */
  67     private Map&lt;String, Object&gt; dirtyProperties;
  68 
  69     /**
  70      * error data limit. Task will failed once {@link AbstractDtRichOutputFormat#outDirtyRecords}
  71      * count over limit. Default 1000L;
  72      */
  73     private Long errorLimit = 0L;
  74 
  75     public String[] getFieldTypes() {
  76         return fieldTypes;
  77     }
  78 
  79     public abstract boolean check();
  80 
  81     public String getType() {
  82         return type;
  83     }
  84 
  85     public void setType(String type) {
  86         this.type = type;
  87     }
  88 
  89     public String[] getFields() {
  90         return fields;
  91     }
  92 
  93     public Class&lt;?&gt;[] getFieldClasses() {
  94         return fieldClasses;
  95     }
  96 
  97     public List&lt;String&gt; getPrimaryKeys() {
  98         if (this instanceof AbstractSideTableInfo &amp;&amp;
  99             Objects.isNull(primaryKeys)) {
 100             throw new IllegalArgumentException(&quot;Side table must contain [primary key]!&quot;);
 101         }
 102         return primaryKeys;
 103     }
 104 
 105     public void setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 106         this.primaryKeys = primaryKeys;
 107     }
 108 
 109     public String getName() {
 110         return name;
 111     }
 112 
 113     public void setName(String name) {
 114         this.name = name;
 115     }
 116 
 117     public Integer getParallelism() {
 118         return parallelism;
 119     }
 120 
 121     public void setParallelism(Integer parallelism) {
 122         if(parallelism == null){
 123             return;
 124         }
 125 
 126         if(parallelism &lt;= 0){
 127             throw new RuntimeException(&quot;Abnormal parameter settings: parallelism &gt; 0&quot;);
 128         }
 129 
 130         this.parallelism = parallelism;
 131     }
 132 
 133     public void addField(String fieldName){
 134         if (fieldList.contains(fieldName)) {
 135             throw new RuntimeException(&quot;redundancy field name &quot; + fieldName + &quot; in table &quot; + getName());
 136         }
 137 
 138         fieldList.add(fieldName);
 139     }
 140 
 141     public void addPhysicalMappings(String aliasName, String physicalFieldName){
 142         physicalFields.put(aliasName, physicalFieldName);
 143     }
 144 
 145     public void addFieldClass(Class fieldClass){
 146         fieldClassList.add(fieldClass);
 147     }
 148 
 149     public void addFieldType(String fieldType){
 150         fieldTypeList.add(fieldType);
 151     }
 152 
 153     public void setFields(String[] fields) {
 154         this.fields = fields;
 155     }
 156 
 157     public void setFieldTypes(String[] fieldTypes) {
 158         this.fieldTypes = fieldTypes;
 159     }
 160 
 161     public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {
 162         this.fieldClasses = fieldClasses;
 163     }
 164 
 165     public void addFieldExtraInfo(FieldExtraInfo extraInfo) {
 166         fieldExtraInfoList.add(extraInfo);
 167     }
 168 
 169     public List&lt;String&gt; getFieldList() {
 170         return fieldList;
 171     }
 172 
 173     public List&lt;String&gt; getFieldTypeList() {
 174         return fieldTypeList;
 175     }
 176 
 177     public List&lt;Class&gt; getFieldClassList() {
 178         return fieldClassList;
 179     }
 180 
 181     public Map&lt;String, String&gt; getPhysicalFields() {
 182         return physicalFields;
 183     }
 184 
 185     public List&lt;FieldExtraInfo&gt; getFieldExtraInfoList() {
 186         return fieldExtraInfoList;
 187     }
 188 
 189     public Map&lt;String, String&gt; getCheckProperties() {
 190         return checkProperties;
 191     }
 192 
 193     public void setCheckProperties() {
 194         this.checkProperties = buildCheckProperties();
 195     }
 196 
 197     public Map&lt;String, String&gt; buildCheckProperties() {
 198         return Maps.newHashMap();
 199     }
 200 
 201     public Map&lt;String, Object&gt; getDirtyProperties() {
 202         dirtyProperties.put(DirtyKeys.TABLE_NAME, this.name);
 203         return dirtyProperties;
 204     }
 205 
 206     public void setDirtyProperties(Map&lt;String, Object&gt; dirtyProperties) {
 207         this.dirtyProperties = dirtyProperties;
 208     }
 209 
 210     public Long getErrorLimit() {
 211         return errorLimit;
 212     }
 213 
 214     public void setErrorLimit(Long errorLimit) {
 215         this.errorLimit = errorLimit;
 216     }
 217 
 218     public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {
 219         this.physicalFields = physicalFields;
 220     }
 221 
 222     public void finish(){
 223         this.fields = fieldList.toArray(new String[0]);
 224         this.fieldClasses = fieldClassList.toArray(new Class[0]);
 225         this.fieldTypes = fieldTypeList.toArray(new String[0]);
 226     }
 227 
 228     /**
 229      * field extra info，used to store `not null` `default 0`...，
 230      * &lt;p&gt;
 231      * now, only support not null
 232      */
 233     public static class FieldExtraInfo implements Serializable {
 234 
 235         /**
 236          * default false：allow field is null
 237          */
 238         boolean notNull = false;
 239         /**
 240          * field length,eg.char(4)
 241          */
 242         int length;
 243 
 244         public int getLength() {
 245             return length;
 246         }
 247 
 248         public void setLength(int length) {
 249             this.length = length;
 250         }
 251 
 252         public boolean getNotNull() {
 253             return notNull;
 254         }
 255 
 256         public void setNotNull(boolean notNull) {
 257             this.notNull = notNull;
 258         }
 259 
 260         @Override
 261         public String toString() {
 262             return &quot;FieldExtraInfo{&quot; +
 263                     &quot;notNull=&quot; + notNull +
 264                     &quot;, length=&quot; + length +
 265                     &#x27;}&#x27;;
 266         }
 267     }
 268 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.table;
  19 
  20 import com.dtstack.flink.sql.dirtyManager.manager.DirtyKeys;
  21 import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;
  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  23 import com.google.common.collect.Lists;
  24 import com.google.common.collect.Maps;
  25 import java.io.Serializable;
  26 import java.util.List;
  27 import java.util.Map;
  28 import java.util.Objects;
  29 import java.util.Properties;
  30 
  31 
  32 /**
  33  * Reason:
  34  * Date: 2018/6/22
  35  * Company: www.dtstack.com
  36  * @author xuchao
  37  */
  38 public abstract class AbstractTableInfo implements Serializable {
  39     public static final String PARALLELISM_KEY = &quot;parallelism&quot;;
  40 
  41     public static final String ERROR_LIMIT = &quot;errorLimit&quot;;
  42 
  43     private final List&lt;String&gt; fieldList = Lists.newArrayList();
  44 
  45     private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();
  46 
  47     private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();
  48 
  49     private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();
  50 
  51     private String name;
  52 
  53     private String type;
  54 
  55     private String[] fields;
  56 
  57     private String[] fieldTypes;
  58 
  59     private Class&lt;?&gt;[] fieldClasses;
  60 
  61     /**
  62      * key:别名, value: realField
  63      */
  64     private Map&lt;String, String&gt; physicalFields = Maps.newLinkedHashMap();
  65 
  66     private List&lt;String&gt; primaryKeys;
  67 
  68     private Integer parallelism = -1;
  69 
  70     private Map&lt;String, String&gt; checkProperties;
  71 
  72     /**
  73      * 构建脏数据插件的相关信息
  74      */
  75     private Map&lt;String, Object&gt; dirtyProperties;
  76 
  77     /**
  78      * error data limit. Task will failed once {@link AbstractDtRichOutputFormat#outDirtyRecords}
  79      * count over limit. Default 1000L;
  80      */
  81     private Long errorLimit = 0L;
  82 
  83     public String[] getFieldTypes() {
  84         return fieldTypes;
  85     }
  86 
  87     public void setFieldTypes(String[] fieldTypes) {
  88         this.fieldTypes = fieldTypes;
  89     }
  90 
  91     public abstract boolean check();
  92 
  93     public String getType() {
  94         return type;
  95     }
  96 
  97     public void setType(String type) {
  98         this.type = type;
  99     }
 100 
 101     public String[] getFields() {
 102         return fields;
 103     }
 104 
 105     public void setFields(String[] fields) {
 106         this.fields = fields;
 107     }
 108 
 109     public Class&lt;?&gt;[] getFieldClasses() {
 110         return fieldClasses;
 111     }
 112 
 113     public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {
 114         this.fieldClasses = fieldClasses;
 115     }
 116 
 117     public List&lt;String&gt; getPrimaryKeys() {
 118         if ((this instanceof AbstractSideTableInfo) &amp;&amp; Objects.isNull(primaryKeys)) {
 119             throw new IllegalArgumentException(&quot;Side table must contain [primary key]!&quot;);
 120         }
 121         return primaryKeys;
 122     }
 123 
 124     public void setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 125         this.primaryKeys = primaryKeys;
 126     }
 127 
 128     public String getName() {
 129         return name;
 130     }
 131 
 132     public void setName(String name) {
 133         this.name = name;
 134     }
 135 
 136     public Integer getParallelism() {
 137         return parallelism;
 138     }
 139 
 140     public void setParallelism(Integer parallelism) {
 141         if(parallelism == null){
 142             return;
 143         }
 144 
 145         if(parallelism &lt;= 0){
 146             throw new RuntimeException(&quot;Abnormal parameter settings: parallelism &gt; 0&quot;);
 147         }
 148 
 149         this.parallelism = parallelism;
 150     }
 151 
 152     public void addField(String fieldName){
 153         if (fieldList.contains(fieldName)) {
 154             throw new RuntimeException(&quot;redundancy field name &quot; + fieldName + &quot; in table &quot; + getName());
 155         }
 156 
 157         fieldList.add(fieldName);
 158     }
 159 
 160     public void addPhysicalMappings(String aliasName, String physicalFieldName){
 161         physicalFields.put(aliasName, physicalFieldName);
 162     }
 163 
 164     public void addFieldClass(Class fieldClass){
 165         fieldClassList.add(fieldClass);
 166     }
 167 
 168     public void addFieldType(String fieldType){
 169         fieldTypeList.add(fieldType);
 170     }
 171 
 172     public void addFieldExtraInfo(FieldExtraInfo extraInfo) {
 173         fieldExtraInfoList.add(extraInfo);
 174     }
 175 
 176     public List&lt;String&gt; getFieldList() {
 177         return fieldList;
 178     }
 179 
 180     public List&lt;String&gt; getFieldTypeList() {
 181         return fieldTypeList;
 182     }
 183 
 184     public List&lt;Class&gt; getFieldClassList() {
 185         return fieldClassList;
 186     }
 187 
 188     public Map&lt;String, String&gt; getPhysicalFields() {
 189         return physicalFields;
 190     }
 191 
 192     public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {
 193         this.physicalFields = physicalFields;
 194     }
 195 
 196     public List&lt;FieldExtraInfo&gt; getFieldExtraInfoList() {
 197         return fieldExtraInfoList;
 198     }
 199 
 200     public Map&lt;String, String&gt; getCheckProperties() {
 201         return checkProperties;
 202     }
 203 
 204     public void setCheckProperties() {
 205         this.checkProperties = buildCheckProperties();
 206     }
 207 
 208     public Map&lt;String, String&gt; buildCheckProperties() {
 209         return Maps.newHashMap();
 210     }
 211 
 212     public Map&lt;String, Object&gt; getDirtyProperties() {
 213         dirtyProperties.put(DirtyKeys.TABLE_NAME, this.name);
 214         return dirtyProperties;
 215     }
 216 
 217     public void setDirtyProperties(Map&lt;String, Object&gt; dirtyProperties) {
 218         this.dirtyProperties = dirtyProperties;
 219     }
 220 
 221     public Long getErrorLimit() {
 222         return errorLimit;
 223     }
 224 
 225     public void setErrorLimit(Long errorLimit) {
 226         this.errorLimit = errorLimit;
 227     }
 228 
 229     public void finish(){
 230         this.fields = fieldList.toArray(new String[0]);
 231         this.fieldClasses = fieldClassList.toArray(new Class[0]);
 232         this.fieldTypes = fieldTypeList.toArray(new String[0]);
 233     }
 234 
 235     /**
 236      * field extra info，used to store `not null` `default 0`...，
 237      * &lt;p&gt;
 238      * now, only support not null
 239      */
 240     public static class FieldExtraInfo implements Serializable {
 241         /**
 242          * default false：allow field is null
 243          */
 244         boolean notNull = false;
 245 
 246         /**
 247          * field length,eg.char(4)
 248          */
 249         int length;
 250 
 251         public int getLength() {
 252             return length;
 253         }
 254 
 255         public void setLength(int length) {
 256             this.length = length;
 257         }
 258 
 259         public boolean getNotNull() {
 260             return notNull;
 261         }
 262 
 263         public void setNotNull(boolean notNull) {
 264             this.notNull = notNull;
 265         }
 266 
 267         @Override
 268         public String toString() {
 269             return &quot;FieldExtraInfo{&quot; +
 270                     &quot;notNull=&quot; + notNull +
 271                     &quot;, length=&quot; + length +
 272                     &#x27;}&#x27;;
 273         }
 274     }
 275 }
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.table;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.dirtyManager.manager.DirtyKeys;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import com.dtstack.flink.sql.outputformat.AbstractDtRichOutputFormat;</span>
  23  import com.google.common.collect.Lists;
  24  import com.google.common.collect.Maps;
  25  
  26  import java.io.Serializable;
  27  import java.util.List;
  28  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import java.util.Properties;</span>
  30  
  31  /**
  32   * Reason:
  33   * Date: 2018/6/22
  34   * Company: www.dtstack.com
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 + *</span>
  36   * @author xuchao
  37   */
  38  
  39  public abstract class AbstractTableInfo implements Serializable {
  40  
  41      public static final String PARALLELISM_KEY = &quot;parallelism&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +    public static final String ERROR_LIMIT = &quot;errorLimit&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +    private final List&lt;String&gt; fieldList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +    private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +    private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +    private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();</span>
  48      private String name;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  49 -</span>
  50      private String type;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  51 -</span>
  52      private String[] fields;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  53 -</span>
  54      private String[] fieldTypes;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -</span>
  56      private Class&lt;?&gt;[] fieldClasses;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -    private final List&lt;String&gt; fieldList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -    /**key:别名, value: realField */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +     * key:别名, value: realField</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +     */</span>
  64      private Map&lt;String, String&gt; physicalFields = Maps.newLinkedHashMap();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  65 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  66 -    private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  67 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -    private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -    private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -</span>
  72      private List&lt;String&gt; primaryKeys;
  73  
  74      private Integer parallelism = -1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +    private Map&lt;String, String&gt; checkProperties;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +     * 构建脏数据插件的相关信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +    private Map&lt;String, Object&gt; dirtyProperties;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +     * error data limit. Task will failed once {@link AbstractDtRichOutputFormat#outDirtyRecords}</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +     * count over limit. Default 1000L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +    private Long errorLimit = 0L;</span>
  87  
  88      public String[] getFieldTypes() {
  89          return fieldTypes;
  90      }
  91  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +    public void setFieldTypes(String[] fieldTypes) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +        this.fieldTypes = fieldTypes;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +</span>
  96      public abstract boolean check();
  97  
  98      public String getType() {
  99          return type;
 100      }
 101  
 102      public void setType(String type) {
 103          this.type = type;
 104      }
 105  
 106      public String[] getFields() {
 107          return fields;
 108      }
 109  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +    public void setFields(String[] fields) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +        this.fields = fields;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +</span>
 114      public Class&lt;?&gt;[] getFieldClasses() {
 115          return fieldClasses;
 116      }
 117  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +        this.fieldClasses = fieldClasses;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
 122      public List&lt;String&gt; getPrimaryKeys() {




 123          return primaryKeys;
 124      }
 125  
 126      public void setPrimaryKeys(List&lt;String&gt; primaryKeys) {
 127          this.primaryKeys = primaryKeys;
 128      }
 129  
 130      public String getName() {
 131          return name;
 132      }
 133  
 134      public void setName(String name) {
 135          this.name = name;
 136      }
 137  
 138      public Integer getParallelism() {
 139          return parallelism;
 140      }
 141  
 142      public void setParallelism(Integer parallelism) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -        if(parallelism == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +        if (parallelism == null) {</span>
 145              return;
 146          }
 147  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -        if(parallelism &lt;= 0){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +        if (parallelism &lt;= 0) {</span>
 150              throw new RuntimeException(&quot;Abnormal parameter settings: parallelism &gt; 0&quot;);
 151          }
 152  
 153          this.parallelism = parallelism;
 154      }
 155  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -    public void addField(String fieldName){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +    public void addField(String fieldName) {</span>
 158          if (fieldList.contains(fieldName)) {
 159              throw new RuntimeException(&quot;redundancy field name &quot; + fieldName + &quot; in table &quot; + getName());
 160          }
 161  
 162          fieldList.add(fieldName);
 163      }
 164  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 165 -    public void addPhysicalMappings(String aliasName, String physicalFieldName){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +    public void addPhysicalMappings(String aliasName, String physicalFieldName) {</span>
 167          physicalFields.put(aliasName, physicalFieldName);
 168      }
 169  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 170 -    public void addFieldClass(Class fieldClass){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +    public void addFieldClass(Class fieldClass) {</span>
 172          fieldClassList.add(fieldClass);
 173      }
 174  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 175 -    public void addFieldType(String fieldType){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +    public void addFieldType(String fieldType) {</span>
 177          fieldTypeList.add(fieldType);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 178 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 180 -    public void setFields(String[] fields) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 181 -        this.fields = fields;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 183 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 184 -    public void setFieldTypes(String[] fieldTypes) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -        this.fieldTypes = fieldTypes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 187 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 188 -    public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -        this.fieldClasses = fieldClasses;</span>
 190      }
 191  
 192      public void addFieldExtraInfo(FieldExtraInfo extraInfo) {
 193          fieldExtraInfoList.add(extraInfo);
 194      }
 195  
 196      public List&lt;String&gt; getFieldList() {
 197          return fieldList;
 198      }
 199  
 200      public List&lt;String&gt; getFieldTypeList() {
 201          return fieldTypeList;
 202      }
 203  
 204      public List&lt;Class&gt; getFieldClassList() {
 205          return fieldClassList;
 206      }
 207  
 208      public Map&lt;String, String&gt; getPhysicalFields() {
 209          return physicalFields;
 210      }
 211  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +    public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        this.physicalFields = physicalFields;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +</span>
 216      public List&lt;FieldExtraInfo&gt; getFieldExtraInfoList() {
 217          return fieldExtraInfoList;
 218      }
 219  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -    public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -        this.physicalFields = physicalFields;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -    public void finish(){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +    public Map&lt;String, String&gt; getCheckProperties() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +        return checkProperties;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +    public void setCheckProperties() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +        this.checkProperties = buildCheckProperties();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +    public Map&lt;String, String&gt; buildCheckProperties() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        return Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +    public Map&lt;String, Object&gt; getDirtyProperties() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +        dirtyProperties.put(DirtyKeys.TABLE_NAME, this.name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        return dirtyProperties;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +    public void setDirtyProperties(Map&lt;String, Object&gt; dirtyProperties) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        this.dirtyProperties = dirtyProperties;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +    public Long getErrorLimit() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        return errorLimit;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +    public void setErrorLimit(Long errorLimit) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +        this.errorLimit = errorLimit;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    public void finish() {</span>
 255          this.fields = fieldList.toArray(new String[0]);
 256          this.fieldClasses = fieldClassList.toArray(new Class[0]);
 257          this.fieldTypes = fieldTypeList.toArray(new String[0]);
 258      }
 259  
 260      /**
 261       * field extra info，used to store `not null` `default 0`...，
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +     * &lt;p&gt;</span>
 264       * now, only support not null
 265       */
 266      public static class FieldExtraInfo implements Serializable {
 267  
 268          /**
 269           * default false：allow field is null
 270           */
 271          boolean notNull = false;
 272          /**
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -         *  field length,eg.char(4)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +         * field length,eg.char(4)</span>
 275           */
 276          int length;
 277  
 278          public int getLength() {
 279              return length;
 280          }
 281  
 282          public void setLength(int length) {
 283              this.length = length;
 284          }
 285  
 286          public boolean getNotNull() {
 287              return notNull;
 288          }
 289  
 290          public void setNotNull(boolean notNull) {
 291              this.notNull = notNull;
 292          }
 293  
 294          @Override
 295          public String toString() {
 296              return &quot;FieldExtraInfo{&quot; +
 297                      &quot;notNull=&quot; + notNull +
 298                      &quot;, length=&quot; + length +
 299                      &#x27;}&#x27;;
 300          }
 301      }
 302  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.table;
  20  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>

  22  import com.google.common.collect.Lists;
  23  import com.google.common.collect.Maps;
  24  
  25  import java.io.Serializable;
  26  import java.util.List;
  27  import java.util.Map;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import java.util.Objects;</span>
  29  
  30  /**
  31   * Reason:
  32   * Date: 2018/6/22
  33   * Company: www.dtstack.com

  34   * @author xuchao
  35   */
  36  
  37  public abstract class AbstractTableInfo implements Serializable {
  38  
  39      public static final String PARALLELISM_KEY = &quot;parallelism&quot;;
  40  





  41      private String name;
  42  
  43      private String type;
  44  
  45      private String[] fields;
  46  
  47      private String[] fieldTypes;
  48  
  49      private Class&lt;?&gt;[] fieldClasses;
  50  
  51      private final List&lt;String&gt; fieldList = Lists.newArrayList();
  52  
  53      /**key:别名, value: realField */



  54      private Map&lt;String, String&gt; physicalFields = Maps.newLinkedHashMap();
  55  
  56      private final List&lt;String&gt; fieldTypeList = Lists.newArrayList();
  57  
  58      private final List&lt;Class&gt; fieldClassList = Lists.newArrayList();
  59  
  60      private final List&lt;FieldExtraInfo&gt; fieldExtraInfoList = Lists.newArrayList();
  61  
  62      private List&lt;String&gt; primaryKeys;
  63  
  64      private Integer parallelism = -1;












  65  
  66      public String[] getFieldTypes() {
  67          return fieldTypes;
  68      }
  69  




  70      public abstract boolean check();
  71  
  72      public String getType() {
  73          return type;
  74      }
  75  
  76      public void setType(String type) {
  77          this.type = type;
  78      }
  79  
  80      public String[] getFields() {
  81          return fields;
  82      }
  83  




  84      public Class&lt;?&gt;[] getFieldClasses() {
  85          return fieldClasses;
  86      }
  87  




  88      public List&lt;String&gt; getPrimaryKeys() {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +        if (this instanceof AbstractSideTableInfo &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +            Objects.isNull(primaryKeys)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +            throw new IllegalArgumentException(&quot;Side table must contain [primary key]!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +        }</span>
  93          return primaryKeys;
  94      }
  95  
  96      public void setPrimaryKeys(List&lt;String&gt; primaryKeys) {
  97          this.primaryKeys = primaryKeys;
  98      }
  99  
 100      public String getName() {
 101          return name;
 102      }
 103  
 104      public void setName(String name) {
 105          this.name = name;
 106      }
 107  
 108      public Integer getParallelism() {
 109          return parallelism;
 110      }
 111  
 112      public void setParallelism(Integer parallelism) {
 113          if(parallelism == null){

 114              return;
 115          }
 116  
 117          if(parallelism &lt;= 0){

 118              throw new RuntimeException(&quot;Abnormal parameter settings: parallelism &gt; 0&quot;);
 119          }
 120  
 121          this.parallelism = parallelism;
 122      }
 123  
 124      public void addField(String fieldName){

 125          if (fieldList.contains(fieldName)) {
 126              throw new RuntimeException(&quot;redundancy field name &quot; + fieldName + &quot; in table &quot; + getName());
 127          }
 128  
 129          fieldList.add(fieldName);
 130      }
 131  
 132      public void addPhysicalMappings(String aliasName, String physicalFieldName){

 133          physicalFields.put(aliasName, physicalFieldName);
 134      }
 135  
 136      public void addFieldClass(Class fieldClass){

 137          fieldClassList.add(fieldClass);
 138      }
 139  
 140      public void addFieldType(String fieldType){

 141          fieldTypeList.add(fieldType);
 142      }
 143  
 144      public void setFields(String[] fields) {
 145          this.fields = fields;
 146      }
 147  
 148      public void setFieldTypes(String[] fieldTypes) {
 149          this.fieldTypes = fieldTypes;
 150      }
 151  
 152      public void setFieldClasses(Class&lt;?&gt;[] fieldClasses) {
 153          this.fieldClasses = fieldClasses;
 154      }
 155  
 156      public void addFieldExtraInfo(FieldExtraInfo extraInfo) {
 157          fieldExtraInfoList.add(extraInfo);
 158      }
 159  
 160      public List&lt;String&gt; getFieldList() {
 161          return fieldList;
 162      }
 163  
 164      public List&lt;String&gt; getFieldTypeList() {
 165          return fieldTypeList;
 166      }
 167  
 168      public List&lt;Class&gt; getFieldClassList() {
 169          return fieldClassList;
 170      }
 171  
 172      public Map&lt;String, String&gt; getPhysicalFields() {
 173          return physicalFields;
 174      }
 175  




 176      public List&lt;FieldExtraInfo&gt; getFieldExtraInfoList() {
 177          return fieldExtraInfoList;
 178      }
 179  
 180      public void setPhysicalFields(Map&lt;String, String&gt; physicalFields) {
 181          this.physicalFields = physicalFields;
 182      }
 183  
 184      public void finish(){






























 185          this.fields = fieldList.toArray(new String[0]);
 186          this.fieldClasses = fieldClassList.toArray(new Class[0]);
 187          this.fieldTypes = fieldTypeList.toArray(new String[0]);
 188      }
 189  
 190      /**
 191       * field extra info，used to store `not null` `default 0`...，
 192       *

 193       * now, only support not null
 194       */
 195      public static class FieldExtraInfo implements Serializable {
 196  
 197          /**
 198           * default false：allow field is null
 199           */
 200          boolean notNull = false;
 201          /**
 202           *  field length,eg.char(4)

 203           */
 204          int length;
 205  
 206          public int getLength() {
 207              return length;
 208          }
 209  
 210          public void setLength(int length) {
 211              this.length = length;
 212          }
 213  
 214          public boolean getNotNull() {
 215              return notNull;
 216          }
 217  
 218          public void setNotNull(boolean notNull) {
 219              this.notNull = notNull;
 220          }
 221  
 222          @Override
 223          public String toString() {
 224              return &quot;FieldExtraInfo{&quot; +
 225                      &quot;notNull=&quot; + notNull +
 226                      &quot;, length=&quot; + length +
 227                      &#x27;}&#x27;;
 228          }
 229      }
 230  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            