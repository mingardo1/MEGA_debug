<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>419 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                         &#x27;                     Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                     StreamTableEnvironment &#x27;
                         &#x27;tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache,\n&#x27;
                         &#x27;                     StreamQueryConfig queryConfig,\n&#x27;
                         &#x27;                     &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache, StreamQueryConfig queryConfig, &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                           &#x27;throws Exception {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public void exec(String sql,\n&#x27;
                         &#x27;                     Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                     StreamTableEnvironment &#x27;
                         &#x27;tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache,\n&#x27;
                         &#x27;                     StreamQueryConfig queryConfig,\n&#x27;
                         &#x27;                     &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void exec(String sql, Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache, StreamQueryConfig queryConfig, &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                           &#x27;throws Exception {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public AliasInfo parseASNode(SqlNode sqlNode) &#x27;
                         &#x27;throws SqlParseException {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    /**\n&#x27;
                           &#x27;     * 添加字段别名\n&#x27;
                           &#x27;     * @param pollSqlNode\n&#x27;
                           &#x27;     * @param fieldList\n&#x27;
                           &#x27;     * @param mappingTable\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void addAliasForFieldNode(SqlNode &#x27;
                           &#x27;pollSqlNode, List&lt;String&gt; fieldList, &#x27;
                           &#x27;HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable) {\n&#x27;
                           &#x27;        SqlKind sqlKind = pollSqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode source = ((SqlInsert) &#x27;
                           &#x27;pollSqlNode).getSource();\n&#x27;
                           &#x27;                addAliasForFieldNode(source, &#x27;
                           &#x27;fieldList, mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                &#x27;
                           &#x27;addAliasForFieldNode(((SqlBasicCall) &#x27;
                           &#x27;pollSqlNode).getOperands()[0], fieldList, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNodeList selectList = &#x27;
                           &#x27;((SqlSelect) pollSqlNode).getSelectList();\n&#x27;
                           &#x27;                selectList.getList().forEach(node &#x27;
                           &#x27;-&gt; {\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        // save real field\n&#x27;
                           &#x27;                        String fieldName = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(!fieldName.endsWith(&quot;0&quot;) || &#x27;
                           &#x27;fieldName.endsWith(&quot;0&quot;) &amp;&amp; &#x27;
                           &#x27;mappingTable.columnMap().containsKey(fieldName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;fieldList.add(fieldName);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;selectList.getList().size(); i++) {\n&#x27;
                           &#x27;                    SqlNode node = &#x27;
                           &#x27;selectList.get(i);\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        String name = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        // avoid real field pv0 &#x27;
                           &#x27;convert pv\n&#x27;
                           &#x27;                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  &#x27;
                           &#x27;!fieldList.contains(name) &amp;&amp; &#x27;
                           &#x27;!fieldList.contains(name.substring(0, &#x27;
                           &#x27;name.length() - 1))) {\n&#x27;
                           &#x27;                            SqlOperator operator = &#x27;
                           &#x27;new SqlAsOperator();\n&#x27;
                           &#x27;                            SqlParserPos &#x27;
                           &#x27;sqlParserPos = new SqlParserPos(0, 0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlIdentifier &#x27;
                           &#x27;sqlIdentifierAlias = new &#x27;
                           &#x27;SqlIdentifier(name.substring(0, name.length() - &#x27;
                           &#x27;1), null, sqlParserPos);\n&#x27;
                           &#x27;                            SqlNode[] sqlNodes = &#x27;
                           &#x27;new SqlNode[2];\n&#x27;
                           &#x27;                            sqlNodes[0] = &#x27;
                           &#x27;sqlIdentifier;\n&#x27;
                           &#x27;                            sqlNodes[1] = &#x27;
                           &#x27;sqlIdentifierAlias;\n&#x27;
                           &#x27;                            SqlBasicCall &#x27;
                           &#x27;sqlBasicCall = new SqlBasicCall(operator, &#x27;
                           &#x27;sqlNodes, sqlParserPos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            selectList.set(i, &#x27;
                           &#x27;sqlBasicCall);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public AliasInfo parseAsNode(SqlNode sqlNode) &#x27;
                           &#x27;throws SqlParseException {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                        List&lt;SqlNode&gt; &#x27;
                           &#x27;newSelectNodeList = Lists.newArrayList();\n&#x27;
                           &#x27;                        for( int i=0; &#x27;
                           &#x27;i&lt;sqlSelectList.getList().size(); i++){\n&#x27;
                           &#x27;                            SqlNode selectNode = &#x27;
                           &#x27;sqlSelectList.getList().get(i);\n&#x27;
                           &#x27;                            //特殊处理 isStar的标识\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;if(selectNode.getKind() == IDENTIFIER &amp;&amp; &#x27;
                           &#x27;((SqlIdentifier) selectNode).isStar()){\n&#x27;
                           &#x27;                                List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceNodeList = &#x27;
                           &#x27;replaceSelectStarFieldName(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;newSelectNodeList.addAll(replaceNodeList);\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(selectNode, replaceInfo);\n&#x27;
                           &#x27;                            if(replaceNode == &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            //sqlSelectList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;newSelectNodeList.add(replaceNode);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        SqlNodeList newSelectList &#x27;
                           &#x27;= new SqlNodeList(newSelectNodeList, &#x27;
                           &#x27;sqlSelectList.getParserPosition());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sqlSelect.setSelectList(newSelectList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //where\n&#x27;
                           &#x27;                        if(whereNode != null){\n&#x27;
                           &#x27;                            SqlNode[] sqlNodeList &#x27;
                           &#x27;= ((SqlBasicCall)whereNode).getOperands();\n&#x27;
                           &#x27;                            for(int i =0; &#x27;
                           &#x27;i&lt;sqlNodeList.length; i++) {\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;whereSqlNode = sqlNodeList[i];\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(whereSqlNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlNodeList[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        if(sqlGroup != null &amp;&amp; &#x27;
                           &#x27;CollectionUtils.isNotEmpty(sqlGroup.getList())){\n&#x27;
                           &#x27;                            for( int i=0; &#x27;
                           &#x27;i&lt;sqlGroup.getList().size(); i++){\n&#x27;
                           &#x27;                                SqlNode selectNode &#x27;
                           &#x27;= sqlGroup.getList().get(i);\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlGroup.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;---not deal type:&quot; + sqlNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case UNION:\n&#x27;
                           &#x27;                SqlNode unionLeft = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                SqlNode unionRight = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[1];\n&#x27;
                           &#x27;                replaceFieldName(unionLeft, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                replaceFieldName(unionRight, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case ORDER_BY:\n&#x27;
                           &#x27;                SqlOrderBy sqlOrderBy  = &#x27;
                           &#x27;(SqlOrderBy) sqlNode;\n&#x27;
                           &#x27;                replaceFieldName(sqlOrderBy.query, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                SqlNodeList orderFiledList = &#x27;
                           &#x27;sqlOrderBy.orderList;\n&#x27;
                           &#x27;                for (int i=0 &#x27;
                           &#x27;;i&lt;orderFiledList.size();i++) {\n&#x27;
                           &#x27;                    SqlNode replaceNode = &#x27;
                           &#x27;replaceOrderByTableName(orderFiledList.get(i), &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                    orderFiledList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode &#x27;
                           &#x27;replaceOrderByTableName(SqlNode orderNode, String &#x27;
                           &#x27;tableAlias) {\n&#x27;
                           &#x27;        if(orderNode.getKind() == IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) orderNode;\n&#x27;
                           &#x27;            if (sqlIdentifier.names.size() == 1) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                return orderNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return sqlIdentifier.setName(0, &#x27;
                           &#x27;tableAlias);\n&#x27;
                           &#x27;        } else if (orderNode instanceof  &#x27;
                           &#x27;SqlBasicCall) {\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) orderNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperandList().size(); i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperandList().get(i);\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceOrderByTableName(sqlNode , tableAlias);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return sqlBasicCall;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            return orderNode;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode replaceNodeInfo(SqlNode &#x27;
                           &#x27;groupNode, FieldReplaceInfo replaceInfo){\n&#x27;
                           &#x27;        if(groupNode.getKind() == IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) groupNode;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return sqlIdentifier;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if(mappingFieldName == null){\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + &#x27;
                           &#x27;sqlIdentifier.toString() );\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            return sqlIdentifier.setName(1, &#x27;
                           &#x27;mappingFieldName);\n&#x27;
                           &#x27;        }else if(groupNode instanceof  &#x27;
                           &#x27;SqlBasicCall){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) groupNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperandList().size(); i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperandList().get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return sqlBasicCall;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            return groupNode;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public SqlNode &#x27;
                           &#x27;filterNodeWithTargetName(SqlNode sqlNode, String &#x27;
                           &#x27;targetTableName) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind){\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNode fromNode = &#x27;
                           &#x27;((SqlSelect)sqlNode).getFrom();\n&#x27;
                           &#x27;                if(fromNode.getKind() == AS &amp;&amp; &#x27;
                           &#x27;((SqlBasicCall)fromNode).getOperands()[0].getKind() &#x27;
                           &#x27;== IDENTIFIER){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){\n&#x27;
                           &#x27;                        return sqlNode;\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        return null;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return &#x27;
                           &#x27;filterNodeWithTargetName(fromNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode childNode = &#x27;
                           &#x27;((SqlBasicCall)sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;filterNodeWithTargetName(childNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;            case JOIN:\n&#x27;
                           &#x27;                SqlNode leftNode = &#x27;
                           &#x27;((SqlJoin)sqlNode).getLeft();\n&#x27;
                           &#x27;                SqlNode rightNode =  &#x27;
                           &#x27;((SqlJoin)sqlNode).getRight();\n&#x27;
                           &#x27;                SqlNode leftReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(leftNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                SqlNode rightReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(rightNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(leftReturnNode != null) {\n&#x27;
                           &#x27;                    return leftReturnNode;\n&#x27;
                           &#x27;                }else if(rightReturnNode != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                    return rightReturnNode;\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return null;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceSelectStarFieldName(SqlNode selectNode, &#x27;
                           &#x27;FieldReplaceInfo replaceInfo){\n&#x27;
                           &#x27;        SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;        List&lt;SqlNode&gt; sqlNodes = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if(sqlIdentifier.isStar()){//处理 [* or &#x27;
                           &#x27;table.*]\n&#x27;
                           &#x27;            int identifierSize = &#x27;
                           &#x27;sqlIdentifier.names.size();\n&#x27;
                           &#x27;            Collection&lt;String&gt; columns = null;\n&#x27;
                           &#x27;            if(identifierSize == 1){\n&#x27;
                           &#x27;                columns = &#x27;
                           &#x27;replaceInfo.getMappingTable().values();\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                columns = &#x27;
                           &#x27;replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(String colAlias : columns){\n&#x27;
                           &#x27;                SqlParserPos sqlParserPos = new &#x27;
                           &#x27;SqlParserPos(0, 0);\n&#x27;
                           &#x27;                List&lt;String&gt; columnInfo = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;                &#x27;
                           &#x27;columnInfo.add(replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                columnInfo.add(colAlias);\n&#x27;
                           &#x27;                SqlIdentifier sqlIdentifierAlias = &#x27;
                           &#x27;new SqlIdentifier(columnInfo, sqlParserPos);\n&#x27;
                           &#x27;                sqlNodes.add(sqlIdentifierAlias);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return sqlNodes;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;is not a &#x27;
                           &#x27;star select field.&quot; + selectNode);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode replaceSelectFieldName(SqlNode &#x27;
                           &#x27;selectNode, FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        if (selectNode.getKind() == AS) {\n&#x27;
                           &#x27;            SqlNode leftNode = ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0];\n&#x27;
                           &#x27;            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(leftNode, replaceInfo);\n&#x27;
                           &#x27;            if (replaceNode != null) {\n&#x27;
                           &#x27;                ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0] = replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == &#x27;
                           &#x27;IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return selectNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            //Same level mappingTable\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if (mappingFieldName == null) {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + selectNode.toString() &#x27;
                           &#x27;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(1, mappingFieldName);\n&#x27;
                           &#x27;            return sqlIdentifier;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == LITERAL &#x27;
                           &#x27;|| selectNode.getKind() == LITERAL_CHAIN){//字面含义\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(  &#x27;
                           &#x27;AGGREGATE.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;AVG_AGG_FUNCTIONS.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;COMPARISON.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;OTHER_FUNCTION\n&#x27;
                           &#x27;                || selectNode.getKind() == DIVIDE\n&#x27;
                           &#x27;                || selectNode.getKind() == CAST\n&#x27;
                           &#x27;                || selectNode.getKind() == TRIM\n&#x27;
                           &#x27;                || selectNode.getKind() == TIMES\n&#x27;
                           &#x27;                || selectNode.getKind() == PLUS\n&#x27;
                           &#x27;                || selectNode.getKind() == NOT_IN\n&#x27;
                           &#x27;                || selectNode.getKind() == OR\n&#x27;
                           &#x27;                || selectNode.getKind() == AND\n&#x27;
                           &#x27;                || selectNode.getKind() == MINUS\n&#x27;
                           &#x27;                || selectNode.getKind() == TUMBLE\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_END\n&#x27;
                           &#x27;                || selectNode.getKind() == HOP\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;BETWEEN\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NOT_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;CONTAINS\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_ADD\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_DIFF\n&#x27;
                           &#x27;                || selectNode.getKind() == LIKE\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                ){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) selectNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperands().length; i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperands()[i];\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlLiteral){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlDataTypeSpec){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                if(replaceNode == null){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == CASE){\n&#x27;
                           &#x27;            SqlCase sqlCase = (SqlCase) &#x27;
                           &#x27;selectNode;\n&#x27;
                           &#x27;            SqlNodeList whenOperands = &#x27;
                           &#x27;sqlCase.getWhenOperands();\n&#x27;
                           &#x27;            SqlNodeList thenOperands = &#x27;
                           &#x27;sqlCase.getThenOperands();\n&#x27;
                           &#x27;            SqlNode elseNode = &#x27;
                           &#x27;sqlCase.getElseOperand();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;whenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;whenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    whenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;thenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;thenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    thenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            ((SqlCase) selectNode).setOperand(3, &#x27;
                           &#x27;replaceSelectFieldName(elseNode, replaceInfo));\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == OTHER){\n&#x27;
                           &#x27;            //不处理\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support node &#x27;
                           &#x27;kind of %s to replace name now.&quot;, &#x27;
                           &#x27;selectNode.getKind()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private void joinFun(Object pollObj,\n&#x27;
                         &#x27;                         Map&lt;String, Table&gt; &#x27;
                         &#x27;localTableCache,\n&#x27;
                         &#x27;                         Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                         StreamTableEnvironment &#x27;
                         &#x27;tableEnv) throws Exception{\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private void joinFun(Object pollObj, &#x27;
                           &#x27;Map&lt;String, Table&gt; localTableCache,\n&#x27;
                           &#x27;                         Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                         List&lt;FieldReplaceInfo&gt; &#x27;
                           &#x27;replaceInfoList) throws Exception{\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void addAliasForFieldNode(SqlNode &#x27;
                           &#x27;pollSqlNode, List&lt;String&gt; fieldList, &#x27;
                           &#x27;HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable) {\n&#x27;
                           &#x27;        SqlKind sqlKind = pollSqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode source = ((SqlInsert) &#x27;
                           &#x27;pollSqlNode).getSource();\n&#x27;
                           &#x27;                addAliasForFieldNode(source, &#x27;
                           &#x27;fieldList, mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                &#x27;
                           &#x27;addAliasForFieldNode(((SqlBasicCall) &#x27;
                           &#x27;pollSqlNode).getOperands()[0], fieldList, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNodeList selectList = &#x27;
                           &#x27;((SqlSelect) pollSqlNode).getSelectList();\n&#x27;
                           &#x27;                selectList.getList().forEach(node &#x27;
                           &#x27;-&gt; {\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        // save real field\n&#x27;
                           &#x27;                        String fieldName = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(!fieldName.endsWith(&quot;0&quot;) || &#x27;
                           &#x27;fieldName.endsWith(&quot;0&quot;) &amp;&amp; &#x27;
                           &#x27;mappingTable.columnMap().containsKey(fieldName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;fieldList.add(fieldName);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;selectList.getList().size(); i++) {\n&#x27;
                           &#x27;                    SqlNode node = &#x27;
                           &#x27;selectList.get(i);\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        String name = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        // avoid real field pv0 &#x27;
                           &#x27;convert pv\n&#x27;
                           &#x27;                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  &#x27;
                           &#x27;!fieldList.contains(name) &amp;&amp; &#x27;
                           &#x27;!fieldList.contains(name.substring(0, &#x27;
                           &#x27;name.length() - 1))) {\n&#x27;
                           &#x27;                            SqlOperator operator = &#x27;
                           &#x27;new SqlAsOperator();\n&#x27;
                           &#x27;                            SqlParserPos &#x27;
                           &#x27;sqlParserPos = new SqlParserPos(0, 0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlIdentifier &#x27;
                           &#x27;sqlIdentifierAlias = new &#x27;
                           &#x27;SqlIdentifier(name.substring(0, name.length() - &#x27;
                           &#x27;1), null, sqlParserPos);\n&#x27;
                           &#x27;                            SqlNode[] sqlNodes = &#x27;
                           &#x27;new SqlNode[2];\n&#x27;
                           &#x27;                            sqlNodes[0] = &#x27;
                           &#x27;sqlIdentifier;\n&#x27;
                           &#x27;                            sqlNodes[1] = &#x27;
                           &#x27;sqlIdentifierAlias;\n&#x27;
                           &#x27;                            SqlBasicCall &#x27;
                           &#x27;sqlBasicCall = new SqlBasicCall(operator, &#x27;
                           &#x27;sqlNodes, sqlParserPos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            selectList.set(i, &#x27;
                           &#x27;sqlBasicCall);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void replaceFieldName(SqlNode sqlNode, &#x27;
                           &#x27;FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode sqlSource = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource();\n&#x27;
                           &#x27;                replaceFieldName(sqlSource, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode asNode = ((SqlBasicCall) &#x27;
                           &#x27;sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                replaceFieldName(asNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlSelect sqlSelect = (SqlSelect) &#x27;
                           &#x27;filterNodeWithTargetName(sqlNode, &#x27;
                           &#x27;replaceInfo.getTargetTableName());\n&#x27;
                           &#x27;                if(sqlSelect == null){\n&#x27;
                           &#x27;                    return;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode sqlSource1 = &#x27;
                           &#x27;sqlSelect.getFrom();\n&#x27;
                           &#x27;                if(sqlSource1.getKind() == AS){\n&#x27;
                           &#x27;                    String tableName = &#x27;
                           &#x27;((SqlBasicCall)sqlSource1).getOperands()[0].toString();\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){\n&#x27;
                           &#x27;                        SqlNodeList sqlSelectList &#x27;
                           &#x27;= sqlSelect.getSelectList();\n&#x27;
                           &#x27;                        SqlNode whereNode = &#x27;
                           &#x27;sqlSelect.getWhere();\n&#x27;
                           &#x27;                        SqlNodeList sqlGroup = &#x27;
                           &#x27;sqlSelect.getGroup();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //TODO 暂时不处理having\n&#x27;
                           &#x27;                        SqlNode sqlHaving = &#x27;
                           &#x27;sqlSelect.getHaving();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        List&lt;SqlNode&gt; &#x27;
                           &#x27;newSelectNodeList = Lists.newArrayList();\n&#x27;
                           &#x27;                        for( int i=0; &#x27;
                           &#x27;i&lt;sqlSelectList.getList().size(); i++){\n&#x27;
                           &#x27;                            SqlNode selectNode = &#x27;
                           &#x27;sqlSelectList.getList().get(i);\n&#x27;
                           &#x27;                            //特殊处理 isStar的标识\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;if(selectNode.getKind() == IDENTIFIER &amp;&amp; &#x27;
                           &#x27;((SqlIdentifier) selectNode).isStar()){\n&#x27;
                           &#x27;                                List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceNodeList = &#x27;
                           &#x27;replaceSelectStarFieldName(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;newSelectNodeList.addAll(replaceNodeList);\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(selectNode, replaceInfo);\n&#x27;
                           &#x27;                            if(replaceNode == &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            //sqlSelectList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;newSelectNodeList.add(replaceNode);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        SqlNodeList newSelectList &#x27;
                           &#x27;= new SqlNodeList(newSelectNodeList, &#x27;
                           &#x27;sqlSelectList.getParserPosition());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sqlSelect.setSelectList(newSelectList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //where\n&#x27;
                           &#x27;                        if(whereNode != null){\n&#x27;
                           &#x27;                            SqlNode[] sqlNodeList &#x27;
                           &#x27;= ((SqlBasicCall)whereNode).getOperands();\n&#x27;
                           &#x27;                            for(int i =0; &#x27;
                           &#x27;i&lt;sqlNodeList.length; i++) {\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;whereSqlNode = sqlNodeList[i];\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(whereSqlNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlNodeList[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        if(sqlGroup != null &amp;&amp; &#x27;
                           &#x27;CollectionUtils.isNotEmpty(sqlGroup.getList())){\n&#x27;
                           &#x27;                            for( int i=0; &#x27;
                           &#x27;i&lt;sqlGroup.getList().size(); i++){\n&#x27;
                           &#x27;                                SqlNode selectNode &#x27;
                           &#x27;= sqlGroup.getList().get(i);\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlGroup.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;---not deal type:&quot; + sqlNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case UNION:\n&#x27;
                           &#x27;                SqlNode unionLeft = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                SqlNode unionRight = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[1];\n&#x27;
                           &#x27;                replaceFieldName(unionLeft, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                replaceFieldName(unionRight, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case ORDER_BY:\n&#x27;
                           &#x27;                SqlOrderBy sqlOrderBy  = &#x27;
                           &#x27;(SqlOrderBy) sqlNode;\n&#x27;
                           &#x27;                replaceFieldName(sqlOrderBy.query, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                SqlNodeList orderFiledList = &#x27;
                           &#x27;sqlOrderBy.orderList;\n&#x27;
                           &#x27;                for (int i=0 &#x27;
                           &#x27;;i&lt;orderFiledList.size();i++) {\n&#x27;
                           &#x27;                    SqlNode replaceNode = &#x27;
                           &#x27;replaceOrderByTableName(orderFiledList.get(i), &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                    orderFiledList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public SqlNode filterNodeWithTargetName(SqlNode &#x27;
                           &#x27;sqlNode, String targetTableName) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind){\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNode fromNode = &#x27;
                           &#x27;((SqlSelect)sqlNode).getFrom();\n&#x27;
                           &#x27;                if(fromNode.getKind() == AS &amp;&amp; &#x27;
                           &#x27;((SqlBasicCall)fromNode).getOperands()[0].getKind() &#x27;
                           &#x27;== IDENTIFIER){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){\n&#x27;
                           &#x27;                        return sqlNode;\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        return null;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return &#x27;
                           &#x27;filterNodeWithTargetName(fromNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode childNode = &#x27;
                           &#x27;((SqlBasicCall)sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;filterNodeWithTargetName(childNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;            case JOIN:\n&#x27;
                           &#x27;                SqlNode leftNode = &#x27;
                           &#x27;((SqlJoin)sqlNode).getLeft();\n&#x27;
                           &#x27;                SqlNode rightNode =  &#x27;
                           &#x27;((SqlJoin)sqlNode).getRight();\n&#x27;
                           &#x27;                SqlNode leftReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(leftNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                SqlNode rightReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(rightNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(leftReturnNode != null) {\n&#x27;
                           &#x27;                    return leftReturnNode;\n&#x27;
                           &#x27;                }else if(rightReturnNode != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                    return rightReturnNode;\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return null;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private SqlNode replaceSelectFieldName(SqlNode &#x27;
                           &#x27;selectNode, FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        if (selectNode.getKind() == AS) {\n&#x27;
                           &#x27;            SqlNode leftNode = ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0];\n&#x27;
                           &#x27;            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(leftNode, replaceInfo);\n&#x27;
                           &#x27;            if (replaceNode != null) {\n&#x27;
                           &#x27;                ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0] = replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == &#x27;
                           &#x27;IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return selectNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            //Same level mappingTable\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if (mappingFieldName == null) {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + selectNode.toString() &#x27;
                           &#x27;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(1, mappingFieldName);\n&#x27;
                           &#x27;            return sqlIdentifier;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == LITERAL &#x27;
                           &#x27;|| selectNode.getKind() == LITERAL_CHAIN){//字面含义\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(  &#x27;
                           &#x27;AGGREGATE.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;AVG_AGG_FUNCTIONS.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;COMPARISON.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;OTHER_FUNCTION\n&#x27;
                           &#x27;                || selectNode.getKind() == DIVIDE\n&#x27;
                           &#x27;                || selectNode.getKind() == CAST\n&#x27;
                           &#x27;                || selectNode.getKind() == TRIM\n&#x27;
                           &#x27;                || selectNode.getKind() == TIMES\n&#x27;
                           &#x27;                || selectNode.getKind() == PLUS\n&#x27;
                           &#x27;                || selectNode.getKind() == NOT_IN\n&#x27;
                           &#x27;                || selectNode.getKind() == OR\n&#x27;
                           &#x27;                || selectNode.getKind() == AND\n&#x27;
                           &#x27;                || selectNode.getKind() == MINUS\n&#x27;
                           &#x27;                || selectNode.getKind() == TUMBLE\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_END\n&#x27;
                           &#x27;                || selectNode.getKind() == HOP\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;BETWEEN\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NOT_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;CONTAINS\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_ADD\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_DIFF\n&#x27;
                           &#x27;                || selectNode.getKind() == LIKE\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                ){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) selectNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperands().length; i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperands()[i];\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlLiteral){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlDataTypeSpec){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                if(replaceNode == null){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == CASE){\n&#x27;
                           &#x27;            SqlCase sqlCase = (SqlCase) &#x27;
                           &#x27;selectNode;\n&#x27;
                           &#x27;            SqlNodeList whenOperands = &#x27;
                           &#x27;sqlCase.getWhenOperands();\n&#x27;
                           &#x27;            SqlNodeList thenOperands = &#x27;
                           &#x27;sqlCase.getThenOperands();\n&#x27;
                           &#x27;            SqlNode elseNode = &#x27;
                           &#x27;sqlCase.getElseOperand();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;whenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;whenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    whenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;thenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;thenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    thenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            ((SqlCase) selectNode).setOperand(3, &#x27;
                           &#x27;replaceSelectFieldName(elseNode, replaceInfo));\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == OTHER){\n&#x27;
                           &#x27;            //不处理\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support node &#x27;
                           &#x27;kind of %s to replace name now.&quot;, &#x27;
                           &#x27;selectNode.getKind()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private void joinFun(Object pollObj,\n&#x27;
                         &#x27;                         Map&lt;String, Table&gt; &#x27;
                         &#x27;localTableCache,\n&#x27;
                         &#x27;                         Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                         StreamTableEnvironment &#x27;
                         &#x27;tableEnv) throws Exception{\n&#x27;
                         &#x27;        JoinInfo joinInfo = (JoinInfo) pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        JoinScope joinScope = new JoinScope();\n&#x27;
                         &#x27;        JoinScope.ScopeChild leftScopeChild = new &#x27;
                         &#x27;JoinScope.ScopeChild();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setAlias(joinInfo.getLeftTableAlias());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setTableName(joinInfo.getLeftTableName());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Table leftTable = &#x27;
                         &#x27;getTableFromCache(localTableCache, &#x27;
                         &#x27;joinInfo.getLeftTableAlias(), &#x27;
                         &#x27;joinInfo.getLeftTableName());\n&#x27;
                         &#x27;        RowTypeInfo leftTypeInfo = new &#x27;
                         &#x27;RowTypeInfo(leftTable.getSchema().getTypes(), &#x27;
                         &#x27;leftTable.getSchema().getColumnNames());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setRowTypeInfo(leftTypeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        JoinScope.ScopeChild rightScopeChild = new &#x27;
                         &#x27;JoinScope.ScopeChild();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setAlias(joinInfo.getRightTableAlias());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setTableName(joinInfo.getRightTableName());\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideTableMap.get(joinInfo.getRightTableName());\n&#x27;
                         &#x27;        if(sideTableInfo == null){\n&#x27;
                         &#x27;            sideTableInfo = &#x27;
                         &#x27;sideTableMap.get(joinInfo.getRightTableAlias());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if(sideTableInfo == null){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;can\&#x27;t not &#x27;
                         &#x27;find side table:&quot; + joinInfo.getRightTableName());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;//            throw new RuntimeException(&quot;ON &#x27;
                         &#x27;condition must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        joinScope.addScope(leftScopeChild);\n&#x27;
                         &#x27;        joinScope.addScope(rightScopeChild);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = ((JoinInfo) &#x27;
                         &#x27;pollObj).getTableFieldRef();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //获取两个表的所有字段\n&#x27;
                         &#x27;        List&lt;FieldInfo&gt; sideJoinFieldInfo = &#x27;
                         &#x27;ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), &#x27;
                         &#x27;joinScope, true);\n&#x27;
                         &#x27;        //通过join的查询字段信息过滤出需要的字段信息\n&#x27;
                         &#x27;        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; &#x27;
                         &#x27;mappingTable.get(tmpFieldInfo.getTable(), &#x27;
                         &#x27;tmpFieldInfo.getFieldName()) == null);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String leftTableAlias = &#x27;
                         &#x27;joinInfo.getLeftTableAlias();\n&#x27;
                         &#x27;        Table targetTable = &#x27;
                         &#x27;localTableCache.get(leftTableAlias);\n&#x27;
                         &#x27;        if(targetTable == null){\n&#x27;
                         &#x27;            targetTable = &#x27;
                         &#x27;localTableCache.get(joinInfo.getLeftTableName());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        RowTypeInfo typeInfo = new &#x27;
                         &#x27;RowTypeInfo(targetTable.getSchema().getTypes(), &#x27;
                         &#x27;targetTable.getSchema().getColumnNames());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        DataStream&lt;CRow&gt; adaptStream = &#x27;
                         &#x27;tableEnv.toRetractStream(targetTable, &#x27;
                         &#x27;org.apache.flink.types.Row.class)\n&#x27;
                         &#x27;                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                    return new CRow(tp2.f1, &#x27;
                         &#x27;tp2.f0);\n&#x27;
                         &#x27;                }).returns(CRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //join side table before keyby ===&gt; Reducing &#x27;
                         &#x27;the size of each dimension table cache of async\n&#x27;
                         &#x27;        if (sideTableInfo.isPartitionedJoin()) {\n&#x27;
                         &#x27;            List&lt;String&gt; leftJoinColList = &#x27;
                         &#x27;getConditionFields(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getLeftTableAlias(), sideTableInfo);\n&#x27;
                         &#x27;            List&lt;String&gt; fieldNames = &#x27;
                         &#x27;Arrays.asList(targetTable.getSchema().getFieldNames());\n&#x27;
                         &#x27;            int[] keyIndex = &#x27;
                         &#x27;leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();\n&#x27;
                         &#x27;            adaptStream = adaptStream.keyBy(new &#x27;
                         &#x27;CRowKeySelector(keyIndex, &#x27;
                         &#x27;projectedTypeInfo(keyIndex, &#x27;
                         &#x27;targetTable.getSchema())));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        DataStream&lt;CRow&gt; dsOut = null;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            dsOut = &#x27;
                         &#x27;SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, &#x27;
                         &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                         &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                         &#x27;sideTableInfo);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            dsOut = &#x27;
                         &#x27;SideAsyncOperator.getSideJoinDataStream(adaptStream, &#x27;
                         &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                         &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                         &#x27;sideTableInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        RowTypeInfo sideOutTypeInfo = &#x27;
                         &#x27;buildOutRowTypeInfo(sideJoinFieldInfo, &#x27;
                         &#x27;mappingTable);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        CRowTypeInfo cRowTypeInfo = new &#x27;
                         &#x27;CRowTypeInfo(sideOutTypeInfo);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;dsOut.getTransformation().setOutputType(cRowTypeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String targetTableName = &#x27;
                         &#x27;joinInfo.getNewTableName();\n&#x27;
                         &#x27;        String targetTableAlias = &#x27;
                         &#x27;joinInfo.getNewTableAlias();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        FieldReplaceInfo replaceInfo = new &#x27;
                         &#x27;FieldReplaceInfo();\n&#x27;
                         &#x27;        replaceInfo.setMappingTable(mappingTable);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;replaceInfo.setTargetTableName(targetTableName);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;replaceInfo.setTargetTableAlias(targetTableAlias);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!tableEnv.isRegistered(joinInfo.getNewTableName())){\n&#x27;
                         &#x27;            Table joinTable = &#x27;
                         &#x27;tableEnv.fromDataStream(dsOut);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableEnv.registerTable(joinInfo.getNewTableName(), &#x27;
                         &#x27;joinTable);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;localTableCache.put(joinInfo.getNewTableName(), &#x27;
                         &#x27;joinTable);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private void joinFun(Object pollObj, &#x27;
                           &#x27;Map&lt;String, Table&gt; localTableCache,\n&#x27;
                           &#x27;                         Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                         List&lt;FieldReplaceInfo&gt; &#x27;
                           &#x27;replaceInfoList) throws Exception{\n&#x27;
                           &#x27;        JoinInfo joinInfo = (JoinInfo) pollObj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        JoinScope joinScope = new JoinScope();\n&#x27;
                           &#x27;        JoinScope.ScopeChild leftScopeChild = new &#x27;
                           &#x27;JoinScope.ScopeChild();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setAlias(joinInfo.getLeftTableAlias());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setTableName(joinInfo.getLeftTableName());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = &#x27;
                           &#x27;joinInfo.getLeftNode().getKind();\n&#x27;
                           &#x27;        if(sqlKind == AS){\n&#x27;
                           &#x27;            dealAsSourceTable(tableEnv, &#x27;
                           &#x27;joinInfo.getLeftNode(), localTableCache, &#x27;
                           &#x27;replaceInfoList);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Table leftTable = &#x27;
                           &#x27;getTableFromCache(localTableCache, &#x27;
                           &#x27;joinInfo.getLeftTableAlias(), &#x27;
                           &#x27;joinInfo.getLeftTableName());\n&#x27;
                           &#x27;        RowTypeInfo leftTypeInfo = new &#x27;
                           &#x27;RowTypeInfo(leftTable.getSchema().getTypes(), &#x27;
                           &#x27;leftTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setRowTypeInfo(leftTypeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        JoinScope.ScopeChild rightScopeChild = new &#x27;
                           &#x27;JoinScope.ScopeChild();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setAlias(joinInfo.getRightTableAlias());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setTableName(joinInfo.getRightTableName());\n&#x27;
                           &#x27;        AbstractSideTableInfo sideTableInfo = &#x27;
                           &#x27;sideTableMap.get(joinInfo.getRightTableName());\n&#x27;
                           &#x27;        if(sideTableInfo == null){\n&#x27;
                           &#x27;            sideTableInfo = &#x27;
                           &#x27;sideTableMap.get(joinInfo.getRightTableAlias());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(sideTableInfo == null){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;can\&#x27;t not &#x27;
                           &#x27;find side table:&quot; + &#x27;
                           &#x27;joinInfo.getRightTableName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//        &#x27;
                           &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                           &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                           &#x27;//            throw new RuntimeException(&quot;ON &#x27;
                           &#x27;condition must contain all equal fields!!!&quot;);\n&#x27;
                           &#x27;//        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        joinScope.addScope(leftScopeChild);\n&#x27;
                           &#x27;        joinScope.addScope(rightScopeChild);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //获取两个表的所有字段\n&#x27;
                           &#x27;        List&lt;FieldInfo&gt; sideJoinFieldInfo = &#x27;
                           &#x27;ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), &#x27;
                           &#x27;joinScope, true);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String leftTableAlias = &#x27;
                           &#x27;joinInfo.getLeftTableAlias();\n&#x27;
                           &#x27;        Table targetTable = &#x27;
                           &#x27;localTableCache.get(leftTableAlias);\n&#x27;
                           &#x27;        if(targetTable == null){\n&#x27;
                           &#x27;            targetTable = &#x27;
                           &#x27;localTableCache.get(joinInfo.getLeftTableName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(targetTable.getSchema().getTypes(), &#x27;
                           &#x27;targetTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        DataStream&lt;CRow&gt; adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(targetTable, &#x27;
                           &#x27;org.apache.flink.types.Row.class)\n&#x27;
                           &#x27;                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    return new CRow(tp2.f1, &#x27;
                           &#x27;tp2.f0);\n&#x27;
                           &#x27;                }).returns(CRow.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //join side table before keyby ===&gt; &#x27;
                           &#x27;Reducing the size of each dimension table cache of &#x27;
                           &#x27;async\n&#x27;
                           &#x27;        if (sideTableInfo.isPartitionedJoin()) {\n&#x27;
                           &#x27;            List&lt;String&gt; leftJoinColList = &#x27;
                           &#x27;getConditionFields(joinInfo.getCondition(), &#x27;
                           &#x27;joinInfo.getLeftTableAlias(), sideTableInfo);\n&#x27;
                           &#x27;            List&lt;String&gt; fieldNames = &#x27;
                           &#x27;Arrays.asList(targetTable.getSchema().getFieldNames());\n&#x27;
                           &#x27;            int[] keyIndex = &#x27;
                           &#x27;leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();\n&#x27;
                           &#x27;            adaptStream = adaptStream.keyBy(new &#x27;
                           &#x27;CRowKeySelector(keyIndex, &#x27;
                           &#x27;projectedTypeInfo(keyIndex, &#x27;
                           &#x27;targetTable.getSchema())));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        DataStream&lt;CRow&gt; dsOut = null;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                           &#x27;            dsOut = &#x27;
                           &#x27;SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, &#x27;
                           &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                           &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                           &#x27;sideTableInfo);\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            dsOut = &#x27;
                           &#x27;SideAsyncOperator.getSideJoinDataStream(adaptStream, &#x27;
                           &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                           &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                           &#x27;sideTableInfo);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime\n&#x27;
                           &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable = HashBasedTable.create();\n&#x27;
                           &#x27;        RowTypeInfo sideOutTypeInfo = &#x27;
                           &#x27;buildOutRowTypeInfo(sideJoinFieldInfo, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        CRowTypeInfo cRowTypeInfo = new &#x27;
                           &#x27;CRowTypeInfo(sideOutTypeInfo);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;dsOut.getTransformation().setOutputType(cRowTypeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String targetTableName = &#x27;
                           &#x27;joinInfo.getNewTableName();\n&#x27;
                           &#x27;        String targetTableAlias = &#x27;
                           &#x27;joinInfo.getNewTableAlias();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        FieldReplaceInfo replaceInfo = new &#x27;
                           &#x27;FieldReplaceInfo();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setMappingTable(mappingTable);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setTargetTableName(targetTableName);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setTargetTableAlias(targetTableAlias);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                           &#x27;        for(FieldReplaceInfo tmp : &#x27;
                           &#x27;replaceInfoList){\n&#x27;
                           &#x27;            &#x27;
                           &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                           &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(joinInfo.getNewTableName())){\n&#x27;
                           &#x27;            Table joinTable = &#x27;
                           &#x27;tableEnv.fromDataStream(dsOut);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;tableEnv.registerTable(joinInfo.getNewTableName(), &#x27;
                           &#x27;joinTable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;localTableCache.put(joinInfo.getNewTableName(), &#x27;
                           &#x27;joinTable);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void exec(String sql,\n&#x27;
                         &#x27;                     Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                     StreamTableEnvironment &#x27;
                         &#x27;tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache,\n&#x27;
                         &#x27;                     StreamQueryConfig queryConfig,\n&#x27;
                         &#x27;                     &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void exec(String sql, Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache, StreamQueryConfig queryConfig, &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                           &#x27;throws Exception {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;public void exec(String sql,\n&#x27;
                         &#x27;                     Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                     StreamTableEnvironment &#x27;
                         &#x27;tableEnv,\n&#x27;
                         &#x27;                     Map&lt;String, Table&gt; tableCache,\n&#x27;
                         &#x27;                     StreamQueryConfig queryConfig,\n&#x27;
                         &#x27;                     &#x27;
                         &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                         &#x27;throws Exception {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void exec(String sql, Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                     Map&lt;String, Table&gt; &#x27;
                           &#x27;tableCache, StreamQueryConfig queryConfig, &#x27;
                           &#x27;CreateTmpTableParser.SqlParserResult createView) &#x27;
                           &#x27;throws Exception {\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                System.out.println(&quot;----------exec &#x27;
                         &#x27;join info----------&quot;);\n&#x27;
                         &#x27;                &#x27;
                         &#x27;System.out.println(pollObj.toString());\n&#x27;
                         &#x27;                joinFun(pollObj, localTableCache, &#x27;
                         &#x27;sideTableMap, tableEnv);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                LOG.info(&quot;----------exec join &#x27;
                           &#x27;info----------\\n{}&quot;, pollObj.toString());\n&#x27;
                           &#x27;                preIsSideJoin = true;\n&#x27;
                           &#x27;                joinFun(pollObj, localTableCache, &#x27;
                           &#x27;sideTableMap, tableEnv, replaceInfoList);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public AliasInfo parseASNode(SqlNode sqlNode) &#x27;
                         &#x27;throws SqlParseException {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    /**\n&#x27;
                           &#x27;     * 添加字段别名\n&#x27;
                           &#x27;     * @param pollSqlNode\n&#x27;
                           &#x27;     * @param fieldList\n&#x27;
                           &#x27;     * @param mappingTable\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    private void addAliasForFieldNode(SqlNode &#x27;
                           &#x27;pollSqlNode, List&lt;String&gt; fieldList, &#x27;
                           &#x27;HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable) {\n&#x27;
                           &#x27;        SqlKind sqlKind = pollSqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode source = ((SqlInsert) &#x27;
                           &#x27;pollSqlNode).getSource();\n&#x27;
                           &#x27;                addAliasForFieldNode(source, &#x27;
                           &#x27;fieldList, mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                &#x27;
                           &#x27;addAliasForFieldNode(((SqlBasicCall) &#x27;
                           &#x27;pollSqlNode).getOperands()[0], fieldList, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNodeList selectList = &#x27;
                           &#x27;((SqlSelect) pollSqlNode).getSelectList();\n&#x27;
                           &#x27;                selectList.getList().forEach(node &#x27;
                           &#x27;-&gt; {\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        // save real field\n&#x27;
                           &#x27;                        String fieldName = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(!fieldName.endsWith(&quot;0&quot;) || &#x27;
                           &#x27;fieldName.endsWith(&quot;0&quot;) &amp;&amp; &#x27;
                           &#x27;mappingTable.columnMap().containsKey(fieldName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;fieldList.add(fieldName);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;selectList.getList().size(); i++) {\n&#x27;
                           &#x27;                    SqlNode node = &#x27;
                           &#x27;selectList.get(i);\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        String name = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        // avoid real field pv0 &#x27;
                           &#x27;convert pv\n&#x27;
                           &#x27;                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  &#x27;
                           &#x27;!fieldList.contains(name) &amp;&amp; &#x27;
                           &#x27;!fieldList.contains(name.substring(0, &#x27;
                           &#x27;name.length() - 1))) {\n&#x27;
                           &#x27;                            SqlOperator operator = &#x27;
                           &#x27;new SqlAsOperator();\n&#x27;
                           &#x27;                            SqlParserPos &#x27;
                           &#x27;sqlParserPos = new SqlParserPos(0, 0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlIdentifier &#x27;
                           &#x27;sqlIdentifierAlias = new &#x27;
                           &#x27;SqlIdentifier(name.substring(0, name.length() - &#x27;
                           &#x27;1), null, sqlParserPos);\n&#x27;
                           &#x27;                            SqlNode[] sqlNodes = &#x27;
                           &#x27;new SqlNode[2];\n&#x27;
                           &#x27;                            sqlNodes[0] = &#x27;
                           &#x27;sqlIdentifier;\n&#x27;
                           &#x27;                            sqlNodes[1] = &#x27;
                           &#x27;sqlIdentifierAlias;\n&#x27;
                           &#x27;                            SqlBasicCall &#x27;
                           &#x27;sqlBasicCall = new SqlBasicCall(operator, &#x27;
                           &#x27;sqlNodes, sqlParserPos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            selectList.set(i, &#x27;
                           &#x27;sqlBasicCall);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public AliasInfo parseAsNode(SqlNode sqlNode) &#x27;
                           &#x27;throws SqlParseException {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void addAliasForFieldNode(SqlNode &#x27;
                           &#x27;pollSqlNode, List&lt;String&gt; fieldList, &#x27;
                           &#x27;HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable) {\n&#x27;
                           &#x27;        SqlKind sqlKind = pollSqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode source = ((SqlInsert) &#x27;
                           &#x27;pollSqlNode).getSource();\n&#x27;
                           &#x27;                addAliasForFieldNode(source, &#x27;
                           &#x27;fieldList, mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                &#x27;
                           &#x27;addAliasForFieldNode(((SqlBasicCall) &#x27;
                           &#x27;pollSqlNode).getOperands()[0], fieldList, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNodeList selectList = &#x27;
                           &#x27;((SqlSelect) pollSqlNode).getSelectList();\n&#x27;
                           &#x27;                selectList.getList().forEach(node &#x27;
                           &#x27;-&gt; {\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        // save real field\n&#x27;
                           &#x27;                        String fieldName = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(!fieldName.endsWith(&quot;0&quot;) || &#x27;
                           &#x27;fieldName.endsWith(&quot;0&quot;) &amp;&amp; &#x27;
                           &#x27;mappingTable.columnMap().containsKey(fieldName)) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;fieldList.add(fieldName);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                for (int i = 0; i &lt; &#x27;
                           &#x27;selectList.getList().size(); i++) {\n&#x27;
                           &#x27;                    SqlNode node = &#x27;
                           &#x27;selectList.get(i);\n&#x27;
                           &#x27;                    if (node.getKind() == &#x27;
                           &#x27;IDENTIFIER) {\n&#x27;
                           &#x27;                        SqlIdentifier &#x27;
                           &#x27;sqlIdentifier = (SqlIdentifier) node;\n&#x27;
                           &#x27;                        if &#x27;
                           &#x27;(sqlIdentifier.names.size() == 1) {\n&#x27;
                           &#x27;                            return;\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        String name = &#x27;
                           &#x27;sqlIdentifier.names.get(1);\n&#x27;
                           &#x27;                        // avoid real field pv0 &#x27;
                           &#x27;convert pv\n&#x27;
                           &#x27;                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  &#x27;
                           &#x27;!fieldList.contains(name) &amp;&amp; &#x27;
                           &#x27;!fieldList.contains(name.substring(0, &#x27;
                           &#x27;name.length() - 1))) {\n&#x27;
                           &#x27;                            SqlOperator operator = &#x27;
                           &#x27;new SqlAsOperator();\n&#x27;
                           &#x27;                            SqlParserPos &#x27;
                           &#x27;sqlParserPos = new SqlParserPos(0, 0);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlIdentifier &#x27;
                           &#x27;sqlIdentifierAlias = new &#x27;
                           &#x27;SqlIdentifier(name.substring(0, name.length() - &#x27;
                           &#x27;1), null, sqlParserPos);\n&#x27;
                           &#x27;                            SqlNode[] sqlNodes = &#x27;
                           &#x27;new SqlNode[2];\n&#x27;
                           &#x27;                            sqlNodes[0] = &#x27;
                           &#x27;sqlIdentifier;\n&#x27;
                           &#x27;                            sqlNodes[1] = &#x27;
                           &#x27;sqlIdentifierAlias;\n&#x27;
                           &#x27;                            SqlBasicCall &#x27;
                           &#x27;sqlBasicCall = new SqlBasicCall(operator, &#x27;
                           &#x27;sqlNodes, sqlParserPos);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            selectList.set(i, &#x27;
                           &#x27;sqlBasicCall);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                        List&lt;SqlNode&gt; &#x27;
                           &#x27;newSelectNodeList = Lists.newArrayList();\n&#x27;
                           &#x27;                        for( int i=0; &#x27;
                           &#x27;i&lt;sqlSelectList.getList().size(); i++){\n&#x27;
                           &#x27;                            SqlNode selectNode = &#x27;
                           &#x27;sqlSelectList.getList().get(i);\n&#x27;
                           &#x27;                            //特殊处理 isStar的标识\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;if(selectNode.getKind() == IDENTIFIER &amp;&amp; &#x27;
                           &#x27;((SqlIdentifier) selectNode).isStar()){\n&#x27;
                           &#x27;                                List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceNodeList = &#x27;
                           &#x27;replaceSelectStarFieldName(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;newSelectNodeList.addAll(replaceNodeList);\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(selectNode, replaceInfo);\n&#x27;
                           &#x27;                            if(replaceNode == &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            //sqlSelectList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;newSelectNodeList.add(replaceNode);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        SqlNodeList newSelectList &#x27;
                           &#x27;= new SqlNodeList(newSelectNodeList, &#x27;
                           &#x27;sqlSelectList.getParserPosition());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sqlSelect.setSelectList(newSelectList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //where\n&#x27;
                           &#x27;                        if(whereNode != null){\n&#x27;
                           &#x27;                            SqlNode[] sqlNodeList &#x27;
                           &#x27;= ((SqlBasicCall)whereNode).getOperands();\n&#x27;
                           &#x27;                            for(int i =0; &#x27;
                           &#x27;i&lt;sqlNodeList.length; i++) {\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;whereSqlNode = sqlNodeList[i];\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(whereSqlNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlNodeList[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        if(sqlGroup != null &amp;&amp; &#x27;
                           &#x27;CollectionUtils.isNotEmpty(sqlGroup.getList())){\n&#x27;
                           &#x27;                            for( int i=0; &#x27;
                           &#x27;i&lt;sqlGroup.getList().size(); i++){\n&#x27;
                           &#x27;                                SqlNode selectNode &#x27;
                           &#x27;= sqlGroup.getList().get(i);\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlGroup.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;---not deal type:&quot; + sqlNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case UNION:\n&#x27;
                           &#x27;                SqlNode unionLeft = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                SqlNode unionRight = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[1];\n&#x27;
                           &#x27;                replaceFieldName(unionLeft, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                replaceFieldName(unionRight, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case ORDER_BY:\n&#x27;
                           &#x27;                SqlOrderBy sqlOrderBy  = &#x27;
                           &#x27;(SqlOrderBy) sqlNode;\n&#x27;
                           &#x27;                replaceFieldName(sqlOrderBy.query, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                SqlNodeList orderFiledList = &#x27;
                           &#x27;sqlOrderBy.orderList;\n&#x27;
                           &#x27;                for (int i=0 &#x27;
                           &#x27;;i&lt;orderFiledList.size();i++) {\n&#x27;
                           &#x27;                    SqlNode replaceNode = &#x27;
                           &#x27;replaceOrderByTableName(orderFiledList.get(i), &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                    orderFiledList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode &#x27;
                           &#x27;replaceOrderByTableName(SqlNode orderNode, String &#x27;
                           &#x27;tableAlias) {\n&#x27;
                           &#x27;        if(orderNode.getKind() == IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) orderNode;\n&#x27;
                           &#x27;            if (sqlIdentifier.names.size() == 1) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                return orderNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return sqlIdentifier.setName(0, &#x27;
                           &#x27;tableAlias);\n&#x27;
                           &#x27;        } else if (orderNode instanceof  &#x27;
                           &#x27;SqlBasicCall) {\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) orderNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperandList().size(); i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperandList().get(i);\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceOrderByTableName(sqlNode , tableAlias);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return sqlBasicCall;\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            return orderNode;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode replaceNodeInfo(SqlNode &#x27;
                           &#x27;groupNode, FieldReplaceInfo replaceInfo){\n&#x27;
                           &#x27;        if(groupNode.getKind() == IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) groupNode;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return sqlIdentifier;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if(mappingFieldName == null){\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + &#x27;
                           &#x27;sqlIdentifier.toString() );\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            return sqlIdentifier.setName(1, &#x27;
                           &#x27;mappingFieldName);\n&#x27;
                           &#x27;        }else if(groupNode instanceof  &#x27;
                           &#x27;SqlBasicCall){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) groupNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperandList().size(); i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperandList().get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return sqlBasicCall;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            return groupNode;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public SqlNode &#x27;
                           &#x27;filterNodeWithTargetName(SqlNode sqlNode, String &#x27;
                           &#x27;targetTableName) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind){\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNode fromNode = &#x27;
                           &#x27;((SqlSelect)sqlNode).getFrom();\n&#x27;
                           &#x27;                if(fromNode.getKind() == AS &amp;&amp; &#x27;
                           &#x27;((SqlBasicCall)fromNode).getOperands()[0].getKind() &#x27;
                           &#x27;== IDENTIFIER){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){\n&#x27;
                           &#x27;                        return sqlNode;\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        return null;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return &#x27;
                           &#x27;filterNodeWithTargetName(fromNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode childNode = &#x27;
                           &#x27;((SqlBasicCall)sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;filterNodeWithTargetName(childNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;            case JOIN:\n&#x27;
                           &#x27;                SqlNode leftNode = &#x27;
                           &#x27;((SqlJoin)sqlNode).getLeft();\n&#x27;
                           &#x27;                SqlNode rightNode =  &#x27;
                           &#x27;((SqlJoin)sqlNode).getRight();\n&#x27;
                           &#x27;                SqlNode leftReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(leftNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                SqlNode rightReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(rightNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(leftReturnNode != null) {\n&#x27;
                           &#x27;                    return leftReturnNode;\n&#x27;
                           &#x27;                }else if(rightReturnNode != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                    return rightReturnNode;\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return null;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public SqlNode filterNodeWithTargetName(SqlNode &#x27;
                           &#x27;sqlNode, String targetTableName) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind){\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlNode fromNode = &#x27;
                           &#x27;((SqlSelect)sqlNode).getFrom();\n&#x27;
                           &#x27;                if(fromNode.getKind() == AS &amp;&amp; &#x27;
                           &#x27;((SqlBasicCall)fromNode).getOperands()[0].getKind() &#x27;
                           &#x27;== IDENTIFIER){\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){\n&#x27;
                           &#x27;                        return sqlNode;\n&#x27;
                           &#x27;                    }else{\n&#x27;
                           &#x27;                        return null;\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return &#x27;
                           &#x27;filterNodeWithTargetName(fromNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode childNode = &#x27;
                           &#x27;((SqlBasicCall)sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;filterNodeWithTargetName(childNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;            case JOIN:\n&#x27;
                           &#x27;                SqlNode leftNode = &#x27;
                           &#x27;((SqlJoin)sqlNode).getLeft();\n&#x27;
                           &#x27;                SqlNode rightNode =  &#x27;
                           &#x27;((SqlJoin)sqlNode).getRight();\n&#x27;
                           &#x27;                SqlNode leftReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(leftNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;                SqlNode rightReturnNode = &#x27;
                           &#x27;filterNodeWithTargetName(rightNode, &#x27;
                           &#x27;targetTableName);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(leftReturnNode != null) {\n&#x27;
                           &#x27;                    return leftReturnNode;\n&#x27;
                           &#x27;                }else if(rightReturnNode != &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                    return rightReturnNode;\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    return null;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return null;\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceSelectStarFieldName(SqlNode selectNode, &#x27;
                           &#x27;FieldReplaceInfo replaceInfo){\n&#x27;
                           &#x27;        SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;        List&lt;SqlNode&gt; sqlNodes = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;        if(sqlIdentifier.isStar()){//处理 [* or &#x27;
                           &#x27;table.*]\n&#x27;
                           &#x27;            int identifierSize = &#x27;
                           &#x27;sqlIdentifier.names.size();\n&#x27;
                           &#x27;            Collection&lt;String&gt; columns = null;\n&#x27;
                           &#x27;            if(identifierSize == 1){\n&#x27;
                           &#x27;                columns = &#x27;
                           &#x27;replaceInfo.getMappingTable().values();\n&#x27;
                           &#x27;            }else{\n&#x27;
                           &#x27;                columns = &#x27;
                           &#x27;replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(String colAlias : columns){\n&#x27;
                           &#x27;                SqlParserPos sqlParserPos = new &#x27;
                           &#x27;SqlParserPos(0, 0);\n&#x27;
                           &#x27;                List&lt;String&gt; columnInfo = &#x27;
                           &#x27;Lists.newArrayList();\n&#x27;
                           &#x27;                &#x27;
                           &#x27;columnInfo.add(replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                columnInfo.add(colAlias);\n&#x27;
                           &#x27;                SqlIdentifier sqlIdentifierAlias = &#x27;
                           &#x27;new SqlIdentifier(columnInfo, sqlParserPos);\n&#x27;
                           &#x27;                sqlNodes.add(sqlIdentifierAlias);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return sqlNodes;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;is not a &#x27;
                           &#x27;star select field.&quot; + selectNode);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private SqlNode replaceSelectFieldName(SqlNode &#x27;
                           &#x27;selectNode, FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        if (selectNode.getKind() == AS) {\n&#x27;
                           &#x27;            SqlNode leftNode = ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0];\n&#x27;
                           &#x27;            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(leftNode, replaceInfo);\n&#x27;
                           &#x27;            if (replaceNode != null) {\n&#x27;
                           &#x27;                ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0] = replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == &#x27;
                           &#x27;IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return selectNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            //Same level mappingTable\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if (mappingFieldName == null) {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + selectNode.toString() &#x27;
                           &#x27;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(1, mappingFieldName);\n&#x27;
                           &#x27;            return sqlIdentifier;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == LITERAL &#x27;
                           &#x27;|| selectNode.getKind() == LITERAL_CHAIN){//字面含义\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(  &#x27;
                           &#x27;AGGREGATE.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;AVG_AGG_FUNCTIONS.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;COMPARISON.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;OTHER_FUNCTION\n&#x27;
                           &#x27;                || selectNode.getKind() == DIVIDE\n&#x27;
                           &#x27;                || selectNode.getKind() == CAST\n&#x27;
                           &#x27;                || selectNode.getKind() == TRIM\n&#x27;
                           &#x27;                || selectNode.getKind() == TIMES\n&#x27;
                           &#x27;                || selectNode.getKind() == PLUS\n&#x27;
                           &#x27;                || selectNode.getKind() == NOT_IN\n&#x27;
                           &#x27;                || selectNode.getKind() == OR\n&#x27;
                           &#x27;                || selectNode.getKind() == AND\n&#x27;
                           &#x27;                || selectNode.getKind() == MINUS\n&#x27;
                           &#x27;                || selectNode.getKind() == TUMBLE\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_END\n&#x27;
                           &#x27;                || selectNode.getKind() == HOP\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;BETWEEN\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NOT_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;CONTAINS\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_ADD\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_DIFF\n&#x27;
                           &#x27;                || selectNode.getKind() == LIKE\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                ){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) selectNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperands().length; i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperands()[i];\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlLiteral){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlDataTypeSpec){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                if(replaceNode == null){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == CASE){\n&#x27;
                           &#x27;            SqlCase sqlCase = (SqlCase) &#x27;
                           &#x27;selectNode;\n&#x27;
                           &#x27;            SqlNodeList whenOperands = &#x27;
                           &#x27;sqlCase.getWhenOperands();\n&#x27;
                           &#x27;            SqlNodeList thenOperands = &#x27;
                           &#x27;sqlCase.getThenOperands();\n&#x27;
                           &#x27;            SqlNode elseNode = &#x27;
                           &#x27;sqlCase.getElseOperand();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;whenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;whenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    whenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;thenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;thenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    thenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            ((SqlCase) selectNode).setOperand(3, &#x27;
                           &#x27;replaceSelectFieldName(elseNode, replaceInfo));\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == OTHER){\n&#x27;
                           &#x27;            //不处理\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support node &#x27;
                           &#x27;kind of %s to replace name now.&quot;, &#x27;
                           &#x27;selectNode.getKind()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private SqlNode replaceSelectFieldName(SqlNode &#x27;
                           &#x27;selectNode, FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        if (selectNode.getKind() == AS) {\n&#x27;
                           &#x27;            SqlNode leftNode = ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0];\n&#x27;
                           &#x27;            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(leftNode, replaceInfo);\n&#x27;
                           &#x27;            if (replaceNode != null) {\n&#x27;
                           &#x27;                ((SqlBasicCall) &#x27;
                           &#x27;selectNode).getOperands()[0] = replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == &#x27;
                           &#x27;IDENTIFIER){\n&#x27;
                           &#x27;            SqlIdentifier sqlIdentifier = &#x27;
                           &#x27;(SqlIdentifier) selectNode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            if(sqlIdentifier.names.size() == 1){\n&#x27;
                           &#x27;                return selectNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            //Same level mappingTable\n&#x27;
                           &#x27;            String mappingFieldName = &#x27;
                           &#x27;replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), &#x27;
                           &#x27;sqlIdentifier.getComponent(1).getSimple());\n&#x27;
                           &#x27;            if (mappingFieldName == null) {\n&#x27;
                           &#x27;                throw new RuntimeException(&quot;can\&#x27;t &#x27;
                           &#x27;find mapping fieldName:&quot; + selectNode.toString() &#x27;
                           &#x27;);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(0, &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;            sqlIdentifier = &#x27;
                           &#x27;sqlIdentifier.setName(1, mappingFieldName);\n&#x27;
                           &#x27;            return sqlIdentifier;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == LITERAL &#x27;
                           &#x27;|| selectNode.getKind() == LITERAL_CHAIN){//字面含义\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(  &#x27;
                           &#x27;AGGREGATE.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;AVG_AGG_FUNCTIONS.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || &#x27;
                           &#x27;COMPARISON.contains(selectNode.getKind())\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;OTHER_FUNCTION\n&#x27;
                           &#x27;                || selectNode.getKind() == DIVIDE\n&#x27;
                           &#x27;                || selectNode.getKind() == CAST\n&#x27;
                           &#x27;                || selectNode.getKind() == TRIM\n&#x27;
                           &#x27;                || selectNode.getKind() == TIMES\n&#x27;
                           &#x27;                || selectNode.getKind() == PLUS\n&#x27;
                           &#x27;                || selectNode.getKind() == NOT_IN\n&#x27;
                           &#x27;                || selectNode.getKind() == OR\n&#x27;
                           &#x27;                || selectNode.getKind() == AND\n&#x27;
                           &#x27;                || selectNode.getKind() == MINUS\n&#x27;
                           &#x27;                || selectNode.getKind() == TUMBLE\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TUMBLE_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;SESSION_END\n&#x27;
                           &#x27;                || selectNode.getKind() == HOP\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_START\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;HOP_END\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;BETWEEN\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;IS_NOT_NULL\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;CONTAINS\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_ADD\n&#x27;
                           &#x27;                || selectNode.getKind() == &#x27;
                           &#x27;TIMESTAMP_DIFF\n&#x27;
                           &#x27;                || selectNode.getKind() == LIKE\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                ){\n&#x27;
                           &#x27;            SqlBasicCall sqlBasicCall = &#x27;
                           &#x27;(SqlBasicCall) selectNode;\n&#x27;
                           &#x27;            for(int i=0; &#x27;
                           &#x27;i&lt;sqlBasicCall.getOperands().length; i++){\n&#x27;
                           &#x27;                SqlNode sqlNode = &#x27;
                           &#x27;sqlBasicCall.getOperands()[i];\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlLiteral){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                if(sqlNode instanceof &#x27;
                           &#x27;SqlDataTypeSpec){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(sqlNode, replaceInfo);\n&#x27;
                           &#x27;                if(replaceNode == null){\n&#x27;
                           &#x27;                    continue;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                sqlBasicCall.getOperands()[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == CASE){\n&#x27;
                           &#x27;            SqlCase sqlCase = (SqlCase) &#x27;
                           &#x27;selectNode;\n&#x27;
                           &#x27;            SqlNodeList whenOperands = &#x27;
                           &#x27;sqlCase.getWhenOperands();\n&#x27;
                           &#x27;            SqlNodeList thenOperands = &#x27;
                           &#x27;sqlCase.getThenOperands();\n&#x27;
                           &#x27;            SqlNode elseNode = &#x27;
                           &#x27;sqlCase.getElseOperand();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;whenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;whenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    whenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            for(int i=0; i&lt;thenOperands.size(); &#x27;
                           &#x27;i++){\n&#x27;
                           &#x27;                SqlNode oneOperand = &#x27;
                           &#x27;thenOperands.get(i);\n&#x27;
                           &#x27;                SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(oneOperand, replaceInfo);\n&#x27;
                           &#x27;                if (replaceNode != null) {\n&#x27;
                           &#x27;                    thenOperands.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            ((SqlCase) selectNode).setOperand(3, &#x27;
                           &#x27;replaceSelectFieldName(elseNode, replaceInfo));\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else if(selectNode.getKind() == OTHER){\n&#x27;
                           &#x27;            //不处理\n&#x27;
                           &#x27;            return selectNode;\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;RuntimeException(String.format(&quot;not support node &#x27;
                           &#x27;kind of %s to replace name now.&quot;, &#x27;
                           &#x27;selectNode.getKind()));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private void joinFun(Object pollObj,\n&#x27;
                         &#x27;                         Map&lt;String, Table&gt; &#x27;
                         &#x27;localTableCache,\n&#x27;
                         &#x27;                         Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                         StreamTableEnvironment &#x27;
                         &#x27;tableEnv) throws Exception{\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private void joinFun(Object pollObj, &#x27;
                           &#x27;Map&lt;String, Table&gt; localTableCache,\n&#x27;
                           &#x27;                         Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                         List&lt;FieldReplaceInfo&gt; &#x27;
                           &#x27;replaceInfoList) throws Exception{\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    private void joinFun(Object pollObj,\n&#x27;
                         &#x27;                         Map&lt;String, Table&gt; &#x27;
                         &#x27;localTableCache,\n&#x27;
                         &#x27;                         Map&lt;String, SideTableInfo&gt; &#x27;
                         &#x27;sideTableMap,\n&#x27;
                         &#x27;                         StreamTableEnvironment &#x27;
                         &#x27;tableEnv) throws Exception{\n&#x27;
                         &#x27;        JoinInfo joinInfo = (JoinInfo) pollObj;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        JoinScope joinScope = new JoinScope();\n&#x27;
                         &#x27;        JoinScope.ScopeChild leftScopeChild = new &#x27;
                         &#x27;JoinScope.ScopeChild();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setAlias(joinInfo.getLeftTableAlias());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setTableName(joinInfo.getLeftTableName());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        Table leftTable = &#x27;
                         &#x27;getTableFromCache(localTableCache, &#x27;
                         &#x27;joinInfo.getLeftTableAlias(), &#x27;
                         &#x27;joinInfo.getLeftTableName());\n&#x27;
                         &#x27;        RowTypeInfo leftTypeInfo = new &#x27;
                         &#x27;RowTypeInfo(leftTable.getSchema().getTypes(), &#x27;
                         &#x27;leftTable.getSchema().getColumnNames());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;leftScopeChild.setRowTypeInfo(leftTypeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        JoinScope.ScopeChild rightScopeChild = new &#x27;
                         &#x27;JoinScope.ScopeChild();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setAlias(joinInfo.getRightTableAlias());\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setTableName(joinInfo.getRightTableName());\n&#x27;
                         &#x27;        SideTableInfo sideTableInfo = &#x27;
                         &#x27;sideTableMap.get(joinInfo.getRightTableName());\n&#x27;
                         &#x27;        if(sideTableInfo == null){\n&#x27;
                         &#x27;            sideTableInfo = &#x27;
                         &#x27;sideTableMap.get(joinInfo.getRightTableAlias());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if(sideTableInfo == null){\n&#x27;
                         &#x27;            throw new RuntimeException(&quot;can\&#x27;t not &#x27;
                         &#x27;find side table:&quot; + joinInfo.getRightTableName());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;//        &#x27;
                         &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                         &#x27;//            throw new RuntimeException(&quot;ON &#x27;
                         &#x27;condition must contain all equal fields!!!&quot;);\n&#x27;
                         &#x27;//        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        joinScope.addScope(leftScopeChild);\n&#x27;
                         &#x27;        joinScope.addScope(rightScopeChild);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                         &#x27;mappingTable = ((JoinInfo) &#x27;
                         &#x27;pollObj).getTableFieldRef();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //获取两个表的所有字段\n&#x27;
                         &#x27;        List&lt;FieldInfo&gt; sideJoinFieldInfo = &#x27;
                         &#x27;ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), &#x27;
                         &#x27;joinScope, true);\n&#x27;
                         &#x27;        //通过join的查询字段信息过滤出需要的字段信息\n&#x27;
                         &#x27;        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; &#x27;
                         &#x27;mappingTable.get(tmpFieldInfo.getTable(), &#x27;
                         &#x27;tmpFieldInfo.getFieldName()) == null);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String leftTableAlias = &#x27;
                         &#x27;joinInfo.getLeftTableAlias();\n&#x27;
                         &#x27;        Table targetTable = &#x27;
                         &#x27;localTableCache.get(leftTableAlias);\n&#x27;
                         &#x27;        if(targetTable == null){\n&#x27;
                         &#x27;            targetTable = &#x27;
                         &#x27;localTableCache.get(joinInfo.getLeftTableName());\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        RowTypeInfo typeInfo = new &#x27;
                         &#x27;RowTypeInfo(targetTable.getSchema().getTypes(), &#x27;
                         &#x27;targetTable.getSchema().getColumnNames());\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        DataStream&lt;CRow&gt; adaptStream = &#x27;
                         &#x27;tableEnv.toRetractStream(targetTable, &#x27;
                         &#x27;org.apache.flink.types.Row.class)\n&#x27;
                         &#x27;                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                    return new CRow(tp2.f1, &#x27;
                         &#x27;tp2.f0);\n&#x27;
                         &#x27;                }).returns(CRow.class);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        //join side table before keyby ===&gt; Reducing &#x27;
                         &#x27;the size of each dimension table cache of async\n&#x27;
                         &#x27;        if (sideTableInfo.isPartitionedJoin()) {\n&#x27;
                         &#x27;            List&lt;String&gt; leftJoinColList = &#x27;
                         &#x27;getConditionFields(joinInfo.getCondition(), &#x27;
                         &#x27;joinInfo.getLeftTableAlias(), sideTableInfo);\n&#x27;
                         &#x27;            List&lt;String&gt; fieldNames = &#x27;
                         &#x27;Arrays.asList(targetTable.getSchema().getFieldNames());\n&#x27;
                         &#x27;            int[] keyIndex = &#x27;
                         &#x27;leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();\n&#x27;
                         &#x27;            adaptStream = adaptStream.keyBy(new &#x27;
                         &#x27;CRowKeySelector(keyIndex, &#x27;
                         &#x27;projectedTypeInfo(keyIndex, &#x27;
                         &#x27;targetTable.getSchema())));\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        DataStream&lt;CRow&gt; dsOut = null;\n&#x27;
                         &#x27;        &#x27;
                         &#x27;if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                         &#x27;            dsOut = &#x27;
                         &#x27;SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, &#x27;
                         &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                         &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                         &#x27;sideTableInfo);\n&#x27;
                         &#x27;        }else{\n&#x27;
                         &#x27;            dsOut = &#x27;
                         &#x27;SideAsyncOperator.getSideJoinDataStream(adaptStream, &#x27;
                         &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                         &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                         &#x27;sideTableInfo);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        RowTypeInfo sideOutTypeInfo = &#x27;
                         &#x27;buildOutRowTypeInfo(sideJoinFieldInfo, &#x27;
                         &#x27;mappingTable);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        CRowTypeInfo cRowTypeInfo = new &#x27;
                         &#x27;CRowTypeInfo(sideOutTypeInfo);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;dsOut.getTransformation().setOutputType(cRowTypeInfo);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        String targetTableName = &#x27;
                         &#x27;joinInfo.getNewTableName();\n&#x27;
                         &#x27;        String targetTableAlias = &#x27;
                         &#x27;joinInfo.getNewTableAlias();\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        FieldReplaceInfo replaceInfo = new &#x27;
                         &#x27;FieldReplaceInfo();\n&#x27;
                         &#x27;        replaceInfo.setMappingTable(mappingTable);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;replaceInfo.setTargetTableName(targetTableName);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;replaceInfo.setTargetTableAlias(targetTableAlias);\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(!tableEnv.isRegistered(joinInfo.getNewTableName())){\n&#x27;
                         &#x27;            Table joinTable = &#x27;
                         &#x27;tableEnv.fromDataStream(dsOut);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;tableEnv.registerTable(joinInfo.getNewTableName(), &#x27;
                         &#x27;joinTable);\n&#x27;
                         &#x27;            &#x27;
                         &#x27;localTableCache.put(joinInfo.getNewTableName(), &#x27;
                         &#x27;joinTable);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    private void joinFun(Object pollObj, &#x27;
                           &#x27;Map&lt;String, Table&gt; localTableCache,\n&#x27;
                           &#x27;                         Map&lt;String, &#x27;
                           &#x27;AbstractSideTableInfo&gt; sideTableMap, &#x27;
                           &#x27;StreamTableEnvironment tableEnv,\n&#x27;
                           &#x27;                         List&lt;FieldReplaceInfo&gt; &#x27;
                           &#x27;replaceInfoList) throws Exception{\n&#x27;
                           &#x27;        JoinInfo joinInfo = (JoinInfo) pollObj;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        JoinScope joinScope = new JoinScope();\n&#x27;
                           &#x27;        JoinScope.ScopeChild leftScopeChild = new &#x27;
                           &#x27;JoinScope.ScopeChild();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setAlias(joinInfo.getLeftTableAlias());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setTableName(joinInfo.getLeftTableName());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        SqlKind sqlKind = &#x27;
                           &#x27;joinInfo.getLeftNode().getKind();\n&#x27;
                           &#x27;        if(sqlKind == AS){\n&#x27;
                           &#x27;            dealAsSourceTable(tableEnv, &#x27;
                           &#x27;joinInfo.getLeftNode(), localTableCache, &#x27;
                           &#x27;replaceInfoList);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Table leftTable = &#x27;
                           &#x27;getTableFromCache(localTableCache, &#x27;
                           &#x27;joinInfo.getLeftTableAlias(), &#x27;
                           &#x27;joinInfo.getLeftTableName());\n&#x27;
                           &#x27;        RowTypeInfo leftTypeInfo = new &#x27;
                           &#x27;RowTypeInfo(leftTable.getSchema().getTypes(), &#x27;
                           &#x27;leftTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;leftScopeChild.setRowTypeInfo(leftTypeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        JoinScope.ScopeChild rightScopeChild = new &#x27;
                           &#x27;JoinScope.ScopeChild();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setAlias(joinInfo.getRightTableAlias());\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setTableName(joinInfo.getRightTableName());\n&#x27;
                           &#x27;        AbstractSideTableInfo sideTableInfo = &#x27;
                           &#x27;sideTableMap.get(joinInfo.getRightTableName());\n&#x27;
                           &#x27;        if(sideTableInfo == null){\n&#x27;
                           &#x27;            sideTableInfo = &#x27;
                           &#x27;sideTableMap.get(joinInfo.getRightTableAlias());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if(sideTableInfo == null){\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;can\&#x27;t not &#x27;
                           &#x27;find side table:&quot; + &#x27;
                           &#x27;joinInfo.getRightTableName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;//        &#x27;
                           &#x27;if(!checkJoinCondition(joinInfo.getCondition(), &#x27;
                           &#x27;joinInfo.getRightTableAlias(), sideTableInfo)){\n&#x27;
                           &#x27;//            throw new RuntimeException(&quot;ON &#x27;
                           &#x27;condition must contain all equal fields!!!&quot;);\n&#x27;
                           &#x27;//        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        joinScope.addScope(leftScopeChild);\n&#x27;
                           &#x27;        joinScope.addScope(rightScopeChild);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //获取两个表的所有字段\n&#x27;
                           &#x27;        List&lt;FieldInfo&gt; sideJoinFieldInfo = &#x27;
                           &#x27;ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), &#x27;
                           &#x27;joinScope, true);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String leftTableAlias = &#x27;
                           &#x27;joinInfo.getLeftTableAlias();\n&#x27;
                           &#x27;        Table targetTable = &#x27;
                           &#x27;localTableCache.get(leftTableAlias);\n&#x27;
                           &#x27;        if(targetTable == null){\n&#x27;
                           &#x27;            targetTable = &#x27;
                           &#x27;localTableCache.get(joinInfo.getLeftTableName());\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo typeInfo = new &#x27;
                           &#x27;RowTypeInfo(targetTable.getSchema().getTypes(), &#x27;
                           &#x27;targetTable.getSchema().getColumnNames());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        DataStream&lt;CRow&gt; adaptStream = &#x27;
                           &#x27;tableEnv.toRetractStream(targetTable, &#x27;
                           &#x27;org.apache.flink.types.Row.class)\n&#x27;
                           &#x27;                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                    return new CRow(tp2.f1, &#x27;
                           &#x27;tp2.f0);\n&#x27;
                           &#x27;                }).returns(CRow.class);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //join side table before keyby ===&gt; &#x27;
                           &#x27;Reducing the size of each dimension table cache of &#x27;
                           &#x27;async\n&#x27;
                           &#x27;        if (sideTableInfo.isPartitionedJoin()) {\n&#x27;
                           &#x27;            List&lt;String&gt; leftJoinColList = &#x27;
                           &#x27;getConditionFields(joinInfo.getCondition(), &#x27;
                           &#x27;joinInfo.getLeftTableAlias(), sideTableInfo);\n&#x27;
                           &#x27;            List&lt;String&gt; fieldNames = &#x27;
                           &#x27;Arrays.asList(targetTable.getSchema().getFieldNames());\n&#x27;
                           &#x27;            int[] keyIndex = &#x27;
                           &#x27;leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();\n&#x27;
                           &#x27;            adaptStream = adaptStream.keyBy(new &#x27;
                           &#x27;CRowKeySelector(keyIndex, &#x27;
                           &#x27;projectedTypeInfo(keyIndex, &#x27;
                           &#x27;targetTable.getSchema())));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        DataStream&lt;CRow&gt; dsOut = null;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){\n&#x27;
                           &#x27;            dsOut = &#x27;
                           &#x27;SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, &#x27;
                           &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                           &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                           &#x27;sideTableInfo);\n&#x27;
                           &#x27;        }else{\n&#x27;
                           &#x27;            dsOut = &#x27;
                           &#x27;SideAsyncOperator.getSideJoinDataStream(adaptStream, &#x27;
                           &#x27;sideTableInfo.getType(), localSqlPluginPath, &#x27;
                           &#x27;typeInfo, joinInfo, sideJoinFieldInfo, &#x27;
                           &#x27;sideTableInfo);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime\n&#x27;
                           &#x27;        HashBasedTable&lt;String, String, String&gt; &#x27;
                           &#x27;mappingTable = HashBasedTable.create();\n&#x27;
                           &#x27;        RowTypeInfo sideOutTypeInfo = &#x27;
                           &#x27;buildOutRowTypeInfo(sideJoinFieldInfo, &#x27;
                           &#x27;mappingTable);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        CRowTypeInfo cRowTypeInfo = new &#x27;
                           &#x27;CRowTypeInfo(sideOutTypeInfo);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;dsOut.getTransformation().setOutputType(cRowTypeInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String targetTableName = &#x27;
                           &#x27;joinInfo.getNewTableName();\n&#x27;
                           &#x27;        String targetTableAlias = &#x27;
                           &#x27;joinInfo.getNewTableAlias();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        FieldReplaceInfo replaceInfo = new &#x27;
                           &#x27;FieldReplaceInfo();\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setMappingTable(mappingTable);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setTargetTableName(targetTableName);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;replaceInfo.setTargetTableAlias(targetTableAlias);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点\n&#x27;
                           &#x27;        for(FieldReplaceInfo tmp : &#x27;
                           &#x27;replaceInfoList){\n&#x27;
                           &#x27;            &#x27;
                           &#x27;if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())\n&#x27;
                           &#x27;            &#x27;
                           &#x27;||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){\n&#x27;
                           &#x27;                replaceInfo.setPreNode(tmp);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        replaceInfoList.add(replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(!tableEnv.isRegistered(joinInfo.getNewTableName())){\n&#x27;
                           &#x27;            Table joinTable = &#x27;
                           &#x27;tableEnv.fromDataStream(dsOut);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;tableEnv.registerTable(joinInfo.getNewTableName(), &#x27;
                           &#x27;joinTable);\n&#x27;
                           &#x27;            &#x27;
                           &#x27;localTableCache.put(joinInfo.getNewTableName(), &#x27;
                           &#x27;joinTable);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;private void replaceFieldName(SqlNode sqlNode, &#x27;
                           &#x27;FieldReplaceInfo replaceInfo) {\n&#x27;
                           &#x27;        SqlKind sqlKind = sqlNode.getKind();\n&#x27;
                           &#x27;        switch (sqlKind) {\n&#x27;
                           &#x27;            case INSERT:\n&#x27;
                           &#x27;                SqlNode sqlSource = ((SqlInsert) &#x27;
                           &#x27;sqlNode).getSource();\n&#x27;
                           &#x27;                replaceFieldName(sqlSource, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case AS:\n&#x27;
                           &#x27;                SqlNode asNode = ((SqlBasicCall) &#x27;
                           &#x27;sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                replaceFieldName(asNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case SELECT:\n&#x27;
                           &#x27;                SqlSelect sqlSelect = (SqlSelect) &#x27;
                           &#x27;filterNodeWithTargetName(sqlNode, &#x27;
                           &#x27;replaceInfo.getTargetTableName());\n&#x27;
                           &#x27;                if(sqlSelect == null){\n&#x27;
                           &#x27;                    return;\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                SqlNode sqlSource1 = &#x27;
                           &#x27;sqlSelect.getFrom();\n&#x27;
                           &#x27;                if(sqlSource1.getKind() == AS){\n&#x27;
                           &#x27;                    String tableName = &#x27;
                           &#x27;((SqlBasicCall)sqlSource1).getOperands()[0].toString();\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){\n&#x27;
                           &#x27;                        SqlNodeList sqlSelectList &#x27;
                           &#x27;= sqlSelect.getSelectList();\n&#x27;
                           &#x27;                        SqlNode whereNode = &#x27;
                           &#x27;sqlSelect.getWhere();\n&#x27;
                           &#x27;                        SqlNodeList sqlGroup = &#x27;
                           &#x27;sqlSelect.getGroup();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //TODO 暂时不处理having\n&#x27;
                           &#x27;                        SqlNode sqlHaving = &#x27;
                           &#x27;sqlSelect.getHaving();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        List&lt;SqlNode&gt; &#x27;
                           &#x27;newSelectNodeList = Lists.newArrayList();\n&#x27;
                           &#x27;                        for( int i=0; &#x27;
                           &#x27;i&lt;sqlSelectList.getList().size(); i++){\n&#x27;
                           &#x27;                            SqlNode selectNode = &#x27;
                           &#x27;sqlSelectList.getList().get(i);\n&#x27;
                           &#x27;                            //特殊处理 isStar的标识\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;if(selectNode.getKind() == IDENTIFIER &amp;&amp; &#x27;
                           &#x27;((SqlIdentifier) selectNode).isStar()){\n&#x27;
                           &#x27;                                List&lt;SqlNode&gt; &#x27;
                           &#x27;replaceNodeList = &#x27;
                           &#x27;replaceSelectStarFieldName(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                &#x27;
                           &#x27;newSelectNodeList.addAll(replaceNodeList);\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            SqlNode replaceNode = &#x27;
                           &#x27;replaceSelectFieldName(selectNode, replaceInfo);\n&#x27;
                           &#x27;                            if(replaceNode == &#x27;
                           &#x27;null){\n&#x27;
                           &#x27;                                continue;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                            //sqlSelectList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;newSelectNodeList.add(replaceNode);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        SqlNodeList newSelectList &#x27;
                           &#x27;= new SqlNodeList(newSelectNodeList, &#x27;
                           &#x27;sqlSelectList.getParserPosition());\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;sqlSelect.setSelectList(newSelectList);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                        //where\n&#x27;
                           &#x27;                        if(whereNode != null){\n&#x27;
                           &#x27;                            SqlNode[] sqlNodeList &#x27;
                           &#x27;= ((SqlBasicCall)whereNode).getOperands();\n&#x27;
                           &#x27;                            for(int i =0; &#x27;
                           &#x27;i&lt;sqlNodeList.length; i++) {\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;whereSqlNode = sqlNodeList[i];\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(whereSqlNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlNodeList[i] = &#x27;
                           &#x27;replaceNode;\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        if(sqlGroup != null &amp;&amp; &#x27;
                           &#x27;CollectionUtils.isNotEmpty(sqlGroup.getList())){\n&#x27;
                           &#x27;                            for( int i=0; &#x27;
                           &#x27;i&lt;sqlGroup.getList().size(); i++){\n&#x27;
                           &#x27;                                SqlNode selectNode &#x27;
                           &#x27;= sqlGroup.getList().get(i);\n&#x27;
                           &#x27;                                SqlNode &#x27;
                           &#x27;replaceNode = replaceNodeInfo(selectNode, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                                sqlGroup.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                            }\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                }else{\n&#x27;
                           &#x27;                    throw new &#x27;
                           &#x27;RuntimeException(&quot;---not deal type:&quot; + sqlNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case UNION:\n&#x27;
                           &#x27;                SqlNode unionLeft = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[0];\n&#x27;
                           &#x27;                SqlNode unionRight = &#x27;
                           &#x27;((SqlBasicCall) sqlNode).getOperands()[1];\n&#x27;
                           &#x27;                replaceFieldName(unionLeft, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                replaceFieldName(unionRight, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;            case ORDER_BY:\n&#x27;
                           &#x27;                SqlOrderBy sqlOrderBy  = &#x27;
                           &#x27;(SqlOrderBy) sqlNode;\n&#x27;
                           &#x27;                replaceFieldName(sqlOrderBy.query, &#x27;
                           &#x27;replaceInfo);\n&#x27;
                           &#x27;                SqlNodeList orderFiledList = &#x27;
                           &#x27;sqlOrderBy.orderList;\n&#x27;
                           &#x27;                for (int i=0 &#x27;
                           &#x27;;i&lt;orderFiledList.size();i++) {\n&#x27;
                           &#x27;                    SqlNode replaceNode = &#x27;
                           &#x27;replaceOrderByTableName(orderFiledList.get(i), &#x27;
                           &#x27;replaceInfo.getTargetTableAlias());\n&#x27;
                           &#x27;                    orderFiledList.set(i, &#x27;
                           &#x27;replaceNode);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            default:\n&#x27;
                           &#x27;                break;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        